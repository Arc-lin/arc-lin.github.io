{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/pasted-0.png","path":"images/pasted-0.png","modified":0,"renderable":0},{"_id":"source/images/pasted-1.png","path":"images/pasted-1.png","modified":0,"renderable":0},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/README.md","path":"lib/algolia-instant-search/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/LICENSE","path":"lib/algolia-instant-search/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1518794137941},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1518881681000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1518881681000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1518881681000},{"_id":"themes/next/.DS_Store","hash":"28fd5ef06b5377186db72d96fe273efc08eb9de9","modified":1518882001494},{"_id":"themes/next/.gitignore","hash":"a18c2e83bb20991b899b58e6aeadcb87dd8aa16e","modified":1518881681000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1518881681000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1518881681000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1518881681000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1518881681000},{"_id":"themes/next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1518881681688},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1518881681000},{"_id":"themes/next/crowdin.yml","hash":"fe22a450cc1272b7ac5476e6b33a999f8b8a2034","modified":1518881681000},{"_id":"themes/next/_config.yml","hash":"1450a10b8639d11f144c3d2992de36a7b9fd9bba","modified":1528689868125},{"_id":"themes/next/README.md","hash":"d03f798ea74a366a1be984c2e11ae502372bacae","modified":1518881681688},{"_id":"themes/next/bower.json","hash":"a9d92dc275f2f9d52161f4b58c28707759d20c38","modified":1518881681000},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1518881681000},{"_id":"themes/next/package.json","hash":"09481e19fd0b0f43649e5290750777f78f11a8fa","modified":1518966720000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1518961791376},{"_id":"source/_posts/2016-Dankal-iOS-MySummary.md","hash":"75ab37eeb8ff69dc4bed281580e7c4838eff3758","modified":1525935095716},{"_id":"source/_posts/Express学习笔记.md","hash":"06e424af2a5a1679130592f4784ac49154be127b","modified":1525935095723},{"_id":"source/_posts/AVFoundation录制视频没声音.md","hash":"79343974faad0a61f46b840f368e6356f284e734","modified":1525935095720},{"_id":"source/_posts/Dankal-iOS崩溃信息提交.md","hash":"d428024480bfc09bc435d59f821dd6c10096c8b6","modified":1525935095722},{"_id":"source/_posts/Jenkins-Git-CocoaPods-Fir-im实现iOS应用持续集成.md","hash":"153ffdecb16a856024cef35aa891d48555a12551","modified":1525935095724},{"_id":"source/_posts/Jenkins上蒲公英插件中update-description-无法自动写入commit-message问题解决.md","hash":"2a0ab273cb5ce92ce4e01cfcdec0553374fbd445","modified":1526022061226},{"_id":"source/_posts/DKLogger-iOS日志管理框架.md","hash":"10dad822e3a657745ad28b052750985977f7abab","modified":1525935095721},{"_id":"source/_posts/ALAsset-Type-Unknown的问题.md","hash":"2d22c0fc59e322e4b7c61959616e24a50266f03c","modified":1525935095719},{"_id":"source/_posts/MongoDB笔记.md","hash":"b8fd5e0d872241175d2a279226205a2bde46e50d","modified":1525935095728},{"_id":"source/_posts/Let’s-Encrypt-免费https.md","hash":"dbae669477a06be1d37a7134dbdda9033098f658","modified":1525935095727},{"_id":"source/_posts/NavigationController的RootViewController和子ViewController的状态栏颜色不一样或者状态栏显示异常.md","hash":"7ff835e3c50f03bec0ca1b1c75233eae17b6a6b6","modified":1525935095729},{"_id":"source/_posts/RACCommand使用注意.md","hash":"95799e327104f37efeb93d9da02ca950cec42d09","modified":1525935095731},{"_id":"source/_posts/Nginx-内容替换模块-http-substitutions-filter-module.md","hash":"a34b6839c77c6a5720818a36921e23df0460f2ea","modified":1525935095730},{"_id":"source/_posts/React-Native真机运行.md","hash":"7cd8073b7622e120587e4e6480438834f66a25e1","modified":1525935095734},{"_id":"source/_posts/Node-js学习笔记.md","hash":"21dd21350c3b5367464dc2e490a415f8284450b8","modified":1525935095732},{"_id":"source/_posts/ReactNative-ListView-flexWrap不起作用解决办法.md","hash":"71c9f7d3af3af00d7089a1fb20f7dad65f7638a5","modified":1525935095735},{"_id":"source/_posts/ReactNative与iOS原生代码之间传值.md","hash":"ee7c8fcf5468f2542469471d55c5ec8c6569dbae","modified":1525935095736},{"_id":"source/_posts/RAC关于cell上的按钮点击后会重复发送信号的问题.md","hash":"acb143b5e3d835d44b9877d443393273cd23acd5","modified":1525935095733},{"_id":"source/_posts/Salesforce-SDK-Bug.md","hash":"b6ec91d313d513d433f78ea87f93f72fc3bcfb2b","modified":1525935095738},{"_id":"source/_posts/ReactNative网络请求.md","hash":"42868f6c90de499bb4aff52f35ee7e1031b976a6","modified":1525935095737},{"_id":"source/_posts/ReactiveCocoa解决异步串行任务执行中多层嵌套-递归的问题.md","hash":"b200cccaff18936face39e769448b406d9f34c38","modified":1525935095737},{"_id":"source/_posts/URLWithString返回空.md","hash":"c9f1c52dc4823b1c9374e0d09db1292c01cd13e2","modified":1525935095740},{"_id":"source/_posts/Vue学习笔记.md","hash":"75c82eb38d03cfdbeebabf86873734b0800cdfeb","modified":1525935095742},{"_id":"source/_posts/WordPress常用函数.md","hash":"6069516f30189235e5c06427ba6cd3ac42813ea1","modified":1525935095744},{"_id":"source/_posts/Untitled.md","hash":"a1d8f74f8b28b54e4288669678afa985c93df782","modified":1525935095741},{"_id":"source/_posts/UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃的问题.md","hash":"a0fa34339e183190932a5c7e97311f7811f656dd","modified":1525935095739},{"_id":"source/_posts/docker笔记.md","hash":"f305188879320e84f106f7327bb91ef9bc14536f","modified":1525935095745},{"_id":"source/_posts/frp-内网穿透.md","hash":"d5c5268aac4d7145c2c17faac9ff16877d5e7875","modified":1525935095746},{"_id":"source/_posts/Shell-笔记.md","hash":"d4877e5e63fc2128d9b241ca86c69ead52214f5c","modified":1526545166507},{"_id":"source/_posts/XCode-添加Target.md","hash":"b0c02a7d7d2c7ff2ede199cb8c7172de006f536b","modified":1525935095743},{"_id":"source/_posts/iOS从服务器下载DAE文件并动态加载到SCNScene.md","hash":"285f46e93d86417636ed94567079861887a1945c","modified":1525935095747},{"_id":"source/_posts/iOS基于Navigation-Base-on-ViewModel的路由搭建——HOOK方式实现.md","hash":"dde899491d68cbc04c8810aaaaa636201c8880c9","modified":1525935095748},{"_id":"source/_posts/nginx-镜像谷歌.md","hash":"6ec25555a851fe07790576d151c847a767b39fab","modified":1525935095751},{"_id":"source/_posts/ipad和iphone使用UIAlertViewController.md","hash":"1c598d0f714d40461c4db83c761ec60602afbcd2","modified":1525935095750},{"_id":"source/_posts/ngrok-内网穿透使用.md","hash":"d2a1bf006ab18427c44f49fb8b60eab875faaa8c","modified":1525935095752},{"_id":"source/_posts/pan手势判断方向.md","hash":"172c310993f3edbd4f34e76e5afff82cdc9d8006","modified":1525935095752},{"_id":"source/_posts/一句ipack命令解决iOS编译打包上传fir流程.md","hash":"3cd917e60e8b5fdc1a97b42866dd6f67680183fd","modified":1525935095754},{"_id":"source/_posts/使用DKHTTPTool时的异常处理.md","hash":"72c639bed85a13cf54415d6fff2532bccace6b6a","modified":1525935095756},{"_id":"source/_posts/关于App混合开发的介绍.md","hash":"c9fd05d5f77d12ec5ea84345bf95a632a5ba1619","modified":1525935095759},{"_id":"source/_posts/pop后强制竖屏.md","hash":"ee03f2db0e4251ab119e8cf9ebb084fc4ae36841","modified":1525935095754},{"_id":"source/_posts/iOS-定位总结.md","hash":"ac8eb40d883ec13e10b1a8e6ae4ec7ca085bdc1f","modified":1525935095746},{"_id":"source/_posts/发现一个api.md","hash":"bb146d0151224cf8ced6a0bb9c8d8c8af0b6087c","modified":1525935095763},{"_id":"source/_posts/在-iCloud-Drive中显示-App的iCloud文件夹.md","hash":"01436a01adf15adea7d9e7982a2bbf968e63d0c6","modified":1525935095764},{"_id":"source/_posts/使用php的exec方法进行webhook的注意点.md","hash":"22fdd40872f17d19a126550c054416dba3db8834","modified":1525935095758},{"_id":"source/_posts/利用MJExtension取出模型数组中的某个属性组成数组.md","hash":"5875e519af86b5105c359e4ee2af779d02296007","modified":1525935095760},{"_id":"source/_posts/建造者模式.md","hash":"00c6c143728aad71fd4f4fd568477912b5611ee8","modified":1525935095766},{"_id":"source/_posts/使用RAC-DKHTTPTool实践.md","hash":"708abd5f5421f2a371ee12e9303df19e8929eb04","modified":1525935095757},{"_id":"source/_posts/什么时候用weakSelf什么时候用strongSelf.md","hash":"0768a0e2a0ff84a66e75768006cb7c55c824af55","modified":1525935095755},{"_id":"source/_posts/用flow-ci做iOS的持续化集成.md","hash":"440898f620a1187b23df4d7278325154b2430622","modified":1525935095768},{"_id":"source/_posts/简易架构设计.md","hash":"66fe37c72788ecfd70ee43669ee3e871ebeeb4f6","modified":1525935095768},{"_id":"source/_posts/组合模式.md","hash":"d9cd6b2ca459ba116b9b900d7c6cc2421ee6ef0c","modified":1525935095769},{"_id":"source/_posts/基于DKHTTPTool的业务层设计-尝试版.md","hash":"51da67fe25ace8eab907c9b710cc0e97e1c1cf81","modified":1525935095765},{"_id":"source/_posts/安装shadowsocks服务端.md","hash":"6ef4d7b80461ea14be4fbf44d6df82fc82be5fed","modified":1525935095764},{"_id":"source/_posts/给-APP添加外部文件导入功能.md","hash":"20774a424accf066ae53ac43bd13be9fa348f880","modified":1525935095770},{"_id":"source/_posts/网络层方法封装.md","hash":"66621328b6d64ee0923848bb736265ea240601a0","modified":1525935095771},{"_id":"source/_posts/网络层方法封装3.md","hash":"93d00064ea7d255e55706af1e86981a37c584de8","modified":1525935095772},{"_id":"source/_posts/网络层方法封装2.md","hash":"f7e7bad21f617d69c5faa89edb05817d2255d8ac","modified":1525935095773},{"_id":"source/_posts/网络层方法封装4.md","hash":"ef125b7fea230ccaaae48ca0245b9375e8684583","modified":1525935095774},{"_id":"source/_posts/网络层方法封装5.md","hash":"51ac773d6d2d4e1419f03dfe1dc08e67425798e3","modified":1525935095775},{"_id":"source/_posts/记录一些关于iOS的一些小技巧.md","hash":"23bc3db95251ebf5c9a7360165ec132899866948","modified":1525935095777},{"_id":"source/_posts/用Swift的框架Vapor写服务端初体验.md","hash":"2b594080c7ecf6ea53fb0cf78111fe4e1b5dcd62","modified":1525935095767},{"_id":"source/_posts/解决git-status中文问题.md","hash":"22a77470f56aa4c3545d8ec7967f5808448be927","modified":1525935095776},{"_id":"source/about/index.md","hash":"ef61ba50a2e647d10496f0750162309f8cc562e2","modified":1526023557975},{"_id":"source/_posts/关于案场管家的技术点总结.md","hash":"95acceb6f6d9b4461fe42dda92e52557fa229b1b","modified":1525935095762},{"_id":"source/_posts/项目里面的库和框架里面的库冲突问题.md","hash":"dc2ff33ba538a49b08723568ddf1559568a2ad6a","modified":1525935095777},{"_id":"source/categories/index.md","hash":"f3d4332e7a31fa7bccda8cdf7d0fc74843a8ede4","modified":1526020456427},{"_id":"source/tags/index.md","hash":"205f3ebdfd3a3012836cf8f1fc70a8c5979d9387","modified":1526020471132},{"_id":"source/images/pasted-0.png","hash":"c0918553b8c5976f49ee8776962b2e6337dd9210","modified":1518926038636},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"792b4e3c3544d51164e8a414219dc1b388dc65dc","modified":1518881681686},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"dc6bcc75f2d790aa291cdf54ae127a4a10bc75a5","modified":1518881681686},{"_id":"themes/next/.github/stale.yml","hash":"1bbdd20d025010ec57225712be82988a26485836","modified":1518881681000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1518881681686},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1518881681686},{"_id":"source/_drafts/关于iOS组件化的思考.md","hash":"1e804a3b34c04216ed89e3844e8b30ff4cece187","modified":1526025570951},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1518881681689},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1518881681690},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1518881681689},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1518881681690},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"17f75f0de0d88e6b5b4bee639b03c364eb1233c5","modified":1518881681689},{"_id":"themes/next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1518881681000},{"_id":"themes/next/docs/MATH.md","hash":"d047b8a3d9aa49b478a33e5a326195d460cb4589","modified":1518881681690},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1518881681691},{"_id":"themes/next/layout/_layout.swig","hash":"2688b61f5bd83fa2b8e92bb5000391e450aab976","modified":1518881681000},{"_id":"themes/next/layout/archive.swig","hash":"833a2213d31be45a12b8e4e5e609073978bd251b","modified":1518881681000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1518881681000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1518881681000},{"_id":"themes/next/layout/page.swig","hash":"3f9b2444f12251727ebbc28159f02e9e9489742e","modified":1518881681000},{"_id":"themes/next/scripts/merge-configs.js","hash":"ca9845dc76f5710b4c6fba5fe25ff0d2fcf0adaa","modified":1518881681717},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1518881681000},{"_id":"themes/next/layout/post.swig","hash":"8e2d079b46076996cc9343213d5bf7da8178d32d","modified":1518881681000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1518881681000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1518881681718},{"_id":"themes/next/languages/bn.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/ar.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/_en.yml","hash":"695614825fcdf80ab5a3dd36b8afe3cce567ddb5","modified":1518881681000},{"_id":"themes/next/languages/bg.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/cs.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/da.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/de.yml","hash":"27b8f7f1b0467466839f317986d195367c5db8b8","modified":1518881681000},{"_id":"themes/next/languages/el.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/es.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/fa.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/fi.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/fr.yml","hash":"15999d4301ea5493e4a9bbbe9a282b4cd0f98d84","modified":1518881681000},{"_id":"themes/next/languages/he.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/hr.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/et.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/hu.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/id.yml","hash":"109cdfd760ab2ecfd00d067ff1373d7ceaa00d33","modified":1518881681000},{"_id":"themes/next/languages/hi.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/it.yml","hash":"404af1d8180972d98afbc7ac424bde2908ede9f4","modified":1518881681000},{"_id":"themes/next/languages/ja.yml","hash":"60239d1d923b77eed2b4e9ebea113457b95fffd9","modified":1518881681000},{"_id":"themes/next/languages/jv.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/ko.yml","hash":"2aacd56326266c03031515a0e01f3fbba89aff85","modified":1518881681000},{"_id":"themes/next/languages/lt.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/lv.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/nl.yml","hash":"159dab3d37d642955d2d7e6bf719a76481c5e6d3","modified":1518881681000},{"_id":"themes/next/languages/no.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/pa.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/ms.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/pl.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/pt-BR.yml","hash":"f038084097e12fae57db70abf695eeeaf69710d8","modified":1518881681000},{"_id":"themes/next/languages/pt.yml","hash":"912444e12419f3461d9da49e80674f73e0664158","modified":1518881681000},{"_id":"themes/next/languages/ro.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/ru.yml","hash":"da1668689c08ccc7115e4e2cd1721579c9d5160b","modified":1518881681000},{"_id":"themes/next/languages/sl.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/sr.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/sv.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/th.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/tr.yml","hash":"f61c0c6a23228368721b9338bf5c14d94be40d00","modified":1518881681000},{"_id":"themes/next/languages/uk.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1518881681000},{"_id":"themes/next/languages/zh-HK.yml","hash":"3388dcf8d04093e1ccff826be91cf4b35453ea80","modified":1518881681000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"fa86f88d55086b6e319fadbc5ba2b48101abcd39","modified":1518881681000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1518881681761},{"_id":"themes/next/languages/vi.yml","hash":"7353c4b45a3708c3707d11d0def38606b3e18447","modified":1518881681000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1518881681762},{"_id":"themes/next/languages/zh-TW.yml","hash":"dec9c71a3b4935fbbcbd4bc0e65a99b98b68f152","modified":1518881681000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1518881681000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518881681746},{"_id":"source/images/pasted-1.png","hash":"9b5536674cfae526b4328c97531dbb81feeb4fae","modified":1518964818711},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1518881681692},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"f904316934d811818804df21b9a7ec5006b2cf02","modified":1518881681692},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"1c7df019737656fdfd8d124c7c045a64ac8a2a8d","modified":1518881681692},{"_id":"themes/next/docs/zh-CN/README.md","hash":"a1a034d8f0117ad6f125e1f4a51e7072eeaa27ea","modified":1518881681693},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"c1ba919f70efe87a39e6217883e1625af0b2c23c","modified":1518881681693},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1518881681691},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1518881681692},{"_id":"themes/next/docs/ru/README.md","hash":"eb6fbd7b55e449e0fa3cace4b9eddc635ac2c70c","modified":1518881681691},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1518881681702},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1518881681691},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1518881681000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1518881681702},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"464082e431ea5b06df782d5f312ee25be9e5f169","modified":1518881681000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1518881681000},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1518881681691},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1518881681000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"aa620c582143f43ba1cb1a5e59240041a911185b","modified":1518881681000},{"_id":"themes/next/layout/_macro/post.swig","hash":"99a381120b4afcb82a3a05bda88cb281ae6027ee","modified":1518881681000},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1518881681000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"fea45ab314b9ea23edab25c2b8620f909d856b1d","modified":1518881681000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"355ddd5b8af696f7bffb183addd7e84c0a4e2123","modified":1518881681000},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1518881681000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1518881681000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1518881681000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1518881681000},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1518881681000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1518881681000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1518881681000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1518881681000},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1518881681000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1518881681000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"e0bdc723d1dc858b41fd66e44e2786e6519f259f","modified":1518881681000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"5df32b286a8265ba82a4ef5e1439ff34751545ad","modified":1518881681000},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1518881681000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"494fc0191f0d0d9b0d5aa2411e45027536002c96","modified":1519142916000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ab12994e20edeed75b277f3e3dbba69375e52005","modified":1518881681000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1518881681000},{"_id":"themes/next/scripts/tags/button.js","hash":"5a61c2da25970a4981fbd65f4a57c5e85db4dcda","modified":1518881681718},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"db70a841e7c1708f95ca97b44413b526b267fa9b","modified":1518881681718},{"_id":"themes/next/scripts/tags/exturl.js","hash":"2b3a4dc15dea33972c0b6d46a1483dabbf06fb5b","modified":1518881681718},{"_id":"themes/next/scripts/tags/full-image.js","hash":"a98fc19a90924f2368e1982f8c449cbc09df8439","modified":1518881681719},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"b7600f6b868d8f4f7032126242d9738cd1e6ad71","modified":1518881681719},{"_id":"themes/next/scripts/tags/label.js","hash":"621004f2836040b12c4e8fef77e62cf22c561297","modified":1518881681719},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"1b97b1b5364945b8ab3e50813bef84273055234f","modified":1518881681719},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"460e5e1f305847dcd4bcab9da2038a85f0a1c273","modified":1518881681719},{"_id":"themes/next/scripts/tags/note.js","hash":"4975d4433e11161b2e9a5744b7287c2d667b3c76","modified":1518881681719},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1518881681720},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1518881681000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1518881681000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1518881681746},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1518881681746},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1518881681746},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1518881681747},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1518881681747},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1518881681747},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1518881681748},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1518881681747},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1518881681748},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1518881681748},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1518881681748},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1518881681748},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1518881681749},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1518881681749},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1518881681749},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1518881681749},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1518881681749},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1518881681748},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1518881681000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518881681708},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518881681708},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518881681738},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518881681738},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518881681738},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518881681745},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1518881681745},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1518881681000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1518881681000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"67f0cb55e6702c492e99a9f697827629da036a0c","modified":1518881681000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1518881681000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1518881681000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"94b26dfbcd1cf2eb87dd9752d58213338926af27","modified":1518881681000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1518881681000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1518881681000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1518881681000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1518881681000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1518881681000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1518881681000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1518881681000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1518881681000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1518881681000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"2fbee33a4ccd7c8217c73e85a9a1488170e05629","modified":1518881681000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"40e3cacbd5fa5f2948d0179eff6dd88053e8648e","modified":1518881681000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"6f340d122a9816ccdf4b45b662880a4b2d087671","modified":1518881681000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"17a54796f6e03fc834880a58efca45c286e40e40","modified":1518881681000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"c0eb6123464d745ac5324ce6deac8ded601f432f","modified":1518881681000},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1518881681000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"42f62695029834d45934705c619035733762309e","modified":1518881681000},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1518881681000},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"011ae6303afacddabc4ddf570fe3dd227569cd4f","modified":1518881681000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1518881681000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1518881681000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1518881681000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1518881681000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1518881681000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1518881681000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1518881681000},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"b8e84eb0e961a89d3f662081c7511a5b8da3aabf","modified":1518881681000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1518881681000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1518881681000},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"e2e3494f35f8bd8d828536a4a273f99e9ed28084","modified":1518881681000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1518881681000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1518881681000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1518881681000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1518881681000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1518881681000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1518881681000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1518881681000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1518881681000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1518881681000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"7a2706304465b9e673d5561b715e7c72a238437c","modified":1518881681000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1518881681000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1518881681000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"cfb03ec629f13883509eac66e561e9dba562333f","modified":1518881681000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1518881681000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1518881681000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"32392d213f5d05bc26b2dc452f2fc6fea9d44f6d","modified":1518881681000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1518881681000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1518881681000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1518881681753},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1518881681761},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1518881681760},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1518881681750},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1518881681750},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1518881681750},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"531cdedd7fbe8cb1dab2e4328774a9f6b15b59da","modified":1518881681750},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1518881681761},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1518881681750},{"_id":"themes/next/source/js/src/motion.js","hash":"50e57f8acb6924c6999cdcc664ddd3f0730d2061","modified":1518881681751},{"_id":"themes/next/source/js/src/post-details.js","hash":"d1333fb588d4521b4d1e9c69aef06e0ad1bf0b12","modified":1518881681751},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1518881681752},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1518881681752},{"_id":"themes/next/source/js/src/utils.js","hash":"5678ab50b01f7a1c609e666fc6dc3d79983104c1","modified":1518881681752},{"_id":"themes/next/source/lib/algolia-instant-search/README.md","hash":"9fa5175cdb7d3d939fe7174b6d68608ca996c174","modified":1518882565006},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1518882565000},{"_id":"themes/next/source/lib/algolia-instant-search/LICENSE","hash":"b29db4c99aa5b8d574026f68804051ff4b75466e","modified":1518882565000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1518881681758},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"3efaeb98e3b82080d037890a20f7c317feacc0b5","modified":1518881681000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1518881681000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/.DS_Store","hash":"62dab44a4b8746b5b65f5d70f535ff25f3bfeb98","modified":1519142715553},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"dbff05af5e3a7c4f0889cdcc9027f882a246aa68","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"ba1842dbeb97e46c6c4d2ae0e7a2ca6d610ada67","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1518881681000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1518881681000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1518881681000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1518881681000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1518881681000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1518881681000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1518881681000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1518881681000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1518881681000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1518881681000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1518881681000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1518881681758},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1518881681758},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1518881681751},{"_id":"themes/next/source/lib/algolia-instant-search/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1518882564000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/config","hash":"ae057b7f33eac7ddf41bed1c7a3323eb69ec0b7c","modified":1518882565000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1518882563000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/index","hash":"9ac42d7390474afe35c7150ce14092c74cc58996","modified":1518882565009},{"_id":"themes/next/source/lib/algolia-instant-search/.git/packed-refs","hash":"52b85a0144e04fcbf9a0911b63026875ac02273a","modified":1518882564000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1518881681760},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1518881681756},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1518881681757},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ce77b4ff598c10aca5687e9a65387ae74684632e","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"381fcdefb6493978d18618afdd7322e0a39decdc","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"8bf095377d28881f63a30bd7db97526829103bf2","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"057f4b720a496c30afb91990589e6733356e71c8","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1c06be422bc41fd35e5c7948cdea2c09961207f6","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"5d15cc8bbefe44c77a9b9f96bf04a6033a4b35b8","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1518881681000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1518881681000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1518881681000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1518882563000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1518882563000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1518882563000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1518882563000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1518882563000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1518882563000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1518882563000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1518882563000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1518882563000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1518882563000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1518882563000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/logs/HEAD","hash":"bdd1ba352067bfe93d11d37f08f415b585eaf7f7","modified":1518882565000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1518881681756},{"_id":"themes/next/source/lib/algolia-instant-search/.git/refs/heads/master","hash":"591d58b48a711af78b2cf38fbf4e5d9e23c22ab8","modified":1518882565000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/08/777d50ffb9e517f20d2cbf2ea19130862fb501","hash":"db56cbd678ba51ffe41f193c84f4590c772573ff","modified":1518882564988},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/0d/49463cf444a6411519b6d7b5bb65fa7e96c4dc","hash":"cdf6108b43b6e74d05bf5760a7d0b0a8a827c7e6","modified":1518882564506},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/59/0f6f985f6018c397b2499bb49e599b7109ec06","hash":"1d7be96ab84efcd3430e856bce1d6c9395c9e047","modified":1518882564508},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/54/7b348ba5c8725ea590087860a352c8ff41cb98","hash":"53cbfcca3f1651469476af24e66ea885e947dcfe","modified":1518882564503},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/69/a20d65d83035fdb01734a8eabe3340f740a4cb","hash":"1671fc91ba7d0bdf1b81fb5db558732d4b0ebaa7","modified":1518882564505},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/6d/b4c7bd4b80f34ae7165de7d91291759569d572","hash":"8fefead6162d812bd5734b8f5554c37bef31d37d","modified":1518882564990},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/a4/0c9f2635389a60948f0f2235f037277f8acff6","hash":"f4c968776b6c6479de656180ce3c069571ed82c2","modified":1518882564505},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/c9/af6112eed1dab47eba55651562f768bfbc861d","hash":"7dffdc3573fddcae81bd2745b8d021100e0fa1e9","modified":1518882564502},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/92/1eb7be3c529d19b6c92ce67e4099e8f7d6adf3","hash":"f63ec47cfd4f1117a3523a3c81db4152fb0fe283","modified":1518882564989},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1518882565009},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/f5/e09255981809338b668b56510e360595fc12fa","hash":"96442f68b585770c99178fe798467e237894743c","modified":1518882564504},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/da/0b2b5f2ab8f750444499f17e4cbf6074aef7f0","hash":"3569a792dbf5ca1c39c49a6ca6fadb986bfbe10b","modified":1518882564502},{"_id":"themes/next/source/lib/algolia-instant-search/.git/objects/2b/d5d590d07a161741477ace2339eb37c07cc40c","hash":"bf4a34376fa1b13d602b2737c83662f4c0006e5c","modified":1518882564988},{"_id":"themes/next/source/lib/algolia-instant-search/.git/logs/refs/heads/master","hash":"bdd1ba352067bfe93d11d37f08f415b585eaf7f7","modified":1518882565000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1518882564000},{"_id":"themes/next/source/lib/algolia-instant-search/.git/logs/refs/remotes/origin/HEAD","hash":"bdd1ba352067bfe93d11d37f08f415b585eaf7f7","modified":1518882564000},{"_id":"source/_drafts/Jenkins分布式构建笔记.md","hash":"35b0e3e6c23c2db5e0b22c3b5f18b8bbd0fdf5b2","modified":1528689703150},{"_id":"public/atom.xml","hash":"49ccc8311f4cec08604e41cd06363619ebe12c46","modified":1528689921247},{"_id":"public/sitemap.xml","hash":"af9db89fe647858148b91c56d28edfd1549b3852","modified":1528689921308},{"_id":"public/about/index.html","hash":"3c71f5f4fbfdc7e34b202a2b4ce698312291c632","modified":1528689923791},{"_id":"public/categories/index.html","hash":"a9524f6481d3a6bfef10b2400269a0a6431dd3b8","modified":1528689923816},{"_id":"public/tags/index.html","hash":"689101767b5900d81c06bf75fa49c427a9145f85","modified":1528689923817},{"_id":"public/post/5fcbb764.html","hash":"a2031eb273fa4940eb9dec1bedf7d27c3c494e59","modified":1528689923817},{"_id":"public/post/cfe784af.html","hash":"90d7b0162b7f0bd04335b7946c042e5d20bfcc52","modified":1528689923817},{"_id":"public/post/4417b09c.html","hash":"9a1c74db70624c7929b9228036d597fb614bd84e","modified":1528689923817},{"_id":"public/post/e35ccdb6.html","hash":"124ded9ece1b0a0815f4d8a5ce3f1a99c1ff8376","modified":1528689923817},{"_id":"public/post/eb81866c.html","hash":"4208eac4bee7e52db16fcbd0fc52dd36e7a15306","modified":1528689923817},{"_id":"public/post/a6a89073.html","hash":"4f863b3d70bad3d2fb612074c7e28858851eac4a","modified":1528689923817},{"_id":"public/post/8cafabb2.html","hash":"566c85fc28d42db45762bc1d1836586a854cabe7","modified":1528689923817},{"_id":"public/post/b72542c2.html","hash":"a9a2d78b2339d4a3d6a0d3abf01a2e76bad6dbc9","modified":1528689923817},{"_id":"public/post/dda122f4.html","hash":"1e924b7c0ac77335edbbc958852a0b0455b1e064","modified":1528689923817},{"_id":"public/post/e88dc875.html","hash":"0aebfb017a15570b8c5eed0538a6da321964689e","modified":1528689923818},{"_id":"public/post/b3b38c86.html","hash":"1ff7f597f2f43b82258420c1b13921b30f4f0d38","modified":1528689923819},{"_id":"public/post/f8291fcc.html","hash":"510cbdba66ca597e79d33a153c8d568faf28db96","modified":1528689923819},{"_id":"public/post/f6ce3122.html","hash":"999625611fdc2f55d4fffd7f4d2b5532300ec395","modified":1528689923819},{"_id":"public/post/feddc8a5.html","hash":"462c56b0b407774c2daed425d51aea55d2c2216e","modified":1528689923819},{"_id":"public/post/71513ccb.html","hash":"44c58441ed5f04e9c362f5ee037b4a8c6b06e13f","modified":1528689923819},{"_id":"public/post/93da1b70.html","hash":"d8c9fad4fcc5d5dc5f756ec626d70840b1378d56","modified":1528689923819},{"_id":"public/post/73291e5a.html","hash":"55609b1af6417bf1aa9a2d91973067ef6221d266","modified":1528689923819},{"_id":"public/post/b6bd206a.html","hash":"17e8b8c46ee03ae47735174f4c99f4a580140682","modified":1528689923819},{"_id":"public/post/b179ff40.html","hash":"0697a392c9852877367cd69aa47a913fa9c8a28a","modified":1528689923820},{"_id":"public/post/5f5664e4.html","hash":"210d0e6fafe0c99aa744a709f285a1456a9ca0c1","modified":1528689923820},{"_id":"public/post/7724d1af.html","hash":"602f1372d49befebf7d980cb61ad37550a581a46","modified":1528689923820},{"_id":"public/post/dcb90c85.html","hash":"0fefc6c74ede17e8c214a0b7052bd808d5c9c940","modified":1528689923820},{"_id":"public/post/1aafa723.html","hash":"6e077c862d69101af1866c75860967a47a47b74c","modified":1528689923820},{"_id":"public/post/efd905d7.html","hash":"03185153b275acc0e120822119ddcd4ad0c82189","modified":1528689923820},{"_id":"public/post/11785d19.html","hash":"f884f5171d8bb978baa4f50fa6fd612d1ebc3681","modified":1528689923820},{"_id":"public/post/3fd5c9ca.html","hash":"02d979aea42f9fc99c2ce3050e82097abface41e","modified":1528689923820},{"_id":"public/post/a8a5ff12.html","hash":"28ac9b94387b7a77cf690053a42d87b9dcabdd7e","modified":1528689923820},{"_id":"public/post/2281692e.html","hash":"4558327f63177f2ca61ecbf729d1085d930066ab","modified":1528689923820},{"_id":"public/post/abce56f1.html","hash":"8f68b889cea989a989cc672f481d335d1eb4faa2","modified":1528689923820},{"_id":"public/post/8c9c88ab.html","hash":"b9224fafdd6e7a710eef9efc135687d7d8e970ce","modified":1528689923821},{"_id":"public/post/4edc914d.html","hash":"89f9c15b81a1211b163c8592a21aca29c156893f","modified":1528689923821},{"_id":"public/post/13ecfb47.html","hash":"517860a2dd79b49b82521bf785d54f150bb95798","modified":1528689923821},{"_id":"public/post/61929cc2.html","hash":"6b02095e4202517a0a6ae2e9c1c5d03c3c43ada6","modified":1528689923821},{"_id":"public/post/7daccd39.html","hash":"fb0aa413738e183cb89ec02681e3a1d6af99d75e","modified":1528689923821},{"_id":"public/post/b111382b.html","hash":"dced718a751f41d330cee13e356cbd4f983bb19d","modified":1528689923821},{"_id":"public/post/8d52056b.html","hash":"29ac74452d0dc574c031eca30207fe914ad654d5","modified":1528689923822},{"_id":"public/post/178548dd.html","hash":"9935ed8f5843b8c6149badc334d085307dd8d069","modified":1528689923822},{"_id":"public/post/6082784b.html","hash":"5e887040e96498487132df99b91f4accb2a701d8","modified":1528689923822},{"_id":"public/post/838ddddd.html","hash":"ed39ea5b78a268e69019a7104fce18e224a97c1b","modified":1528689923822},{"_id":"public/post/fee6ede8.html","hash":"3771d82fca29bad8b5ae8c93c7ccd79c02845b4c","modified":1528689923822},{"_id":"public/post/1787ee1c.html","hash":"768f659fd08c1c8290fad32c4a33fe14b9de0c98","modified":1528689923822},{"_id":"public/post/89e1dd7e.html","hash":"90f7a9707c42829ca57b3f786adbccbb9e2ed99c","modified":1528689923822},{"_id":"public/post/df879792.html","hash":"fdc3c149241faddc3feaebc21b75ccf7eeb46cb9","modified":1528689923822},{"_id":"public/post/afeed214.html","hash":"a20ad2678d2b268c150241e574c9165a6ff48ac7","modified":1528689923822},{"_id":"public/post/d2301e87.html","hash":"f49279434f6181a1d14676b7a76327ce87906113","modified":1528689923822},{"_id":"public/post/fe816c3c.html","hash":"1b1d57076153fe4caadea7b868c62f6fcc16504c","modified":1528689923822},{"_id":"public/post/3d9cee8d.html","hash":"b2800511300b52bfbc99cc353b71469ee257d3c5","modified":1528689923822},{"_id":"public/post/4948514e.html","hash":"fb360dad1bcd91f12c768ac4fa34215070e5fd9d","modified":1528689923822},{"_id":"public/post/2684222a.html","hash":"cf5cb12665d839afc1eb19020d4a4465d018ef0c","modified":1528689923823},{"_id":"public/post/3eb7dc04.html","hash":"f805e02bdd8ca4f954d582da052a86798d635349","modified":1528689923823},{"_id":"public/post/b072216a.html","hash":"28e667298698abe1fb5446b8ac25823d08299527","modified":1528689923823},{"_id":"public/post/8e2ebfdf.html","hash":"9f442098a79765eda97211ba8d37214e8f296f09","modified":1528689923823},{"_id":"public/post/cacc49a3.html","hash":"f9b7efeac73297f25eb846a65f8b3670640e9c44","modified":1528689923823},{"_id":"public/post/79533f9e.html","hash":"a5d8a557617eba3e058d84c6e6ba2357db4cf428","modified":1528689923823},{"_id":"public/post/50c5f6e6.html","hash":"fd6e39f740a707b1918bfef6f77bb09973a88d58","modified":1528689923823},{"_id":"public/post/f9b1d95c.html","hash":"630fd258201786f05a0625591c93fb51e9a712cb","modified":1528689923823},{"_id":"public/post/890a3088.html","hash":"2ef0b9dc9a8658f28a98b3e73d7e3feb6f9901dd","modified":1528689923823},{"_id":"public/post/f0080c3e.html","hash":"455c071bf636a30d7cbc043bc8f2ed4c48fe68b2","modified":1528689923823},{"_id":"public/post/54b26395.html","hash":"5d08905bc1b3a278846481ec6d651c0627d42125","modified":1528689923823},{"_id":"public/post/34db2dbc.html","hash":"541647e00e0dce3e27da53f49cb0cb52f22ce851","modified":1528689923823},{"_id":"public/post/a8ea2211.html","hash":"fad2cca1cb3868fe91cc25b56c0c024399dad126","modified":1528689923823},{"_id":"public/post/452efb32.html","hash":"dacc23c8162d7289daa8ef0a678582f0ed868ce6","modified":1528689923823},{"_id":"public/post/8ff6aa28.html","hash":"89d59e431b8988f935070cc2cf2211fe54c8d5f5","modified":1528689923823},{"_id":"public/post/1b8f24c7.html","hash":"c19cac6f3f82b29a5d6756c89f0935e16fe1718e","modified":1528689923824},{"_id":"public/archives/index.html","hash":"855412025db5cd091d3e4d812832753ca15607bc","modified":1528689923824},{"_id":"public/archives/page/2/index.html","hash":"2ed3e6b2fa3a4ebe3b82e941384be991ab9e16f3","modified":1528689923824},{"_id":"public/archives/page/5/index.html","hash":"93f073891326a4b2fe76bb8125a121f6a738853f","modified":1528689923824},{"_id":"public/archives/page/3/index.html","hash":"be1a55235a9ed063167e06e6b6aca70488457afe","modified":1528689923824},{"_id":"public/archives/page/4/index.html","hash":"e5a8148646fda8399a9c7ef678d1cd30ec2978f3","modified":1528689923824},{"_id":"public/archives/page/6/index.html","hash":"b5e3afed48ccc0ec59b95a50cee4a8a327cca816","modified":1528689923824},{"_id":"public/archives/page/7/index.html","hash":"910d62fb9f6e869ec9f7bb1ee5768f2a9dbdf3cf","modified":1528689923824},{"_id":"public/archives/2016/index.html","hash":"68ae7240fe3d27374722e3fc6d165ec6e737abc9","modified":1528689923824},{"_id":"public/archives/2016/page/2/index.html","hash":"f9c9c36af5da9f552f33469f9e316ee873be6662","modified":1528689923824},{"_id":"public/archives/2016/page/3/index.html","hash":"ec5924d653a496a30c3d344f0958f45a7288f715","modified":1528689923824},{"_id":"public/archives/2016/10/index.html","hash":"eb07717035f79385c7572ed17d0d715f1e613383","modified":1528689923824},{"_id":"public/archives/2016/06/index.html","hash":"57ba4651a680ce9b9886ae7102d43c29460560ce","modified":1528689923825},{"_id":"public/archives/2016/12/index.html","hash":"8775243ff1e92cc692e92f841dcd3406dc220afd","modified":1528689923827},{"_id":"public/archives/2016/11/index.html","hash":"ccd55447d1205eac0d51f4f54070a00f1f4f4687","modified":1528689923828},{"_id":"public/archives/2017/index.html","hash":"afc5bf4c8fc8709053e7197f2e1001afb47065fc","modified":1528689923828},{"_id":"public/archives/2016/10/page/2/index.html","hash":"245f8984fbd5815f57a94a8d46a9e96ccb271283","modified":1528689923828},{"_id":"public/archives/2017/01/index.html","hash":"98fecae735e98c76b0e7ef6d379dfd6fa8999391","modified":1528689923828},{"_id":"public/archives/2017/page/2/index.html","hash":"7bf336ded536aadc01bcb1f98abc614ec6e923e8","modified":1528689923828},{"_id":"public/archives/2017/page/3/index.html","hash":"4dec0b7dcb8b6de16eee56593fe83363ffe7b482","modified":1528689923828},{"_id":"public/archives/2017/02/index.html","hash":"0fcc11e112dc4ce12536a2d383958586de66e384","modified":1528689923828},{"_id":"public/archives/2017/03/index.html","hash":"57dff0663957683db68717bd73a8d7eb4ad67941","modified":1528689923828},{"_id":"public/archives/2017/08/index.html","hash":"5e9f592748dd577b48fe48429fa92a7dfe7b638e","modified":1528689923829},{"_id":"public/archives/2018/index.html","hash":"935c1f8a0281af58154edc0397a17b851fd51a34","modified":1528689923829},{"_id":"public/archives/2018/page/2/index.html","hash":"e8dd431bda22beb17ce22380ba658b63afa44e35","modified":1528689923829},{"_id":"public/archives/2018/02/index.html","hash":"292bae7c069fea3112e2434982f9a6537071c688","modified":1528689923829},{"_id":"public/archives/2018/05/index.html","hash":"03f58b0df7029ea847a4e86c50629a259fcbc666","modified":1528689923829},{"_id":"public/archives/2018/02/page/2/index.html","hash":"30730b4419b65e4e37dbcc78fc4ca1b3fe74b394","modified":1528689923829},{"_id":"public/categories/iOS/index.html","hash":"e60e891cd403b3212f347dc066c74cb3de74012a","modified":1528689923829},{"_id":"public/categories/iOS/page/4/index.html","hash":"73f3ee5df4fc6855dbfccda6eb6c4453c12510af","modified":1528689923829},{"_id":"public/categories/iOS/page/5/index.html","hash":"4f172a871a18f78826a46d8a148f391bb2612876","modified":1528689923829},{"_id":"public/categories/iOS/page/2/index.html","hash":"47d71f2a1be2f04182e19026def42ffe72d0a92d","modified":1528689923829},{"_id":"public/categories/iOS/page/3/index.html","hash":"a0e30856caebc8c7e650e58cb90b1dbc030cb0ee","modified":1528689923829},{"_id":"public/categories/Node-js/index.html","hash":"8d97264e021b1f036311880dd511a01fd76b7b7e","modified":1528689923829},{"_id":"public/categories/Jenkins/index.html","hash":"ce445b72e583349d865f329eee0f0f0af3097738","modified":1528689923830},{"_id":"public/categories/React-Native/index.html","hash":"6d12bf4225b8d97bf5bdd5fe8ce71d552af61b9d","modified":1528689923830},{"_id":"public/categories/MongoDB/index.html","hash":"d7f361f22f0f51df56ab1e88f8abfceaf781d2e3","modified":1528689923830},{"_id":"public/categories/Linux/index.html","hash":"91b38b92a4efc7f22f89ed70ac2da3c5e5b41aef","modified":1528689923830},{"_id":"public/categories/PHP/index.html","hash":"967ada78c3cbd886f5bacb53302b3394c435df4c","modified":1528689923830},{"_id":"public/categories/前端/index.html","hash":"d7dd7ab3b42fa36eed2186abbdb6e87cb645e26a","modified":1528689923830},{"_id":"public/index.html","hash":"3a51aae9618757acc3f12adb790e9557e1d94831","modified":1528689923830},{"_id":"public/categories/Git/index.html","hash":"0f067033f68c15693bf9165bba07a8aa5c984d67","modified":1528689923830},{"_id":"public/categories/杂谈/index.html","hash":"8a13ddb3ec83efe83bbef10bea9c4d389e534072","modified":1528689923830},{"_id":"public/categories/Swift/index.html","hash":"e908bed2e7904b0580a142b913bb746773bb180f","modified":1528689923830},{"_id":"public/page/3/index.html","hash":"750b4fc6938dbb153f7d05b3c636a6e4f3a7c156","modified":1528689923844},{"_id":"public/page/5/index.html","hash":"fc0a479ae074ab71b61cc067f8aa50b560fb9669","modified":1528689923844},{"_id":"public/page/4/index.html","hash":"b2c5b15b31f7a1deb30d86a09114a774cf04584f","modified":1528689923844},{"_id":"public/page/2/index.html","hash":"e3dff9079d8dbf983f28fc33f7c483ca4297fecd","modified":1528689923844},{"_id":"public/page/6/index.html","hash":"a48708530d7609bb8bfad03105fa57419f7a62ea","modified":1528689923844},{"_id":"public/tags/iOS/index.html","hash":"b6d1762e16cebbeba6b3831f86b2745d30db8d93","modified":1528689923844},{"_id":"public/page/7/index.html","hash":"5d92b2d11467c8e2ce810f5524fc06f14dada885","modified":1528689923844},{"_id":"public/tags/iOS/page/4/index.html","hash":"4a0be1ddca401c9052478bc18c1c650a2d03bd8f","modified":1528689923844},{"_id":"public/tags/iOS/page/3/index.html","hash":"d3820b5b0bab4c84f49eee78e3bf578cd5c0e21a","modified":1528689923844},{"_id":"public/tags/杂谈/index.html","hash":"bcb6b0c84eb70dff304dd086980846cacb6fcc0b","modified":1528689923845},{"_id":"public/tags/iOS/page/2/index.html","hash":"529bd35b60f1e58a3c892ce20dcdab3c0511b1a2","modified":1528689923845},{"_id":"public/tags/Node-js/index.html","hash":"86ab800371602fd9ae203c744ecebd3c6a2e4ece","modified":1528689923845},{"_id":"public/tags/Jenkins/index.html","hash":"96c509cbea5f8b636d6d3efbf0f9b969f76c9223","modified":1528689923845},{"_id":"public/tags/Express/index.html","hash":"7092d890cb8653e7e22cf39b337f6b81071a9d4f","modified":1528689923845},{"_id":"public/tags/Git/index.html","hash":"9ca598162238aa32ca2d580a1fa122b580c008c3","modified":1528689923845},{"_id":"public/tags/CocoaPods/index.html","hash":"2c7e95d9d6228d713f8e9aca02f8ce610ad78120","modified":1528689923845},{"_id":"public/tags/Let-s-Encrypt/index.html","hash":"8a85d605e89e0a1ba5e1034d0ce196dc2801f23b","modified":1528689923845},{"_id":"public/tags/Fir/index.html","hash":"1bb587ad2dcc947cb7512e127f026c51a715290e","modified":1528689923845},{"_id":"public/tags/MongoDB/index.html","hash":"acf1a2e19db143032ca579a11fa76abd36cd823a","modified":1528689923862},{"_id":"public/tags/https/index.html","hash":"6ab29c3f6dfe08c0f12f0c4e48c78990f8b821bc","modified":1528689923862},{"_id":"public/tags/nginx/index.html","hash":"4275ac46e160b0a51256f49ca9cf8224524160dc","modified":1528689923862},{"_id":"public/tags/Reactive-Cocoa/index.html","hash":"b8716d977f096fbb6c749d9c693869de79f85510","modified":1528689923863},{"_id":"public/tags/React-Native/index.html","hash":"be34ec83441280ef6432a827d354ff2a8b60112b","modified":1528689923863},{"_id":"public/tags/Salesforce/index.html","hash":"aae7efeeffca1011559a2f894fa99523bbc0428c","modified":1528689923863},{"_id":"public/tags/Vue-js/index.html","hash":"f634405a7afa59498e831ede3240dc37a51e7e56","modified":1528689923864},{"_id":"public/tags/PHP/index.html","hash":"97fef25ef9d242392e800075349ef7deb57a800a","modified":1528689923864},{"_id":"public/tags/docker/index.html","hash":"20076b2a781e8dc7d492ee2219784090098c8427","modified":1528689923864},{"_id":"public/tags/WordPress/index.html","hash":"574f0c5300f46f411fc8054591f3a3e2cecb08d9","modified":1528689923864},{"_id":"public/tags/frp/index.html","hash":"7657bd3ef81a92d59078abec0854112d332d8f90","modified":1528689923864},{"_id":"public/tags/XCode/index.html","hash":"3b8524d7d8cec36ae004a07809f9f3eb5845e235","modified":1528689923864},{"_id":"public/tags/Scene-Kit/index.html","hash":"23a4b17b20132709f50e4ae7e20e60584a7e9f56","modified":1528689923864},{"_id":"public/tags/ngrok/index.html","hash":"ba54b8f0bb8a098717b44c8e9f60aca7ec547e9d","modified":1528689923864},{"_id":"public/tags/shell/index.html","hash":"e1ae5f22a5609e455ed84f655572e2cc9e8481ce","modified":1528689923864},{"_id":"public/tags/AppCan/index.html","hash":"21d3a1abf1c576a722c5ca4804079724d3a3e515","modified":1528689923864},{"_id":"public/tags/Cordova/index.html","hash":"6312e5abd4531eca35a8da4da744ab91f5ab8c86","modified":1528689923864},{"_id":"public/tags/Weex/index.html","hash":"639f626eeb5d5cd2a2316dd795650b9927c5bbc0","modified":1528689923864},{"_id":"public/tags/php/index.html","hash":"e75d2d8f793be674672fe948daeaf4630c274c26","modified":1528689923864},{"_id":"public/tags/HTML5/index.html","hash":"ee7a86f7516f31bc9a646b0a8837faf40bebc424","modified":1528689923864},{"_id":"public/tags/Flow-ci/index.html","hash":"0d9e168a17262a0aadd2eeba44ff8b9ab9d37b2e","modified":1528689923864},{"_id":"public/tags/webhook/index.html","hash":"aa76b8ef47fb0ad40421c3efe5ffe953c2ce8999","modified":1528689923864},{"_id":"public/tags/Shadowsocks/index.html","hash":"43371fbc569ad6f5fea4bf59267fb7e5054a4d31","modified":1528689923864},{"_id":"public/tags/git/index.html","hash":"2cfc5dd3cf1c33f5516c38ac1330f835e3cf2b0f","modified":1528689923865},{"_id":"public/tags/Swift/index.html","hash":"cb6238daeda3d4c98f0b3009e211f3eecca7d734","modified":1528689923865},{"_id":"public/tags/技巧/index.html","hash":"92c0a3a3217fc014166c4f525d621743614227bb","modified":1528689923865},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"047450360b8f38a38d671f870245e1fecd240d74","modified":1528689923869},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"c12c5229d21bf401b5eb976d93f58bd2ea440126","modified":1528689923869},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"445fb22a5c7d9190dc30cfe57ee8a3e13289cd01","modified":1528689923871},{"_id":"public/assets/algolia/algoliasearch.js","hash":"058e6f06bf93a63babc7e0e280142dac6bcc56ca","modified":1528689923879},{"_id":"source/_posts/通过代理上传方案.md","hash":"5a8e8f2b859e532ba877ae708280bbd4944b9d13","modified":1533283958442}],"Category":[{"name":"iOS","_id":"cji9qbcgl0002ldxu4eg7i0zq"},{"name":"Node.js","_id":"cji9qbch60007ldxuajm3qodq"},{"name":"Jenkins","_id":"cji9qbcho000lldxu695u02e5"},{"name":"MongoDB","_id":"cji9qbchv000tldxud00xb3o7"},{"name":"Linux","_id":"cji9qbci50011ldxufvafh0pt"},{"name":"React Native","_id":"cji9qbcix001jldxuclls4bdq"},{"name":"前端","_id":"cji9qbcjk0022ldxui266jsob"},{"name":"PHP","_id":"cji9qbcjx002bldxut3b3ng7w"},{"name":"杂谈","_id":"cji9qbcl8003nldxu7ngqx518"},{"name":"Swift","_id":"cji9qbcvw0072ldxu1et1qk8n"},{"name":"Git","_id":"cji9qbcw70079ldxukqi6301q"}],"Data":[],"Page":[{"title":"关于","date":"2018-02-16T14:05:46.000Z","type":"about","_content":"\n如果你只是想知道我叫什么，叫我`Arc`就行了<br/>\n如果你想知道我在做什么，我现在在做`程序开发`<br/>\n如果你想联系我，发邮件到`arclin325@gmail.com`，有时间我一定会回复你<br/>\n如果你已经认识我，你不介意的话就留言一下让我知道这个世界还有其他人:)<br/>","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2018-02-16 22:05:46\ntype: about\n---\n\n如果你只是想知道我叫什么，叫我`Arc`就行了<br/>\n如果你想知道我在做什么，我现在在做`程序开发`<br/>\n如果你想联系我，发邮件到`arclin325@gmail.com`，有时间我一定会回复你<br/>\n如果你已经认识我，你不介意的话就留言一下让我知道这个世界还有其他人:)<br/>","updated":"2018-05-11T07:25:57.975Z","path":"about/index.html","comments":1,"layout":"page","_id":"cji9qbcvm006zldxucqurtm33","content":"<p>如果你只是想知道我叫什么，叫我<code>Arc</code>就行了<br><br>如果你想知道我在做什么，我现在在做<code>程序开发</code><br><br>如果你想联系我，发邮件到<code>arclin325@gmail.com</code>，有时间我一定会回复你<br><br>如果你已经认识我，你不介意的话就留言一下让我知道这个世界还有其他人:)<br></p>\n","site":{"data":{}},"excerpt":"","more":"<p>如果你只是想知道我叫什么，叫我<code>Arc</code>就行了<br><br>如果你想知道我在做什么，我现在在做<code>程序开发</code><br><br>如果你想联系我，发邮件到<code>arclin325@gmail.com</code>，有时间我一定会回复你<br><br>如果你已经认识我，你不介意的话就留言一下让我知道这个世界还有其他人:)<br></p>\n"},{"title":"分类","date":"2018-02-16T14:05:11.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-02-16 22:05:11\ntype: categories\ncomments: false\n---\n","updated":"2018-05-11T06:34:16.427Z","path":"categories/index.html","layout":"page","_id":"cji9qbcvs0071ldxugm2i2cdz","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-02-16T14:05:25.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-02-16 22:05:25\ntype: tags\ncomments: false\n---\n","updated":"2018-05-11T06:34:31.132Z","path":"tags/index.html","layout":"page","_id":"cji9qbcw00075ldxu1rard4fi","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"2016-Dankal-iOS-MySummary","author":"Arclin","abbrlink":"61929cc2","date":"2017-01-23T16:00:00.000Z","_content":"总结2016在 Dankal 工作过程中学习到的东西\n\n<!-- more -->\n\n### Main Argument 主要论点\n中介者\n组件化\n封装\nMVVM\nReactiveCocoa\n\n### 基于MVC的组件化设计 CTMediator + （CTNetworking -> DKNetworking -> DKHTTPTool）\nCTMediator和CTNetworking 是我在5-6月份左右看的一套源码，出处是这里,然后去年年底作者又发布了[基于 CTMediator工程实践](http://casatwy.com/modulization_in_action.html)。总的设计思想如下：\n\n### 组件逻辑\n\n- CTMediator 是一种组件化方案，主要是针对大型项目多人开发情况下的一种方案。路由方式是 Targer-Action，通过这种方式进行模块之间的沟通，模块使用私有 pod 进行封装（这个是在第二篇的实践中提出来的），因为目前我们还没接触过这种大型的项目，所以一直停留在理论阶段（也就是虽然我看懂了源码的设计思想但是却没得地方实现），后来启动了觅书项目，打算尝试这种设计，结果发现过于大材小用了。模块的创建要先通过中介者进行注册，调用要通过中介者进行调用，总结一下大概就像这样子：\n\n```\n             --------------------------------------\n             | [CTMediator sharedInstance]        |\n             |                                    |\n             |                openUrl:       <<<<<<<<<  (AppDelegate)  <<<<  Call From Other App With URL\n             |                                    |\n             |                   |                |\n             |                   |/               |\n             |                parseUrl            |\n             |                                    |\n             |                   |                |\n.................................|...............................\n             |                   |                |\n             |                   |/               |\n             |  performTarget:action:params: <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  Call From Native Module\n             |                   |/               |\n             |             -------------          |\n             |             |  runtime  |          |\n             |             -------------          |\n             ---------------.---------.------------\n                           .           .\n                          .             .\n-------------------------------      --------------------------------\n|                       ·     |      |    ·                         |\n|                     ·       |      |     ·                        |\n|           Target            |      |           Target             |\n|                             |      |                              |\n|         /   |   \\           |      |         /   |   \\            |\n|        /    |    \\          |      |        /    |    \\           |\n|                             |      |                              |\n|   Action Action Action ...  |      |   Action Action Action ...   |\n|                             |      |                              |\n|Service  A                   |      | Service  B                   |\n-------------------------------      --------------------------------\n```\n\n这里面包括了内部调用和远程应用调用，远程应用调用因为我们目前还用不着所以先不管，内部调用的流程为了方便理解我举个例子，fromController通过performTarget:action:params:方法传入toController类名和在toController要执行的方法和所需的参数，这样子组件之间就实现了解耦，fromController 只需要知道他想去的地方是 toController和要给什么值出去，甚至这个 controller 存不存在都无所谓，而 toController 只需要遵循协议方法/重写父类方法去的到参数即可，然后里面就可以直接调这个参数，并且这一系列跳转规则和传参规则都通过 CTMediator 中介者去控制。\n\n### 服务层（Service Layer） 或者叫 业务层（Business Layer）\n\n刚刚总结了一下CTMediator的组件间的逻辑,现在来总结一下业务层与 ViewController 层之间的设计.因为虽然是 MVC，那当然也得尽量避免 Mess View Controller ,Service 在这里可以理解为数据仓库+业务逻辑仓库，为的是令ViewController中避免出现像数据 A处理判断完才显示到控件上的情况，尽量能把最直接的数据给 ViewController 显示,利用像下图这种方式，业务层暴露出 Target 和 action供外界调用，调用方法后就进入了CTMediator 进行处理，接下来的事情就像我上面说的一样了。\n\n```\n         --------------------------------\n         |           Service  A         |\n         ---  ----------  ----------  ---\n           |  |        |  |        |  |\n...........|  |........|  |........|  |...........\n.          |  |        |  |        |  |          .\n.        ---  ---    ---  ---    ---  ---        .\n.        |action|    |action|    |action|        .\n.        ---|----    -----|--    --|-----        .\n.           |             |        |             .\n.           |             |        |             .\n.       ----|------     --|--------|--           .\n.       |Target_A1|     |  Target_A2 |           .\n.       -----------     --------------           .\n..................................................\n```\n\n### CTNetworking -> DKNetworking -> DKHTTPTool\n\n- CTNetworking 是一个基于AFNetworking的开源网络层组件，经过改装之后我组装出了 DKNetworking（虽然后面发现有 RAC神器之后就觉得这个东西不够轻便了）。\n\n- CTNetworking 解决了以下几个问题\n\t- 使用哪种交互模式来跟业务层做对接？\n\t- 是否有必要将API返回的数据封装成对象然后再交付给业务层？\n\t- 使用集约化调用方式还是离散型调用方式去调用API？\n\n- 上面三个问题分别给出的答案是\n\t- 代理模式\n\t- 没必要\n\t- 离散型\n\n- CTNetworking考虑的东西相当地多，除了上面几个问题之外，还考虑到了网络层安全机制（数据传输，HTTPS）,链接环节的优化（链接传输量和链接复用）等，一开始看源码也是看的很懵逼\n- 通过协议的方式进行组件内的方法封装\n\n|协议名|解释|\n|----|----|\n|CTAPIManagerApiCallBackDelegate|回调协议|\n|CTAPIManagerCallbackDataReformer|负责重新组装API数据的对象|\n|CTAPIManagerValidator|验证器验证参数和返回|\n|CTAPIManagerParamSourceDelegate|参数源|\n|CTAPIManager|CTAPIBaseManager的派生类必须符合这个protocal|\n|CTAPIManagerInterceptor|拦截器，拦截参数和回调|\n\n- 用协议的好处就是各取所需。当你想要统一管理所有回调的时候，那你这个类只要遵循`CTAPIManagerApiCallBackDelegate`代理和实现对应的方法，如果你这个类想要拦截参数，那么就遵循`CTAPIManagerInterceptor`协议并实现对应的方法，大抵就是这种思想，然后底层就会进行各种判断并拼接各个协议的方法的返回值，最后发出请求，得到回调然后处理值并返回出去。\n\n- CTNetworking 框架没有使用数据模型，原因就是认为模型嵌入模型的时候处理数据很麻烦，另外模型的复用性很差，容易出现类型爆炸，提高维护成本，还有就是不够NSDictionary、NSArray直观,最最重要的一点就是同一API的数据被不同View展示时，难以控制数据转化的代码，它们有可能会散落在任何需要的地方。所以框架使用了 Reformer 的方法去处理返回的数据（NSDictionary）转成 View 需要的数据（NSDictionary）。\n\n- DKNetworking 把 Refromer 部分的实现给改了，依赖了 MJExtension，去实现数据模型数组，因为总感觉NSDictionary很麻烦，难维护就难维护吧，反正项目也不大。\n\n- DKHTTPTool 是我在近期集成出来的框架，主要特性包括：\n\t- 支持缓存策略选择\n\t- 支持链式调用\n\t- 支持 RACSignal 返回\n\t- 支持拦截器、验证器\n\t- 支持直观的Logger输出\n\t- 支持全局请求头、请求参数\n\t- 服务器异常直接弹出异常数据而不是一坨 NSData\n\t- 支持错误码表，统一处理错误\n    \n还有其他的吗？忘记了\n总的来说，这个还是挺管用的,毕竟能支持 RAC,符合我们现在的 \nMVVM+ReactiveCocoa的架构\n\n### MVVM+ReactiveCocoa\n\n- ReactiveCocoa 博大精深，以致于现在都用不到它提供的功能的一半\n- 第二份优秀的源码（虽然跑不起来）[MVVMReactiveCocoa](https://github.com/leichunfeng/MVVMReactiveCocoa)\n- 产出成品[Poi](https://coding.net/u/Arclin/p/Poi/git)\n\n### Navigation-With-ViewModel\n\n 使用 MVVM 模式应该注意的问题\n\n- 以 ViewModel 为驱动引导着整个应用而不是 ViewController\n- ViewModel 中不应该引入任何 UIKit 框架\n- 模块与模块间通过 服务总线 去沟通 , 减少模块之间的耦合\n\n先看看用 ViewModel 进行 push操作的流程\n\n ```\n--------------------------------    \n|        ViewModel A           |   \n---  ----------  ----------  ---   \n\t|\n\t| \n[- initWithService:params:]\n\t| ---------------\n\t| | service bus | --- > - pushViewModel: animated: \n\t| ---------------                 |\n\t|\t\t\t             （HOOK）[rac_responseToSelector:]\n\t|\t\t\t                     |/\n\t|\t\t\t               <DKNavigationProtocol>-- @{ viewModel:viewController}--->navigationController [pushViewController:animated:]\n\t|/\n --------------------------------\n |        ViewModel B           |\n ---  ----------  ----------  ---\n```\n\n说明： ViewModelA 与 ViewControllerA ，ViewModelB 与 ViewControllerB 在 Router 里面通过字典的方式绑定在了一起，然后通过 RAC的方法监听pushViewModel: animated: 方法的执行，然后通过字典得到viewController从而进行真正的 push 操作，大概就是这样子\n\n### 抽出父类和ReactiveCocoa\n\nMVVMReactiveCocoa 通过封装父类的方式来实现这个架构，这些父类已经被我抽出来了，过几天会传上去，然后先写一些使用说明\n\n1. 每个 Vc 对应一个 ViewModel\n2. TableViewController必须对应 ViewModel\n3. ViewModel 的初始化方法在 - initliazed 中\n4. 初始化之前添加一些额外的方法，需要重写 - initWithServer:params:\n5. DKTableViewController是一个二维数组，里面封装的是 viewmodel\n6. cell 要遵循 DKReactiveView 协议\n7. 绑定 cell与 viewModel 就在 ViewController里面重写 configureCell:withObject\n8. 待补充\n\nReativeCocoa 主要是用来实现 MVVM 的融合剂，当然也不一定要用 RAC去实现 MVVM,说实话 RAC 的学习成本还是相当高的，目前已经在尝试 DKRACHTTPTool,用纯 RAC 的方式去实现网络层和数据持久层的封装，另外还有些异常处理之类的,在这里面使用了filter: ignore: thottle: startWith: doNext: catch: try: doComplete: map: flattenMap: flatten: 等等的方法，非常好使，其他的可以看看我的几篇笔记\"使用RAC-DKHTTPTool实践\"、\"RACCommand使用注意\"\n\n最近的一个个人项目 Poi 就实践了这个架构。UI 结构如下\n\n```\n   \t    --------------------------------\n            |     NavigationConroller0     |\n            ---  ----------  ----------  ---\n\t\t\t    |\n \t    --------------------------------\n            |       TabBarController       |\n            ---  ----------  ----------  ---\n\t\t|\t\t\t |\n--------------------------------     --------------------------------   \n|     NavigationConroller1     |     |     NavigationConroller2     |\n---  ----------  ----------  ---     ---  ----------  ----------  ---\n\t\t|                   \t\t    |\n--------------------------------     --------------------------------\n|       ViewConroller1         |     |       ViewConroller2         |\n---  ----------  ----------  --      --------------------------------\n```\n\n默认整个应用的跳转用的是NavigationConroller0，这样子做的原因是使用了一个第三方框架，为了可以在TabBarController中滑动切换。\n当 pushViewModel 执行的时候，有一个 NavigationStack 会拿到最底部的 NavigationController 进行 push，如果 modal 出一个 navigationController,那么这个 navigationcontroller 将会压入NavigationStack ,然后这个 modal 出来的 viewController 后面的页面跳转就用这个 stack最上层的 NavigationController，dismiss 之后就会就会从栈中移除这个 NavigationController\n\n大概就是长这样子\n\n```\n--------------------------------\n|     NavigationConroller0     |  \n---  ----------  ----------  ---    \n\t\t |\tstack + 1\tpush\n--------------------------------    \n|       TabBarController       |    \n---  ----------  ----------  ---  \n\t\t |\t\t           \n--------------------------------   \n|     NavigationConroller1     |    \n---  ----------  ----------  ---    \n\t\t |      nv0 push     \n--------------------------------    \n|       ViewConroller1         |    \n---  ----------  ----------  ---\t  \n\t\t |   \tv1 modal\n--------------------------------    \n|      NavigationConroller2    |    \n---  ----------  ----------  ---\t  \n\t\t |     stack + 1  push   \n--------------------------------    \n|      ViewConroller2\t       |    \n---  ----------  ----------  ---\t\n\t\t| dismiss\n\tstack - 1 pop\n```\n\n### MVVM WithOut ReacitveCocoa\n用 Block 的方式代替 Reactive 的绑定功能。\n\n### 其他\n- BugReporter For iOS\n\t- 和思华一起开发的基于 iOS 的 bug自动反馈系统，一旦发生崩溃事故就会给开发者发送邮件\n- 自动部署系统Jenkines\n- JSPatch 热修复平台\n- UMeng 用户数据统计\n- 等等","source":"_posts/2016-Dankal-iOS-MySummary.md","raw":"---\ntitle: 2016-Dankal-iOS-MySummary\nauthor: Arclin\ntags:\n  - iOS\n  - 杂谈\ncategories:\n  - iOS\nabbrlink: 61929cc2\ndate: 2017-01-24 00:00:00\n---\n总结2016在 Dankal 工作过程中学习到的东西\n\n<!-- more -->\n\n### Main Argument 主要论点\n中介者\n组件化\n封装\nMVVM\nReactiveCocoa\n\n### 基于MVC的组件化设计 CTMediator + （CTNetworking -> DKNetworking -> DKHTTPTool）\nCTMediator和CTNetworking 是我在5-6月份左右看的一套源码，出处是这里,然后去年年底作者又发布了[基于 CTMediator工程实践](http://casatwy.com/modulization_in_action.html)。总的设计思想如下：\n\n### 组件逻辑\n\n- CTMediator 是一种组件化方案，主要是针对大型项目多人开发情况下的一种方案。路由方式是 Targer-Action，通过这种方式进行模块之间的沟通，模块使用私有 pod 进行封装（这个是在第二篇的实践中提出来的），因为目前我们还没接触过这种大型的项目，所以一直停留在理论阶段（也就是虽然我看懂了源码的设计思想但是却没得地方实现），后来启动了觅书项目，打算尝试这种设计，结果发现过于大材小用了。模块的创建要先通过中介者进行注册，调用要通过中介者进行调用，总结一下大概就像这样子：\n\n```\n             --------------------------------------\n             | [CTMediator sharedInstance]        |\n             |                                    |\n             |                openUrl:       <<<<<<<<<  (AppDelegate)  <<<<  Call From Other App With URL\n             |                                    |\n             |                   |                |\n             |                   |/               |\n             |                parseUrl            |\n             |                                    |\n             |                   |                |\n.................................|...............................\n             |                   |                |\n             |                   |/               |\n             |  performTarget:action:params: <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  Call From Native Module\n             |                   |/               |\n             |             -------------          |\n             |             |  runtime  |          |\n             |             -------------          |\n             ---------------.---------.------------\n                           .           .\n                          .             .\n-------------------------------      --------------------------------\n|                       ·     |      |    ·                         |\n|                     ·       |      |     ·                        |\n|           Target            |      |           Target             |\n|                             |      |                              |\n|         /   |   \\           |      |         /   |   \\            |\n|        /    |    \\          |      |        /    |    \\           |\n|                             |      |                              |\n|   Action Action Action ...  |      |   Action Action Action ...   |\n|                             |      |                              |\n|Service  A                   |      | Service  B                   |\n-------------------------------      --------------------------------\n```\n\n这里面包括了内部调用和远程应用调用，远程应用调用因为我们目前还用不着所以先不管，内部调用的流程为了方便理解我举个例子，fromController通过performTarget:action:params:方法传入toController类名和在toController要执行的方法和所需的参数，这样子组件之间就实现了解耦，fromController 只需要知道他想去的地方是 toController和要给什么值出去，甚至这个 controller 存不存在都无所谓，而 toController 只需要遵循协议方法/重写父类方法去的到参数即可，然后里面就可以直接调这个参数，并且这一系列跳转规则和传参规则都通过 CTMediator 中介者去控制。\n\n### 服务层（Service Layer） 或者叫 业务层（Business Layer）\n\n刚刚总结了一下CTMediator的组件间的逻辑,现在来总结一下业务层与 ViewController 层之间的设计.因为虽然是 MVC，那当然也得尽量避免 Mess View Controller ,Service 在这里可以理解为数据仓库+业务逻辑仓库，为的是令ViewController中避免出现像数据 A处理判断完才显示到控件上的情况，尽量能把最直接的数据给 ViewController 显示,利用像下图这种方式，业务层暴露出 Target 和 action供外界调用，调用方法后就进入了CTMediator 进行处理，接下来的事情就像我上面说的一样了。\n\n```\n         --------------------------------\n         |           Service  A         |\n         ---  ----------  ----------  ---\n           |  |        |  |        |  |\n...........|  |........|  |........|  |...........\n.          |  |        |  |        |  |          .\n.        ---  ---    ---  ---    ---  ---        .\n.        |action|    |action|    |action|        .\n.        ---|----    -----|--    --|-----        .\n.           |             |        |             .\n.           |             |        |             .\n.       ----|------     --|--------|--           .\n.       |Target_A1|     |  Target_A2 |           .\n.       -----------     --------------           .\n..................................................\n```\n\n### CTNetworking -> DKNetworking -> DKHTTPTool\n\n- CTNetworking 是一个基于AFNetworking的开源网络层组件，经过改装之后我组装出了 DKNetworking（虽然后面发现有 RAC神器之后就觉得这个东西不够轻便了）。\n\n- CTNetworking 解决了以下几个问题\n\t- 使用哪种交互模式来跟业务层做对接？\n\t- 是否有必要将API返回的数据封装成对象然后再交付给业务层？\n\t- 使用集约化调用方式还是离散型调用方式去调用API？\n\n- 上面三个问题分别给出的答案是\n\t- 代理模式\n\t- 没必要\n\t- 离散型\n\n- CTNetworking考虑的东西相当地多，除了上面几个问题之外，还考虑到了网络层安全机制（数据传输，HTTPS）,链接环节的优化（链接传输量和链接复用）等，一开始看源码也是看的很懵逼\n- 通过协议的方式进行组件内的方法封装\n\n|协议名|解释|\n|----|----|\n|CTAPIManagerApiCallBackDelegate|回调协议|\n|CTAPIManagerCallbackDataReformer|负责重新组装API数据的对象|\n|CTAPIManagerValidator|验证器验证参数和返回|\n|CTAPIManagerParamSourceDelegate|参数源|\n|CTAPIManager|CTAPIBaseManager的派生类必须符合这个protocal|\n|CTAPIManagerInterceptor|拦截器，拦截参数和回调|\n\n- 用协议的好处就是各取所需。当你想要统一管理所有回调的时候，那你这个类只要遵循`CTAPIManagerApiCallBackDelegate`代理和实现对应的方法，如果你这个类想要拦截参数，那么就遵循`CTAPIManagerInterceptor`协议并实现对应的方法，大抵就是这种思想，然后底层就会进行各种判断并拼接各个协议的方法的返回值，最后发出请求，得到回调然后处理值并返回出去。\n\n- CTNetworking 框架没有使用数据模型，原因就是认为模型嵌入模型的时候处理数据很麻烦，另外模型的复用性很差，容易出现类型爆炸，提高维护成本，还有就是不够NSDictionary、NSArray直观,最最重要的一点就是同一API的数据被不同View展示时，难以控制数据转化的代码，它们有可能会散落在任何需要的地方。所以框架使用了 Reformer 的方法去处理返回的数据（NSDictionary）转成 View 需要的数据（NSDictionary）。\n\n- DKNetworking 把 Refromer 部分的实现给改了，依赖了 MJExtension，去实现数据模型数组，因为总感觉NSDictionary很麻烦，难维护就难维护吧，反正项目也不大。\n\n- DKHTTPTool 是我在近期集成出来的框架，主要特性包括：\n\t- 支持缓存策略选择\n\t- 支持链式调用\n\t- 支持 RACSignal 返回\n\t- 支持拦截器、验证器\n\t- 支持直观的Logger输出\n\t- 支持全局请求头、请求参数\n\t- 服务器异常直接弹出异常数据而不是一坨 NSData\n\t- 支持错误码表，统一处理错误\n    \n还有其他的吗？忘记了\n总的来说，这个还是挺管用的,毕竟能支持 RAC,符合我们现在的 \nMVVM+ReactiveCocoa的架构\n\n### MVVM+ReactiveCocoa\n\n- ReactiveCocoa 博大精深，以致于现在都用不到它提供的功能的一半\n- 第二份优秀的源码（虽然跑不起来）[MVVMReactiveCocoa](https://github.com/leichunfeng/MVVMReactiveCocoa)\n- 产出成品[Poi](https://coding.net/u/Arclin/p/Poi/git)\n\n### Navigation-With-ViewModel\n\n 使用 MVVM 模式应该注意的问题\n\n- 以 ViewModel 为驱动引导着整个应用而不是 ViewController\n- ViewModel 中不应该引入任何 UIKit 框架\n- 模块与模块间通过 服务总线 去沟通 , 减少模块之间的耦合\n\n先看看用 ViewModel 进行 push操作的流程\n\n ```\n--------------------------------    \n|        ViewModel A           |   \n---  ----------  ----------  ---   \n\t|\n\t| \n[- initWithService:params:]\n\t| ---------------\n\t| | service bus | --- > - pushViewModel: animated: \n\t| ---------------                 |\n\t|\t\t\t             （HOOK）[rac_responseToSelector:]\n\t|\t\t\t                     |/\n\t|\t\t\t               <DKNavigationProtocol>-- @{ viewModel:viewController}--->navigationController [pushViewController:animated:]\n\t|/\n --------------------------------\n |        ViewModel B           |\n ---  ----------  ----------  ---\n```\n\n说明： ViewModelA 与 ViewControllerA ，ViewModelB 与 ViewControllerB 在 Router 里面通过字典的方式绑定在了一起，然后通过 RAC的方法监听pushViewModel: animated: 方法的执行，然后通过字典得到viewController从而进行真正的 push 操作，大概就是这样子\n\n### 抽出父类和ReactiveCocoa\n\nMVVMReactiveCocoa 通过封装父类的方式来实现这个架构，这些父类已经被我抽出来了，过几天会传上去，然后先写一些使用说明\n\n1. 每个 Vc 对应一个 ViewModel\n2. TableViewController必须对应 ViewModel\n3. ViewModel 的初始化方法在 - initliazed 中\n4. 初始化之前添加一些额外的方法，需要重写 - initWithServer:params:\n5. DKTableViewController是一个二维数组，里面封装的是 viewmodel\n6. cell 要遵循 DKReactiveView 协议\n7. 绑定 cell与 viewModel 就在 ViewController里面重写 configureCell:withObject\n8. 待补充\n\nReativeCocoa 主要是用来实现 MVVM 的融合剂，当然也不一定要用 RAC去实现 MVVM,说实话 RAC 的学习成本还是相当高的，目前已经在尝试 DKRACHTTPTool,用纯 RAC 的方式去实现网络层和数据持久层的封装，另外还有些异常处理之类的,在这里面使用了filter: ignore: thottle: startWith: doNext: catch: try: doComplete: map: flattenMap: flatten: 等等的方法，非常好使，其他的可以看看我的几篇笔记\"使用RAC-DKHTTPTool实践\"、\"RACCommand使用注意\"\n\n最近的一个个人项目 Poi 就实践了这个架构。UI 结构如下\n\n```\n   \t    --------------------------------\n            |     NavigationConroller0     |\n            ---  ----------  ----------  ---\n\t\t\t    |\n \t    --------------------------------\n            |       TabBarController       |\n            ---  ----------  ----------  ---\n\t\t|\t\t\t |\n--------------------------------     --------------------------------   \n|     NavigationConroller1     |     |     NavigationConroller2     |\n---  ----------  ----------  ---     ---  ----------  ----------  ---\n\t\t|                   \t\t    |\n--------------------------------     --------------------------------\n|       ViewConroller1         |     |       ViewConroller2         |\n---  ----------  ----------  --      --------------------------------\n```\n\n默认整个应用的跳转用的是NavigationConroller0，这样子做的原因是使用了一个第三方框架，为了可以在TabBarController中滑动切换。\n当 pushViewModel 执行的时候，有一个 NavigationStack 会拿到最底部的 NavigationController 进行 push，如果 modal 出一个 navigationController,那么这个 navigationcontroller 将会压入NavigationStack ,然后这个 modal 出来的 viewController 后面的页面跳转就用这个 stack最上层的 NavigationController，dismiss 之后就会就会从栈中移除这个 NavigationController\n\n大概就是长这样子\n\n```\n--------------------------------\n|     NavigationConroller0     |  \n---  ----------  ----------  ---    \n\t\t |\tstack + 1\tpush\n--------------------------------    \n|       TabBarController       |    \n---  ----------  ----------  ---  \n\t\t |\t\t           \n--------------------------------   \n|     NavigationConroller1     |    \n---  ----------  ----------  ---    \n\t\t |      nv0 push     \n--------------------------------    \n|       ViewConroller1         |    \n---  ----------  ----------  ---\t  \n\t\t |   \tv1 modal\n--------------------------------    \n|      NavigationConroller2    |    \n---  ----------  ----------  ---\t  \n\t\t |     stack + 1  push   \n--------------------------------    \n|      ViewConroller2\t       |    \n---  ----------  ----------  ---\t\n\t\t| dismiss\n\tstack - 1 pop\n```\n\n### MVVM WithOut ReacitveCocoa\n用 Block 的方式代替 Reactive 的绑定功能。\n\n### 其他\n- BugReporter For iOS\n\t- 和思华一起开发的基于 iOS 的 bug自动反馈系统，一旦发生崩溃事故就会给开发者发送邮件\n- 自动部署系统Jenkines\n- JSPatch 热修复平台\n- UMeng 用户数据统计\n- 等等","slug":"2016-Dankal-iOS-MySummary","published":1,"updated":"2018-05-10T06:51:35.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcg40000ldxu1rxmz3dp","content":"<p>总结2016在 Dankal 工作过程中学习到的东西</p>\n<a id=\"more\"></a>\n<h3 id=\"Main-Argument-主要论点\"><a href=\"#Main-Argument-主要论点\" class=\"headerlink\" title=\"Main Argument 主要论点\"></a>Main Argument 主要论点</h3><p>中介者<br>组件化<br>封装<br>MVVM<br>ReactiveCocoa</p>\n<h3 id=\"基于MVC的组件化设计-CTMediator-（CTNetworking-gt-DKNetworking-gt-DKHTTPTool）\"><a href=\"#基于MVC的组件化设计-CTMediator-（CTNetworking-gt-DKNetworking-gt-DKHTTPTool）\" class=\"headerlink\" title=\"基于MVC的组件化设计 CTMediator + （CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool）\"></a>基于MVC的组件化设计 CTMediator + （CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool）</h3><p>CTMediator和CTNetworking 是我在5-6月份左右看的一套源码，出处是这里,然后去年年底作者又发布了<a href=\"http://casatwy.com/modulization_in_action.html\" target=\"_blank\" rel=\"noopener\">基于 CTMediator工程实践</a>。总的设计思想如下：</p>\n<h3 id=\"组件逻辑\"><a href=\"#组件逻辑\" class=\"headerlink\" title=\"组件逻辑\"></a>组件逻辑</h3><ul>\n<li>CTMediator 是一种组件化方案，主要是针对大型项目多人开发情况下的一种方案。路由方式是 Targer-Action，通过这种方式进行模块之间的沟通，模块使用私有 pod 进行封装（这个是在第二篇的实践中提出来的），因为目前我们还没接触过这种大型的项目，所以一直停留在理论阶段（也就是虽然我看懂了源码的设计思想但是却没得地方实现），后来启动了觅书项目，打算尝试这种设计，结果发现过于大材小用了。模块的创建要先通过中介者进行注册，调用要通过中介者进行调用，总结一下大概就像这样子：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">             --------------------------------------</span><br><span class=\"line\">             | [CTMediator sharedInstance]        |</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                openUrl:       &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  (AppDelegate)  &lt;&lt;&lt;&lt;  Call From Other App With URL</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">             |                   |/               |</span><br><span class=\"line\">             |                parseUrl            |</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">.................................|...............................</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">             |                   |/               |</span><br><span class=\"line\">             |  performTarget:action:params: &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  Call From Native Module</span><br><span class=\"line\">             |                   |/               |</span><br><span class=\"line\">             |             -------------          |</span><br><span class=\"line\">             |             |  runtime  |          |</span><br><span class=\"line\">             |             -------------          |</span><br><span class=\"line\">             ---------------.---------.------------</span><br><span class=\"line\">                           .           .</span><br><span class=\"line\">                          .             .</span><br><span class=\"line\">-------------------------------      --------------------------------</span><br><span class=\"line\">|                       ·     |      |    ·                         |</span><br><span class=\"line\">|                     ·       |      |     ·                        |</span><br><span class=\"line\">|           Target            |      |           Target             |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|         /   |   \\           |      |         /   |   \\            |</span><br><span class=\"line\">|        /    |    \\          |      |        /    |    \\           |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|   Action Action Action ...  |      |   Action Action Action ...   |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|Service  A                   |      | Service  B                   |</span><br><span class=\"line\">-------------------------------      --------------------------------</span><br></pre></td></tr></table></figure>\n<p>这里面包括了内部调用和远程应用调用，远程应用调用因为我们目前还用不着所以先不管，内部调用的流程为了方便理解我举个例子，fromController通过performTarget:action:params:方法传入toController类名和在toController要执行的方法和所需的参数，这样子组件之间就实现了解耦，fromController 只需要知道他想去的地方是 toController和要给什么值出去，甚至这个 controller 存不存在都无所谓，而 toController 只需要遵循协议方法/重写父类方法去的到参数即可，然后里面就可以直接调这个参数，并且这一系列跳转规则和传参规则都通过 CTMediator 中介者去控制。</p>\n<h3 id=\"服务层（Service-Layer）-或者叫-业务层（Business-Layer）\"><a href=\"#服务层（Service-Layer）-或者叫-业务层（Business-Layer）\" class=\"headerlink\" title=\"服务层（Service Layer） 或者叫 业务层（Business Layer）\"></a>服务层（Service Layer） 或者叫 业务层（Business Layer）</h3><p>刚刚总结了一下CTMediator的组件间的逻辑,现在来总结一下业务层与 ViewController 层之间的设计.因为虽然是 MVC，那当然也得尽量避免 Mess View Controller ,Service 在这里可以理解为数据仓库+业务逻辑仓库，为的是令ViewController中避免出现像数据 A处理判断完才显示到控件上的情况，尽量能把最直接的数据给 ViewController 显示,利用像下图这种方式，业务层暴露出 Target 和 action供外界调用，调用方法后就进入了CTMediator 进行处理，接下来的事情就像我上面说的一样了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         --------------------------------</span><br><span class=\"line\">         |           Service  A         |</span><br><span class=\"line\">         ---  ----------  ----------  ---</span><br><span class=\"line\">           |  |        |  |        |  |</span><br><span class=\"line\">...........|  |........|  |........|  |...........</span><br><span class=\"line\">.          |  |        |  |        |  |          .</span><br><span class=\"line\">.        ---  ---    ---  ---    ---  ---        .</span><br><span class=\"line\">.        |action|    |action|    |action|        .</span><br><span class=\"line\">.        ---|----    -----|--    --|-----        .</span><br><span class=\"line\">.           |             |        |             .</span><br><span class=\"line\">.           |             |        |             .</span><br><span class=\"line\">.       ----|------     --|--------|--           .</span><br><span class=\"line\">.       |Target_A1|     |  Target_A2 |           .</span><br><span class=\"line\">.       -----------     --------------           .</span><br><span class=\"line\">..................................................</span><br></pre></td></tr></table></figure>\n<h3 id=\"CTNetworking-gt-DKNetworking-gt-DKHTTPTool\"><a href=\"#CTNetworking-gt-DKNetworking-gt-DKHTTPTool\" class=\"headerlink\" title=\"CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool\"></a>CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool</h3><ul>\n<li><p>CTNetworking 是一个基于AFNetworking的开源网络层组件，经过改装之后我组装出了 DKNetworking（虽然后面发现有 RAC神器之后就觉得这个东西不够轻便了）。</p>\n</li>\n<li><p>CTNetworking 解决了以下几个问题</p>\n<ul>\n<li>使用哪种交互模式来跟业务层做对接？</li>\n<li>是否有必要将API返回的数据封装成对象然后再交付给业务层？</li>\n<li>使用集约化调用方式还是离散型调用方式去调用API？</li>\n</ul>\n</li>\n<li><p>上面三个问题分别给出的答案是</p>\n<ul>\n<li>代理模式</li>\n<li>没必要</li>\n<li>离散型</li>\n</ul>\n</li>\n<li><p>CTNetworking考虑的东西相当地多，除了上面几个问题之外，还考虑到了网络层安全机制（数据传输，HTTPS）,链接环节的优化（链接传输量和链接复用）等，一开始看源码也是看的很懵逼</p>\n</li>\n<li>通过协议的方式进行组件内的方法封装</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>协议名</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CTAPIManagerApiCallBackDelegate</td>\n<td>回调协议</td>\n</tr>\n<tr>\n<td>CTAPIManagerCallbackDataReformer</td>\n<td>负责重新组装API数据的对象</td>\n</tr>\n<tr>\n<td>CTAPIManagerValidator</td>\n<td>验证器验证参数和返回</td>\n</tr>\n<tr>\n<td>CTAPIManagerParamSourceDelegate</td>\n<td>参数源</td>\n</tr>\n<tr>\n<td>CTAPIManager</td>\n<td>CTAPIBaseManager的派生类必须符合这个protocal</td>\n</tr>\n<tr>\n<td>CTAPIManagerInterceptor</td>\n<td>拦截器，拦截参数和回调</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>用协议的好处就是各取所需。当你想要统一管理所有回调的时候，那你这个类只要遵循<code>CTAPIManagerApiCallBackDelegate</code>代理和实现对应的方法，如果你这个类想要拦截参数，那么就遵循<code>CTAPIManagerInterceptor</code>协议并实现对应的方法，大抵就是这种思想，然后底层就会进行各种判断并拼接各个协议的方法的返回值，最后发出请求，得到回调然后处理值并返回出去。</p>\n</li>\n<li><p>CTNetworking 框架没有使用数据模型，原因就是认为模型嵌入模型的时候处理数据很麻烦，另外模型的复用性很差，容易出现类型爆炸，提高维护成本，还有就是不够NSDictionary、NSArray直观,最最重要的一点就是同一API的数据被不同View展示时，难以控制数据转化的代码，它们有可能会散落在任何需要的地方。所以框架使用了 Reformer 的方法去处理返回的数据（NSDictionary）转成 View 需要的数据（NSDictionary）。</p>\n</li>\n<li><p>DKNetworking 把 Refromer 部分的实现给改了，依赖了 MJExtension，去实现数据模型数组，因为总感觉NSDictionary很麻烦，难维护就难维护吧，反正项目也不大。</p>\n</li>\n<li><p>DKHTTPTool 是我在近期集成出来的框架，主要特性包括：</p>\n<ul>\n<li>支持缓存策略选择</li>\n<li>支持链式调用</li>\n<li>支持 RACSignal 返回</li>\n<li>支持拦截器、验证器</li>\n<li>支持直观的Logger输出</li>\n<li>支持全局请求头、请求参数</li>\n<li>服务器异常直接弹出异常数据而不是一坨 NSData</li>\n<li>支持错误码表，统一处理错误</li>\n</ul>\n</li>\n</ul>\n<p>还有其他的吗？忘记了<br>总的来说，这个还是挺管用的,毕竟能支持 RAC,符合我们现在的<br>MVVM+ReactiveCocoa的架构</p>\n<h3 id=\"MVVM-ReactiveCocoa\"><a href=\"#MVVM-ReactiveCocoa\" class=\"headerlink\" title=\"MVVM+ReactiveCocoa\"></a>MVVM+ReactiveCocoa</h3><ul>\n<li>ReactiveCocoa 博大精深，以致于现在都用不到它提供的功能的一半</li>\n<li>第二份优秀的源码（虽然跑不起来）<a href=\"https://github.com/leichunfeng/MVVMReactiveCocoa\" target=\"_blank\" rel=\"noopener\">MVVMReactiveCocoa</a></li>\n<li>产出成品<a href=\"https://coding.net/u/Arclin/p/Poi/git\" target=\"_blank\" rel=\"noopener\">Poi</a></li>\n</ul>\n<h3 id=\"Navigation-With-ViewModel\"><a href=\"#Navigation-With-ViewModel\" class=\"headerlink\" title=\"Navigation-With-ViewModel\"></a>Navigation-With-ViewModel</h3><p> 使用 MVVM 模式应该注意的问题</p>\n<ul>\n<li>以 ViewModel 为驱动引导着整个应用而不是 ViewController</li>\n<li>ViewModel 中不应该引入任何 UIKit 框架</li>\n<li>模块与模块间通过 服务总线 去沟通 , 减少模块之间的耦合</li>\n</ul>\n<p>先看看用 ViewModel 进行 push操作的流程</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|        ViewModel A           |   </span><br><span class=\"line\">---  ----------  ----------  ---   </span><br><span class=\"line\">\t|</span><br><span class=\"line\">\t| </span><br><span class=\"line\">[- initWithService:params:]</span><br><span class=\"line\">\t| ---------------</span><br><span class=\"line\">\t| | service bus | --- &gt; - pushViewModel: animated: </span><br><span class=\"line\">\t| ---------------                 |</span><br><span class=\"line\">\t|\t\t\t             （HOOK）[rac_responseToSelector:]</span><br><span class=\"line\">\t|\t\t\t                     |/</span><br><span class=\"line\">\t|\t\t\t               &lt;DKNavigationProtocol&gt;-- @&#123; viewModel:viewController&#125;---&gt;navigationController [pushViewController:animated:]</span><br><span class=\"line\">\t|/</span><br><span class=\"line\"> --------------------------------</span><br><span class=\"line\"> |        ViewModel B           |</span><br><span class=\"line\"> ---  ----------  ----------  ---</span><br></pre></td></tr></table></figure>\n<p>说明： ViewModelA 与 ViewControllerA ，ViewModelB 与 ViewControllerB 在 Router 里面通过字典的方式绑定在了一起，然后通过 RAC的方法监听pushViewModel: animated: 方法的执行，然后通过字典得到viewController从而进行真正的 push 操作，大概就是这样子</p>\n<h3 id=\"抽出父类和ReactiveCocoa\"><a href=\"#抽出父类和ReactiveCocoa\" class=\"headerlink\" title=\"抽出父类和ReactiveCocoa\"></a>抽出父类和ReactiveCocoa</h3><p>MVVMReactiveCocoa 通过封装父类的方式来实现这个架构，这些父类已经被我抽出来了，过几天会传上去，然后先写一些使用说明</p>\n<ol>\n<li>每个 Vc 对应一个 ViewModel</li>\n<li>TableViewController必须对应 ViewModel</li>\n<li>ViewModel 的初始化方法在 - initliazed 中</li>\n<li>初始化之前添加一些额外的方法，需要重写 - initWithServer:params:</li>\n<li>DKTableViewController是一个二维数组，里面封装的是 viewmodel</li>\n<li>cell 要遵循 DKReactiveView 协议</li>\n<li>绑定 cell与 viewModel 就在 ViewController里面重写 configureCell:withObject</li>\n<li>待补充</li>\n</ol>\n<p>ReativeCocoa 主要是用来实现 MVVM 的融合剂，当然也不一定要用 RAC去实现 MVVM,说实话 RAC 的学习成本还是相当高的，目前已经在尝试 DKRACHTTPTool,用纯 RAC 的方式去实现网络层和数据持久层的封装，另外还有些异常处理之类的,在这里面使用了filter: ignore: thottle: startWith: doNext: catch: try: doComplete: map: flattenMap: flatten: 等等的方法，非常好使，其他的可以看看我的几篇笔记”使用RAC-DKHTTPTool实践”、”RACCommand使用注意”</p>\n<p>最近的一个个人项目 Poi 就实践了这个架构。UI 结构如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   \t    --------------------------------</span><br><span class=\"line\">            |     NavigationConroller0     |</span><br><span class=\"line\">            ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t\t    |</span><br><span class=\"line\"> \t    --------------------------------</span><br><span class=\"line\">            |       TabBarController       |</span><br><span class=\"line\">            ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t|\t\t\t |</span><br><span class=\"line\">--------------------------------     --------------------------------   </span><br><span class=\"line\">|     NavigationConroller1     |     |     NavigationConroller2     |</span><br><span class=\"line\">---  ----------  ----------  ---     ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t|                   \t\t    |</span><br><span class=\"line\">--------------------------------     --------------------------------</span><br><span class=\"line\">|       ViewConroller1         |     |       ViewConroller2         |</span><br><span class=\"line\">---  ----------  ----------  --      --------------------------------</span><br></pre></td></tr></table></figure>\n<p>默认整个应用的跳转用的是NavigationConroller0，这样子做的原因是使用了一个第三方框架，为了可以在TabBarController中滑动切换。<br>当 pushViewModel 执行的时候，有一个 NavigationStack 会拿到最底部的 NavigationController 进行 push，如果 modal 出一个 navigationController,那么这个 navigationcontroller 将会压入NavigationStack ,然后这个 modal 出来的 viewController 后面的页面跳转就用这个 stack最上层的 NavigationController，dismiss 之后就会就会从栈中移除这个 NavigationController</p>\n<p>大概就是长这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------------------------------</span><br><span class=\"line\">|     NavigationConroller0     |  </span><br><span class=\"line\">---  ----------  ----------  ---    </span><br><span class=\"line\">\t\t |\tstack + 1\tpush</span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|       TabBarController       |    </span><br><span class=\"line\">---  ----------  ----------  ---  </span><br><span class=\"line\">\t\t |\t\t           </span><br><span class=\"line\">--------------------------------   </span><br><span class=\"line\">|     NavigationConroller1     |    </span><br><span class=\"line\">---  ----------  ----------  ---    </span><br><span class=\"line\">\t\t |      nv0 push     </span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|       ViewConroller1         |    </span><br><span class=\"line\">---  ----------  ----------  ---\t  </span><br><span class=\"line\">\t\t |   \tv1 modal</span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|      NavigationConroller2    |    </span><br><span class=\"line\">---  ----------  ----------  ---\t  </span><br><span class=\"line\">\t\t |     stack + 1  push   </span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|      ViewConroller2\t       |    </span><br><span class=\"line\">---  ----------  ----------  ---\t</span><br><span class=\"line\">\t\t| dismiss</span><br><span class=\"line\">\tstack - 1 pop</span><br></pre></td></tr></table></figure>\n<h3 id=\"MVVM-WithOut-ReacitveCocoa\"><a href=\"#MVVM-WithOut-ReacitveCocoa\" class=\"headerlink\" title=\"MVVM WithOut ReacitveCocoa\"></a>MVVM WithOut ReacitveCocoa</h3><p>用 Block 的方式代替 Reactive 的绑定功能。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>BugReporter For iOS<ul>\n<li>和思华一起开发的基于 iOS 的 bug自动反馈系统，一旦发生崩溃事故就会给开发者发送邮件</li>\n</ul>\n</li>\n<li>自动部署系统Jenkines</li>\n<li>JSPatch 热修复平台</li>\n<li>UMeng 用户数据统计</li>\n<li>等等</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>总结2016在 Dankal 工作过程中学习到的东西</p>","more":"<h3 id=\"Main-Argument-主要论点\"><a href=\"#Main-Argument-主要论点\" class=\"headerlink\" title=\"Main Argument 主要论点\"></a>Main Argument 主要论点</h3><p>中介者<br>组件化<br>封装<br>MVVM<br>ReactiveCocoa</p>\n<h3 id=\"基于MVC的组件化设计-CTMediator-（CTNetworking-gt-DKNetworking-gt-DKHTTPTool）\"><a href=\"#基于MVC的组件化设计-CTMediator-（CTNetworking-gt-DKNetworking-gt-DKHTTPTool）\" class=\"headerlink\" title=\"基于MVC的组件化设计 CTMediator + （CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool）\"></a>基于MVC的组件化设计 CTMediator + （CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool）</h3><p>CTMediator和CTNetworking 是我在5-6月份左右看的一套源码，出处是这里,然后去年年底作者又发布了<a href=\"http://casatwy.com/modulization_in_action.html\" target=\"_blank\" rel=\"noopener\">基于 CTMediator工程实践</a>。总的设计思想如下：</p>\n<h3 id=\"组件逻辑\"><a href=\"#组件逻辑\" class=\"headerlink\" title=\"组件逻辑\"></a>组件逻辑</h3><ul>\n<li>CTMediator 是一种组件化方案，主要是针对大型项目多人开发情况下的一种方案。路由方式是 Targer-Action，通过这种方式进行模块之间的沟通，模块使用私有 pod 进行封装（这个是在第二篇的实践中提出来的），因为目前我们还没接触过这种大型的项目，所以一直停留在理论阶段（也就是虽然我看懂了源码的设计思想但是却没得地方实现），后来启动了觅书项目，打算尝试这种设计，结果发现过于大材小用了。模块的创建要先通过中介者进行注册，调用要通过中介者进行调用，总结一下大概就像这样子：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">             --------------------------------------</span><br><span class=\"line\">             | [CTMediator sharedInstance]        |</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                openUrl:       &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  (AppDelegate)  &lt;&lt;&lt;&lt;  Call From Other App With URL</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">             |                   |/               |</span><br><span class=\"line\">             |                parseUrl            |</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">.................................|...............................</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">             |                   |/               |</span><br><span class=\"line\">             |  performTarget:action:params: &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  Call From Native Module</span><br><span class=\"line\">             |                   |/               |</span><br><span class=\"line\">             |             -------------          |</span><br><span class=\"line\">             |             |  runtime  |          |</span><br><span class=\"line\">             |             -------------          |</span><br><span class=\"line\">             ---------------.---------.------------</span><br><span class=\"line\">                           .           .</span><br><span class=\"line\">                          .             .</span><br><span class=\"line\">-------------------------------      --------------------------------</span><br><span class=\"line\">|                       ·     |      |    ·                         |</span><br><span class=\"line\">|                     ·       |      |     ·                        |</span><br><span class=\"line\">|           Target            |      |           Target             |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|         /   |   \\           |      |         /   |   \\            |</span><br><span class=\"line\">|        /    |    \\          |      |        /    |    \\           |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|   Action Action Action ...  |      |   Action Action Action ...   |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|Service  A                   |      | Service  B                   |</span><br><span class=\"line\">-------------------------------      --------------------------------</span><br></pre></td></tr></table></figure>\n<p>这里面包括了内部调用和远程应用调用，远程应用调用因为我们目前还用不着所以先不管，内部调用的流程为了方便理解我举个例子，fromController通过performTarget:action:params:方法传入toController类名和在toController要执行的方法和所需的参数，这样子组件之间就实现了解耦，fromController 只需要知道他想去的地方是 toController和要给什么值出去，甚至这个 controller 存不存在都无所谓，而 toController 只需要遵循协议方法/重写父类方法去的到参数即可，然后里面就可以直接调这个参数，并且这一系列跳转规则和传参规则都通过 CTMediator 中介者去控制。</p>\n<h3 id=\"服务层（Service-Layer）-或者叫-业务层（Business-Layer）\"><a href=\"#服务层（Service-Layer）-或者叫-业务层（Business-Layer）\" class=\"headerlink\" title=\"服务层（Service Layer） 或者叫 业务层（Business Layer）\"></a>服务层（Service Layer） 或者叫 业务层（Business Layer）</h3><p>刚刚总结了一下CTMediator的组件间的逻辑,现在来总结一下业务层与 ViewController 层之间的设计.因为虽然是 MVC，那当然也得尽量避免 Mess View Controller ,Service 在这里可以理解为数据仓库+业务逻辑仓库，为的是令ViewController中避免出现像数据 A处理判断完才显示到控件上的情况，尽量能把最直接的数据给 ViewController 显示,利用像下图这种方式，业务层暴露出 Target 和 action供外界调用，调用方法后就进入了CTMediator 进行处理，接下来的事情就像我上面说的一样了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         --------------------------------</span><br><span class=\"line\">         |           Service  A         |</span><br><span class=\"line\">         ---  ----------  ----------  ---</span><br><span class=\"line\">           |  |        |  |        |  |</span><br><span class=\"line\">...........|  |........|  |........|  |...........</span><br><span class=\"line\">.          |  |        |  |        |  |          .</span><br><span class=\"line\">.        ---  ---    ---  ---    ---  ---        .</span><br><span class=\"line\">.        |action|    |action|    |action|        .</span><br><span class=\"line\">.        ---|----    -----|--    --|-----        .</span><br><span class=\"line\">.           |             |        |             .</span><br><span class=\"line\">.           |             |        |             .</span><br><span class=\"line\">.       ----|------     --|--------|--           .</span><br><span class=\"line\">.       |Target_A1|     |  Target_A2 |           .</span><br><span class=\"line\">.       -----------     --------------           .</span><br><span class=\"line\">..................................................</span><br></pre></td></tr></table></figure>\n<h3 id=\"CTNetworking-gt-DKNetworking-gt-DKHTTPTool\"><a href=\"#CTNetworking-gt-DKNetworking-gt-DKHTTPTool\" class=\"headerlink\" title=\"CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool\"></a>CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool</h3><ul>\n<li><p>CTNetworking 是一个基于AFNetworking的开源网络层组件，经过改装之后我组装出了 DKNetworking（虽然后面发现有 RAC神器之后就觉得这个东西不够轻便了）。</p>\n</li>\n<li><p>CTNetworking 解决了以下几个问题</p>\n<ul>\n<li>使用哪种交互模式来跟业务层做对接？</li>\n<li>是否有必要将API返回的数据封装成对象然后再交付给业务层？</li>\n<li>使用集约化调用方式还是离散型调用方式去调用API？</li>\n</ul>\n</li>\n<li><p>上面三个问题分别给出的答案是</p>\n<ul>\n<li>代理模式</li>\n<li>没必要</li>\n<li>离散型</li>\n</ul>\n</li>\n<li><p>CTNetworking考虑的东西相当地多，除了上面几个问题之外，还考虑到了网络层安全机制（数据传输，HTTPS）,链接环节的优化（链接传输量和链接复用）等，一开始看源码也是看的很懵逼</p>\n</li>\n<li>通过协议的方式进行组件内的方法封装</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>协议名</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CTAPIManagerApiCallBackDelegate</td>\n<td>回调协议</td>\n</tr>\n<tr>\n<td>CTAPIManagerCallbackDataReformer</td>\n<td>负责重新组装API数据的对象</td>\n</tr>\n<tr>\n<td>CTAPIManagerValidator</td>\n<td>验证器验证参数和返回</td>\n</tr>\n<tr>\n<td>CTAPIManagerParamSourceDelegate</td>\n<td>参数源</td>\n</tr>\n<tr>\n<td>CTAPIManager</td>\n<td>CTAPIBaseManager的派生类必须符合这个protocal</td>\n</tr>\n<tr>\n<td>CTAPIManagerInterceptor</td>\n<td>拦截器，拦截参数和回调</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>用协议的好处就是各取所需。当你想要统一管理所有回调的时候，那你这个类只要遵循<code>CTAPIManagerApiCallBackDelegate</code>代理和实现对应的方法，如果你这个类想要拦截参数，那么就遵循<code>CTAPIManagerInterceptor</code>协议并实现对应的方法，大抵就是这种思想，然后底层就会进行各种判断并拼接各个协议的方法的返回值，最后发出请求，得到回调然后处理值并返回出去。</p>\n</li>\n<li><p>CTNetworking 框架没有使用数据模型，原因就是认为模型嵌入模型的时候处理数据很麻烦，另外模型的复用性很差，容易出现类型爆炸，提高维护成本，还有就是不够NSDictionary、NSArray直观,最最重要的一点就是同一API的数据被不同View展示时，难以控制数据转化的代码，它们有可能会散落在任何需要的地方。所以框架使用了 Reformer 的方法去处理返回的数据（NSDictionary）转成 View 需要的数据（NSDictionary）。</p>\n</li>\n<li><p>DKNetworking 把 Refromer 部分的实现给改了，依赖了 MJExtension，去实现数据模型数组，因为总感觉NSDictionary很麻烦，难维护就难维护吧，反正项目也不大。</p>\n</li>\n<li><p>DKHTTPTool 是我在近期集成出来的框架，主要特性包括：</p>\n<ul>\n<li>支持缓存策略选择</li>\n<li>支持链式调用</li>\n<li>支持 RACSignal 返回</li>\n<li>支持拦截器、验证器</li>\n<li>支持直观的Logger输出</li>\n<li>支持全局请求头、请求参数</li>\n<li>服务器异常直接弹出异常数据而不是一坨 NSData</li>\n<li>支持错误码表，统一处理错误</li>\n</ul>\n</li>\n</ul>\n<p>还有其他的吗？忘记了<br>总的来说，这个还是挺管用的,毕竟能支持 RAC,符合我们现在的<br>MVVM+ReactiveCocoa的架构</p>\n<h3 id=\"MVVM-ReactiveCocoa\"><a href=\"#MVVM-ReactiveCocoa\" class=\"headerlink\" title=\"MVVM+ReactiveCocoa\"></a>MVVM+ReactiveCocoa</h3><ul>\n<li>ReactiveCocoa 博大精深，以致于现在都用不到它提供的功能的一半</li>\n<li>第二份优秀的源码（虽然跑不起来）<a href=\"https://github.com/leichunfeng/MVVMReactiveCocoa\" target=\"_blank\" rel=\"noopener\">MVVMReactiveCocoa</a></li>\n<li>产出成品<a href=\"https://coding.net/u/Arclin/p/Poi/git\" target=\"_blank\" rel=\"noopener\">Poi</a></li>\n</ul>\n<h3 id=\"Navigation-With-ViewModel\"><a href=\"#Navigation-With-ViewModel\" class=\"headerlink\" title=\"Navigation-With-ViewModel\"></a>Navigation-With-ViewModel</h3><p> 使用 MVVM 模式应该注意的问题</p>\n<ul>\n<li>以 ViewModel 为驱动引导着整个应用而不是 ViewController</li>\n<li>ViewModel 中不应该引入任何 UIKit 框架</li>\n<li>模块与模块间通过 服务总线 去沟通 , 减少模块之间的耦合</li>\n</ul>\n<p>先看看用 ViewModel 进行 push操作的流程</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|        ViewModel A           |   </span><br><span class=\"line\">---  ----------  ----------  ---   </span><br><span class=\"line\">\t|</span><br><span class=\"line\">\t| </span><br><span class=\"line\">[- initWithService:params:]</span><br><span class=\"line\">\t| ---------------</span><br><span class=\"line\">\t| | service bus | --- &gt; - pushViewModel: animated: </span><br><span class=\"line\">\t| ---------------                 |</span><br><span class=\"line\">\t|\t\t\t             （HOOK）[rac_responseToSelector:]</span><br><span class=\"line\">\t|\t\t\t                     |/</span><br><span class=\"line\">\t|\t\t\t               &lt;DKNavigationProtocol&gt;-- @&#123; viewModel:viewController&#125;---&gt;navigationController [pushViewController:animated:]</span><br><span class=\"line\">\t|/</span><br><span class=\"line\"> --------------------------------</span><br><span class=\"line\"> |        ViewModel B           |</span><br><span class=\"line\"> ---  ----------  ----------  ---</span><br></pre></td></tr></table></figure>\n<p>说明： ViewModelA 与 ViewControllerA ，ViewModelB 与 ViewControllerB 在 Router 里面通过字典的方式绑定在了一起，然后通过 RAC的方法监听pushViewModel: animated: 方法的执行，然后通过字典得到viewController从而进行真正的 push 操作，大概就是这样子</p>\n<h3 id=\"抽出父类和ReactiveCocoa\"><a href=\"#抽出父类和ReactiveCocoa\" class=\"headerlink\" title=\"抽出父类和ReactiveCocoa\"></a>抽出父类和ReactiveCocoa</h3><p>MVVMReactiveCocoa 通过封装父类的方式来实现这个架构，这些父类已经被我抽出来了，过几天会传上去，然后先写一些使用说明</p>\n<ol>\n<li>每个 Vc 对应一个 ViewModel</li>\n<li>TableViewController必须对应 ViewModel</li>\n<li>ViewModel 的初始化方法在 - initliazed 中</li>\n<li>初始化之前添加一些额外的方法，需要重写 - initWithServer:params:</li>\n<li>DKTableViewController是一个二维数组，里面封装的是 viewmodel</li>\n<li>cell 要遵循 DKReactiveView 协议</li>\n<li>绑定 cell与 viewModel 就在 ViewController里面重写 configureCell:withObject</li>\n<li>待补充</li>\n</ol>\n<p>ReativeCocoa 主要是用来实现 MVVM 的融合剂，当然也不一定要用 RAC去实现 MVVM,说实话 RAC 的学习成本还是相当高的，目前已经在尝试 DKRACHTTPTool,用纯 RAC 的方式去实现网络层和数据持久层的封装，另外还有些异常处理之类的,在这里面使用了filter: ignore: thottle: startWith: doNext: catch: try: doComplete: map: flattenMap: flatten: 等等的方法，非常好使，其他的可以看看我的几篇笔记”使用RAC-DKHTTPTool实践”、”RACCommand使用注意”</p>\n<p>最近的一个个人项目 Poi 就实践了这个架构。UI 结构如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   \t    --------------------------------</span><br><span class=\"line\">            |     NavigationConroller0     |</span><br><span class=\"line\">            ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t\t    |</span><br><span class=\"line\"> \t    --------------------------------</span><br><span class=\"line\">            |       TabBarController       |</span><br><span class=\"line\">            ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t|\t\t\t |</span><br><span class=\"line\">--------------------------------     --------------------------------   </span><br><span class=\"line\">|     NavigationConroller1     |     |     NavigationConroller2     |</span><br><span class=\"line\">---  ----------  ----------  ---     ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t|                   \t\t    |</span><br><span class=\"line\">--------------------------------     --------------------------------</span><br><span class=\"line\">|       ViewConroller1         |     |       ViewConroller2         |</span><br><span class=\"line\">---  ----------  ----------  --      --------------------------------</span><br></pre></td></tr></table></figure>\n<p>默认整个应用的跳转用的是NavigationConroller0，这样子做的原因是使用了一个第三方框架，为了可以在TabBarController中滑动切换。<br>当 pushViewModel 执行的时候，有一个 NavigationStack 会拿到最底部的 NavigationController 进行 push，如果 modal 出一个 navigationController,那么这个 navigationcontroller 将会压入NavigationStack ,然后这个 modal 出来的 viewController 后面的页面跳转就用这个 stack最上层的 NavigationController，dismiss 之后就会就会从栈中移除这个 NavigationController</p>\n<p>大概就是长这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------------------------------</span><br><span class=\"line\">|     NavigationConroller0     |  </span><br><span class=\"line\">---  ----------  ----------  ---    </span><br><span class=\"line\">\t\t |\tstack + 1\tpush</span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|       TabBarController       |    </span><br><span class=\"line\">---  ----------  ----------  ---  </span><br><span class=\"line\">\t\t |\t\t           </span><br><span class=\"line\">--------------------------------   </span><br><span class=\"line\">|     NavigationConroller1     |    </span><br><span class=\"line\">---  ----------  ----------  ---    </span><br><span class=\"line\">\t\t |      nv0 push     </span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|       ViewConroller1         |    </span><br><span class=\"line\">---  ----------  ----------  ---\t  </span><br><span class=\"line\">\t\t |   \tv1 modal</span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|      NavigationConroller2    |    </span><br><span class=\"line\">---  ----------  ----------  ---\t  </span><br><span class=\"line\">\t\t |     stack + 1  push   </span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|      ViewConroller2\t       |    </span><br><span class=\"line\">---  ----------  ----------  ---\t</span><br><span class=\"line\">\t\t| dismiss</span><br><span class=\"line\">\tstack - 1 pop</span><br></pre></td></tr></table></figure>\n<h3 id=\"MVVM-WithOut-ReacitveCocoa\"><a href=\"#MVVM-WithOut-ReacitveCocoa\" class=\"headerlink\" title=\"MVVM WithOut ReacitveCocoa\"></a>MVVM WithOut ReacitveCocoa</h3><p>用 Block 的方式代替 Reactive 的绑定功能。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>BugReporter For iOS<ul>\n<li>和思华一起开发的基于 iOS 的 bug自动反馈系统，一旦发生崩溃事故就会给开发者发送邮件</li>\n</ul>\n</li>\n<li>自动部署系统Jenkines</li>\n<li>JSPatch 热修复平台</li>\n<li>UMeng 用户数据统计</li>\n<li>等等</li>\n</ul>"},{"title":"Express学习笔记","author":"Arclin","abbrlink":"dcb90c85","date":"2017-03-06T16:00:00.000Z","_content":"Express 是 Node.js 的一个轻量级web框架,目前使用EJS模板引擎,该笔记持续更新\n\n<!-- more -->\n\n## supervisor\n\n使用supervisor监听文件改变然后自动重启node服务器,这样子就不用每改一次代码run一遍服务器了\n\n`sudo npm install -g supervisor`\n\n### WebStrom配置supervisor\n\n文件目录结构\n```\n├── app.js        项目入口及程序启动文件。\n├── bin\n│   └── www       存放启动项目的脚本文件，默认www。\n├── package.json  项目依赖配置及开发者信息。\n├── public        静态资源文件夹，默认images、javascripts、stylesheets。\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n├── routes        路由文件相当于MVC中的Controller，默认index.js、users.js。\n│   ├── index.js\n│   └── users.js\n└── views         页面文件，相当于MVC中的view，Ejs模板默认error.ejs、index.ejs\n    ├── error.ejs\n    └── index.ejs\n```\n\n项目依赖配置 `package.json`\n\n`package.json` 里面有项目依赖配置及开发者信息。\n在dependencies后面写上依赖的包名和版本号,然后在项目根目录执行npm install就可以像cocopods一样一次性安装包依赖\n\n## 路由 Routes\n路由用来处理URL的访问\n\n`index.js`\n\n```\nvar express = require('express');   获取express对象\nvar router = express.Router();      获取router对象\n```\n\nrouter有get(),post(),put(),delete()对象,代表接受的请求方式,对应查,增,改,删\n\n```\nrouter.get('/getSomething',function(req,res,next) {});\nrouter.post('/post', function (req,res) {});\nrouter.put('/put',function(req,res,next) {});\nrouter.delete('/delete',function(req,res,next) {});\n```\n\n方法中第一个参数意味着请求路径,例如第一个的请求路径是`http://localhost:3000/getSomething`,第二个参数是获取请求内容和准备返回的响应体.\n\n## Request获取请求参数\n\n例如请求发送了id参数,则`var id = req.params.id;`可以取得\nResponse返回响应体\n\n`send()`方法向浏览器发送一个响应信息\n例如想返回一个json,则res.send({test:id = ${id},name = ${name}});\n当参数为一个Number时，并且没有上面提到的任何一条在响应体里，Express会帮你设置一个响应 体，比如：200会返回字符”OK”。\nres.send(200); // OK\nres.send(404); // Not Found\nres.send(500); // Internal Server Error\n\n## Response重定向\n\n`res.redirect(\"http://www.hubwiz.com\");`\n\n## Response渲染页面\n\n如果想渲染`hello.ejs`页面,`res.render('hello',{title:\"MySQL\",test_params:'aaa'});`\n`hello.ejs`页面通过`<%= title %>`的方式取得title等参数\n\nRequest获取主机名,路径名\n\n`req.host`获取主机名，`req.path`获取请求路径名\n\n## restful 方式路由\n\n```\nrouter.post('/restful/:id/name/:name', function (req,res) {\n  var id  = req.params.id;\n  var name = req.params.name;\n  console.log(JSON.stringify(req.params));\n  res.send({test:`id = ${id},name = ${name}`});\n});\nJSON.stringify() 把js对象转成json\n```\n\n## 数据库\n\n### MySQL\n安装MySQL\n\n`$ npm install mysql`\n\n引入MySQL并配置\n```\nvar mysql      = require('mysql');\nvar connection = mysql.createConnection({\n    host     : 'localhost',\n    user     : 'root',\n    password : '123456',\n    database : 'csdn_test',\n    port     : 3306\n});\n```\n\n连接数据库\n\n```\nconnection.connect()\n```\n\n这个方法可以接受一个回调用来判断是否连接成功\n\n```\nconnection.connect(function(err) {\n    if (!err) {\n   \t\t// 连接成功\n     } else {\n      // 连接失败 \n     }\n});\nconnection.end();\n```\n\n#### 查询\n\n```\nconnection.query('SELECT 1 + 1 AS solution', function(err, rows, fields) {\n  if (err) throw err;\n  console.log('The solution is: ', rows[0].solution);\n});\n```\n\n同上,接受一个回调来判断是否成功关闭连接\n\n`connection.end(err => console.log(`连接中断${err}`));'\n\n### MongoDB\n\n安装\n\n`npm install -g mongoose`\n配置\n\n```\nvar mongoose = require('mongoose');\nvar options = {\n    db_user: \"root\",\n    db_pwd: \"123456\",\n    db_host: \"localhost\",\n    db_port: 27017,\n    db_name: \"csdn_test\"\n};\n```\n\n#### 连接\n\n```\nvar dbURL = \"mongodb://\" + options.db_user + \":\" + options.db_pwd + \"@\" + options.db_host + \":\" + options.db_port + \"/\" + options.db_name;\n\n// 连接\nmongoose.connect(dbURL);\n\n// 监听连接事件\nmongoose.connection.on('connected', function (err) {\n    if (err) logger.error('Database connection failure');\n});\n\n// 监听错误事件\nmongoose.connection.on('error', function (err) {\n    logger.error('Mongoose connected error ' + err);\n});\n\n// 监听断开事件\nmongoose.connection.on('disconnected', function () {\n    logger.error('Mongoose disconnected');\n});\n查询\n\nmongoose.collection('mamals').find().toArray(function(err, result) {\n  if (err) throw err;\n  console.log(result);\n});\n```\n\n其他方法以后遇到再补充.","source":"_posts/Express学习笔记.md","raw":"---\ntitle: Express学习笔记\nauthor: Arclin\ntags:\n  - Node.js\n  - Express\ncategories:\n  - Node.js\nabbrlink: dcb90c85\ndate: 2017-03-07 00:00:00\n---\nExpress 是 Node.js 的一个轻量级web框架,目前使用EJS模板引擎,该笔记持续更新\n\n<!-- more -->\n\n## supervisor\n\n使用supervisor监听文件改变然后自动重启node服务器,这样子就不用每改一次代码run一遍服务器了\n\n`sudo npm install -g supervisor`\n\n### WebStrom配置supervisor\n\n文件目录结构\n```\n├── app.js        项目入口及程序启动文件。\n├── bin\n│   └── www       存放启动项目的脚本文件，默认www。\n├── package.json  项目依赖配置及开发者信息。\n├── public        静态资源文件夹，默认images、javascripts、stylesheets。\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n├── routes        路由文件相当于MVC中的Controller，默认index.js、users.js。\n│   ├── index.js\n│   └── users.js\n└── views         页面文件，相当于MVC中的view，Ejs模板默认error.ejs、index.ejs\n    ├── error.ejs\n    └── index.ejs\n```\n\n项目依赖配置 `package.json`\n\n`package.json` 里面有项目依赖配置及开发者信息。\n在dependencies后面写上依赖的包名和版本号,然后在项目根目录执行npm install就可以像cocopods一样一次性安装包依赖\n\n## 路由 Routes\n路由用来处理URL的访问\n\n`index.js`\n\n```\nvar express = require('express');   获取express对象\nvar router = express.Router();      获取router对象\n```\n\nrouter有get(),post(),put(),delete()对象,代表接受的请求方式,对应查,增,改,删\n\n```\nrouter.get('/getSomething',function(req,res,next) {});\nrouter.post('/post', function (req,res) {});\nrouter.put('/put',function(req,res,next) {});\nrouter.delete('/delete',function(req,res,next) {});\n```\n\n方法中第一个参数意味着请求路径,例如第一个的请求路径是`http://localhost:3000/getSomething`,第二个参数是获取请求内容和准备返回的响应体.\n\n## Request获取请求参数\n\n例如请求发送了id参数,则`var id = req.params.id;`可以取得\nResponse返回响应体\n\n`send()`方法向浏览器发送一个响应信息\n例如想返回一个json,则res.send({test:id = ${id},name = ${name}});\n当参数为一个Number时，并且没有上面提到的任何一条在响应体里，Express会帮你设置一个响应 体，比如：200会返回字符”OK”。\nres.send(200); // OK\nres.send(404); // Not Found\nres.send(500); // Internal Server Error\n\n## Response重定向\n\n`res.redirect(\"http://www.hubwiz.com\");`\n\n## Response渲染页面\n\n如果想渲染`hello.ejs`页面,`res.render('hello',{title:\"MySQL\",test_params:'aaa'});`\n`hello.ejs`页面通过`<%= title %>`的方式取得title等参数\n\nRequest获取主机名,路径名\n\n`req.host`获取主机名，`req.path`获取请求路径名\n\n## restful 方式路由\n\n```\nrouter.post('/restful/:id/name/:name', function (req,res) {\n  var id  = req.params.id;\n  var name = req.params.name;\n  console.log(JSON.stringify(req.params));\n  res.send({test:`id = ${id},name = ${name}`});\n});\nJSON.stringify() 把js对象转成json\n```\n\n## 数据库\n\n### MySQL\n安装MySQL\n\n`$ npm install mysql`\n\n引入MySQL并配置\n```\nvar mysql      = require('mysql');\nvar connection = mysql.createConnection({\n    host     : 'localhost',\n    user     : 'root',\n    password : '123456',\n    database : 'csdn_test',\n    port     : 3306\n});\n```\n\n连接数据库\n\n```\nconnection.connect()\n```\n\n这个方法可以接受一个回调用来判断是否连接成功\n\n```\nconnection.connect(function(err) {\n    if (!err) {\n   \t\t// 连接成功\n     } else {\n      // 连接失败 \n     }\n});\nconnection.end();\n```\n\n#### 查询\n\n```\nconnection.query('SELECT 1 + 1 AS solution', function(err, rows, fields) {\n  if (err) throw err;\n  console.log('The solution is: ', rows[0].solution);\n});\n```\n\n同上,接受一个回调来判断是否成功关闭连接\n\n`connection.end(err => console.log(`连接中断${err}`));'\n\n### MongoDB\n\n安装\n\n`npm install -g mongoose`\n配置\n\n```\nvar mongoose = require('mongoose');\nvar options = {\n    db_user: \"root\",\n    db_pwd: \"123456\",\n    db_host: \"localhost\",\n    db_port: 27017,\n    db_name: \"csdn_test\"\n};\n```\n\n#### 连接\n\n```\nvar dbURL = \"mongodb://\" + options.db_user + \":\" + options.db_pwd + \"@\" + options.db_host + \":\" + options.db_port + \"/\" + options.db_name;\n\n// 连接\nmongoose.connect(dbURL);\n\n// 监听连接事件\nmongoose.connection.on('connected', function (err) {\n    if (err) logger.error('Database connection failure');\n});\n\n// 监听错误事件\nmongoose.connection.on('error', function (err) {\n    logger.error('Mongoose connected error ' + err);\n});\n\n// 监听断开事件\nmongoose.connection.on('disconnected', function () {\n    logger.error('Mongoose disconnected');\n});\n查询\n\nmongoose.collection('mamals').find().toArray(function(err, result) {\n  if (err) throw err;\n  console.log(result);\n});\n```\n\n其他方法以后遇到再补充.","slug":"Express学习笔记","published":1,"updated":"2018-05-10T06:51:35.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcgd0001ldxu400tgpup","content":"<p>Express 是 Node.js 的一个轻量级web框架,目前使用EJS模板引擎,该笔记持续更新</p>\n<a id=\"more\"></a>\n<h2 id=\"supervisor\"><a href=\"#supervisor\" class=\"headerlink\" title=\"supervisor\"></a>supervisor</h2><p>使用supervisor监听文件改变然后自动重启node服务器,这样子就不用每改一次代码run一遍服务器了</p>\n<p><code>sudo npm install -g supervisor</code></p>\n<h3 id=\"WebStrom配置supervisor\"><a href=\"#WebStrom配置supervisor\" class=\"headerlink\" title=\"WebStrom配置supervisor\"></a>WebStrom配置supervisor</h3><p>文件目录结构<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── app.js        项目入口及程序启动文件。</span><br><span class=\"line\">├── bin</span><br><span class=\"line\">│   └── www       存放启动项目的脚本文件，默认www。</span><br><span class=\"line\">├── package.json  项目依赖配置及开发者信息。</span><br><span class=\"line\">├── public        静态资源文件夹，默认images、javascripts、stylesheets。</span><br><span class=\"line\">│   ├── images</span><br><span class=\"line\">│   ├── javascripts</span><br><span class=\"line\">│   └── stylesheets</span><br><span class=\"line\">├── routes        路由文件相当于MVC中的Controller，默认index.js、users.js。</span><br><span class=\"line\">│   ├── index.js</span><br><span class=\"line\">│   └── users.js</span><br><span class=\"line\">└── views         页面文件，相当于MVC中的view，Ejs模板默认error.ejs、index.ejs</span><br><span class=\"line\">    ├── error.ejs</span><br><span class=\"line\">    └── index.ejs</span><br></pre></td></tr></table></figure></p>\n<p>项目依赖配置 <code>package.json</code></p>\n<p><code>package.json</code> 里面有项目依赖配置及开发者信息。<br>在dependencies后面写上依赖的包名和版本号,然后在项目根目录执行npm install就可以像cocopods一样一次性安装包依赖</p>\n<h2 id=\"路由-Routes\"><a href=\"#路由-Routes\" class=\"headerlink\" title=\"路由 Routes\"></a>路由 Routes</h2><p>路由用来处理URL的访问</p>\n<p><code>index.js</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&apos;express&apos;);   获取express对象</span><br><span class=\"line\">var router = express.Router();      获取router对象</span><br></pre></td></tr></table></figure>\n<p>router有get(),post(),put(),delete()对象,代表接受的请求方式,对应查,增,改,删</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.get(&apos;/getSomething&apos;,function(req,res,next) &#123;&#125;);</span><br><span class=\"line\">router.post(&apos;/post&apos;, function (req,res) &#123;&#125;);</span><br><span class=\"line\">router.put(&apos;/put&apos;,function(req,res,next) &#123;&#125;);</span><br><span class=\"line\">router.delete(&apos;/delete&apos;,function(req,res,next) &#123;&#125;);</span><br></pre></td></tr></table></figure>\n<p>方法中第一个参数意味着请求路径,例如第一个的请求路径是<code>http://localhost:3000/getSomething</code>,第二个参数是获取请求内容和准备返回的响应体.</p>\n<h2 id=\"Request获取请求参数\"><a href=\"#Request获取请求参数\" class=\"headerlink\" title=\"Request获取请求参数\"></a>Request获取请求参数</h2><p>例如请求发送了id参数,则<code>var id = req.params.id;</code>可以取得<br>Response返回响应体</p>\n<p><code>send()</code>方法向浏览器发送一个响应信息<br>例如想返回一个json,则res.send({test:id = ${id},name = ${name}});<br>当参数为一个Number时，并且没有上面提到的任何一条在响应体里，Express会帮你设置一个响应 体，比如：200会返回字符”OK”。<br>res.send(200); // OK<br>res.send(404); // Not Found<br>res.send(500); // Internal Server Error</p>\n<h2 id=\"Response重定向\"><a href=\"#Response重定向\" class=\"headerlink\" title=\"Response重定向\"></a>Response重定向</h2><p><code>res.redirect(&quot;http://www.hubwiz.com&quot;);</code></p>\n<h2 id=\"Response渲染页面\"><a href=\"#Response渲染页面\" class=\"headerlink\" title=\"Response渲染页面\"></a>Response渲染页面</h2><p>如果想渲染<code>hello.ejs</code>页面,<code>res.render(&#39;hello&#39;,{title:&quot;MySQL&quot;,test_params:&#39;aaa&#39;});</code><br><code>hello.ejs</code>页面通过<code>&lt;%= title %&gt;</code>的方式取得title等参数</p>\n<p>Request获取主机名,路径名</p>\n<p><code>req.host</code>获取主机名，<code>req.path</code>获取请求路径名</p>\n<h2 id=\"restful-方式路由\"><a href=\"#restful-方式路由\" class=\"headerlink\" title=\"restful 方式路由\"></a>restful 方式路由</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.post(&apos;/restful/:id/name/:name&apos;, function (req,res) &#123;</span><br><span class=\"line\">  var id  = req.params.id;</span><br><span class=\"line\">  var name = req.params.name;</span><br><span class=\"line\">  console.log(JSON.stringify(req.params));</span><br><span class=\"line\">  res.send(&#123;test:`id = $&#123;id&#125;,name = $&#123;name&#125;`&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">JSON.stringify() 把js对象转成json</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><p>安装MySQL</p>\n<p><code>$ npm install mysql</code></p>\n<p>引入MySQL并配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mysql      = require(&apos;mysql&apos;);</span><br><span class=\"line\">var connection = mysql.createConnection(&#123;</span><br><span class=\"line\">    host     : &apos;localhost&apos;,</span><br><span class=\"line\">    user     : &apos;root&apos;,</span><br><span class=\"line\">    password : &apos;123456&apos;,</span><br><span class=\"line\">    database : &apos;csdn_test&apos;,</span><br><span class=\"line\">    port     : 3306</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>连接数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.connect()</span><br></pre></td></tr></table></figure>\n<p>这个方法可以接受一个回调用来判断是否连接成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.connect(function(err) &#123;</span><br><span class=\"line\">    if (!err) &#123;</span><br><span class=\"line\">   \t\t// 连接成功</span><br><span class=\"line\">     &#125; else &#123;</span><br><span class=\"line\">      // 连接失败 </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.end();</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.query(&apos;SELECT 1 + 1 AS solution&apos;, function(err, rows, fields) &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(&apos;The solution is: &apos;, rows[0].solution);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>同上,接受一个回调来判断是否成功关闭连接</p>\n<p><code>connection.end(err =&gt; console.log(</code>连接中断${err}`));’</p>\n<h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><p>安装</p>\n<p><code>npm install -g mongoose</code><br>配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mongoose = require(&apos;mongoose&apos;);</span><br><span class=\"line\">var options = &#123;</span><br><span class=\"line\">    db_user: &quot;root&quot;,</span><br><span class=\"line\">    db_pwd: &quot;123456&quot;,</span><br><span class=\"line\">    db_host: &quot;localhost&quot;,</span><br><span class=\"line\">    db_port: 27017,</span><br><span class=\"line\">    db_name: &quot;csdn_test&quot;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dbURL = &quot;mongodb://&quot; + options.db_user + &quot;:&quot; + options.db_pwd + &quot;@&quot; + options.db_host + &quot;:&quot; + options.db_port + &quot;/&quot; + options.db_name;</span><br><span class=\"line\"></span><br><span class=\"line\">// 连接</span><br><span class=\"line\">mongoose.connect(dbURL);</span><br><span class=\"line\"></span><br><span class=\"line\">// 监听连接事件</span><br><span class=\"line\">mongoose.connection.on(&apos;connected&apos;, function (err) &#123;</span><br><span class=\"line\">    if (err) logger.error(&apos;Database connection failure&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 监听错误事件</span><br><span class=\"line\">mongoose.connection.on(&apos;error&apos;, function (err) &#123;</span><br><span class=\"line\">    logger.error(&apos;Mongoose connected error &apos; + err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 监听断开事件</span><br><span class=\"line\">mongoose.connection.on(&apos;disconnected&apos;, function () &#123;</span><br><span class=\"line\">    logger.error(&apos;Mongoose disconnected&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">查询</span><br><span class=\"line\"></span><br><span class=\"line\">mongoose.collection(&apos;mamals&apos;).find().toArray(function(err, result) &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>其他方法以后遇到再补充.</p>\n","site":{"data":{}},"excerpt":"<p>Express 是 Node.js 的一个轻量级web框架,目前使用EJS模板引擎,该笔记持续更新</p>","more":"<h2 id=\"supervisor\"><a href=\"#supervisor\" class=\"headerlink\" title=\"supervisor\"></a>supervisor</h2><p>使用supervisor监听文件改变然后自动重启node服务器,这样子就不用每改一次代码run一遍服务器了</p>\n<p><code>sudo npm install -g supervisor</code></p>\n<h3 id=\"WebStrom配置supervisor\"><a href=\"#WebStrom配置supervisor\" class=\"headerlink\" title=\"WebStrom配置supervisor\"></a>WebStrom配置supervisor</h3><p>文件目录结构<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── app.js        项目入口及程序启动文件。</span><br><span class=\"line\">├── bin</span><br><span class=\"line\">│   └── www       存放启动项目的脚本文件，默认www。</span><br><span class=\"line\">├── package.json  项目依赖配置及开发者信息。</span><br><span class=\"line\">├── public        静态资源文件夹，默认images、javascripts、stylesheets。</span><br><span class=\"line\">│   ├── images</span><br><span class=\"line\">│   ├── javascripts</span><br><span class=\"line\">│   └── stylesheets</span><br><span class=\"line\">├── routes        路由文件相当于MVC中的Controller，默认index.js、users.js。</span><br><span class=\"line\">│   ├── index.js</span><br><span class=\"line\">│   └── users.js</span><br><span class=\"line\">└── views         页面文件，相当于MVC中的view，Ejs模板默认error.ejs、index.ejs</span><br><span class=\"line\">    ├── error.ejs</span><br><span class=\"line\">    └── index.ejs</span><br></pre></td></tr></table></figure></p>\n<p>项目依赖配置 <code>package.json</code></p>\n<p><code>package.json</code> 里面有项目依赖配置及开发者信息。<br>在dependencies后面写上依赖的包名和版本号,然后在项目根目录执行npm install就可以像cocopods一样一次性安装包依赖</p>\n<h2 id=\"路由-Routes\"><a href=\"#路由-Routes\" class=\"headerlink\" title=\"路由 Routes\"></a>路由 Routes</h2><p>路由用来处理URL的访问</p>\n<p><code>index.js</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express = require(&apos;express&apos;);   获取express对象</span><br><span class=\"line\">var router = express.Router();      获取router对象</span><br></pre></td></tr></table></figure>\n<p>router有get(),post(),put(),delete()对象,代表接受的请求方式,对应查,增,改,删</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.get(&apos;/getSomething&apos;,function(req,res,next) &#123;&#125;);</span><br><span class=\"line\">router.post(&apos;/post&apos;, function (req,res) &#123;&#125;);</span><br><span class=\"line\">router.put(&apos;/put&apos;,function(req,res,next) &#123;&#125;);</span><br><span class=\"line\">router.delete(&apos;/delete&apos;,function(req,res,next) &#123;&#125;);</span><br></pre></td></tr></table></figure>\n<p>方法中第一个参数意味着请求路径,例如第一个的请求路径是<code>http://localhost:3000/getSomething</code>,第二个参数是获取请求内容和准备返回的响应体.</p>\n<h2 id=\"Request获取请求参数\"><a href=\"#Request获取请求参数\" class=\"headerlink\" title=\"Request获取请求参数\"></a>Request获取请求参数</h2><p>例如请求发送了id参数,则<code>var id = req.params.id;</code>可以取得<br>Response返回响应体</p>\n<p><code>send()</code>方法向浏览器发送一个响应信息<br>例如想返回一个json,则res.send({test:id = ${id},name = ${name}});<br>当参数为一个Number时，并且没有上面提到的任何一条在响应体里，Express会帮你设置一个响应 体，比如：200会返回字符”OK”。<br>res.send(200); // OK<br>res.send(404); // Not Found<br>res.send(500); // Internal Server Error</p>\n<h2 id=\"Response重定向\"><a href=\"#Response重定向\" class=\"headerlink\" title=\"Response重定向\"></a>Response重定向</h2><p><code>res.redirect(&quot;http://www.hubwiz.com&quot;);</code></p>\n<h2 id=\"Response渲染页面\"><a href=\"#Response渲染页面\" class=\"headerlink\" title=\"Response渲染页面\"></a>Response渲染页面</h2><p>如果想渲染<code>hello.ejs</code>页面,<code>res.render(&#39;hello&#39;,{title:&quot;MySQL&quot;,test_params:&#39;aaa&#39;});</code><br><code>hello.ejs</code>页面通过<code>&lt;%= title %&gt;</code>的方式取得title等参数</p>\n<p>Request获取主机名,路径名</p>\n<p><code>req.host</code>获取主机名，<code>req.path</code>获取请求路径名</p>\n<h2 id=\"restful-方式路由\"><a href=\"#restful-方式路由\" class=\"headerlink\" title=\"restful 方式路由\"></a>restful 方式路由</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.post(&apos;/restful/:id/name/:name&apos;, function (req,res) &#123;</span><br><span class=\"line\">  var id  = req.params.id;</span><br><span class=\"line\">  var name = req.params.name;</span><br><span class=\"line\">  console.log(JSON.stringify(req.params));</span><br><span class=\"line\">  res.send(&#123;test:`id = $&#123;id&#125;,name = $&#123;name&#125;`&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">JSON.stringify() 把js对象转成json</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><p>安装MySQL</p>\n<p><code>$ npm install mysql</code></p>\n<p>引入MySQL并配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mysql      = require(&apos;mysql&apos;);</span><br><span class=\"line\">var connection = mysql.createConnection(&#123;</span><br><span class=\"line\">    host     : &apos;localhost&apos;,</span><br><span class=\"line\">    user     : &apos;root&apos;,</span><br><span class=\"line\">    password : &apos;123456&apos;,</span><br><span class=\"line\">    database : &apos;csdn_test&apos;,</span><br><span class=\"line\">    port     : 3306</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>连接数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.connect()</span><br></pre></td></tr></table></figure>\n<p>这个方法可以接受一个回调用来判断是否连接成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.connect(function(err) &#123;</span><br><span class=\"line\">    if (!err) &#123;</span><br><span class=\"line\">   \t\t// 连接成功</span><br><span class=\"line\">     &#125; else &#123;</span><br><span class=\"line\">      // 连接失败 </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.end();</span><br></pre></td></tr></table></figure>\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.query(&apos;SELECT 1 + 1 AS solution&apos;, function(err, rows, fields) &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(&apos;The solution is: &apos;, rows[0].solution);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>同上,接受一个回调来判断是否成功关闭连接</p>\n<p><code>connection.end(err =&gt; console.log(</code>连接中断${err}`));’</p>\n<h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><p>安装</p>\n<p><code>npm install -g mongoose</code><br>配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mongoose = require(&apos;mongoose&apos;);</span><br><span class=\"line\">var options = &#123;</span><br><span class=\"line\">    db_user: &quot;root&quot;,</span><br><span class=\"line\">    db_pwd: &quot;123456&quot;,</span><br><span class=\"line\">    db_host: &quot;localhost&quot;,</span><br><span class=\"line\">    db_port: 27017,</span><br><span class=\"line\">    db_name: &quot;csdn_test&quot;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dbURL = &quot;mongodb://&quot; + options.db_user + &quot;:&quot; + options.db_pwd + &quot;@&quot; + options.db_host + &quot;:&quot; + options.db_port + &quot;/&quot; + options.db_name;</span><br><span class=\"line\"></span><br><span class=\"line\">// 连接</span><br><span class=\"line\">mongoose.connect(dbURL);</span><br><span class=\"line\"></span><br><span class=\"line\">// 监听连接事件</span><br><span class=\"line\">mongoose.connection.on(&apos;connected&apos;, function (err) &#123;</span><br><span class=\"line\">    if (err) logger.error(&apos;Database connection failure&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 监听错误事件</span><br><span class=\"line\">mongoose.connection.on(&apos;error&apos;, function (err) &#123;</span><br><span class=\"line\">    logger.error(&apos;Mongoose connected error &apos; + err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 监听断开事件</span><br><span class=\"line\">mongoose.connection.on(&apos;disconnected&apos;, function () &#123;</span><br><span class=\"line\">    logger.error(&apos;Mongoose disconnected&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">查询</span><br><span class=\"line\"></span><br><span class=\"line\">mongoose.collection(&apos;mamals&apos;).find().toArray(function(err, result) &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>其他方法以后遇到再补充.</p>"},{"title":"AVFoundation录制视频没声音?","author":"Arclin","abbrlink":"efd905d7","date":"2017-03-03T16:00:00.000Z","_content":"先说结论 , 加一行代码 \n\n```\n_captureMovieFileOutput.movieFragmentInterval = kCMTimeInvalid\n```\n\n<!-- more -->\n\n看看`movieFragmentInterval` 属性的说明\n\n```\n/*!\n @property movieFragmentInterval\n @abstract\n    Specifies the frequency with which movie fragments should be written.\n\n @discussion\n    When movie fragments are used, a partially written QuickTime movie file whose writing is unexpectedly interrupted can be successfully opened and played up to multiples of the specified time interval. A value of kCMTimeInvalid indicates that movie fragments should not be used, but that only a movie atom describing all of the media in the file should be written. The default value of this property is ten seconds.\n\n    Changing the value of this property will not affect the movie fragment interval of the file currently being written, if there is one.\n */\n@property(nonatomic) CMTime movieFragmentInterval;\n```\n\n用拙略的英语水平翻译一下就是,`movieFragmentInterval`这东西代表一个时间间隔,每隔x秒就会把视频片段写入内存,这是为了保证当意外中断视频文件写入的时候还可以有一个可以播放的视频片段,默认是十秒,如果你给他赋了这个值`kCMTimeInvalid`,就表示要一直写入直到调用某个方法结束视频录制,之后他就会给视频文件加上文件尾部,所以如果没有设置这个值的话,十秒到二十秒的视频中间就会出现没声音的状况.\n","source":"_posts/AVFoundation录制视频没声音.md","raw":"---\ntitle: AVFoundation录制视频没声音?\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: efd905d7\ndate: 2017-03-04 00:00:00\n---\n先说结论 , 加一行代码 \n\n```\n_captureMovieFileOutput.movieFragmentInterval = kCMTimeInvalid\n```\n\n<!-- more -->\n\n看看`movieFragmentInterval` 属性的说明\n\n```\n/*!\n @property movieFragmentInterval\n @abstract\n    Specifies the frequency with which movie fragments should be written.\n\n @discussion\n    When movie fragments are used, a partially written QuickTime movie file whose writing is unexpectedly interrupted can be successfully opened and played up to multiples of the specified time interval. A value of kCMTimeInvalid indicates that movie fragments should not be used, but that only a movie atom describing all of the media in the file should be written. The default value of this property is ten seconds.\n\n    Changing the value of this property will not affect the movie fragment interval of the file currently being written, if there is one.\n */\n@property(nonatomic) CMTime movieFragmentInterval;\n```\n\n用拙略的英语水平翻译一下就是,`movieFragmentInterval`这东西代表一个时间间隔,每隔x秒就会把视频片段写入内存,这是为了保证当意外中断视频文件写入的时候还可以有一个可以播放的视频片段,默认是十秒,如果你给他赋了这个值`kCMTimeInvalid`,就表示要一直写入直到调用某个方法结束视频录制,之后他就会给视频文件加上文件尾部,所以如果没有设置这个值的话,十秒到二十秒的视频中间就会出现没声音的状况.\n","slug":"AVFoundation录制视频没声音","published":1,"updated":"2018-05-10T06:51:35.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcgq0004ldxux811i77z","content":"<p>先说结论 , 加一行代码 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_captureMovieFileOutput.movieFragmentInterval = kCMTimeInvalid</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>看看<code>movieFragmentInterval</code> 属性的说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\"> @property movieFragmentInterval</span><br><span class=\"line\"> @abstract</span><br><span class=\"line\">    Specifies the frequency with which movie fragments should be written.</span><br><span class=\"line\"></span><br><span class=\"line\"> @discussion</span><br><span class=\"line\">    When movie fragments are used, a partially written QuickTime movie file whose writing is unexpectedly interrupted can be successfully opened and played up to multiples of the specified time interval. A value of kCMTimeInvalid indicates that movie fragments should not be used, but that only a movie atom describing all of the media in the file should be written. The default value of this property is ten seconds.</span><br><span class=\"line\"></span><br><span class=\"line\">    Changing the value of this property will not affect the movie fragment interval of the file currently being written, if there is one.</span><br><span class=\"line\"> */</span><br><span class=\"line\">@property(nonatomic) CMTime movieFragmentInterval;</span><br></pre></td></tr></table></figure>\n<p>用拙略的英语水平翻译一下就是,<code>movieFragmentInterval</code>这东西代表一个时间间隔,每隔x秒就会把视频片段写入内存,这是为了保证当意外中断视频文件写入的时候还可以有一个可以播放的视频片段,默认是十秒,如果你给他赋了这个值<code>kCMTimeInvalid</code>,就表示要一直写入直到调用某个方法结束视频录制,之后他就会给视频文件加上文件尾部,所以如果没有设置这个值的话,十秒到二十秒的视频中间就会出现没声音的状况.</p>\n","site":{"data":{}},"excerpt":"<p>先说结论 , 加一行代码 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_captureMovieFileOutput.movieFragmentInterval = kCMTimeInvalid</span><br></pre></td></tr></table></figure>","more":"<p>看看<code>movieFragmentInterval</code> 属性的说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*!</span><br><span class=\"line\"> @property movieFragmentInterval</span><br><span class=\"line\"> @abstract</span><br><span class=\"line\">    Specifies the frequency with which movie fragments should be written.</span><br><span class=\"line\"></span><br><span class=\"line\"> @discussion</span><br><span class=\"line\">    When movie fragments are used, a partially written QuickTime movie file whose writing is unexpectedly interrupted can be successfully opened and played up to multiples of the specified time interval. A value of kCMTimeInvalid indicates that movie fragments should not be used, but that only a movie atom describing all of the media in the file should be written. The default value of this property is ten seconds.</span><br><span class=\"line\"></span><br><span class=\"line\">    Changing the value of this property will not affect the movie fragment interval of the file currently being written, if there is one.</span><br><span class=\"line\"> */</span><br><span class=\"line\">@property(nonatomic) CMTime movieFragmentInterval;</span><br></pre></td></tr></table></figure>\n<p>用拙略的英语水平翻译一下就是,<code>movieFragmentInterval</code>这东西代表一个时间间隔,每隔x秒就会把视频片段写入内存,这是为了保证当意外中断视频文件写入的时候还可以有一个可以播放的视频片段,默认是十秒,如果你给他赋了这个值<code>kCMTimeInvalid</code>,就表示要一直写入直到调用某个方法结束视频录制,之后他就会给视频文件加上文件尾部,所以如果没有设置这个值的话,十秒到二十秒的视频中间就会出现没声音的状况.</p>"},{"title":"Dankal_iOS崩溃信息提交","author":"Arclin","abbrlink":"afeed214","date":"2016-10-31T16:00:00.000Z","_content":"Dankal_iOS 崩溃信息提交\n<!-- more -->\n\n1. 获取到崩溃信息（异常原因，异常方法，异常类名，堆栈）\n2. 获取到本机信息（型号，系统）\n3. 保存为 plist到本地\n4. 下次启动应用的时候发送信息到服务器(POST发送，记得添加 token 到HEADER)\n5. 发送完之后删除掉 plist 文件\n\n---\n\n## 如何捕获崩溃信息\n\nC 语言捕获\n\n```\n#include <libkern/OSAtomic.h>\n#include <execinfo.h>\n\n// 系统信号截获处理方法\nvoid signalHandler(int signal);\n// 异常截获处理方法\nvoid exceptionHandler(NSException *exception);\nconst int32_t _uncaughtExceptionMaximum = 20;\n\nNSString * const UncaughtExceptionHandlerSignalKey = @\"UncaughtExceptionHandlerSignalKey\";\nNSString *const SingalExceptionHandlerAddressesKey = @\"SingalExceptionHandlerAddressesKey\";\nNSString *const ExceptionHandlerAddressesKey = @\"ExceptionHandlerAddressesKey\";\n\nvoid signalHandler(int signal)\n{\n    volatile int32_t _uncaughtExceptionCount = 0;\n    int32_t exceptionCount = OSAtomicIncrement32(&_uncaughtExceptionCount);\n    if (exceptionCount > _uncaughtExceptionMaximum) // 如果太多不用处理\n    {\n        return;\n    }\n    // 获取信息\n    NSMutableDictionary *userInfo =\n    [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey];\n    \n    NSArray *callStack = [DKUncaughtExceptionHandler backtrace];\n    [userInfo  setObject:callStack  forKey:SingalExceptionHandlerAddressesKey];\n    \n}\n\nvoid exceptionHandler(NSException *exception)\n{\n    volatile int32_t _uncaughtExceptionCount = 0;\n    int32_t exceptionCount = OSAtomicIncrement32(&_uncaughtExceptionCount);\n    if (exceptionCount > _uncaughtExceptionMaximum) // 如果太多不用处理\n    {\n        return;\n    }\n    \n    NSArray *callStack = [DKUncaughtExceptionHandler backtrace];\n    NSMutableDictionary *userInfo =[NSMutableDictionary dictionaryWithDictionary:[exception userInfo]];\n    [userInfo setObject:callStack forKey:ExceptionHandlerAddressesKey];\n    \n    // 保存信息到本地\n    NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] stringByAppendingPathComponent:@\"crash.plist\"];\n    \n    // 获取本机信息\n    struct utsname systemInfo;\n    uname(&systemInfo);\n    \n    NSDictionary *crashInfo = @{@\"crash_time\":[NSDate dateStringWithDateFormat:@\"yyyy-MM-dd HH:mm:ss\"],\n                                @\"device_type\": [DKUncaughtExceptionHandler deviceVersion:[NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]],\n                                @\"device_system\": [UIDevice currentDevice].systemVersion,\n                                @\"crash_type\":exception.name,\n                                @\"crash_reason\":exception.reason,\n                                @\"crash_stack\":userInfo.descriptionInStringsFileFormat};\n    [crashInfo writeToFile:path atomically:YES];\n}\n```\n\n## OC 部分获取调用堆栈和注册崩溃拦截\n\n```\n//获取调用堆栈\n+ (NSArray *)backtrace\n{\n    void* callstack[128];\n    int frames = backtrace(callstack, 128);\n    char **strs = backtrace_symbols(callstack,frames);\n    \n    NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames];\n    for (int i=0;i<frames;i++)\n    {\n        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];\n    }\n    free(strs);\n    \n    return backtrace;\n}\n\n// 注册崩溃拦截\n- (void)installExceptionHandler\n{\n    NSSetUncaughtExceptionHandler(&exceptionHandler);\n    signal(SIGHUP, signalHandler);\n    signal(SIGINT, signalHandler);\n    signal(SIGQUIT, signalHandler);\n    \n    signal(SIGABRT, signalHandler);\n    signal(SIGILL, signalHandler);\n    signal(SIGSEGV, signalHandler);\n    signal(SIGFPE, signalHandler);\n    signal(SIGBUS, signalHandler);\n    signal(SIGPIPE, signalHandler);\n    \n    NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] stringByAppendingPathComponent:@\"crash.plist\"];\n    if([[NSFileManager defaultManager] fileExistsAtPath:path]){\n        NSDictionary *params = [[NSDictionary alloc] initWithContentsOfFile:path];\n        [DKHTTPTool POST:去看 Coding 的Crash Reporter项目说明文档  parameters:params header:@{@\"token\":去看 Coding的Crash Reporter项目说明文档} responseBlock:^(DKResponse *response) {\n            if (!response.error) {\n                NSError *error;\n                [[NSFileManager defaultManager] removeItemAtPath:path error:&error];\n                if(error)DKLog(@\"%@\",error);\n            }\n        }];\n    }\n}\n```\n\n## 发送请求的AFN封装方法\n\n```\n+ (void)POST:(NSString *)URLString parameters:(id)parameters header:(NSDictionary *)headerField responseBlock:(DKHTTPResponseBlock)block\n{\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n    AFHTTPRequestSerializer *requestSerializer =  [AFJSONRequestSerializer serializer];\n    [headerField enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        [requestSerializer setValue:obj forHTTPHeaderField:key];\n    }];\n    mgr.requestSerializer = requestSerializer;\n    [mgr POST:URLString parameters:parameters  progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\n        resp.rawData = responseObject;\n        if(block){\n            block(resp);\n        }\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        DKResponse *resp = [[DKResponse alloc] init];\n        resp.error = error;\n        if (block) {\n            block(resp);\n        }\n    }];\n} \n```    \n\n## 在 AppDelegte内注册\n\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n  [[[DKUncaughtExceptionHandler alloc] init] installExceptionHandler];\n\treturn YES:\n}\n```\n\n## iOS设备测试编号转机型\n\n```\n+ (NSString *) deviceVersion:(NSString *)deviceString\n{\n    //iPhone\n    if ([deviceString isEqualToString:@\"iPhone1,1\"])    return @\"iPhone 1G\";\n    if ([deviceString isEqualToString:@\"iPhone1,2\"])    return @\"iPhone 3G\";\n    if ([deviceString isEqualToString:@\"iPhone2,1\"])    return @\"iPhone 3GS\";\n    if ([deviceString isEqualToString:@\"iPhone3,1\"])    return @\"iPhone 4\";\n    if ([deviceString isEqualToString:@\"iPhone3,2\"])    return @\"Verizon iPhone 4\";\n    if ([deviceString isEqualToString:@\"iPhone4,1\"])    return @\"iPhone 4S\";\n    if ([deviceString isEqualToString:@\"iPhone5,1\"])    return @\"iPhone 5\";\n    if ([deviceString isEqualToString:@\"iPhone5,2\"])    return @\"iPhone 5\";\n    if ([deviceString isEqualToString:@\"iPhone5,3\"])    return @\"iPhone 5C\";\n    if ([deviceString isEqualToString:@\"iPhone5,4\"])    return @\"iPhone 5C\";\n    if ([deviceString isEqualToString:@\"iPhone6,1\"])    return @\"iPhone 5S\";\n    if ([deviceString isEqualToString:@\"iPhone6,2\"])    return @\"iPhone 5S\";\n    if ([deviceString isEqualToString:@\"iPhone7,1\"])    return @\"iPhone 6 Plus\";\n    if ([deviceString isEqualToString:@\"iPhone7,2\"])    return @\"iPhone 6\";\n    if ([deviceString isEqualToString:@\"iPhone8,1\"])    return @\"iPhone 6s\";\n    if ([deviceString isEqualToString:@\"iPhone8,2\"])    return @\"iPhone 6s Plus\";\n    if ([deviceString isEqualToString:@\"iPhone8,4\"])    return @\"iPhone SE\";\n    if ([deviceString isEqualToString:@\"iPhone9,1\"])    return @\"iPhone 7\";\n    if ([deviceString isEqualToString:@\"iPhone9,3\"])    return @\"iPhone 7\";\n    if ([deviceString isEqualToString:@\"iPhone9,2\"])    return @\"iPhone 7 Plus\";\n    if ([deviceString isEqualToString:@\"iPhone9,4\"])    return @\"iPhone 7 Plus\";\n    \n    //iPod\n    if ([deviceString isEqualToString:@\"iPod1,1\"])      return @\"iPod Touch 1G\";\n    if ([deviceString isEqualToString:@\"iPod2,1\"])      return @\"iPod Touch 2G\";\n    if ([deviceString isEqualToString:@\"iPod3,1\"])      return @\"iPod Touch 3G\";\n    if ([deviceString isEqualToString:@\"iPod4,1\"])      return @\"iPod Touch 4G\";\n    if ([deviceString isEqualToString:@\"iPod5,1\"])      return @\"iPod Touch 5G\";\n    \n    //iPad\n    if ([deviceString isEqualToString:@\"iPad1,1\"])      return @\"iPad\";\n    if ([deviceString isEqualToString:@\"iPad2,1\"])      return @\"iPad 2 (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad2,2\"])      return @\"iPad 2 (GSM)\";\n    if ([deviceString isEqualToString:@\"iPad2,3\"])      return @\"iPad 2 (CDMA)\";\n    if ([deviceString isEqualToString:@\"iPad2,4\"])      return @\"iPad 2 (32nm)\";\n    if ([deviceString isEqualToString:@\"iPad2,5\"])      return @\"iPad mini (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad2,6\"])      return @\"iPad mini (GSM)\";\n    if ([deviceString isEqualToString:@\"iPad2,7\"])      return @\"iPad mini (CDMA)\";\n    \n    if ([deviceString isEqualToString:@\"iPad3,1\"])      return @\"iPad 3(WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad3,2\"])      return @\"iPad 3(CDMA)\";\n    if ([deviceString isEqualToString:@\"iPad3,3\"])      return @\"iPad 3(4G)\";\n    if ([deviceString isEqualToString:@\"iPad3,4\"])      return @\"iPad 4 (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad3,5\"])      return @\"iPad 4 (4G)\";\n    if ([deviceString isEqualToString:@\"iPad3,6\"])      return @\"iPad 4 (CDMA)\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,1\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad4,2\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad4,3\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad5,3\"])      return @\"iPad Air 2\";\n    if ([deviceString isEqualToString:@\"iPad5,4\"])      return @\"iPad Air 2\";\n    if ([deviceString isEqualToString:@\"i386\"])         return @\"Simulator\";\n    if ([deviceString isEqualToString:@\"x86_64\"])       return @\"Simulator\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,4\"]\n        ||[deviceString isEqualToString:@\"iPad4,5\"]\n        ||[deviceString isEqualToString:@\"iPad4,6\"])      return @\"iPad mini 2\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,7\"]\n        ||[deviceString isEqualToString:@\"iPad4,8\"]\n        ||[deviceString isEqualToString:@\"iPad4,9\"])      return @\"iPad mini 3\";\n    \n    return deviceString;\n}\n```","source":"_posts/Dankal-iOS崩溃信息提交.md","raw":"---\ntitle: Dankal_iOS崩溃信息提交\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: afeed214\ndate: 2016-11-01 00:00:00\n---\nDankal_iOS 崩溃信息提交\n<!-- more -->\n\n1. 获取到崩溃信息（异常原因，异常方法，异常类名，堆栈）\n2. 获取到本机信息（型号，系统）\n3. 保存为 plist到本地\n4. 下次启动应用的时候发送信息到服务器(POST发送，记得添加 token 到HEADER)\n5. 发送完之后删除掉 plist 文件\n\n---\n\n## 如何捕获崩溃信息\n\nC 语言捕获\n\n```\n#include <libkern/OSAtomic.h>\n#include <execinfo.h>\n\n// 系统信号截获处理方法\nvoid signalHandler(int signal);\n// 异常截获处理方法\nvoid exceptionHandler(NSException *exception);\nconst int32_t _uncaughtExceptionMaximum = 20;\n\nNSString * const UncaughtExceptionHandlerSignalKey = @\"UncaughtExceptionHandlerSignalKey\";\nNSString *const SingalExceptionHandlerAddressesKey = @\"SingalExceptionHandlerAddressesKey\";\nNSString *const ExceptionHandlerAddressesKey = @\"ExceptionHandlerAddressesKey\";\n\nvoid signalHandler(int signal)\n{\n    volatile int32_t _uncaughtExceptionCount = 0;\n    int32_t exceptionCount = OSAtomicIncrement32(&_uncaughtExceptionCount);\n    if (exceptionCount > _uncaughtExceptionMaximum) // 如果太多不用处理\n    {\n        return;\n    }\n    // 获取信息\n    NSMutableDictionary *userInfo =\n    [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey];\n    \n    NSArray *callStack = [DKUncaughtExceptionHandler backtrace];\n    [userInfo  setObject:callStack  forKey:SingalExceptionHandlerAddressesKey];\n    \n}\n\nvoid exceptionHandler(NSException *exception)\n{\n    volatile int32_t _uncaughtExceptionCount = 0;\n    int32_t exceptionCount = OSAtomicIncrement32(&_uncaughtExceptionCount);\n    if (exceptionCount > _uncaughtExceptionMaximum) // 如果太多不用处理\n    {\n        return;\n    }\n    \n    NSArray *callStack = [DKUncaughtExceptionHandler backtrace];\n    NSMutableDictionary *userInfo =[NSMutableDictionary dictionaryWithDictionary:[exception userInfo]];\n    [userInfo setObject:callStack forKey:ExceptionHandlerAddressesKey];\n    \n    // 保存信息到本地\n    NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] stringByAppendingPathComponent:@\"crash.plist\"];\n    \n    // 获取本机信息\n    struct utsname systemInfo;\n    uname(&systemInfo);\n    \n    NSDictionary *crashInfo = @{@\"crash_time\":[NSDate dateStringWithDateFormat:@\"yyyy-MM-dd HH:mm:ss\"],\n                                @\"device_type\": [DKUncaughtExceptionHandler deviceVersion:[NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]],\n                                @\"device_system\": [UIDevice currentDevice].systemVersion,\n                                @\"crash_type\":exception.name,\n                                @\"crash_reason\":exception.reason,\n                                @\"crash_stack\":userInfo.descriptionInStringsFileFormat};\n    [crashInfo writeToFile:path atomically:YES];\n}\n```\n\n## OC 部分获取调用堆栈和注册崩溃拦截\n\n```\n//获取调用堆栈\n+ (NSArray *)backtrace\n{\n    void* callstack[128];\n    int frames = backtrace(callstack, 128);\n    char **strs = backtrace_symbols(callstack,frames);\n    \n    NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames];\n    for (int i=0;i<frames;i++)\n    {\n        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];\n    }\n    free(strs);\n    \n    return backtrace;\n}\n\n// 注册崩溃拦截\n- (void)installExceptionHandler\n{\n    NSSetUncaughtExceptionHandler(&exceptionHandler);\n    signal(SIGHUP, signalHandler);\n    signal(SIGINT, signalHandler);\n    signal(SIGQUIT, signalHandler);\n    \n    signal(SIGABRT, signalHandler);\n    signal(SIGILL, signalHandler);\n    signal(SIGSEGV, signalHandler);\n    signal(SIGFPE, signalHandler);\n    signal(SIGBUS, signalHandler);\n    signal(SIGPIPE, signalHandler);\n    \n    NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] stringByAppendingPathComponent:@\"crash.plist\"];\n    if([[NSFileManager defaultManager] fileExistsAtPath:path]){\n        NSDictionary *params = [[NSDictionary alloc] initWithContentsOfFile:path];\n        [DKHTTPTool POST:去看 Coding 的Crash Reporter项目说明文档  parameters:params header:@{@\"token\":去看 Coding的Crash Reporter项目说明文档} responseBlock:^(DKResponse *response) {\n            if (!response.error) {\n                NSError *error;\n                [[NSFileManager defaultManager] removeItemAtPath:path error:&error];\n                if(error)DKLog(@\"%@\",error);\n            }\n        }];\n    }\n}\n```\n\n## 发送请求的AFN封装方法\n\n```\n+ (void)POST:(NSString *)URLString parameters:(id)parameters header:(NSDictionary *)headerField responseBlock:(DKHTTPResponseBlock)block\n{\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n    AFHTTPRequestSerializer *requestSerializer =  [AFJSONRequestSerializer serializer];\n    [headerField enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        [requestSerializer setValue:obj forHTTPHeaderField:key];\n    }];\n    mgr.requestSerializer = requestSerializer;\n    [mgr POST:URLString parameters:parameters  progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\n        resp.rawData = responseObject;\n        if(block){\n            block(resp);\n        }\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        DKResponse *resp = [[DKResponse alloc] init];\n        resp.error = error;\n        if (block) {\n            block(resp);\n        }\n    }];\n} \n```    \n\n## 在 AppDelegte内注册\n\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n  [[[DKUncaughtExceptionHandler alloc] init] installExceptionHandler];\n\treturn YES:\n}\n```\n\n## iOS设备测试编号转机型\n\n```\n+ (NSString *) deviceVersion:(NSString *)deviceString\n{\n    //iPhone\n    if ([deviceString isEqualToString:@\"iPhone1,1\"])    return @\"iPhone 1G\";\n    if ([deviceString isEqualToString:@\"iPhone1,2\"])    return @\"iPhone 3G\";\n    if ([deviceString isEqualToString:@\"iPhone2,1\"])    return @\"iPhone 3GS\";\n    if ([deviceString isEqualToString:@\"iPhone3,1\"])    return @\"iPhone 4\";\n    if ([deviceString isEqualToString:@\"iPhone3,2\"])    return @\"Verizon iPhone 4\";\n    if ([deviceString isEqualToString:@\"iPhone4,1\"])    return @\"iPhone 4S\";\n    if ([deviceString isEqualToString:@\"iPhone5,1\"])    return @\"iPhone 5\";\n    if ([deviceString isEqualToString:@\"iPhone5,2\"])    return @\"iPhone 5\";\n    if ([deviceString isEqualToString:@\"iPhone5,3\"])    return @\"iPhone 5C\";\n    if ([deviceString isEqualToString:@\"iPhone5,4\"])    return @\"iPhone 5C\";\n    if ([deviceString isEqualToString:@\"iPhone6,1\"])    return @\"iPhone 5S\";\n    if ([deviceString isEqualToString:@\"iPhone6,2\"])    return @\"iPhone 5S\";\n    if ([deviceString isEqualToString:@\"iPhone7,1\"])    return @\"iPhone 6 Plus\";\n    if ([deviceString isEqualToString:@\"iPhone7,2\"])    return @\"iPhone 6\";\n    if ([deviceString isEqualToString:@\"iPhone8,1\"])    return @\"iPhone 6s\";\n    if ([deviceString isEqualToString:@\"iPhone8,2\"])    return @\"iPhone 6s Plus\";\n    if ([deviceString isEqualToString:@\"iPhone8,4\"])    return @\"iPhone SE\";\n    if ([deviceString isEqualToString:@\"iPhone9,1\"])    return @\"iPhone 7\";\n    if ([deviceString isEqualToString:@\"iPhone9,3\"])    return @\"iPhone 7\";\n    if ([deviceString isEqualToString:@\"iPhone9,2\"])    return @\"iPhone 7 Plus\";\n    if ([deviceString isEqualToString:@\"iPhone9,4\"])    return @\"iPhone 7 Plus\";\n    \n    //iPod\n    if ([deviceString isEqualToString:@\"iPod1,1\"])      return @\"iPod Touch 1G\";\n    if ([deviceString isEqualToString:@\"iPod2,1\"])      return @\"iPod Touch 2G\";\n    if ([deviceString isEqualToString:@\"iPod3,1\"])      return @\"iPod Touch 3G\";\n    if ([deviceString isEqualToString:@\"iPod4,1\"])      return @\"iPod Touch 4G\";\n    if ([deviceString isEqualToString:@\"iPod5,1\"])      return @\"iPod Touch 5G\";\n    \n    //iPad\n    if ([deviceString isEqualToString:@\"iPad1,1\"])      return @\"iPad\";\n    if ([deviceString isEqualToString:@\"iPad2,1\"])      return @\"iPad 2 (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad2,2\"])      return @\"iPad 2 (GSM)\";\n    if ([deviceString isEqualToString:@\"iPad2,3\"])      return @\"iPad 2 (CDMA)\";\n    if ([deviceString isEqualToString:@\"iPad2,4\"])      return @\"iPad 2 (32nm)\";\n    if ([deviceString isEqualToString:@\"iPad2,5\"])      return @\"iPad mini (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad2,6\"])      return @\"iPad mini (GSM)\";\n    if ([deviceString isEqualToString:@\"iPad2,7\"])      return @\"iPad mini (CDMA)\";\n    \n    if ([deviceString isEqualToString:@\"iPad3,1\"])      return @\"iPad 3(WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad3,2\"])      return @\"iPad 3(CDMA)\";\n    if ([deviceString isEqualToString:@\"iPad3,3\"])      return @\"iPad 3(4G)\";\n    if ([deviceString isEqualToString:@\"iPad3,4\"])      return @\"iPad 4 (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad3,5\"])      return @\"iPad 4 (4G)\";\n    if ([deviceString isEqualToString:@\"iPad3,6\"])      return @\"iPad 4 (CDMA)\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,1\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad4,2\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad4,3\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad5,3\"])      return @\"iPad Air 2\";\n    if ([deviceString isEqualToString:@\"iPad5,4\"])      return @\"iPad Air 2\";\n    if ([deviceString isEqualToString:@\"i386\"])         return @\"Simulator\";\n    if ([deviceString isEqualToString:@\"x86_64\"])       return @\"Simulator\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,4\"]\n        ||[deviceString isEqualToString:@\"iPad4,5\"]\n        ||[deviceString isEqualToString:@\"iPad4,6\"])      return @\"iPad mini 2\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,7\"]\n        ||[deviceString isEqualToString:@\"iPad4,8\"]\n        ||[deviceString isEqualToString:@\"iPad4,9\"])      return @\"iPad mini 3\";\n    \n    return deviceString;\n}\n```","slug":"Dankal-iOS崩溃信息提交","published":1,"updated":"2018-05-10T06:51:35.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcgv0005ldxu3ifeqvvy","content":"<p>Dankal_iOS 崩溃信息提交<br><a id=\"more\"></a></p>\n<ol>\n<li>获取到崩溃信息（异常原因，异常方法，异常类名，堆栈）</li>\n<li>获取到本机信息（型号，系统）</li>\n<li>保存为 plist到本地</li>\n<li>下次启动应用的时候发送信息到服务器(POST发送，记得添加 token 到HEADER)</li>\n<li>发送完之后删除掉 plist 文件</li>\n</ol>\n<hr>\n<h2 id=\"如何捕获崩溃信息\"><a href=\"#如何捕获崩溃信息\" class=\"headerlink\" title=\"如何捕获崩溃信息\"></a>如何捕获崩溃信息</h2><p>C 语言捕获</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;libkern/OSAtomic.h&gt;</span><br><span class=\"line\">#include &lt;execinfo.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 系统信号截获处理方法</span><br><span class=\"line\">void signalHandler(int signal);</span><br><span class=\"line\">// 异常截获处理方法</span><br><span class=\"line\">void exceptionHandler(NSException *exception);</span><br><span class=\"line\">const int32_t _uncaughtExceptionMaximum = 20;</span><br><span class=\"line\"></span><br><span class=\"line\">NSString * const UncaughtExceptionHandlerSignalKey = @&quot;UncaughtExceptionHandlerSignalKey&quot;;</span><br><span class=\"line\">NSString *const SingalExceptionHandlerAddressesKey = @&quot;SingalExceptionHandlerAddressesKey&quot;;</span><br><span class=\"line\">NSString *const ExceptionHandlerAddressesKey = @&quot;ExceptionHandlerAddressesKey&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">void signalHandler(int signal)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    volatile int32_t _uncaughtExceptionCount = 0;</span><br><span class=\"line\">    int32_t exceptionCount = OSAtomicIncrement32(&amp;_uncaughtExceptionCount);</span><br><span class=\"line\">    if (exceptionCount &gt; _uncaughtExceptionMaximum) // 如果太多不用处理</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 获取信息</span><br><span class=\"line\">    NSMutableDictionary *userInfo =</span><br><span class=\"line\">    [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSArray *callStack = [DKUncaughtExceptionHandler backtrace];</span><br><span class=\"line\">    [userInfo  setObject:callStack  forKey:SingalExceptionHandlerAddressesKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void exceptionHandler(NSException *exception)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    volatile int32_t _uncaughtExceptionCount = 0;</span><br><span class=\"line\">    int32_t exceptionCount = OSAtomicIncrement32(&amp;_uncaughtExceptionCount);</span><br><span class=\"line\">    if (exceptionCount &gt; _uncaughtExceptionMaximum) // 如果太多不用处理</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSArray *callStack = [DKUncaughtExceptionHandler backtrace];</span><br><span class=\"line\">    NSMutableDictionary *userInfo =[NSMutableDictionary dictionaryWithDictionary:[exception userInfo]];</span><br><span class=\"line\">    [userInfo setObject:callStack forKey:ExceptionHandlerAddressesKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 保存信息到本地</span><br><span class=\"line\">    NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] stringByAppendingPathComponent:@&quot;crash.plist&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 获取本机信息</span><br><span class=\"line\">    struct utsname systemInfo;</span><br><span class=\"line\">    uname(&amp;systemInfo);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSDictionary *crashInfo = @&#123;@&quot;crash_time&quot;:[NSDate dateStringWithDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;],</span><br><span class=\"line\">                                @&quot;device_type&quot;: [DKUncaughtExceptionHandler deviceVersion:[NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]],</span><br><span class=\"line\">                                @&quot;device_system&quot;: [UIDevice currentDevice].systemVersion,</span><br><span class=\"line\">                                @&quot;crash_type&quot;:exception.name,</span><br><span class=\"line\">                                @&quot;crash_reason&quot;:exception.reason,</span><br><span class=\"line\">                                @&quot;crash_stack&quot;:userInfo.descriptionInStringsFileFormat&#125;;</span><br><span class=\"line\">    [crashInfo writeToFile:path atomically:YES];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"OC-部分获取调用堆栈和注册崩溃拦截\"><a href=\"#OC-部分获取调用堆栈和注册崩溃拦截\" class=\"headerlink\" title=\"OC 部分获取调用堆栈和注册崩溃拦截\"></a>OC 部分获取调用堆栈和注册崩溃拦截</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取调用堆栈</span><br><span class=\"line\">+ (NSArray *)backtrace</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    void* callstack[128];</span><br><span class=\"line\">    int frames = backtrace(callstack, 128);</span><br><span class=\"line\">    char **strs = backtrace_symbols(callstack,frames);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames];</span><br><span class=\"line\">    for (int i=0;i&lt;frames;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free(strs);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return backtrace;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 注册崩溃拦截</span><br><span class=\"line\">- (void)installExceptionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSSetUncaughtExceptionHandler(&amp;exceptionHandler);</span><br><span class=\"line\">    signal(SIGHUP, signalHandler);</span><br><span class=\"line\">    signal(SIGINT, signalHandler);</span><br><span class=\"line\">    signal(SIGQUIT, signalHandler);</span><br><span class=\"line\">    </span><br><span class=\"line\">    signal(SIGABRT, signalHandler);</span><br><span class=\"line\">    signal(SIGILL, signalHandler);</span><br><span class=\"line\">    signal(SIGSEGV, signalHandler);</span><br><span class=\"line\">    signal(SIGFPE, signalHandler);</span><br><span class=\"line\">    signal(SIGBUS, signalHandler);</span><br><span class=\"line\">    signal(SIGPIPE, signalHandler);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] stringByAppendingPathComponent:@&quot;crash.plist&quot;];</span><br><span class=\"line\">    if([[NSFileManager defaultManager] fileExistsAtPath:path])&#123;</span><br><span class=\"line\">        NSDictionary *params = [[NSDictionary alloc] initWithContentsOfFile:path];</span><br><span class=\"line\">        [DKHTTPTool POST:去看 Coding 的Crash Reporter项目说明文档  parameters:params header:@&#123;@&quot;token&quot;:去看 Coding的Crash Reporter项目说明文档&#125; responseBlock:^(DKResponse *response) &#123;</span><br><span class=\"line\">            if (!response.error) &#123;</span><br><span class=\"line\">                NSError *error;</span><br><span class=\"line\">                [[NSFileManager defaultManager] removeItemAtPath:path error:&amp;error];</span><br><span class=\"line\">                if(error)DKLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"发送请求的AFN封装方法\"><a href=\"#发送请求的AFN封装方法\" class=\"headerlink\" title=\"发送请求的AFN封装方法\"></a>发送请求的AFN封装方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)POST:(NSString *)URLString parameters:(id)parameters header:(NSDictionary *)headerField responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer =  [AFJSONRequestSerializer serializer];</span><br><span class=\"line\">    [headerField enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [requestSerializer setValue:obj forHTTPHeaderField:key];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    mgr.requestSerializer = requestSerializer;</span><br><span class=\"line\">    [mgr POST:URLString parameters:parameters  progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];</span><br><span class=\"line\">        resp.rawData = responseObject;</span><br><span class=\"line\">        if(block)&#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKResponse *resp = [[DKResponse alloc] init];</span><br><span class=\"line\">        resp.error = error;</span><br><span class=\"line\">        if (block) &#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">```    </span><br><span class=\"line\"></span><br><span class=\"line\">## 在 AppDelegte内注册</span><br></pre></td></tr></table></figure>\n<ul>\n<li>(BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions<br>{<br>[[[DKUncaughtExceptionHandler alloc] init] installExceptionHandler];<br>  return YES:<br>}<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## iOS设备测试编号转机型</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>(NSString <em>) deviceVersion:(NSString </em>)deviceString<br>{<br>  //iPhone<br>  if ([deviceString isEqualToString:@”iPhone1,1”])    return @”iPhone 1G”;<br>  if ([deviceString isEqualToString:@”iPhone1,2”])    return @”iPhone 3G”;<br>  if ([deviceString isEqualToString:@”iPhone2,1”])    return @”iPhone 3GS”;<br>  if ([deviceString isEqualToString:@”iPhone3,1”])    return @”iPhone 4”;<br>  if ([deviceString isEqualToString:@”iPhone3,2”])    return @”Verizon iPhone 4”;<br>  if ([deviceString isEqualToString:@”iPhone4,1”])    return @”iPhone 4S”;<br>  if ([deviceString isEqualToString:@”iPhone5,1”])    return @”iPhone 5”;<br>  if ([deviceString isEqualToString:@”iPhone5,2”])    return @”iPhone 5”;<br>  if ([deviceString isEqualToString:@”iPhone5,3”])    return @”iPhone 5C”;<br>  if ([deviceString isEqualToString:@”iPhone5,4”])    return @”iPhone 5C”;<br>  if ([deviceString isEqualToString:@”iPhone6,1”])    return @”iPhone 5S”;<br>  if ([deviceString isEqualToString:@”iPhone6,2”])    return @”iPhone 5S”;<br>  if ([deviceString isEqualToString:@”iPhone7,1”])    return @”iPhone 6 Plus”;<br>  if ([deviceString isEqualToString:@”iPhone7,2”])    return @”iPhone 6”;<br>  if ([deviceString isEqualToString:@”iPhone8,1”])    return @”iPhone 6s”;<br>  if ([deviceString isEqualToString:@”iPhone8,2”])    return @”iPhone 6s Plus”;<br>  if ([deviceString isEqualToString:@”iPhone8,4”])    return @”iPhone SE”;<br>  if ([deviceString isEqualToString:@”iPhone9,1”])    return @”iPhone 7”;<br>  if ([deviceString isEqualToString:@”iPhone9,3”])    return @”iPhone 7”;<br>  if ([deviceString isEqualToString:@”iPhone9,2”])    return @”iPhone 7 Plus”;<br>  if ([deviceString isEqualToString:@”iPhone9,4”])    return @”iPhone 7 Plus”;</p>\n<p>  //iPod<br>  if ([deviceString isEqualToString:@”iPod1,1”])      return @”iPod Touch 1G”;<br>  if ([deviceString isEqualToString:@”iPod2,1”])      return @”iPod Touch 2G”;<br>  if ([deviceString isEqualToString:@”iPod3,1”])      return @”iPod Touch 3G”;<br>  if ([deviceString isEqualToString:@”iPod4,1”])      return @”iPod Touch 4G”;<br>  if ([deviceString isEqualToString:@”iPod5,1”])      return @”iPod Touch 5G”;</p>\n<p>  //iPad<br>  if ([deviceString isEqualToString:@”iPad1,1”])      return @”iPad”;<br>  if ([deviceString isEqualToString:@”iPad2,1”])      return @”iPad 2 (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad2,2”])      return @”iPad 2 (GSM)”;<br>  if ([deviceString isEqualToString:@”iPad2,3”])      return @”iPad 2 (CDMA)”;<br>  if ([deviceString isEqualToString:@”iPad2,4”])      return @”iPad 2 (32nm)”;<br>  if ([deviceString isEqualToString:@”iPad2,5”])      return @”iPad mini (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad2,6”])      return @”iPad mini (GSM)”;<br>  if ([deviceString isEqualToString:@”iPad2,7”])      return @”iPad mini (CDMA)”;</p>\n<p>  if ([deviceString isEqualToString:@”iPad3,1”])      return @”iPad 3(WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad3,2”])      return @”iPad 3(CDMA)”;<br>  if ([deviceString isEqualToString:@”iPad3,3”])      return @”iPad 3(4G)”;<br>  if ([deviceString isEqualToString:@”iPad3,4”])      return @”iPad 4 (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad3,5”])      return @”iPad 4 (4G)”;<br>  if ([deviceString isEqualToString:@”iPad3,6”])      return @”iPad 4 (CDMA)”;</p>\n<p>  if ([deviceString isEqualToString:@”iPad4,1”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad4,2”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad4,3”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad5,3”])      return @”iPad Air 2”;<br>  if ([deviceString isEqualToString:@”iPad5,4”])      return @”iPad Air 2”;<br>  if ([deviceString isEqualToString:@”i386”])         return @”Simulator”;<br>  if ([deviceString isEqualToString:@”x86_64”])       return @”Simulator”;</p>\n<p>  if ([deviceString isEqualToString:@”iPad4,4”]</p>\n<pre><code>||[deviceString isEqualToString:@&quot;iPad4,5&quot;]\n||[deviceString isEqualToString:@&quot;iPad4,6&quot;])      return @&quot;iPad mini 2&quot;;\n</code></pre><p>  if ([deviceString isEqualToString:@”iPad4,7”]</p>\n<pre><code>||[deviceString isEqualToString:@&quot;iPad4,8&quot;]\n||[deviceString isEqualToString:@&quot;iPad4,9&quot;])      return @&quot;iPad mini 3&quot;;\n</code></pre><p>  return deviceString;<br>}<br>```</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Dankal_iOS 崩溃信息提交<br>","more":"</p>\n<ol>\n<li>获取到崩溃信息（异常原因，异常方法，异常类名，堆栈）</li>\n<li>获取到本机信息（型号，系统）</li>\n<li>保存为 plist到本地</li>\n<li>下次启动应用的时候发送信息到服务器(POST发送，记得添加 token 到HEADER)</li>\n<li>发送完之后删除掉 plist 文件</li>\n</ol>\n<hr>\n<h2 id=\"如何捕获崩溃信息\"><a href=\"#如何捕获崩溃信息\" class=\"headerlink\" title=\"如何捕获崩溃信息\"></a>如何捕获崩溃信息</h2><p>C 语言捕获</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;libkern/OSAtomic.h&gt;</span><br><span class=\"line\">#include &lt;execinfo.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 系统信号截获处理方法</span><br><span class=\"line\">void signalHandler(int signal);</span><br><span class=\"line\">// 异常截获处理方法</span><br><span class=\"line\">void exceptionHandler(NSException *exception);</span><br><span class=\"line\">const int32_t _uncaughtExceptionMaximum = 20;</span><br><span class=\"line\"></span><br><span class=\"line\">NSString * const UncaughtExceptionHandlerSignalKey = @&quot;UncaughtExceptionHandlerSignalKey&quot;;</span><br><span class=\"line\">NSString *const SingalExceptionHandlerAddressesKey = @&quot;SingalExceptionHandlerAddressesKey&quot;;</span><br><span class=\"line\">NSString *const ExceptionHandlerAddressesKey = @&quot;ExceptionHandlerAddressesKey&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">void signalHandler(int signal)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    volatile int32_t _uncaughtExceptionCount = 0;</span><br><span class=\"line\">    int32_t exceptionCount = OSAtomicIncrement32(&amp;_uncaughtExceptionCount);</span><br><span class=\"line\">    if (exceptionCount &gt; _uncaughtExceptionMaximum) // 如果太多不用处理</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 获取信息</span><br><span class=\"line\">    NSMutableDictionary *userInfo =</span><br><span class=\"line\">    [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSArray *callStack = [DKUncaughtExceptionHandler backtrace];</span><br><span class=\"line\">    [userInfo  setObject:callStack  forKey:SingalExceptionHandlerAddressesKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void exceptionHandler(NSException *exception)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    volatile int32_t _uncaughtExceptionCount = 0;</span><br><span class=\"line\">    int32_t exceptionCount = OSAtomicIncrement32(&amp;_uncaughtExceptionCount);</span><br><span class=\"line\">    if (exceptionCount &gt; _uncaughtExceptionMaximum) // 如果太多不用处理</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSArray *callStack = [DKUncaughtExceptionHandler backtrace];</span><br><span class=\"line\">    NSMutableDictionary *userInfo =[NSMutableDictionary dictionaryWithDictionary:[exception userInfo]];</span><br><span class=\"line\">    [userInfo setObject:callStack forKey:ExceptionHandlerAddressesKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 保存信息到本地</span><br><span class=\"line\">    NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] stringByAppendingPathComponent:@&quot;crash.plist&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 获取本机信息</span><br><span class=\"line\">    struct utsname systemInfo;</span><br><span class=\"line\">    uname(&amp;systemInfo);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSDictionary *crashInfo = @&#123;@&quot;crash_time&quot;:[NSDate dateStringWithDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;],</span><br><span class=\"line\">                                @&quot;device_type&quot;: [DKUncaughtExceptionHandler deviceVersion:[NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]],</span><br><span class=\"line\">                                @&quot;device_system&quot;: [UIDevice currentDevice].systemVersion,</span><br><span class=\"line\">                                @&quot;crash_type&quot;:exception.name,</span><br><span class=\"line\">                                @&quot;crash_reason&quot;:exception.reason,</span><br><span class=\"line\">                                @&quot;crash_stack&quot;:userInfo.descriptionInStringsFileFormat&#125;;</span><br><span class=\"line\">    [crashInfo writeToFile:path atomically:YES];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"OC-部分获取调用堆栈和注册崩溃拦截\"><a href=\"#OC-部分获取调用堆栈和注册崩溃拦截\" class=\"headerlink\" title=\"OC 部分获取调用堆栈和注册崩溃拦截\"></a>OC 部分获取调用堆栈和注册崩溃拦截</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取调用堆栈</span><br><span class=\"line\">+ (NSArray *)backtrace</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    void* callstack[128];</span><br><span class=\"line\">    int frames = backtrace(callstack, 128);</span><br><span class=\"line\">    char **strs = backtrace_symbols(callstack,frames);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames];</span><br><span class=\"line\">    for (int i=0;i&lt;frames;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free(strs);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return backtrace;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 注册崩溃拦截</span><br><span class=\"line\">- (void)installExceptionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSSetUncaughtExceptionHandler(&amp;exceptionHandler);</span><br><span class=\"line\">    signal(SIGHUP, signalHandler);</span><br><span class=\"line\">    signal(SIGINT, signalHandler);</span><br><span class=\"line\">    signal(SIGQUIT, signalHandler);</span><br><span class=\"line\">    </span><br><span class=\"line\">    signal(SIGABRT, signalHandler);</span><br><span class=\"line\">    signal(SIGILL, signalHandler);</span><br><span class=\"line\">    signal(SIGSEGV, signalHandler);</span><br><span class=\"line\">    signal(SIGFPE, signalHandler);</span><br><span class=\"line\">    signal(SIGBUS, signalHandler);</span><br><span class=\"line\">    signal(SIGPIPE, signalHandler);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] stringByAppendingPathComponent:@&quot;crash.plist&quot;];</span><br><span class=\"line\">    if([[NSFileManager defaultManager] fileExistsAtPath:path])&#123;</span><br><span class=\"line\">        NSDictionary *params = [[NSDictionary alloc] initWithContentsOfFile:path];</span><br><span class=\"line\">        [DKHTTPTool POST:去看 Coding 的Crash Reporter项目说明文档  parameters:params header:@&#123;@&quot;token&quot;:去看 Coding的Crash Reporter项目说明文档&#125; responseBlock:^(DKResponse *response) &#123;</span><br><span class=\"line\">            if (!response.error) &#123;</span><br><span class=\"line\">                NSError *error;</span><br><span class=\"line\">                [[NSFileManager defaultManager] removeItemAtPath:path error:&amp;error];</span><br><span class=\"line\">                if(error)DKLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"发送请求的AFN封装方法\"><a href=\"#发送请求的AFN封装方法\" class=\"headerlink\" title=\"发送请求的AFN封装方法\"></a>发送请求的AFN封装方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)POST:(NSString *)URLString parameters:(id)parameters header:(NSDictionary *)headerField responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer =  [AFJSONRequestSerializer serializer];</span><br><span class=\"line\">    [headerField enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [requestSerializer setValue:obj forHTTPHeaderField:key];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    mgr.requestSerializer = requestSerializer;</span><br><span class=\"line\">    [mgr POST:URLString parameters:parameters  progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];</span><br><span class=\"line\">        resp.rawData = responseObject;</span><br><span class=\"line\">        if(block)&#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKResponse *resp = [[DKResponse alloc] init];</span><br><span class=\"line\">        resp.error = error;</span><br><span class=\"line\">        if (block) &#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">```    </span><br><span class=\"line\"></span><br><span class=\"line\">## 在 AppDelegte内注册</span><br></pre></td></tr></table></figure>\n<ul>\n<li>(BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions<br>{<br>[[[DKUncaughtExceptionHandler alloc] init] installExceptionHandler];<br>  return YES:<br>}<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## iOS设备测试编号转机型</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>(NSString <em>) deviceVersion:(NSString </em>)deviceString<br>{<br>  //iPhone<br>  if ([deviceString isEqualToString:@”iPhone1,1”])    return @”iPhone 1G”;<br>  if ([deviceString isEqualToString:@”iPhone1,2”])    return @”iPhone 3G”;<br>  if ([deviceString isEqualToString:@”iPhone2,1”])    return @”iPhone 3GS”;<br>  if ([deviceString isEqualToString:@”iPhone3,1”])    return @”iPhone 4”;<br>  if ([deviceString isEqualToString:@”iPhone3,2”])    return @”Verizon iPhone 4”;<br>  if ([deviceString isEqualToString:@”iPhone4,1”])    return @”iPhone 4S”;<br>  if ([deviceString isEqualToString:@”iPhone5,1”])    return @”iPhone 5”;<br>  if ([deviceString isEqualToString:@”iPhone5,2”])    return @”iPhone 5”;<br>  if ([deviceString isEqualToString:@”iPhone5,3”])    return @”iPhone 5C”;<br>  if ([deviceString isEqualToString:@”iPhone5,4”])    return @”iPhone 5C”;<br>  if ([deviceString isEqualToString:@”iPhone6,1”])    return @”iPhone 5S”;<br>  if ([deviceString isEqualToString:@”iPhone6,2”])    return @”iPhone 5S”;<br>  if ([deviceString isEqualToString:@”iPhone7,1”])    return @”iPhone 6 Plus”;<br>  if ([deviceString isEqualToString:@”iPhone7,2”])    return @”iPhone 6”;<br>  if ([deviceString isEqualToString:@”iPhone8,1”])    return @”iPhone 6s”;<br>  if ([deviceString isEqualToString:@”iPhone8,2”])    return @”iPhone 6s Plus”;<br>  if ([deviceString isEqualToString:@”iPhone8,4”])    return @”iPhone SE”;<br>  if ([deviceString isEqualToString:@”iPhone9,1”])    return @”iPhone 7”;<br>  if ([deviceString isEqualToString:@”iPhone9,3”])    return @”iPhone 7”;<br>  if ([deviceString isEqualToString:@”iPhone9,2”])    return @”iPhone 7 Plus”;<br>  if ([deviceString isEqualToString:@”iPhone9,4”])    return @”iPhone 7 Plus”;</p>\n<p>  //iPod<br>  if ([deviceString isEqualToString:@”iPod1,1”])      return @”iPod Touch 1G”;<br>  if ([deviceString isEqualToString:@”iPod2,1”])      return @”iPod Touch 2G”;<br>  if ([deviceString isEqualToString:@”iPod3,1”])      return @”iPod Touch 3G”;<br>  if ([deviceString isEqualToString:@”iPod4,1”])      return @”iPod Touch 4G”;<br>  if ([deviceString isEqualToString:@”iPod5,1”])      return @”iPod Touch 5G”;</p>\n<p>  //iPad<br>  if ([deviceString isEqualToString:@”iPad1,1”])      return @”iPad”;<br>  if ([deviceString isEqualToString:@”iPad2,1”])      return @”iPad 2 (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad2,2”])      return @”iPad 2 (GSM)”;<br>  if ([deviceString isEqualToString:@”iPad2,3”])      return @”iPad 2 (CDMA)”;<br>  if ([deviceString isEqualToString:@”iPad2,4”])      return @”iPad 2 (32nm)”;<br>  if ([deviceString isEqualToString:@”iPad2,5”])      return @”iPad mini (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad2,6”])      return @”iPad mini (GSM)”;<br>  if ([deviceString isEqualToString:@”iPad2,7”])      return @”iPad mini (CDMA)”;</p>\n<p>  if ([deviceString isEqualToString:@”iPad3,1”])      return @”iPad 3(WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad3,2”])      return @”iPad 3(CDMA)”;<br>  if ([deviceString isEqualToString:@”iPad3,3”])      return @”iPad 3(4G)”;<br>  if ([deviceString isEqualToString:@”iPad3,4”])      return @”iPad 4 (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad3,5”])      return @”iPad 4 (4G)”;<br>  if ([deviceString isEqualToString:@”iPad3,6”])      return @”iPad 4 (CDMA)”;</p>\n<p>  if ([deviceString isEqualToString:@”iPad4,1”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad4,2”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad4,3”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad5,3”])      return @”iPad Air 2”;<br>  if ([deviceString isEqualToString:@”iPad5,4”])      return @”iPad Air 2”;<br>  if ([deviceString isEqualToString:@”i386”])         return @”Simulator”;<br>  if ([deviceString isEqualToString:@”x86_64”])       return @”Simulator”;</p>\n<p>  if ([deviceString isEqualToString:@”iPad4,4”]</p>\n<pre><code>||[deviceString isEqualToString:@&quot;iPad4,5&quot;]\n||[deviceString isEqualToString:@&quot;iPad4,6&quot;])      return @&quot;iPad mini 2&quot;;\n</code></pre><p>  if ([deviceString isEqualToString:@”iPad4,7”]</p>\n<pre><code>||[deviceString isEqualToString:@&quot;iPad4,8&quot;]\n||[deviceString isEqualToString:@&quot;iPad4,9&quot;])      return @&quot;iPad mini 3&quot;;\n</code></pre><p>  return deviceString;<br>}<br>```</p>\n</li>\n</ul>"},{"title":"Jenkins上蒲公英插件中update description 无法自动写入commit message问题解决","author":"Arclin","abbrlink":"5fcbb764","date":"2018-05-10T02:46:00.000Z","_content":"花了一天时间解决这个问题，找了好多资料都没找到，最后终于想到了办法。\n<!--more-->\n\n### 背景\n\n在Jenkins上使用蒲公英上传软件安装包有两种方法，一种是使用命令行的方式\n类似下面这种\n\n```\nIPANAME=\"jinkens-myapp\"\nfastlane gym --export_method ad-hoc --output_name ${IPANAME}\n\nMSG=`git log -1 --pretty=%B`\nPASSWORD=123456\ncurl -F \"file=@${IPANAME}\" -F \"uKey=USER_KEY\" -F \"_api_key=API_KEY\" -F \"updateDescription=${MSG}\" -F \"password=${PASSWORD}\" https://qiniu-storage.pgyer.com/apiv1/app/upload\n```\n\n这种方式的话就可以直接通过命令行获得`commit message`作为版本更新说明，但是缺点是无法直接通过环境变量获得上传后的App的各种信息，比如安装包地址，app二维码图片的等等。\n\n第二种方式是通过蒲公英在Jenkins上发布的插件`Upload to pgyer`，优点是上传后的各种App的信息都会被注入到环境变量中，可以在邮件模板中直接调用。缺点是Upload description必须写死为某个值，或者使用某个环境变量，但是Jenkins的Git插件又不提供给你最后一条`commit message`的环境变量。\n\n所以说为了结合两种方式的优点，想出了如下办法解决了。\n\n### 方法\n\n1. 安装插件\t`Environment Injector Plugin`\n2. 构建步骤添加`Execute Shell`，填写\n\t```\n\t# 把commit message写入文件中\n\tMSG=$(git log -1 --pretty=%B)\n\techo \"commitMessage=\"${MSG} > commitMessage.txt\n    ```\n3. 构件步骤中添加`Inject Environment variables`，`Properties File Path`填写`${WORKSPACE}/commitMessage.txt`(也有可能是别的路径，不要写错了)\n4. 最后在蒲公英插件`Upload to pgyer`上`updateDescription`中填写`${commitMessage}`\n\n\n就这样子就可以了，就是把message写到文件中，然后通过文件注入环境变量，然后蒲公英插件再去用就行了。","source":"_posts/Jenkins上蒲公英插件中update-description-无法自动写入commit-message问题解决.md","raw":"title: Jenkins上蒲公英插件中update description 无法自动写入commit message问题解决\nauthor: Arclin\ntags:\n  - Jenkins\ncategories:\n  - Jenkins\nabbrlink: 5fcbb764\ndate: 2018-05-10 10:46:00\n---\n花了一天时间解决这个问题，找了好多资料都没找到，最后终于想到了办法。\n<!--more-->\n\n### 背景\n\n在Jenkins上使用蒲公英上传软件安装包有两种方法，一种是使用命令行的方式\n类似下面这种\n\n```\nIPANAME=\"jinkens-myapp\"\nfastlane gym --export_method ad-hoc --output_name ${IPANAME}\n\nMSG=`git log -1 --pretty=%B`\nPASSWORD=123456\ncurl -F \"file=@${IPANAME}\" -F \"uKey=USER_KEY\" -F \"_api_key=API_KEY\" -F \"updateDescription=${MSG}\" -F \"password=${PASSWORD}\" https://qiniu-storage.pgyer.com/apiv1/app/upload\n```\n\n这种方式的话就可以直接通过命令行获得`commit message`作为版本更新说明，但是缺点是无法直接通过环境变量获得上传后的App的各种信息，比如安装包地址，app二维码图片的等等。\n\n第二种方式是通过蒲公英在Jenkins上发布的插件`Upload to pgyer`，优点是上传后的各种App的信息都会被注入到环境变量中，可以在邮件模板中直接调用。缺点是Upload description必须写死为某个值，或者使用某个环境变量，但是Jenkins的Git插件又不提供给你最后一条`commit message`的环境变量。\n\n所以说为了结合两种方式的优点，想出了如下办法解决了。\n\n### 方法\n\n1. 安装插件\t`Environment Injector Plugin`\n2. 构建步骤添加`Execute Shell`，填写\n\t```\n\t# 把commit message写入文件中\n\tMSG=$(git log -1 --pretty=%B)\n\techo \"commitMessage=\"${MSG} > commitMessage.txt\n    ```\n3. 构件步骤中添加`Inject Environment variables`，`Properties File Path`填写`${WORKSPACE}/commitMessage.txt`(也有可能是别的路径，不要写错了)\n4. 最后在蒲公英插件`Upload to pgyer`上`updateDescription`中填写`${commitMessage}`\n\n\n就这样子就可以了，就是把message写到文件中，然后通过文件注入环境变量，然后蒲公英插件再去用就行了。","slug":"Jenkins上蒲公英插件中update-description-无法自动写入commit-message问题解决","published":1,"updated":"2018-05-11T07:01:01.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbch30006ldxumcofczfl","content":"<p>花了一天时间解决这个问题，找了好多资料都没找到，最后终于想到了办法。<br><a id=\"more\"></a></p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>在Jenkins上使用蒲公英上传软件安装包有两种方法，一种是使用命令行的方式<br>类似下面这种</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IPANAME=&quot;jinkens-myapp&quot;</span><br><span class=\"line\">fastlane gym --export_method ad-hoc --output_name $&#123;IPANAME&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MSG=`git log -1 --pretty=%B`</span><br><span class=\"line\">PASSWORD=123456</span><br><span class=\"line\">curl -F &quot;file=@$&#123;IPANAME&#125;&quot; -F &quot;uKey=USER_KEY&quot; -F &quot;_api_key=API_KEY&quot; -F &quot;updateDescription=$&#123;MSG&#125;&quot; -F &quot;password=$&#123;PASSWORD&#125;&quot; https://qiniu-storage.pgyer.com/apiv1/app/upload</span><br></pre></td></tr></table></figure>\n<p>这种方式的话就可以直接通过命令行获得<code>commit message</code>作为版本更新说明，但是缺点是无法直接通过环境变量获得上传后的App的各种信息，比如安装包地址，app二维码图片的等等。</p>\n<p>第二种方式是通过蒲公英在Jenkins上发布的插件<code>Upload to pgyer</code>，优点是上传后的各种App的信息都会被注入到环境变量中，可以在邮件模板中直接调用。缺点是Upload description必须写死为某个值，或者使用某个环境变量，但是Jenkins的Git插件又不提供给你最后一条<code>commit message</code>的环境变量。</p>\n<p>所以说为了结合两种方式的优点，想出了如下办法解决了。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><ol>\n<li>安装插件    <code>Environment Injector Plugin</code></li>\n<li><p>构建步骤添加<code>Execute Shell</code>，填写</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 把commit message写入文件中</span><br><span class=\"line\">MSG=$(git log -1 --pretty=%B)</span><br><span class=\"line\">echo &quot;commitMessage=&quot;$&#123;MSG&#125; &gt; commitMessage.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>构件步骤中添加<code>Inject Environment variables</code>，<code>Properties File Path</code>填写<code>${WORKSPACE}/commitMessage.txt</code>(也有可能是别的路径，不要写错了)</p>\n</li>\n<li>最后在蒲公英插件<code>Upload to pgyer</code>上<code>updateDescription</code>中填写<code>${commitMessage}</code></li>\n</ol>\n<p>就这样子就可以了，就是把message写到文件中，然后通过文件注入环境变量，然后蒲公英插件再去用就行了。</p>\n","site":{"data":{}},"excerpt":"<p>花了一天时间解决这个问题，找了好多资料都没找到，最后终于想到了办法。<br>","more":"</p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>在Jenkins上使用蒲公英上传软件安装包有两种方法，一种是使用命令行的方式<br>类似下面这种</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IPANAME=&quot;jinkens-myapp&quot;</span><br><span class=\"line\">fastlane gym --export_method ad-hoc --output_name $&#123;IPANAME&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MSG=`git log -1 --pretty=%B`</span><br><span class=\"line\">PASSWORD=123456</span><br><span class=\"line\">curl -F &quot;file=@$&#123;IPANAME&#125;&quot; -F &quot;uKey=USER_KEY&quot; -F &quot;_api_key=API_KEY&quot; -F &quot;updateDescription=$&#123;MSG&#125;&quot; -F &quot;password=$&#123;PASSWORD&#125;&quot; https://qiniu-storage.pgyer.com/apiv1/app/upload</span><br></pre></td></tr></table></figure>\n<p>这种方式的话就可以直接通过命令行获得<code>commit message</code>作为版本更新说明，但是缺点是无法直接通过环境变量获得上传后的App的各种信息，比如安装包地址，app二维码图片的等等。</p>\n<p>第二种方式是通过蒲公英在Jenkins上发布的插件<code>Upload to pgyer</code>，优点是上传后的各种App的信息都会被注入到环境变量中，可以在邮件模板中直接调用。缺点是Upload description必须写死为某个值，或者使用某个环境变量，但是Jenkins的Git插件又不提供给你最后一条<code>commit message</code>的环境变量。</p>\n<p>所以说为了结合两种方式的优点，想出了如下办法解决了。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><ol>\n<li>安装插件    <code>Environment Injector Plugin</code></li>\n<li><p>构建步骤添加<code>Execute Shell</code>，填写</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 把commit message写入文件中</span><br><span class=\"line\">MSG=$(git log -1 --pretty=%B)</span><br><span class=\"line\">echo &quot;commitMessage=&quot;$&#123;MSG&#125; &gt; commitMessage.txt</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>构件步骤中添加<code>Inject Environment variables</code>，<code>Properties File Path</code>填写<code>${WORKSPACE}/commitMessage.txt</code>(也有可能是别的路径，不要写错了)</p>\n</li>\n<li>最后在蒲公英插件<code>Upload to pgyer</code>上<code>updateDescription</code>中填写<code>${commitMessage}</code></li>\n</ol>\n<p>就这样子就可以了，就是把message写到文件中，然后通过文件注入环境变量，然后蒲公英插件再去用就行了。</p>"},{"title":"Jenkins+Git+CocoaPods+Fir.im实现iOS应用持续集成","author":"Arclin","abbrlink":"13ecfb47","date":"2017-02-07T16:00:00.000Z","_content":"Jenkins 可以定时检测 Git 上的某个分支的代码，打包生成 ipa 后直接上传到 Fir.im\n\n<!-- more -->\n\n### 安装 Jenkins\n\n#### JDK\nJenkins 是基于 Java 的一个应用，所以你需要先有JDK ，安装 JDK 网上有很多资料这里就跳过了\n\n使用 Brew 安装 Jenkins\n\n```\nbrew install jenkins\n```\n\n### 启动 Jenkins\n\n`jenkins` 或者 `java -jar /usr/local/opt/jenkins/libexec/jenkins.war --httpPort=8088` 这种方法可以指定端口号执行\n\n如果想自动启动，需要先执行以下命令，创建启动项\n`ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents`\n\n可以编辑一下`~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist`这个文件\n`open ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist`\n\n想要让局域网都可以访问，需要把`–httpListenAddress=127.0.0.1`改成自己的局域网IP\n\n手动启动启动项可以执行\n\n```\nlaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist\n```\n\n### 配置Xcode项目\n\n使用 CocoaPods\n终端进入已有项目的目录下，执行\n\n填写 podfile 类似下面这样子\n\n```\ntarget 'TestJenkins' do\n\tpod 'MJExtension'\n  target 'TestJenkinsTests' do\n    inherit! :search_paths\n  end\nend\n```\n\n然后执行 `pod install`\n\n执行完成之后打开`TestJenkins.xcworkspace`\n\n打开 `Product - Scheme - Manage Scheme`\n\n把 `Share` 下面的勾都打上\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/888.png)\n\n\n### 上传到Git\n在终端进入该项目根目录，执行`git init`\n\n在 Git托管平台上新建一个项目，得到 git 远程仓库地址，然后在项目中添加该远程地址\n\n`git remote add origin git@git.coding.net:Arclin/TestJenkins.git`\n\n新的项目或许还需要`git pull origin master` pull一下Readme等东西\n\n1. `git add . ` 添加项目文件\n2. `git git commit -m \"initial\"` 提交更改\n3. `git push origin master` 推送到 master远程分支\n\n### 配置 Jenkins\n\n在浏览器中打开 Jenkins,比如我指定了8088端口的话，那就打开`http://localhost:8088/`,然后根据提示安装，注意里面有一个选择插件的界面，根据需要选择就好。\n\n#### 安装插件\n系统管理 - 插件管理 可以安装插件,建议安装\n\n- Git Server Plugin  \n- Git Client Plugin  \n- fir-plugin  （安装教程看 http://www.jianshu.com/p/9a245918a219）\n- Xcode integration\n- Keychains and Provisioning Profiles Management\n\n下面我们就会用上这些插件\n\n#### 新建一个Job\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/999.png)\n\n进行一系列配置\n设置包的保留天数还有天数。\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1001.png)\n\n源码管理\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1002.png)\n\n要先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。\n\n![](http://upload-images.jianshu.io/upload_images/1194012-6d1b6f56e4dac318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n构建触发器\n构建触发器设置这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。\n\n不过这里有两个配置还是需要是配置的\n\nPoll SCM (poll source code management) 轮询源码管理\n需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次\nBuild periodically (定时build)\n一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。\n\n格式是这样的\n\n分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日)\n\n例如 `H/10 * * * *` 就是每十分钟一次\n\n#### 构建环境\niOS打包需要签名文件和证书，所以这部分我们勾选“Keychains and Code Signing Identities”和“Mobile Provisioning Profiles”。\n\n在这之前\n\n在系统设置中进入Keychains and Provisioning Profiles Management页面，点击“浏览”按钮，分别上传自己的keychain和证书（是这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下）。上传成功后，我们再为keychain指明签名文件的名称。点击“Add Code Signing Identity”，最后添加成功后如下图所示\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1003.png)\n\npassword 填写你的用户密码\n\nCode Signing Identity 的内容来源是这里\n\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_1.png?version=1&modificationDate=1375867279000)\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_2.png?version=2&modificationDate=1375868440000)\n\nProvision Profiles Directory Path 的内容填上\n\n`/Users/Shared/Jenkins/Library/MobileDevice`\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/Screen+Shot+2013-08-07+at+14.17.05.png?version=1&modificationDate=1375877888000)\n\n回到项目配置\n\n这样子填写\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1004.png)\n\n#### 构建\n点击”增加构建步骤”,先后选择 XCode 和 Execute Shell\n\nXCode 配置如下\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1005.png)\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1006.png)\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1007.png)\n\nExecute Shell 只要写入这个命令就好\n\n`fir publish /Users/Arclin/.jenkins/workspace/TestJenkins/build/TestJenkins.ipa --token=你的fir.im Token`\n\n如果没安装 fir 命令行工具的话\n\n用`gem install fir-cli` 安装\n如果发现问题就看这里\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1008.png)\n\n然后保存回到Jenkins项目首页，点击立即构建，然后如果成功的话就会像下图那样子\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1009.png)\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1010.png)\n\n每隔一个触发器设定的时间，他就会检查一下 git 上面的代码，如果有发现更新就会自动 pull然后打包并上传到 fir.im\n\n结束","source":"_posts/Jenkins-Git-CocoaPods-Fir-im实现iOS应用持续集成.md","raw":"---\ntitle: Jenkins+Git+CocoaPods+Fir.im实现iOS应用持续集成\nauthor: Arclin\ntags:\n  - Jenkins\n  - Git\n  - CocoaPods\n  - Fir\ncategories:\n  - iOS\nabbrlink: 13ecfb47\ndate: 2017-02-08 00:00:00\n---\nJenkins 可以定时检测 Git 上的某个分支的代码，打包生成 ipa 后直接上传到 Fir.im\n\n<!-- more -->\n\n### 安装 Jenkins\n\n#### JDK\nJenkins 是基于 Java 的一个应用，所以你需要先有JDK ，安装 JDK 网上有很多资料这里就跳过了\n\n使用 Brew 安装 Jenkins\n\n```\nbrew install jenkins\n```\n\n### 启动 Jenkins\n\n`jenkins` 或者 `java -jar /usr/local/opt/jenkins/libexec/jenkins.war --httpPort=8088` 这种方法可以指定端口号执行\n\n如果想自动启动，需要先执行以下命令，创建启动项\n`ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents`\n\n可以编辑一下`~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist`这个文件\n`open ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist`\n\n想要让局域网都可以访问，需要把`–httpListenAddress=127.0.0.1`改成自己的局域网IP\n\n手动启动启动项可以执行\n\n```\nlaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist\n```\n\n### 配置Xcode项目\n\n使用 CocoaPods\n终端进入已有项目的目录下，执行\n\n填写 podfile 类似下面这样子\n\n```\ntarget 'TestJenkins' do\n\tpod 'MJExtension'\n  target 'TestJenkinsTests' do\n    inherit! :search_paths\n  end\nend\n```\n\n然后执行 `pod install`\n\n执行完成之后打开`TestJenkins.xcworkspace`\n\n打开 `Product - Scheme - Manage Scheme`\n\n把 `Share` 下面的勾都打上\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/888.png)\n\n\n### 上传到Git\n在终端进入该项目根目录，执行`git init`\n\n在 Git托管平台上新建一个项目，得到 git 远程仓库地址，然后在项目中添加该远程地址\n\n`git remote add origin git@git.coding.net:Arclin/TestJenkins.git`\n\n新的项目或许还需要`git pull origin master` pull一下Readme等东西\n\n1. `git add . ` 添加项目文件\n2. `git git commit -m \"initial\"` 提交更改\n3. `git push origin master` 推送到 master远程分支\n\n### 配置 Jenkins\n\n在浏览器中打开 Jenkins,比如我指定了8088端口的话，那就打开`http://localhost:8088/`,然后根据提示安装，注意里面有一个选择插件的界面，根据需要选择就好。\n\n#### 安装插件\n系统管理 - 插件管理 可以安装插件,建议安装\n\n- Git Server Plugin  \n- Git Client Plugin  \n- fir-plugin  （安装教程看 http://www.jianshu.com/p/9a245918a219）\n- Xcode integration\n- Keychains and Provisioning Profiles Management\n\n下面我们就会用上这些插件\n\n#### 新建一个Job\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/999.png)\n\n进行一系列配置\n设置包的保留天数还有天数。\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1001.png)\n\n源码管理\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1002.png)\n\n要先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。\n\n![](http://upload-images.jianshu.io/upload_images/1194012-6d1b6f56e4dac318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n构建触发器\n构建触发器设置这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。\n\n不过这里有两个配置还是需要是配置的\n\nPoll SCM (poll source code management) 轮询源码管理\n需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次\nBuild periodically (定时build)\n一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。\n\n格式是这样的\n\n分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日)\n\n例如 `H/10 * * * *` 就是每十分钟一次\n\n#### 构建环境\niOS打包需要签名文件和证书，所以这部分我们勾选“Keychains and Code Signing Identities”和“Mobile Provisioning Profiles”。\n\n在这之前\n\n在系统设置中进入Keychains and Provisioning Profiles Management页面，点击“浏览”按钮，分别上传自己的keychain和证书（是这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下）。上传成功后，我们再为keychain指明签名文件的名称。点击“Add Code Signing Identity”，最后添加成功后如下图所示\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1003.png)\n\npassword 填写你的用户密码\n\nCode Signing Identity 的内容来源是这里\n\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_1.png?version=1&modificationDate=1375867279000)\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_2.png?version=2&modificationDate=1375868440000)\n\nProvision Profiles Directory Path 的内容填上\n\n`/Users/Shared/Jenkins/Library/MobileDevice`\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/Screen+Shot+2013-08-07+at+14.17.05.png?version=1&modificationDate=1375877888000)\n\n回到项目配置\n\n这样子填写\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1004.png)\n\n#### 构建\n点击”增加构建步骤”,先后选择 XCode 和 Execute Shell\n\nXCode 配置如下\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1005.png)\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1006.png)\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1007.png)\n\nExecute Shell 只要写入这个命令就好\n\n`fir publish /Users/Arclin/.jenkins/workspace/TestJenkins/build/TestJenkins.ipa --token=你的fir.im Token`\n\n如果没安装 fir 命令行工具的话\n\n用`gem install fir-cli` 安装\n如果发现问题就看这里\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1008.png)\n\n然后保存回到Jenkins项目首页，点击立即构建，然后如果成功的话就会像下图那样子\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1009.png)\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1010.png)\n\n每隔一个触发器设定的时间，他就会检查一下 git 上面的代码，如果有发现更新就会自动 pull然后打包并上传到 fir.im\n\n结束","slug":"Jenkins-Git-CocoaPods-Fir-im实现iOS应用持续集成","published":1,"updated":"2018-05-10T06:51:35.724Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbch9000aldxuc1ju8dlz","content":"<p>Jenkins 可以定时检测 Git 上的某个分支的代码，打包生成 ipa 后直接上传到 Fir.im</p>\n<a id=\"more\"></a>\n<h3 id=\"安装-Jenkins\"><a href=\"#安装-Jenkins\" class=\"headerlink\" title=\"安装 Jenkins\"></a>安装 Jenkins</h3><h4 id=\"JDK\"><a href=\"#JDK\" class=\"headerlink\" title=\"JDK\"></a>JDK</h4><p>Jenkins 是基于 Java 的一个应用，所以你需要先有JDK ，安装 JDK 网上有很多资料这里就跳过了</p>\n<p>使用 Brew 安装 Jenkins</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install jenkins</span><br></pre></td></tr></table></figure>\n<h3 id=\"启动-Jenkins\"><a href=\"#启动-Jenkins\" class=\"headerlink\" title=\"启动 Jenkins\"></a>启动 Jenkins</h3><p><code>jenkins</code> 或者 <code>java -jar /usr/local/opt/jenkins/libexec/jenkins.war --httpPort=8088</code> 这种方法可以指定端口号执行</p>\n<p>如果想自动启动，需要先执行以下命令，创建启动项<br><code>ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents</code></p>\n<p>可以编辑一下<code>~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</code>这个文件<br><code>open ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</code></p>\n<p>想要让局域网都可以访问，需要把<code>–httpListenAddress=127.0.0.1</code>改成自己的局域网IP</p>\n<p>手动启动启动项可以执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置Xcode项目\"><a href=\"#配置Xcode项目\" class=\"headerlink\" title=\"配置Xcode项目\"></a>配置Xcode项目</h3><p>使用 CocoaPods<br>终端进入已有项目的目录下，执行</p>\n<p>填写 podfile 类似下面这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target &apos;TestJenkins&apos; do</span><br><span class=\"line\">\tpod &apos;MJExtension&apos;</span><br><span class=\"line\">  target &apos;TestJenkinsTests&apos; do</span><br><span class=\"line\">    inherit! :search_paths</span><br><span class=\"line\">  end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>然后执行 <code>pod install</code></p>\n<p>执行完成之后打开<code>TestJenkins.xcworkspace</code></p>\n<p>打开 <code>Product - Scheme - Manage Scheme</code></p>\n<p>把 <code>Share</code> 下面的勾都打上</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/888.png\" alt=\"\"></p>\n<h3 id=\"上传到Git\"><a href=\"#上传到Git\" class=\"headerlink\" title=\"上传到Git\"></a>上传到Git</h3><p>在终端进入该项目根目录，执行<code>git init</code></p>\n<p>在 Git托管平台上新建一个项目，得到 git 远程仓库地址，然后在项目中添加该远程地址</p>\n<p><code>git remote add origin git@git.coding.net:Arclin/TestJenkins.git</code></p>\n<p>新的项目或许还需要<code>git pull origin master</code> pull一下Readme等东西</p>\n<ol>\n<li><code>git add .</code> 添加项目文件</li>\n<li><code>git git commit -m &quot;initial&quot;</code> 提交更改</li>\n<li><code>git push origin master</code> 推送到 master远程分支</li>\n</ol>\n<h3 id=\"配置-Jenkins\"><a href=\"#配置-Jenkins\" class=\"headerlink\" title=\"配置 Jenkins\"></a>配置 Jenkins</h3><p>在浏览器中打开 Jenkins,比如我指定了8088端口的话，那就打开<code>http://localhost:8088/</code>,然后根据提示安装，注意里面有一个选择插件的界面，根据需要选择就好。</p>\n<h4 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h4><p>系统管理 - 插件管理 可以安装插件,建议安装</p>\n<ul>\n<li>Git Server Plugin  </li>\n<li>Git Client Plugin  </li>\n<li>fir-plugin  （安装教程看 <a href=\"http://www.jianshu.com/p/9a245918a219）\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/9a245918a219）</a></li>\n<li>Xcode integration</li>\n<li>Keychains and Provisioning Profiles Management</li>\n</ul>\n<p>下面我们就会用上这些插件</p>\n<h4 id=\"新建一个Job\"><a href=\"#新建一个Job\" class=\"headerlink\" title=\"新建一个Job\"></a>新建一个Job</h4><p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/999.png\" alt=\"\"></p>\n<p>进行一系列配置<br>设置包的保留天数还有天数。</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1001.png\" alt=\"\"></p>\n<p>源码管理</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1002.png\" alt=\"\"></p>\n<p>要先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1194012-6d1b6f56e4dac318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>构建触发器<br>构建触发器设置这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。</p>\n<p>不过这里有两个配置还是需要是配置的</p>\n<p>Poll SCM (poll source code management) 轮询源码管理<br>需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次<br>Build periodically (定时build)<br>一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。</p>\n<p>格式是这样的</p>\n<p>分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日)</p>\n<p>例如 <code>H/10 * * * *</code> 就是每十分钟一次</p>\n<h4 id=\"构建环境\"><a href=\"#构建环境\" class=\"headerlink\" title=\"构建环境\"></a>构建环境</h4><p>iOS打包需要签名文件和证书，所以这部分我们勾选“Keychains and Code Signing Identities”和“Mobile Provisioning Profiles”。</p>\n<p>在这之前</p>\n<p>在系统设置中进入Keychains and Provisioning Profiles Management页面，点击“浏览”按钮，分别上传自己的keychain和证书（是这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下）。上传成功后，我们再为keychain指明签名文件的名称。点击“Add Code Signing Identity”，最后添加成功后如下图所示</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1003.png\" alt=\"\"></p>\n<p>password 填写你的用户密码</p>\n<p>Code Signing Identity 的内容来源是这里</p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_1.png?version=1&amp;modificationDate=1375867279000\" alt=\"\"></p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_2.png?version=2&amp;modificationDate=1375868440000\" alt=\"\"></p>\n<p>Provision Profiles Directory Path 的内容填上</p>\n<p><code>/Users/Shared/Jenkins/Library/MobileDevice</code></p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/Screen+Shot+2013-08-07+at+14.17.05.png?version=1&amp;modificationDate=1375877888000\" alt=\"\"></p>\n<p>回到项目配置</p>\n<p>这样子填写</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1004.png\" alt=\"\"></p>\n<h4 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h4><p>点击”增加构建步骤”,先后选择 XCode 和 Execute Shell</p>\n<p>XCode 配置如下</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1005.png\" alt=\"\"><br><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1006.png\" alt=\"\"><br><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1007.png\" alt=\"\"></p>\n<p>Execute Shell 只要写入这个命令就好</p>\n<p><code>fir publish /Users/Arclin/.jenkins/workspace/TestJenkins/build/TestJenkins.ipa --token=你的fir.im Token</code></p>\n<p>如果没安装 fir 命令行工具的话</p>\n<p>用<code>gem install fir-cli</code> 安装<br>如果发现问题就看这里</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1008.png\" alt=\"\"></p>\n<p>然后保存回到Jenkins项目首页，点击立即构建，然后如果成功的话就会像下图那样子</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1009.png\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1010.png\" alt=\"\"></p>\n<p>每隔一个触发器设定的时间，他就会检查一下 git 上面的代码，如果有发现更新就会自动 pull然后打包并上传到 fir.im</p>\n<p>结束</p>\n","site":{"data":{}},"excerpt":"<p>Jenkins 可以定时检测 Git 上的某个分支的代码，打包生成 ipa 后直接上传到 Fir.im</p>","more":"<h3 id=\"安装-Jenkins\"><a href=\"#安装-Jenkins\" class=\"headerlink\" title=\"安装 Jenkins\"></a>安装 Jenkins</h3><h4 id=\"JDK\"><a href=\"#JDK\" class=\"headerlink\" title=\"JDK\"></a>JDK</h4><p>Jenkins 是基于 Java 的一个应用，所以你需要先有JDK ，安装 JDK 网上有很多资料这里就跳过了</p>\n<p>使用 Brew 安装 Jenkins</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install jenkins</span><br></pre></td></tr></table></figure>\n<h3 id=\"启动-Jenkins\"><a href=\"#启动-Jenkins\" class=\"headerlink\" title=\"启动 Jenkins\"></a>启动 Jenkins</h3><p><code>jenkins</code> 或者 <code>java -jar /usr/local/opt/jenkins/libexec/jenkins.war --httpPort=8088</code> 这种方法可以指定端口号执行</p>\n<p>如果想自动启动，需要先执行以下命令，创建启动项<br><code>ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents</code></p>\n<p>可以编辑一下<code>~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</code>这个文件<br><code>open ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</code></p>\n<p>想要让局域网都可以访问，需要把<code>–httpListenAddress=127.0.0.1</code>改成自己的局域网IP</p>\n<p>手动启动启动项可以执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置Xcode项目\"><a href=\"#配置Xcode项目\" class=\"headerlink\" title=\"配置Xcode项目\"></a>配置Xcode项目</h3><p>使用 CocoaPods<br>终端进入已有项目的目录下，执行</p>\n<p>填写 podfile 类似下面这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target &apos;TestJenkins&apos; do</span><br><span class=\"line\">\tpod &apos;MJExtension&apos;</span><br><span class=\"line\">  target &apos;TestJenkinsTests&apos; do</span><br><span class=\"line\">    inherit! :search_paths</span><br><span class=\"line\">  end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>然后执行 <code>pod install</code></p>\n<p>执行完成之后打开<code>TestJenkins.xcworkspace</code></p>\n<p>打开 <code>Product - Scheme - Manage Scheme</code></p>\n<p>把 <code>Share</code> 下面的勾都打上</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/888.png\" alt=\"\"></p>\n<h3 id=\"上传到Git\"><a href=\"#上传到Git\" class=\"headerlink\" title=\"上传到Git\"></a>上传到Git</h3><p>在终端进入该项目根目录，执行<code>git init</code></p>\n<p>在 Git托管平台上新建一个项目，得到 git 远程仓库地址，然后在项目中添加该远程地址</p>\n<p><code>git remote add origin git@git.coding.net:Arclin/TestJenkins.git</code></p>\n<p>新的项目或许还需要<code>git pull origin master</code> pull一下Readme等东西</p>\n<ol>\n<li><code>git add .</code> 添加项目文件</li>\n<li><code>git git commit -m &quot;initial&quot;</code> 提交更改</li>\n<li><code>git push origin master</code> 推送到 master远程分支</li>\n</ol>\n<h3 id=\"配置-Jenkins\"><a href=\"#配置-Jenkins\" class=\"headerlink\" title=\"配置 Jenkins\"></a>配置 Jenkins</h3><p>在浏览器中打开 Jenkins,比如我指定了8088端口的话，那就打开<code>http://localhost:8088/</code>,然后根据提示安装，注意里面有一个选择插件的界面，根据需要选择就好。</p>\n<h4 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h4><p>系统管理 - 插件管理 可以安装插件,建议安装</p>\n<ul>\n<li>Git Server Plugin  </li>\n<li>Git Client Plugin  </li>\n<li>fir-plugin  （安装教程看 <a href=\"http://www.jianshu.com/p/9a245918a219）\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/9a245918a219）</a></li>\n<li>Xcode integration</li>\n<li>Keychains and Provisioning Profiles Management</li>\n</ul>\n<p>下面我们就会用上这些插件</p>\n<h4 id=\"新建一个Job\"><a href=\"#新建一个Job\" class=\"headerlink\" title=\"新建一个Job\"></a>新建一个Job</h4><p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/999.png\" alt=\"\"></p>\n<p>进行一系列配置<br>设置包的保留天数还有天数。</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1001.png\" alt=\"\"></p>\n<p>源码管理</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1002.png\" alt=\"\"></p>\n<p>要先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1194012-6d1b6f56e4dac318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>构建触发器<br>构建触发器设置这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。</p>\n<p>不过这里有两个配置还是需要是配置的</p>\n<p>Poll SCM (poll source code management) 轮询源码管理<br>需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次<br>Build periodically (定时build)<br>一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。</p>\n<p>格式是这样的</p>\n<p>分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日)</p>\n<p>例如 <code>H/10 * * * *</code> 就是每十分钟一次</p>\n<h4 id=\"构建环境\"><a href=\"#构建环境\" class=\"headerlink\" title=\"构建环境\"></a>构建环境</h4><p>iOS打包需要签名文件和证书，所以这部分我们勾选“Keychains and Code Signing Identities”和“Mobile Provisioning Profiles”。</p>\n<p>在这之前</p>\n<p>在系统设置中进入Keychains and Provisioning Profiles Management页面，点击“浏览”按钮，分别上传自己的keychain和证书（是这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下）。上传成功后，我们再为keychain指明签名文件的名称。点击“Add Code Signing Identity”，最后添加成功后如下图所示</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1003.png\" alt=\"\"></p>\n<p>password 填写你的用户密码</p>\n<p>Code Signing Identity 的内容来源是这里</p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_1.png?version=1&amp;modificationDate=1375867279000\" alt=\"\"></p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_2.png?version=2&amp;modificationDate=1375868440000\" alt=\"\"></p>\n<p>Provision Profiles Directory Path 的内容填上</p>\n<p><code>/Users/Shared/Jenkins/Library/MobileDevice</code></p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/Screen+Shot+2013-08-07+at+14.17.05.png?version=1&amp;modificationDate=1375877888000\" alt=\"\"></p>\n<p>回到项目配置</p>\n<p>这样子填写</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1004.png\" alt=\"\"></p>\n<h4 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h4><p>点击”增加构建步骤”,先后选择 XCode 和 Execute Shell</p>\n<p>XCode 配置如下</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1005.png\" alt=\"\"><br><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1006.png\" alt=\"\"><br><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1007.png\" alt=\"\"></p>\n<p>Execute Shell 只要写入这个命令就好</p>\n<p><code>fir publish /Users/Arclin/.jenkins/workspace/TestJenkins/build/TestJenkins.ipa --token=你的fir.im Token</code></p>\n<p>如果没安装 fir 命令行工具的话</p>\n<p>用<code>gem install fir-cli</code> 安装<br>如果发现问题就看这里</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1008.png\" alt=\"\"></p>\n<p>然后保存回到Jenkins项目首页，点击立即构建，然后如果成功的话就会像下图那样子</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1009.png\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1010.png\" alt=\"\"></p>\n<p>每隔一个触发器设定的时间，他就会检查一下 git 上面的代码，如果有发现更新就会自动 pull然后打包并上传到 fir.im</p>\n<p>结束</p>"},{"title":"DKLogger--iOS日志管理框架","author":"Arclin","abbrlink":"abce56f1","date":"2017-02-22T16:00:00.000Z","_content":"用于管理iOS的Log信息的框架\n\n<!-- more -->\n可以用在平时的调试中,另外如果app在用户使用过程中发生一些意外事件或者程序崩溃事件,那我们也可以通过服务器的文件得知问题所在\n\n特性\n- 支持四个Log等级 `DEBUG`,`INFO`,`WARN`,`ERROR`\n- 支持储存Log文件到本地和上传到服务器\n- 支持自定义打印Log类型和写入Log类型\n- 支持捕获&发送崩溃信息\n- 在界面长按2秒可以查看Log信息\n- 可以获取用户的在App内的查看轨迹(进入了哪些控制器)\n- 崩溃的时候重启RunLoop,进入ANR状态,不闪退\n- 支持服务器端同步显示Log信息(建议搭建本地服务器,因为这样子Log发送快)\n\n使用\n\n```\nDKLog(@\"...\"); 普通log\nDKInfoLog(@\"...\"); 包含特殊信息的log\nDKWRANLog(@\"...\"); 警告log\nDKERRLog(@\"...\"); 错误log\n```\n```\n/**\t\n 初始化: 创建Txt的Log文件并写入输出\n \n @param path  文件夹路径,默认Documents\n @param url   上传log地址 当发生崩溃事故的时候就会提示用户是否上传Log到服务器\n @param debug 调试模式 */\n- (void)registerLoggerInPath:(NSString *)path uploadUrlStr:(NSString *)url debug:(BOOL)debug;\neg:\n[[DKSharedLogger registerLoggerInPath:[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] uploadUrlStr:@\"http://192.168.1.91/public/index/Index/hello\" debug:YES];\n```\n\n```\n[DKSharedLogger printLevel:DKLoggerLevelInfo|DKLoggerLevelWARN]; 在控制器只打印Info和Warn等级的Log\n```\n```\n[DKSharedLogger saveLevel:DKLoggerLevelError|DKLoggerLevelInfo]; 在文件中之写入Info和Error等级的Log\n```\n\n```\nDK_VAR_DUMP(arr); 查看对象信息,例如变量arr\n```\n\n长按界面2秒弹出log信息界面\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/1011.png?raw=true)","source":"_posts/DKLogger-iOS日志管理框架.md","raw":"---\ntitle: DKLogger--iOS日志管理框架\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: abce56f1\ndate: 2017-02-23 00:00:00\n---\n用于管理iOS的Log信息的框架\n\n<!-- more -->\n可以用在平时的调试中,另外如果app在用户使用过程中发生一些意外事件或者程序崩溃事件,那我们也可以通过服务器的文件得知问题所在\n\n特性\n- 支持四个Log等级 `DEBUG`,`INFO`,`WARN`,`ERROR`\n- 支持储存Log文件到本地和上传到服务器\n- 支持自定义打印Log类型和写入Log类型\n- 支持捕获&发送崩溃信息\n- 在界面长按2秒可以查看Log信息\n- 可以获取用户的在App内的查看轨迹(进入了哪些控制器)\n- 崩溃的时候重启RunLoop,进入ANR状态,不闪退\n- 支持服务器端同步显示Log信息(建议搭建本地服务器,因为这样子Log发送快)\n\n使用\n\n```\nDKLog(@\"...\"); 普通log\nDKInfoLog(@\"...\"); 包含特殊信息的log\nDKWRANLog(@\"...\"); 警告log\nDKERRLog(@\"...\"); 错误log\n```\n```\n/**\t\n 初始化: 创建Txt的Log文件并写入输出\n \n @param path  文件夹路径,默认Documents\n @param url   上传log地址 当发生崩溃事故的时候就会提示用户是否上传Log到服务器\n @param debug 调试模式 */\n- (void)registerLoggerInPath:(NSString *)path uploadUrlStr:(NSString *)url debug:(BOOL)debug;\neg:\n[[DKSharedLogger registerLoggerInPath:[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] uploadUrlStr:@\"http://192.168.1.91/public/index/Index/hello\" debug:YES];\n```\n\n```\n[DKSharedLogger printLevel:DKLoggerLevelInfo|DKLoggerLevelWARN]; 在控制器只打印Info和Warn等级的Log\n```\n```\n[DKSharedLogger saveLevel:DKLoggerLevelError|DKLoggerLevelInfo]; 在文件中之写入Info和Error等级的Log\n```\n\n```\nDK_VAR_DUMP(arr); 查看对象信息,例如变量arr\n```\n\n长按界面2秒弹出log信息界面\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/1011.png?raw=true)","slug":"DKLogger-iOS日志管理框架","published":1,"updated":"2018-05-10T06:51:35.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbchd000bldxus0tubkcd","content":"<p>用于管理iOS的Log信息的框架</p>\n<a id=\"more\"></a>\n<p>可以用在平时的调试中,另外如果app在用户使用过程中发生一些意外事件或者程序崩溃事件,那我们也可以通过服务器的文件得知问题所在</p>\n<p>特性</p>\n<ul>\n<li>支持四个Log等级 <code>DEBUG</code>,<code>INFO</code>,<code>WARN</code>,<code>ERROR</code></li>\n<li>支持储存Log文件到本地和上传到服务器</li>\n<li>支持自定义打印Log类型和写入Log类型</li>\n<li>支持捕获&amp;发送崩溃信息</li>\n<li>在界面长按2秒可以查看Log信息</li>\n<li>可以获取用户的在App内的查看轨迹(进入了哪些控制器)</li>\n<li>崩溃的时候重启RunLoop,进入ANR状态,不闪退</li>\n<li>支持服务器端同步显示Log信息(建议搭建本地服务器,因为这样子Log发送快)</li>\n</ul>\n<p>使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKLog(@&quot;...&quot;); 普通log</span><br><span class=\"line\">DKInfoLog(@&quot;...&quot;); 包含特殊信息的log</span><br><span class=\"line\">DKWRANLog(@&quot;...&quot;); 警告log</span><br><span class=\"line\">DKERRLog(@&quot;...&quot;); 错误log</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**\t</span><br><span class=\"line\"> 初始化: 创建Txt的Log文件并写入输出</span><br><span class=\"line\"> </span><br><span class=\"line\"> @param path  文件夹路径,默认Documents</span><br><span class=\"line\"> @param url   上传log地址 当发生崩溃事故的时候就会提示用户是否上传Log到服务器</span><br><span class=\"line\"> @param debug 调试模式 */</span><br><span class=\"line\">- (void)registerLoggerInPath:(NSString *)path uploadUrlStr:(NSString *)url debug:(BOOL)debug;</span><br><span class=\"line\">eg:</span><br><span class=\"line\">[[DKSharedLogger registerLoggerInPath:[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] uploadUrlStr:@&quot;http://192.168.1.91/public/index/Index/hello&quot; debug:YES];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKSharedLogger printLevel:DKLoggerLevelInfo|DKLoggerLevelWARN]; 在控制器只打印Info和Warn等级的Log</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKSharedLogger saveLevel:DKLoggerLevelError|DKLoggerLevelInfo]; 在文件中之写入Info和Error等级的Log</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DK_VAR_DUMP(arr); 查看对象信息,例如变量arr</span><br></pre></td></tr></table></figure>\n<p>长按界面2秒弹出log信息界面</p>\n<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/1011.png?raw=true\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>用于管理iOS的Log信息的框架</p>","more":"<p>可以用在平时的调试中,另外如果app在用户使用过程中发生一些意外事件或者程序崩溃事件,那我们也可以通过服务器的文件得知问题所在</p>\n<p>特性</p>\n<ul>\n<li>支持四个Log等级 <code>DEBUG</code>,<code>INFO</code>,<code>WARN</code>,<code>ERROR</code></li>\n<li>支持储存Log文件到本地和上传到服务器</li>\n<li>支持自定义打印Log类型和写入Log类型</li>\n<li>支持捕获&amp;发送崩溃信息</li>\n<li>在界面长按2秒可以查看Log信息</li>\n<li>可以获取用户的在App内的查看轨迹(进入了哪些控制器)</li>\n<li>崩溃的时候重启RunLoop,进入ANR状态,不闪退</li>\n<li>支持服务器端同步显示Log信息(建议搭建本地服务器,因为这样子Log发送快)</li>\n</ul>\n<p>使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKLog(@&quot;...&quot;); 普通log</span><br><span class=\"line\">DKInfoLog(@&quot;...&quot;); 包含特殊信息的log</span><br><span class=\"line\">DKWRANLog(@&quot;...&quot;); 警告log</span><br><span class=\"line\">DKERRLog(@&quot;...&quot;); 错误log</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**\t</span><br><span class=\"line\"> 初始化: 创建Txt的Log文件并写入输出</span><br><span class=\"line\"> </span><br><span class=\"line\"> @param path  文件夹路径,默认Documents</span><br><span class=\"line\"> @param url   上传log地址 当发生崩溃事故的时候就会提示用户是否上传Log到服务器</span><br><span class=\"line\"> @param debug 调试模式 */</span><br><span class=\"line\">- (void)registerLoggerInPath:(NSString *)path uploadUrlStr:(NSString *)url debug:(BOOL)debug;</span><br><span class=\"line\">eg:</span><br><span class=\"line\">[[DKSharedLogger registerLoggerInPath:[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] uploadUrlStr:@&quot;http://192.168.1.91/public/index/Index/hello&quot; debug:YES];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKSharedLogger printLevel:DKLoggerLevelInfo|DKLoggerLevelWARN]; 在控制器只打印Info和Warn等级的Log</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKSharedLogger saveLevel:DKLoggerLevelError|DKLoggerLevelInfo]; 在文件中之写入Info和Error等级的Log</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DK_VAR_DUMP(arr); 查看对象信息,例如变量arr</span><br></pre></td></tr></table></figure>\n<p>长按界面2秒弹出log信息界面</p>\n<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/1011.png?raw=true\" alt=\"\"></p>"},{"title":"MongoDB笔记","author":"Arclin","abbrlink":"b3b38c86","date":"2018-02-18T13:58:00.000Z","_content":"MongoDB笔记\n\n<!-- more -->\n\nOS X安装\n\n`brew install mongodb`\n\n进入mongodb\n\n`mongo`\n\n查看所有数据库\n\n`db`\n\n查看所有*有数据的*数据库并带上内存信息\n\n`show dbs`\n\n创建/进入某个数据库\n\n`use DATABASE_NAME`\n\n删除数据库(需要先`use DATABASE_NAME` 进入数据库)\n\n`db.dropDatabase()`\n\n插入数据\n\n`db.DATABASE_NAME.insert({“COLUMN_NAME”:”VALUE”,”COLUMN_NAME_SECOND”:”SECOND_VALUE”})`\n\n查询所有数据\n\n`db.DATABASE_NAME.find()`\n\n查询所有数据并pretty形式打印\n\n`db.DATABASE_NAME.find().pretty()`\n\n更新满足条件的第一条数据\n\n`db.DATABASE_NAME.update({‘条件字段’:’条件值’},{$set:{‘更新字段’:’更新值’,‘更新字段2’:’更新值2’}})`\n\n更新满足条件的所有数据\n\n`db.DATABASE_NAME.update({‘条件字段’:’条件值’},{$set:{‘更新字段’:’更新值’,‘更新字段2’:’更新值2’},{multi:true}})`\n\n替换整条数据的内容(根据ID查找)\n\n`db.DATABASE_NAME.save({“_id”:ObjectId(“xxxxx”),”要替换的字段名”:”要替换的字段名”,”要替换的字段名2”:”要替换的字段名2”})`\n\n删除数据\n\n`db.DATABASE_NAME.remove({‘条件字段’:’条件值’})`\n\n删除第一条找到的记录\n\n`db.DATABASE_NAME.remove({‘条件字段’:’条件值’},1)`\n\n删除所有数据(请空表)\n\n`db.DATABASE_NAME.remove({})`\n\n\n\n\n\n\n","source":"_posts/MongoDB笔记.md","raw":"---\ntitle: MongoDB笔记\nauthor: Arclin\ntags:\n  - MongoDB\ncategories:\n  - MongoDB\nabbrlink: b3b38c86\ndate: 2018-02-18 21:58:00\n---\nMongoDB笔记\n\n<!-- more -->\n\nOS X安装\n\n`brew install mongodb`\n\n进入mongodb\n\n`mongo`\n\n查看所有数据库\n\n`db`\n\n查看所有*有数据的*数据库并带上内存信息\n\n`show dbs`\n\n创建/进入某个数据库\n\n`use DATABASE_NAME`\n\n删除数据库(需要先`use DATABASE_NAME` 进入数据库)\n\n`db.dropDatabase()`\n\n插入数据\n\n`db.DATABASE_NAME.insert({“COLUMN_NAME”:”VALUE”,”COLUMN_NAME_SECOND”:”SECOND_VALUE”})`\n\n查询所有数据\n\n`db.DATABASE_NAME.find()`\n\n查询所有数据并pretty形式打印\n\n`db.DATABASE_NAME.find().pretty()`\n\n更新满足条件的第一条数据\n\n`db.DATABASE_NAME.update({‘条件字段’:’条件值’},{$set:{‘更新字段’:’更新值’,‘更新字段2’:’更新值2’}})`\n\n更新满足条件的所有数据\n\n`db.DATABASE_NAME.update({‘条件字段’:’条件值’},{$set:{‘更新字段’:’更新值’,‘更新字段2’:’更新值2’},{multi:true}})`\n\n替换整条数据的内容(根据ID查找)\n\n`db.DATABASE_NAME.save({“_id”:ObjectId(“xxxxx”),”要替换的字段名”:”要替换的字段名”,”要替换的字段名2”:”要替换的字段名2”})`\n\n删除数据\n\n`db.DATABASE_NAME.remove({‘条件字段’:’条件值’})`\n\n删除第一条找到的记录\n\n`db.DATABASE_NAME.remove({‘条件字段’:’条件值’},1)`\n\n删除所有数据(请空表)\n\n`db.DATABASE_NAME.remove({})`\n\n\n\n\n\n\n","slug":"MongoDB笔记","published":1,"updated":"2018-05-10T06:51:35.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbchh000fldxu6a84glt7","content":"<p>MongoDB笔记</p>\n<a id=\"more\"></a>\n<p>OS X安装</p>\n<p><code>brew install mongodb</code></p>\n<p>进入mongodb</p>\n<p><code>mongo</code></p>\n<p>查看所有数据库</p>\n<p><code>db</code></p>\n<p>查看所有<em>有数据的</em>数据库并带上内存信息</p>\n<p><code>show dbs</code></p>\n<p>创建/进入某个数据库</p>\n<p><code>use DATABASE_NAME</code></p>\n<p>删除数据库(需要先<code>use DATABASE_NAME</code> 进入数据库)</p>\n<p><code>db.dropDatabase()</code></p>\n<p>插入数据</p>\n<p><code>db.DATABASE_NAME.insert({“COLUMN_NAME”:”VALUE”,”COLUMN_NAME_SECOND”:”SECOND_VALUE”})</code></p>\n<p>查询所有数据</p>\n<p><code>db.DATABASE_NAME.find()</code></p>\n<p>查询所有数据并pretty形式打印</p>\n<p><code>db.DATABASE_NAME.find().pretty()</code></p>\n<p>更新满足条件的第一条数据</p>\n<p><code>db.DATABASE_NAME.update({‘条件字段’:’条件值’},{$set:{‘更新字段’:’更新值’,‘更新字段2’:’更新值2’}})</code></p>\n<p>更新满足条件的所有数据</p>\n<p><code>db.DATABASE_NAME.update({‘条件字段’:’条件值’},{$set:{‘更新字段’:’更新值’,‘更新字段2’:’更新值2’},{multi:true}})</code></p>\n<p>替换整条数据的内容(根据ID查找)</p>\n<p><code>db.DATABASE_NAME.save({“_id”:ObjectId(“xxxxx”),”要替换的字段名”:”要替换的字段名”,”要替换的字段名2”:”要替换的字段名2”})</code></p>\n<p>删除数据</p>\n<p><code>db.DATABASE_NAME.remove({‘条件字段’:’条件值’})</code></p>\n<p>删除第一条找到的记录</p>\n<p><code>db.DATABASE_NAME.remove({‘条件字段’:’条件值’},1)</code></p>\n<p>删除所有数据(请空表)</p>\n<p><code>db.DATABASE_NAME.remove({})</code></p>\n","site":{"data":{}},"excerpt":"<p>MongoDB笔记</p>","more":"<p>OS X安装</p>\n<p><code>brew install mongodb</code></p>\n<p>进入mongodb</p>\n<p><code>mongo</code></p>\n<p>查看所有数据库</p>\n<p><code>db</code></p>\n<p>查看所有<em>有数据的</em>数据库并带上内存信息</p>\n<p><code>show dbs</code></p>\n<p>创建/进入某个数据库</p>\n<p><code>use DATABASE_NAME</code></p>\n<p>删除数据库(需要先<code>use DATABASE_NAME</code> 进入数据库)</p>\n<p><code>db.dropDatabase()</code></p>\n<p>插入数据</p>\n<p><code>db.DATABASE_NAME.insert({“COLUMN_NAME”:”VALUE”,”COLUMN_NAME_SECOND”:”SECOND_VALUE”})</code></p>\n<p>查询所有数据</p>\n<p><code>db.DATABASE_NAME.find()</code></p>\n<p>查询所有数据并pretty形式打印</p>\n<p><code>db.DATABASE_NAME.find().pretty()</code></p>\n<p>更新满足条件的第一条数据</p>\n<p><code>db.DATABASE_NAME.update({‘条件字段’:’条件值’},{$set:{‘更新字段’:’更新值’,‘更新字段2’:’更新值2’}})</code></p>\n<p>更新满足条件的所有数据</p>\n<p><code>db.DATABASE_NAME.update({‘条件字段’:’条件值’},{$set:{‘更新字段’:’更新值’,‘更新字段2’:’更新值2’},{multi:true}})</code></p>\n<p>替换整条数据的内容(根据ID查找)</p>\n<p><code>db.DATABASE_NAME.save({“_id”:ObjectId(“xxxxx”),”要替换的字段名”:”要替换的字段名”,”要替换的字段名2”:”要替换的字段名2”})</code></p>\n<p>删除数据</p>\n<p><code>db.DATABASE_NAME.remove({‘条件字段’:’条件值’})</code></p>\n<p>删除第一条找到的记录</p>\n<p><code>db.DATABASE_NAME.remove({‘条件字段’:’条件值’},1)</code></p>\n<p>删除所有数据(请空表)</p>\n<p><code>db.DATABASE_NAME.remove({})</code></p>"},{"title":"ALAsset-Type:Unknown的问题","author":"Arclin","abbrlink":"a8ea2211","date":"2016-10-16T16:00:00.000Z","_content":"- 利用ALAssetsLibrary时候，将得到的`ALAsset`存到数组里，会出现`ALAsset - Type:Unknown, URLs:(null)`的问题\n\n解决方案：初始化ALAssetsLibrary的时候，不要用alloc-init，用一个单例，如下：\n\n```\n+ (ALAssetsLibrary *)defaultAssetsLibrary\n{\n    static dispatch_once_t pred = 0;\n    static ALAssetsLibrary *library = nil;\n    dispatch_once(&pred,\n                  ^{\n                      library = [[ALAssetsLibrary alloc] init];\n                  });\n    return library;\n}\n```","source":"_posts/ALAsset-Type-Unknown的问题.md","raw":"---\ntitle: 'ALAsset-Type:Unknown的问题'\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: a8ea2211\ndate: 2016-10-17 00:00:00\n---\n- 利用ALAssetsLibrary时候，将得到的`ALAsset`存到数组里，会出现`ALAsset - Type:Unknown, URLs:(null)`的问题\n\n解决方案：初始化ALAssetsLibrary的时候，不要用alloc-init，用一个单例，如下：\n\n```\n+ (ALAssetsLibrary *)defaultAssetsLibrary\n{\n    static dispatch_once_t pred = 0;\n    static ALAssetsLibrary *library = nil;\n    dispatch_once(&pred,\n                  ^{\n                      library = [[ALAssetsLibrary alloc] init];\n                  });\n    return library;\n}\n```","slug":"ALAsset-Type-Unknown的问题","published":1,"updated":"2018-05-10T06:51:35.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbchl000ildxuza7euvv7","content":"<ul>\n<li>利用ALAssetsLibrary时候，将得到的<code>ALAsset</code>存到数组里，会出现<code>ALAsset - Type:Unknown, URLs:(null)</code>的问题</li>\n</ul>\n<p>解决方案：初始化ALAssetsLibrary的时候，不要用alloc-init，用一个单例，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (ALAssetsLibrary *)defaultAssetsLibrary</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static dispatch_once_t pred = 0;</span><br><span class=\"line\">    static ALAssetsLibrary *library = nil;</span><br><span class=\"line\">    dispatch_once(&amp;pred,</span><br><span class=\"line\">                  ^&#123;</span><br><span class=\"line\">                      library = [[ALAssetsLibrary alloc] init];</span><br><span class=\"line\">                  &#125;);</span><br><span class=\"line\">    return library;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>利用ALAssetsLibrary时候，将得到的<code>ALAsset</code>存到数组里，会出现<code>ALAsset - Type:Unknown, URLs:(null)</code>的问题</li>\n</ul>\n<p>解决方案：初始化ALAssetsLibrary的时候，不要用alloc-init，用一个单例，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (ALAssetsLibrary *)defaultAssetsLibrary</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static dispatch_once_t pred = 0;</span><br><span class=\"line\">    static ALAssetsLibrary *library = nil;</span><br><span class=\"line\">    dispatch_once(&amp;pred,</span><br><span class=\"line\">                  ^&#123;</span><br><span class=\"line\">                      library = [[ALAssetsLibrary alloc] init];</span><br><span class=\"line\">                  &#125;);</span><br><span class=\"line\">    return library;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Let’s Encrypt 免费https","author":"Arclin","abbrlink":"feddc8a5","date":"2018-02-18T13:34:00.000Z","_content":"在服务器配置免费的CA证书\n\n<!-- more -->\n\n下载源码\n\n```\ngit clone https://github.com/letsencrypt/letsencrypt\n```\n\n生成证书\n\n```\ncd letsencrypt/\n\n./letsencrypt-auto certonly --standalone --email arclin@dankal.cn -d arclin.me -d g.arclin.me \n```\n\n默认有效期90天\n\n自动续期\n\n```\n./letsencrypt-auto certonly --renew-by-default --email arclin@dankal.cn -d arclin.me -d g.arclin.me\n```\n\n报错及解决\n\n- 报错\nProblem binding to port 443: Could not bind to IPv4 or IPv6.\n\n- 解决\n停止443端口\n比如 关闭ShadowSocks服务(ssserver)  关闭nginx\n\n- 报错 \nFailed authorization procedure. arclin.me (tls-sni-01): urn:acme:error:connection :: The server could not connect to the client to verify the domain :: Connection refused\n\n- 解决\n在DNSPod 绑定 arclin.me域名到本服务器\n\n修改Nginx 配置\n\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    listen 443 ssl http2; #443这里是https的端口  开启http2服务需要安装http_v2_module模块\n    ssl_certificate /etc/letsencrypt/live/arclin.me/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/arclin.me/privkey.pem;\n    resolver 8.8.8.8;\n    location / {\n        google on;\n    }\n  }\n```\n\n重启服务\n\n```\nnginx -c /usr/local/nginx/conf/nginx.conf\nnginx -s reload\nservice nginx restart\n```","source":"_posts/Let’s-Encrypt-免费https.md","raw":"---\ntitle: Let’s Encrypt 免费https\nauthor: Arclin\ntags:\n  - Let's Encrypt\n  - https\ncategories:\n  - Linux\nabbrlink: feddc8a5\ndate: 2018-02-18 21:34:00\n---\n在服务器配置免费的CA证书\n\n<!-- more -->\n\n下载源码\n\n```\ngit clone https://github.com/letsencrypt/letsencrypt\n```\n\n生成证书\n\n```\ncd letsencrypt/\n\n./letsencrypt-auto certonly --standalone --email arclin@dankal.cn -d arclin.me -d g.arclin.me \n```\n\n默认有效期90天\n\n自动续期\n\n```\n./letsencrypt-auto certonly --renew-by-default --email arclin@dankal.cn -d arclin.me -d g.arclin.me\n```\n\n报错及解决\n\n- 报错\nProblem binding to port 443: Could not bind to IPv4 or IPv6.\n\n- 解决\n停止443端口\n比如 关闭ShadowSocks服务(ssserver)  关闭nginx\n\n- 报错 \nFailed authorization procedure. arclin.me (tls-sni-01): urn:acme:error:connection :: The server could not connect to the client to verify the domain :: Connection refused\n\n- 解决\n在DNSPod 绑定 arclin.me域名到本服务器\n\n修改Nginx 配置\n\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    listen 443 ssl http2; #443这里是https的端口  开启http2服务需要安装http_v2_module模块\n    ssl_certificate /etc/letsencrypt/live/arclin.me/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/arclin.me/privkey.pem;\n    resolver 8.8.8.8;\n    location / {\n        google on;\n    }\n  }\n```\n\n重启服务\n\n```\nnginx -c /usr/local/nginx/conf/nginx.conf\nnginx -s reload\nservice nginx restart\n```","slug":"Let’s-Encrypt-免费https","published":1,"updated":"2018-05-10T06:51:35.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbchp000nldxu82fwgmu5","content":"<p>在服务器配置免费的CA证书</p>\n<a id=\"more\"></a>\n<p>下载源码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/letsencrypt/letsencrypt</span><br></pre></td></tr></table></figure>\n<p>生成证书</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd letsencrypt/</span><br><span class=\"line\"></span><br><span class=\"line\">./letsencrypt-auto certonly --standalone --email arclin@dankal.cn -d arclin.me -d g.arclin.me</span><br></pre></td></tr></table></figure>\n<p>默认有效期90天</p>\n<p>自动续期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./letsencrypt-auto certonly --renew-by-default --email arclin@dankal.cn -d arclin.me -d g.arclin.me</span><br></pre></td></tr></table></figure>\n<p>报错及解决</p>\n<ul>\n<li><p>报错<br>Problem binding to port 443: Could not bind to IPv4 or IPv6.</p>\n</li>\n<li><p>解决<br>停止443端口<br>比如 关闭ShadowSocks服务(ssserver)  关闭nginx</p>\n</li>\n<li><p>报错<br>Failed authorization procedure. arclin.me (tls-sni-01): urn:acme:error:connection :: The server could not connect to the client to verify the domain :: Connection refused</p>\n</li>\n<li><p>解决<br>在DNSPod 绑定 arclin.me域名到本服务器</p>\n</li>\n</ul>\n<p>修改Nginx 配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    listen 443 ssl http2; #443这里是https的端口  开启http2服务需要安装http_v2_module模块</span><br><span class=\"line\">    ssl_certificate /etc/letsencrypt/live/arclin.me/fullchain.pem;</span><br><span class=\"line\">    ssl_certificate_key /etc/letsencrypt/live/arclin.me/privkey.pem;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>重启服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class=\"line\">nginx -s reload</span><br><span class=\"line\">service nginx restart</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>在服务器配置免费的CA证书</p>","more":"<p>下载源码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/letsencrypt/letsencrypt</span><br></pre></td></tr></table></figure>\n<p>生成证书</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd letsencrypt/</span><br><span class=\"line\"></span><br><span class=\"line\">./letsencrypt-auto certonly --standalone --email arclin@dankal.cn -d arclin.me -d g.arclin.me</span><br></pre></td></tr></table></figure>\n<p>默认有效期90天</p>\n<p>自动续期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./letsencrypt-auto certonly --renew-by-default --email arclin@dankal.cn -d arclin.me -d g.arclin.me</span><br></pre></td></tr></table></figure>\n<p>报错及解决</p>\n<ul>\n<li><p>报错<br>Problem binding to port 443: Could not bind to IPv4 or IPv6.</p>\n</li>\n<li><p>解决<br>停止443端口<br>比如 关闭ShadowSocks服务(ssserver)  关闭nginx</p>\n</li>\n<li><p>报错<br>Failed authorization procedure. arclin.me (tls-sni-01): urn:acme:error:connection :: The server could not connect to the client to verify the domain :: Connection refused</p>\n</li>\n<li><p>解决<br>在DNSPod 绑定 arclin.me域名到本服务器</p>\n</li>\n</ul>\n<p>修改Nginx 配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    listen 443 ssl http2; #443这里是https的端口  开启http2服务需要安装http_v2_module模块</span><br><span class=\"line\">    ssl_certificate /etc/letsencrypt/live/arclin.me/fullchain.pem;</span><br><span class=\"line\">    ssl_certificate_key /etc/letsencrypt/live/arclin.me/privkey.pem;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>重启服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class=\"line\">nginx -s reload</span><br><span class=\"line\">service nginx restart</span><br></pre></td></tr></table></figure>"},{"title":"NavigationController的RootViewController和子ViewController的状态栏颜色不一样或者状态栏显示异常","author":"Arclin","abbrlink":"cacc49a3","date":"2016-10-16T16:00:00.000Z","_content":"如果NavigationController的状态栏颜色跟子ViewController的状态栏颜色不一样，那么就像下面这么写\n\n在UINavigationController的子类写这个\n\n```\n- (UIViewController *)childViewControllerForStatusBarStyle{\n    return self.topViewController;\n}\n```","source":"_posts/NavigationController的RootViewController和子ViewController的状态栏颜色不一样或者状态栏显示异常.md","raw":"---\ntitle: NavigationController的RootViewController和子ViewController的状态栏颜色不一样或者状态栏显示异常\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: cacc49a3\ndate: 2016-10-17 00:00:00\n---\n如果NavigationController的状态栏颜色跟子ViewController的状态栏颜色不一样，那么就像下面这么写\n\n在UINavigationController的子类写这个\n\n```\n- (UIViewController *)childViewControllerForStatusBarStyle{\n    return self.topViewController;\n}\n```","slug":"NavigationController的RootViewController和子ViewController的状态栏颜色不一样或者状态栏显示异常","published":1,"updated":"2018-05-10T06:51:35.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcht000qldxuv5z7tak6","content":"<p>如果NavigationController的状态栏颜色跟子ViewController的状态栏颜色不一样，那么就像下面这么写</p>\n<p>在UINavigationController的子类写这个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIViewController *)childViewControllerForStatusBarStyle&#123;</span><br><span class=\"line\">    return self.topViewController;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>如果NavigationController的状态栏颜色跟子ViewController的状态栏颜色不一样，那么就像下面这么写</p>\n<p>在UINavigationController的子类写这个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIViewController *)childViewControllerForStatusBarStyle&#123;</span><br><span class=\"line\">    return self.topViewController;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"RACCommand使用注意","author":"Arclin","abbrlink":"79533f9e","date":"2016-10-16T16:00:00.000Z","_content":"RACCommand使用注意\n\n<!-- more -->\n\n 1. `signalBlock`必须要返回一个信号，不能传nil. \n 2. 如果不想要传递信号，直接创建空的信号`[RACSignal empty]`;\n 3. RACCommand中信号如果数据传递完，必须调用`[subscriber sendCompleted]`，这时命令才会执行完毕，否则永远处于执行中。\n 4. `RACCommand`需要被强引用，否则接收不到`RACCommand`中的信号，因此RACCommand中的信号是延迟发送的。\n\n- `RACCommand`设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。\n\n \t1. 在RAC开发中，通常会把网络请求封装到`RACCommand`，直接执行某个RACCommand就能发送请求。\n \t2. 当`RACCommand`内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。\n\n- 如何拿到RACCommand中返回信号发出的数据。\n\n \t1. RACCommand有个执行信号源`executionSignals`，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。\n \t2. 订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。\n\n- 监听当前命令是否正在执行`executing`\n- 使用场景,监听按钮点击，网络请求","source":"_posts/RACCommand使用注意.md","raw":"---\ntitle: RACCommand使用注意\nauthor: Arclin\ntags:\n  - iOS\n  - Reactive Cocoa\ncategories:\n  - iOS\nabbrlink: 79533f9e\ndate: 2016-10-17 00:00:00\n---\nRACCommand使用注意\n\n<!-- more -->\n\n 1. `signalBlock`必须要返回一个信号，不能传nil. \n 2. 如果不想要传递信号，直接创建空的信号`[RACSignal empty]`;\n 3. RACCommand中信号如果数据传递完，必须调用`[subscriber sendCompleted]`，这时命令才会执行完毕，否则永远处于执行中。\n 4. `RACCommand`需要被强引用，否则接收不到`RACCommand`中的信号，因此RACCommand中的信号是延迟发送的。\n\n- `RACCommand`设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。\n\n \t1. 在RAC开发中，通常会把网络请求封装到`RACCommand`，直接执行某个RACCommand就能发送请求。\n \t2. 当`RACCommand`内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。\n\n- 如何拿到RACCommand中返回信号发出的数据。\n\n \t1. RACCommand有个执行信号源`executionSignals`，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。\n \t2. 订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。\n\n- 监听当前命令是否正在执行`executing`\n- 使用场景,监听按钮点击，网络请求","slug":"RACCommand使用注意","published":1,"updated":"2018-05-10T06:51:35.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbchw000vldxuon4qusd6","content":"<p>RACCommand使用注意</p>\n<a id=\"more\"></a>\n<ol>\n<li><code>signalBlock</code>必须要返回一个信号，不能传nil. </li>\n<li>如果不想要传递信号，直接创建空的信号<code>[RACSignal empty]</code>;</li>\n<li>RACCommand中信号如果数据传递完，必须调用<code>[subscriber sendCompleted]</code>，这时命令才会执行完毕，否则永远处于执行中。</li>\n<li><code>RACCommand</code>需要被强引用，否则接收不到<code>RACCommand</code>中的信号，因此RACCommand中的信号是延迟发送的。</li>\n</ol>\n<ul>\n<li><p><code>RACCommand</code>设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。</p>\n<ol>\n<li>在RAC开发中，通常会把网络请求封装到<code>RACCommand</code>，直接执行某个RACCommand就能发送请求。</li>\n<li>当<code>RACCommand</code>内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。</li>\n</ol>\n</li>\n<li><p>如何拿到RACCommand中返回信号发出的数据。</p>\n<ol>\n<li>RACCommand有个执行信号源<code>executionSignals</code>，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。</li>\n<li>订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。</li>\n</ol>\n</li>\n<li><p>监听当前命令是否正在执行<code>executing</code></p>\n</li>\n<li>使用场景,监听按钮点击，网络请求</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>RACCommand使用注意</p>","more":"<ol>\n<li><code>signalBlock</code>必须要返回一个信号，不能传nil. </li>\n<li>如果不想要传递信号，直接创建空的信号<code>[RACSignal empty]</code>;</li>\n<li>RACCommand中信号如果数据传递完，必须调用<code>[subscriber sendCompleted]</code>，这时命令才会执行完毕，否则永远处于执行中。</li>\n<li><code>RACCommand</code>需要被强引用，否则接收不到<code>RACCommand</code>中的信号，因此RACCommand中的信号是延迟发送的。</li>\n</ol>\n<ul>\n<li><p><code>RACCommand</code>设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。</p>\n<ol>\n<li>在RAC开发中，通常会把网络请求封装到<code>RACCommand</code>，直接执行某个RACCommand就能发送请求。</li>\n<li>当<code>RACCommand</code>内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。</li>\n</ol>\n</li>\n<li><p>如何拿到RACCommand中返回信号发出的数据。</p>\n<ol>\n<li>RACCommand有个执行信号源<code>executionSignals</code>，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。</li>\n<li>订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。</li>\n</ol>\n</li>\n<li><p>监听当前命令是否正在执行<code>executing</code></p>\n</li>\n<li>使用场景,监听按钮点击，网络请求</li>\n</ul>"},{"title":"Nginx 内容替换模块 http_substitutions_filter_module","author":"Arclin","abbrlink":"e35ccdb6","date":"2018-02-18T14:16:00.000Z","_content":"在镜像了某个网站之后,想要改变这个网站上某些元素的显示内容, 这是我们可以使用nginx的一个第三方模块`http_substitutions_filter_module`\n\n<!-- more -->\n\n修改nginx配置文件\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    listen 443 ssl http2;\n    ssl_certificate /etc/letsencrypt/live/arclin.me/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/arclin.me/privkey.pem;\n    resolver 8.8.8.8;\n    location / {\n        subs_filter Google\\s提供 Arclin提供 r;\n        google on;\n    }\n  }\n```","source":"_posts/Nginx-内容替换模块-http-substitutions-filter-module.md","raw":"---\ntitle: Nginx 内容替换模块 http_substitutions_filter_module\nauthor: Arclin\ntags:\n  - nginx\ncategories:\n  - Linux\nabbrlink: e35ccdb6\ndate: 2018-02-18 22:16:00\n---\n在镜像了某个网站之后,想要改变这个网站上某些元素的显示内容, 这是我们可以使用nginx的一个第三方模块`http_substitutions_filter_module`\n\n<!-- more -->\n\n修改nginx配置文件\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    listen 443 ssl http2;\n    ssl_certificate /etc/letsencrypt/live/arclin.me/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/arclin.me/privkey.pem;\n    resolver 8.8.8.8;\n    location / {\n        subs_filter Google\\s提供 Arclin提供 r;\n        google on;\n    }\n  }\n```","slug":"Nginx-内容替换模块-http-substitutions-filter-module","published":1,"updated":"2018-05-10T06:51:35.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbci1000yldxu08ijuva4","content":"<p>在镜像了某个网站之后,想要改变这个网站上某些元素的显示内容, 这是我们可以使用nginx的一个第三方模块<code>http_substitutions_filter_module</code></p>\n<a id=\"more\"></a>\n<p>修改nginx配置文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    listen 443 ssl http2;</span><br><span class=\"line\">    ssl_certificate /etc/letsencrypt/live/arclin.me/fullchain.pem;</span><br><span class=\"line\">    ssl_certificate_key /etc/letsencrypt/live/arclin.me/privkey.pem;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        subs_filter Google\\s提供 Arclin提供 r;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>在镜像了某个网站之后,想要改变这个网站上某些元素的显示内容, 这是我们可以使用nginx的一个第三方模块<code>http_substitutions_filter_module</code></p>","more":"<p>修改nginx配置文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    listen 443 ssl http2;</span><br><span class=\"line\">    ssl_certificate /etc/letsencrypt/live/arclin.me/fullchain.pem;</span><br><span class=\"line\">    ssl_certificate_key /etc/letsencrypt/live/arclin.me/privkey.pem;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        subs_filter Google\\s提供 Arclin提供 r;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"React Native真机运行","author":"Arclin","abbrlink":"7724d1af","date":"2017-03-07T16:00:00.000Z","_content":"三步即可\n\n在项目根目录使用终端执行\n\n```\n$ curl http://localhost:8081/index.ios.bundle -o main.jsbundle\n```\n\n`AppDelegate.m` 找到这一行并注释\n\n```\njsCodeLocation = [NSURL URLWithString:@\"http://localhost:8081/index.ios.bundle?platform=ios&dev=true\"];\n```\n\n`AppDelegate.m` 写上或反注释这一行\n\n```\njsCodeLocation = [[NSBundle mainBundle] URLForResource:@\"main\" withExtension:@\"jsbundle\"];\n```\n","source":"_posts/React-Native真机运行.md","raw":"---\ntitle: React Native真机运行\nauthor: Arclin\ntags:\n  - React Native\n  - iOS\ncategories:\n  - React Native\nabbrlink: 7724d1af\ndate: 2017-03-08 00:00:00\n---\n三步即可\n\n在项目根目录使用终端执行\n\n```\n$ curl http://localhost:8081/index.ios.bundle -o main.jsbundle\n```\n\n`AppDelegate.m` 找到这一行并注释\n\n```\njsCodeLocation = [NSURL URLWithString:@\"http://localhost:8081/index.ios.bundle?platform=ios&dev=true\"];\n```\n\n`AppDelegate.m` 写上或反注释这一行\n\n```\njsCodeLocation = [[NSBundle mainBundle] URLForResource:@\"main\" withExtension:@\"jsbundle\"];\n```\n","slug":"React-Native真机运行","published":1,"updated":"2018-05-10T06:51:35.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbci70013ldxuj1n095wr","content":"<p>三步即可</p>\n<p>在项目根目录使用终端执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl http://localhost:8081/index.ios.bundle -o main.jsbundle</span><br></pre></td></tr></table></figure>\n<p><code>AppDelegate.m</code> 找到这一行并注释</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsCodeLocation = [NSURL URLWithString:@&quot;http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;];</span><br></pre></td></tr></table></figure>\n<p><code>AppDelegate.m</code> 写上或反注释这一行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;];</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>三步即可</p>\n<p>在项目根目录使用终端执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl http://localhost:8081/index.ios.bundle -o main.jsbundle</span><br></pre></td></tr></table></figure>\n<p><code>AppDelegate.m</code> 找到这一行并注释</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsCodeLocation = [NSURL URLWithString:@&quot;http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;];</span><br></pre></td></tr></table></figure>\n<p><code>AppDelegate.m</code> 写上或反注释这一行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;];</span><br></pre></td></tr></table></figure>\n"},{"title":"Node.js学习笔记","author":"Arclin","abbrlink":"1aafa723","date":"2017-03-05T16:00:00.000Z","_content":"Node.js的学习笔记,持续更新\n\n<!-- more -->\n\n> Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型\n>\n> 事件驱动\n>> 所谓事件驱动，简单地说就是你点什么按钮（即产生什么事件），电脑执行什么操作（即调用什么函数）.当然事件不仅限于用户的操作. 事件驱动的核心自然是事件。从事件角度说，事件驱动程序的基本结构是由一个事件收集器、一个事件发送器和一个_事件处理器组成。\n\n>> 事件收集器专门负责收集所有事件，包括来自用户的（如鼠标、键盘事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。\n事件发送器负责将收集器收集到的事件分发到目标对象中。\n事件处理器做具体的事件响应工作，它往往要到实现阶段才完全确定，因而需要运用虚函数机制（函数名往往取为类似于HandleMsg的一个名字）。对于框架的使用者来说，他们唯一能够看到的是事件处理器。这也是他们所关心的内容。\n\n> 非阻塞式 I/O\n\n>> I/O 即Input/Output 的缩写\n\n>> 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.\n\n>> 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。\n非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。\n\n>>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。\n在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。\n\n## let var const\n\n`let` 允许把变量的作用域限制在块级域中。与 `var` 不同处是：`var` 申明变量要么是全局的，要么是函数级的，而无法是块级的。\n\n`let`的作用域是块，而`var`的作用域是函数\n\n```\n'use strict';\nfor (let i = 0; i < 10; i++) {\n  console.log(i); // 0, 1, 2, 3, 4 ... 9\n}\nconsole.log(i); // i is not defined\nconst这个声明创建一个常量,可以全局或局部的函数声明,不可以被重新赋值.\n```\n\n## Map WeakMap Set WeakSet\n\n### Map\nMap原生提供三个遍历器生成函数和一个遍历方法。\n\n`keys()` 返回键名的遍历器。\n`values()` 返回键值的遍历器。\n`entries()` 返回所有成员的遍历器。\n`forEach()` 遍历Map的所有成员。\n\n```\nvar myMap = new Map();\nmyMap.set(0, \"zero\");\nmyMap.set(1, \"one\");\n \nfor (var key of myMap.keys()) {\n  console.log(key);\n}\n// 0 1\n \nfor (var value of myMap.values()) {\n  console.log(value);\n}\n// zero one\n \nfor (var item of myMap.entries()) {\n  console.log(item[0] + \" = \" + item[1]);\n}\n// 0 = zero 1 = one\n \nmyMap.forEach(function(value, key) {\n  console.log(key + \" = \" + value);\n}, myMap)\n// 0 = zero 1 = one\n```\n\n### WeakMap\nWeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。\nWeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。\nWeakMap只有四个方法可用：get()、set()、has()、delete()。\n\n### Set\n`add(value)` 添加某个值，返回Set结构本身。\n`delete(value)` 删除某个值，返回一个布尔值，表示删除是否成功。\n`has(value)` 返回一个布尔值，表示该值是否为Set的成员。\n`clear()` 清除所有成员，没有返回值。 上面这些属性和方法的实例如下。\n\n```\nvar s = new Set();\ns.add(1).add(2).add(2);\n// 注意2被加入了两次\nconsole.log(s.size); // 2\nconsole.log(s.has(1)); // true\nconsole.log(s.has(2)); // true\nconsole.log(s.has(3)); // false\nconsole.log(s.delete(2));\nconsole.log(s.has(2)); // false\n```\n\nSet的遍历跟Map差不多,但是如果使用`set.entries()`去遍历的话,出来的结果会是像这样子[\"red\", \"red\"] [\"green\", \"green\"] [\"blue\", \"blue\"],包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。\n### WeakSet\nweakSet和WeakMap的道理也差不多,WeakSet的成员只能是对象，而不能是其他类型的值.WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用\nWeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。\n\n```\nvar ws = new WeakSet();\nvar obj = {};\nvar foo = {};\nws.add(obj);\nws.has(foo);    // false\nWeakSet没有size属性，没有办法遍历它的成员。\nws.size // undefined\nws.forEach // undefined\nws.forEach(function(item){ console.log('WeakSet has ' + item)})\n```\n\n```\n// TypeError: undefined is not a function\n```\n## Generator Promise Symbol\n### Generator\nGenerator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。\n\n执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。\n\n```\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\nvar hw = helloWorldGenerator();\nconsole.log(hw.next()); \\\\ { value: 'hello', done: false }\nconsole.log(hw.next()); \\\\ { value: 'world', done: false }\nconsole.log(hw.next()); \\\\ { value: 'ending', done: true }\nconsole.log(hw.next()); \\\\ { value: undefined, done: true }\n```\n\n`yield` 意为’产出’ 是用来定义不同的内部状态,调用next()方法的时候会返回Generator的下一个状态,直到return为止,输出的done中的值表示Generator函数是否已经执行结束.\n\n`yield *` 语句 : 用来在一个Generator中执行另外一个Generator函数\n\n```\nfunction* anotherGenerator(i) {\n  yield i + 1;\n  yield i + 2;\n  yield i + 3;\n}\nfunction* generator(i){\n  yield i;\n  yield* anotherGenerator(i);\n  yield i + 10;\n}\nvar gen = generator(10);\nconsole.log(gen.next().value); // 10\nconsole.log(gen.next().value); // 11\nconsole.log(gen.next().value); // 12\nconsole.log(gen.next().value); // 13\nconsole.log(gen.next().value); // 20\n```\n运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。\n\n### Promise\nPromise 是一个构造函数\n\n```\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\nPromise函数自带两个参数: `resolve`意为返回一个成功的回调,`reject`意为返回一个错误的回调\n然后订阅回调的方法如下\n\n```\npromise.then(function(value) {\n  // success\n}, function(value) {\n  // failure\n});\n```\n\nPS: 这个函数很像OC的block方法,上面的函数就类似OC的如下写法\n\n```\n- (void)promise:(void(^)(id success))resolve failure:(void(^)(id failure))reject {\n\tif(...){\n\t\tresolve(resolveValue);\n\t}else {\n\t\treject(rejectValue);\n\t}\n} \n\n//订阅\n[self promise:^(id success){\n\tNSLog(success);\n} failure:^(id failure){\n\tNSLog(failure);\n}];\n// 纯脑补,也不知道有没有写对\n```\n\n#### catch() 方法\n专门用来捕获异常的回调,会捕获到`then()`的第二个参数的回调\n\n如果在`then()`中使用了throw xxx;语句,那么也会走`catch()`回调\n\n`catch()`和`then()`方法都会返回Promise对象,所以可以链式调用\n\n```\npromise.then(function(value) {\n    console.log(value);      \n},null).catch(function(value){\n\tconsole.log(value);\n});\n```\n\nOR\n\n```\np1.then(function(value) {\n  console.log(value); // \"成功!\"\n  throw \"哦，不!\";\n}).catch(function(e) {\n  console.log(e); // \"哦，不!\"\n});\n```\n\n你还可以`then()`完再`then()`\n\n```\nvar p2 = new Promise(function(resolve, reject) {\n  resolve(1);\n});\n\np2.then(function(value) {\n  console.log(value); // 1\n  return value + 1;\n}).then(function(value) {\n  console.log(value); // 2\n});\n```\n#### all() 方法\n\nPromise.all方法用于将多个Promise实例，包装成一个新的Promise实例。\n\n```\nvar p = Promise.all([p1,p2,p3]);\n```\n\n只要有一个reject了,那么p就会抛出失败的回调,只有全部都resolve了,才会抛出成功的回调\n\n#### race() 方法\n顾名思义 赛跑\n\n同样是来绑定多个Promise实例,不同的是谁先返回就走谁的回调,如果p1五秒后发失败回调,p2一秒后发成功回调,那么Promise.race([p1, p2])就等于p2.\n\n```\nPromise.race([p1, p2]).then(function(value) {\n  console.log(value); // \"two\"\n  // Both resolve, but p2 is faster\n});\n```\n\n### Symbol\n符号\n\n用Symbol生成的对象,绝对不会重复!!!\n\n```\nvar s1 = Symbol(\"foo\");\nvar s2 = Symbol(\"foo\");\nconsole.log(s1 === s2); // false\ngetOwnPropertySymbols()\n```\n\n这个方法可以获得对象的所有Symbol类型的成员属性名\n\n```\nvar obj = {};\nvar a = Symbol('a');\nvar b = Symbol('b');\n \nobj[a] = 'Hello';\nobj[b] = 'World';\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\nconsole.log(objectSymbols);\n// [Symbol(a), Symbol(b)]\n```\n\n#### Symbol.for()\n这个方法用来搜索之前有没有定义过某个Symbol名,如果有的话就返回值没有的话就就新建一个Symbol,有种取缓存的感觉\n\n```\nvar s1 = Symbol.for('foo'); // 定义一下\nvar s2 = Symbol.for('foo'); // 取出之前定义的值\nconsole.log(s1 === s2); // true\nSymbol.keyFor()\n跟上面的是相反的,通过值来取键\n\nvar s1 = Symbol.for(\"foo\");\nSymbol.keyFor(s1) // \"foo\"\n \nvar s2 = Symbol(\"foo\");\nSymbol.keyFor(s2) // undefined\n```\n\n## 箭头函数\n其实就是简写方法而已\n\n```\nvar  f = function(v1,v2) {\n\treturn v1+v2;\n}\n```\n\n等同于\n\n```\nvar f = (v1,v2) => v1+v2;\n```\n\n### 注意事项\n\n函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。\n不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。\n不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用`Rest`参数代替。\n不可以使用`yield`命令，因此箭头函数不能用作Generator函数。\n\n## 网络请求\n\n### 方式一 使用 http.request()\n\n```\nvar http = require('http');  \n  \nvar qs = require('querystring');  \n  \nvar data = {  \n    a: 123,  \n    time: new Date().getTime()};//这是需要提交的数据  \n    \nvar content = qs.stringify(data);   \nvar options = {  \n    hostname: '127.0.0.1',  \n    port: 10086,  \n    path: '/pay/pay_callback?' + content,  \n    method: 'GET'  \n};  \n  \nvar req = http.request(options, function (res) {  \n    console.log('STATUS: ' + res.statusCode);  \n    console.log('HEADERS: ' + JSON.stringify(res.headers));  \n    res.setEncoding('utf8');  \n    res.on('data', function (chunk) {  \n        console.log('BODY: ' + chunk);  \n    });  \n});  \n  \nreq.on('error', function (e) {  \n    console.log('problem with request: ' + e.message);  \n});  \n  \nreq.end();\n```\n\n### 方式二 使用 http.get() 发送GET请求\n\n```\nvar httpRequest = http.get('http://localhost:8088/tempFile/LocalData.json',function(request,response){\n      var html='';\n      request.on('data',function(data){\n        \thtml+=data;\n      });\n      request.on('end',function(){\n\t\t\tconsole.log(html);\n      });\n  });\n```\n\n> 学习资料来自:[http://www.hubwiz.com](http://www.hubwiz.com) 等","source":"_posts/Node-js学习笔记.md","raw":"---\ntitle: Node.js学习笔记\nauthor: Arclin\ntags:\n  - Node.js\ncategories:\n  - Node.js\nabbrlink: 1aafa723\ndate: 2017-03-06 00:00:00\n---\nNode.js的学习笔记,持续更新\n\n<!-- more -->\n\n> Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型\n>\n> 事件驱动\n>> 所谓事件驱动，简单地说就是你点什么按钮（即产生什么事件），电脑执行什么操作（即调用什么函数）.当然事件不仅限于用户的操作. 事件驱动的核心自然是事件。从事件角度说，事件驱动程序的基本结构是由一个事件收集器、一个事件发送器和一个_事件处理器组成。\n\n>> 事件收集器专门负责收集所有事件，包括来自用户的（如鼠标、键盘事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。\n事件发送器负责将收集器收集到的事件分发到目标对象中。\n事件处理器做具体的事件响应工作，它往往要到实现阶段才完全确定，因而需要运用虚函数机制（函数名往往取为类似于HandleMsg的一个名字）。对于框架的使用者来说，他们唯一能够看到的是事件处理器。这也是他们所关心的内容。\n\n> 非阻塞式 I/O\n\n>> I/O 即Input/Output 的缩写\n\n>> 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.\n\n>> 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。\n非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。\n\n>>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。\n在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。\n\n## let var const\n\n`let` 允许把变量的作用域限制在块级域中。与 `var` 不同处是：`var` 申明变量要么是全局的，要么是函数级的，而无法是块级的。\n\n`let`的作用域是块，而`var`的作用域是函数\n\n```\n'use strict';\nfor (let i = 0; i < 10; i++) {\n  console.log(i); // 0, 1, 2, 3, 4 ... 9\n}\nconsole.log(i); // i is not defined\nconst这个声明创建一个常量,可以全局或局部的函数声明,不可以被重新赋值.\n```\n\n## Map WeakMap Set WeakSet\n\n### Map\nMap原生提供三个遍历器生成函数和一个遍历方法。\n\n`keys()` 返回键名的遍历器。\n`values()` 返回键值的遍历器。\n`entries()` 返回所有成员的遍历器。\n`forEach()` 遍历Map的所有成员。\n\n```\nvar myMap = new Map();\nmyMap.set(0, \"zero\");\nmyMap.set(1, \"one\");\n \nfor (var key of myMap.keys()) {\n  console.log(key);\n}\n// 0 1\n \nfor (var value of myMap.values()) {\n  console.log(value);\n}\n// zero one\n \nfor (var item of myMap.entries()) {\n  console.log(item[0] + \" = \" + item[1]);\n}\n// 0 = zero 1 = one\n \nmyMap.forEach(function(value, key) {\n  console.log(key + \" = \" + value);\n}, myMap)\n// 0 = zero 1 = one\n```\n\n### WeakMap\nWeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。\nWeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。\nWeakMap只有四个方法可用：get()、set()、has()、delete()。\n\n### Set\n`add(value)` 添加某个值，返回Set结构本身。\n`delete(value)` 删除某个值，返回一个布尔值，表示删除是否成功。\n`has(value)` 返回一个布尔值，表示该值是否为Set的成员。\n`clear()` 清除所有成员，没有返回值。 上面这些属性和方法的实例如下。\n\n```\nvar s = new Set();\ns.add(1).add(2).add(2);\n// 注意2被加入了两次\nconsole.log(s.size); // 2\nconsole.log(s.has(1)); // true\nconsole.log(s.has(2)); // true\nconsole.log(s.has(3)); // false\nconsole.log(s.delete(2));\nconsole.log(s.has(2)); // false\n```\n\nSet的遍历跟Map差不多,但是如果使用`set.entries()`去遍历的话,出来的结果会是像这样子[\"red\", \"red\"] [\"green\", \"green\"] [\"blue\", \"blue\"],包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。\n### WeakSet\nweakSet和WeakMap的道理也差不多,WeakSet的成员只能是对象，而不能是其他类型的值.WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用\nWeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。\n\n```\nvar ws = new WeakSet();\nvar obj = {};\nvar foo = {};\nws.add(obj);\nws.has(foo);    // false\nWeakSet没有size属性，没有办法遍历它的成员。\nws.size // undefined\nws.forEach // undefined\nws.forEach(function(item){ console.log('WeakSet has ' + item)})\n```\n\n```\n// TypeError: undefined is not a function\n```\n## Generator Promise Symbol\n### Generator\nGenerator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。\n\n执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。\n\n```\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\nvar hw = helloWorldGenerator();\nconsole.log(hw.next()); \\\\ { value: 'hello', done: false }\nconsole.log(hw.next()); \\\\ { value: 'world', done: false }\nconsole.log(hw.next()); \\\\ { value: 'ending', done: true }\nconsole.log(hw.next()); \\\\ { value: undefined, done: true }\n```\n\n`yield` 意为’产出’ 是用来定义不同的内部状态,调用next()方法的时候会返回Generator的下一个状态,直到return为止,输出的done中的值表示Generator函数是否已经执行结束.\n\n`yield *` 语句 : 用来在一个Generator中执行另外一个Generator函数\n\n```\nfunction* anotherGenerator(i) {\n  yield i + 1;\n  yield i + 2;\n  yield i + 3;\n}\nfunction* generator(i){\n  yield i;\n  yield* anotherGenerator(i);\n  yield i + 10;\n}\nvar gen = generator(10);\nconsole.log(gen.next().value); // 10\nconsole.log(gen.next().value); // 11\nconsole.log(gen.next().value); // 12\nconsole.log(gen.next().value); // 13\nconsole.log(gen.next().value); // 20\n```\n运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。\n\n### Promise\nPromise 是一个构造函数\n\n```\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\nPromise函数自带两个参数: `resolve`意为返回一个成功的回调,`reject`意为返回一个错误的回调\n然后订阅回调的方法如下\n\n```\npromise.then(function(value) {\n  // success\n}, function(value) {\n  // failure\n});\n```\n\nPS: 这个函数很像OC的block方法,上面的函数就类似OC的如下写法\n\n```\n- (void)promise:(void(^)(id success))resolve failure:(void(^)(id failure))reject {\n\tif(...){\n\t\tresolve(resolveValue);\n\t}else {\n\t\treject(rejectValue);\n\t}\n} \n\n//订阅\n[self promise:^(id success){\n\tNSLog(success);\n} failure:^(id failure){\n\tNSLog(failure);\n}];\n// 纯脑补,也不知道有没有写对\n```\n\n#### catch() 方法\n专门用来捕获异常的回调,会捕获到`then()`的第二个参数的回调\n\n如果在`then()`中使用了throw xxx;语句,那么也会走`catch()`回调\n\n`catch()`和`then()`方法都会返回Promise对象,所以可以链式调用\n\n```\npromise.then(function(value) {\n    console.log(value);      \n},null).catch(function(value){\n\tconsole.log(value);\n});\n```\n\nOR\n\n```\np1.then(function(value) {\n  console.log(value); // \"成功!\"\n  throw \"哦，不!\";\n}).catch(function(e) {\n  console.log(e); // \"哦，不!\"\n});\n```\n\n你还可以`then()`完再`then()`\n\n```\nvar p2 = new Promise(function(resolve, reject) {\n  resolve(1);\n});\n\np2.then(function(value) {\n  console.log(value); // 1\n  return value + 1;\n}).then(function(value) {\n  console.log(value); // 2\n});\n```\n#### all() 方法\n\nPromise.all方法用于将多个Promise实例，包装成一个新的Promise实例。\n\n```\nvar p = Promise.all([p1,p2,p3]);\n```\n\n只要有一个reject了,那么p就会抛出失败的回调,只有全部都resolve了,才会抛出成功的回调\n\n#### race() 方法\n顾名思义 赛跑\n\n同样是来绑定多个Promise实例,不同的是谁先返回就走谁的回调,如果p1五秒后发失败回调,p2一秒后发成功回调,那么Promise.race([p1, p2])就等于p2.\n\n```\nPromise.race([p1, p2]).then(function(value) {\n  console.log(value); // \"two\"\n  // Both resolve, but p2 is faster\n});\n```\n\n### Symbol\n符号\n\n用Symbol生成的对象,绝对不会重复!!!\n\n```\nvar s1 = Symbol(\"foo\");\nvar s2 = Symbol(\"foo\");\nconsole.log(s1 === s2); // false\ngetOwnPropertySymbols()\n```\n\n这个方法可以获得对象的所有Symbol类型的成员属性名\n\n```\nvar obj = {};\nvar a = Symbol('a');\nvar b = Symbol('b');\n \nobj[a] = 'Hello';\nobj[b] = 'World';\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\nconsole.log(objectSymbols);\n// [Symbol(a), Symbol(b)]\n```\n\n#### Symbol.for()\n这个方法用来搜索之前有没有定义过某个Symbol名,如果有的话就返回值没有的话就就新建一个Symbol,有种取缓存的感觉\n\n```\nvar s1 = Symbol.for('foo'); // 定义一下\nvar s2 = Symbol.for('foo'); // 取出之前定义的值\nconsole.log(s1 === s2); // true\nSymbol.keyFor()\n跟上面的是相反的,通过值来取键\n\nvar s1 = Symbol.for(\"foo\");\nSymbol.keyFor(s1) // \"foo\"\n \nvar s2 = Symbol(\"foo\");\nSymbol.keyFor(s2) // undefined\n```\n\n## 箭头函数\n其实就是简写方法而已\n\n```\nvar  f = function(v1,v2) {\n\treturn v1+v2;\n}\n```\n\n等同于\n\n```\nvar f = (v1,v2) => v1+v2;\n```\n\n### 注意事项\n\n函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。\n不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。\n不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用`Rest`参数代替。\n不可以使用`yield`命令，因此箭头函数不能用作Generator函数。\n\n## 网络请求\n\n### 方式一 使用 http.request()\n\n```\nvar http = require('http');  \n  \nvar qs = require('querystring');  \n  \nvar data = {  \n    a: 123,  \n    time: new Date().getTime()};//这是需要提交的数据  \n    \nvar content = qs.stringify(data);   \nvar options = {  \n    hostname: '127.0.0.1',  \n    port: 10086,  \n    path: '/pay/pay_callback?' + content,  \n    method: 'GET'  \n};  \n  \nvar req = http.request(options, function (res) {  \n    console.log('STATUS: ' + res.statusCode);  \n    console.log('HEADERS: ' + JSON.stringify(res.headers));  \n    res.setEncoding('utf8');  \n    res.on('data', function (chunk) {  \n        console.log('BODY: ' + chunk);  \n    });  \n});  \n  \nreq.on('error', function (e) {  \n    console.log('problem with request: ' + e.message);  \n});  \n  \nreq.end();\n```\n\n### 方式二 使用 http.get() 发送GET请求\n\n```\nvar httpRequest = http.get('http://localhost:8088/tempFile/LocalData.json',function(request,response){\n      var html='';\n      request.on('data',function(data){\n        \thtml+=data;\n      });\n      request.on('end',function(){\n\t\t\tconsole.log(html);\n      });\n  });\n```\n\n> 学习资料来自:[http://www.hubwiz.com](http://www.hubwiz.com) 等","slug":"Node-js学习笔记","published":1,"updated":"2018-05-10T06:51:35.732Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcib0016ldxuo8u506mi","content":"<p>Node.js的学习笔记,持续更新</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型</p>\n<p>事件驱动</p>\n<blockquote>\n<p>所谓事件驱动，简单地说就是你点什么按钮（即产生什么事件），电脑执行什么操作（即调用什么函数）.当然事件不仅限于用户的操作. 事件驱动的核心自然是事件。从事件角度说，事件驱动程序的基本结构是由一个事件收集器、一个事件发送器和一个_事件处理器组成。</p>\n<p>事件收集器专门负责收集所有事件，包括来自用户的（如鼠标、键盘事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。<br>事件发送器负责将收集器收集到的事件分发到目标对象中。<br>事件处理器做具体的事件响应工作，它往往要到实现阶段才完全确定，因而需要运用虚函数机制（函数名往往取为类似于HandleMsg的一个名字）。对于框架的使用者来说，他们唯一能够看到的是事件处理器。这也是他们所关心的内容。</p>\n</blockquote>\n<p>非阻塞式 I/O</p>\n<blockquote>\n<p>I/O 即Input/Output 的缩写</p>\n<p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p>\n<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>\n<p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>\n</blockquote>\n</blockquote>\n<h2 id=\"let-var-const\"><a href=\"#let-var-const\" class=\"headerlink\" title=\"let var const\"></a>let var const</h2><p><code>let</code> 允许把变量的作用域限制在块级域中。与 <code>var</code> 不同处是：<code>var</code> 申明变量要么是全局的，要么是函数级的，而无法是块级的。</p>\n<p><code>let</code>的作用域是块，而<code>var</code>的作用域是函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">  console.log(i); // 0, 1, 2, 3, 4 ... 9</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(i); // i is not defined</span><br><span class=\"line\">const这个声明创建一个常量,可以全局或局部的函数声明,不可以被重新赋值.</span><br></pre></td></tr></table></figure>\n<h2 id=\"Map-WeakMap-Set-WeakSet\"><a href=\"#Map-WeakMap-Set-WeakSet\" class=\"headerlink\" title=\"Map WeakMap Set WeakSet\"></a>Map WeakMap Set WeakSet</h2><h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>Map原生提供三个遍历器生成函数和一个遍历方法。</p>\n<p><code>keys()</code> 返回键名的遍历器。<br><code>values()</code> 返回键值的遍历器。<br><code>entries()</code> 返回所有成员的遍历器。<br><code>forEach()</code> 遍历Map的所有成员。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myMap = new Map();</span><br><span class=\"line\">myMap.set(0, &quot;zero&quot;);</span><br><span class=\"line\">myMap.set(1, &quot;one&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var key of myMap.keys()) &#123;</span><br><span class=\"line\">  console.log(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 0 1</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var value of myMap.values()) &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// zero one</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var item of myMap.entries()) &#123;</span><br><span class=\"line\">  console.log(item[0] + &quot; = &quot; + item[1]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 0 = zero 1 = one</span><br><span class=\"line\"> </span><br><span class=\"line\">myMap.forEach(function(value, key) &#123;</span><br><span class=\"line\">  console.log(key + &quot; = &quot; + value);</span><br><span class=\"line\">&#125;, myMap)</span><br><span class=\"line\">// 0 = zero 1 = one</span><br></pre></td></tr></table></figure>\n<h3 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h3><p>WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。<br>WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。<br>WeakMap只有四个方法可用：get()、set()、has()、delete()。</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p><code>add(value)</code> 添加某个值，返回Set结构本身。<br><code>delete(value)</code> 删除某个值，返回一个布尔值，表示删除是否成功。<br><code>has(value)</code> 返回一个布尔值，表示该值是否为Set的成员。<br><code>clear()</code> 清除所有成员，没有返回值。 上面这些属性和方法的实例如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = new Set();</span><br><span class=\"line\">s.add(1).add(2).add(2);</span><br><span class=\"line\">// 注意2被加入了两次</span><br><span class=\"line\">console.log(s.size); // 2</span><br><span class=\"line\">console.log(s.has(1)); // true</span><br><span class=\"line\">console.log(s.has(2)); // true</span><br><span class=\"line\">console.log(s.has(3)); // false</span><br><span class=\"line\">console.log(s.delete(2));</span><br><span class=\"line\">console.log(s.has(2)); // false</span><br></pre></td></tr></table></figure>\n<p>Set的遍历跟Map差不多,但是如果使用<code>set.entries()</code>去遍历的话,出来的结果会是像这样子[“red”, “red”] [“green”, “green”] [“blue”, “blue”],包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p>weakSet和WeakMap的道理也差不多,WeakSet的成员只能是对象，而不能是其他类型的值.WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用<br>WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ws = new WeakSet();</span><br><span class=\"line\">var obj = &#123;&#125;;</span><br><span class=\"line\">var foo = &#123;&#125;;</span><br><span class=\"line\">ws.add(obj);</span><br><span class=\"line\">ws.has(foo);    // false</span><br><span class=\"line\">WeakSet没有size属性，没有办法遍历它的成员。</span><br><span class=\"line\">ws.size // undefined</span><br><span class=\"line\">ws.forEach // undefined</span><br><span class=\"line\">ws.forEach(function(item)&#123; console.log(&apos;WeakSet has &apos; + item)&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// TypeError: undefined is not a function</span><br></pre></td></tr></table></figure>\n<h2 id=\"Generator-Promise-Symbol\"><a href=\"#Generator-Promise-Symbol\" class=\"headerlink\" title=\"Generator Promise Symbol\"></a>Generator Promise Symbol</h2><h3 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h3><p>Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。</p>\n<p>执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* helloWorldGenerator() &#123;</span><br><span class=\"line\">  yield &apos;hello&apos;;</span><br><span class=\"line\">  yield &apos;world&apos;;</span><br><span class=\"line\">  return &apos;ending&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var hw = helloWorldGenerator();</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &apos;hello&apos;, done: false &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &apos;world&apos;, done: false &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &apos;ending&apos;, done: true &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>\n<p><code>yield</code> 意为’产出’ 是用来定义不同的内部状态,调用next()方法的时候会返回Generator的下一个状态,直到return为止,输出的done中的值表示Generator函数是否已经执行结束.</p>\n<p><code>yield *</code> 语句 : 用来在一个Generator中执行另外一个Generator函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* anotherGenerator(i) &#123;</span><br><span class=\"line\">  yield i + 1;</span><br><span class=\"line\">  yield i + 2;</span><br><span class=\"line\">  yield i + 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function* generator(i)&#123;</span><br><span class=\"line\">  yield i;</span><br><span class=\"line\">  yield* anotherGenerator(i);</span><br><span class=\"line\">  yield i + 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var gen = generator(10);</span><br><span class=\"line\">console.log(gen.next().value); // 10</span><br><span class=\"line\">console.log(gen.next().value); // 11</span><br><span class=\"line\">console.log(gen.next().value); // 12</span><br><span class=\"line\">console.log(gen.next().value); // 13</span><br><span class=\"line\">console.log(gen.next().value); // 20</span><br></pre></td></tr></table></figure>\n<p>运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。</p>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>Promise 是一个构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var promise = new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">  // ... some code</span><br><span class=\"line\">  if (/* 异步操作成功 */)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Promise函数自带两个参数: <code>resolve</code>意为返回一个成功的回调,<code>reject</code>意为返回一个错误的回调<br>然后订阅回调的方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(function(value) &#123;</span><br><span class=\"line\">  // success</span><br><span class=\"line\">&#125;, function(value) &#123;</span><br><span class=\"line\">  // failure</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>PS: 这个函数很像OC的block方法,上面的函数就类似OC的如下写法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)promise:(void(^)(id success))resolve failure:(void(^)(id failure))reject &#123;</span><br><span class=\"line\">\tif(...)&#123;</span><br><span class=\"line\">\t\tresolve(resolveValue);</span><br><span class=\"line\">\t&#125;else &#123;</span><br><span class=\"line\">\t\treject(rejectValue);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">//订阅</span><br><span class=\"line\">[self promise:^(id success)&#123;</span><br><span class=\"line\">\tNSLog(success);</span><br><span class=\"line\">&#125; failure:^(id failure)&#123;</span><br><span class=\"line\">\tNSLog(failure);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">// 纯脑补,也不知道有没有写对</span><br></pre></td></tr></table></figure>\n<h4 id=\"catch-方法\"><a href=\"#catch-方法\" class=\"headerlink\" title=\"catch() 方法\"></a>catch() 方法</h4><p>专门用来捕获异常的回调,会捕获到<code>then()</code>的第二个参数的回调</p>\n<p>如果在<code>then()</code>中使用了throw xxx;语句,那么也会走<code>catch()</code>回调</p>\n<p><code>catch()</code>和<code>then()</code>方法都会返回Promise对象,所以可以链式调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(function(value) &#123;</span><br><span class=\"line\">    console.log(value);      </span><br><span class=\"line\">&#125;,null).catch(function(value)&#123;</span><br><span class=\"line\">\tconsole.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>OR</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p1.then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); // &quot;成功!&quot;</span><br><span class=\"line\">  throw &quot;哦，不!&quot;;</span><br><span class=\"line\">&#125;).catch(function(e) &#123;</span><br><span class=\"line\">  console.log(e); // &quot;哦，不!&quot;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>你还可以<code>then()</code>完再<code>then()</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p2 = new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">  resolve(1);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p2.then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); // 1</span><br><span class=\"line\">  return value + 1;</span><br><span class=\"line\">&#125;).then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); // 2</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"all-方法\"><a href=\"#all-方法\" class=\"headerlink\" title=\"all() 方法\"></a>all() 方法</h4><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p = Promise.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>\n<p>只要有一个reject了,那么p就会抛出失败的回调,只有全部都resolve了,才会抛出成功的回调</p>\n<h4 id=\"race-方法\"><a href=\"#race-方法\" class=\"headerlink\" title=\"race() 方法\"></a>race() 方法</h4><p>顾名思义 赛跑</p>\n<p>同样是来绑定多个Promise实例,不同的是谁先返回就走谁的回调,如果p1五秒后发失败回调,p2一秒后发成功回调,那么Promise.race([p1, p2])就等于p2.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.race([p1, p2]).then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); // &quot;two&quot;</span><br><span class=\"line\">  // Both resolve, but p2 is faster</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h3><p>符号</p>\n<p>用Symbol生成的对象,绝对不会重复!!!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1 = Symbol(&quot;foo&quot;);</span><br><span class=\"line\">var s2 = Symbol(&quot;foo&quot;);</span><br><span class=\"line\">console.log(s1 === s2); // false</span><br><span class=\"line\">getOwnPropertySymbols()</span><br></pre></td></tr></table></figure>\n<p>这个方法可以获得对象的所有Symbol类型的成员属性名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;&#125;;</span><br><span class=\"line\">var a = Symbol(&apos;a&apos;);</span><br><span class=\"line\">var b = Symbol(&apos;b&apos;);</span><br><span class=\"line\"> </span><br><span class=\"line\">obj[a] = &apos;Hello&apos;;</span><br><span class=\"line\">obj[b] = &apos;World&apos;;</span><br><span class=\"line\">var objectSymbols = Object.getOwnPropertySymbols(obj);</span><br><span class=\"line\">console.log(objectSymbols);</span><br><span class=\"line\">// [Symbol(a), Symbol(b)]</span><br></pre></td></tr></table></figure>\n<h4 id=\"Symbol-for\"><a href=\"#Symbol-for\" class=\"headerlink\" title=\"Symbol.for()\"></a>Symbol.for()</h4><p>这个方法用来搜索之前有没有定义过某个Symbol名,如果有的话就返回值没有的话就就新建一个Symbol,有种取缓存的感觉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1 = Symbol.for(&apos;foo&apos;); // 定义一下</span><br><span class=\"line\">var s2 = Symbol.for(&apos;foo&apos;); // 取出之前定义的值</span><br><span class=\"line\">console.log(s1 === s2); // true</span><br><span class=\"line\">Symbol.keyFor()</span><br><span class=\"line\">跟上面的是相反的,通过值来取键</span><br><span class=\"line\"></span><br><span class=\"line\">var s1 = Symbol.for(&quot;foo&quot;);</span><br><span class=\"line\">Symbol.keyFor(s1) // &quot;foo&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">var s2 = Symbol(&quot;foo&quot;);</span><br><span class=\"line\">Symbol.keyFor(s2) // undefined</span><br></pre></td></tr></table></figure>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>其实就是简写方法而已</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var  f = function(v1,v2) &#123;</span><br><span class=\"line\">\treturn v1+v2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f = (v1,v2) =&gt; v1+v2;</span><br></pre></td></tr></table></figure>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。<br>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。<br>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用<code>Rest</code>参数代替。<br>不可以使用<code>yield</code>命令，因此箭头函数不能用作Generator函数。</p>\n<h2 id=\"网络请求\"><a href=\"#网络请求\" class=\"headerlink\" title=\"网络请求\"></a>网络请求</h2><h3 id=\"方式一-使用-http-request\"><a href=\"#方式一-使用-http-request\" class=\"headerlink\" title=\"方式一 使用 http.request()\"></a>方式一 使用 http.request()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var http = require(&apos;http&apos;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">var qs = require(&apos;querystring&apos;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">var data = &#123;  </span><br><span class=\"line\">    a: 123,  </span><br><span class=\"line\">    time: new Date().getTime()&#125;;//这是需要提交的数据  </span><br><span class=\"line\">    </span><br><span class=\"line\">var content = qs.stringify(data);   </span><br><span class=\"line\">var options = &#123;  </span><br><span class=\"line\">    hostname: &apos;127.0.0.1&apos;,  </span><br><span class=\"line\">    port: 10086,  </span><br><span class=\"line\">    path: &apos;/pay/pay_callback?&apos; + content,  </span><br><span class=\"line\">    method: &apos;GET&apos;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">var req = http.request(options, function (res) &#123;  </span><br><span class=\"line\">    console.log(&apos;STATUS: &apos; + res.statusCode);  </span><br><span class=\"line\">    console.log(&apos;HEADERS: &apos; + JSON.stringify(res.headers));  </span><br><span class=\"line\">    res.setEncoding(&apos;utf8&apos;);  </span><br><span class=\"line\">    res.on(&apos;data&apos;, function (chunk) &#123;  </span><br><span class=\"line\">        console.log(&apos;BODY: &apos; + chunk);  </span><br><span class=\"line\">    &#125;);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">req.on(&apos;error&apos;, function (e) &#123;  </span><br><span class=\"line\">    console.log(&apos;problem with request: &apos; + e.message);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">req.end();</span><br></pre></td></tr></table></figure>\n<h3 id=\"方式二-使用-http-get-发送GET请求\"><a href=\"#方式二-使用-http-get-发送GET请求\" class=\"headerlink\" title=\"方式二 使用 http.get() 发送GET请求\"></a>方式二 使用 http.get() 发送GET请求</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var httpRequest = http.get(&apos;http://localhost:8088/tempFile/LocalData.json&apos;,function(request,response)&#123;</span><br><span class=\"line\">      var html=&apos;&apos;;</span><br><span class=\"line\">      request.on(&apos;data&apos;,function(data)&#123;</span><br><span class=\"line\">        \thtml+=data;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      request.on(&apos;end&apos;,function()&#123;</span><br><span class=\"line\">\t\t\tconsole.log(html);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>学习资料来自:<a href=\"http://www.hubwiz.com\" target=\"_blank\" rel=\"noopener\">http://www.hubwiz.com</a> 等</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>Node.js的学习笔记,持续更新</p>","more":"<blockquote>\n<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型</p>\n<p>事件驱动</p>\n<blockquote>\n<p>所谓事件驱动，简单地说就是你点什么按钮（即产生什么事件），电脑执行什么操作（即调用什么函数）.当然事件不仅限于用户的操作. 事件驱动的核心自然是事件。从事件角度说，事件驱动程序的基本结构是由一个事件收集器、一个事件发送器和一个_事件处理器组成。</p>\n<p>事件收集器专门负责收集所有事件，包括来自用户的（如鼠标、键盘事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。<br>事件发送器负责将收集器收集到的事件分发到目标对象中。<br>事件处理器做具体的事件响应工作，它往往要到实现阶段才完全确定，因而需要运用虚函数机制（函数名往往取为类似于HandleMsg的一个名字）。对于框架的使用者来说，他们唯一能够看到的是事件处理器。这也是他们所关心的内容。</p>\n</blockquote>\n<p>非阻塞式 I/O</p>\n<blockquote>\n<p>I/O 即Input/Output 的缩写</p>\n<p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p>\n<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>\n<p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>\n</blockquote>\n</blockquote>\n<h2 id=\"let-var-const\"><a href=\"#let-var-const\" class=\"headerlink\" title=\"let var const\"></a>let var const</h2><p><code>let</code> 允许把变量的作用域限制在块级域中。与 <code>var</code> 不同处是：<code>var</code> 申明变量要么是全局的，要么是函数级的，而无法是块级的。</p>\n<p><code>let</code>的作用域是块，而<code>var</code>的作用域是函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;;</span><br><span class=\"line\">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">  console.log(i); // 0, 1, 2, 3, 4 ... 9</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(i); // i is not defined</span><br><span class=\"line\">const这个声明创建一个常量,可以全局或局部的函数声明,不可以被重新赋值.</span><br></pre></td></tr></table></figure>\n<h2 id=\"Map-WeakMap-Set-WeakSet\"><a href=\"#Map-WeakMap-Set-WeakSet\" class=\"headerlink\" title=\"Map WeakMap Set WeakSet\"></a>Map WeakMap Set WeakSet</h2><h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>Map原生提供三个遍历器生成函数和一个遍历方法。</p>\n<p><code>keys()</code> 返回键名的遍历器。<br><code>values()</code> 返回键值的遍历器。<br><code>entries()</code> 返回所有成员的遍历器。<br><code>forEach()</code> 遍历Map的所有成员。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myMap = new Map();</span><br><span class=\"line\">myMap.set(0, &quot;zero&quot;);</span><br><span class=\"line\">myMap.set(1, &quot;one&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var key of myMap.keys()) &#123;</span><br><span class=\"line\">  console.log(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 0 1</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var value of myMap.values()) &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// zero one</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var item of myMap.entries()) &#123;</span><br><span class=\"line\">  console.log(item[0] + &quot; = &quot; + item[1]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 0 = zero 1 = one</span><br><span class=\"line\"> </span><br><span class=\"line\">myMap.forEach(function(value, key) &#123;</span><br><span class=\"line\">  console.log(key + &quot; = &quot; + value);</span><br><span class=\"line\">&#125;, myMap)</span><br><span class=\"line\">// 0 = zero 1 = one</span><br></pre></td></tr></table></figure>\n<h3 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h3><p>WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。<br>WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。<br>WeakMap只有四个方法可用：get()、set()、has()、delete()。</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p><code>add(value)</code> 添加某个值，返回Set结构本身。<br><code>delete(value)</code> 删除某个值，返回一个布尔值，表示删除是否成功。<br><code>has(value)</code> 返回一个布尔值，表示该值是否为Set的成员。<br><code>clear()</code> 清除所有成员，没有返回值。 上面这些属性和方法的实例如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = new Set();</span><br><span class=\"line\">s.add(1).add(2).add(2);</span><br><span class=\"line\">// 注意2被加入了两次</span><br><span class=\"line\">console.log(s.size); // 2</span><br><span class=\"line\">console.log(s.has(1)); // true</span><br><span class=\"line\">console.log(s.has(2)); // true</span><br><span class=\"line\">console.log(s.has(3)); // false</span><br><span class=\"line\">console.log(s.delete(2));</span><br><span class=\"line\">console.log(s.has(2)); // false</span><br></pre></td></tr></table></figure>\n<p>Set的遍历跟Map差不多,但是如果使用<code>set.entries()</code>去遍历的话,出来的结果会是像这样子[“red”, “red”] [“green”, “green”] [“blue”, “blue”],包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p>weakSet和WeakMap的道理也差不多,WeakSet的成员只能是对象，而不能是其他类型的值.WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用<br>WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ws = new WeakSet();</span><br><span class=\"line\">var obj = &#123;&#125;;</span><br><span class=\"line\">var foo = &#123;&#125;;</span><br><span class=\"line\">ws.add(obj);</span><br><span class=\"line\">ws.has(foo);    // false</span><br><span class=\"line\">WeakSet没有size属性，没有办法遍历它的成员。</span><br><span class=\"line\">ws.size // undefined</span><br><span class=\"line\">ws.forEach // undefined</span><br><span class=\"line\">ws.forEach(function(item)&#123; console.log(&apos;WeakSet has &apos; + item)&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// TypeError: undefined is not a function</span><br></pre></td></tr></table></figure>\n<h2 id=\"Generator-Promise-Symbol\"><a href=\"#Generator-Promise-Symbol\" class=\"headerlink\" title=\"Generator Promise Symbol\"></a>Generator Promise Symbol</h2><h3 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h3><p>Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。</p>\n<p>执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* helloWorldGenerator() &#123;</span><br><span class=\"line\">  yield &apos;hello&apos;;</span><br><span class=\"line\">  yield &apos;world&apos;;</span><br><span class=\"line\">  return &apos;ending&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var hw = helloWorldGenerator();</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &apos;hello&apos;, done: false &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &apos;world&apos;, done: false &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &apos;ending&apos;, done: true &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>\n<p><code>yield</code> 意为’产出’ 是用来定义不同的内部状态,调用next()方法的时候会返回Generator的下一个状态,直到return为止,输出的done中的值表示Generator函数是否已经执行结束.</p>\n<p><code>yield *</code> 语句 : 用来在一个Generator中执行另外一个Generator函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* anotherGenerator(i) &#123;</span><br><span class=\"line\">  yield i + 1;</span><br><span class=\"line\">  yield i + 2;</span><br><span class=\"line\">  yield i + 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function* generator(i)&#123;</span><br><span class=\"line\">  yield i;</span><br><span class=\"line\">  yield* anotherGenerator(i);</span><br><span class=\"line\">  yield i + 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var gen = generator(10);</span><br><span class=\"line\">console.log(gen.next().value); // 10</span><br><span class=\"line\">console.log(gen.next().value); // 11</span><br><span class=\"line\">console.log(gen.next().value); // 12</span><br><span class=\"line\">console.log(gen.next().value); // 13</span><br><span class=\"line\">console.log(gen.next().value); // 20</span><br></pre></td></tr></table></figure>\n<p>运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。</p>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>Promise 是一个构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var promise = new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">  // ... some code</span><br><span class=\"line\">  if (/* 异步操作成功 */)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Promise函数自带两个参数: <code>resolve</code>意为返回一个成功的回调,<code>reject</code>意为返回一个错误的回调<br>然后订阅回调的方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(function(value) &#123;</span><br><span class=\"line\">  // success</span><br><span class=\"line\">&#125;, function(value) &#123;</span><br><span class=\"line\">  // failure</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>PS: 这个函数很像OC的block方法,上面的函数就类似OC的如下写法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)promise:(void(^)(id success))resolve failure:(void(^)(id failure))reject &#123;</span><br><span class=\"line\">\tif(...)&#123;</span><br><span class=\"line\">\t\tresolve(resolveValue);</span><br><span class=\"line\">\t&#125;else &#123;</span><br><span class=\"line\">\t\treject(rejectValue);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">//订阅</span><br><span class=\"line\">[self promise:^(id success)&#123;</span><br><span class=\"line\">\tNSLog(success);</span><br><span class=\"line\">&#125; failure:^(id failure)&#123;</span><br><span class=\"line\">\tNSLog(failure);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">// 纯脑补,也不知道有没有写对</span><br></pre></td></tr></table></figure>\n<h4 id=\"catch-方法\"><a href=\"#catch-方法\" class=\"headerlink\" title=\"catch() 方法\"></a>catch() 方法</h4><p>专门用来捕获异常的回调,会捕获到<code>then()</code>的第二个参数的回调</p>\n<p>如果在<code>then()</code>中使用了throw xxx;语句,那么也会走<code>catch()</code>回调</p>\n<p><code>catch()</code>和<code>then()</code>方法都会返回Promise对象,所以可以链式调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(function(value) &#123;</span><br><span class=\"line\">    console.log(value);      </span><br><span class=\"line\">&#125;,null).catch(function(value)&#123;</span><br><span class=\"line\">\tconsole.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>OR</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p1.then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); // &quot;成功!&quot;</span><br><span class=\"line\">  throw &quot;哦，不!&quot;;</span><br><span class=\"line\">&#125;).catch(function(e) &#123;</span><br><span class=\"line\">  console.log(e); // &quot;哦，不!&quot;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>你还可以<code>then()</code>完再<code>then()</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p2 = new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">  resolve(1);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p2.then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); // 1</span><br><span class=\"line\">  return value + 1;</span><br><span class=\"line\">&#125;).then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); // 2</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"all-方法\"><a href=\"#all-方法\" class=\"headerlink\" title=\"all() 方法\"></a>all() 方法</h4><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p = Promise.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>\n<p>只要有一个reject了,那么p就会抛出失败的回调,只有全部都resolve了,才会抛出成功的回调</p>\n<h4 id=\"race-方法\"><a href=\"#race-方法\" class=\"headerlink\" title=\"race() 方法\"></a>race() 方法</h4><p>顾名思义 赛跑</p>\n<p>同样是来绑定多个Promise实例,不同的是谁先返回就走谁的回调,如果p1五秒后发失败回调,p2一秒后发成功回调,那么Promise.race([p1, p2])就等于p2.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.race([p1, p2]).then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); // &quot;two&quot;</span><br><span class=\"line\">  // Both resolve, but p2 is faster</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h3><p>符号</p>\n<p>用Symbol生成的对象,绝对不会重复!!!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1 = Symbol(&quot;foo&quot;);</span><br><span class=\"line\">var s2 = Symbol(&quot;foo&quot;);</span><br><span class=\"line\">console.log(s1 === s2); // false</span><br><span class=\"line\">getOwnPropertySymbols()</span><br></pre></td></tr></table></figure>\n<p>这个方法可以获得对象的所有Symbol类型的成员属性名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;&#125;;</span><br><span class=\"line\">var a = Symbol(&apos;a&apos;);</span><br><span class=\"line\">var b = Symbol(&apos;b&apos;);</span><br><span class=\"line\"> </span><br><span class=\"line\">obj[a] = &apos;Hello&apos;;</span><br><span class=\"line\">obj[b] = &apos;World&apos;;</span><br><span class=\"line\">var objectSymbols = Object.getOwnPropertySymbols(obj);</span><br><span class=\"line\">console.log(objectSymbols);</span><br><span class=\"line\">// [Symbol(a), Symbol(b)]</span><br></pre></td></tr></table></figure>\n<h4 id=\"Symbol-for\"><a href=\"#Symbol-for\" class=\"headerlink\" title=\"Symbol.for()\"></a>Symbol.for()</h4><p>这个方法用来搜索之前有没有定义过某个Symbol名,如果有的话就返回值没有的话就就新建一个Symbol,有种取缓存的感觉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1 = Symbol.for(&apos;foo&apos;); // 定义一下</span><br><span class=\"line\">var s2 = Symbol.for(&apos;foo&apos;); // 取出之前定义的值</span><br><span class=\"line\">console.log(s1 === s2); // true</span><br><span class=\"line\">Symbol.keyFor()</span><br><span class=\"line\">跟上面的是相反的,通过值来取键</span><br><span class=\"line\"></span><br><span class=\"line\">var s1 = Symbol.for(&quot;foo&quot;);</span><br><span class=\"line\">Symbol.keyFor(s1) // &quot;foo&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">var s2 = Symbol(&quot;foo&quot;);</span><br><span class=\"line\">Symbol.keyFor(s2) // undefined</span><br></pre></td></tr></table></figure>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>其实就是简写方法而已</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var  f = function(v1,v2) &#123;</span><br><span class=\"line\">\treturn v1+v2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f = (v1,v2) =&gt; v1+v2;</span><br></pre></td></tr></table></figure>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。<br>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。<br>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用<code>Rest</code>参数代替。<br>不可以使用<code>yield</code>命令，因此箭头函数不能用作Generator函数。</p>\n<h2 id=\"网络请求\"><a href=\"#网络请求\" class=\"headerlink\" title=\"网络请求\"></a>网络请求</h2><h3 id=\"方式一-使用-http-request\"><a href=\"#方式一-使用-http-request\" class=\"headerlink\" title=\"方式一 使用 http.request()\"></a>方式一 使用 http.request()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var http = require(&apos;http&apos;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">var qs = require(&apos;querystring&apos;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">var data = &#123;  </span><br><span class=\"line\">    a: 123,  </span><br><span class=\"line\">    time: new Date().getTime()&#125;;//这是需要提交的数据  </span><br><span class=\"line\">    </span><br><span class=\"line\">var content = qs.stringify(data);   </span><br><span class=\"line\">var options = &#123;  </span><br><span class=\"line\">    hostname: &apos;127.0.0.1&apos;,  </span><br><span class=\"line\">    port: 10086,  </span><br><span class=\"line\">    path: &apos;/pay/pay_callback?&apos; + content,  </span><br><span class=\"line\">    method: &apos;GET&apos;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">var req = http.request(options, function (res) &#123;  </span><br><span class=\"line\">    console.log(&apos;STATUS: &apos; + res.statusCode);  </span><br><span class=\"line\">    console.log(&apos;HEADERS: &apos; + JSON.stringify(res.headers));  </span><br><span class=\"line\">    res.setEncoding(&apos;utf8&apos;);  </span><br><span class=\"line\">    res.on(&apos;data&apos;, function (chunk) &#123;  </span><br><span class=\"line\">        console.log(&apos;BODY: &apos; + chunk);  </span><br><span class=\"line\">    &#125;);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">req.on(&apos;error&apos;, function (e) &#123;  </span><br><span class=\"line\">    console.log(&apos;problem with request: &apos; + e.message);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">req.end();</span><br></pre></td></tr></table></figure>\n<h3 id=\"方式二-使用-http-get-发送GET请求\"><a href=\"#方式二-使用-http-get-发送GET请求\" class=\"headerlink\" title=\"方式二 使用 http.get() 发送GET请求\"></a>方式二 使用 http.get() 发送GET请求</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var httpRequest = http.get(&apos;http://localhost:8088/tempFile/LocalData.json&apos;,function(request,response)&#123;</span><br><span class=\"line\">      var html=&apos;&apos;;</span><br><span class=\"line\">      request.on(&apos;data&apos;,function(data)&#123;</span><br><span class=\"line\">        \thtml+=data;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      request.on(&apos;end&apos;,function()&#123;</span><br><span class=\"line\">\t\t\tconsole.log(html);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>学习资料来自:<a href=\"http://www.hubwiz.com\" target=\"_blank\" rel=\"noopener\">http://www.hubwiz.com</a> 等</p>\n</blockquote>"},{"title":"ReactNative ListView flexWrap不起作用解决办法","author":"Arclin","abbrlink":"11785d19","date":"2017-03-01T16:00:00.000Z","_content":"`flexWrap:’wrap’ `作用是让超出页面的元素进行换行显示,但是在RN 0.28之后就发生了改变\n\n<!-- more -->\n\n|RN0.28之前|RN0.28之后|\n|----|----|\n|contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems: ‘stretch’,<br/>// 屏幕宽度<br/>width:width,<br/>},|contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems:’flex-start’,<br/>// 屏幕宽度<br/> width:width,<br/>},|\n\n`alignItems: ‘stretch’` 变成了 `alignItems:’flex-start’`,\n\n但是现在的教程基本上不会加上`alignItems`…只有一个`flexWrap`,但是放到现在就实现不了了","source":"_posts/ReactNative-ListView-flexWrap不起作用解决办法.md","raw":"---\ntitle: ReactNative ListView flexWrap不起作用解决办法\nauthor: Arclin\ntags:\n  - React Native\ncategories: []\nabbrlink: 11785d19\ndate: 2017-03-02 00:00:00\n---\n`flexWrap:’wrap’ `作用是让超出页面的元素进行换行显示,但是在RN 0.28之后就发生了改变\n\n<!-- more -->\n\n|RN0.28之前|RN0.28之后|\n|----|----|\n|contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems: ‘stretch’,<br/>// 屏幕宽度<br/>width:width,<br/>},|contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems:’flex-start’,<br/>// 屏幕宽度<br/> width:width,<br/>},|\n\n`alignItems: ‘stretch’` 变成了 `alignItems:’flex-start’`,\n\n但是现在的教程基本上不会加上`alignItems`…只有一个`flexWrap`,但是放到现在就实现不了了","slug":"ReactNative-ListView-flexWrap不起作用解决办法","published":1,"updated":"2018-05-10T06:51:35.735Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbciq0019ldxuvrrqhe5o","content":"<p><code>flexWrap:’wrap’</code>作用是让超出页面的元素进行换行显示,但是在RN 0.28之后就发生了改变</p>\n<a id=\"more\"></a>\n<table>\n<thead>\n<tr>\n<th>RN0.28之前</th>\n<th>RN0.28之后</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>contentViewStyle:<br>{<br>flexDirection:’row’,<br>flexWrap:’wrap’,<br>alignItems: ‘stretch’,<br>// 屏幕宽度<br>width:width,<br>},</td>\n<td>contentViewStyle:<br>{<br>flexDirection:’row’,<br>flexWrap:’wrap’,<br>alignItems:’flex-start’,<br>// 屏幕宽度<br> width:width,<br>},</td>\n</tr>\n</tbody>\n</table>\n<p><code>alignItems: ‘stretch’</code> 变成了 <code>alignItems:’flex-start’</code>,</p>\n<p>但是现在的教程基本上不会加上<code>alignItems</code>…只有一个<code>flexWrap</code>,但是放到现在就实现不了了</p>\n","site":{"data":{}},"excerpt":"<p><code>flexWrap:’wrap’</code>作用是让超出页面的元素进行换行显示,但是在RN 0.28之后就发生了改变</p>","more":"<table>\n<thead>\n<tr>\n<th>RN0.28之前</th>\n<th>RN0.28之后</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>contentViewStyle:<br>{<br>flexDirection:’row’,<br>flexWrap:’wrap’,<br>alignItems: ‘stretch’,<br>// 屏幕宽度<br>width:width,<br>},</td>\n<td>contentViewStyle:<br>{<br>flexDirection:’row’,<br>flexWrap:’wrap’,<br>alignItems:’flex-start’,<br>// 屏幕宽度<br> width:width,<br>},</td>\n</tr>\n</tbody>\n</table>\n<p><code>alignItems: ‘stretch’</code> 变成了 <code>alignItems:’flex-start’</code>,</p>\n<p>但是现在的教程基本上不会加上<code>alignItems</code>…只有一个<code>flexWrap</code>,但是放到现在就实现不了了</p>"},{"title":"ReactNative与iOS原生代码之间传值","author":"Arclin","abbrlink":"a8a5ff12","date":"2017-02-25T16:00:00.000Z","_content":"本文包含两部分:\n\n- 原生传值到RN\n- RN传值到原生\n\n<!-- more -->\n\n### 原生传值到RN\n\n加载`RCTRootView`的时候在`initialProperties`内传值\n\n```\nNSDictionary *params = @{@\"image\":@\"https://dn-coding-net-production-static.qbox.me/ac823dee-6303-4745-9216-711ab4d83753.png?imageMogr2/auto-orient/format/png/crop/!651x651a0a0\"};\n\nRCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\n                                                         moduleName:@\"Test\"\n                                                  initialProperties:params\n                                                      launchOptions:nil];\n```\n\n发送的值可以在`this.props`内得到,像上面的例子就是`this.props.image`\n\n```\n<View style={[styles.tabContent,{backgroundColor:color}]}>\n            <Text style={styles.tabText}>{pageText}</Text>\n            <Text style={styles.tabText}>第{num}次重复渲染{pageText}</Text>\n            <Text stype={styles.tabText}>{this._renderImage(this.props.image)}</Text>\n</View>\n```\n\n### RN传值到原生\n\n原生代码实现协议`RCTBridgeModule`,如下\n\n```\n#import <React/RCTBridgeModule.h>\n\n@interface ReactViewController : UIViewController<RCTBridgeModule>\n\n@end\n```\n\n添加方法,下面代码中的`testPassValue`给这个Controller声明一个`testPassValue`方法,在RN中可以调用这个方法\n\n```\n// 导出模块\nRCT_EXPORT_MODULE(); // 此处不添加参数默认为这个类的类名\n\nRCT_EXPORT_METHOD(testPassValue:(NSString *)value)\n{\n    NSLog(@\"%@\",value);\n}\n```\n\nRN中调用原生的`testPassValue`方法\n\n```\nimport {\n    NativeModules,\n} from 'react-native';\n\nvar ReactViewController = NativeModules.ReactViewController;\n\n//方法调用\nReactViewController.testPassValue('I pass this value to controller');\n```\n\n注意: RN调用原生方法的时候,如果涉及到UI操作,记得使用`dispatch_async(dispatch_get_main_queue(), ^{});`拉回主线程,另外在被调用方法中调用的self的地址和真正的这个controller的地址是不一样的,所以在进入RN的controller的时候要把self保存起来,比如另外创建一个单例之类的,然后RN回调原生的时候取出控制器对象才可使用.\n\n类似下面这个例子是pop掉RN所在的控制器\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 保存到单例\n    [RNSingleton sharedInstance].rnvc = self;\n    \n    // Do any additional setup after loading the view.\n    self.navigationController.navigationBarHidden = YES;\n    NSString * strUrl = @\"http://localhost:8081/index.ios.bundle?platform=ios&dev=true\";\n    NSURL * jsCodeLocation = [NSURL URLWithString:strUrl];\n    \n    RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\n                                                         moduleName:@\"Test\"\n                                                  initialProperties:self.params\n                                                      launchOptions:nil];\n    self.view = rootView;\n}\n\n// 导出模块\nRCT_EXPORT_MODULE(); // 此处不添加参数默认为这个类的类名\n\nRCT_EXPORT_METHOD(testPassValue:(NSString *)value)\n{\n    NSLog(@\"%@\",value);\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [[RNSingleton sharedInstance].rnvc.navigationController popViewControllerAnimated:YES];\n    });\n}\n\n```","source":"_posts/ReactNative与iOS原生代码之间传值.md","raw":"---\ntitle: ReactNative与iOS原生代码之间传值\nauthor: Arclin\ntags:\n  - React Native\ncategories:\n  - React Native\nabbrlink: a8a5ff12\ndate: 2017-02-26 00:00:00\n---\n本文包含两部分:\n\n- 原生传值到RN\n- RN传值到原生\n\n<!-- more -->\n\n### 原生传值到RN\n\n加载`RCTRootView`的时候在`initialProperties`内传值\n\n```\nNSDictionary *params = @{@\"image\":@\"https://dn-coding-net-production-static.qbox.me/ac823dee-6303-4745-9216-711ab4d83753.png?imageMogr2/auto-orient/format/png/crop/!651x651a0a0\"};\n\nRCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\n                                                         moduleName:@\"Test\"\n                                                  initialProperties:params\n                                                      launchOptions:nil];\n```\n\n发送的值可以在`this.props`内得到,像上面的例子就是`this.props.image`\n\n```\n<View style={[styles.tabContent,{backgroundColor:color}]}>\n            <Text style={styles.tabText}>{pageText}</Text>\n            <Text style={styles.tabText}>第{num}次重复渲染{pageText}</Text>\n            <Text stype={styles.tabText}>{this._renderImage(this.props.image)}</Text>\n</View>\n```\n\n### RN传值到原生\n\n原生代码实现协议`RCTBridgeModule`,如下\n\n```\n#import <React/RCTBridgeModule.h>\n\n@interface ReactViewController : UIViewController<RCTBridgeModule>\n\n@end\n```\n\n添加方法,下面代码中的`testPassValue`给这个Controller声明一个`testPassValue`方法,在RN中可以调用这个方法\n\n```\n// 导出模块\nRCT_EXPORT_MODULE(); // 此处不添加参数默认为这个类的类名\n\nRCT_EXPORT_METHOD(testPassValue:(NSString *)value)\n{\n    NSLog(@\"%@\",value);\n}\n```\n\nRN中调用原生的`testPassValue`方法\n\n```\nimport {\n    NativeModules,\n} from 'react-native';\n\nvar ReactViewController = NativeModules.ReactViewController;\n\n//方法调用\nReactViewController.testPassValue('I pass this value to controller');\n```\n\n注意: RN调用原生方法的时候,如果涉及到UI操作,记得使用`dispatch_async(dispatch_get_main_queue(), ^{});`拉回主线程,另外在被调用方法中调用的self的地址和真正的这个controller的地址是不一样的,所以在进入RN的controller的时候要把self保存起来,比如另外创建一个单例之类的,然后RN回调原生的时候取出控制器对象才可使用.\n\n类似下面这个例子是pop掉RN所在的控制器\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 保存到单例\n    [RNSingleton sharedInstance].rnvc = self;\n    \n    // Do any additional setup after loading the view.\n    self.navigationController.navigationBarHidden = YES;\n    NSString * strUrl = @\"http://localhost:8081/index.ios.bundle?platform=ios&dev=true\";\n    NSURL * jsCodeLocation = [NSURL URLWithString:strUrl];\n    \n    RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\n                                                         moduleName:@\"Test\"\n                                                  initialProperties:self.params\n                                                      launchOptions:nil];\n    self.view = rootView;\n}\n\n// 导出模块\nRCT_EXPORT_MODULE(); // 此处不添加参数默认为这个类的类名\n\nRCT_EXPORT_METHOD(testPassValue:(NSString *)value)\n{\n    NSLog(@\"%@\",value);\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [[RNSingleton sharedInstance].rnvc.navigationController popViewControllerAnimated:YES];\n    });\n}\n\n```","slug":"ReactNative与iOS原生代码之间传值","published":1,"updated":"2018-05-10T06:51:35.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcit001eldxujuhlay1r","content":"<p>本文包含两部分:</p>\n<ul>\n<li>原生传值到RN</li>\n<li>RN传值到原生</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"原生传值到RN\"><a href=\"#原生传值到RN\" class=\"headerlink\" title=\"原生传值到RN\"></a>原生传值到RN</h3><p>加载<code>RCTRootView</code>的时候在<code>initialProperties</code>内传值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSDictionary *params = @&#123;@&quot;image&quot;:@&quot;https://dn-coding-net-production-static.qbox.me/ac823dee-6303-4745-9216-711ab4d83753.png?imageMogr2/auto-orient/format/png/crop/!651x651a0a0&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class=\"line\">                                                         moduleName:@&quot;Test&quot;</span><br><span class=\"line\">                                                  initialProperties:params</span><br><span class=\"line\">                                                      launchOptions:nil];</span><br></pre></td></tr></table></figure>\n<p>发送的值可以在<code>this.props</code>内得到,像上面的例子就是<code>this.props.image</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;View style=&#123;[styles.tabContent,&#123;backgroundColor:color&#125;]&#125;&gt;</span><br><span class=\"line\">            &lt;Text style=&#123;styles.tabText&#125;&gt;&#123;pageText&#125;&lt;/Text&gt;</span><br><span class=\"line\">            &lt;Text style=&#123;styles.tabText&#125;&gt;第&#123;num&#125;次重复渲染&#123;pageText&#125;&lt;/Text&gt;</span><br><span class=\"line\">            &lt;Text stype=&#123;styles.tabText&#125;&gt;&#123;this._renderImage(this.props.image)&#125;&lt;/Text&gt;</span><br><span class=\"line\">&lt;/View&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"RN传值到原生\"><a href=\"#RN传值到原生\" class=\"headerlink\" title=\"RN传值到原生\"></a>RN传值到原生</h3><p>原生代码实现协议<code>RCTBridgeModule</code>,如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface ReactViewController : UIViewController&lt;RCTBridgeModule&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>添加方法,下面代码中的<code>testPassValue</code>给这个Controller声明一个<code>testPassValue</code>方法,在RN中可以调用这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 导出模块</span><br><span class=\"line\">RCT_EXPORT_MODULE(); // 此处不添加参数默认为这个类的类名</span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_METHOD(testPassValue:(NSString *)value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RN中调用原生的<code>testPassValue</code>方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;</span><br><span class=\"line\">    NativeModules,</span><br><span class=\"line\">&#125; from &apos;react-native&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var ReactViewController = NativeModules.ReactViewController;</span><br><span class=\"line\"></span><br><span class=\"line\">//方法调用</span><br><span class=\"line\">ReactViewController.testPassValue(&apos;I pass this value to controller&apos;);</span><br></pre></td></tr></table></figure>\n<p>注意: RN调用原生方法的时候,如果涉及到UI操作,记得使用<code>dispatch_async(dispatch_get_main_queue(), ^{});</code>拉回主线程,另外在被调用方法中调用的self的地址和真正的这个controller的地址是不一样的,所以在进入RN的controller的时候要把self保存起来,比如另外创建一个单例之类的,然后RN回调原生的时候取出控制器对象才可使用.</p>\n<p>类似下面这个例子是pop掉RN所在的控制器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 保存到单例</span><br><span class=\"line\">    [RNSingleton sharedInstance].rnvc = self;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Do any additional setup after loading the view.</span><br><span class=\"line\">    self.navigationController.navigationBarHidden = YES;</span><br><span class=\"line\">    NSString * strUrl = @&quot;http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;;</span><br><span class=\"line\">    NSURL * jsCodeLocation = [NSURL URLWithString:strUrl];</span><br><span class=\"line\">    </span><br><span class=\"line\">    RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class=\"line\">                                                         moduleName:@&quot;Test&quot;</span><br><span class=\"line\">                                                  initialProperties:self.params</span><br><span class=\"line\">                                                      launchOptions:nil];</span><br><span class=\"line\">    self.view = rootView;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 导出模块</span><br><span class=\"line\">RCT_EXPORT_MODULE(); // 此处不添加参数默认为这个类的类名</span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_METHOD(testPassValue:(NSString *)value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,value);</span><br><span class=\"line\">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        [[RNSingleton sharedInstance].rnvc.navigationController popViewControllerAnimated:YES];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>本文包含两部分:</p>\n<ul>\n<li>原生传值到RN</li>\n<li>RN传值到原生</li>\n</ul>","more":"<h3 id=\"原生传值到RN\"><a href=\"#原生传值到RN\" class=\"headerlink\" title=\"原生传值到RN\"></a>原生传值到RN</h3><p>加载<code>RCTRootView</code>的时候在<code>initialProperties</code>内传值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSDictionary *params = @&#123;@&quot;image&quot;:@&quot;https://dn-coding-net-production-static.qbox.me/ac823dee-6303-4745-9216-711ab4d83753.png?imageMogr2/auto-orient/format/png/crop/!651x651a0a0&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class=\"line\">                                                         moduleName:@&quot;Test&quot;</span><br><span class=\"line\">                                                  initialProperties:params</span><br><span class=\"line\">                                                      launchOptions:nil];</span><br></pre></td></tr></table></figure>\n<p>发送的值可以在<code>this.props</code>内得到,像上面的例子就是<code>this.props.image</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;View style=&#123;[styles.tabContent,&#123;backgroundColor:color&#125;]&#125;&gt;</span><br><span class=\"line\">            &lt;Text style=&#123;styles.tabText&#125;&gt;&#123;pageText&#125;&lt;/Text&gt;</span><br><span class=\"line\">            &lt;Text style=&#123;styles.tabText&#125;&gt;第&#123;num&#125;次重复渲染&#123;pageText&#125;&lt;/Text&gt;</span><br><span class=\"line\">            &lt;Text stype=&#123;styles.tabText&#125;&gt;&#123;this._renderImage(this.props.image)&#125;&lt;/Text&gt;</span><br><span class=\"line\">&lt;/View&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"RN传值到原生\"><a href=\"#RN传值到原生\" class=\"headerlink\" title=\"RN传值到原生\"></a>RN传值到原生</h3><p>原生代码实现协议<code>RCTBridgeModule</code>,如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;React/RCTBridgeModule.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface ReactViewController : UIViewController&lt;RCTBridgeModule&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>添加方法,下面代码中的<code>testPassValue</code>给这个Controller声明一个<code>testPassValue</code>方法,在RN中可以调用这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 导出模块</span><br><span class=\"line\">RCT_EXPORT_MODULE(); // 此处不添加参数默认为这个类的类名</span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_METHOD(testPassValue:(NSString *)value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RN中调用原生的<code>testPassValue</code>方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;</span><br><span class=\"line\">    NativeModules,</span><br><span class=\"line\">&#125; from &apos;react-native&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">var ReactViewController = NativeModules.ReactViewController;</span><br><span class=\"line\"></span><br><span class=\"line\">//方法调用</span><br><span class=\"line\">ReactViewController.testPassValue(&apos;I pass this value to controller&apos;);</span><br></pre></td></tr></table></figure>\n<p>注意: RN调用原生方法的时候,如果涉及到UI操作,记得使用<code>dispatch_async(dispatch_get_main_queue(), ^{});</code>拉回主线程,另外在被调用方法中调用的self的地址和真正的这个controller的地址是不一样的,所以在进入RN的controller的时候要把self保存起来,比如另外创建一个单例之类的,然后RN回调原生的时候取出控制器对象才可使用.</p>\n<p>类似下面这个例子是pop掉RN所在的控制器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 保存到单例</span><br><span class=\"line\">    [RNSingleton sharedInstance].rnvc = self;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Do any additional setup after loading the view.</span><br><span class=\"line\">    self.navigationController.navigationBarHidden = YES;</span><br><span class=\"line\">    NSString * strUrl = @&quot;http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=true&quot;;</span><br><span class=\"line\">    NSURL * jsCodeLocation = [NSURL URLWithString:strUrl];</span><br><span class=\"line\">    </span><br><span class=\"line\">    RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class=\"line\">                                                         moduleName:@&quot;Test&quot;</span><br><span class=\"line\">                                                  initialProperties:self.params</span><br><span class=\"line\">                                                      launchOptions:nil];</span><br><span class=\"line\">    self.view = rootView;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 导出模块</span><br><span class=\"line\">RCT_EXPORT_MODULE(); // 此处不添加参数默认为这个类的类名</span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_METHOD(testPassValue:(NSString *)value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,value);</span><br><span class=\"line\">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        [[RNSingleton sharedInstance].rnvc.navigationController popViewControllerAnimated:YES];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"RAC关于cell上的按钮点击后会重复发送信号的问题","author":"Arclin","abbrlink":"452efb32","date":"2016-10-16T16:00:00.000Z","_content":"关于cell上的按钮点击后会重复发送信号的问题\n\nRAC给`UITableViewCell`提供了一个方法：`rac_prepareForReuseSignal`，它的作用是当Cell即将要被重用时，告诉Cell。想象Cell上有多个button，Cell在初始化时给每个button都`addTarget:action:forControlEvents`，被重用时需要先移除这些target，下面这段代码就可以很方便地解决这个问题：\n\n```\n[[[self.cancelButton\n    rac_signalForControlEvents:UIControlEventTouchUpInside]\n    takeUntil:self.rac_prepareForReuseSignal]\n    subscribeNext:^(UIButton *x) {\n    // do other things\n}];\n```","source":"_posts/RAC关于cell上的按钮点击后会重复发送信号的问题.md","raw":"---\ntitle: RAC关于cell上的按钮点击后会重复发送信号的问题\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 452efb32\ndate: 2016-10-17 00:00:00\n---\n关于cell上的按钮点击后会重复发送信号的问题\n\nRAC给`UITableViewCell`提供了一个方法：`rac_prepareForReuseSignal`，它的作用是当Cell即将要被重用时，告诉Cell。想象Cell上有多个button，Cell在初始化时给每个button都`addTarget:action:forControlEvents`，被重用时需要先移除这些target，下面这段代码就可以很方便地解决这个问题：\n\n```\n[[[self.cancelButton\n    rac_signalForControlEvents:UIControlEventTouchUpInside]\n    takeUntil:self.rac_prepareForReuseSignal]\n    subscribeNext:^(UIButton *x) {\n    // do other things\n}];\n```","slug":"RAC关于cell上的按钮点击后会重复发送信号的问题","published":1,"updated":"2018-05-10T06:51:35.733Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbciv001hldxujx6t4q8h","content":"<p>关于cell上的按钮点击后会重复发送信号的问题</p>\n<p>RAC给<code>UITableViewCell</code>提供了一个方法：<code>rac_prepareForReuseSignal</code>，它的作用是当Cell即将要被重用时，告诉Cell。想象Cell上有多个button，Cell在初始化时给每个button都<code>addTarget:action:forControlEvents</code>，被重用时需要先移除这些target，下面这段代码就可以很方便地解决这个问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[[self.cancelButton</span><br><span class=\"line\">    rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class=\"line\">    takeUntil:self.rac_prepareForReuseSignal]</span><br><span class=\"line\">    subscribeNext:^(UIButton *x) &#123;</span><br><span class=\"line\">    // do other things</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>关于cell上的按钮点击后会重复发送信号的问题</p>\n<p>RAC给<code>UITableViewCell</code>提供了一个方法：<code>rac_prepareForReuseSignal</code>，它的作用是当Cell即将要被重用时，告诉Cell。想象Cell上有多个button，Cell在初始化时给每个button都<code>addTarget:action:forControlEvents</code>，被重用时需要先移除这些target，下面这段代码就可以很方便地解决这个问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[[self.cancelButton</span><br><span class=\"line\">    rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class=\"line\">    takeUntil:self.rac_prepareForReuseSignal]</span><br><span class=\"line\">    subscribeNext:^(UIButton *x) &#123;</span><br><span class=\"line\">    // do other things</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>"},{"title":"Salesforce SDK Bug","author":"Arclin","abbrlink":"e88dc875","date":"2018-02-18T13:59:00.000Z","_content":"Salesforce SDK 有几个bug 不修复的话跑不起来 所以在这里记录一下\n\n<!-- more -->\n\n1. `SFOAuthCoordinator` 960行 \n\n```\n   if ([self isRedirectURL:requestUrl]) {\n        [self handleUserAgentResponse:url];\n        decisionHandler(WKNavigationActionPolicyCancel);\n        return;\n    }\n```\n\n2. `SFSDKLoginHostListViewController` `viewDidLoad`最下面的注册cell移动到`viewDidLoad`的第一行\n","source":"_posts/Salesforce-SDK-Bug.md","raw":"---\ntitle: Salesforce SDK Bug\nauthor: Arclin\ntags:\n  - Salesforce\ncategories:\n  - iOS\nabbrlink: e88dc875\ndate: 2018-02-18 21:59:00\n---\nSalesforce SDK 有几个bug 不修复的话跑不起来 所以在这里记录一下\n\n<!-- more -->\n\n1. `SFOAuthCoordinator` 960行 \n\n```\n   if ([self isRedirectURL:requestUrl]) {\n        [self handleUserAgentResponse:url];\n        decisionHandler(WKNavigationActionPolicyCancel);\n        return;\n    }\n```\n\n2. `SFSDKLoginHostListViewController` `viewDidLoad`最下面的注册cell移动到`viewDidLoad`的第一行\n","slug":"Salesforce-SDK-Bug","published":1,"updated":"2018-05-10T06:51:35.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbciz001lldxur07piv6v","content":"<p>Salesforce SDK 有几个bug 不修复的话跑不起来 所以在这里记录一下</p>\n<a id=\"more\"></a>\n<ol>\n<li><code>SFOAuthCoordinator</code> 960行 </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ([self isRedirectURL:requestUrl]) &#123;</span><br><span class=\"line\">     [self handleUserAgentResponse:url];</span><br><span class=\"line\">     decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class=\"line\">     return;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>SFSDKLoginHostListViewController</code> <code>viewDidLoad</code>最下面的注册cell移动到<code>viewDidLoad</code>的第一行</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Salesforce SDK 有几个bug 不修复的话跑不起来 所以在这里记录一下</p>","more":"<ol>\n<li><code>SFOAuthCoordinator</code> 960行 </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ([self isRedirectURL:requestUrl]) &#123;</span><br><span class=\"line\">     [self handleUserAgentResponse:url];</span><br><span class=\"line\">     decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class=\"line\">     return;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>SFSDKLoginHostListViewController</code> <code>viewDidLoad</code>最下面的注册cell移动到<code>viewDidLoad</code>的第一行</li>\n</ol>"},{"title":"ReactNative网络请求","author":"Arclin","abbrlink":"b6bd206a","date":"2017-03-14T16:00:00.000Z","_content":"关于React Native 的网络请求的总结\n\n<!-- more -->\n\n因为这里使用的是`fetch()`方法,返回的是一个`Promise`对象,所以可以使用`then()`和`catch()`方法进行链式调用,也可以用`all()`,`race()` 去包装多个请求\n\n具体的话可以看这里\n\n### GET\n```\nfetch(\"http://localhost:3000/get\")\n\t.then((response) => response.json()) // 这里取出响应体的JSON数据并返回\n\t.then((responseJSON) => { // 处理上面返回的JSON数据\n\t\t// do something\n\t\t\n\t})\n\t.catch((err) => { // 捕获错误\n\t\t// catch err\n\t});\n```\n### POST\n网上说有两种,不过我一般用第二种比较多\n\n#### application/json\n```\nvar fetchOptions = {\n           method: 'POST',\n           headers: {\n               'Accept': 'application/json',\n               //json形式\n               'Content-Type': 'application/json'\n           },\n           body:JSON.stringify('data=test') // 这里是请求参数,键值对形式\n       };\n\nfetch(\"http://localhost:3000/post\", fetchOptions)\n   .then((response) => response.json())\n   .then((responseText) => {\n        console.log(responseText);\n   });\n```\n\n#### application/x-www-form-urlencoded\n\n```\n var fetchOptions = {\n           method: 'POST',\n           headers: {\n               'Accept': 'application/json',\n               //表单\n               'Content-Type': 'application/x-www-form-urlencoded'\n           },\n           body:'data=test' // 这里是请求参数,键值对形式\n       };\n\nfetch(\"http://localhost:3000/post\", fetchOptions)\n   .then((response) => response.json())\n   .then((responseText) => {\n        console.log(responseText);\n   });\n```\n如果使用的是Restful的API的话,那么只要把上面`fetchOption`里面的`method`改成对应的方法就好.\n\n当然,封装一个网络请求工具是有必要的,等我有时间写一下.","source":"_posts/ReactNative网络请求.md","raw":"---\ntitle: ReactNative网络请求\nauthor: Arclin\ntags:\n  - React Native\ncategories:\n  - React Native\nabbrlink: b6bd206a\ndate: 2017-03-15 00:00:00\n---\n关于React Native 的网络请求的总结\n\n<!-- more -->\n\n因为这里使用的是`fetch()`方法,返回的是一个`Promise`对象,所以可以使用`then()`和`catch()`方法进行链式调用,也可以用`all()`,`race()` 去包装多个请求\n\n具体的话可以看这里\n\n### GET\n```\nfetch(\"http://localhost:3000/get\")\n\t.then((response) => response.json()) // 这里取出响应体的JSON数据并返回\n\t.then((responseJSON) => { // 处理上面返回的JSON数据\n\t\t// do something\n\t\t\n\t})\n\t.catch((err) => { // 捕获错误\n\t\t// catch err\n\t});\n```\n### POST\n网上说有两种,不过我一般用第二种比较多\n\n#### application/json\n```\nvar fetchOptions = {\n           method: 'POST',\n           headers: {\n               'Accept': 'application/json',\n               //json形式\n               'Content-Type': 'application/json'\n           },\n           body:JSON.stringify('data=test') // 这里是请求参数,键值对形式\n       };\n\nfetch(\"http://localhost:3000/post\", fetchOptions)\n   .then((response) => response.json())\n   .then((responseText) => {\n        console.log(responseText);\n   });\n```\n\n#### application/x-www-form-urlencoded\n\n```\n var fetchOptions = {\n           method: 'POST',\n           headers: {\n               'Accept': 'application/json',\n               //表单\n               'Content-Type': 'application/x-www-form-urlencoded'\n           },\n           body:'data=test' // 这里是请求参数,键值对形式\n       };\n\nfetch(\"http://localhost:3000/post\", fetchOptions)\n   .then((response) => response.json())\n   .then((responseText) => {\n        console.log(responseText);\n   });\n```\n如果使用的是Restful的API的话,那么只要把上面`fetchOption`里面的`method`改成对应的方法就好.\n\n当然,封装一个网络请求工具是有必要的,等我有时间写一下.","slug":"ReactNative网络请求","published":1,"updated":"2018-05-10T06:51:35.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcj1001oldxuvu9udr59","content":"<p>关于React Native 的网络请求的总结</p>\n<a id=\"more\"></a>\n<p>因为这里使用的是<code>fetch()</code>方法,返回的是一个<code>Promise</code>对象,所以可以使用<code>then()</code>和<code>catch()</code>方法进行链式调用,也可以用<code>all()</code>,<code>race()</code> 去包装多个请求</p>\n<p>具体的话可以看这里</p>\n<h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&quot;http://localhost:3000/get&quot;)</span><br><span class=\"line\">\t.then((response) =&gt; response.json()) // 这里取出响应体的JSON数据并返回</span><br><span class=\"line\">\t.then((responseJSON) =&gt; &#123; // 处理上面返回的JSON数据</span><br><span class=\"line\">\t\t// do something</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.catch((err) =&gt; &#123; // 捕获错误</span><br><span class=\"line\">\t\t// catch err</span><br><span class=\"line\">\t&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h3><p>网上说有两种,不过我一般用第二种比较多</p>\n<h4 id=\"application-json\"><a href=\"#application-json\" class=\"headerlink\" title=\"application/json\"></a>application/json</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fetchOptions = &#123;</span><br><span class=\"line\">           method: &apos;POST&apos;,</span><br><span class=\"line\">           headers: &#123;</span><br><span class=\"line\">               &apos;Accept&apos;: &apos;application/json&apos;,</span><br><span class=\"line\">               //json形式</span><br><span class=\"line\">               &apos;Content-Type&apos;: &apos;application/json&apos;</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           body:JSON.stringify(&apos;data=test&apos;) // 这里是请求参数,键值对形式</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fetch(&quot;http://localhost:3000/post&quot;, fetchOptions)</span><br><span class=\"line\">   .then((response) =&gt; response.json())</span><br><span class=\"line\">   .then((responseText) =&gt; &#123;</span><br><span class=\"line\">        console.log(responseText);</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"application-x-www-form-urlencoded\"><a href=\"#application-x-www-form-urlencoded\" class=\"headerlink\" title=\"application/x-www-form-urlencoded\"></a>application/x-www-form-urlencoded</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var fetchOptions = &#123;</span><br><span class=\"line\">           method: &apos;POST&apos;,</span><br><span class=\"line\">           headers: &#123;</span><br><span class=\"line\">               &apos;Accept&apos;: &apos;application/json&apos;,</span><br><span class=\"line\">               //表单</span><br><span class=\"line\">               &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           body:&apos;data=test&apos; // 这里是请求参数,键值对形式</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fetch(&quot;http://localhost:3000/post&quot;, fetchOptions)</span><br><span class=\"line\">   .then((response) =&gt; response.json())</span><br><span class=\"line\">   .then((responseText) =&gt; &#123;</span><br><span class=\"line\">        console.log(responseText);</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n<p>如果使用的是Restful的API的话,那么只要把上面<code>fetchOption</code>里面的<code>method</code>改成对应的方法就好.</p>\n<p>当然,封装一个网络请求工具是有必要的,等我有时间写一下.</p>\n","site":{"data":{}},"excerpt":"<p>关于React Native 的网络请求的总结</p>","more":"<p>因为这里使用的是<code>fetch()</code>方法,返回的是一个<code>Promise</code>对象,所以可以使用<code>then()</code>和<code>catch()</code>方法进行链式调用,也可以用<code>all()</code>,<code>race()</code> 去包装多个请求</p>\n<p>具体的话可以看这里</p>\n<h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&quot;http://localhost:3000/get&quot;)</span><br><span class=\"line\">\t.then((response) =&gt; response.json()) // 这里取出响应体的JSON数据并返回</span><br><span class=\"line\">\t.then((responseJSON) =&gt; &#123; // 处理上面返回的JSON数据</span><br><span class=\"line\">\t\t// do something</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.catch((err) =&gt; &#123; // 捕获错误</span><br><span class=\"line\">\t\t// catch err</span><br><span class=\"line\">\t&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h3><p>网上说有两种,不过我一般用第二种比较多</p>\n<h4 id=\"application-json\"><a href=\"#application-json\" class=\"headerlink\" title=\"application/json\"></a>application/json</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fetchOptions = &#123;</span><br><span class=\"line\">           method: &apos;POST&apos;,</span><br><span class=\"line\">           headers: &#123;</span><br><span class=\"line\">               &apos;Accept&apos;: &apos;application/json&apos;,</span><br><span class=\"line\">               //json形式</span><br><span class=\"line\">               &apos;Content-Type&apos;: &apos;application/json&apos;</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           body:JSON.stringify(&apos;data=test&apos;) // 这里是请求参数,键值对形式</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fetch(&quot;http://localhost:3000/post&quot;, fetchOptions)</span><br><span class=\"line\">   .then((response) =&gt; response.json())</span><br><span class=\"line\">   .then((responseText) =&gt; &#123;</span><br><span class=\"line\">        console.log(responseText);</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"application-x-www-form-urlencoded\"><a href=\"#application-x-www-form-urlencoded\" class=\"headerlink\" title=\"application/x-www-form-urlencoded\"></a>application/x-www-form-urlencoded</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var fetchOptions = &#123;</span><br><span class=\"line\">           method: &apos;POST&apos;,</span><br><span class=\"line\">           headers: &#123;</span><br><span class=\"line\">               &apos;Accept&apos;: &apos;application/json&apos;,</span><br><span class=\"line\">               //表单</span><br><span class=\"line\">               &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           body:&apos;data=test&apos; // 这里是请求参数,键值对形式</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fetch(&quot;http://localhost:3000/post&quot;, fetchOptions)</span><br><span class=\"line\">   .then((response) =&gt; response.json())</span><br><span class=\"line\">   .then((responseText) =&gt; &#123;</span><br><span class=\"line\">        console.log(responseText);</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n<p>如果使用的是Restful的API的话,那么只要把上面<code>fetchOption</code>里面的<code>method</code>改成对应的方法就好.</p>\n<p>当然,封装一个网络请求工具是有必要的,等我有时间写一下.</p>"},{"title":"ReactiveCocoa解决异步串行任务执行中多层嵌套/递归的问题","author":"Arclin","abbrlink":"5f5664e4","date":"2017-03-19T16:00:00.000Z","_content":"\n因为在项目中遇到了一个异步的串行任务执行的问题,通过ReactiveCocoa解决了,所以在这里记录一下\n\n<!-- more -->\n\n首先是一个第三方的API,这个API会进行一个网络请求,并且使用block进行回调.批量执行并且是串行执行.\n如果不用RAC,我们可以通过递归,当任务一结束的时候递归执行任务二,以达到串行的效果,然后判断索引达到最后的时候跳出递归,但这种操作如果一多容易造成栈溢出,所以用RAC的优化如下.\n\n首先使用一个`RACSignal`包装API,如下\n\n```\n- (RACSignal *)deleteWithId:(NSString *)identifier\n{\n    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        GTLQueryDrive *query = [GTLQueryDrive queryForFilesDeleteWithFileId:identifier];\n        [self.service executeQuery:query completionHandler:^(GTLServiceTicket *ticket, id object, NSError *error) {\n            if(!error) {\n                [subscriber sendNext:nil];\n                [subscriber sendCompleted];\n            }else {\n                [subscriber sendError:error]; // 失败的时候抛出异常\n            }\n        }];\n        return nil;\n    }];\n    return signal;\n}\n```\n  \n接下来把多个任务组装成一个数组\n\n```\nNSMutableArray *signals = [NSMutableArray array];\nfor (NSString *identifier in identifiers) {\n    RACSignal * signal = [self deleteWithId:identifier];\n    [signals addObject:signal];\n}\n```\n然后使用`RACSignal`的`concat`方法\n\n`concat`会顺序执行数组中的信号内容,上一个signal的信号`sendComplete`之后下一个信号内容才会开始执行\n\n因为我们要在任务全部执行完成的时候发送一个回调和任务执行到一半的时候抛出异常停止任务和队列.\n所以我们顺便加一个`doCompleted`和`catch`\n\n```\nRACSignal *concatSignal = [[[RACSignal concat:signals] doCompleted:^{\n       completeBlock(nil); // 回调告诉前台说所有任务都完成了\n   }] catch:^RACSignal *(NSError *error) {\n       completeBlock(error); // 回调告诉前台说异常了\n       return [RACSignal empty]; // 停止当前和接下来的任务的执行\n   }];\n```\n\n如果你要订阅concatSignal信号的时候用到了UI刷新或者其他需要在主线程执行的任务,那么这里可以加多一个`deliverOn:[RACScheduler mainThreadScheduler]]`\n\n所以最后的信号可能是这样子\n\n```\nRACSignal *concatSignal = [[[[RACSignal concat:signals] doCompleted:^{\n    completeBlock(nil);\n}] catch:^RACSignal *(NSError *error) {\n    completeBlock(error);\n    return [RACSignal empty];\n}] deliverOn:[RACScheduler mainThreadScheduler]];\n```\n\n那订阅信号就简单了\n\n```\n[concatSignal subscribeNext:^(id x) {\n    DKLog(@\"%@\",x);\n}];\n```\n执行的时候他会根据数组的顺序一个个执行信号内的内容,这样子写起来也好看了很多.\n","source":"_posts/ReactiveCocoa解决异步串行任务执行中多层嵌套-递归的问题.md","raw":"---\ntitle: ReactiveCocoa解决异步串行任务执行中多层嵌套/递归的问题\nauthor: Arclin\ntags:\n  - iOS\n  - Reactive Cocoa\ncategories:\n  - iOS\nabbrlink: 5f5664e4\ndate: 2017-03-20 00:00:00\n---\n\n因为在项目中遇到了一个异步的串行任务执行的问题,通过ReactiveCocoa解决了,所以在这里记录一下\n\n<!-- more -->\n\n首先是一个第三方的API,这个API会进行一个网络请求,并且使用block进行回调.批量执行并且是串行执行.\n如果不用RAC,我们可以通过递归,当任务一结束的时候递归执行任务二,以达到串行的效果,然后判断索引达到最后的时候跳出递归,但这种操作如果一多容易造成栈溢出,所以用RAC的优化如下.\n\n首先使用一个`RACSignal`包装API,如下\n\n```\n- (RACSignal *)deleteWithId:(NSString *)identifier\n{\n    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        GTLQueryDrive *query = [GTLQueryDrive queryForFilesDeleteWithFileId:identifier];\n        [self.service executeQuery:query completionHandler:^(GTLServiceTicket *ticket, id object, NSError *error) {\n            if(!error) {\n                [subscriber sendNext:nil];\n                [subscriber sendCompleted];\n            }else {\n                [subscriber sendError:error]; // 失败的时候抛出异常\n            }\n        }];\n        return nil;\n    }];\n    return signal;\n}\n```\n  \n接下来把多个任务组装成一个数组\n\n```\nNSMutableArray *signals = [NSMutableArray array];\nfor (NSString *identifier in identifiers) {\n    RACSignal * signal = [self deleteWithId:identifier];\n    [signals addObject:signal];\n}\n```\n然后使用`RACSignal`的`concat`方法\n\n`concat`会顺序执行数组中的信号内容,上一个signal的信号`sendComplete`之后下一个信号内容才会开始执行\n\n因为我们要在任务全部执行完成的时候发送一个回调和任务执行到一半的时候抛出异常停止任务和队列.\n所以我们顺便加一个`doCompleted`和`catch`\n\n```\nRACSignal *concatSignal = [[[RACSignal concat:signals] doCompleted:^{\n       completeBlock(nil); // 回调告诉前台说所有任务都完成了\n   }] catch:^RACSignal *(NSError *error) {\n       completeBlock(error); // 回调告诉前台说异常了\n       return [RACSignal empty]; // 停止当前和接下来的任务的执行\n   }];\n```\n\n如果你要订阅concatSignal信号的时候用到了UI刷新或者其他需要在主线程执行的任务,那么这里可以加多一个`deliverOn:[RACScheduler mainThreadScheduler]]`\n\n所以最后的信号可能是这样子\n\n```\nRACSignal *concatSignal = [[[[RACSignal concat:signals] doCompleted:^{\n    completeBlock(nil);\n}] catch:^RACSignal *(NSError *error) {\n    completeBlock(error);\n    return [RACSignal empty];\n}] deliverOn:[RACScheduler mainThreadScheduler]];\n```\n\n那订阅信号就简单了\n\n```\n[concatSignal subscribeNext:^(id x) {\n    DKLog(@\"%@\",x);\n}];\n```\n执行的时候他会根据数组的顺序一个个执行信号内的内容,这样子写起来也好看了很多.\n","slug":"ReactiveCocoa解决异步串行任务执行中多层嵌套-递归的问题","published":1,"updated":"2018-05-10T06:51:35.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcj8001sldxulnuhrtac","content":"<p>因为在项目中遇到了一个异步的串行任务执行的问题,通过ReactiveCocoa解决了,所以在这里记录一下</p>\n<a id=\"more\"></a>\n<p>首先是一个第三方的API,这个API会进行一个网络请求,并且使用block进行回调.批量执行并且是串行执行.<br>如果不用RAC,我们可以通过递归,当任务一结束的时候递归执行任务二,以达到串行的效果,然后判断索引达到最后的时候跳出递归,但这种操作如果一多容易造成栈溢出,所以用RAC的优化如下.</p>\n<p>首先使用一个<code>RACSignal</code>包装API,如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (RACSignal *)deleteWithId:(NSString *)identifier</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class=\"line\">        GTLQueryDrive *query = [GTLQueryDrive queryForFilesDeleteWithFileId:identifier];</span><br><span class=\"line\">        [self.service executeQuery:query completionHandler:^(GTLServiceTicket *ticket, id object, NSError *error) &#123;</span><br><span class=\"line\">            if(!error) &#123;</span><br><span class=\"line\">                [subscriber sendNext:nil];</span><br><span class=\"line\">                [subscriber sendCompleted];</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                [subscriber sendError:error]; // 失败的时候抛出异常</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    return signal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来把多个任务组装成一个数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableArray *signals = [NSMutableArray array];</span><br><span class=\"line\">for (NSString *identifier in identifiers) &#123;</span><br><span class=\"line\">    RACSignal * signal = [self deleteWithId:identifier];</span><br><span class=\"line\">    [signals addObject:signal];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后使用<code>RACSignal</code>的<code>concat</code>方法</p>\n<p><code>concat</code>会顺序执行数组中的信号内容,上一个signal的信号<code>sendComplete</code>之后下一个信号内容才会开始执行</p>\n<p>因为我们要在任务全部执行完成的时候发送一个回调和任务执行到一半的时候抛出异常停止任务和队列.<br>所以我们顺便加一个<code>doCompleted</code>和<code>catch</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *concatSignal = [[[RACSignal concat:signals] doCompleted:^&#123;</span><br><span class=\"line\">       completeBlock(nil); // 回调告诉前台说所有任务都完成了</span><br><span class=\"line\">   &#125;] catch:^RACSignal *(NSError *error) &#123;</span><br><span class=\"line\">       completeBlock(error); // 回调告诉前台说异常了</span><br><span class=\"line\">       return [RACSignal empty]; // 停止当前和接下来的任务的执行</span><br><span class=\"line\">   &#125;];</span><br></pre></td></tr></table></figure>\n<p>如果你要订阅concatSignal信号的时候用到了UI刷新或者其他需要在主线程执行的任务,那么这里可以加多一个<code>deliverOn:[RACScheduler mainThreadScheduler]]</code></p>\n<p>所以最后的信号可能是这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *concatSignal = [[[[RACSignal concat:signals] doCompleted:^&#123;</span><br><span class=\"line\">    completeBlock(nil);</span><br><span class=\"line\">&#125;] catch:^RACSignal *(NSError *error) &#123;</span><br><span class=\"line\">    completeBlock(error);</span><br><span class=\"line\">    return [RACSignal empty];</span><br><span class=\"line\">&#125;] deliverOn:[RACScheduler mainThreadScheduler]];</span><br></pre></td></tr></table></figure>\n<p>那订阅信号就简单了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[concatSignal subscribeNext:^(id x) &#123;</span><br><span class=\"line\">    DKLog(@&quot;%@&quot;,x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>执行的时候他会根据数组的顺序一个个执行信号内的内容,这样子写起来也好看了很多.</p>\n","site":{"data":{}},"excerpt":"<p>因为在项目中遇到了一个异步的串行任务执行的问题,通过ReactiveCocoa解决了,所以在这里记录一下</p>","more":"<p>首先是一个第三方的API,这个API会进行一个网络请求,并且使用block进行回调.批量执行并且是串行执行.<br>如果不用RAC,我们可以通过递归,当任务一结束的时候递归执行任务二,以达到串行的效果,然后判断索引达到最后的时候跳出递归,但这种操作如果一多容易造成栈溢出,所以用RAC的优化如下.</p>\n<p>首先使用一个<code>RACSignal</code>包装API,如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (RACSignal *)deleteWithId:(NSString *)identifier</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class=\"line\">        GTLQueryDrive *query = [GTLQueryDrive queryForFilesDeleteWithFileId:identifier];</span><br><span class=\"line\">        [self.service executeQuery:query completionHandler:^(GTLServiceTicket *ticket, id object, NSError *error) &#123;</span><br><span class=\"line\">            if(!error) &#123;</span><br><span class=\"line\">                [subscriber sendNext:nil];</span><br><span class=\"line\">                [subscriber sendCompleted];</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                [subscriber sendError:error]; // 失败的时候抛出异常</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    return signal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来把多个任务组装成一个数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableArray *signals = [NSMutableArray array];</span><br><span class=\"line\">for (NSString *identifier in identifiers) &#123;</span><br><span class=\"line\">    RACSignal * signal = [self deleteWithId:identifier];</span><br><span class=\"line\">    [signals addObject:signal];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后使用<code>RACSignal</code>的<code>concat</code>方法</p>\n<p><code>concat</code>会顺序执行数组中的信号内容,上一个signal的信号<code>sendComplete</code>之后下一个信号内容才会开始执行</p>\n<p>因为我们要在任务全部执行完成的时候发送一个回调和任务执行到一半的时候抛出异常停止任务和队列.<br>所以我们顺便加一个<code>doCompleted</code>和<code>catch</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *concatSignal = [[[RACSignal concat:signals] doCompleted:^&#123;</span><br><span class=\"line\">       completeBlock(nil); // 回调告诉前台说所有任务都完成了</span><br><span class=\"line\">   &#125;] catch:^RACSignal *(NSError *error) &#123;</span><br><span class=\"line\">       completeBlock(error); // 回调告诉前台说异常了</span><br><span class=\"line\">       return [RACSignal empty]; // 停止当前和接下来的任务的执行</span><br><span class=\"line\">   &#125;];</span><br></pre></td></tr></table></figure>\n<p>如果你要订阅concatSignal信号的时候用到了UI刷新或者其他需要在主线程执行的任务,那么这里可以加多一个<code>deliverOn:[RACScheduler mainThreadScheduler]]</code></p>\n<p>所以最后的信号可能是这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *concatSignal = [[[[RACSignal concat:signals] doCompleted:^&#123;</span><br><span class=\"line\">    completeBlock(nil);</span><br><span class=\"line\">&#125;] catch:^RACSignal *(NSError *error) &#123;</span><br><span class=\"line\">    completeBlock(error);</span><br><span class=\"line\">    return [RACSignal empty];</span><br><span class=\"line\">&#125;] deliverOn:[RACScheduler mainThreadScheduler]];</span><br></pre></td></tr></table></figure>\n<p>那订阅信号就简单了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[concatSignal subscribeNext:^(id x) &#123;</span><br><span class=\"line\">    DKLog(@&quot;%@&quot;,x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>执行的时候他会根据数组的顺序一个个执行信号内的内容,这样子写起来也好看了很多.</p>"},{"title":"URLWithString返回空","author":"Arclin","abbrlink":"890a3088","date":"2016-10-16T16:00:00.000Z","_content":"`[NSURL URLWithString:@”…………”]` 返回空 nil\n但是貌似汉字或者空格等无法被识别，String不被认为是URLString，这个NSURL的值也就一直是nil\n要怎样才能够让它识别呢？\n解决方法如下 ：\n\n1. 转换编码\n\n  ```\n  str1 = [str1 stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n\n  NSURL *url = [NSURL URLWithString:[Tool returnFormatString:str1]];\n  ```\n\n2. 除去空格\n\n  ```\n  +(NSString *)returnFormatString:(NSString *)str\n  {\n      return [str stringByReplacingOccurrencesOfString:@\" \"withString:@\" \"];\n  }\n\n   NSLog(@\"URL==%@\",url);\n  ```","source":"_posts/URLWithString返回空.md","raw":"---\ntitle: URLWithString返回空\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 890a3088\ndate: 2016-10-17 00:00:00\n---\n`[NSURL URLWithString:@”…………”]` 返回空 nil\n但是貌似汉字或者空格等无法被识别，String不被认为是URLString，这个NSURL的值也就一直是nil\n要怎样才能够让它识别呢？\n解决方法如下 ：\n\n1. 转换编码\n\n  ```\n  str1 = [str1 stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n\n  NSURL *url = [NSURL URLWithString:[Tool returnFormatString:str1]];\n  ```\n\n2. 除去空格\n\n  ```\n  +(NSString *)returnFormatString:(NSString *)str\n  {\n      return [str stringByReplacingOccurrencesOfString:@\" \"withString:@\" \"];\n  }\n\n   NSLog(@\"URL==%@\",url);\n  ```","slug":"URLWithString返回空","published":1,"updated":"2018-05-10T06:51:35.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcjc001uldxu1q0i7ivt","content":"<p><code>[NSURL URLWithString:@”…………”]</code> 返回空 nil<br>但是貌似汉字或者空格等无法被识别，String不被认为是URLString，这个NSURL的值也就一直是nil<br>要怎样才能够让它识别呢？<br>解决方法如下 ：</p>\n<ol>\n<li><p>转换编码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = [str1 stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class=\"line\"></span><br><span class=\"line\">NSURL *url = [NSURL URLWithString:[Tool returnFormatString:str1]];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>除去空格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+(NSString *)returnFormatString:(NSString *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return [str stringByReplacingOccurrencesOfString:@&quot; &quot;withString:@&quot; &quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> NSLog(@&quot;URL==%@&quot;,url);</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p><code>[NSURL URLWithString:@”…………”]</code> 返回空 nil<br>但是貌似汉字或者空格等无法被识别，String不被认为是URLString，这个NSURL的值也就一直是nil<br>要怎样才能够让它识别呢？<br>解决方法如下 ：</p>\n<ol>\n<li><p>转换编码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 = [str1 stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class=\"line\"></span><br><span class=\"line\">NSURL *url = [NSURL URLWithString:[Tool returnFormatString:str1]];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>除去空格</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+(NSString *)returnFormatString:(NSString *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return [str stringByReplacingOccurrencesOfString:@&quot; &quot;withString:@&quot; &quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> NSLog(@&quot;URL==%@&quot;,url);</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"Vue学习笔记","author":"Arclin","abbrlink":"71513ccb","date":"2017-08-07T16:10:00.000Z","_content":"Vue.js 是一个用于构建用户界面的渐进式前端框架\n\n<!-- more -->\n\n## 安装 vue-cli 命令行工具\n\n 安装Vue\n`npm install -g vue-cli`\n\n## 初始化项目\nvue init webpack-simple 项目名\n\n项目模板有很多种,这里用了webpack-simple webpack-simple 没有包括Eslint检查功能等等功能，webpack有,但是普通项目用webpack-simple就足够了.\n\n构造Vue实例\n\n```\nvar vm = new Vue({\n  // 选项\n})\n```\n\n例子\n\n```\nwindow.onload=function(){\n //在这里面写Vue.js代码\n new Vue({\n  el: '#demo', // 需要渲染的DOM元素\n  data: {\t\t // 渲染的数据,key-value方式\n    message: 'Hello Vue.js!' \n  }\n})\n//----------------\n}\n```\n\n## HTML中数据绑定\n\n### 单次插值\n\n```\n<span>Message: {{ message }}</span>\n```\n\n如果想要单次插值,即今后的数据变化就不会再引起插值更新,加个 *\n\n```\n<span>This will never change: {{* message }}</span>\n```\n\n例子\n\n```\nJS\n\nvar data={message:'Hello Vue.js!'};\nnew Vue({\n  el: '#demo',\n  data: data\n })\ndata.message =\"Hello World!\";\ndata.message =\"Hello\"; // 再次改变时候,第二个元素内的值不会变化\n\nHTML\n\n<span>This will never change: {{ message }}</span><br>\n<span>This will never change: {{* message }}</span>\n```\n\n### 嵌入HTML\n\n三个大括号表示不是插入文本而是html标签\n\n```\nHTML\n\n<div>{{{ msg }}}</div>\n```\n\n```\nJS\n\nvar data={msg:'<p>Hello Vue.js!</p>'};\nnew Vue({\n    el: '#demo',\n    data: data\n})\n\n```\n\n### HTMl特性\n比如说修改某个元素的id属性\n\n```\nHTML\n\n<div id=\"{{ id }}\"></div>\n```\n\n```\nJS\n\nvar data={id:'demo'};\nnew Vue({\n  el: 'div',\n  data: data\n})\n```\n\n### JavaScript表达式\n\n绑定的数据支持JavaScript表达式\n\n```\nJS\n\nwindow.onload=function(){\n //在这里面写Vue.js代码\n var data={message:'Hello ',number:3,ok:true};\n new Vue({\n  el: '#demo',\n  data: data\n })\n //----------------\n}\n```\n\n```\n<div id='demo'>\n{{ number + 1 }}<br/>\n{{ ok ? 'YES' : 'NO' }}<br/>\n{{ message.split('').reverse().join('') }}\n</div>\n```\n\n输出\n\n```\nYES\nolleH\n```\n\n### 过滤器\n使用管道符 |\n\n将message内的全部转换为小写字母\n\n```\n{{ message | lowercase }}\n```\n\n转为小写字母后,首字母大写\n\n```\n{{msg | lowercase | capitalize}}\n```\n\n此外还有大写过滤器`uppercase`\n\n```\nJS\n var data={msg:'heLLO!'};\n new Vue({\n  el: '#demo',\n  data: data\n })\n```\n\n输出\n\n```\nHello\n```\n\n### 指令\n渲染数据的时候的逻辑表达式\nv-text v-html v-model v-on v-else\n\n```\nJS\n\nvar data={msg:0};\n new Vue({\n  el: '#demo',\n  data: data\n })\n```\n\n当msg的值为1的时候才打印Hello!\n\n```\nHTML\n<p v-if=\"msg\">Hello!</p>\n```\n\n### 计算属性\n\n在模板中表达式非常便利，但是它们实际上只用于简单的操作。模板是为了描述视图的结构。在模板中放入太多的逻辑会让模板过重且难以维护。这就是为什么 Vue.js 将绑定表达式限制为一个表达式。如果需要多于一个表达式的逻辑，应当使用计算属性。\n\n```\nJS\n\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    a: 1\n  },\n  computed: {\n    // 一个计算属性的 getter\n    b: function () {\n      // `this` 指向 vm 实例\n      return this.a + 1\n    }\n  }\n})\n```\n```\nHTML\n\n<div id=\"example\">\n  a={{ a }}, b={{ b }}\n</div>\n```\n输出\n\n```\n1\na=1, b=2\n```","source":"_posts/Vue学习笔记.md","raw":"---\ntitle: Vue学习笔记\nauthor: Arclin\ntags:\n  - Vue.js\ncategories:\n  - 前端\nabbrlink: 71513ccb\ndate: 2017-08-08 00:10:00\n---\nVue.js 是一个用于构建用户界面的渐进式前端框架\n\n<!-- more -->\n\n## 安装 vue-cli 命令行工具\n\n 安装Vue\n`npm install -g vue-cli`\n\n## 初始化项目\nvue init webpack-simple 项目名\n\n项目模板有很多种,这里用了webpack-simple webpack-simple 没有包括Eslint检查功能等等功能，webpack有,但是普通项目用webpack-simple就足够了.\n\n构造Vue实例\n\n```\nvar vm = new Vue({\n  // 选项\n})\n```\n\n例子\n\n```\nwindow.onload=function(){\n //在这里面写Vue.js代码\n new Vue({\n  el: '#demo', // 需要渲染的DOM元素\n  data: {\t\t // 渲染的数据,key-value方式\n    message: 'Hello Vue.js!' \n  }\n})\n//----------------\n}\n```\n\n## HTML中数据绑定\n\n### 单次插值\n\n```\n<span>Message: {{ message }}</span>\n```\n\n如果想要单次插值,即今后的数据变化就不会再引起插值更新,加个 *\n\n```\n<span>This will never change: {{* message }}</span>\n```\n\n例子\n\n```\nJS\n\nvar data={message:'Hello Vue.js!'};\nnew Vue({\n  el: '#demo',\n  data: data\n })\ndata.message =\"Hello World!\";\ndata.message =\"Hello\"; // 再次改变时候,第二个元素内的值不会变化\n\nHTML\n\n<span>This will never change: {{ message }}</span><br>\n<span>This will never change: {{* message }}</span>\n```\n\n### 嵌入HTML\n\n三个大括号表示不是插入文本而是html标签\n\n```\nHTML\n\n<div>{{{ msg }}}</div>\n```\n\n```\nJS\n\nvar data={msg:'<p>Hello Vue.js!</p>'};\nnew Vue({\n    el: '#demo',\n    data: data\n})\n\n```\n\n### HTMl特性\n比如说修改某个元素的id属性\n\n```\nHTML\n\n<div id=\"{{ id }}\"></div>\n```\n\n```\nJS\n\nvar data={id:'demo'};\nnew Vue({\n  el: 'div',\n  data: data\n})\n```\n\n### JavaScript表达式\n\n绑定的数据支持JavaScript表达式\n\n```\nJS\n\nwindow.onload=function(){\n //在这里面写Vue.js代码\n var data={message:'Hello ',number:3,ok:true};\n new Vue({\n  el: '#demo',\n  data: data\n })\n //----------------\n}\n```\n\n```\n<div id='demo'>\n{{ number + 1 }}<br/>\n{{ ok ? 'YES' : 'NO' }}<br/>\n{{ message.split('').reverse().join('') }}\n</div>\n```\n\n输出\n\n```\nYES\nolleH\n```\n\n### 过滤器\n使用管道符 |\n\n将message内的全部转换为小写字母\n\n```\n{{ message | lowercase }}\n```\n\n转为小写字母后,首字母大写\n\n```\n{{msg | lowercase | capitalize}}\n```\n\n此外还有大写过滤器`uppercase`\n\n```\nJS\n var data={msg:'heLLO!'};\n new Vue({\n  el: '#demo',\n  data: data\n })\n```\n\n输出\n\n```\nHello\n```\n\n### 指令\n渲染数据的时候的逻辑表达式\nv-text v-html v-model v-on v-else\n\n```\nJS\n\nvar data={msg:0};\n new Vue({\n  el: '#demo',\n  data: data\n })\n```\n\n当msg的值为1的时候才打印Hello!\n\n```\nHTML\n<p v-if=\"msg\">Hello!</p>\n```\n\n### 计算属性\n\n在模板中表达式非常便利，但是它们实际上只用于简单的操作。模板是为了描述视图的结构。在模板中放入太多的逻辑会让模板过重且难以维护。这就是为什么 Vue.js 将绑定表达式限制为一个表达式。如果需要多于一个表达式的逻辑，应当使用计算属性。\n\n```\nJS\n\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    a: 1\n  },\n  computed: {\n    // 一个计算属性的 getter\n    b: function () {\n      // `this` 指向 vm 实例\n      return this.a + 1\n    }\n  }\n})\n```\n```\nHTML\n\n<div id=\"example\">\n  a={{ a }}, b={{ b }}\n</div>\n```\n输出\n\n```\n1\na=1, b=2\n```","slug":"Vue学习笔记","published":1,"updated":"2018-05-10T06:51:35.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcjf001xldxu1hic93e6","content":"<p>Vue.js 是一个用于构建用户界面的渐进式前端框架</p>\n<a id=\"more\"></a>\n<h2 id=\"安装-vue-cli-命令行工具\"><a href=\"#安装-vue-cli-命令行工具\" class=\"headerlink\" title=\"安装 vue-cli 命令行工具\"></a>安装 vue-cli 命令行工具</h2><p> 安装Vue<br><code>npm install -g vue-cli</code></p>\n<h2 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h2><p>vue init webpack-simple 项目名</p>\n<p>项目模板有很多种,这里用了webpack-simple webpack-simple 没有包括Eslint检查功能等等功能，webpack有,但是普通项目用webpack-simple就足够了.</p>\n<p>构造Vue实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  // 选项</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.onload=function()&#123;</span><br><span class=\"line\"> //在这里面写Vue.js代码</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#demo&apos;, // 需要渲染的DOM元素</span><br><span class=\"line\">  data: &#123;\t\t // 渲染的数据,key-value方式</span><br><span class=\"line\">    message: &apos;Hello Vue.js!&apos; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//----------------</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"HTML中数据绑定\"><a href=\"#HTML中数据绑定\" class=\"headerlink\" title=\"HTML中数据绑定\"></a>HTML中数据绑定</h2><h3 id=\"单次插值\"><a href=\"#单次插值\" class=\"headerlink\" title=\"单次插值\"></a>单次插值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span&gt;Message: &#123;&#123; message &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<p>如果想要单次插值,即今后的数据变化就不会再引起插值更新,加个 *</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123;* message &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<p>例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data=&#123;message:&apos;Hello Vue.js!&apos;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#demo&apos;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\">data.message =&quot;Hello World!&quot;;</span><br><span class=\"line\">data.message =&quot;Hello&quot;; // 再次改变时候,第二个元素内的值不会变化</span><br><span class=\"line\"></span><br><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123; message &#125;&#125;&lt;/span&gt;&lt;br&gt;</span><br><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123;* message &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"嵌入HTML\"><a href=\"#嵌入HTML\" class=\"headerlink\" title=\"嵌入HTML\"></a>嵌入HTML</h3><p>三个大括号表示不是插入文本而是html标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;&#123;&#123;&#123; msg &#125;&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data=&#123;msg:&apos;&lt;p&gt;Hello Vue.js!&lt;/p&gt;&apos;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: &apos;#demo&apos;,</span><br><span class=\"line\">    data: data</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"HTMl特性\"><a href=\"#HTMl特性\" class=\"headerlink\" title=\"HTMl特性\"></a>HTMl特性</h3><p>比如说修改某个元素的id属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=&quot;&#123;&#123; id &#125;&#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data=&#123;id:&apos;demo&apos;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;div&apos;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"JavaScript表达式\"><a href=\"#JavaScript表达式\" class=\"headerlink\" title=\"JavaScript表达式\"></a>JavaScript表达式</h3><p>绑定的数据支持JavaScript表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">window.onload=function()&#123;</span><br><span class=\"line\"> //在这里面写Vue.js代码</span><br><span class=\"line\"> var data=&#123;message:&apos;Hello &apos;,number:3,ok:true&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#demo&apos;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> //----------------</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&apos;demo&apos;&gt;</span><br><span class=\"line\">&#123;&#123; number + 1 &#125;&#125;&lt;br/&gt;</span><br><span class=\"line\">&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;&lt;br/&gt;</span><br><span class=\"line\">&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YES</span><br><span class=\"line\">olleH</span><br></pre></td></tr></table></figure>\n<h3 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h3><p>使用管道符 |</p>\n<p>将message内的全部转换为小写字母</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; message | lowercase &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>转为小写字母后,首字母大写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;msg | lowercase | capitalize&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>此外还有大写过滤器<code>uppercase</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"> var data=&#123;msg:&apos;heLLO!&apos;&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#demo&apos;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello</span><br></pre></td></tr></table></figure>\n<h3 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h3><p>渲染数据的时候的逻辑表达式<br>v-text v-html v-model v-on v-else</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data=&#123;msg:0&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#demo&apos;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n<p>当msg的值为1的时候才打印Hello!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\">&lt;p v-if=&quot;msg&quot;&gt;Hello!&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h3><p>在模板中表达式非常便利，但是它们实际上只用于简单的操作。模板是为了描述视图的结构。在模板中放入太多的逻辑会让模板过重且难以维护。这就是为什么 Vue.js 将绑定表达式限制为一个表达式。如果需要多于一个表达式的逻辑，应当使用计算属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#example&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    a: 1</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    // 一个计算属性的 getter</span><br><span class=\"line\">    b: function () &#123;</span><br><span class=\"line\">      // `this` 指向 vm 实例</span><br><span class=\"line\">      return this.a + 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=&quot;example&quot;&gt;</span><br><span class=\"line\">  a=&#123;&#123; a &#125;&#125;, b=&#123;&#123; b &#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">a=1, b=2</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>Vue.js 是一个用于构建用户界面的渐进式前端框架</p>","more":"<h2 id=\"安装-vue-cli-命令行工具\"><a href=\"#安装-vue-cli-命令行工具\" class=\"headerlink\" title=\"安装 vue-cli 命令行工具\"></a>安装 vue-cli 命令行工具</h2><p> 安装Vue<br><code>npm install -g vue-cli</code></p>\n<h2 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h2><p>vue init webpack-simple 项目名</p>\n<p>项目模板有很多种,这里用了webpack-simple webpack-simple 没有包括Eslint检查功能等等功能，webpack有,但是普通项目用webpack-simple就足够了.</p>\n<p>构造Vue实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  // 选项</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.onload=function()&#123;</span><br><span class=\"line\"> //在这里面写Vue.js代码</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#demo&apos;, // 需要渲染的DOM元素</span><br><span class=\"line\">  data: &#123;\t\t // 渲染的数据,key-value方式</span><br><span class=\"line\">    message: &apos;Hello Vue.js!&apos; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//----------------</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"HTML中数据绑定\"><a href=\"#HTML中数据绑定\" class=\"headerlink\" title=\"HTML中数据绑定\"></a>HTML中数据绑定</h2><h3 id=\"单次插值\"><a href=\"#单次插值\" class=\"headerlink\" title=\"单次插值\"></a>单次插值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span&gt;Message: &#123;&#123; message &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<p>如果想要单次插值,即今后的数据变化就不会再引起插值更新,加个 *</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123;* message &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<p>例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data=&#123;message:&apos;Hello Vue.js!&apos;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#demo&apos;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\">data.message =&quot;Hello World!&quot;;</span><br><span class=\"line\">data.message =&quot;Hello&quot;; // 再次改变时候,第二个元素内的值不会变化</span><br><span class=\"line\"></span><br><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123; message &#125;&#125;&lt;/span&gt;&lt;br&gt;</span><br><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123;* message &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"嵌入HTML\"><a href=\"#嵌入HTML\" class=\"headerlink\" title=\"嵌入HTML\"></a>嵌入HTML</h3><p>三个大括号表示不是插入文本而是html标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;&#123;&#123;&#123; msg &#125;&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data=&#123;msg:&apos;&lt;p&gt;Hello Vue.js!&lt;/p&gt;&apos;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: &apos;#demo&apos;,</span><br><span class=\"line\">    data: data</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"HTMl特性\"><a href=\"#HTMl特性\" class=\"headerlink\" title=\"HTMl特性\"></a>HTMl特性</h3><p>比如说修改某个元素的id属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=&quot;&#123;&#123; id &#125;&#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data=&#123;id:&apos;demo&apos;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &apos;div&apos;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"JavaScript表达式\"><a href=\"#JavaScript表达式\" class=\"headerlink\" title=\"JavaScript表达式\"></a>JavaScript表达式</h3><p>绑定的数据支持JavaScript表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">window.onload=function()&#123;</span><br><span class=\"line\"> //在这里面写Vue.js代码</span><br><span class=\"line\"> var data=&#123;message:&apos;Hello &apos;,number:3,ok:true&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#demo&apos;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> //----------------</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&apos;demo&apos;&gt;</span><br><span class=\"line\">&#123;&#123; number + 1 &#125;&#125;&lt;br/&gt;</span><br><span class=\"line\">&#123;&#123; ok ? &apos;YES&apos; : &apos;NO&apos; &#125;&#125;&lt;br/&gt;</span><br><span class=\"line\">&#123;&#123; message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YES</span><br><span class=\"line\">olleH</span><br></pre></td></tr></table></figure>\n<h3 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h3><p>使用管道符 |</p>\n<p>将message内的全部转换为小写字母</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; message | lowercase &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>转为小写字母后,首字母大写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;msg | lowercase | capitalize&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>此外还有大写过滤器<code>uppercase</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"> var data=&#123;msg:&apos;heLLO!&apos;&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#demo&apos;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello</span><br></pre></td></tr></table></figure>\n<h3 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h3><p>渲染数据的时候的逻辑表达式<br>v-text v-html v-model v-on v-else</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data=&#123;msg:0&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#demo&apos;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n<p>当msg的值为1的时候才打印Hello!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\">&lt;p v-if=&quot;msg&quot;&gt;Hello!&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h3><p>在模板中表达式非常便利，但是它们实际上只用于简单的操作。模板是为了描述视图的结构。在模板中放入太多的逻辑会让模板过重且难以维护。这就是为什么 Vue.js 将绑定表达式限制为一个表达式。如果需要多于一个表达式的逻辑，应当使用计算属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  el: &apos;#example&apos;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    a: 1</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    // 一个计算属性的 getter</span><br><span class=\"line\">    b: function () &#123;</span><br><span class=\"line\">      // `this` 指向 vm 实例</span><br><span class=\"line\">      return this.a + 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id=&quot;example&quot;&gt;</span><br><span class=\"line\">  a=&#123;&#123; a &#125;&#125;, b=&#123;&#123; b &#125;&#125;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">a=1, b=2</span><br></pre></td></tr></table></figure>"},{"title":"WordPress常用函数","author":"Arclin","abbrlink":"3fd5c9ca","date":"2017-03-01T16:00:00.000Z","_content":"wordpress自定义主题的时候需要用到的函数\n\n<!-- more -->\n\n[参考文档](https://codex.wordpress.org/zh-cn:模板标签)\n\n\n|函数名|作用|\n|----|----|\n|bloginfo()|可以拿到博客的信息,name,description,version,特别注意bloginfo('stylesheet_url');会直接找到根目录下的style.css文件,这个页面的样式表|\n|wp_head()|\t一般放在header.php,会有很多东西引入进去|\n|wp_title()|网站标题|\n|get_header()|检查同目录下是否有header.php,有的话就会调用这个文件作为页面头部|\n|get_sidebar()|检查sidebar.php,调用作为侧边栏|\n|get_footer()|检查footer.php,调用作为底部栏|\n|have_posts()|判断是否有日志|\n|the_post()|调用一篇具体的日志,和主循环配合使用|\n|the_permalink()|每篇日志地址|\n|the_title()|日志标题|\n|the_content()|日志内容|\n|_e()|框架里面有语言文件,这里是调用语言文件内对应文字,使用类似这样子_e(\"Archives\"),中文页面下显示归档,英文页面下显示Archives|\n|the_category()|分类,这个函数里面有一个参数,可以表示用什么符号去分割多个分类名,例如the_category(',')|\n|the_author()|作者名|\n|the_excerpt()|日志摘要|\n|comments_popup_link(‘No Comments »’, ‘1 Comment »’, ‘% Comments »’);|当弹出留言的功能激活的话，comments_popup_link() 调用一个弹出的留言窗口，如果没有激活，comments_popup_link() 则只是简单的显示留言列表。No Comments » 是在没有留言的时候显示的。1 Comment » 是用于当刚好只有1条留言时候。% Comments &187; 是用于当有多于一条留言的时候。比如：8 Comments »。百分号 % 用来显示数字。» 是用来显示一个双层箭头 »。|\n|edit_post_link(‘Edit’, ‘&124’, ”);\t|这个只有当我们以管理员或者作者身份登录的的时候才可见。|\n|edit_post_link()|只是简单显示一个可以用来编辑当前日志的编辑链接，这样就可以让我们不必去管理界面搜寻该日志就能直接编辑。|\n|edit_post_link() |有三个参数。第一个是用来确定哪个词你将用在编辑链接的链接标题。如果你使用 Edit post，那么将显示 Edit post 而不是 Edit。第二个参数是用来显示在链接前面的字符，在这里是竖线，代码就是&124;。第三个参数是用于显示在编辑链接后面的字符，在这里没有使用。登录 WordPress 之后，再返回到首页就可以看到“Edit”的链接和一条竖线。|\n|posts_nav_link(‘中间页’, ‘<<上一页’, ‘下一页>>’)|调用后一页和前一页的链接,3个参数，分别给链接的中间，前面和后面的设置字符|\n|previous_post_link(‘%link’)|上一篇日志|\n|next_post_link(‘%link’)|下一篇日志|\n|wp_list_pages()|展示页面列表,如果参数里面填`title_li=<h2>Pages</h2>&depth=3`,可以设置title的样式,depth指的是页面的展示深度|\n|wp_list_cats()|展示分类列表,参数可填`sort_column=name&optioncount=1&hierarchical=0`,分别是设置排序根据,是否显示文章个数,以分层缩进的方式显示分类列表|\n|get_links_list();|友情链接列表,在后台装插件之后就可以用了|\n|wp_get_archives()|意思跟上面的差不多,也是有参数,获取的是文章归档列表,参数填type=daily的话就是按日期分,monthly按月分,yearly按年分,format=link以链接形式显示|\n|wp_loginout()|退出登录链接|\n|wp_register()|注册链接|\n|wp_meta()|显示管理员的相关控制信息|\n|get_calendar()|显示一个日历|\n|include(TEMPLATEPATH . ‘/searchform.php’)|导入某个自定义文件,像左边就是/searchform.php文件|\n\n### 判断是否有日志并循环输出日志\n```\n<?php if(have_posts()) : ?> <!--检查是否有日志-->\n\t<?php while(have_posts()) : the_post(); ?> <!--循环输出日志-->\n\t\t\t<div class=\"post\" id=\"post-<?php the_ID(); ?>\">\n\t\t\t\t<h2><a href=\"<?php the_permalink(); ?>\" title=\"<?php the_title(); ?>\"><?php the_title(); ?></a></h2><!--日志标题-->\n\t\t\t\t<div class='entry'>\n\t\t\t\t<?php the_content(); ?>\n\t\t\t</div>\n\t\t\t<p class=\"postmetadata\">\n\t\t\t<?php _e('Filed under&#58;'); ?> <?php the_category(', ') ?> <?php _e('by'); ?> <?php  the_author(); ?><br />\n\t\t\t<?php comments_popup_link('No Comments &#187;', '1 Comment &#187;', '% Comments &#187;'); ?> <?php edit_post_link('Edit', ' &#124; ', ''); ?>\n\t\t\t</p>\n\t\t\t</div>\n\t<?php endwhile; ?>\n\t<div class=\"navigation\">\n\t\t\t<?php posts_nav_link('index', '<<上一页', '下一页>>'); ?>\n\t</div>\n\t<?php else : ?> <!--如果没有日志-->\n\t<div class = \"post\">\n\t\t<h2><?php _e(\"Not Found\"); ?></h2>\n\t</div>\n<?php endif; ?>\n```\n\n### 搜索框\n\n```\n<form method=\"get\" id=\"searchform\" action=\"<?php bloginfo('home'); ?>/\">\n\n<div>\n\n\t<input type=\"text\" value=\"<?php echo wp_specialchars($s, 1); ?>\" name=\"s\" id=\"s\" size=\"15\" /><br />\n\n\t<input type=\"submit\" id=\"searchsubmit\" value=\"Search\" />\n\n</div>\n\n</form>\n```","source":"_posts/WordPress常用函数.md","raw":"---\ntitle: WordPress常用函数\nauthor: Arclin\ntags:\n  - PHP\n  - WordPress\ncategories:\n  - PHP\nabbrlink: 3fd5c9ca\ndate: 2017-03-02 00:00:00\n---\nwordpress自定义主题的时候需要用到的函数\n\n<!-- more -->\n\n[参考文档](https://codex.wordpress.org/zh-cn:模板标签)\n\n\n|函数名|作用|\n|----|----|\n|bloginfo()|可以拿到博客的信息,name,description,version,特别注意bloginfo('stylesheet_url');会直接找到根目录下的style.css文件,这个页面的样式表|\n|wp_head()|\t一般放在header.php,会有很多东西引入进去|\n|wp_title()|网站标题|\n|get_header()|检查同目录下是否有header.php,有的话就会调用这个文件作为页面头部|\n|get_sidebar()|检查sidebar.php,调用作为侧边栏|\n|get_footer()|检查footer.php,调用作为底部栏|\n|have_posts()|判断是否有日志|\n|the_post()|调用一篇具体的日志,和主循环配合使用|\n|the_permalink()|每篇日志地址|\n|the_title()|日志标题|\n|the_content()|日志内容|\n|_e()|框架里面有语言文件,这里是调用语言文件内对应文字,使用类似这样子_e(\"Archives\"),中文页面下显示归档,英文页面下显示Archives|\n|the_category()|分类,这个函数里面有一个参数,可以表示用什么符号去分割多个分类名,例如the_category(',')|\n|the_author()|作者名|\n|the_excerpt()|日志摘要|\n|comments_popup_link(‘No Comments »’, ‘1 Comment »’, ‘% Comments »’);|当弹出留言的功能激活的话，comments_popup_link() 调用一个弹出的留言窗口，如果没有激活，comments_popup_link() 则只是简单的显示留言列表。No Comments » 是在没有留言的时候显示的。1 Comment » 是用于当刚好只有1条留言时候。% Comments &187; 是用于当有多于一条留言的时候。比如：8 Comments »。百分号 % 用来显示数字。» 是用来显示一个双层箭头 »。|\n|edit_post_link(‘Edit’, ‘&124’, ”);\t|这个只有当我们以管理员或者作者身份登录的的时候才可见。|\n|edit_post_link()|只是简单显示一个可以用来编辑当前日志的编辑链接，这样就可以让我们不必去管理界面搜寻该日志就能直接编辑。|\n|edit_post_link() |有三个参数。第一个是用来确定哪个词你将用在编辑链接的链接标题。如果你使用 Edit post，那么将显示 Edit post 而不是 Edit。第二个参数是用来显示在链接前面的字符，在这里是竖线，代码就是&124;。第三个参数是用于显示在编辑链接后面的字符，在这里没有使用。登录 WordPress 之后，再返回到首页就可以看到“Edit”的链接和一条竖线。|\n|posts_nav_link(‘中间页’, ‘<<上一页’, ‘下一页>>’)|调用后一页和前一页的链接,3个参数，分别给链接的中间，前面和后面的设置字符|\n|previous_post_link(‘%link’)|上一篇日志|\n|next_post_link(‘%link’)|下一篇日志|\n|wp_list_pages()|展示页面列表,如果参数里面填`title_li=<h2>Pages</h2>&depth=3`,可以设置title的样式,depth指的是页面的展示深度|\n|wp_list_cats()|展示分类列表,参数可填`sort_column=name&optioncount=1&hierarchical=0`,分别是设置排序根据,是否显示文章个数,以分层缩进的方式显示分类列表|\n|get_links_list();|友情链接列表,在后台装插件之后就可以用了|\n|wp_get_archives()|意思跟上面的差不多,也是有参数,获取的是文章归档列表,参数填type=daily的话就是按日期分,monthly按月分,yearly按年分,format=link以链接形式显示|\n|wp_loginout()|退出登录链接|\n|wp_register()|注册链接|\n|wp_meta()|显示管理员的相关控制信息|\n|get_calendar()|显示一个日历|\n|include(TEMPLATEPATH . ‘/searchform.php’)|导入某个自定义文件,像左边就是/searchform.php文件|\n\n### 判断是否有日志并循环输出日志\n```\n<?php if(have_posts()) : ?> <!--检查是否有日志-->\n\t<?php while(have_posts()) : the_post(); ?> <!--循环输出日志-->\n\t\t\t<div class=\"post\" id=\"post-<?php the_ID(); ?>\">\n\t\t\t\t<h2><a href=\"<?php the_permalink(); ?>\" title=\"<?php the_title(); ?>\"><?php the_title(); ?></a></h2><!--日志标题-->\n\t\t\t\t<div class='entry'>\n\t\t\t\t<?php the_content(); ?>\n\t\t\t</div>\n\t\t\t<p class=\"postmetadata\">\n\t\t\t<?php _e('Filed under&#58;'); ?> <?php the_category(', ') ?> <?php _e('by'); ?> <?php  the_author(); ?><br />\n\t\t\t<?php comments_popup_link('No Comments &#187;', '1 Comment &#187;', '% Comments &#187;'); ?> <?php edit_post_link('Edit', ' &#124; ', ''); ?>\n\t\t\t</p>\n\t\t\t</div>\n\t<?php endwhile; ?>\n\t<div class=\"navigation\">\n\t\t\t<?php posts_nav_link('index', '<<上一页', '下一页>>'); ?>\n\t</div>\n\t<?php else : ?> <!--如果没有日志-->\n\t<div class = \"post\">\n\t\t<h2><?php _e(\"Not Found\"); ?></h2>\n\t</div>\n<?php endif; ?>\n```\n\n### 搜索框\n\n```\n<form method=\"get\" id=\"searchform\" action=\"<?php bloginfo('home'); ?>/\">\n\n<div>\n\n\t<input type=\"text\" value=\"<?php echo wp_specialchars($s, 1); ?>\" name=\"s\" id=\"s\" size=\"15\" /><br />\n\n\t<input type=\"submit\" id=\"searchsubmit\" value=\"Search\" />\n\n</div>\n\n</form>\n```","slug":"WordPress常用函数","published":1,"updated":"2018-05-10T06:51:35.744Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcjh0020ldxu8r6b6hep","content":"<p>wordpress自定义主题的时候需要用到的函数</p>\n<a id=\"more\"></a>\n<p><a href=\"https://codex.wordpress.org/zh-cn:模板标签\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bloginfo()</td>\n<td>可以拿到博客的信息,name,description,version,特别注意bloginfo(‘stylesheet_url’);会直接找到根目录下的style.css文件,这个页面的样式表</td>\n</tr>\n<tr>\n<td>wp_head()</td>\n<td>一般放在header.php,会有很多东西引入进去</td>\n</tr>\n<tr>\n<td>wp_title()</td>\n<td>网站标题</td>\n</tr>\n<tr>\n<td>get_header()</td>\n<td>检查同目录下是否有header.php,有的话就会调用这个文件作为页面头部</td>\n</tr>\n<tr>\n<td>get_sidebar()</td>\n<td>检查sidebar.php,调用作为侧边栏</td>\n</tr>\n<tr>\n<td>get_footer()</td>\n<td>检查footer.php,调用作为底部栏</td>\n</tr>\n<tr>\n<td>have_posts()</td>\n<td>判断是否有日志</td>\n</tr>\n<tr>\n<td>the_post()</td>\n<td>调用一篇具体的日志,和主循环配合使用</td>\n</tr>\n<tr>\n<td>the_permalink()</td>\n<td>每篇日志地址</td>\n</tr>\n<tr>\n<td>the_title()</td>\n<td>日志标题</td>\n</tr>\n<tr>\n<td>the_content()</td>\n<td>日志内容</td>\n</tr>\n<tr>\n<td>_e()</td>\n<td>框架里面有语言文件,这里是调用语言文件内对应文字,使用类似这样子_e(“Archives”),中文页面下显示归档,英文页面下显示Archives</td>\n</tr>\n<tr>\n<td>the_category()</td>\n<td>分类,这个函数里面有一个参数,可以表示用什么符号去分割多个分类名,例如the_category(‘,’)</td>\n</tr>\n<tr>\n<td>the_author()</td>\n<td>作者名</td>\n</tr>\n<tr>\n<td>the_excerpt()</td>\n<td>日志摘要</td>\n</tr>\n<tr>\n<td>comments_popup_link(‘No Comments »’, ‘1 Comment »’, ‘% Comments »’);</td>\n<td>当弹出留言的功能激活的话，comments_popup_link() 调用一个弹出的留言窗口，如果没有激活，comments_popup_link() 则只是简单的显示留言列表。No Comments » 是在没有留言的时候显示的。1 Comment » 是用于当刚好只有1条留言时候。% Comments &187; 是用于当有多于一条留言的时候。比如：8 Comments »。百分号 % 用来显示数字。» 是用来显示一个双层箭头 »。</td>\n</tr>\n<tr>\n<td>edit_post_link(‘Edit’, ‘&amp;124’, ”);</td>\n<td>这个只有当我们以管理员或者作者身份登录的的时候才可见。</td>\n</tr>\n<tr>\n<td>edit_post_link()</td>\n<td>只是简单显示一个可以用来编辑当前日志的编辑链接，这样就可以让我们不必去管理界面搜寻该日志就能直接编辑。</td>\n</tr>\n<tr>\n<td>edit_post_link()</td>\n<td>有三个参数。第一个是用来确定哪个词你将用在编辑链接的链接标题。如果你使用 Edit post，那么将显示 Edit post 而不是 Edit。第二个参数是用来显示在链接前面的字符，在这里是竖线，代码就是&124;。第三个参数是用于显示在编辑链接后面的字符，在这里没有使用。登录 WordPress 之后，再返回到首页就可以看到“Edit”的链接和一条竖线。</td>\n</tr>\n<tr>\n<td>posts_nav_link(‘中间页’, ‘&lt;&lt;上一页’, ‘下一页&gt;&gt;’)</td>\n<td>调用后一页和前一页的链接,3个参数，分别给链接的中间，前面和后面的设置字符</td>\n</tr>\n<tr>\n<td>previous_post_link(‘%link’)</td>\n<td>上一篇日志</td>\n</tr>\n<tr>\n<td>next_post_link(‘%link’)</td>\n<td>下一篇日志</td>\n</tr>\n<tr>\n<td>wp_list_pages()</td>\n<td>展示页面列表,如果参数里面填<code>title_li=&lt;h2&gt;Pages&lt;/h2&gt;&amp;depth=3</code>,可以设置title的样式,depth指的是页面的展示深度</td>\n</tr>\n<tr>\n<td>wp_list_cats()</td>\n<td>展示分类列表,参数可填<code>sort_column=name&amp;optioncount=1&amp;hierarchical=0</code>,分别是设置排序根据,是否显示文章个数,以分层缩进的方式显示分类列表</td>\n</tr>\n<tr>\n<td>get_links_list();</td>\n<td>友情链接列表,在后台装插件之后就可以用了</td>\n</tr>\n<tr>\n<td>wp_get_archives()</td>\n<td>意思跟上面的差不多,也是有参数,获取的是文章归档列表,参数填type=daily的话就是按日期分,monthly按月分,yearly按年分,format=link以链接形式显示</td>\n</tr>\n<tr>\n<td>wp_loginout()</td>\n<td>退出登录链接</td>\n</tr>\n<tr>\n<td>wp_register()</td>\n<td>注册链接</td>\n</tr>\n<tr>\n<td>wp_meta()</td>\n<td>显示管理员的相关控制信息</td>\n</tr>\n<tr>\n<td>get_calendar()</td>\n<td>显示一个日历</td>\n</tr>\n<tr>\n<td>include(TEMPLATEPATH . ‘/searchform.php’)</td>\n<td>导入某个自定义文件,像左边就是/searchform.php文件</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"判断是否有日志并循环输出日志\"><a href=\"#判断是否有日志并循环输出日志\" class=\"headerlink\" title=\"判断是否有日志并循环输出日志\"></a>判断是否有日志并循环输出日志</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php if(have_posts()) : ?&gt; &lt;!--检查是否有日志--&gt;</span><br><span class=\"line\">\t&lt;?php while(have_posts()) : the_post(); ?&gt; &lt;!--循环输出日志--&gt;</span><br><span class=\"line\">\t\t\t&lt;div class=&quot;post&quot; id=&quot;post-&lt;?php the_ID(); ?&gt;&quot;&gt;</span><br><span class=\"line\">\t\t\t\t&lt;h2&gt;&lt;a href=&quot;&lt;?php the_permalink(); ?&gt;&quot; title=&quot;&lt;?php the_title(); ?&gt;&quot;&gt;&lt;?php the_title(); ?&gt;&lt;/a&gt;&lt;/h2&gt;&lt;!--日志标题--&gt;</span><br><span class=\"line\">\t\t\t\t&lt;div class=&apos;entry&apos;&gt;</span><br><span class=\"line\">\t\t\t\t&lt;?php the_content(); ?&gt;</span><br><span class=\"line\">\t\t\t&lt;/div&gt;</span><br><span class=\"line\">\t\t\t&lt;p class=&quot;postmetadata&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;?php _e(&apos;Filed under&amp;#58;&apos;); ?&gt; &lt;?php the_category(&apos;, &apos;) ?&gt; &lt;?php _e(&apos;by&apos;); ?&gt; &lt;?php  the_author(); ?&gt;&lt;br /&gt;</span><br><span class=\"line\">\t\t\t&lt;?php comments_popup_link(&apos;No Comments &amp;#187;&apos;, &apos;1 Comment &amp;#187;&apos;, &apos;% Comments &amp;#187;&apos;); ?&gt; &lt;?php edit_post_link(&apos;Edit&apos;, &apos; &amp;#124; &apos;, &apos;&apos;); ?&gt;</span><br><span class=\"line\">\t\t\t&lt;/p&gt;</span><br><span class=\"line\">\t\t\t&lt;/div&gt;</span><br><span class=\"line\">\t&lt;?php endwhile; ?&gt;</span><br><span class=\"line\">\t&lt;div class=&quot;navigation&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;?php posts_nav_link(&apos;index&apos;, &apos;&lt;&lt;上一页&apos;, &apos;下一页&gt;&gt;&apos;); ?&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">\t&lt;?php else : ?&gt; &lt;!--如果没有日志--&gt;</span><br><span class=\"line\">\t&lt;div class = &quot;post&quot;&gt;</span><br><span class=\"line\">\t\t&lt;h2&gt;&lt;?php _e(&quot;Not Found&quot;); ?&gt;&lt;/h2&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;?php endif; ?&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"搜索框\"><a href=\"#搜索框\" class=\"headerlink\" title=\"搜索框\"></a>搜索框</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form method=&quot;get&quot; id=&quot;searchform&quot; action=&quot;&lt;?php bloginfo(&apos;home&apos;); ?&gt;/&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;input type=&quot;text&quot; value=&quot;&lt;?php echo wp_specialchars($s, 1); ?&gt;&quot; name=&quot;s&quot; id=&quot;s&quot; size=&quot;15&quot; /&gt;&lt;br /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;input type=&quot;submit&quot; id=&quot;searchsubmit&quot; value=&quot;Search&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>wordpress自定义主题的时候需要用到的函数</p>","more":"<p><a href=\"https://codex.wordpress.org/zh-cn:模板标签\" target=\"_blank\" rel=\"noopener\">参考文档</a></p>\n<table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>bloginfo()</td>\n<td>可以拿到博客的信息,name,description,version,特别注意bloginfo(‘stylesheet_url’);会直接找到根目录下的style.css文件,这个页面的样式表</td>\n</tr>\n<tr>\n<td>wp_head()</td>\n<td>一般放在header.php,会有很多东西引入进去</td>\n</tr>\n<tr>\n<td>wp_title()</td>\n<td>网站标题</td>\n</tr>\n<tr>\n<td>get_header()</td>\n<td>检查同目录下是否有header.php,有的话就会调用这个文件作为页面头部</td>\n</tr>\n<tr>\n<td>get_sidebar()</td>\n<td>检查sidebar.php,调用作为侧边栏</td>\n</tr>\n<tr>\n<td>get_footer()</td>\n<td>检查footer.php,调用作为底部栏</td>\n</tr>\n<tr>\n<td>have_posts()</td>\n<td>判断是否有日志</td>\n</tr>\n<tr>\n<td>the_post()</td>\n<td>调用一篇具体的日志,和主循环配合使用</td>\n</tr>\n<tr>\n<td>the_permalink()</td>\n<td>每篇日志地址</td>\n</tr>\n<tr>\n<td>the_title()</td>\n<td>日志标题</td>\n</tr>\n<tr>\n<td>the_content()</td>\n<td>日志内容</td>\n</tr>\n<tr>\n<td>_e()</td>\n<td>框架里面有语言文件,这里是调用语言文件内对应文字,使用类似这样子_e(“Archives”),中文页面下显示归档,英文页面下显示Archives</td>\n</tr>\n<tr>\n<td>the_category()</td>\n<td>分类,这个函数里面有一个参数,可以表示用什么符号去分割多个分类名,例如the_category(‘,’)</td>\n</tr>\n<tr>\n<td>the_author()</td>\n<td>作者名</td>\n</tr>\n<tr>\n<td>the_excerpt()</td>\n<td>日志摘要</td>\n</tr>\n<tr>\n<td>comments_popup_link(‘No Comments »’, ‘1 Comment »’, ‘% Comments »’);</td>\n<td>当弹出留言的功能激活的话，comments_popup_link() 调用一个弹出的留言窗口，如果没有激活，comments_popup_link() 则只是简单的显示留言列表。No Comments » 是在没有留言的时候显示的。1 Comment » 是用于当刚好只有1条留言时候。% Comments &187; 是用于当有多于一条留言的时候。比如：8 Comments »。百分号 % 用来显示数字。» 是用来显示一个双层箭头 »。</td>\n</tr>\n<tr>\n<td>edit_post_link(‘Edit’, ‘&amp;124’, ”);</td>\n<td>这个只有当我们以管理员或者作者身份登录的的时候才可见。</td>\n</tr>\n<tr>\n<td>edit_post_link()</td>\n<td>只是简单显示一个可以用来编辑当前日志的编辑链接，这样就可以让我们不必去管理界面搜寻该日志就能直接编辑。</td>\n</tr>\n<tr>\n<td>edit_post_link()</td>\n<td>有三个参数。第一个是用来确定哪个词你将用在编辑链接的链接标题。如果你使用 Edit post，那么将显示 Edit post 而不是 Edit。第二个参数是用来显示在链接前面的字符，在这里是竖线，代码就是&124;。第三个参数是用于显示在编辑链接后面的字符，在这里没有使用。登录 WordPress 之后，再返回到首页就可以看到“Edit”的链接和一条竖线。</td>\n</tr>\n<tr>\n<td>posts_nav_link(‘中间页’, ‘&lt;&lt;上一页’, ‘下一页&gt;&gt;’)</td>\n<td>调用后一页和前一页的链接,3个参数，分别给链接的中间，前面和后面的设置字符</td>\n</tr>\n<tr>\n<td>previous_post_link(‘%link’)</td>\n<td>上一篇日志</td>\n</tr>\n<tr>\n<td>next_post_link(‘%link’)</td>\n<td>下一篇日志</td>\n</tr>\n<tr>\n<td>wp_list_pages()</td>\n<td>展示页面列表,如果参数里面填<code>title_li=&lt;h2&gt;Pages&lt;/h2&gt;&amp;depth=3</code>,可以设置title的样式,depth指的是页面的展示深度</td>\n</tr>\n<tr>\n<td>wp_list_cats()</td>\n<td>展示分类列表,参数可填<code>sort_column=name&amp;optioncount=1&amp;hierarchical=0</code>,分别是设置排序根据,是否显示文章个数,以分层缩进的方式显示分类列表</td>\n</tr>\n<tr>\n<td>get_links_list();</td>\n<td>友情链接列表,在后台装插件之后就可以用了</td>\n</tr>\n<tr>\n<td>wp_get_archives()</td>\n<td>意思跟上面的差不多,也是有参数,获取的是文章归档列表,参数填type=daily的话就是按日期分,monthly按月分,yearly按年分,format=link以链接形式显示</td>\n</tr>\n<tr>\n<td>wp_loginout()</td>\n<td>退出登录链接</td>\n</tr>\n<tr>\n<td>wp_register()</td>\n<td>注册链接</td>\n</tr>\n<tr>\n<td>wp_meta()</td>\n<td>显示管理员的相关控制信息</td>\n</tr>\n<tr>\n<td>get_calendar()</td>\n<td>显示一个日历</td>\n</tr>\n<tr>\n<td>include(TEMPLATEPATH . ‘/searchform.php’)</td>\n<td>导入某个自定义文件,像左边就是/searchform.php文件</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"判断是否有日志并循环输出日志\"><a href=\"#判断是否有日志并循环输出日志\" class=\"headerlink\" title=\"判断是否有日志并循环输出日志\"></a>判断是否有日志并循环输出日志</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php if(have_posts()) : ?&gt; &lt;!--检查是否有日志--&gt;</span><br><span class=\"line\">\t&lt;?php while(have_posts()) : the_post(); ?&gt; &lt;!--循环输出日志--&gt;</span><br><span class=\"line\">\t\t\t&lt;div class=&quot;post&quot; id=&quot;post-&lt;?php the_ID(); ?&gt;&quot;&gt;</span><br><span class=\"line\">\t\t\t\t&lt;h2&gt;&lt;a href=&quot;&lt;?php the_permalink(); ?&gt;&quot; title=&quot;&lt;?php the_title(); ?&gt;&quot;&gt;&lt;?php the_title(); ?&gt;&lt;/a&gt;&lt;/h2&gt;&lt;!--日志标题--&gt;</span><br><span class=\"line\">\t\t\t\t&lt;div class=&apos;entry&apos;&gt;</span><br><span class=\"line\">\t\t\t\t&lt;?php the_content(); ?&gt;</span><br><span class=\"line\">\t\t\t&lt;/div&gt;</span><br><span class=\"line\">\t\t\t&lt;p class=&quot;postmetadata&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;?php _e(&apos;Filed under&amp;#58;&apos;); ?&gt; &lt;?php the_category(&apos;, &apos;) ?&gt; &lt;?php _e(&apos;by&apos;); ?&gt; &lt;?php  the_author(); ?&gt;&lt;br /&gt;</span><br><span class=\"line\">\t\t\t&lt;?php comments_popup_link(&apos;No Comments &amp;#187;&apos;, &apos;1 Comment &amp;#187;&apos;, &apos;% Comments &amp;#187;&apos;); ?&gt; &lt;?php edit_post_link(&apos;Edit&apos;, &apos; &amp;#124; &apos;, &apos;&apos;); ?&gt;</span><br><span class=\"line\">\t\t\t&lt;/p&gt;</span><br><span class=\"line\">\t\t\t&lt;/div&gt;</span><br><span class=\"line\">\t&lt;?php endwhile; ?&gt;</span><br><span class=\"line\">\t&lt;div class=&quot;navigation&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;?php posts_nav_link(&apos;index&apos;, &apos;&lt;&lt;上一页&apos;, &apos;下一页&gt;&gt;&apos;); ?&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">\t&lt;?php else : ?&gt; &lt;!--如果没有日志--&gt;</span><br><span class=\"line\">\t&lt;div class = &quot;post&quot;&gt;</span><br><span class=\"line\">\t\t&lt;h2&gt;&lt;?php _e(&quot;Not Found&quot;); ?&gt;&lt;/h2&gt;</span><br><span class=\"line\">\t&lt;/div&gt;</span><br><span class=\"line\">&lt;?php endif; ?&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"搜索框\"><a href=\"#搜索框\" class=\"headerlink\" title=\"搜索框\"></a>搜索框</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form method=&quot;get&quot; id=&quot;searchform&quot; action=&quot;&lt;?php bloginfo(&apos;home&apos;); ?&gt;/&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;input type=&quot;text&quot; value=&quot;&lt;?php echo wp_specialchars($s, 1); ?&gt;&quot; name=&quot;s&quot; id=&quot;s&quot; size=&quot;15&quot; /&gt;&lt;br /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;input type=&quot;submit&quot; id=&quot;searchsubmit&quot; value=&quot;Search&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/form&gt;</span><br></pre></td></tr></table></figure>"},{"title":"Apache强制https ","author":"Arclin","abbrlink":"f6ce3122","date":"2018-02-18T13:50:00.000Z","_content":"当用户访问http的地址的时候，Apache如何强制跳转到https地址\n\n<!-- more -->\n\n修改httpd.conf\n\n1. LoadModule rewrite_module modules/mod_rewrite.so 这个拓展貌似是已经被加载了；\n2. 修改Apache默认项目路径的这个\n\n```\n<Directory \"/var/www/html\">\n```\n\n其实是修改为项目发布的路径\n```\n<Directory \"/var/www/html/app/src/htdocs_www\">\n```\n改为All\n\n```\nAllowOverride All\n```\n\n\n```\n# \n# Possible values for the Options directive are \"None\", \"All\", \n# or any combination of: \n# Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews \n# \n# Note that \"MultiViews\" must be named *explicitly* --- \"Options All\" \n# doesn't give it to you. \n# \n# The Options directive is both complicated and important. Please see \n# http://httpd.apache.org/docs/2.2/mod/core.html\n# options \n# for more information. \n# Options Indexes FollowSymLinks \n# \n# AllowOverride controls what directives may be placed in .htaccess files. \n# It can be \"All\", \"None\", or any combination of the keywords: \n# Options FileInfo AuthConfig Limit \n# \n# \n# Controls who can get stuff from this server. \n# \nOrder allow,deny \nAllow from all\n```\n\n添加三行代码\n\n```\nRewriteEngine on\nRewriteCond %{SERVER_PORT} !^443$\nRewriteRule ^(.*)?$ https://%{SERVER_NAME}/$1 [L,R]\n```","source":"_posts/Untitled.md","raw":"---\ntitle: 'Apache强制https '\nauthor: Arclin\ntags:\n  - https\ncategories:\n  - Linux\nabbrlink: f6ce3122\ndate: 2018-02-18 21:50:00\n---\n当用户访问http的地址的时候，Apache如何强制跳转到https地址\n\n<!-- more -->\n\n修改httpd.conf\n\n1. LoadModule rewrite_module modules/mod_rewrite.so 这个拓展貌似是已经被加载了；\n2. 修改Apache默认项目路径的这个\n\n```\n<Directory \"/var/www/html\">\n```\n\n其实是修改为项目发布的路径\n```\n<Directory \"/var/www/html/app/src/htdocs_www\">\n```\n改为All\n\n```\nAllowOverride All\n```\n\n\n```\n# \n# Possible values for the Options directive are \"None\", \"All\", \n# or any combination of: \n# Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews \n# \n# Note that \"MultiViews\" must be named *explicitly* --- \"Options All\" \n# doesn't give it to you. \n# \n# The Options directive is both complicated and important. Please see \n# http://httpd.apache.org/docs/2.2/mod/core.html\n# options \n# for more information. \n# Options Indexes FollowSymLinks \n# \n# AllowOverride controls what directives may be placed in .htaccess files. \n# It can be \"All\", \"None\", or any combination of the keywords: \n# Options FileInfo AuthConfig Limit \n# \n# \n# Controls who can get stuff from this server. \n# \nOrder allow,deny \nAllow from all\n```\n\n添加三行代码\n\n```\nRewriteEngine on\nRewriteCond %{SERVER_PORT} !^443$\nRewriteRule ^(.*)?$ https://%{SERVER_NAME}/$1 [L,R]\n```","slug":"Untitled","published":1,"updated":"2018-05-10T06:51:35.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcjl0024ldxuodvs8bhp","content":"<p>当用户访问http的地址的时候，Apache如何强制跳转到https地址</p>\n<a id=\"more\"></a>\n<p>修改httpd.conf</p>\n<ol>\n<li>LoadModule rewrite_module modules/mod_rewrite.so 这个拓展貌似是已经被加载了；</li>\n<li>修改Apache默认项目路径的这个</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Directory &quot;/var/www/html&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>其实是修改为项目发布的路径<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Directory &quot;/var/www/html/app/src/htdocs_www&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>改为All</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AllowOverride All</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># </span><br><span class=\"line\"># Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, </span><br><span class=\"line\"># or any combination of: </span><br><span class=\"line\"># Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews </span><br><span class=\"line\"># </span><br><span class=\"line\"># Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; </span><br><span class=\"line\"># doesn&apos;t give it to you. </span><br><span class=\"line\"># </span><br><span class=\"line\"># The Options directive is both complicated and important. Please see </span><br><span class=\"line\"># http://httpd.apache.org/docs/2.2/mod/core.html</span><br><span class=\"line\"># options </span><br><span class=\"line\"># for more information. </span><br><span class=\"line\"># Options Indexes FollowSymLinks </span><br><span class=\"line\"># </span><br><span class=\"line\"># AllowOverride controls what directives may be placed in .htaccess files. </span><br><span class=\"line\"># It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: </span><br><span class=\"line\"># Options FileInfo AuthConfig Limit </span><br><span class=\"line\"># </span><br><span class=\"line\"># </span><br><span class=\"line\"># Controls who can get stuff from this server. </span><br><span class=\"line\"># </span><br><span class=\"line\">Order allow,deny </span><br><span class=\"line\">Allow from all</span><br></pre></td></tr></table></figure>\n<p>添加三行代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RewriteEngine on</span><br><span class=\"line\">RewriteCond %&#123;SERVER_PORT&#125; !^443$</span><br><span class=\"line\">RewriteRule ^(.*)?$ https://%&#123;SERVER_NAME&#125;/$1 [L,R]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>当用户访问http的地址的时候，Apache如何强制跳转到https地址</p>","more":"<p>修改httpd.conf</p>\n<ol>\n<li>LoadModule rewrite_module modules/mod_rewrite.so 这个拓展貌似是已经被加载了；</li>\n<li>修改Apache默认项目路径的这个</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Directory &quot;/var/www/html&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>其实是修改为项目发布的路径<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Directory &quot;/var/www/html/app/src/htdocs_www&quot;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>改为All</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AllowOverride All</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># </span><br><span class=\"line\"># Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, </span><br><span class=\"line\"># or any combination of: </span><br><span class=\"line\"># Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews </span><br><span class=\"line\"># </span><br><span class=\"line\"># Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; </span><br><span class=\"line\"># doesn&apos;t give it to you. </span><br><span class=\"line\"># </span><br><span class=\"line\"># The Options directive is both complicated and important. Please see </span><br><span class=\"line\"># http://httpd.apache.org/docs/2.2/mod/core.html</span><br><span class=\"line\"># options </span><br><span class=\"line\"># for more information. </span><br><span class=\"line\"># Options Indexes FollowSymLinks </span><br><span class=\"line\"># </span><br><span class=\"line\"># AllowOverride controls what directives may be placed in .htaccess files. </span><br><span class=\"line\"># It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: </span><br><span class=\"line\"># Options FileInfo AuthConfig Limit </span><br><span class=\"line\"># </span><br><span class=\"line\"># </span><br><span class=\"line\"># Controls who can get stuff from this server. </span><br><span class=\"line\"># </span><br><span class=\"line\">Order allow,deny </span><br><span class=\"line\">Allow from all</span><br></pre></td></tr></table></figure>\n<p>添加三行代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RewriteEngine on</span><br><span class=\"line\">RewriteCond %&#123;SERVER_PORT&#125; !^443$</span><br><span class=\"line\">RewriteRule ^(.*)?$ https://%&#123;SERVER_NAME&#125;/$1 [L,R]</span><br></pre></td></tr></table></figure>"},{"title":" UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃的问题","author":"Arclin","abbrlink":"1787ee1c","date":"2016-11-08T16:00:00.000Z","_content":"UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃\n\n```\n-[UIPopoverController dealloc] reached while popover is still visible.\n```\n\n<!-- more -->\n\n错误的大体意思是：popover在仍旧可见的时候被销毁了（调用了dealloc）\n\n从错误可以得出的结论\n当popover仍旧可见的时候，不准销毁popover对象\n在销\n毁popover对象之前，一定先让popover消失（不可见）\n\n```\n@property (retain, nonatomic) UIPopoverController *popoverController;\n\n- (void)splitViewController:(UISplitViewController *)svc willHideViewController:(UIViewController *)aViewController withBarButtonItem:(UIBarButtonItem *)barButtonItem forPopoverController:(UIPopoverController *)pc\n{\n    self.popoverController = pc;\n}\n\n- (void)dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion\n{\n    [self.popoverController dismissPopoverAnimated:YES];\n    [super dismissViewControllerAnimated:YES completion:nil];\n}\n```","source":"_posts/UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃的问题.md","raw":"---\ntitle: ' UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃的问题'\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 1787ee1c\ndate: 2016-11-09 00:00:00\n---\nUISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃\n\n```\n-[UIPopoverController dealloc] reached while popover is still visible.\n```\n\n<!-- more -->\n\n错误的大体意思是：popover在仍旧可见的时候被销毁了（调用了dealloc）\n\n从错误可以得出的结论\n当popover仍旧可见的时候，不准销毁popover对象\n在销\n毁popover对象之前，一定先让popover消失（不可见）\n\n```\n@property (retain, nonatomic) UIPopoverController *popoverController;\n\n- (void)splitViewController:(UISplitViewController *)svc willHideViewController:(UIViewController *)aViewController withBarButtonItem:(UIBarButtonItem *)barButtonItem forPopoverController:(UIPopoverController *)pc\n{\n    self.popoverController = pc;\n}\n\n- (void)dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion\n{\n    [self.popoverController dismissPopoverAnimated:YES];\n    [super dismissViewControllerAnimated:YES completion:nil];\n}\n```","slug":"UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃的问题","published":1,"updated":"2018-05-10T06:51:35.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcjo0027ldxu7rx5src6","content":"<p>UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-[UIPopoverController dealloc] reached while popover is still visible.</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>错误的大体意思是：popover在仍旧可见的时候被销毁了（调用了dealloc）</p>\n<p>从错误可以得出的结论<br>当popover仍旧可见的时候，不准销毁popover对象<br>在销<br>毁popover对象之前，一定先让popover消失（不可见）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property (retain, nonatomic) UIPopoverController *popoverController;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)splitViewController:(UISplitViewController *)svc willHideViewController:(UIViewController *)aViewController withBarButtonItem:(UIBarButtonItem *)barButtonItem forPopoverController:(UIPopoverController *)pc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self.popoverController = pc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.popoverController dismissPopoverAnimated:YES];</span><br><span class=\"line\">    [super dismissViewControllerAnimated:YES completion:nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-[UIPopoverController dealloc] reached while popover is still visible.</span><br></pre></td></tr></table></figure>","more":"<p>错误的大体意思是：popover在仍旧可见的时候被销毁了（调用了dealloc）</p>\n<p>从错误可以得出的结论<br>当popover仍旧可见的时候，不准销毁popover对象<br>在销<br>毁popover对象之前，一定先让popover消失（不可见）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property (retain, nonatomic) UIPopoverController *popoverController;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)splitViewController:(UISplitViewController *)svc willHideViewController:(UIViewController *)aViewController withBarButtonItem:(UIBarButtonItem *)barButtonItem forPopoverController:(UIPopoverController *)pc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self.popoverController = pc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.popoverController dismissPopoverAnimated:YES];</span><br><span class=\"line\">    [super dismissViewControllerAnimated:YES completion:nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"docker笔记","author":"Arclin","abbrlink":"4417b09c","date":"2018-02-18T14:19:00.000Z","_content":"docker学习笔记\n\n<!-- more -->\n\ndocker是一种类似虚拟机的存在\n\n\n// 查看本机docker信息\n\n`docker info`\n\n// 运行hello world\n\n`docker run centos:6.7 /bin/echo \"Hello World\"`\n\n//  -t 进入伪终端\n//  -i 允许你对容器内的标准输入 (STDIN) 进行交互。 \n\n`docker run -i -t centos:6.7 /bin/bash`\n\n// -d 后台模式\n\n` docker run -d centos:6.7 /bin/sh -c \"while true;do echo hello world; sleep 1; done\"`\n\n//  查看当前运行的容器\n\n`docker ps`\n\n// -l 最近创建的容器\n\n`docker ps -l`\n\n// -a 所有容器\n\n`docker ps -a`\n\n// 查看运行log\n\n`docker logs 2b1b7a428627`\n\n//或\n\n`docker logs angry_austin`\n\n// 具体参数看ps的内容进行替换\n\n// 停止容器\n\n`docker stop angry_austin`\n\n\n// 删除容器\n\n`docker rm awesome_bardeen`\n\n// 进入容器终端 允许标准输入\n\n`docker exec -it practical_fermat /bin/bash`\n\n中间的参数是容器名\n\n// 拉取镜像 (如:httpd)\n\n`docker pull httpd`\n\n// 指定端口运行容器\n\n`docker run -d -p 5000:5001 httpd`\n\n// 提交新的镜像并添加tag v2 \n\n`docker commit -m \"has update\" -a=\"arclin\" 000c5746fa52 arclin/centos:v2`\n\n// 添加标签dev  中间那串是容器id\n\n`docker tag d 607e5fac1115 arclin/centos:dev`\n\n// 删除标签 6.7\n\n`docker rmi -f arclin/centos:6.7`\n\n\n// 指定端口运行  8080 是本地端口 80是容器端口 -d 是后台运行的意思\n\n`docker run -d -p 8080:80 httpd`\n\n// 随机端口运行 -P\n\n`docker run -d -P  httpd`\n\n// 查看容器practical_fermat的80端口被绑定到本机的哪个端口上了\n\n`docker port practical_fermat 80`\n\n// 运行的时候顺便给容器命名\n\n`docker run -d -P --name testName httpd`\n\n// 给容器重命名\n\n`docker rename practical_fermat test_httpd`\n\n// 运行nginx\n```\ndocker run -p 81:80 --name mynginx -v $PWD/www:/www -v \n\n$PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx  \n-p 81:80：将容器的80端口映射到主机的81端口\n--name mynginx：将容器命名为mynginx\n-v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www\n-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf\n-v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs\n```\n\n// 查看nginx的文件系统\n\n`docker inspect mynginx | grep Mounts -A 20`\n\n\n// 安装Apache\n\n`mkdir -p  ~/apache/www ~/apache/logs ~/apache/conf `\n\n// 运行Apache\n\n`docker run -p 80:80 -v $PWD/www/:/usr/local/apache2/htdocs/ -v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf -v $PWD/logs/:/usr/local/apache2/logs/ -d httpd`\n\n\n// 删除所有容器\n\n`sudo docker rm $(docker ps -a -q)`\n\n// 下载容器内的文件\n\n`docker cp ecef8319d2c8:/root/test.txt /root/`\n\n// 上传文件到容器中\n\n`docker cp /root/test.txt ecef8319d2c8:/root/`\n","source":"_posts/docker笔记.md","raw":"---\ntitle: docker笔记\nauthor: Arclin\ntags:\n  - docker\ncategories:\n  - Linux\nabbrlink: 4417b09c\ndate: 2018-02-18 22:19:00\n---\ndocker学习笔记\n\n<!-- more -->\n\ndocker是一种类似虚拟机的存在\n\n\n// 查看本机docker信息\n\n`docker info`\n\n// 运行hello world\n\n`docker run centos:6.7 /bin/echo \"Hello World\"`\n\n//  -t 进入伪终端\n//  -i 允许你对容器内的标准输入 (STDIN) 进行交互。 \n\n`docker run -i -t centos:6.7 /bin/bash`\n\n// -d 后台模式\n\n` docker run -d centos:6.7 /bin/sh -c \"while true;do echo hello world; sleep 1; done\"`\n\n//  查看当前运行的容器\n\n`docker ps`\n\n// -l 最近创建的容器\n\n`docker ps -l`\n\n// -a 所有容器\n\n`docker ps -a`\n\n// 查看运行log\n\n`docker logs 2b1b7a428627`\n\n//或\n\n`docker logs angry_austin`\n\n// 具体参数看ps的内容进行替换\n\n// 停止容器\n\n`docker stop angry_austin`\n\n\n// 删除容器\n\n`docker rm awesome_bardeen`\n\n// 进入容器终端 允许标准输入\n\n`docker exec -it practical_fermat /bin/bash`\n\n中间的参数是容器名\n\n// 拉取镜像 (如:httpd)\n\n`docker pull httpd`\n\n// 指定端口运行容器\n\n`docker run -d -p 5000:5001 httpd`\n\n// 提交新的镜像并添加tag v2 \n\n`docker commit -m \"has update\" -a=\"arclin\" 000c5746fa52 arclin/centos:v2`\n\n// 添加标签dev  中间那串是容器id\n\n`docker tag d 607e5fac1115 arclin/centos:dev`\n\n// 删除标签 6.7\n\n`docker rmi -f arclin/centos:6.7`\n\n\n// 指定端口运行  8080 是本地端口 80是容器端口 -d 是后台运行的意思\n\n`docker run -d -p 8080:80 httpd`\n\n// 随机端口运行 -P\n\n`docker run -d -P  httpd`\n\n// 查看容器practical_fermat的80端口被绑定到本机的哪个端口上了\n\n`docker port practical_fermat 80`\n\n// 运行的时候顺便给容器命名\n\n`docker run -d -P --name testName httpd`\n\n// 给容器重命名\n\n`docker rename practical_fermat test_httpd`\n\n// 运行nginx\n```\ndocker run -p 81:80 --name mynginx -v $PWD/www:/www -v \n\n$PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx  \n-p 81:80：将容器的80端口映射到主机的81端口\n--name mynginx：将容器命名为mynginx\n-v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www\n-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf\n-v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs\n```\n\n// 查看nginx的文件系统\n\n`docker inspect mynginx | grep Mounts -A 20`\n\n\n// 安装Apache\n\n`mkdir -p  ~/apache/www ~/apache/logs ~/apache/conf `\n\n// 运行Apache\n\n`docker run -p 80:80 -v $PWD/www/:/usr/local/apache2/htdocs/ -v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf -v $PWD/logs/:/usr/local/apache2/logs/ -d httpd`\n\n\n// 删除所有容器\n\n`sudo docker rm $(docker ps -a -q)`\n\n// 下载容器内的文件\n\n`docker cp ecef8319d2c8:/root/test.txt /root/`\n\n// 上传文件到容器中\n\n`docker cp /root/test.txt ecef8319d2c8:/root/`\n","slug":"docker笔记","published":1,"updated":"2018-05-10T06:51:35.745Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcjt002aldxun2kvd1pd","content":"<p>docker学习笔记</p>\n<a id=\"more\"></a>\n<p>docker是一种类似虚拟机的存在</p>\n<p>// 查看本机docker信息</p>\n<p><code>docker info</code></p>\n<p>// 运行hello world</p>\n<p><code>docker run centos:6.7 /bin/echo &quot;Hello World&quot;</code></p>\n<p>//  -t 进入伪终端<br>//  -i 允许你对容器内的标准输入 (STDIN) 进行交互。 </p>\n<p><code>docker run -i -t centos:6.7 /bin/bash</code></p>\n<p>// -d 后台模式</p>\n<p><code>docker run -d centos:6.7 /bin/sh -c &quot;while true;do echo hello world; sleep 1; done&quot;</code></p>\n<p>//  查看当前运行的容器</p>\n<p><code>docker ps</code></p>\n<p>// -l 最近创建的容器</p>\n<p><code>docker ps -l</code></p>\n<p>// -a 所有容器</p>\n<p><code>docker ps -a</code></p>\n<p>// 查看运行log</p>\n<p><code>docker logs 2b1b7a428627</code></p>\n<p>//或</p>\n<p><code>docker logs angry_austin</code></p>\n<p>// 具体参数看ps的内容进行替换</p>\n<p>// 停止容器</p>\n<p><code>docker stop angry_austin</code></p>\n<p>// 删除容器</p>\n<p><code>docker rm awesome_bardeen</code></p>\n<p>// 进入容器终端 允许标准输入</p>\n<p><code>docker exec -it practical_fermat /bin/bash</code></p>\n<p>中间的参数是容器名</p>\n<p>// 拉取镜像 (如:httpd)</p>\n<p><code>docker pull httpd</code></p>\n<p>// 指定端口运行容器</p>\n<p><code>docker run -d -p 5000:5001 httpd</code></p>\n<p>// 提交新的镜像并添加tag v2 </p>\n<p><code>docker commit -m &quot;has update&quot; -a=&quot;arclin&quot; 000c5746fa52 arclin/centos:v2</code></p>\n<p>// 添加标签dev  中间那串是容器id</p>\n<p><code>docker tag d 607e5fac1115 arclin/centos:dev</code></p>\n<p>// 删除标签 6.7</p>\n<p><code>docker rmi -f arclin/centos:6.7</code></p>\n<p>// 指定端口运行  8080 是本地端口 80是容器端口 -d 是后台运行的意思</p>\n<p><code>docker run -d -p 8080:80 httpd</code></p>\n<p>// 随机端口运行 -P</p>\n<p><code>docker run -d -P  httpd</code></p>\n<p>// 查看容器practical_fermat的80端口被绑定到本机的哪个端口上了</p>\n<p><code>docker port practical_fermat 80</code></p>\n<p>// 运行的时候顺便给容器命名</p>\n<p><code>docker run -d -P --name testName httpd</code></p>\n<p>// 给容器重命名</p>\n<p><code>docker rename practical_fermat test_httpd</code></p>\n<p>// 运行nginx<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p 81:80 --name mynginx -v $PWD/www:/www -v </span><br><span class=\"line\"></span><br><span class=\"line\">$PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx  </span><br><span class=\"line\">-p 81:80：将容器的80端口映射到主机的81端口</span><br><span class=\"line\">--name mynginx：将容器命名为mynginx</span><br><span class=\"line\">-v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www</span><br><span class=\"line\">-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf</span><br><span class=\"line\">-v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs</span><br></pre></td></tr></table></figure></p>\n<p>// 查看nginx的文件系统</p>\n<p><code>docker inspect mynginx | grep Mounts -A 20</code></p>\n<p>// 安装Apache</p>\n<p><code>mkdir -p  ~/apache/www ~/apache/logs ~/apache/conf</code></p>\n<p>// 运行Apache</p>\n<p><code>docker run -p 80:80 -v $PWD/www/:/usr/local/apache2/htdocs/ -v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf -v $PWD/logs/:/usr/local/apache2/logs/ -d httpd</code></p>\n<p>// 删除所有容器</p>\n<p><code>sudo docker rm $(docker ps -a -q)</code></p>\n<p>// 下载容器内的文件</p>\n<p><code>docker cp ecef8319d2c8:/root/test.txt /root/</code></p>\n<p>// 上传文件到容器中</p>\n<p><code>docker cp /root/test.txt ecef8319d2c8:/root/</code></p>\n","site":{"data":{}},"excerpt":"<p>docker学习笔记</p>","more":"<p>docker是一种类似虚拟机的存在</p>\n<p>// 查看本机docker信息</p>\n<p><code>docker info</code></p>\n<p>// 运行hello world</p>\n<p><code>docker run centos:6.7 /bin/echo &quot;Hello World&quot;</code></p>\n<p>//  -t 进入伪终端<br>//  -i 允许你对容器内的标准输入 (STDIN) 进行交互。 </p>\n<p><code>docker run -i -t centos:6.7 /bin/bash</code></p>\n<p>// -d 后台模式</p>\n<p><code>docker run -d centos:6.7 /bin/sh -c &quot;while true;do echo hello world; sleep 1; done&quot;</code></p>\n<p>//  查看当前运行的容器</p>\n<p><code>docker ps</code></p>\n<p>// -l 最近创建的容器</p>\n<p><code>docker ps -l</code></p>\n<p>// -a 所有容器</p>\n<p><code>docker ps -a</code></p>\n<p>// 查看运行log</p>\n<p><code>docker logs 2b1b7a428627</code></p>\n<p>//或</p>\n<p><code>docker logs angry_austin</code></p>\n<p>// 具体参数看ps的内容进行替换</p>\n<p>// 停止容器</p>\n<p><code>docker stop angry_austin</code></p>\n<p>// 删除容器</p>\n<p><code>docker rm awesome_bardeen</code></p>\n<p>// 进入容器终端 允许标准输入</p>\n<p><code>docker exec -it practical_fermat /bin/bash</code></p>\n<p>中间的参数是容器名</p>\n<p>// 拉取镜像 (如:httpd)</p>\n<p><code>docker pull httpd</code></p>\n<p>// 指定端口运行容器</p>\n<p><code>docker run -d -p 5000:5001 httpd</code></p>\n<p>// 提交新的镜像并添加tag v2 </p>\n<p><code>docker commit -m &quot;has update&quot; -a=&quot;arclin&quot; 000c5746fa52 arclin/centos:v2</code></p>\n<p>// 添加标签dev  中间那串是容器id</p>\n<p><code>docker tag d 607e5fac1115 arclin/centos:dev</code></p>\n<p>// 删除标签 6.7</p>\n<p><code>docker rmi -f arclin/centos:6.7</code></p>\n<p>// 指定端口运行  8080 是本地端口 80是容器端口 -d 是后台运行的意思</p>\n<p><code>docker run -d -p 8080:80 httpd</code></p>\n<p>// 随机端口运行 -P</p>\n<p><code>docker run -d -P  httpd</code></p>\n<p>// 查看容器practical_fermat的80端口被绑定到本机的哪个端口上了</p>\n<p><code>docker port practical_fermat 80</code></p>\n<p>// 运行的时候顺便给容器命名</p>\n<p><code>docker run -d -P --name testName httpd</code></p>\n<p>// 给容器重命名</p>\n<p><code>docker rename practical_fermat test_httpd</code></p>\n<p>// 运行nginx<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p 81:80 --name mynginx -v $PWD/www:/www -v </span><br><span class=\"line\"></span><br><span class=\"line\">$PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx  </span><br><span class=\"line\">-p 81:80：将容器的80端口映射到主机的81端口</span><br><span class=\"line\">--name mynginx：将容器命名为mynginx</span><br><span class=\"line\">-v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www</span><br><span class=\"line\">-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf</span><br><span class=\"line\">-v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs</span><br></pre></td></tr></table></figure></p>\n<p>// 查看nginx的文件系统</p>\n<p><code>docker inspect mynginx | grep Mounts -A 20</code></p>\n<p>// 安装Apache</p>\n<p><code>mkdir -p  ~/apache/www ~/apache/logs ~/apache/conf</code></p>\n<p>// 运行Apache</p>\n<p><code>docker run -p 80:80 -v $PWD/www/:/usr/local/apache2/htdocs/ -v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf -v $PWD/logs/:/usr/local/apache2/logs/ -d httpd</code></p>\n<p>// 删除所有容器</p>\n<p><code>sudo docker rm $(docker ps -a -q)</code></p>\n<p>// 下载容器内的文件</p>\n<p><code>docker cp ecef8319d2c8:/root/test.txt /root/</code></p>\n<p>// 上传文件到容器中</p>\n<p><code>docker cp /root/test.txt ecef8319d2c8:/root/</code></p>"},{"title":"frp 内网穿透","author":"Arclin","abbrlink":"b72542c2","date":"2018-02-18T14:05:00.000Z","_content":"frp 内网穿透\n\n<!-- more -->\n\n[文档](https://github.com/fatedier/frp/blob/master/README_zh.md)\n\n### 服务器CentOS下载安装\n\n```\nwget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_linux_amd64.tar.gz\ntar -zxvf frp_0.13.0_linux_amd64.tar.gz\ncd frp_0.13.0_linux_amd64.tar.gz\nrm -f frpc\nrm -f frpc.ini\nvi frps.ini\n```\n\n编辑frps.ini\n\n```\n[common]\nvhost_http_port = 8001 # http访问端口\nbind_port = 8009 # 远程响应的地址\ndashboard_port = 8002 #控制面板端口号\n# dashboard 用户名密码，默认都为 admin\ndashboard_user = admin\ndashboard_pwd = admin\n```\n\n### 启动服务端\n\n```\n./frps -c ./frps.ini\n```\n\n### Mac客户端下载\n\n```\nwget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_darwin_amd64.tar.gz\ntar -zxvf frp_0.13.0_darwin_amd64.tar.gz\ncd frp_0.13.0_darwin_amd64.tar.gz\nrm -f frps\nrm -f frps.ini\nvi frpc.ini\n```\n\n编辑frpc.ini\n\n```\n[common]\nserver_addr = 120.78.175.51 # 远程服务器地址\nserver_port = 8009 # 服务端填写的bind_port\n\n[web]\ntype = http \nlocal_port = 3000 # 本地要映射的端口\ncustom_domains = frp.arclin.me # 自定义的域名,需要在dnspod绑定远程主机地址\n```\n\n### 客户端运行\n\n```\n ./frpc -c ./frpc.ini\n```","source":"_posts/frp-内网穿透.md","raw":"---\ntitle: frp 内网穿透\nauthor: Arclin\ntags:\n  - frp\ncategories:\n  - Linux\nabbrlink: b72542c2\ndate: 2018-02-18 22:05:00\n---\nfrp 内网穿透\n\n<!-- more -->\n\n[文档](https://github.com/fatedier/frp/blob/master/README_zh.md)\n\n### 服务器CentOS下载安装\n\n```\nwget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_linux_amd64.tar.gz\ntar -zxvf frp_0.13.0_linux_amd64.tar.gz\ncd frp_0.13.0_linux_amd64.tar.gz\nrm -f frpc\nrm -f frpc.ini\nvi frps.ini\n```\n\n编辑frps.ini\n\n```\n[common]\nvhost_http_port = 8001 # http访问端口\nbind_port = 8009 # 远程响应的地址\ndashboard_port = 8002 #控制面板端口号\n# dashboard 用户名密码，默认都为 admin\ndashboard_user = admin\ndashboard_pwd = admin\n```\n\n### 启动服务端\n\n```\n./frps -c ./frps.ini\n```\n\n### Mac客户端下载\n\n```\nwget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_darwin_amd64.tar.gz\ntar -zxvf frp_0.13.0_darwin_amd64.tar.gz\ncd frp_0.13.0_darwin_amd64.tar.gz\nrm -f frps\nrm -f frps.ini\nvi frpc.ini\n```\n\n编辑frpc.ini\n\n```\n[common]\nserver_addr = 120.78.175.51 # 远程服务器地址\nserver_port = 8009 # 服务端填写的bind_port\n\n[web]\ntype = http \nlocal_port = 3000 # 本地要映射的端口\ncustom_domains = frp.arclin.me # 自定义的域名,需要在dnspod绑定远程主机地址\n```\n\n### 客户端运行\n\n```\n ./frpc -c ./frpc.ini\n```","slug":"frp-内网穿透","published":1,"updated":"2018-05-10T06:51:35.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcjz002fldxuwj80ayt2","content":"<p>frp 内网穿透</p>\n<a id=\"more\"></a>\n<p><a href=\"https://github.com/fatedier/frp/blob/master/README_zh.md\" target=\"_blank\" rel=\"noopener\">文档</a></p>\n<h3 id=\"服务器CentOS下载安装\"><a href=\"#服务器CentOS下载安装\" class=\"headerlink\" title=\"服务器CentOS下载安装\"></a>服务器CentOS下载安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">tar -zxvf frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">cd frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">rm -f frpc</span><br><span class=\"line\">rm -f frpc.ini</span><br><span class=\"line\">vi frps.ini</span><br></pre></td></tr></table></figure>\n<p>编辑frps.ini</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">vhost_http_port = 8001 # http访问端口</span><br><span class=\"line\">bind_port = 8009 # 远程响应的地址</span><br><span class=\"line\">dashboard_port = 8002 #控制面板端口号</span><br><span class=\"line\"># dashboard 用户名密码，默认都为 admin</span><br><span class=\"line\">dashboard_user = admin</span><br><span class=\"line\">dashboard_pwd = admin</span><br></pre></td></tr></table></figure>\n<h3 id=\"启动服务端\"><a href=\"#启动服务端\" class=\"headerlink\" title=\"启动服务端\"></a>启动服务端</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure>\n<h3 id=\"Mac客户端下载\"><a href=\"#Mac客户端下载\" class=\"headerlink\" title=\"Mac客户端下载\"></a>Mac客户端下载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">tar -zxvf frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">cd frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">rm -f frps</span><br><span class=\"line\">rm -f frps.ini</span><br><span class=\"line\">vi frpc.ini</span><br></pre></td></tr></table></figure>\n<p>编辑frpc.ini</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">server_addr = 120.78.175.51 # 远程服务器地址</span><br><span class=\"line\">server_port = 8009 # 服务端填写的bind_port</span><br><span class=\"line\"></span><br><span class=\"line\">[web]</span><br><span class=\"line\">type = http </span><br><span class=\"line\">local_port = 3000 # 本地要映射的端口</span><br><span class=\"line\">custom_domains = frp.arclin.me # 自定义的域名,需要在dnspod绑定远程主机地址</span><br></pre></td></tr></table></figure>\n<h3 id=\"客户端运行\"><a href=\"#客户端运行\" class=\"headerlink\" title=\"客户端运行\"></a>客户端运行</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>frp 内网穿透</p>","more":"<p><a href=\"https://github.com/fatedier/frp/blob/master/README_zh.md\" target=\"_blank\" rel=\"noopener\">文档</a></p>\n<h3 id=\"服务器CentOS下载安装\"><a href=\"#服务器CentOS下载安装\" class=\"headerlink\" title=\"服务器CentOS下载安装\"></a>服务器CentOS下载安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">tar -zxvf frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">cd frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">rm -f frpc</span><br><span class=\"line\">rm -f frpc.ini</span><br><span class=\"line\">vi frps.ini</span><br></pre></td></tr></table></figure>\n<p>编辑frps.ini</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">vhost_http_port = 8001 # http访问端口</span><br><span class=\"line\">bind_port = 8009 # 远程响应的地址</span><br><span class=\"line\">dashboard_port = 8002 #控制面板端口号</span><br><span class=\"line\"># dashboard 用户名密码，默认都为 admin</span><br><span class=\"line\">dashboard_user = admin</span><br><span class=\"line\">dashboard_pwd = admin</span><br></pre></td></tr></table></figure>\n<h3 id=\"启动服务端\"><a href=\"#启动服务端\" class=\"headerlink\" title=\"启动服务端\"></a>启动服务端</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure>\n<h3 id=\"Mac客户端下载\"><a href=\"#Mac客户端下载\" class=\"headerlink\" title=\"Mac客户端下载\"></a>Mac客户端下载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">tar -zxvf frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">cd frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">rm -f frps</span><br><span class=\"line\">rm -f frps.ini</span><br><span class=\"line\">vi frpc.ini</span><br></pre></td></tr></table></figure>\n<p>编辑frpc.ini</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">server_addr = 120.78.175.51 # 远程服务器地址</span><br><span class=\"line\">server_port = 8009 # 服务端填写的bind_port</span><br><span class=\"line\"></span><br><span class=\"line\">[web]</span><br><span class=\"line\">type = http </span><br><span class=\"line\">local_port = 3000 # 本地要映射的端口</span><br><span class=\"line\">custom_domains = frp.arclin.me # 自定义的域名,需要在dnspod绑定远程主机地址</span><br></pre></td></tr></table></figure>\n<h3 id=\"客户端运行\"><a href=\"#客户端运行\" class=\"headerlink\" title=\"客户端运行\"></a>客户端运行</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure>"},{"title":"Shell 笔记","author":"Arclin","abbrlink":"cfe784af","date":"2018-05-17T08:10:25.000Z","_content":"Shell 笔记，有机会写就会继续补充\n<!--more-->\n\n1. if语句的中括号要留空格  `if空格[空格 判断语句 空格]; then xxx fi` \n2. 判断买某个路径是否是文件夹  `if [ -d “./xxx” ]; then xxx fi`\n3. 建立一个数组 `check=(\"Wechat\" \"Ali\" \"Union\" \"Pay\")`\n4. 声明一个函数, 并取得第一个参数\n\t```\n    function xxx() {\n    \tdir=$1\n    }\n    ```\n5. 获得某个后缀名的文件 `directory=./${d%.*}\".app\"`\n6. 执行某个命令但不输出到控制台 `unzip $xxx > /dev/null 2>&1`\n7. 声明某个变量为局部变量，使用`local`关键字 `local dir=$1`\n8. 大写转小写 `local file_name_lower=$(echo $file_name | tr 'A-Z' 'a-z')`\n9. 小写转大写 `local file_name_lower=$(echo $file_name | tr 'a-z' 'A-Z')`\n10. 遍历数组\n  ```\n  for item in ${check[@]}; do\n      echo $item\n  done\n  ```\n11. 字符串A是否包含字符串B `if[[ $A =~ $B ]]; then xxx fi`","source":"_posts/Shell-笔记.md","raw":"title: Shell 笔记\nauthor: Arclin\nabbrlink: cfe784af\ndate: 2018-05-17 16:10:25\ntags:\n---\nShell 笔记，有机会写就会继续补充\n<!--more-->\n\n1. if语句的中括号要留空格  `if空格[空格 判断语句 空格]; then xxx fi` \n2. 判断买某个路径是否是文件夹  `if [ -d “./xxx” ]; then xxx fi`\n3. 建立一个数组 `check=(\"Wechat\" \"Ali\" \"Union\" \"Pay\")`\n4. 声明一个函数, 并取得第一个参数\n\t```\n    function xxx() {\n    \tdir=$1\n    }\n    ```\n5. 获得某个后缀名的文件 `directory=./${d%.*}\".app\"`\n6. 执行某个命令但不输出到控制台 `unzip $xxx > /dev/null 2>&1`\n7. 声明某个变量为局部变量，使用`local`关键字 `local dir=$1`\n8. 大写转小写 `local file_name_lower=$(echo $file_name | tr 'A-Z' 'a-z')`\n9. 小写转大写 `local file_name_lower=$(echo $file_name | tr 'a-z' 'A-Z')`\n10. 遍历数组\n  ```\n  for item in ${check[@]}; do\n      echo $item\n  done\n  ```\n11. 字符串A是否包含字符串B `if[[ $A =~ $B ]]; then xxx fi`","slug":"Shell-笔记","published":1,"updated":"2018-05-17T08:19:26.507Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbck3002ildxughvz0gi1","content":"<p>Shell 笔记，有机会写就会继续补充<br><a id=\"more\"></a></p>\n<ol>\n<li>if语句的中括号要留空格  <code>if空格[空格 判断语句 空格]; then xxx fi</code> </li>\n<li>判断买某个路径是否是文件夹  <code>if [ -d “./xxx” ]; then xxx fi</code></li>\n<li>建立一个数组 <code>check=(&quot;Wechat&quot; &quot;Ali&quot; &quot;Union&quot; &quot;Pay&quot;)</code></li>\n<li><p>声明一个函数, 并取得第一个参数</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function xxx() &#123;</span><br><span class=\"line\">\tdir=$1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>获得某个后缀名的文件 <code>directory=./${d%.*}&quot;.app&quot;</code></p>\n</li>\n<li>执行某个命令但不输出到控制台 <code>unzip $xxx &gt; /dev/null 2&gt;&amp;1</code></li>\n<li>声明某个变量为局部变量，使用<code>local</code>关键字 <code>local dir=$1</code></li>\n<li>大写转小写 <code>local file_name_lower=$(echo $file_name | tr &#39;A-Z&#39; &#39;a-z&#39;)</code></li>\n<li>小写转大写 <code>local file_name_lower=$(echo $file_name | tr &#39;a-z&#39; &#39;A-Z&#39;)</code></li>\n<li><p>遍历数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for item in $&#123;check[@]&#125;; do</span><br><span class=\"line\">    echo $item</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符串A是否包含字符串B <code>if[[ $A =~ $B ]]; then xxx fi</code></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Shell 笔记，有机会写就会继续补充<br>","more":"</p>\n<ol>\n<li>if语句的中括号要留空格  <code>if空格[空格 判断语句 空格]; then xxx fi</code> </li>\n<li>判断买某个路径是否是文件夹  <code>if [ -d “./xxx” ]; then xxx fi</code></li>\n<li>建立一个数组 <code>check=(&quot;Wechat&quot; &quot;Ali&quot; &quot;Union&quot; &quot;Pay&quot;)</code></li>\n<li><p>声明一个函数, 并取得第一个参数</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function xxx() &#123;</span><br><span class=\"line\">\tdir=$1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>获得某个后缀名的文件 <code>directory=./${d%.*}&quot;.app&quot;</code></p>\n</li>\n<li>执行某个命令但不输出到控制台 <code>unzip $xxx &gt; /dev/null 2&gt;&amp;1</code></li>\n<li>声明某个变量为局部变量，使用<code>local</code>关键字 <code>local dir=$1</code></li>\n<li>大写转小写 <code>local file_name_lower=$(echo $file_name | tr &#39;A-Z&#39; &#39;a-z&#39;)</code></li>\n<li>小写转大写 <code>local file_name_lower=$(echo $file_name | tr &#39;a-z&#39; &#39;A-Z&#39;)</code></li>\n<li><p>遍历数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for item in $&#123;check[@]&#125;; do</span><br><span class=\"line\">    echo $item</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符串A是否包含字符串B <code>if[[ $A =~ $B ]]; then xxx fi</code></p>\n</li>\n</ol>"},{"title":"XCode 添加Target","author":"Arclin","abbrlink":"8cafabb2","date":"2018-02-18T14:08:00.000Z","_content":"在区分开发环境和测试环境或生产环境的时候经常需要在XCode 添加Target, 所以在此记录一下\n\n<!-- more -->\n\n1. Duplicate target\n2. Change DisplayName & Bundle Identifier\n3. A copy-info.plist，默认生成在程序环境根目录，也就是`A.xcodeproj`的同级目录中，如果想放到里层（比如与`A-info.plist`放在同级目录），可以先在Xcode删除`A copy-info.plist`索引，然后拷贝文件到制定目录中，然后更名为`B-info.plist`，在add到project中。在`Project`的`Build Settings`中，修改`Info.plist` File选项为`B-info.plist`的目录（相对路径）,这样就可以看到Info页了（就是B-info.plist），接着修改`ProductName`和`Bundle identifier`，使之成为另一个app。`Prefix Header的路径`，视具体需求而定是否要修改，如果两个target可以公用同一个`Prefix Header`，那么就不需要修改这里的路径\n4. 修改scheme，在调试的Stop按钮边上，我们可以选择本工程中所有的target来做编译，如果不修改，在这里选择出来的名字就是A copy，为了与新建的target统一起来，同样也要修改这里的名字。点击scheme选择区，然后选Manager Scheme，找到A copy，然后改成你需要的名字，比如B\n5. 生成一个新的target，一定会与原target有区别，这里可以定义预编译宏，来区分两个版本的不同代码，预编译宏可以在Build Settings中Preprocessor Macros定义，比如在我们新建的target B中定义预编译宏MACRO，然后在代码中通过\n```\n\t#if defined (MACRO)\n\t//target  B需要执行的代码\n\t#else\n\t//target A需要执行的代码\n\t#endif\n```\n来区分\n6. 其他：Build Phases（各target编译所包含的内容，需要注意的是，如果创建了target B后，再往A里面添加资源或文件，target B中不会自动增加这些资源，需要手动添加）\n\t- Compile Sources\n\t需要编译的代码文件\n\t- Link Binary With Libraries\n\t编译所依赖的库\n\t- Copy Bundle Resources\n\t编译需要的资源\n\t每个target可以根据具体需要增减里面的内容\n","source":"_posts/XCode-添加Target.md","raw":"---\ntitle: XCode 添加Target\nauthor: Arclin\ntags:\n  - iOS\n  - XCode\ncategories:\n  - iOS\nabbrlink: 8cafabb2\ndate: 2018-02-18 22:08:00\n---\n在区分开发环境和测试环境或生产环境的时候经常需要在XCode 添加Target, 所以在此记录一下\n\n<!-- more -->\n\n1. Duplicate target\n2. Change DisplayName & Bundle Identifier\n3. A copy-info.plist，默认生成在程序环境根目录，也就是`A.xcodeproj`的同级目录中，如果想放到里层（比如与`A-info.plist`放在同级目录），可以先在Xcode删除`A copy-info.plist`索引，然后拷贝文件到制定目录中，然后更名为`B-info.plist`，在add到project中。在`Project`的`Build Settings`中，修改`Info.plist` File选项为`B-info.plist`的目录（相对路径）,这样就可以看到Info页了（就是B-info.plist），接着修改`ProductName`和`Bundle identifier`，使之成为另一个app。`Prefix Header的路径`，视具体需求而定是否要修改，如果两个target可以公用同一个`Prefix Header`，那么就不需要修改这里的路径\n4. 修改scheme，在调试的Stop按钮边上，我们可以选择本工程中所有的target来做编译，如果不修改，在这里选择出来的名字就是A copy，为了与新建的target统一起来，同样也要修改这里的名字。点击scheme选择区，然后选Manager Scheme，找到A copy，然后改成你需要的名字，比如B\n5. 生成一个新的target，一定会与原target有区别，这里可以定义预编译宏，来区分两个版本的不同代码，预编译宏可以在Build Settings中Preprocessor Macros定义，比如在我们新建的target B中定义预编译宏MACRO，然后在代码中通过\n```\n\t#if defined (MACRO)\n\t//target  B需要执行的代码\n\t#else\n\t//target A需要执行的代码\n\t#endif\n```\n来区分\n6. 其他：Build Phases（各target编译所包含的内容，需要注意的是，如果创建了target B后，再往A里面添加资源或文件，target B中不会自动增加这些资源，需要手动添加）\n\t- Compile Sources\n\t需要编译的代码文件\n\t- Link Binary With Libraries\n\t编译所依赖的库\n\t- Copy Bundle Resources\n\t编译需要的资源\n\t每个target可以根据具体需要增减里面的内容\n","slug":"XCode-添加Target","published":1,"updated":"2018-05-10T06:51:35.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbck6002mldxugujkp3q3","content":"<p>在区分开发环境和测试环境或生产环境的时候经常需要在XCode 添加Target, 所以在此记录一下</p>\n<a id=\"more\"></a>\n<ol>\n<li>Duplicate target</li>\n<li>Change DisplayName &amp; Bundle Identifier</li>\n<li>A copy-info.plist，默认生成在程序环境根目录，也就是<code>A.xcodeproj</code>的同级目录中，如果想放到里层（比如与<code>A-info.plist</code>放在同级目录），可以先在Xcode删除<code>A copy-info.plist</code>索引，然后拷贝文件到制定目录中，然后更名为<code>B-info.plist</code>，在add到project中。在<code>Project</code>的<code>Build Settings</code>中，修改<code>Info.plist</code> File选项为<code>B-info.plist</code>的目录（相对路径）,这样就可以看到Info页了（就是B-info.plist），接着修改<code>ProductName</code>和<code>Bundle identifier</code>，使之成为另一个app。<code>Prefix Header的路径</code>，视具体需求而定是否要修改，如果两个target可以公用同一个<code>Prefix Header</code>，那么就不需要修改这里的路径</li>\n<li>修改scheme，在调试的Stop按钮边上，我们可以选择本工程中所有的target来做编译，如果不修改，在这里选择出来的名字就是A copy，为了与新建的target统一起来，同样也要修改这里的名字。点击scheme选择区，然后选Manager Scheme，找到A copy，然后改成你需要的名字，比如B</li>\n<li>生成一个新的target，一定会与原target有区别，这里可以定义预编译宏，来区分两个版本的不同代码，预编译宏可以在Build Settings中Preprocessor Macros定义，比如在我们新建的target B中定义预编译宏MACRO，然后在代码中通过<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if defined (MACRO)</span><br><span class=\"line\">//target  B需要执行的代码</span><br><span class=\"line\">#else</span><br><span class=\"line\">//target A需要执行的代码</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>来区分</p>\n<ol>\n<li>其他：Build Phases（各target编译所包含的内容，需要注意的是，如果创建了target B后，再往A里面添加资源或文件，target B中不会自动增加这些资源，需要手动添加）<ul>\n<li>Compile Sources<br>需要编译的代码文件</li>\n<li>Link Binary With Libraries<br>编译所依赖的库</li>\n<li>Copy Bundle Resources<br>编译需要的资源<br>每个target可以根据具体需要增减里面的内容</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在区分开发环境和测试环境或生产环境的时候经常需要在XCode 添加Target, 所以在此记录一下</p>","more":"<ol>\n<li>Duplicate target</li>\n<li>Change DisplayName &amp; Bundle Identifier</li>\n<li>A copy-info.plist，默认生成在程序环境根目录，也就是<code>A.xcodeproj</code>的同级目录中，如果想放到里层（比如与<code>A-info.plist</code>放在同级目录），可以先在Xcode删除<code>A copy-info.plist</code>索引，然后拷贝文件到制定目录中，然后更名为<code>B-info.plist</code>，在add到project中。在<code>Project</code>的<code>Build Settings</code>中，修改<code>Info.plist</code> File选项为<code>B-info.plist</code>的目录（相对路径）,这样就可以看到Info页了（就是B-info.plist），接着修改<code>ProductName</code>和<code>Bundle identifier</code>，使之成为另一个app。<code>Prefix Header的路径</code>，视具体需求而定是否要修改，如果两个target可以公用同一个<code>Prefix Header</code>，那么就不需要修改这里的路径</li>\n<li>修改scheme，在调试的Stop按钮边上，我们可以选择本工程中所有的target来做编译，如果不修改，在这里选择出来的名字就是A copy，为了与新建的target统一起来，同样也要修改这里的名字。点击scheme选择区，然后选Manager Scheme，找到A copy，然后改成你需要的名字，比如B</li>\n<li>生成一个新的target，一定会与原target有区别，这里可以定义预编译宏，来区分两个版本的不同代码，预编译宏可以在Build Settings中Preprocessor Macros定义，比如在我们新建的target B中定义预编译宏MACRO，然后在代码中通过<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if defined (MACRO)</span><br><span class=\"line\">//target  B需要执行的代码</span><br><span class=\"line\">#else</span><br><span class=\"line\">//target A需要执行的代码</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>来区分</p>\n<ol>\n<li>其他：Build Phases（各target编译所包含的内容，需要注意的是，如果创建了target B后，再往A里面添加资源或文件，target B中不会自动增加这些资源，需要手动添加）<ul>\n<li>Compile Sources<br>需要编译的代码文件</li>\n<li>Link Binary With Libraries<br>编译所依赖的库</li>\n<li>Copy Bundle Resources<br>编译需要的资源<br>每个target可以根据具体需要增减里面的内容</li>\n</ul>\n</li>\n</ol>"},{"title":"iOS从服务器下载DAE文件并动态加载到SCNScene","author":"Arclin","abbrlink":"8c9c88ab","date":"2017-02-22T16:00:00.000Z","_content":"ViewController 已有 SCNScene,怎么从服务器下载3D模型文件(DAE)然后加载到这个 SCNScene呢？\n\n<!-- more -->\n\n1. 由于 `SCNScene` 不支持动态加载 DAE 文件，或者说不支持动态加载 `COLLADA` 方案下的所有3d 类型，但是测试发现直接把 DAE 文件放进 `arc.scnassets` 文件夹下的时候是可以加载的，可见系统编译的时候应该是做了某些手脚，查询资料后发现系统是执行了两个脚本，两个脚本的路径分别是`/Applications/Xcode.app/Contents/Developer/usr/bin/copySceneKitAssets`和\n`/Applications/Xcode.app/Contents/Developer/usr/bin/scntool` 所以先把这两个文件拷出来\n\n2. 新建一个文件夹，命名是 自定义名字.scnassets,例如abc.scnassets\n\n3. 把模型文件放在里面,然后在这个文件夹外面放上copySceneKitAssets和scntool\n4. 终端执行./copySceneKitAssets abc.scnassets -o abc-o.scnassets 如果没问题的话就会生成一个 abc-o.scnassets 文件夹\n5. 打包 zip 上传服务器\n6. 代码下载 zip包,解压,然后载入文件\n\n```\ndocumentsDirectoryURL = [documentsDirectoryURL URLByAppendingPathComponent:@\"abc-o.scnassets/test.dae\"];\nSCNSceneSource *sceneSource = [SCNSceneSource sceneSourceWithURL:documentsDirectoryURL options:nil];\nSCNNode *theCube = [sceneSource entryWithIdentifier:@\"Cube\" withClass:[SCNNode class]];\n```\n或者使用SCNScene这个方法\n\n```\n+ (nullable instancetype)sceneWithURL:(NSURL *)url options:(nullable NSDictionary<SCNSceneSourceLoadingOption, id> *)options error:(NSError **)error;\n```\n也是可以的\n\n","source":"_posts/iOS从服务器下载DAE文件并动态加载到SCNScene.md","raw":"---\ntitle: iOS从服务器下载DAE文件并动态加载到SCNScene\nauthor: Arclin\ntags:\n  - iOS\n  - Scene Kit\n  - ''\ncategories:\n  - iOS\nabbrlink: 8c9c88ab\ndate: 2017-02-23 00:00:00\n---\nViewController 已有 SCNScene,怎么从服务器下载3D模型文件(DAE)然后加载到这个 SCNScene呢？\n\n<!-- more -->\n\n1. 由于 `SCNScene` 不支持动态加载 DAE 文件，或者说不支持动态加载 `COLLADA` 方案下的所有3d 类型，但是测试发现直接把 DAE 文件放进 `arc.scnassets` 文件夹下的时候是可以加载的，可见系统编译的时候应该是做了某些手脚，查询资料后发现系统是执行了两个脚本，两个脚本的路径分别是`/Applications/Xcode.app/Contents/Developer/usr/bin/copySceneKitAssets`和\n`/Applications/Xcode.app/Contents/Developer/usr/bin/scntool` 所以先把这两个文件拷出来\n\n2. 新建一个文件夹，命名是 自定义名字.scnassets,例如abc.scnassets\n\n3. 把模型文件放在里面,然后在这个文件夹外面放上copySceneKitAssets和scntool\n4. 终端执行./copySceneKitAssets abc.scnassets -o abc-o.scnassets 如果没问题的话就会生成一个 abc-o.scnassets 文件夹\n5. 打包 zip 上传服务器\n6. 代码下载 zip包,解压,然后载入文件\n\n```\ndocumentsDirectoryURL = [documentsDirectoryURL URLByAppendingPathComponent:@\"abc-o.scnassets/test.dae\"];\nSCNSceneSource *sceneSource = [SCNSceneSource sceneSourceWithURL:documentsDirectoryURL options:nil];\nSCNNode *theCube = [sceneSource entryWithIdentifier:@\"Cube\" withClass:[SCNNode class]];\n```\n或者使用SCNScene这个方法\n\n```\n+ (nullable instancetype)sceneWithURL:(NSURL *)url options:(nullable NSDictionary<SCNSceneSourceLoadingOption, id> *)options error:(NSError **)error;\n```\n也是可以的\n\n","slug":"iOS从服务器下载DAE文件并动态加载到SCNScene","published":1,"updated":"2018-05-10T06:51:35.747Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbck9002pldxua51gv493","content":"<p>ViewController 已有 SCNScene,怎么从服务器下载3D模型文件(DAE)然后加载到这个 SCNScene呢？</p>\n<a id=\"more\"></a>\n<ol>\n<li><p>由于 <code>SCNScene</code> 不支持动态加载 DAE 文件，或者说不支持动态加载 <code>COLLADA</code> 方案下的所有3d 类型，但是测试发现直接把 DAE 文件放进 <code>arc.scnassets</code> 文件夹下的时候是可以加载的，可见系统编译的时候应该是做了某些手脚，查询资料后发现系统是执行了两个脚本，两个脚本的路径分别是<code>/Applications/Xcode.app/Contents/Developer/usr/bin/copySceneKitAssets</code>和<br><code>/Applications/Xcode.app/Contents/Developer/usr/bin/scntool</code> 所以先把这两个文件拷出来</p>\n</li>\n<li><p>新建一个文件夹，命名是 自定义名字.scnassets,例如abc.scnassets</p>\n</li>\n<li><p>把模型文件放在里面,然后在这个文件夹外面放上copySceneKitAssets和scntool</p>\n</li>\n<li>终端执行./copySceneKitAssets abc.scnassets -o abc-o.scnassets 如果没问题的话就会生成一个 abc-o.scnassets 文件夹</li>\n<li>打包 zip 上传服务器</li>\n<li>代码下载 zip包,解压,然后载入文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">documentsDirectoryURL = [documentsDirectoryURL URLByAppendingPathComponent:@&quot;abc-o.scnassets/test.dae&quot;];</span><br><span class=\"line\">SCNSceneSource *sceneSource = [SCNSceneSource sceneSourceWithURL:documentsDirectoryURL options:nil];</span><br><span class=\"line\">SCNNode *theCube = [sceneSource entryWithIdentifier:@&quot;Cube&quot; withClass:[SCNNode class]];</span><br></pre></td></tr></table></figure>\n<p>或者使用SCNScene这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (nullable instancetype)sceneWithURL:(NSURL *)url options:(nullable NSDictionary&lt;SCNSceneSourceLoadingOption, id&gt; *)options error:(NSError **)error;</span><br></pre></td></tr></table></figure>\n<p>也是可以的</p>\n","site":{"data":{}},"excerpt":"<p>ViewController 已有 SCNScene,怎么从服务器下载3D模型文件(DAE)然后加载到这个 SCNScene呢？</p>","more":"<ol>\n<li><p>由于 <code>SCNScene</code> 不支持动态加载 DAE 文件，或者说不支持动态加载 <code>COLLADA</code> 方案下的所有3d 类型，但是测试发现直接把 DAE 文件放进 <code>arc.scnassets</code> 文件夹下的时候是可以加载的，可见系统编译的时候应该是做了某些手脚，查询资料后发现系统是执行了两个脚本，两个脚本的路径分别是<code>/Applications/Xcode.app/Contents/Developer/usr/bin/copySceneKitAssets</code>和<br><code>/Applications/Xcode.app/Contents/Developer/usr/bin/scntool</code> 所以先把这两个文件拷出来</p>\n</li>\n<li><p>新建一个文件夹，命名是 自定义名字.scnassets,例如abc.scnassets</p>\n</li>\n<li><p>把模型文件放在里面,然后在这个文件夹外面放上copySceneKitAssets和scntool</p>\n</li>\n<li>终端执行./copySceneKitAssets abc.scnassets -o abc-o.scnassets 如果没问题的话就会生成一个 abc-o.scnassets 文件夹</li>\n<li>打包 zip 上传服务器</li>\n<li>代码下载 zip包,解压,然后载入文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">documentsDirectoryURL = [documentsDirectoryURL URLByAppendingPathComponent:@&quot;abc-o.scnassets/test.dae&quot;];</span><br><span class=\"line\">SCNSceneSource *sceneSource = [SCNSceneSource sceneSourceWithURL:documentsDirectoryURL options:nil];</span><br><span class=\"line\">SCNNode *theCube = [sceneSource entryWithIdentifier:@&quot;Cube&quot; withClass:[SCNNode class]];</span><br></pre></td></tr></table></figure>\n<p>或者使用SCNScene这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (nullable instancetype)sceneWithURL:(NSURL *)url options:(nullable NSDictionary&lt;SCNSceneSourceLoadingOption, id&gt; *)options error:(NSError **)error;</span><br></pre></td></tr></table></figure>\n<p>也是可以的</p>"},{"title":"iOS基于Navigation-Base-on-ViewModel的路由搭建——HOOK方式实现","author":"Arclin","abbrlink":"b111382b","date":"2017-01-04T16:00:00.000Z","_content":"本文主要讲述的是在 iOS 中使用 MVVM 架构开发的情况下，将 ViewModel 作为行为驱动主体，通过 Hook 的方式，设计一个 App 的路由层\n\n<!-- more -->\n\n- 什么是路由\n\n\t- 路由在服务端指的是url请求的分层解析，将一个请求分发到对应的应用处理程序。\n在移动端指的是将 App 内页面访问、H5与App之间和访问请求和 App之间的访问请求 进行分发的逻辑层。\n\n- 在移动端中路由需要做什么事情\n\n\t- 针对网络上的各种说法，这里做一下简要说明：\n\t\t- 提供接口供外部访问，这里的”外部”指的可能是App内的一个ViewController，也有可能是其他应用（包括系统应用），也有可能是 H5页面。\n分发资源。路由不需要依赖外部的资源的定义，就可以将资源传递给目的地。（‘资源’在这里指的是原生页面、模块、组件等等）\n\t\t- 统一的标识符（或者统一格式的标识符）去标识资源，并且可以通过这些标示符去统一访问请求的过程。\n\t\t- 解决安全访问的问题，如果是外部的H5、App去访问你的 App,那么就得特别注意这个问题。（本文暂不提及这个问题）\n\n- 在移动端中路由的使用场景\n\n\t- 原生界面之间，模块之间与组件之间的交互（例如页面的跳转之类）\n\t- H5页面与原生界面之间的交互\n\t- 解除业务依赖\n\t- 组件化开发\n\n- iOS自带的系统访问方式、统一的连接协议\n\n\t- 苹果开发了[URLScheme](https://developer.apple.com/library/content/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899)这种东西，使得 App 能够在沙盒机制的前提下互相调用，定义URL-Scheme的方式如下\n> - 协议部分来标示App应用\n> - 主机Host部分用于标示业务线或者是应用提供的划分好的服务实体，比方说index、discover是业务条线，api-asycn是对外提供的api，pushService是App内部的推送服务等。\n> - 路径部分则可以是细分的页面、组件或者服务的标示\n> - 参数定义有一些是必要的，比如说action来标示动作，比方说可以使用get标示获取、insert增加，userToken表示安全的用户令牌，source表示来源，当然像是userToken与source这些都是路由层需要进行解析和验证的，而action则是业务相关的参数，这一点在路由曾设计的时候需要进行详细区分\n\n- 讲完了路由的概念，接下来谈谈 路由设计\n\t- 我们先抽取最常见的页面跳转来讲，因为我们使用的是 MVVM,那么从理论上来讲，我们就应该让App以 ViewModel为驱动进行运作，而不是用 ViewController,之前说 ViewController 在跳转的时候只需要关心跳转过去的界面是否是一个 UIViewController 的子类，而不需要关心这个 viewController的具体细节,所以考虑用 ViewModel把 目的 ViewController 传递到当前 ViewController，但是ViewModel 严格来讲不能引入任何 UIKit 的任何内容，不然ViewModel级就会失去其可测试性，所以我们通过引入服务总线的概念，维护一个NavigationController 的堆栈（这个思想来自于雷纯锋的博客中的一篇文章[MVVM With ReactiveCocoa](http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/)）具体实现如下\n\n```\n//这个是协议声明部分\n@protocol MRCNavigationProtocol <NSObject>\n- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated;\n- (void)popViewModelAnimated:(BOOL)animated;\n- (void)popToRootViewModelAnimated:(BOOL)animated;\n- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion;\n- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion;\n- (void)resetRootViewModel:(MRCViewModel *)viewModel;\n@end\n```\n  \n以下是方法的实现部分，没有写任何方法的实现过程，只是进行了空操作，目的是使用 Hook 思想去捕获操作\n  \n```\n- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated {}\n- (void)popViewModelAnimated:(BOOL)animated {}\n- (void)popToRootViewModelAnimated:(BOOL)animated {}\n- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion {}\n- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion {}\n- (void)resetRootViewModel:(MRCViewModel *)viewModel {}\n```\n\n栈顶的 NavigationController 进行 Hook 并执行真正的跳转操作(使用到了 ReactiveCocoa， 因为要捕获的方法太多，这里只列举两条)\n\n```\n- (void)registerNavigationHooks {\n  \t @weakify(self)\n    [[(NSObject *)self.services\n        rac_signalForSelector:@selector(pushViewModel:animated:)]\n        subscribeNext:^(RACTuple *tuple) {\n            @strongify(self)\n            UIViewController *viewController = (UIViewController *)[MRCRouter.sharedInstance viewControllerForViewModel:tuple.first];\n            [self.navigationControllers.lastObject pushViewController:viewController animated:[tuple.second boolValue]];\n        }];\n    [[(NSObject *)self.services\n        rac_signalForSelector:@selector(popViewModelAnimated:)]\n        subscribeNext:^(RACTuple *tuple) {\n          @strongify(self)\n            [self.navigationControllers.lastObject popViewControllerAnimated:[tuple.first boolValue]];\n    }];\n}\n```\n\n实际在 ViewController 里面调用起来就会是这种感觉\n\n```\n- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {\n    [tableView deselectRowAtIndexPath:indexPath animated:YES];\n    if (indexPath.section == 0) {\n        MRCTrendingViewModel *trendingViewModel = [[MRCTrendingViewModel alloc] initWithServices:self.viewModel.services params:nil];\n        [self.viewModel.services pushViewModel:trendingViewModel animated:YES];\n    }\n}\n```\n\n然后看下将ViewModel与 ViewController 关联起来的 路由内的映射(截取部分)\n\n```\n- (NSDictionary *)viewModelViewMappings {\n   return @{\n   \t   @\"MRCLoginViewModel\": @\"MRCLoginViewController\",\n      @\"MRCHomepageViewModel\": @\"MRCHomepageViewController\",\n      @\"MRCRepoDetailViewModel\": @\"MRCRepoDetailViewController\",\n      @\"MRCWebViewModel\": @\"MRCWebViewController\",\n   };\n}\n```\n\n当然这上面的只是路由的实现方案1，纯粹地将 ViewController 与 ViewModel 关联起来，方案2是 建立一个路由层通过URL 的方式进行路由交互参考[一步步构建iOS路由](http://www.jianshu.com/p/3a902f274a3d)这部分我后面会讲讲我的思考。\n\n","source":"_posts/iOS基于Navigation-Base-on-ViewModel的路由搭建——HOOK方式实现.md","raw":"---\ntitle: iOS基于Navigation-Base-on-ViewModel的路由搭建——HOOK方式实现\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: b111382b\ndate: 2017-01-05 00:00:00\n---\n本文主要讲述的是在 iOS 中使用 MVVM 架构开发的情况下，将 ViewModel 作为行为驱动主体，通过 Hook 的方式，设计一个 App 的路由层\n\n<!-- more -->\n\n- 什么是路由\n\n\t- 路由在服务端指的是url请求的分层解析，将一个请求分发到对应的应用处理程序。\n在移动端指的是将 App 内页面访问、H5与App之间和访问请求和 App之间的访问请求 进行分发的逻辑层。\n\n- 在移动端中路由需要做什么事情\n\n\t- 针对网络上的各种说法，这里做一下简要说明：\n\t\t- 提供接口供外部访问，这里的”外部”指的可能是App内的一个ViewController，也有可能是其他应用（包括系统应用），也有可能是 H5页面。\n分发资源。路由不需要依赖外部的资源的定义，就可以将资源传递给目的地。（‘资源’在这里指的是原生页面、模块、组件等等）\n\t\t- 统一的标识符（或者统一格式的标识符）去标识资源，并且可以通过这些标示符去统一访问请求的过程。\n\t\t- 解决安全访问的问题，如果是外部的H5、App去访问你的 App,那么就得特别注意这个问题。（本文暂不提及这个问题）\n\n- 在移动端中路由的使用场景\n\n\t- 原生界面之间，模块之间与组件之间的交互（例如页面的跳转之类）\n\t- H5页面与原生界面之间的交互\n\t- 解除业务依赖\n\t- 组件化开发\n\n- iOS自带的系统访问方式、统一的连接协议\n\n\t- 苹果开发了[URLScheme](https://developer.apple.com/library/content/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899)这种东西，使得 App 能够在沙盒机制的前提下互相调用，定义URL-Scheme的方式如下\n> - 协议部分来标示App应用\n> - 主机Host部分用于标示业务线或者是应用提供的划分好的服务实体，比方说index、discover是业务条线，api-asycn是对外提供的api，pushService是App内部的推送服务等。\n> - 路径部分则可以是细分的页面、组件或者服务的标示\n> - 参数定义有一些是必要的，比如说action来标示动作，比方说可以使用get标示获取、insert增加，userToken表示安全的用户令牌，source表示来源，当然像是userToken与source这些都是路由层需要进行解析和验证的，而action则是业务相关的参数，这一点在路由曾设计的时候需要进行详细区分\n\n- 讲完了路由的概念，接下来谈谈 路由设计\n\t- 我们先抽取最常见的页面跳转来讲，因为我们使用的是 MVVM,那么从理论上来讲，我们就应该让App以 ViewModel为驱动进行运作，而不是用 ViewController,之前说 ViewController 在跳转的时候只需要关心跳转过去的界面是否是一个 UIViewController 的子类，而不需要关心这个 viewController的具体细节,所以考虑用 ViewModel把 目的 ViewController 传递到当前 ViewController，但是ViewModel 严格来讲不能引入任何 UIKit 的任何内容，不然ViewModel级就会失去其可测试性，所以我们通过引入服务总线的概念，维护一个NavigationController 的堆栈（这个思想来自于雷纯锋的博客中的一篇文章[MVVM With ReactiveCocoa](http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/)）具体实现如下\n\n```\n//这个是协议声明部分\n@protocol MRCNavigationProtocol <NSObject>\n- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated;\n- (void)popViewModelAnimated:(BOOL)animated;\n- (void)popToRootViewModelAnimated:(BOOL)animated;\n- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion;\n- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion;\n- (void)resetRootViewModel:(MRCViewModel *)viewModel;\n@end\n```\n  \n以下是方法的实现部分，没有写任何方法的实现过程，只是进行了空操作，目的是使用 Hook 思想去捕获操作\n  \n```\n- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated {}\n- (void)popViewModelAnimated:(BOOL)animated {}\n- (void)popToRootViewModelAnimated:(BOOL)animated {}\n- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion {}\n- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion {}\n- (void)resetRootViewModel:(MRCViewModel *)viewModel {}\n```\n\n栈顶的 NavigationController 进行 Hook 并执行真正的跳转操作(使用到了 ReactiveCocoa， 因为要捕获的方法太多，这里只列举两条)\n\n```\n- (void)registerNavigationHooks {\n  \t @weakify(self)\n    [[(NSObject *)self.services\n        rac_signalForSelector:@selector(pushViewModel:animated:)]\n        subscribeNext:^(RACTuple *tuple) {\n            @strongify(self)\n            UIViewController *viewController = (UIViewController *)[MRCRouter.sharedInstance viewControllerForViewModel:tuple.first];\n            [self.navigationControllers.lastObject pushViewController:viewController animated:[tuple.second boolValue]];\n        }];\n    [[(NSObject *)self.services\n        rac_signalForSelector:@selector(popViewModelAnimated:)]\n        subscribeNext:^(RACTuple *tuple) {\n          @strongify(self)\n            [self.navigationControllers.lastObject popViewControllerAnimated:[tuple.first boolValue]];\n    }];\n}\n```\n\n实际在 ViewController 里面调用起来就会是这种感觉\n\n```\n- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {\n    [tableView deselectRowAtIndexPath:indexPath animated:YES];\n    if (indexPath.section == 0) {\n        MRCTrendingViewModel *trendingViewModel = [[MRCTrendingViewModel alloc] initWithServices:self.viewModel.services params:nil];\n        [self.viewModel.services pushViewModel:trendingViewModel animated:YES];\n    }\n}\n```\n\n然后看下将ViewModel与 ViewController 关联起来的 路由内的映射(截取部分)\n\n```\n- (NSDictionary *)viewModelViewMappings {\n   return @{\n   \t   @\"MRCLoginViewModel\": @\"MRCLoginViewController\",\n      @\"MRCHomepageViewModel\": @\"MRCHomepageViewController\",\n      @\"MRCRepoDetailViewModel\": @\"MRCRepoDetailViewController\",\n      @\"MRCWebViewModel\": @\"MRCWebViewController\",\n   };\n}\n```\n\n当然这上面的只是路由的实现方案1，纯粹地将 ViewController 与 ViewModel 关联起来，方案2是 建立一个路由层通过URL 的方式进行路由交互参考[一步步构建iOS路由](http://www.jianshu.com/p/3a902f274a3d)这部分我后面会讲讲我的思考。\n\n","slug":"iOS基于Navigation-Base-on-ViewModel的路由搭建——HOOK方式实现","published":1,"updated":"2018-05-10T06:51:35.748Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbckc002sldxueh82f84s","content":"<p>本文主要讲述的是在 iOS 中使用 MVVM 架构开发的情况下，将 ViewModel 作为行为驱动主体，通过 Hook 的方式，设计一个 App 的路由层</p>\n<a id=\"more\"></a>\n<ul>\n<li><p>什么是路由</p>\n<ul>\n<li>路由在服务端指的是url请求的分层解析，将一个请求分发到对应的应用处理程序。<br>在移动端指的是将 App 内页面访问、H5与App之间和访问请求和 App之间的访问请求 进行分发的逻辑层。</li>\n</ul>\n</li>\n<li><p>在移动端中路由需要做什么事情</p>\n<ul>\n<li>针对网络上的各种说法，这里做一下简要说明：<ul>\n<li>提供接口供外部访问，这里的”外部”指的可能是App内的一个ViewController，也有可能是其他应用（包括系统应用），也有可能是 H5页面。<br>分发资源。路由不需要依赖外部的资源的定义，就可以将资源传递给目的地。（‘资源’在这里指的是原生页面、模块、组件等等）</li>\n<li>统一的标识符（或者统一格式的标识符）去标识资源，并且可以通过这些标示符去统一访问请求的过程。</li>\n<li>解决安全访问的问题，如果是外部的H5、App去访问你的 App,那么就得特别注意这个问题。（本文暂不提及这个问题）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>在移动端中路由的使用场景</p>\n<ul>\n<li>原生界面之间，模块之间与组件之间的交互（例如页面的跳转之类）</li>\n<li>H5页面与原生界面之间的交互</li>\n<li>解除业务依赖</li>\n<li>组件化开发</li>\n</ul>\n</li>\n<li><p>iOS自带的系统访问方式、统一的连接协议</p>\n<ul>\n<li>苹果开发了<a href=\"https://developer.apple.com/library/content/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899\" target=\"_blank\" rel=\"noopener\">URLScheme</a>这种东西，使得 App 能够在沙盒机制的前提下互相调用，定义URL-Scheme的方式如下<blockquote>\n<ul>\n<li>协议部分来标示App应用</li>\n<li>主机Host部分用于标示业务线或者是应用提供的划分好的服务实体，比方说index、discover是业务条线，api-asycn是对外提供的api，pushService是App内部的推送服务等。</li>\n<li>路径部分则可以是细分的页面、组件或者服务的标示</li>\n<li>参数定义有一些是必要的，比如说action来标示动作，比方说可以使用get标示获取、insert增加，userToken表示安全的用户令牌，source表示来源，当然像是userToken与source这些都是路由层需要进行解析和验证的，而action则是业务相关的参数，这一点在路由曾设计的时候需要进行详细区分</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>讲完了路由的概念，接下来谈谈 路由设计</p>\n<ul>\n<li>我们先抽取最常见的页面跳转来讲，因为我们使用的是 MVVM,那么从理论上来讲，我们就应该让App以 ViewModel为驱动进行运作，而不是用 ViewController,之前说 ViewController 在跳转的时候只需要关心跳转过去的界面是否是一个 UIViewController 的子类，而不需要关心这个 viewController的具体细节,所以考虑用 ViewModel把 目的 ViewController 传递到当前 ViewController，但是ViewModel 严格来讲不能引入任何 UIKit 的任何内容，不然ViewModel级就会失去其可测试性，所以我们通过引入服务总线的概念，维护一个NavigationController 的堆栈（这个思想来自于雷纯锋的博客中的一篇文章<a href=\"http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/\" target=\"_blank\" rel=\"noopener\">MVVM With ReactiveCocoa</a>）具体实现如下</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//这个是协议声明部分</span><br><span class=\"line\">@protocol MRCNavigationProtocol &lt;NSObject&gt;</span><br><span class=\"line\">- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated;</span><br><span class=\"line\">- (void)popViewModelAnimated:(BOOL)animated;</span><br><span class=\"line\">- (void)popToRootViewModelAnimated:(BOOL)animated;</span><br><span class=\"line\">- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion;</span><br><span class=\"line\">- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion;</span><br><span class=\"line\">- (void)resetRootViewModel:(MRCViewModel *)viewModel;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>以下是方法的实现部分，没有写任何方法的实现过程，只是进行了空操作，目的是使用 Hook 思想去捕获操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)popViewModelAnimated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)popToRootViewModelAnimated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion &#123;&#125;</span><br><span class=\"line\">- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion &#123;&#125;</span><br><span class=\"line\">- (void)resetRootViewModel:(MRCViewModel *)viewModel &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>栈顶的 NavigationController 进行 Hook 并执行真正的跳转操作(使用到了 ReactiveCocoa， 因为要捕获的方法太多，这里只列举两条)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)registerNavigationHooks &#123;</span><br><span class=\"line\">  \t @weakify(self)</span><br><span class=\"line\">    [[(NSObject *)self.services</span><br><span class=\"line\">        rac_signalForSelector:@selector(pushViewModel:animated:)]</span><br><span class=\"line\">        subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">            @strongify(self)</span><br><span class=\"line\">            UIViewController *viewController = (UIViewController *)[MRCRouter.sharedInstance viewControllerForViewModel:tuple.first];</span><br><span class=\"line\">            [self.navigationControllers.lastObject pushViewController:viewController animated:[tuple.second boolValue]];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    [[(NSObject *)self.services</span><br><span class=\"line\">        rac_signalForSelector:@selector(popViewModelAnimated:)]</span><br><span class=\"line\">        subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">          @strongify(self)</span><br><span class=\"line\">            [self.navigationControllers.lastObject popViewControllerAnimated:[tuple.first boolValue]];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际在 ViewController 里面调用起来就会是这种感觉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class=\"line\">    [tableView deselectRowAtIndexPath:indexPath animated:YES];</span><br><span class=\"line\">    if (indexPath.section == 0) &#123;</span><br><span class=\"line\">        MRCTrendingViewModel *trendingViewModel = [[MRCTrendingViewModel alloc] initWithServices:self.viewModel.services params:nil];</span><br><span class=\"line\">        [self.viewModel.services pushViewModel:trendingViewModel animated:YES];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后看下将ViewModel与 ViewController 关联起来的 路由内的映射(截取部分)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSDictionary *)viewModelViewMappings &#123;</span><br><span class=\"line\">   return @&#123;</span><br><span class=\"line\">   \t   @&quot;MRCLoginViewModel&quot;: @&quot;MRCLoginViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCHomepageViewModel&quot;: @&quot;MRCHomepageViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCRepoDetailViewModel&quot;: @&quot;MRCRepoDetailViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCWebViewModel&quot;: @&quot;MRCWebViewController&quot;,</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然这上面的只是路由的实现方案1，纯粹地将 ViewController 与 ViewModel 关联起来，方案2是 建立一个路由层通过URL 的方式进行路由交互参考<a href=\"http://www.jianshu.com/p/3a902f274a3d\" target=\"_blank\" rel=\"noopener\">一步步构建iOS路由</a>这部分我后面会讲讲我的思考。</p>\n","site":{"data":{}},"excerpt":"<p>本文主要讲述的是在 iOS 中使用 MVVM 架构开发的情况下，将 ViewModel 作为行为驱动主体，通过 Hook 的方式，设计一个 App 的路由层</p>","more":"<ul>\n<li><p>什么是路由</p>\n<ul>\n<li>路由在服务端指的是url请求的分层解析，将一个请求分发到对应的应用处理程序。<br>在移动端指的是将 App 内页面访问、H5与App之间和访问请求和 App之间的访问请求 进行分发的逻辑层。</li>\n</ul>\n</li>\n<li><p>在移动端中路由需要做什么事情</p>\n<ul>\n<li>针对网络上的各种说法，这里做一下简要说明：<ul>\n<li>提供接口供外部访问，这里的”外部”指的可能是App内的一个ViewController，也有可能是其他应用（包括系统应用），也有可能是 H5页面。<br>分发资源。路由不需要依赖外部的资源的定义，就可以将资源传递给目的地。（‘资源’在这里指的是原生页面、模块、组件等等）</li>\n<li>统一的标识符（或者统一格式的标识符）去标识资源，并且可以通过这些标示符去统一访问请求的过程。</li>\n<li>解决安全访问的问题，如果是外部的H5、App去访问你的 App,那么就得特别注意这个问题。（本文暂不提及这个问题）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>在移动端中路由的使用场景</p>\n<ul>\n<li>原生界面之间，模块之间与组件之间的交互（例如页面的跳转之类）</li>\n<li>H5页面与原生界面之间的交互</li>\n<li>解除业务依赖</li>\n<li>组件化开发</li>\n</ul>\n</li>\n<li><p>iOS自带的系统访问方式、统一的连接协议</p>\n<ul>\n<li>苹果开发了<a href=\"https://developer.apple.com/library/content/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899\" target=\"_blank\" rel=\"noopener\">URLScheme</a>这种东西，使得 App 能够在沙盒机制的前提下互相调用，定义URL-Scheme的方式如下<blockquote>\n<ul>\n<li>协议部分来标示App应用</li>\n<li>主机Host部分用于标示业务线或者是应用提供的划分好的服务实体，比方说index、discover是业务条线，api-asycn是对外提供的api，pushService是App内部的推送服务等。</li>\n<li>路径部分则可以是细分的页面、组件或者服务的标示</li>\n<li>参数定义有一些是必要的，比如说action来标示动作，比方说可以使用get标示获取、insert增加，userToken表示安全的用户令牌，source表示来源，当然像是userToken与source这些都是路由层需要进行解析和验证的，而action则是业务相关的参数，这一点在路由曾设计的时候需要进行详细区分</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>讲完了路由的概念，接下来谈谈 路由设计</p>\n<ul>\n<li>我们先抽取最常见的页面跳转来讲，因为我们使用的是 MVVM,那么从理论上来讲，我们就应该让App以 ViewModel为驱动进行运作，而不是用 ViewController,之前说 ViewController 在跳转的时候只需要关心跳转过去的界面是否是一个 UIViewController 的子类，而不需要关心这个 viewController的具体细节,所以考虑用 ViewModel把 目的 ViewController 传递到当前 ViewController，但是ViewModel 严格来讲不能引入任何 UIKit 的任何内容，不然ViewModel级就会失去其可测试性，所以我们通过引入服务总线的概念，维护一个NavigationController 的堆栈（这个思想来自于雷纯锋的博客中的一篇文章<a href=\"http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/\" target=\"_blank\" rel=\"noopener\">MVVM With ReactiveCocoa</a>）具体实现如下</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//这个是协议声明部分</span><br><span class=\"line\">@protocol MRCNavigationProtocol &lt;NSObject&gt;</span><br><span class=\"line\">- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated;</span><br><span class=\"line\">- (void)popViewModelAnimated:(BOOL)animated;</span><br><span class=\"line\">- (void)popToRootViewModelAnimated:(BOOL)animated;</span><br><span class=\"line\">- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion;</span><br><span class=\"line\">- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion;</span><br><span class=\"line\">- (void)resetRootViewModel:(MRCViewModel *)viewModel;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>以下是方法的实现部分，没有写任何方法的实现过程，只是进行了空操作，目的是使用 Hook 思想去捕获操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)popViewModelAnimated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)popToRootViewModelAnimated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion &#123;&#125;</span><br><span class=\"line\">- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion &#123;&#125;</span><br><span class=\"line\">- (void)resetRootViewModel:(MRCViewModel *)viewModel &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>栈顶的 NavigationController 进行 Hook 并执行真正的跳转操作(使用到了 ReactiveCocoa， 因为要捕获的方法太多，这里只列举两条)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)registerNavigationHooks &#123;</span><br><span class=\"line\">  \t @weakify(self)</span><br><span class=\"line\">    [[(NSObject *)self.services</span><br><span class=\"line\">        rac_signalForSelector:@selector(pushViewModel:animated:)]</span><br><span class=\"line\">        subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">            @strongify(self)</span><br><span class=\"line\">            UIViewController *viewController = (UIViewController *)[MRCRouter.sharedInstance viewControllerForViewModel:tuple.first];</span><br><span class=\"line\">            [self.navigationControllers.lastObject pushViewController:viewController animated:[tuple.second boolValue]];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    [[(NSObject *)self.services</span><br><span class=\"line\">        rac_signalForSelector:@selector(popViewModelAnimated:)]</span><br><span class=\"line\">        subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">          @strongify(self)</span><br><span class=\"line\">            [self.navigationControllers.lastObject popViewControllerAnimated:[tuple.first boolValue]];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实际在 ViewController 里面调用起来就会是这种感觉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class=\"line\">    [tableView deselectRowAtIndexPath:indexPath animated:YES];</span><br><span class=\"line\">    if (indexPath.section == 0) &#123;</span><br><span class=\"line\">        MRCTrendingViewModel *trendingViewModel = [[MRCTrendingViewModel alloc] initWithServices:self.viewModel.services params:nil];</span><br><span class=\"line\">        [self.viewModel.services pushViewModel:trendingViewModel animated:YES];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后看下将ViewModel与 ViewController 关联起来的 路由内的映射(截取部分)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSDictionary *)viewModelViewMappings &#123;</span><br><span class=\"line\">   return @&#123;</span><br><span class=\"line\">   \t   @&quot;MRCLoginViewModel&quot;: @&quot;MRCLoginViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCHomepageViewModel&quot;: @&quot;MRCHomepageViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCRepoDetailViewModel&quot;: @&quot;MRCRepoDetailViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCWebViewModel&quot;: @&quot;MRCWebViewController&quot;,</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然这上面的只是路由的实现方案1，纯粹地将 ViewController 与 ViewModel 关联起来，方案2是 建立一个路由层通过URL 的方式进行路由交互参考<a href=\"http://www.jianshu.com/p/3a902f274a3d\" target=\"_blank\" rel=\"noopener\">一步步构建iOS路由</a>这部分我后面会讲讲我的思考。</p>"},{"title":"nginx 镜像谷歌","author":"Arclin","abbrlink":"a6a89073","date":"2018-02-18T14:12:00.000Z","_content":"nginx 镜像谷歌\n\n<!-- more -->\n\n安装nginx第三方模块\n\n下载->解压->编译\n\n```\nwget  http://artfiles.org/openssl.org/source/openssl-1.1.0g.tar.gz\nwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz\nwget http://zlib.net/zlib-1.2.11.tar.gz\n\ngit clone https://github.com/nginx/nginx.git\ngit clone https://github.com/cuber/ngx_http_google_filter_module\ngit clone https://github.com/yaoweibin/ngx_http_substitutions_filter_module\n\ntar -zxvf openssl-1.1.0g.tar.gz \ntar -zxvf pcre-8.39.tar.gz \ntar -zxvf zlib-1.2.11.tar.gz\n\ncd nginx\n\n./auto/configure --with-http_v2_module --with-pcre=../pcre-8.39 --with-openssl=../openssl-1.1.0g --with-zlib=../zlib-1.2.11 --with-http_ssl_module --add-module=../ngx_http_google_filter_module --add-module=../ngx_http_substitutions_filter_module\n\nmake -j 4\n\nsudo make install\n```\n\n修改配置文件\n\n`vi /usr/local/nginx/conf/nginx.conf`\n\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    resolver 8.8.8.8;\n    location / {\n        google on;\n    }\n}\n```\n\n重启nginx\n\n```\nnginx -s reload\nservice nginx restart\n```\n\nreload 时发生错误\n\n```\nnginx: [error] open() \"/var/run/nginx.pid\" failed (2: No such file or directory)\n```\n\n解决\n\n```\nnginx -c /usr/local/nginx/conf/nginx.conf\n```\n","source":"_posts/nginx-镜像谷歌.md","raw":"---\ntitle: nginx 镜像谷歌\nauthor: Arclin\ntags:\n  - nginx\ncategories:\n  - Linux\nabbrlink: a6a89073\ndate: 2018-02-18 22:12:00\n---\nnginx 镜像谷歌\n\n<!-- more -->\n\n安装nginx第三方模块\n\n下载->解压->编译\n\n```\nwget  http://artfiles.org/openssl.org/source/openssl-1.1.0g.tar.gz\nwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz\nwget http://zlib.net/zlib-1.2.11.tar.gz\n\ngit clone https://github.com/nginx/nginx.git\ngit clone https://github.com/cuber/ngx_http_google_filter_module\ngit clone https://github.com/yaoweibin/ngx_http_substitutions_filter_module\n\ntar -zxvf openssl-1.1.0g.tar.gz \ntar -zxvf pcre-8.39.tar.gz \ntar -zxvf zlib-1.2.11.tar.gz\n\ncd nginx\n\n./auto/configure --with-http_v2_module --with-pcre=../pcre-8.39 --with-openssl=../openssl-1.1.0g --with-zlib=../zlib-1.2.11 --with-http_ssl_module --add-module=../ngx_http_google_filter_module --add-module=../ngx_http_substitutions_filter_module\n\nmake -j 4\n\nsudo make install\n```\n\n修改配置文件\n\n`vi /usr/local/nginx/conf/nginx.conf`\n\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    resolver 8.8.8.8;\n    location / {\n        google on;\n    }\n}\n```\n\n重启nginx\n\n```\nnginx -s reload\nservice nginx restart\n```\n\nreload 时发生错误\n\n```\nnginx: [error] open() \"/var/run/nginx.pid\" failed (2: No such file or directory)\n```\n\n解决\n\n```\nnginx -c /usr/local/nginx/conf/nginx.conf\n```\n","slug":"nginx-镜像谷歌","published":1,"updated":"2018-05-10T06:51:35.751Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcki002vldxu1eccwe0l","content":"<p>nginx 镜像谷歌</p>\n<a id=\"more\"></a>\n<p>安装nginx第三方模块</p>\n<p>下载-&gt;解压-&gt;编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget  http://artfiles.org/openssl.org/source/openssl-1.1.0g.tar.gz</span><br><span class=\"line\">wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz</span><br><span class=\"line\">wget http://zlib.net/zlib-1.2.11.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">git clone https://github.com/nginx/nginx.git</span><br><span class=\"line\">git clone https://github.com/cuber/ngx_http_google_filter_module</span><br><span class=\"line\">git clone https://github.com/yaoweibin/ngx_http_substitutions_filter_module</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf openssl-1.1.0g.tar.gz </span><br><span class=\"line\">tar -zxvf pcre-8.39.tar.gz </span><br><span class=\"line\">tar -zxvf zlib-1.2.11.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">cd nginx</span><br><span class=\"line\"></span><br><span class=\"line\">./auto/configure --with-http_v2_module --with-pcre=../pcre-8.39 --with-openssl=../openssl-1.1.0g --with-zlib=../zlib-1.2.11 --with-http_ssl_module --add-module=../ngx_http_google_filter_module --add-module=../ngx_http_substitutions_filter_module</span><br><span class=\"line\"></span><br><span class=\"line\">make -j 4</span><br><span class=\"line\"></span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure>\n<p>修改配置文件</p>\n<p><code>vi /usr/local/nginx/conf/nginx.conf</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重启nginx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br><span class=\"line\">service nginx restart</span><br></pre></td></tr></table></figure>\n<p>reload 时发生错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx: [error] open() &quot;/var/run/nginx.pid&quot; failed (2: No such file or directory)</span><br></pre></td></tr></table></figure>\n<p>解决</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>nginx 镜像谷歌</p>","more":"<p>安装nginx第三方模块</p>\n<p>下载-&gt;解压-&gt;编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget  http://artfiles.org/openssl.org/source/openssl-1.1.0g.tar.gz</span><br><span class=\"line\">wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz</span><br><span class=\"line\">wget http://zlib.net/zlib-1.2.11.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">git clone https://github.com/nginx/nginx.git</span><br><span class=\"line\">git clone https://github.com/cuber/ngx_http_google_filter_module</span><br><span class=\"line\">git clone https://github.com/yaoweibin/ngx_http_substitutions_filter_module</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf openssl-1.1.0g.tar.gz </span><br><span class=\"line\">tar -zxvf pcre-8.39.tar.gz </span><br><span class=\"line\">tar -zxvf zlib-1.2.11.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">cd nginx</span><br><span class=\"line\"></span><br><span class=\"line\">./auto/configure --with-http_v2_module --with-pcre=../pcre-8.39 --with-openssl=../openssl-1.1.0g --with-zlib=../zlib-1.2.11 --with-http_ssl_module --add-module=../ngx_http_google_filter_module --add-module=../ngx_http_substitutions_filter_module</span><br><span class=\"line\"></span><br><span class=\"line\">make -j 4</span><br><span class=\"line\"></span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure>\n<p>修改配置文件</p>\n<p><code>vi /usr/local/nginx/conf/nginx.conf</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重启nginx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br><span class=\"line\">service nginx restart</span><br></pre></td></tr></table></figure>\n<p>reload 时发生错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx: [error] open() &quot;/var/run/nginx.pid&quot; failed (2: No such file or directory)</span><br></pre></td></tr></table></figure>\n<p>解决</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>"},{"title":"ipad和iphone使用UIAlertViewController","author":"Arclin","abbrlink":"f0080c3e","date":"2016-10-16T16:00:00.000Z","_content":"ipad和iphone使用UIAlertViewController\n\n```\nid aController;\n    if(DKDeviceiPad){\n    alertC.modalPresentationStyle = UIModalPresentationPopover;\n    UIPopoverPresentationController *popPc = alertC.popoverPresentationController;\n    popPc.barButtonItem = self.downloadItem;\n    popPc.permittedArrowDirections = UIPopoverArrowDirectionAny;\n    aController = alertC;\n}else{\n    aController = alertC;\n}\n[window.rootViewController presentViewController:aController animated:YES completion:nil];\n```","source":"_posts/ipad和iphone使用UIAlertViewController.md","raw":"---\ntitle: ipad和iphone使用UIAlertViewController\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: f0080c3e\ndate: 2016-10-17 00:00:00\n---\nipad和iphone使用UIAlertViewController\n\n```\nid aController;\n    if(DKDeviceiPad){\n    alertC.modalPresentationStyle = UIModalPresentationPopover;\n    UIPopoverPresentationController *popPc = alertC.popoverPresentationController;\n    popPc.barButtonItem = self.downloadItem;\n    popPc.permittedArrowDirections = UIPopoverArrowDirectionAny;\n    aController = alertC;\n}else{\n    aController = alertC;\n}\n[window.rootViewController presentViewController:aController animated:YES completion:nil];\n```","slug":"ipad和iphone使用UIAlertViewController","published":1,"updated":"2018-05-10T06:51:35.750Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbckl002zldxuspyi9ipf","content":"<p>ipad和iphone使用UIAlertViewController</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id aController;</span><br><span class=\"line\">    if(DKDeviceiPad)&#123;</span><br><span class=\"line\">    alertC.modalPresentationStyle = UIModalPresentationPopover;</span><br><span class=\"line\">    UIPopoverPresentationController *popPc = alertC.popoverPresentationController;</span><br><span class=\"line\">    popPc.barButtonItem = self.downloadItem;</span><br><span class=\"line\">    popPc.permittedArrowDirections = UIPopoverArrowDirectionAny;</span><br><span class=\"line\">    aController = alertC;</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">    aController = alertC;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[window.rootViewController presentViewController:aController animated:YES completion:nil];</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>ipad和iphone使用UIAlertViewController</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id aController;</span><br><span class=\"line\">    if(DKDeviceiPad)&#123;</span><br><span class=\"line\">    alertC.modalPresentationStyle = UIModalPresentationPopover;</span><br><span class=\"line\">    UIPopoverPresentationController *popPc = alertC.popoverPresentationController;</span><br><span class=\"line\">    popPc.barButtonItem = self.downloadItem;</span><br><span class=\"line\">    popPc.permittedArrowDirections = UIPopoverArrowDirectionAny;</span><br><span class=\"line\">    aController = alertC;</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">    aController = alertC;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[window.rootViewController presentViewController:aController animated:YES completion:nil];</span><br></pre></td></tr></table></figure>"},{"title":"ngrok 内网穿透使用","author":"Arclin","abbrlink":"dda122f4","date":"2018-02-18T14:02:00.000Z","_content":"ngrok 内网穿透使用\n\n<!-- more -->\n\n### 安装golang\n\n```\nsudo yum install build-essential golang mercurial git\n```\n\n### 运行脚本\n\n```\ncd ~\ngit clone https://github.com/tutumcloud/ngrok.git ngrok\nexport NGROK_DOMAIN=\"ngrok.arclin.me\"\ncd ngrok\nopenssl genrsa -out rootCA.key 2048\nopenssl req -x509 -new -nodes -key rootCA.key -subj \"/CN=$NGROK_DOMAIN” -days 5000 -out rootCA.pem\nopenssl genrsa -out device.key 2048\nopenssl req -new -key device.key -subj \"/CN=$NGROK_DOMAIN” -out device.csr\nopenssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000\ncp rootCA.pem assets/client/tls/ngrokroot.crt\ncp device.crt assets/server/tls/snakeoil.crt\ncp device.key assets/server/tls/snakeoil.key\nGOOS=linux GOARCH=amd64\nmake release-server\ncd /usr/lib/golang/src/\nGOOS=darwin GOARCH=amd64 ./make.bash\ncd ~/ngrok\nGOOS=darwin GOARCH=amd64 make release-client\n```\n\n### 服务端运行脚本\n\n```\nnohup  bin/ngrokd -domain=\"ngrok.arclin.me\" -httpAddr=\":8081\" -httpsAddr=\":8082\" &\n```\n> nohub 后台运行\n\n### 客户端\n\n新建 `./ngrok.cfg` 文件写入信息\n\n```\nserver_addr:arclin.me:4443\ntrust_host_root_certs: false\n```\n\n客户端运行\n```\n./ngrok -config=./ngrok.cfg -subdomain=test 3000\n```","source":"_posts/ngrok-内网穿透使用.md","raw":"---\ntitle: ngrok 内网穿透使用\nauthor: Arclin\ntags:\n  - ngrok\ncategories:\n  - Linux\nabbrlink: dda122f4\ndate: 2018-02-18 22:02:00\n---\nngrok 内网穿透使用\n\n<!-- more -->\n\n### 安装golang\n\n```\nsudo yum install build-essential golang mercurial git\n```\n\n### 运行脚本\n\n```\ncd ~\ngit clone https://github.com/tutumcloud/ngrok.git ngrok\nexport NGROK_DOMAIN=\"ngrok.arclin.me\"\ncd ngrok\nopenssl genrsa -out rootCA.key 2048\nopenssl req -x509 -new -nodes -key rootCA.key -subj \"/CN=$NGROK_DOMAIN” -days 5000 -out rootCA.pem\nopenssl genrsa -out device.key 2048\nopenssl req -new -key device.key -subj \"/CN=$NGROK_DOMAIN” -out device.csr\nopenssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000\ncp rootCA.pem assets/client/tls/ngrokroot.crt\ncp device.crt assets/server/tls/snakeoil.crt\ncp device.key assets/server/tls/snakeoil.key\nGOOS=linux GOARCH=amd64\nmake release-server\ncd /usr/lib/golang/src/\nGOOS=darwin GOARCH=amd64 ./make.bash\ncd ~/ngrok\nGOOS=darwin GOARCH=amd64 make release-client\n```\n\n### 服务端运行脚本\n\n```\nnohup  bin/ngrokd -domain=\"ngrok.arclin.me\" -httpAddr=\":8081\" -httpsAddr=\":8082\" &\n```\n> nohub 后台运行\n\n### 客户端\n\n新建 `./ngrok.cfg` 文件写入信息\n\n```\nserver_addr:arclin.me:4443\ntrust_host_root_certs: false\n```\n\n客户端运行\n```\n./ngrok -config=./ngrok.cfg -subdomain=test 3000\n```","slug":"ngrok-内网穿透使用","published":1,"updated":"2018-05-10T06:51:35.752Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcko0032ldxuuabefgll","content":"<p>ngrok 内网穿透使用</p>\n<a id=\"more\"></a>\n<h3 id=\"安装golang\"><a href=\"#安装golang\" class=\"headerlink\" title=\"安装golang\"></a>安装golang</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install build-essential golang mercurial git</span><br></pre></td></tr></table></figure>\n<h3 id=\"运行脚本\"><a href=\"#运行脚本\" class=\"headerlink\" title=\"运行脚本\"></a>运行脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">git clone https://github.com/tutumcloud/ngrok.git ngrok</span><br><span class=\"line\">export NGROK_DOMAIN=&quot;ngrok.arclin.me&quot;</span><br><span class=\"line\">cd ngrok</span><br><span class=\"line\">openssl genrsa -out rootCA.key 2048</span><br><span class=\"line\">openssl req -x509 -new -nodes -key rootCA.key -subj &quot;/CN=$NGROK_DOMAIN” -days 5000 -out rootCA.pem</span><br><span class=\"line\">openssl genrsa -out device.key 2048</span><br><span class=\"line\">openssl req -new -key device.key -subj &quot;/CN=$NGROK_DOMAIN” -out device.csr</span><br><span class=\"line\">openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br><span class=\"line\">cp rootCA.pem assets/client/tls/ngrokroot.crt</span><br><span class=\"line\">cp device.crt assets/server/tls/snakeoil.crt</span><br><span class=\"line\">cp device.key assets/server/tls/snakeoil.key</span><br><span class=\"line\">GOOS=linux GOARCH=amd64</span><br><span class=\"line\">make release-server</span><br><span class=\"line\">cd /usr/lib/golang/src/</span><br><span class=\"line\">GOOS=darwin GOARCH=amd64 ./make.bash</span><br><span class=\"line\">cd ~/ngrok</span><br><span class=\"line\">GOOS=darwin GOARCH=amd64 make release-client</span><br></pre></td></tr></table></figure>\n<h3 id=\"服务端运行脚本\"><a href=\"#服务端运行脚本\" class=\"headerlink\" title=\"服务端运行脚本\"></a>服务端运行脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup  bin/ngrokd -domain=&quot;ngrok.arclin.me&quot; -httpAddr=&quot;:8081&quot; -httpsAddr=&quot;:8082&quot; &amp;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>nohub 后台运行</p>\n</blockquote>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><p>新建 <code>./ngrok.cfg</code> 文件写入信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server_addr:arclin.me:4443</span><br><span class=\"line\">trust_host_root_certs: false</span><br></pre></td></tr></table></figure>\n<p>客户端运行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./ngrok -config=./ngrok.cfg -subdomain=test 3000</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>ngrok 内网穿透使用</p>","more":"<h3 id=\"安装golang\"><a href=\"#安装golang\" class=\"headerlink\" title=\"安装golang\"></a>安装golang</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install build-essential golang mercurial git</span><br></pre></td></tr></table></figure>\n<h3 id=\"运行脚本\"><a href=\"#运行脚本\" class=\"headerlink\" title=\"运行脚本\"></a>运行脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">git clone https://github.com/tutumcloud/ngrok.git ngrok</span><br><span class=\"line\">export NGROK_DOMAIN=&quot;ngrok.arclin.me&quot;</span><br><span class=\"line\">cd ngrok</span><br><span class=\"line\">openssl genrsa -out rootCA.key 2048</span><br><span class=\"line\">openssl req -x509 -new -nodes -key rootCA.key -subj &quot;/CN=$NGROK_DOMAIN” -days 5000 -out rootCA.pem</span><br><span class=\"line\">openssl genrsa -out device.key 2048</span><br><span class=\"line\">openssl req -new -key device.key -subj &quot;/CN=$NGROK_DOMAIN” -out device.csr</span><br><span class=\"line\">openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br><span class=\"line\">cp rootCA.pem assets/client/tls/ngrokroot.crt</span><br><span class=\"line\">cp device.crt assets/server/tls/snakeoil.crt</span><br><span class=\"line\">cp device.key assets/server/tls/snakeoil.key</span><br><span class=\"line\">GOOS=linux GOARCH=amd64</span><br><span class=\"line\">make release-server</span><br><span class=\"line\">cd /usr/lib/golang/src/</span><br><span class=\"line\">GOOS=darwin GOARCH=amd64 ./make.bash</span><br><span class=\"line\">cd ~/ngrok</span><br><span class=\"line\">GOOS=darwin GOARCH=amd64 make release-client</span><br></pre></td></tr></table></figure>\n<h3 id=\"服务端运行脚本\"><a href=\"#服务端运行脚本\" class=\"headerlink\" title=\"服务端运行脚本\"></a>服务端运行脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup  bin/ngrokd -domain=&quot;ngrok.arclin.me&quot; -httpAddr=&quot;:8081&quot; -httpsAddr=&quot;:8082&quot; &amp;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>nohub 后台运行</p>\n</blockquote>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><p>新建 <code>./ngrok.cfg</code> 文件写入信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server_addr:arclin.me:4443</span><br><span class=\"line\">trust_host_root_certs: false</span><br></pre></td></tr></table></figure>\n<p>客户端运行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./ngrok -config=./ngrok.cfg -subdomain=test 3000</span><br></pre></td></tr></table></figure></p>"},{"title":"pan手势判断方向","author":"Arclin","abbrlink":"34db2dbc","date":"2016-10-16T16:00:00.000Z","_content":"pan手势判断方向\n\n```\nUIPanGestureRecognizer *pan = (UIPanGestureRecognizer *)gestureRecognizer;\nCGPoint point = [pan translationInView:gestureRecognizer.view]; // point.x < 0 左滑\n```","source":"_posts/pan手势判断方向.md","raw":"---\ntitle: pan手势判断方向\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 34db2dbc\ndate: 2016-10-17 00:00:00\n---\npan手势判断方向\n\n```\nUIPanGestureRecognizer *pan = (UIPanGestureRecognizer *)gestureRecognizer;\nCGPoint point = [pan translationInView:gestureRecognizer.view]; // point.x < 0 左滑\n```","slug":"pan手势判断方向","published":1,"updated":"2018-05-10T06:51:35.752Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbckq0035ldxugdnc8xlx","content":"<p>pan手势判断方向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIPanGestureRecognizer *pan = (UIPanGestureRecognizer *)gestureRecognizer;</span><br><span class=\"line\">CGPoint point = [pan translationInView:gestureRecognizer.view]; // point.x &lt; 0 左滑</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>pan手势判断方向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIPanGestureRecognizer *pan = (UIPanGestureRecognizer *)gestureRecognizer;</span><br><span class=\"line\">CGPoint point = [pan translationInView:gestureRecognizer.view]; // point.x &lt; 0 左滑</span><br></pre></td></tr></table></figure>"},{"title":"一句ipack命令解决iOS编译打包上传fir流程","author":"Arclin","abbrlink":"4edc914d","date":"2017-02-13T16:00:00.000Z","_content":"一行命令即可将包含 cocoapods 的iOS 项目编译打包并上传到 fir\n<!-- more -->\n\n### 准备工具\n - fir-cli\n - Cocopods\n \n### 功能\n\n进入任意一个有.xcodeworksapce文件的目录下，输入ipack（可以自定义）即可完成编译打包上传，加上-c 更新说明\n参数就可以填写本次打包的更新说明，这个说明会在 fir 上面显示出来\n\n### 编写shell脚本\n\nsh代码说明\n\n变量定义\n\n`basepath=$(pwd)`  命令行代码执行位置\n`bName=$(basename ${basepath})`  拿到项目文件夹名字\n`description=$(basename ${basepath})` 要写在 fir 的更新说明\n`achivepath=${basepath}'/build/'${bName}'.xcarchive'` 构建文件的储存位置\n\n`ipaPath=${basepath}'/'${bName}'.ipa'` ipa 的储存位置\n\n拿到参数\n\n```\nwhile getopts \":c:\" opt; do` # 遍历参数 虽然现在只有一个，不过为了拓展还是可以加上去\ncase $opt in\n    c ) description=\"$OPTARG\";;   # 如果参数是c 的话就把内容赋值给description\n    ? ) echo \"参数选项不正确，应该是 -c <发布内容>\"\n        exit 1;;\n    esca\ndone\n```\n\n判断命令是不是执行在有`.xcodeworksapce`文件的目录下\n\n`$(ls *.xcwork* >/dev/null 2>&1)`\n\n清除缓存\n\n```\n/usr/bin/xcodebuild -target　${bName} clean\n```\n\n编译\n\n```\n/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}\n```\n\n判断编译成功了吗\n\n`if [ ! -d ${achivepath} ];`\n\n打包\n\n/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}\n\n判断打包成功了吗\n\n`if [ ! -f ${ipaPath} ];`\n\n上传到 fir\n\n```\nfir publish ${bName}.ipa --token <你的 Fir Token> -c ${description}\n```\n\nfirToken 的位置\n\n![](/images/pasted-0.png)\n\n清理编译打包的文件\n\n```\nrm -rf ${ipaPath} ${achivepath}\n```\n\n完事\n\n执行\n如果你把 sh文件放在桌面的话，一般来说现在去到有.xcodeworksapce文件的目录下，执行\n\n```\n~/Desktop/iosPackage.sh\n```\n\n就可以了，加个参数就是\n\n```\n~/Desktop/iosPackage.sh -c \"测试测试\"`\n```\n\n但是`~/Desktop/iosPackage.sh`太长了，所以得给他加个别名\n\n所以执行\n\n```\ncd ~\ntouch .bash_profile\n```\n\n创建一个`.bash_profile`文件\n\n然后在里面填写 `alias ipack='~/Desktop/iosPackage.sh'`\n这个`ipack`你想写啥就啥\n\n然后保存之后执行\n\n`source ./bash_profile`\n\n之后就可以直接用 ipack 代替 `~/Desktop/iosPackage.sh`\n\n`ipack ipack -c \"测试测试\"`\n\nEND","source":"_posts/一句ipack命令解决iOS编译打包上传fir流程.md","raw":"---\ntitle: 一句ipack命令解决iOS编译打包上传fir流程\nauthor: Arclin\ntags:\n  - Fir\n  - shell\ncategories:\n  - iOS\nabbrlink: 4edc914d\ndate: 2017-02-14 00:00:00\n---\n一行命令即可将包含 cocoapods 的iOS 项目编译打包并上传到 fir\n<!-- more -->\n\n### 准备工具\n - fir-cli\n - Cocopods\n \n### 功能\n\n进入任意一个有.xcodeworksapce文件的目录下，输入ipack（可以自定义）即可完成编译打包上传，加上-c 更新说明\n参数就可以填写本次打包的更新说明，这个说明会在 fir 上面显示出来\n\n### 编写shell脚本\n\nsh代码说明\n\n变量定义\n\n`basepath=$(pwd)`  命令行代码执行位置\n`bName=$(basename ${basepath})`  拿到项目文件夹名字\n`description=$(basename ${basepath})` 要写在 fir 的更新说明\n`achivepath=${basepath}'/build/'${bName}'.xcarchive'` 构建文件的储存位置\n\n`ipaPath=${basepath}'/'${bName}'.ipa'` ipa 的储存位置\n\n拿到参数\n\n```\nwhile getopts \":c:\" opt; do` # 遍历参数 虽然现在只有一个，不过为了拓展还是可以加上去\ncase $opt in\n    c ) description=\"$OPTARG\";;   # 如果参数是c 的话就把内容赋值给description\n    ? ) echo \"参数选项不正确，应该是 -c <发布内容>\"\n        exit 1;;\n    esca\ndone\n```\n\n判断命令是不是执行在有`.xcodeworksapce`文件的目录下\n\n`$(ls *.xcwork* >/dev/null 2>&1)`\n\n清除缓存\n\n```\n/usr/bin/xcodebuild -target　${bName} clean\n```\n\n编译\n\n```\n/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}\n```\n\n判断编译成功了吗\n\n`if [ ! -d ${achivepath} ];`\n\n打包\n\n/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}\n\n判断打包成功了吗\n\n`if [ ! -f ${ipaPath} ];`\n\n上传到 fir\n\n```\nfir publish ${bName}.ipa --token <你的 Fir Token> -c ${description}\n```\n\nfirToken 的位置\n\n![](/images/pasted-0.png)\n\n清理编译打包的文件\n\n```\nrm -rf ${ipaPath} ${achivepath}\n```\n\n完事\n\n执行\n如果你把 sh文件放在桌面的话，一般来说现在去到有.xcodeworksapce文件的目录下，执行\n\n```\n~/Desktop/iosPackage.sh\n```\n\n就可以了，加个参数就是\n\n```\n~/Desktop/iosPackage.sh -c \"测试测试\"`\n```\n\n但是`~/Desktop/iosPackage.sh`太长了，所以得给他加个别名\n\n所以执行\n\n```\ncd ~\ntouch .bash_profile\n```\n\n创建一个`.bash_profile`文件\n\n然后在里面填写 `alias ipack='~/Desktop/iosPackage.sh'`\n这个`ipack`你想写啥就啥\n\n然后保存之后执行\n\n`source ./bash_profile`\n\n之后就可以直接用 ipack 代替 `~/Desktop/iosPackage.sh`\n\n`ipack ipack -c \"测试测试\"`\n\nEND","slug":"一句ipack命令解决iOS编译打包上传fir流程","published":1,"updated":"2018-05-10T06:51:35.754Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbckt0039ldxuc6177nxs","content":"<p>一行命令即可将包含 cocoapods 的iOS 项目编译打包并上传到 fir<br><a id=\"more\"></a></p>\n<h3 id=\"准备工具\"><a href=\"#准备工具\" class=\"headerlink\" title=\"准备工具\"></a>准备工具</h3><ul>\n<li>fir-cli</li>\n<li>Cocopods</li>\n</ul>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>进入任意一个有.xcodeworksapce文件的目录下，输入ipack（可以自定义）即可完成编译打包上传，加上-c 更新说明<br>参数就可以填写本次打包的更新说明，这个说明会在 fir 上面显示出来</p>\n<h3 id=\"编写shell脚本\"><a href=\"#编写shell脚本\" class=\"headerlink\" title=\"编写shell脚本\"></a>编写shell脚本</h3><p>sh代码说明</p>\n<p>变量定义</p>\n<p><code>basepath=$(pwd)</code>  命令行代码执行位置<br><code>bName=$(basename ${basepath})</code>  拿到项目文件夹名字<br><code>description=$(basename ${basepath})</code> 要写在 fir 的更新说明<br><code>achivepath=${basepath}&#39;/build/&#39;${bName}&#39;.xcarchive&#39;</code> 构建文件的储存位置</p>\n<p><code>ipaPath=${basepath}&#39;/&#39;${bName}&#39;.ipa&#39;</code> ipa 的储存位置</p>\n<p>拿到参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while getopts &quot;:c:&quot; opt; do` # 遍历参数 虽然现在只有一个，不过为了拓展还是可以加上去</span><br><span class=\"line\">case $opt in</span><br><span class=\"line\">    c ) description=&quot;$OPTARG&quot;;;   # 如果参数是c 的话就把内容赋值给description</span><br><span class=\"line\">    ? ) echo &quot;参数选项不正确，应该是 -c &lt;发布内容&gt;&quot;</span><br><span class=\"line\">        exit 1;;</span><br><span class=\"line\">    esca</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>判断命令是不是执行在有<code>.xcodeworksapce</code>文件的目录下</p>\n<p><code>$(ls *.xcwork* &gt;/dev/null 2&gt;&amp;1)</code></p>\n<p>清除缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/xcodebuild -target　$&#123;bName&#125; clean</span><br></pre></td></tr></table></figure>\n<p>编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath $&#123;achivepath&#125; -exportPath $&#123;ipaPath&#125;</span><br></pre></td></tr></table></figure>\n<p>判断编译成功了吗</p>\n<p><code>if [ ! -d ${achivepath} ];</code></p>\n<p>打包</p>\n<p>/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}</p>\n<p>判断打包成功了吗</p>\n<p><code>if [ ! -f ${ipaPath} ];</code></p>\n<p>上传到 fir</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fir publish $&#123;bName&#125;.ipa --token &lt;你的 Fir Token&gt; -c $&#123;description&#125;</span><br></pre></td></tr></table></figure>\n<p>firToken 的位置</p>\n<p><img src=\"/images/pasted-0.png\" alt=\"\"></p>\n<p>清理编译打包的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf $&#123;ipaPath&#125; $&#123;achivepath&#125;</span><br></pre></td></tr></table></figure>\n<p>完事</p>\n<p>执行<br>如果你把 sh文件放在桌面的话，一般来说现在去到有.xcodeworksapce文件的目录下，执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/Desktop/iosPackage.sh</span><br></pre></td></tr></table></figure>\n<p>就可以了，加个参数就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/Desktop/iosPackage.sh -c &quot;测试测试&quot;`</span><br></pre></td></tr></table></figure>\n<p>但是<code>~/Desktop/iosPackage.sh</code>太长了，所以得给他加个别名</p>\n<p>所以执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">touch .bash_profile</span><br></pre></td></tr></table></figure>\n<p>创建一个<code>.bash_profile</code>文件</p>\n<p>然后在里面填写 <code>alias ipack=&#39;~/Desktop/iosPackage.sh&#39;</code><br>这个<code>ipack</code>你想写啥就啥</p>\n<p>然后保存之后执行</p>\n<p><code>source ./bash_profile</code></p>\n<p>之后就可以直接用 ipack 代替 <code>~/Desktop/iosPackage.sh</code></p>\n<p><code>ipack ipack -c &quot;测试测试&quot;</code></p>\n<p>END</p>\n","site":{"data":{}},"excerpt":"<p>一行命令即可将包含 cocoapods 的iOS 项目编译打包并上传到 fir<br>","more":"</p>\n<h3 id=\"准备工具\"><a href=\"#准备工具\" class=\"headerlink\" title=\"准备工具\"></a>准备工具</h3><ul>\n<li>fir-cli</li>\n<li>Cocopods</li>\n</ul>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>进入任意一个有.xcodeworksapce文件的目录下，输入ipack（可以自定义）即可完成编译打包上传，加上-c 更新说明<br>参数就可以填写本次打包的更新说明，这个说明会在 fir 上面显示出来</p>\n<h3 id=\"编写shell脚本\"><a href=\"#编写shell脚本\" class=\"headerlink\" title=\"编写shell脚本\"></a>编写shell脚本</h3><p>sh代码说明</p>\n<p>变量定义</p>\n<p><code>basepath=$(pwd)</code>  命令行代码执行位置<br><code>bName=$(basename ${basepath})</code>  拿到项目文件夹名字<br><code>description=$(basename ${basepath})</code> 要写在 fir 的更新说明<br><code>achivepath=${basepath}&#39;/build/&#39;${bName}&#39;.xcarchive&#39;</code> 构建文件的储存位置</p>\n<p><code>ipaPath=${basepath}&#39;/&#39;${bName}&#39;.ipa&#39;</code> ipa 的储存位置</p>\n<p>拿到参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while getopts &quot;:c:&quot; opt; do` # 遍历参数 虽然现在只有一个，不过为了拓展还是可以加上去</span><br><span class=\"line\">case $opt in</span><br><span class=\"line\">    c ) description=&quot;$OPTARG&quot;;;   # 如果参数是c 的话就把内容赋值给description</span><br><span class=\"line\">    ? ) echo &quot;参数选项不正确，应该是 -c &lt;发布内容&gt;&quot;</span><br><span class=\"line\">        exit 1;;</span><br><span class=\"line\">    esca</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>判断命令是不是执行在有<code>.xcodeworksapce</code>文件的目录下</p>\n<p><code>$(ls *.xcwork* &gt;/dev/null 2&gt;&amp;1)</code></p>\n<p>清除缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/xcodebuild -target　$&#123;bName&#125; clean</span><br></pre></td></tr></table></figure>\n<p>编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath $&#123;achivepath&#125; -exportPath $&#123;ipaPath&#125;</span><br></pre></td></tr></table></figure>\n<p>判断编译成功了吗</p>\n<p><code>if [ ! -d ${achivepath} ];</code></p>\n<p>打包</p>\n<p>/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}</p>\n<p>判断打包成功了吗</p>\n<p><code>if [ ! -f ${ipaPath} ];</code></p>\n<p>上传到 fir</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fir publish $&#123;bName&#125;.ipa --token &lt;你的 Fir Token&gt; -c $&#123;description&#125;</span><br></pre></td></tr></table></figure>\n<p>firToken 的位置</p>\n<p><img src=\"/images/pasted-0.png\" alt=\"\"></p>\n<p>清理编译打包的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf $&#123;ipaPath&#125; $&#123;achivepath&#125;</span><br></pre></td></tr></table></figure>\n<p>完事</p>\n<p>执行<br>如果你把 sh文件放在桌面的话，一般来说现在去到有.xcodeworksapce文件的目录下，执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/Desktop/iosPackage.sh</span><br></pre></td></tr></table></figure>\n<p>就可以了，加个参数就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~/Desktop/iosPackage.sh -c &quot;测试测试&quot;`</span><br></pre></td></tr></table></figure>\n<p>但是<code>~/Desktop/iosPackage.sh</code>太长了，所以得给他加个别名</p>\n<p>所以执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">touch .bash_profile</span><br></pre></td></tr></table></figure>\n<p>创建一个<code>.bash_profile</code>文件</p>\n<p>然后在里面填写 <code>alias ipack=&#39;~/Desktop/iosPackage.sh&#39;</code><br>这个<code>ipack</code>你想写啥就啥</p>\n<p>然后保存之后执行</p>\n<p><code>source ./bash_profile</code></p>\n<p>之后就可以直接用 ipack 代替 <code>~/Desktop/iosPackage.sh</code></p>\n<p><code>ipack ipack -c &quot;测试测试&quot;</code></p>\n<p>END</p>"},{"title":"使用DKHTTPTool时的异常处理","author":"Arclin","abbrlink":"7daccd39","date":"2017-01-04T16:00:00.000Z","_content":"本文主要讲述的是在使用 DKHTTPTool 时，返回异常数据时的处理\n\n<!-- more -->\n\n如果是普通调用情况的话,也即是调用这个方法\n```\n- (NSInteger)requestForMethod:(NSString *)method\n                cacheStragety:(DKCacheStrategy)strategy\n                          url:(NSString *)URLString\n                       header:(NSDictionary *)header\n                       params:(NSDictionary *)params\n                       filter:(DKHTTPRequestFilterBlock)filterBlock\n                 verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock\n                responseBlock:(DKHTTPResponseBlock)block;\n```\n\n那么捕获异常只需要拿到回调中的DKResponse中的error属性即可\n\n如果是用链式调用的方法`RACSignal`回调的话，那么就得看情况了，如果你是用 `RACCommand` 去启用网络请求的话，那么记得 `RACCommand` 是用 `errors` 属性去存储错误信号的，如果你有多个 `RACCommand` 对象建议你在 `ViewModel` 里创建一个 `RACSubject` 去统一处理错误信号，然后你可以这么写`[[RACSignal merge:@[_addParamCommand.errors,_removeParamCommand.errors,_sendCommand.errors]] subscribe:self.errors];`\n\n如果你直接取得网络请求回调中的`RACSignal`对象的话 ，直接`subscribeError:`就可以得到`NSError`对象\n关于提示错误信息，从交互的角度上来讲，我觉得友好程度\n\n`TopBarMessage(TWMessageBarManager) > HUD > ALERT`\n\n当然实际运用的时候还是得看情况，不同情况使用不同的提示方式","source":"_posts/使用DKHTTPTool时的异常处理.md","raw":"---\ntitle: 使用DKHTTPTool时的异常处理\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 7daccd39\ndate: 2017-01-05 00:00:00\n---\n本文主要讲述的是在使用 DKHTTPTool 时，返回异常数据时的处理\n\n<!-- more -->\n\n如果是普通调用情况的话,也即是调用这个方法\n```\n- (NSInteger)requestForMethod:(NSString *)method\n                cacheStragety:(DKCacheStrategy)strategy\n                          url:(NSString *)URLString\n                       header:(NSDictionary *)header\n                       params:(NSDictionary *)params\n                       filter:(DKHTTPRequestFilterBlock)filterBlock\n                 verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock\n                responseBlock:(DKHTTPResponseBlock)block;\n```\n\n那么捕获异常只需要拿到回调中的DKResponse中的error属性即可\n\n如果是用链式调用的方法`RACSignal`回调的话，那么就得看情况了，如果你是用 `RACCommand` 去启用网络请求的话，那么记得 `RACCommand` 是用 `errors` 属性去存储错误信号的，如果你有多个 `RACCommand` 对象建议你在 `ViewModel` 里创建一个 `RACSubject` 去统一处理错误信号，然后你可以这么写`[[RACSignal merge:@[_addParamCommand.errors,_removeParamCommand.errors,_sendCommand.errors]] subscribe:self.errors];`\n\n如果你直接取得网络请求回调中的`RACSignal`对象的话 ，直接`subscribeError:`就可以得到`NSError`对象\n关于提示错误信息，从交互的角度上来讲，我觉得友好程度\n\n`TopBarMessage(TWMessageBarManager) > HUD > ALERT`\n\n当然实际运用的时候还是得看情况，不同情况使用不同的提示方式","slug":"使用DKHTTPTool时的异常处理","published":1,"updated":"2018-05-10T06:51:35.756Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbckw003cldxuj4y6gdu4","content":"<p>本文主要讲述的是在使用 DKHTTPTool 时，返回异常数据时的处理</p>\n<a id=\"more\"></a>\n<p>如果是普通调用情况的话,也即是调用这个方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method</span><br><span class=\"line\">                cacheStragety:(DKCacheStrategy)strategy</span><br><span class=\"line\">                          url:(NSString *)URLString</span><br><span class=\"line\">                       header:(NSDictionary *)header</span><br><span class=\"line\">                       params:(NSDictionary *)params</span><br><span class=\"line\">                       filter:(DKHTTPRequestFilterBlock)filterBlock</span><br><span class=\"line\">                 verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock</span><br><span class=\"line\">                responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure></p>\n<p>那么捕获异常只需要拿到回调中的DKResponse中的error属性即可</p>\n<p>如果是用链式调用的方法<code>RACSignal</code>回调的话，那么就得看情况了，如果你是用 <code>RACCommand</code> 去启用网络请求的话，那么记得 <code>RACCommand</code> 是用 <code>errors</code> 属性去存储错误信号的，如果你有多个 <code>RACCommand</code> 对象建议你在 <code>ViewModel</code> 里创建一个 <code>RACSubject</code> 去统一处理错误信号，然后你可以这么写<code>[[RACSignal merge:@[_addParamCommand.errors,_removeParamCommand.errors,_sendCommand.errors]] subscribe:self.errors];</code></p>\n<p>如果你直接取得网络请求回调中的<code>RACSignal</code>对象的话 ，直接<code>subscribeError:</code>就可以得到<code>NSError</code>对象<br>关于提示错误信息，从交互的角度上来讲，我觉得友好程度</p>\n<p><code>TopBarMessage(TWMessageBarManager) &gt; HUD &gt; ALERT</code></p>\n<p>当然实际运用的时候还是得看情况，不同情况使用不同的提示方式</p>\n","site":{"data":{}},"excerpt":"<p>本文主要讲述的是在使用 DKHTTPTool 时，返回异常数据时的处理</p>","more":"<p>如果是普通调用情况的话,也即是调用这个方法<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method</span><br><span class=\"line\">                cacheStragety:(DKCacheStrategy)strategy</span><br><span class=\"line\">                          url:(NSString *)URLString</span><br><span class=\"line\">                       header:(NSDictionary *)header</span><br><span class=\"line\">                       params:(NSDictionary *)params</span><br><span class=\"line\">                       filter:(DKHTTPRequestFilterBlock)filterBlock</span><br><span class=\"line\">                 verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock</span><br><span class=\"line\">                responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure></p>\n<p>那么捕获异常只需要拿到回调中的DKResponse中的error属性即可</p>\n<p>如果是用链式调用的方法<code>RACSignal</code>回调的话，那么就得看情况了，如果你是用 <code>RACCommand</code> 去启用网络请求的话，那么记得 <code>RACCommand</code> 是用 <code>errors</code> 属性去存储错误信号的，如果你有多个 <code>RACCommand</code> 对象建议你在 <code>ViewModel</code> 里创建一个 <code>RACSubject</code> 去统一处理错误信号，然后你可以这么写<code>[[RACSignal merge:@[_addParamCommand.errors,_removeParamCommand.errors,_sendCommand.errors]] subscribe:self.errors];</code></p>\n<p>如果你直接取得网络请求回调中的<code>RACSignal</code>对象的话 ，直接<code>subscribeError:</code>就可以得到<code>NSError</code>对象<br>关于提示错误信息，从交互的角度上来讲，我觉得友好程度</p>\n<p><code>TopBarMessage(TWMessageBarManager) &gt; HUD &gt; ALERT</code></p>\n<p>当然实际运用的时候还是得看情况，不同情况使用不同的提示方式</p>"},{"title":"关于App混合开发的介绍","author":"Arclin","abbrlink":"b179ff40","date":"2017-03-13T16:00:00.000Z","_content":"![](https://ooo.0o0.ooo/2017/03/14/58c75bfb373da.png)\n\n### 前言\n\nHybrid App 混合开发意思是在web-app、native-app这两者之间的app开发,兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”, 并且也方便我们进行热修复.\n\n<!-- more -->\n\n> 跨平台就是你写一套代码,然后iOS和Android都能用,这样子可以大大节省人力成本和开发成本\n\n> 热修复就是应用发布之后你还可以通过下发补丁或者直接修改web部分代码去修改app的内容,由于iOS版本应用要上传到应用市场需要经过严格的审核,这将会花费很多时间,如果每次项目一有点小问题就重新发布上架,这将会是一场灾难,所以app的热修复技术在iOS中显得尤为重要\n\n目前比较流行的有Cordova/PhoneGap,HTML 5+,React Native,Weex,AppCan(因为这个平台在很多地方吐槽很严重所以暂时不讨论),接下来我们一个个地讨论这些开发框架.\n\n### Cordova/PhoneGap\t\n\n![Cordova logo](https://ooo.0o0.ooo/2017/03/14/58c7511a7b3cf.png)\n\n[Cordova 官网](http://cordova.apache.org/)\n\n#### 介绍\n为什么这两个要放在一起呢,因为PhoneGap被Adobe收购了,临走之前把核心代码给了Apache,Apache就把这个项目名作Cordova,所以说PhoneGap和Cordova出自同一家,他们都会被开源社区和Adobe所推动.\n\n这个框架是作为原生与web之间的中间件,它采用插件的形式调用原生模块,最后成品就是原生页面和web页面的一个混合应用,现在是一个为大多数混合应用所采用的框架,拥有广大的前景\n\n#### 优点\n用相对简单,学习成本低,对于不熟悉原生开发的前端工程师来说是不错的选择.\n\n#### 缺点\n说实话这个并不是Cordova的缺点,而是web应用共有的问题,就是页面响应迟钝和操作体验不佳的问题.但是这些问题在现在也已经有了足够多的解决方案,具体想了解可以自行上网查阅.\n\n### HTML 5+\n\n![HTML5+ logo](https://ooo.0o0.ooo/2017/03/14/58c7511a6ebea.png)\n\n[官方文档](http://ask.dcloud.net.cn/docs/)\n\n#### 介绍\nDCloud和H5中国产业联盟发起的项目,使用H5+框架自带的各种方法去进行与原生模块之间的沟通,结果产出的依然是web页面,但是\u0007性能相对比Cordova好.\n\n#### 优点\n上手简单,学习成本低,有完整的中文文档,作为移动端webView上的框架体验是很不错的,前端人员可以优先考虑使用这个框架.\n\n#### 缺点\n貌似国外基本没人知道这东西,第三方插件和资源相对较少,要是遇到问题也只能去dcloud社区里面找,stackoverflow是帮不到你的啦,而且就目前看来框架自带的bug还是有的.\n\n### ReactNative\n\n![ReactNative logo](https://ooo.0o0.ooo/2017/03/14/58c7511a63fec.jpg)\n\n[中文官网](http://reactnative.cn/)\n\n#### 介绍\nFacebook 发布的一个混合开发框架,使用ES5/ES6语法,通过ReactNative自带的框架去调用原生模块,但重点是他虽然写的是前端语言,JSX和ES5/ES6但是可以经过构建渲染,将DOM元素转为原生元素,也就是使用前端语言开发原生app已成为现实,既能保留原生的体验又能体现出跨平台和热修复的优势,所以近两年来这个框架十分火.\n\n#### 优点\n既有原生的体验,又能做到跨平台,虽然加载速度还是比纯原生慢一点,但是这个差距已经能达到毫秒级,基本不影响体验,目前像支付宝,手机QQ,淘宝 都已经在部分模块使用了React Native框架,市场前景广阔,拥有丰富的资料.\n\n#### 缺点\n因为这个框架还出现不久,目前还是0.x版本阶段,有部分原生模块还没有接入,只能等他更新\n\n需要一定的学习成本,如果你说你是个会HTML和CSS的前端工程师,那不好意思你还是从入门教程开始看吧╮(╯_╰)╭\n\n### Weex\n\n\n官网 … 额… 没官网..只有一个[论坛](http://www.weex.help/)\n\n#### 介绍\n阿里爸爸推出的跟ReactNative差不多的框架,所以介绍就跟上面差不多,其实我并不是很熟悉这个框架,而且这个框架是16年4月阿里才开放出来内测的,现在支持的原生元素还是不多,现在一年过去了感觉没引起多大关注,如果你学过Vue,那么这个框架你可能会比较好上手\n\n总之阿里爸爸推出了这个轮子还是很吊的.之后说不定会一鸣惊人呢?\n\n### AppCan\n\n[官网](http://www.appcan.cn/)\n\n#### 介绍\n国内的混合开发框架\n\n_(´ཀ`」 ∠) 这个东西是基于他们服务器运行的,所以说如果他们的服务器跪了,你的app就跪了,当然如果你是付费用户,他们就会很快地帮你处理.他们有自己的开发IDE,产出的是也是webView页面,这里就不过多介绍了,具体可以看他们官网.\n\n### 关于热修复\n前言就讲了热修复是啥东西,然后说说最近发生的一件事\n\n今年的三八妇女节那天,苹果发了邮件给使用了热修复的开发者,说你们在应用商店上面的app里面有使用了热修复框架,希望你们以后不要用,因为这会违反什么吧啦吧啦协议条款,然后一群不是很懂英文的程序员就猜来猜去,就说苹果不让用热修复了,JSPatch不能用了啊,ReactNative药丸啊╮(╯_╰)╭,我在V2看到的最多的就是iOS开发者的欢呼23333,感觉真是世态炎凉,原生的优势已经得通过保护才能体现了吗?\n\n嘛.认真看看邮件,苹果是说你们不能用热修复的手段去改变app的功能,像是调用runtime底层方法之类的,就比如说你这个功能本来是显示一个公司的产品展示的的,但是你通过了应用审核之后,远程下发补丁,然后一打开app就弹出一大堆广告,那这样子肯定是违反协议的,当然你用JSPatch的方式你想做啥就做啥,显然不是很好,所以现在JSPatch官方也说近期不要用(前几天我更新了一个app的新版本,没有移除JSPatch,居然也过审了???),但是RN框架是不会做这些事情的,收到邮件的RN开发者大多是因为里面用了Code Push或Expo之类的第三方.\n\n那结论就是,JSPatch不给用了,那也许大家会更倾向于RN或者web方案,所以近期RN的发展应该会更加迅速,反正无论如何,大家尝到热修复的甜头,肯定不会就此罢休.\n\n---\n\n文: Arclin\n\n2017.03.14","source":"_posts/关于App混合开发的介绍.md","raw":"---\ntitle: 关于App混合开发的介绍\nauthor: Arclin\ntags:\n  - React Native\n  - Cordova\n  - AppCan\n  - Weex\n  - HTML5+\ncategories:\n  - 杂谈\nabbrlink: b179ff40\ndate: 2017-03-14 00:00:00\n---\n![](https://ooo.0o0.ooo/2017/03/14/58c75bfb373da.png)\n\n### 前言\n\nHybrid App 混合开发意思是在web-app、native-app这两者之间的app开发,兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”, 并且也方便我们进行热修复.\n\n<!-- more -->\n\n> 跨平台就是你写一套代码,然后iOS和Android都能用,这样子可以大大节省人力成本和开发成本\n\n> 热修复就是应用发布之后你还可以通过下发补丁或者直接修改web部分代码去修改app的内容,由于iOS版本应用要上传到应用市场需要经过严格的审核,这将会花费很多时间,如果每次项目一有点小问题就重新发布上架,这将会是一场灾难,所以app的热修复技术在iOS中显得尤为重要\n\n目前比较流行的有Cordova/PhoneGap,HTML 5+,React Native,Weex,AppCan(因为这个平台在很多地方吐槽很严重所以暂时不讨论),接下来我们一个个地讨论这些开发框架.\n\n### Cordova/PhoneGap\t\n\n![Cordova logo](https://ooo.0o0.ooo/2017/03/14/58c7511a7b3cf.png)\n\n[Cordova 官网](http://cordova.apache.org/)\n\n#### 介绍\n为什么这两个要放在一起呢,因为PhoneGap被Adobe收购了,临走之前把核心代码给了Apache,Apache就把这个项目名作Cordova,所以说PhoneGap和Cordova出自同一家,他们都会被开源社区和Adobe所推动.\n\n这个框架是作为原生与web之间的中间件,它采用插件的形式调用原生模块,最后成品就是原生页面和web页面的一个混合应用,现在是一个为大多数混合应用所采用的框架,拥有广大的前景\n\n#### 优点\n用相对简单,学习成本低,对于不熟悉原生开发的前端工程师来说是不错的选择.\n\n#### 缺点\n说实话这个并不是Cordova的缺点,而是web应用共有的问题,就是页面响应迟钝和操作体验不佳的问题.但是这些问题在现在也已经有了足够多的解决方案,具体想了解可以自行上网查阅.\n\n### HTML 5+\n\n![HTML5+ logo](https://ooo.0o0.ooo/2017/03/14/58c7511a6ebea.png)\n\n[官方文档](http://ask.dcloud.net.cn/docs/)\n\n#### 介绍\nDCloud和H5中国产业联盟发起的项目,使用H5+框架自带的各种方法去进行与原生模块之间的沟通,结果产出的依然是web页面,但是\u0007性能相对比Cordova好.\n\n#### 优点\n上手简单,学习成本低,有完整的中文文档,作为移动端webView上的框架体验是很不错的,前端人员可以优先考虑使用这个框架.\n\n#### 缺点\n貌似国外基本没人知道这东西,第三方插件和资源相对较少,要是遇到问题也只能去dcloud社区里面找,stackoverflow是帮不到你的啦,而且就目前看来框架自带的bug还是有的.\n\n### ReactNative\n\n![ReactNative logo](https://ooo.0o0.ooo/2017/03/14/58c7511a63fec.jpg)\n\n[中文官网](http://reactnative.cn/)\n\n#### 介绍\nFacebook 发布的一个混合开发框架,使用ES5/ES6语法,通过ReactNative自带的框架去调用原生模块,但重点是他虽然写的是前端语言,JSX和ES5/ES6但是可以经过构建渲染,将DOM元素转为原生元素,也就是使用前端语言开发原生app已成为现实,既能保留原生的体验又能体现出跨平台和热修复的优势,所以近两年来这个框架十分火.\n\n#### 优点\n既有原生的体验,又能做到跨平台,虽然加载速度还是比纯原生慢一点,但是这个差距已经能达到毫秒级,基本不影响体验,目前像支付宝,手机QQ,淘宝 都已经在部分模块使用了React Native框架,市场前景广阔,拥有丰富的资料.\n\n#### 缺点\n因为这个框架还出现不久,目前还是0.x版本阶段,有部分原生模块还没有接入,只能等他更新\n\n需要一定的学习成本,如果你说你是个会HTML和CSS的前端工程师,那不好意思你还是从入门教程开始看吧╮(╯_╰)╭\n\n### Weex\n\n\n官网 … 额… 没官网..只有一个[论坛](http://www.weex.help/)\n\n#### 介绍\n阿里爸爸推出的跟ReactNative差不多的框架,所以介绍就跟上面差不多,其实我并不是很熟悉这个框架,而且这个框架是16年4月阿里才开放出来内测的,现在支持的原生元素还是不多,现在一年过去了感觉没引起多大关注,如果你学过Vue,那么这个框架你可能会比较好上手\n\n总之阿里爸爸推出了这个轮子还是很吊的.之后说不定会一鸣惊人呢?\n\n### AppCan\n\n[官网](http://www.appcan.cn/)\n\n#### 介绍\n国内的混合开发框架\n\n_(´ཀ`」 ∠) 这个东西是基于他们服务器运行的,所以说如果他们的服务器跪了,你的app就跪了,当然如果你是付费用户,他们就会很快地帮你处理.他们有自己的开发IDE,产出的是也是webView页面,这里就不过多介绍了,具体可以看他们官网.\n\n### 关于热修复\n前言就讲了热修复是啥东西,然后说说最近发生的一件事\n\n今年的三八妇女节那天,苹果发了邮件给使用了热修复的开发者,说你们在应用商店上面的app里面有使用了热修复框架,希望你们以后不要用,因为这会违反什么吧啦吧啦协议条款,然后一群不是很懂英文的程序员就猜来猜去,就说苹果不让用热修复了,JSPatch不能用了啊,ReactNative药丸啊╮(╯_╰)╭,我在V2看到的最多的就是iOS开发者的欢呼23333,感觉真是世态炎凉,原生的优势已经得通过保护才能体现了吗?\n\n嘛.认真看看邮件,苹果是说你们不能用热修复的手段去改变app的功能,像是调用runtime底层方法之类的,就比如说你这个功能本来是显示一个公司的产品展示的的,但是你通过了应用审核之后,远程下发补丁,然后一打开app就弹出一大堆广告,那这样子肯定是违反协议的,当然你用JSPatch的方式你想做啥就做啥,显然不是很好,所以现在JSPatch官方也说近期不要用(前几天我更新了一个app的新版本,没有移除JSPatch,居然也过审了???),但是RN框架是不会做这些事情的,收到邮件的RN开发者大多是因为里面用了Code Push或Expo之类的第三方.\n\n那结论就是,JSPatch不给用了,那也许大家会更倾向于RN或者web方案,所以近期RN的发展应该会更加迅速,反正无论如何,大家尝到热修复的甜头,肯定不会就此罢休.\n\n---\n\n文: Arclin\n\n2017.03.14","slug":"关于App混合开发的介绍","published":1,"updated":"2018-05-10T06:51:35.759Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcl0003gldxusowkinkt","content":"<p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c75bfb373da.png\" alt=\"\"></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Hybrid App 混合开发意思是在web-app、native-app这两者之间的app开发,兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”, 并且也方便我们进行热修复.</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>跨平台就是你写一套代码,然后iOS和Android都能用,这样子可以大大节省人力成本和开发成本</p>\n<p>热修复就是应用发布之后你还可以通过下发补丁或者直接修改web部分代码去修改app的内容,由于iOS版本应用要上传到应用市场需要经过严格的审核,这将会花费很多时间,如果每次项目一有点小问题就重新发布上架,这将会是一场灾难,所以app的热修复技术在iOS中显得尤为重要</p>\n</blockquote>\n<p>目前比较流行的有Cordova/PhoneGap,HTML 5+,React Native,Weex,AppCan(因为这个平台在很多地方吐槽很严重所以暂时不讨论),接下来我们一个个地讨论这些开发框架.</p>\n<h3 id=\"Cordova-PhoneGap\"><a href=\"#Cordova-PhoneGap\" class=\"headerlink\" title=\"Cordova/PhoneGap\"></a>Cordova/PhoneGap</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a7b3cf.png\" alt=\"Cordova logo\"></p>\n<p><a href=\"http://cordova.apache.org/\" target=\"_blank\" rel=\"noopener\">Cordova 官网</a></p>\n<h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>为什么这两个要放在一起呢,因为PhoneGap被Adobe收购了,临走之前把核心代码给了Apache,Apache就把这个项目名作Cordova,所以说PhoneGap和Cordova出自同一家,他们都会被开源社区和Adobe所推动.</p>\n<p>这个框架是作为原生与web之间的中间件,它采用插件的形式调用原生模块,最后成品就是原生页面和web页面的一个混合应用,现在是一个为大多数混合应用所采用的框架,拥有广大的前景</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>用相对简单,学习成本低,对于不熟悉原生开发的前端工程师来说是不错的选择.</p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>说实话这个并不是Cordova的缺点,而是web应用共有的问题,就是页面响应迟钝和操作体验不佳的问题.但是这些问题在现在也已经有了足够多的解决方案,具体想了解可以自行上网查阅.</p>\n<h3 id=\"HTML-5\"><a href=\"#HTML-5\" class=\"headerlink\" title=\"HTML 5+\"></a>HTML 5+</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a6ebea.png\" alt=\"HTML5+ logo\"></p>\n<p><a href=\"http://ask.dcloud.net.cn/docs/\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>DCloud和H5中国产业联盟发起的项目,使用H5+框架自带的各种方法去进行与原生模块之间的沟通,结果产出的依然是web页面,但是\u0007性能相对比Cordova好.</p>\n<h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>上手简单,学习成本低,有完整的中文文档,作为移动端webView上的框架体验是很不错的,前端人员可以优先考虑使用这个框架.</p>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>貌似国外基本没人知道这东西,第三方插件和资源相对较少,要是遇到问题也只能去dcloud社区里面找,stackoverflow是帮不到你的啦,而且就目前看来框架自带的bug还是有的.</p>\n<h3 id=\"ReactNative\"><a href=\"#ReactNative\" class=\"headerlink\" title=\"ReactNative\"></a>ReactNative</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a63fec.jpg\" alt=\"ReactNative logo\"></p>\n<p><a href=\"http://reactnative.cn/\" target=\"_blank\" rel=\"noopener\">中文官网</a></p>\n<h4 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>Facebook 发布的一个混合开发框架,使用ES5/ES6语法,通过ReactNative自带的框架去调用原生模块,但重点是他虽然写的是前端语言,JSX和ES5/ES6但是可以经过构建渲染,将DOM元素转为原生元素,也就是使用前端语言开发原生app已成为现实,既能保留原生的体验又能体现出跨平台和热修复的优势,所以近两年来这个框架十分火.</p>\n<h4 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>既有原生的体验,又能做到跨平台,虽然加载速度还是比纯原生慢一点,但是这个差距已经能达到毫秒级,基本不影响体验,目前像支付宝,手机QQ,淘宝 都已经在部分模块使用了React Native框架,市场前景广阔,拥有丰富的资料.</p>\n<h4 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>因为这个框架还出现不久,目前还是0.x版本阶段,有部分原生模块还没有接入,只能等他更新</p>\n<p>需要一定的学习成本,如果你说你是个会HTML和CSS的前端工程师,那不好意思你还是从入门教程开始看吧╮(╯_╰)╭</p>\n<h3 id=\"Weex\"><a href=\"#Weex\" class=\"headerlink\" title=\"Weex\"></a>Weex</h3><p>官网 … 额… 没官网..只有一个<a href=\"http://www.weex.help/\" target=\"_blank\" rel=\"noopener\">论坛</a></p>\n<h4 id=\"介绍-3\"><a href=\"#介绍-3\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>阿里爸爸推出的跟ReactNative差不多的框架,所以介绍就跟上面差不多,其实我并不是很熟悉这个框架,而且这个框架是16年4月阿里才开放出来内测的,现在支持的原生元素还是不多,现在一年过去了感觉没引起多大关注,如果你学过Vue,那么这个框架你可能会比较好上手</p>\n<p>总之阿里爸爸推出了这个轮子还是很吊的.之后说不定会一鸣惊人呢?</p>\n<h3 id=\"AppCan\"><a href=\"#AppCan\" class=\"headerlink\" title=\"AppCan\"></a>AppCan</h3><p><a href=\"http://www.appcan.cn/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h4 id=\"介绍-4\"><a href=\"#介绍-4\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>国内的混合开发框架</p>\n<p>_(´ཀ`」 ∠) 这个东西是基于他们服务器运行的,所以说如果他们的服务器跪了,你的app就跪了,当然如果你是付费用户,他们就会很快地帮你处理.他们有自己的开发IDE,产出的是也是webView页面,这里就不过多介绍了,具体可以看他们官网.</p>\n<h3 id=\"关于热修复\"><a href=\"#关于热修复\" class=\"headerlink\" title=\"关于热修复\"></a>关于热修复</h3><p>前言就讲了热修复是啥东西,然后说说最近发生的一件事</p>\n<p>今年的三八妇女节那天,苹果发了邮件给使用了热修复的开发者,说你们在应用商店上面的app里面有使用了热修复框架,希望你们以后不要用,因为这会违反什么吧啦吧啦协议条款,然后一群不是很懂英文的程序员就猜来猜去,就说苹果不让用热修复了,JSPatch不能用了啊,ReactNative药丸啊╮(╯_╰)╭,我在V2看到的最多的就是iOS开发者的欢呼23333,感觉真是世态炎凉,原生的优势已经得通过保护才能体现了吗?</p>\n<p>嘛.认真看看邮件,苹果是说你们不能用热修复的手段去改变app的功能,像是调用runtime底层方法之类的,就比如说你这个功能本来是显示一个公司的产品展示的的,但是你通过了应用审核之后,远程下发补丁,然后一打开app就弹出一大堆广告,那这样子肯定是违反协议的,当然你用JSPatch的方式你想做啥就做啥,显然不是很好,所以现在JSPatch官方也说近期不要用(前几天我更新了一个app的新版本,没有移除JSPatch,居然也过审了???),但是RN框架是不会做这些事情的,收到邮件的RN开发者大多是因为里面用了Code Push或Expo之类的第三方.</p>\n<p>那结论就是,JSPatch不给用了,那也许大家会更倾向于RN或者web方案,所以近期RN的发展应该会更加迅速,反正无论如何,大家尝到热修复的甜头,肯定不会就此罢休.</p>\n<hr>\n<p>文: Arclin</p>\n<p>2017.03.14</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c75bfb373da.png\" alt=\"\"></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Hybrid App 混合开发意思是在web-app、native-app这两者之间的app开发,兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”, 并且也方便我们进行热修复.</p>","more":"<blockquote>\n<p>跨平台就是你写一套代码,然后iOS和Android都能用,这样子可以大大节省人力成本和开发成本</p>\n<p>热修复就是应用发布之后你还可以通过下发补丁或者直接修改web部分代码去修改app的内容,由于iOS版本应用要上传到应用市场需要经过严格的审核,这将会花费很多时间,如果每次项目一有点小问题就重新发布上架,这将会是一场灾难,所以app的热修复技术在iOS中显得尤为重要</p>\n</blockquote>\n<p>目前比较流行的有Cordova/PhoneGap,HTML 5+,React Native,Weex,AppCan(因为这个平台在很多地方吐槽很严重所以暂时不讨论),接下来我们一个个地讨论这些开发框架.</p>\n<h3 id=\"Cordova-PhoneGap\"><a href=\"#Cordova-PhoneGap\" class=\"headerlink\" title=\"Cordova/PhoneGap\"></a>Cordova/PhoneGap</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a7b3cf.png\" alt=\"Cordova logo\"></p>\n<p><a href=\"http://cordova.apache.org/\" target=\"_blank\" rel=\"noopener\">Cordova 官网</a></p>\n<h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>为什么这两个要放在一起呢,因为PhoneGap被Adobe收购了,临走之前把核心代码给了Apache,Apache就把这个项目名作Cordova,所以说PhoneGap和Cordova出自同一家,他们都会被开源社区和Adobe所推动.</p>\n<p>这个框架是作为原生与web之间的中间件,它采用插件的形式调用原生模块,最后成品就是原生页面和web页面的一个混合应用,现在是一个为大多数混合应用所采用的框架,拥有广大的前景</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>用相对简单,学习成本低,对于不熟悉原生开发的前端工程师来说是不错的选择.</p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>说实话这个并不是Cordova的缺点,而是web应用共有的问题,就是页面响应迟钝和操作体验不佳的问题.但是这些问题在现在也已经有了足够多的解决方案,具体想了解可以自行上网查阅.</p>\n<h3 id=\"HTML-5\"><a href=\"#HTML-5\" class=\"headerlink\" title=\"HTML 5+\"></a>HTML 5+</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a6ebea.png\" alt=\"HTML5+ logo\"></p>\n<p><a href=\"http://ask.dcloud.net.cn/docs/\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>DCloud和H5中国产业联盟发起的项目,使用H5+框架自带的各种方法去进行与原生模块之间的沟通,结果产出的依然是web页面,但是\u0007性能相对比Cordova好.</p>\n<h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>上手简单,学习成本低,有完整的中文文档,作为移动端webView上的框架体验是很不错的,前端人员可以优先考虑使用这个框架.</p>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>貌似国外基本没人知道这东西,第三方插件和资源相对较少,要是遇到问题也只能去dcloud社区里面找,stackoverflow是帮不到你的啦,而且就目前看来框架自带的bug还是有的.</p>\n<h3 id=\"ReactNative\"><a href=\"#ReactNative\" class=\"headerlink\" title=\"ReactNative\"></a>ReactNative</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a63fec.jpg\" alt=\"ReactNative logo\"></p>\n<p><a href=\"http://reactnative.cn/\" target=\"_blank\" rel=\"noopener\">中文官网</a></p>\n<h4 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>Facebook 发布的一个混合开发框架,使用ES5/ES6语法,通过ReactNative自带的框架去调用原生模块,但重点是他虽然写的是前端语言,JSX和ES5/ES6但是可以经过构建渲染,将DOM元素转为原生元素,也就是使用前端语言开发原生app已成为现实,既能保留原生的体验又能体现出跨平台和热修复的优势,所以近两年来这个框架十分火.</p>\n<h4 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>既有原生的体验,又能做到跨平台,虽然加载速度还是比纯原生慢一点,但是这个差距已经能达到毫秒级,基本不影响体验,目前像支付宝,手机QQ,淘宝 都已经在部分模块使用了React Native框架,市场前景广阔,拥有丰富的资料.</p>\n<h4 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>因为这个框架还出现不久,目前还是0.x版本阶段,有部分原生模块还没有接入,只能等他更新</p>\n<p>需要一定的学习成本,如果你说你是个会HTML和CSS的前端工程师,那不好意思你还是从入门教程开始看吧╮(╯_╰)╭</p>\n<h3 id=\"Weex\"><a href=\"#Weex\" class=\"headerlink\" title=\"Weex\"></a>Weex</h3><p>官网 … 额… 没官网..只有一个<a href=\"http://www.weex.help/\" target=\"_blank\" rel=\"noopener\">论坛</a></p>\n<h4 id=\"介绍-3\"><a href=\"#介绍-3\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>阿里爸爸推出的跟ReactNative差不多的框架,所以介绍就跟上面差不多,其实我并不是很熟悉这个框架,而且这个框架是16年4月阿里才开放出来内测的,现在支持的原生元素还是不多,现在一年过去了感觉没引起多大关注,如果你学过Vue,那么这个框架你可能会比较好上手</p>\n<p>总之阿里爸爸推出了这个轮子还是很吊的.之后说不定会一鸣惊人呢?</p>\n<h3 id=\"AppCan\"><a href=\"#AppCan\" class=\"headerlink\" title=\"AppCan\"></a>AppCan</h3><p><a href=\"http://www.appcan.cn/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h4 id=\"介绍-4\"><a href=\"#介绍-4\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>国内的混合开发框架</p>\n<p>_(´ཀ`」 ∠) 这个东西是基于他们服务器运行的,所以说如果他们的服务器跪了,你的app就跪了,当然如果你是付费用户,他们就会很快地帮你处理.他们有自己的开发IDE,产出的是也是webView页面,这里就不过多介绍了,具体可以看他们官网.</p>\n<h3 id=\"关于热修复\"><a href=\"#关于热修复\" class=\"headerlink\" title=\"关于热修复\"></a>关于热修复</h3><p>前言就讲了热修复是啥东西,然后说说最近发生的一件事</p>\n<p>今年的三八妇女节那天,苹果发了邮件给使用了热修复的开发者,说你们在应用商店上面的app里面有使用了热修复框架,希望你们以后不要用,因为这会违反什么吧啦吧啦协议条款,然后一群不是很懂英文的程序员就猜来猜去,就说苹果不让用热修复了,JSPatch不能用了啊,ReactNative药丸啊╮(╯_╰)╭,我在V2看到的最多的就是iOS开发者的欢呼23333,感觉真是世态炎凉,原生的优势已经得通过保护才能体现了吗?</p>\n<p>嘛.认真看看邮件,苹果是说你们不能用热修复的手段去改变app的功能,像是调用runtime底层方法之类的,就比如说你这个功能本来是显示一个公司的产品展示的的,但是你通过了应用审核之后,远程下发补丁,然后一打开app就弹出一大堆广告,那这样子肯定是违反协议的,当然你用JSPatch的方式你想做啥就做啥,显然不是很好,所以现在JSPatch官方也说近期不要用(前几天我更新了一个app的新版本,没有移除JSPatch,居然也过审了???),但是RN框架是不会做这些事情的,收到邮件的RN开发者大多是因为里面用了Code Push或Expo之类的第三方.</p>\n<p>那结论就是,JSPatch不给用了,那也许大家会更倾向于RN或者web方案,所以近期RN的发展应该会更加迅速,反正无论如何,大家尝到热修复的甜头,肯定不会就此罢休.</p>\n<hr>\n<p>文: Arclin</p>\n<p>2017.03.14</p>"},{"title":"pop后强制竖屏","author":"Arclin","abbrlink":"50c5f6e6","date":"2016-10-16T16:00:00.000Z","_content":"pop之后强制竖屏\n\n<!-- more -->\n\n`AppDeleagte.h`\n\n```\n// 控制全部不支持横屏，当allowRotation为YES的时候可以横/竖屏切换\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    if (self.allowRotation) {\n        return  UIInterfaceOrientationMaskAllButUpsideDown;\n    }\n    return UIInterfaceOrientationMaskPortrait;\n}\n```\n\npop之后强制竖屏\n\n```\n- (void)viewDidAppear:(BOOL)animated\n{\n     [super viewDidAppear:animated];\n    \n    // 强制竖屏\n    [[UIDevice currentDevice] setValue:@(UIDeviceOrientationPortrait) forKey:@\"orientation\"];\n}\n```","source":"_posts/pop后强制竖屏.md","raw":"---\ntitle: pop后强制竖屏\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 50c5f6e6\ndate: 2016-10-17 00:00:00\n---\npop之后强制竖屏\n\n<!-- more -->\n\n`AppDeleagte.h`\n\n```\n// 控制全部不支持横屏，当allowRotation为YES的时候可以横/竖屏切换\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    if (self.allowRotation) {\n        return  UIInterfaceOrientationMaskAllButUpsideDown;\n    }\n    return UIInterfaceOrientationMaskPortrait;\n}\n```\n\npop之后强制竖屏\n\n```\n- (void)viewDidAppear:(BOOL)animated\n{\n     [super viewDidAppear:animated];\n    \n    // 强制竖屏\n    [[UIDevice currentDevice] setValue:@(UIDeviceOrientationPortrait) forKey:@\"orientation\"];\n}\n```","slug":"pop后强制竖屏","published":1,"updated":"2018-05-10T06:51:35.754Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcl3003jldxung8v40ca","content":"<p>pop之后强制竖屏</p>\n<a id=\"more\"></a>\n<p><code>AppDeleagte.h</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 控制全部不支持横屏，当allowRotation为YES的时候可以横/竖屏切换</span><br><span class=\"line\">- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;</span><br><span class=\"line\">    if (self.allowRotation) &#123;</span><br><span class=\"line\">        return  UIInterfaceOrientationMaskAllButUpsideDown;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return UIInterfaceOrientationMaskPortrait;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>pop之后强制竖屏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     [super viewDidAppear:animated];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 强制竖屏</span><br><span class=\"line\">    [[UIDevice currentDevice] setValue:@(UIDeviceOrientationPortrait) forKey:@&quot;orientation&quot;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>pop之后强制竖屏</p>","more":"<p><code>AppDeleagte.h</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 控制全部不支持横屏，当allowRotation为YES的时候可以横/竖屏切换</span><br><span class=\"line\">- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;</span><br><span class=\"line\">    if (self.allowRotation) &#123;</span><br><span class=\"line\">        return  UIInterfaceOrientationMaskAllButUpsideDown;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return UIInterfaceOrientationMaskPortrait;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>pop之后强制竖屏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     [super viewDidAppear:animated];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 强制竖屏</span><br><span class=\"line\">    [[UIDevice currentDevice] setValue:@(UIDeviceOrientationPortrait) forKey:@&quot;orientation&quot;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"iOS-定位总结","author":"Arclin","abbrlink":"2684222a","date":"2016-10-28T16:00:00.000Z","_content":"iOS-定位总结\n<!-- more -->\n\ninfo.plist 请求用户位置授权\n\n```\n<key>NSLocationWhenInUseUsageDescription</key>\n\t<string>需要使用位置</string>\n<key>NSLocationAlwaysUsageDescription</key>\n\t<string>需要使用位置</string>\n```\n\n代码\n\n\nlanguage: 要生成的位置信息的语言（’China‘还是’中国‘）\n\n - 中文 : @”zh-hans”\n - 英文 : @”en”\n - 日文 : @”jp”\n\n```\n- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location;\n```\n\n```\n@interface DKLocation()<CLLocationManagerDelegate>\n\n@property (nonatomic,strong) CLLocationManager *locationManager;\n\n@end\n@implementation DKLocation\n- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location\n{\n    \n    [[self rac_signalForSelector:@selector(locationManager:didUpdateToLocation:fromLocation:) fromProtocol:@protocol(CLLocationManagerDelegate)] subscribeNext:^(RACTuple *tuple) {\n        // 停止位置更新\n        CLLocationManager *manager = tuple.first;\n        CLLocation *newLocation = tuple.second;\n        \n        [manager stopUpdatingLocation];\n        [_locationManager stopUpdatingLocation];\n        _locationManager.delegate = nil;\n        // 保存 Device 的现语言\n        NSString *userDefaultLanguages = DKUserDefaults(kAppLanguage);\n        // 强制 成 英文\n        [[NSUserDefaults standardUserDefaults] setObject:[NSArray arrayWithObjects:language,nil] forKey:@\"AppleLanguages\"];\n        // 逆地理编码\n        CLGeocoder * geoCoder = [[CLGeocoder alloc] init];\n        [geoCoder reverseGeocodeLocation:newLocation completionHandler:^(NSArray *placemarks, NSError *error) {\n            if(!error){\n                for (CLPlacemark * placemark in placemarks) {\n                    NSString *provinceName = placemark.administrativeArea;\n                    NSString *country = placemark.country;\n                    location(country,provinceName);\n                    DKLog(@\"%@%@\",country,provinceName);\n                    break;\n                }\n            }\n            // 还原Device 的语言\n            [[NSUserDefaults standardUserDefaults] setObject:@[userDefaultLanguages] forKey:@\"AppleLanguages\"];\n        }];\n\n    }];\n    \n    // 初始化定位管理器\n    _locationManager = [[CLLocationManager alloc] init];\n    _locationManager.delegate = self;\n    // 设置定位精确度到米\n    _locationManager.desiredAccuracy = kCLLocationAccuracyBest;\n    // 设置过滤器为无\n    _locationManager.distanceFilter = kCLDistanceFilterNone;\n    if ([_locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) {\n        [_locationManager requestAlwaysAuthorization];\n    }\n    //开始定位，不断调用其代理方法\n    [_locationManager startUpdatingLocation];\n    \n}\n\n@end\n```","source":"_posts/iOS-定位总结.md","raw":"---\ntitle: iOS-定位总结\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 2684222a\ndate: 2016-10-29 00:00:00\n---\niOS-定位总结\n<!-- more -->\n\ninfo.plist 请求用户位置授权\n\n```\n<key>NSLocationWhenInUseUsageDescription</key>\n\t<string>需要使用位置</string>\n<key>NSLocationAlwaysUsageDescription</key>\n\t<string>需要使用位置</string>\n```\n\n代码\n\n\nlanguage: 要生成的位置信息的语言（’China‘还是’中国‘）\n\n - 中文 : @”zh-hans”\n - 英文 : @”en”\n - 日文 : @”jp”\n\n```\n- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location;\n```\n\n```\n@interface DKLocation()<CLLocationManagerDelegate>\n\n@property (nonatomic,strong) CLLocationManager *locationManager;\n\n@end\n@implementation DKLocation\n- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location\n{\n    \n    [[self rac_signalForSelector:@selector(locationManager:didUpdateToLocation:fromLocation:) fromProtocol:@protocol(CLLocationManagerDelegate)] subscribeNext:^(RACTuple *tuple) {\n        // 停止位置更新\n        CLLocationManager *manager = tuple.first;\n        CLLocation *newLocation = tuple.second;\n        \n        [manager stopUpdatingLocation];\n        [_locationManager stopUpdatingLocation];\n        _locationManager.delegate = nil;\n        // 保存 Device 的现语言\n        NSString *userDefaultLanguages = DKUserDefaults(kAppLanguage);\n        // 强制 成 英文\n        [[NSUserDefaults standardUserDefaults] setObject:[NSArray arrayWithObjects:language,nil] forKey:@\"AppleLanguages\"];\n        // 逆地理编码\n        CLGeocoder * geoCoder = [[CLGeocoder alloc] init];\n        [geoCoder reverseGeocodeLocation:newLocation completionHandler:^(NSArray *placemarks, NSError *error) {\n            if(!error){\n                for (CLPlacemark * placemark in placemarks) {\n                    NSString *provinceName = placemark.administrativeArea;\n                    NSString *country = placemark.country;\n                    location(country,provinceName);\n                    DKLog(@\"%@%@\",country,provinceName);\n                    break;\n                }\n            }\n            // 还原Device 的语言\n            [[NSUserDefaults standardUserDefaults] setObject:@[userDefaultLanguages] forKey:@\"AppleLanguages\"];\n        }];\n\n    }];\n    \n    // 初始化定位管理器\n    _locationManager = [[CLLocationManager alloc] init];\n    _locationManager.delegate = self;\n    // 设置定位精确度到米\n    _locationManager.desiredAccuracy = kCLLocationAccuracyBest;\n    // 设置过滤器为无\n    _locationManager.distanceFilter = kCLDistanceFilterNone;\n    if ([_locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) {\n        [_locationManager requestAlwaysAuthorization];\n    }\n    //开始定位，不断调用其代理方法\n    [_locationManager startUpdatingLocation];\n    \n}\n\n@end\n```","slug":"iOS-定位总结","published":1,"updated":"2018-05-10T06:51:35.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcl9003oldxuy93mo32u","content":"<p>iOS-定位总结<br><a id=\"more\"></a></p>\n<p>info.plist 请求用户位置授权</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;</span><br><span class=\"line\">\t&lt;string&gt;需要使用位置&lt;/string&gt;</span><br><span class=\"line\">&lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt;</span><br><span class=\"line\">\t&lt;string&gt;需要使用位置&lt;/string&gt;</span><br></pre></td></tr></table></figure>\n<p>代码</p>\n<p>language: 要生成的位置信息的语言（’China‘还是’中国‘）</p>\n<ul>\n<li>中文 : @”zh-hans”</li>\n<li>英文 : @”en”</li>\n<li>日文 : @”jp”</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface DKLocation()&lt;CLLocationManagerDelegate&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic,strong) CLLocationManager *locationManager;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\">@implementation DKLocation</span><br><span class=\"line\">- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [[self rac_signalForSelector:@selector(locationManager:didUpdateToLocation:fromLocation:) fromProtocol:@protocol(CLLocationManagerDelegate)] subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">        // 停止位置更新</span><br><span class=\"line\">        CLLocationManager *manager = tuple.first;</span><br><span class=\"line\">        CLLocation *newLocation = tuple.second;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [manager stopUpdatingLocation];</span><br><span class=\"line\">        [_locationManager stopUpdatingLocation];</span><br><span class=\"line\">        _locationManager.delegate = nil;</span><br><span class=\"line\">        // 保存 Device 的现语言</span><br><span class=\"line\">        NSString *userDefaultLanguages = DKUserDefaults(kAppLanguage);</span><br><span class=\"line\">        // 强制 成 英文</span><br><span class=\"line\">        [[NSUserDefaults standardUserDefaults] setObject:[NSArray arrayWithObjects:language,nil] forKey:@&quot;AppleLanguages&quot;];</span><br><span class=\"line\">        // 逆地理编码</span><br><span class=\"line\">        CLGeocoder * geoCoder = [[CLGeocoder alloc] init];</span><br><span class=\"line\">        [geoCoder reverseGeocodeLocation:newLocation completionHandler:^(NSArray *placemarks, NSError *error) &#123;</span><br><span class=\"line\">            if(!error)&#123;</span><br><span class=\"line\">                for (CLPlacemark * placemark in placemarks) &#123;</span><br><span class=\"line\">                    NSString *provinceName = placemark.administrativeArea;</span><br><span class=\"line\">                    NSString *country = placemark.country;</span><br><span class=\"line\">                    location(country,provinceName);</span><br><span class=\"line\">                    DKLog(@&quot;%@%@&quot;,country,provinceName);</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 还原Device 的语言</span><br><span class=\"line\">            [[NSUserDefaults standardUserDefaults] setObject:@[userDefaultLanguages] forKey:@&quot;AppleLanguages&quot;];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 初始化定位管理器</span><br><span class=\"line\">    _locationManager = [[CLLocationManager alloc] init];</span><br><span class=\"line\">    _locationManager.delegate = self;</span><br><span class=\"line\">    // 设置定位精确度到米</span><br><span class=\"line\">    _locationManager.desiredAccuracy = kCLLocationAccuracyBest;</span><br><span class=\"line\">    // 设置过滤器为无</span><br><span class=\"line\">    _locationManager.distanceFilter = kCLDistanceFilterNone;</span><br><span class=\"line\">    if ([_locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) &#123;</span><br><span class=\"line\">        [_locationManager requestAlwaysAuthorization];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //开始定位，不断调用其代理方法</span><br><span class=\"line\">    [_locationManager startUpdatingLocation];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>iOS-定位总结<br>","more":"</p>\n<p>info.plist 请求用户位置授权</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;</span><br><span class=\"line\">\t&lt;string&gt;需要使用位置&lt;/string&gt;</span><br><span class=\"line\">&lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt;</span><br><span class=\"line\">\t&lt;string&gt;需要使用位置&lt;/string&gt;</span><br></pre></td></tr></table></figure>\n<p>代码</p>\n<p>language: 要生成的位置信息的语言（’China‘还是’中国‘）</p>\n<ul>\n<li>中文 : @”zh-hans”</li>\n<li>英文 : @”en”</li>\n<li>日文 : @”jp”</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface DKLocation()&lt;CLLocationManagerDelegate&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic,strong) CLLocationManager *locationManager;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\">@implementation DKLocation</span><br><span class=\"line\">- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [[self rac_signalForSelector:@selector(locationManager:didUpdateToLocation:fromLocation:) fromProtocol:@protocol(CLLocationManagerDelegate)] subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">        // 停止位置更新</span><br><span class=\"line\">        CLLocationManager *manager = tuple.first;</span><br><span class=\"line\">        CLLocation *newLocation = tuple.second;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [manager stopUpdatingLocation];</span><br><span class=\"line\">        [_locationManager stopUpdatingLocation];</span><br><span class=\"line\">        _locationManager.delegate = nil;</span><br><span class=\"line\">        // 保存 Device 的现语言</span><br><span class=\"line\">        NSString *userDefaultLanguages = DKUserDefaults(kAppLanguage);</span><br><span class=\"line\">        // 强制 成 英文</span><br><span class=\"line\">        [[NSUserDefaults standardUserDefaults] setObject:[NSArray arrayWithObjects:language,nil] forKey:@&quot;AppleLanguages&quot;];</span><br><span class=\"line\">        // 逆地理编码</span><br><span class=\"line\">        CLGeocoder * geoCoder = [[CLGeocoder alloc] init];</span><br><span class=\"line\">        [geoCoder reverseGeocodeLocation:newLocation completionHandler:^(NSArray *placemarks, NSError *error) &#123;</span><br><span class=\"line\">            if(!error)&#123;</span><br><span class=\"line\">                for (CLPlacemark * placemark in placemarks) &#123;</span><br><span class=\"line\">                    NSString *provinceName = placemark.administrativeArea;</span><br><span class=\"line\">                    NSString *country = placemark.country;</span><br><span class=\"line\">                    location(country,provinceName);</span><br><span class=\"line\">                    DKLog(@&quot;%@%@&quot;,country,provinceName);</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 还原Device 的语言</span><br><span class=\"line\">            [[NSUserDefaults standardUserDefaults] setObject:@[userDefaultLanguages] forKey:@&quot;AppleLanguages&quot;];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 初始化定位管理器</span><br><span class=\"line\">    _locationManager = [[CLLocationManager alloc] init];</span><br><span class=\"line\">    _locationManager.delegate = self;</span><br><span class=\"line\">    // 设置定位精确度到米</span><br><span class=\"line\">    _locationManager.desiredAccuracy = kCLLocationAccuracyBest;</span><br><span class=\"line\">    // 设置过滤器为无</span><br><span class=\"line\">    _locationManager.distanceFilter = kCLDistanceFilterNone;</span><br><span class=\"line\">    if ([_locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) &#123;</span><br><span class=\"line\">        [_locationManager requestAlwaysAuthorization];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //开始定位，不断调用其代理方法</span><br><span class=\"line\">    [_locationManager startUpdatingLocation];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>"},{"title":"发现一个api","author":"Arclin","abbrlink":"54b26395","date":"2016-10-16T16:00:00.000Z","_content":"发现一个好用的api，用于找出selectedItem 在 dataSource 里面的位置，适用于tableView和collectionView\n\n```\nNSIndexSet *indexSet = [self.photos indexesOfObjectsPassingTest:^BOOL(DKPhoto * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n    if ([self.selectedPhotoArray containsObject:obj]) {\n        return YES;\n    }\n    return NO;\n}];\n```","source":"_posts/发现一个api.md","raw":"---\ntitle: 发现一个api\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 54b26395\ndate: 2016-10-17 00:00:00\n---\n发现一个好用的api，用于找出selectedItem 在 dataSource 里面的位置，适用于tableView和collectionView\n\n```\nNSIndexSet *indexSet = [self.photos indexesOfObjectsPassingTest:^BOOL(DKPhoto * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n    if ([self.selectedPhotoArray containsObject:obj]) {\n        return YES;\n    }\n    return NO;\n}];\n```","slug":"发现一个api","published":1,"updated":"2018-05-10T06:51:35.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcld003rldxuqsu2221u","content":"<p>发现一个好用的api，用于找出selectedItem 在 dataSource 里面的位置，适用于tableView和collectionView</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSIndexSet *indexSet = [self.photos indexesOfObjectsPassingTest:^BOOL(DKPhoto * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">    if ([self.selectedPhotoArray containsObject:obj]) &#123;</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>发现一个好用的api，用于找出selectedItem 在 dataSource 里面的位置，适用于tableView和collectionView</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSIndexSet *indexSet = [self.photos indexesOfObjectsPassingTest:^BOOL(DKPhoto * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">    if ([self.selectedPhotoArray containsObject:obj]) &#123;</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>"},{"title":"在 iCloud Drive中显示 App的iCloud文件夹","author":"Arclin","abbrlink":"3eb7dc04","date":"2016-10-28T16:00:00.000Z","_content":"1. 修改 info.plist\n\n  ```\n  <key>NSUbiquitousContainers</key>\n      <dict>\n          <key>iCloud.com.example.app</key>\n          <dict>\n              <key>NSUbiquitousContainerIsDocumentScopePublic</key>\n              <true/>\n              <key>NSUbiquitousContainerName</key>\n              <string>App name to display in iCloud Drive</string>\n              <key>NSUbiquitousContainerSupportedFolderLevels</key>\n              <string>None</string>\n          </dict>\n      </dict>\n  ```\n\n2. 修改版本构件号(必改)","source":"_posts/在-iCloud-Drive中显示-App的iCloud文件夹.md","raw":"---\ntitle: 在 iCloud Drive中显示 App的iCloud文件夹\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 3eb7dc04\ndate: 2016-10-29 00:00:00\n---\n1. 修改 info.plist\n\n  ```\n  <key>NSUbiquitousContainers</key>\n      <dict>\n          <key>iCloud.com.example.app</key>\n          <dict>\n              <key>NSUbiquitousContainerIsDocumentScopePublic</key>\n              <true/>\n              <key>NSUbiquitousContainerName</key>\n              <string>App name to display in iCloud Drive</string>\n              <key>NSUbiquitousContainerSupportedFolderLevels</key>\n              <string>None</string>\n          </dict>\n      </dict>\n  ```\n\n2. 修改版本构件号(必改)","slug":"在-iCloud-Drive中显示-App的iCloud文件夹","published":1,"updated":"2018-05-10T06:51:35.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbclh003vldxux2fm7wa9","content":"<ol>\n<li><p>修改 info.plist</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;NSUbiquitousContainers&lt;/key&gt;</span><br><span class=\"line\">    &lt;dict&gt;</span><br><span class=\"line\">        &lt;key&gt;iCloud.com.example.app&lt;/key&gt;</span><br><span class=\"line\">        &lt;dict&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerIsDocumentScopePublic&lt;/key&gt;</span><br><span class=\"line\">            &lt;true/&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerName&lt;/key&gt;</span><br><span class=\"line\">            &lt;string&gt;App name to display in iCloud Drive&lt;/string&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerSupportedFolderLevels&lt;/key&gt;</span><br><span class=\"line\">            &lt;string&gt;None&lt;/string&gt;</span><br><span class=\"line\">        &lt;/dict&gt;</span><br><span class=\"line\">    &lt;/dict&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改版本构件号(必改)</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>修改 info.plist</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;NSUbiquitousContainers&lt;/key&gt;</span><br><span class=\"line\">    &lt;dict&gt;</span><br><span class=\"line\">        &lt;key&gt;iCloud.com.example.app&lt;/key&gt;</span><br><span class=\"line\">        &lt;dict&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerIsDocumentScopePublic&lt;/key&gt;</span><br><span class=\"line\">            &lt;true/&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerName&lt;/key&gt;</span><br><span class=\"line\">            &lt;string&gt;App name to display in iCloud Drive&lt;/string&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerSupportedFolderLevels&lt;/key&gt;</span><br><span class=\"line\">            &lt;string&gt;None&lt;/string&gt;</span><br><span class=\"line\">        &lt;/dict&gt;</span><br><span class=\"line\">    &lt;/dict&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改版本构件号(必改)</p>\n</li>\n</ol>\n"},{"title":"使用PHP进行webhook的注意点","author":"Arclin","abbrlink":"f8291fcc","date":"2018-02-18T13:55:00.000Z","_content":"有时会编写PHP脚本进行webhook, 这里有些地方需要注意一下, 否则会导致脚本执行失败\n\n<!-- more -->\n\n允许某些敏感方法的执行\n编辑`php.ini`\n\n```\ndisable_functions = scandir,passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,\nini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,\nstream_socket_server,fsocket,fsockopen\n```\n\n把`exec`去掉\n\n检查`apache`用户的目录权限\n\napache用户公钥要配置在项目里面\n也就是项目里会有两个公钥\n一个是root的一个是apache的","source":"_posts/使用php的exec方法进行webhook的注意点.md","raw":"---\ntitle: 使用PHP进行webhook的注意点\nauthor: Arclin\ntags:\n  - php\n  - webhook\ncategories:\n  - PHP\nabbrlink: f8291fcc\ndate: 2018-02-18 21:55:00\n---\n有时会编写PHP脚本进行webhook, 这里有些地方需要注意一下, 否则会导致脚本执行失败\n\n<!-- more -->\n\n允许某些敏感方法的执行\n编辑`php.ini`\n\n```\ndisable_functions = scandir,passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,\nini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,\nstream_socket_server,fsocket,fsockopen\n```\n\n把`exec`去掉\n\n检查`apache`用户的目录权限\n\napache用户公钥要配置在项目里面\n也就是项目里会有两个公钥\n一个是root的一个是apache的","slug":"使用php的exec方法进行webhook的注意点","published":1,"updated":"2018-05-10T06:51:35.758Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbclj003yldxugl6iabhm","content":"<p>有时会编写PHP脚本进行webhook, 这里有些地方需要注意一下, 否则会导致脚本执行失败</p>\n<a id=\"more\"></a>\n<p>允许某些敏感方法的执行<br>编辑<code>php.ini</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">disable_functions = scandir,passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,</span><br><span class=\"line\">ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,</span><br><span class=\"line\">stream_socket_server,fsocket,fsockopen</span><br></pre></td></tr></table></figure>\n<p>把<code>exec</code>去掉</p>\n<p>检查<code>apache</code>用户的目录权限</p>\n<p>apache用户公钥要配置在项目里面<br>也就是项目里会有两个公钥<br>一个是root的一个是apache的</p>\n","site":{"data":{}},"excerpt":"<p>有时会编写PHP脚本进行webhook, 这里有些地方需要注意一下, 否则会导致脚本执行失败</p>","more":"<p>允许某些敏感方法的执行<br>编辑<code>php.ini</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">disable_functions = scandir,passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,</span><br><span class=\"line\">ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,</span><br><span class=\"line\">stream_socket_server,fsocket,fsockopen</span><br></pre></td></tr></table></figure>\n<p>把<code>exec</code>去掉</p>\n<p>检查<code>apache</code>用户的目录权限</p>\n<p>apache用户公钥要配置在项目里面<br>也就是项目里会有两个公钥<br>一个是root的一个是apache的</p>"},{"title":"利用MJExtension取出模型数组中的某个属性组成数组","author":"Arclin","abbrlink":"8e2ebfdf","date":"2016-10-16T16:00:00.000Z","_content":"利用MJExtension取出模型数组中的某个属性组成数组\n\n<!-- more -->\n\n在做otg的时候想做这么一件事，就是遍历模型数组然后取出里面的属性值然后再保存到数组里，后来翻了翻MJExtension好像有类似的方法声明，试了一下果然可以\n\n```\nMJProperty *p = [[MJProperty alloc] init];\n[p setValue:@\"text\" forKey:@\"name\"]; \\\\ 因为name是readonly，所以我就只能用keyValue的方式去给他赋值了\nNSArray *arr = [p valueForObject:self.topics];\nNSLog(@\"%@\",arr);\n```\n\n如果包装一下大概就是这样子\n\n```\n- (NSArray *)fetchPropertys:(NSString *)propertyName fromObjects:(NSArray *)objects{\n\tMJProperty *p = [[MJProperty alloc] init];\n\t[p setValue:propertyName forKey:@\"name\"]; \n\treturn [p valueForObject:objects];\n}\n```\n\n弄个分类可能会比较方便吧\n\n```\n- (NSArray *)fetchPropertys:(NSString *)propertyName{\n\tMJProperty *p = [[MJProperty alloc] init];\n\t[p setValue:propertyName forKey:@\"name\"]; \n\treturn [p valueForObject:self];\n}\n```","source":"_posts/利用MJExtension取出模型数组中的某个属性组成数组.md","raw":"---\ntitle: 利用MJExtension取出模型数组中的某个属性组成数组\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 8e2ebfdf\ndate: 2016-10-17 00:00:00\n---\n利用MJExtension取出模型数组中的某个属性组成数组\n\n<!-- more -->\n\n在做otg的时候想做这么一件事，就是遍历模型数组然后取出里面的属性值然后再保存到数组里，后来翻了翻MJExtension好像有类似的方法声明，试了一下果然可以\n\n```\nMJProperty *p = [[MJProperty alloc] init];\n[p setValue:@\"text\" forKey:@\"name\"]; \\\\ 因为name是readonly，所以我就只能用keyValue的方式去给他赋值了\nNSArray *arr = [p valueForObject:self.topics];\nNSLog(@\"%@\",arr);\n```\n\n如果包装一下大概就是这样子\n\n```\n- (NSArray *)fetchPropertys:(NSString *)propertyName fromObjects:(NSArray *)objects{\n\tMJProperty *p = [[MJProperty alloc] init];\n\t[p setValue:propertyName forKey:@\"name\"]; \n\treturn [p valueForObject:objects];\n}\n```\n\n弄个分类可能会比较方便吧\n\n```\n- (NSArray *)fetchPropertys:(NSString *)propertyName{\n\tMJProperty *p = [[MJProperty alloc] init];\n\t[p setValue:propertyName forKey:@\"name\"]; \n\treturn [p valueForObject:self];\n}\n```","slug":"利用MJExtension取出模型数组中的某个属性组成数组","published":1,"updated":"2018-05-10T06:51:35.760Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbclo0042ldxutobpxygq","content":"<p>利用MJExtension取出模型数组中的某个属性组成数组</p>\n<a id=\"more\"></a>\n<p>在做otg的时候想做这么一件事，就是遍历模型数组然后取出里面的属性值然后再保存到数组里，后来翻了翻MJExtension好像有类似的方法声明，试了一下果然可以</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MJProperty *p = [[MJProperty alloc] init];</span><br><span class=\"line\">[p setValue:@&quot;text&quot; forKey:@&quot;name&quot;]; \\\\ 因为name是readonly，所以我就只能用keyValue的方式去给他赋值了</span><br><span class=\"line\">NSArray *arr = [p valueForObject:self.topics];</span><br><span class=\"line\">NSLog(@&quot;%@&quot;,arr);</span><br></pre></td></tr></table></figure>\n<p>如果包装一下大概就是这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)fetchPropertys:(NSString *)propertyName fromObjects:(NSArray *)objects&#123;</span><br><span class=\"line\">\tMJProperty *p = [[MJProperty alloc] init];</span><br><span class=\"line\">\t[p setValue:propertyName forKey:@&quot;name&quot;]; </span><br><span class=\"line\">\treturn [p valueForObject:objects];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>弄个分类可能会比较方便吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)fetchPropertys:(NSString *)propertyName&#123;</span><br><span class=\"line\">\tMJProperty *p = [[MJProperty alloc] init];</span><br><span class=\"line\">\t[p setValue:propertyName forKey:@&quot;name&quot;]; </span><br><span class=\"line\">\treturn [p valueForObject:self];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>利用MJExtension取出模型数组中的某个属性组成数组</p>","more":"<p>在做otg的时候想做这么一件事，就是遍历模型数组然后取出里面的属性值然后再保存到数组里，后来翻了翻MJExtension好像有类似的方法声明，试了一下果然可以</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MJProperty *p = [[MJProperty alloc] init];</span><br><span class=\"line\">[p setValue:@&quot;text&quot; forKey:@&quot;name&quot;]; \\\\ 因为name是readonly，所以我就只能用keyValue的方式去给他赋值了</span><br><span class=\"line\">NSArray *arr = [p valueForObject:self.topics];</span><br><span class=\"line\">NSLog(@&quot;%@&quot;,arr);</span><br></pre></td></tr></table></figure>\n<p>如果包装一下大概就是这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)fetchPropertys:(NSString *)propertyName fromObjects:(NSArray *)objects&#123;</span><br><span class=\"line\">\tMJProperty *p = [[MJProperty alloc] init];</span><br><span class=\"line\">\t[p setValue:propertyName forKey:@&quot;name&quot;]; </span><br><span class=\"line\">\treturn [p valueForObject:objects];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>弄个分类可能会比较方便吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)fetchPropertys:(NSString *)propertyName&#123;</span><br><span class=\"line\">\tMJProperty *p = [[MJProperty alloc] init];</span><br><span class=\"line\">\t[p setValue:propertyName forKey:@&quot;name&quot;]; </span><br><span class=\"line\">\treturn [p valueForObject:self];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"建造者模式","author":"Arclin","abbrlink":"fe816c3c","date":"2016-10-29T16:00:00.000Z","_content":"关于建造者模式的个人理解\n建造者模式适用于一个复杂的对象,但是他有多种构建方式,而且每种构建方式都不简单,写在一起不方便维护.建造者模式可以帮助分离对象和它的构建,使得调用相同的一个方法可以创建不同的表示.\n<!-- more -->\n比如说 蛋糕 对象,使用者需要通过调用一个方法,只要传入不同的参数,就可以返回草莓蛋糕,黑森林蛋糕,芝士蛋糕(懒得写了)等.\n\n举蛋糕的例子:\n怎么做蛋糕\n\n```\n- (void)viewDidLoad\n{\n\t[super viewDidLoad];\n\t// 想要什么蛋糕就只要实例化这个蛋糕(下订单)\n\tCakeBulider *bulider = [[StraberryCakeBulider alloc] init];\t\n\t\n\t// 然后让蛋糕店去做蛋糕\n\tCake *cake = [CakeStore createCake:bulider];\n\t\n\t// 看看蛋糕长什么样子\n\tNSLog(@\"%@\",cake.description);\n}\n```\n\nCake.m 蛋糕实体\n\n```\n@interface Cake : NSObject\n\n@property (nonatomic, assign)NSInteger *self.scream;// 奶油分量\n@property (nonatomic, copy)NSString *self.ingredients;// 配料\n@property (nonatomic, assign)NSInteger *self.bakeTime;// 烘焙时间\n// 还有等等好多好多参数，但是我只关心这些\n\n@end\n\n@implementation Cake\n\n// 让它做自我介绍\n- (NSString *)description{\n   return [NSString stringWithFormat:@\"我是一个蛋糕:奶油分量%zd 配料%@ 烘焙时间是:%zd\",self.scream,self.ingredients,self.bakeTime];\n}\n```\n\nCakeStore.m 卖蛋糕的店铺\n\n```\n+ (Cake *)createCake:(CakeBulider *)bulider\n{\n\tCake *cake = [bulider bakeCake];\n\treturn cake;\n}\n```\n\nCakeBulider.m 蛋糕自动烘焙机\n\n```\n- (Cake *)bakeCake\n{\n\tCake *cake = [[Cake alloc] init];\n\tcake.scream = self.scream;\n\tcake.ingredients = self.ingredients;\n\tcake.bakeTime = self.bakeTime;\n\tretrn cake;\n}\n```\n\nStrawberryCakeBulider.m 草莓蛋糕\n\n```\n@interface StrawberryCakeBulider():Cake\n@end\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.scream = 10;\n        self.ingredients = @\"strawberry\";\n        self.bakeTime = 10;\n    }\n    return self;\n}\n```\n\nBlackForestCakeBulider.m 黑森林蛋糕\n\n```\n@interface BlackForestCakeBulider():Cake\n@end\n\n- (instancetype)init\n{\n\tself = [super init];\n\tif(self){\n\t\tself.scream = 11;\n\t\tself.ingredients = @\"cholocate\";\n\t\tself.bakeTime = 5;\n\t}\n\treturn self;\n}\n```\n\n(话说大半夜的写蛋糕真的好吗)\n其实QCCloud那个项目说不定就会用到这个模式,所以在这里稍微复习一下,回忆之前的知识.\n\n(明天再去复习别的即将会用到的设计模式)","source":"_posts/建造者模式.md","raw":"---\ntitle: 建造者模式\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: fe816c3c\ndate: 2016-10-30 00:00:00\n---\n关于建造者模式的个人理解\n建造者模式适用于一个复杂的对象,但是他有多种构建方式,而且每种构建方式都不简单,写在一起不方便维护.建造者模式可以帮助分离对象和它的构建,使得调用相同的一个方法可以创建不同的表示.\n<!-- more -->\n比如说 蛋糕 对象,使用者需要通过调用一个方法,只要传入不同的参数,就可以返回草莓蛋糕,黑森林蛋糕,芝士蛋糕(懒得写了)等.\n\n举蛋糕的例子:\n怎么做蛋糕\n\n```\n- (void)viewDidLoad\n{\n\t[super viewDidLoad];\n\t// 想要什么蛋糕就只要实例化这个蛋糕(下订单)\n\tCakeBulider *bulider = [[StraberryCakeBulider alloc] init];\t\n\t\n\t// 然后让蛋糕店去做蛋糕\n\tCake *cake = [CakeStore createCake:bulider];\n\t\n\t// 看看蛋糕长什么样子\n\tNSLog(@\"%@\",cake.description);\n}\n```\n\nCake.m 蛋糕实体\n\n```\n@interface Cake : NSObject\n\n@property (nonatomic, assign)NSInteger *self.scream;// 奶油分量\n@property (nonatomic, copy)NSString *self.ingredients;// 配料\n@property (nonatomic, assign)NSInteger *self.bakeTime;// 烘焙时间\n// 还有等等好多好多参数，但是我只关心这些\n\n@end\n\n@implementation Cake\n\n// 让它做自我介绍\n- (NSString *)description{\n   return [NSString stringWithFormat:@\"我是一个蛋糕:奶油分量%zd 配料%@ 烘焙时间是:%zd\",self.scream,self.ingredients,self.bakeTime];\n}\n```\n\nCakeStore.m 卖蛋糕的店铺\n\n```\n+ (Cake *)createCake:(CakeBulider *)bulider\n{\n\tCake *cake = [bulider bakeCake];\n\treturn cake;\n}\n```\n\nCakeBulider.m 蛋糕自动烘焙机\n\n```\n- (Cake *)bakeCake\n{\n\tCake *cake = [[Cake alloc] init];\n\tcake.scream = self.scream;\n\tcake.ingredients = self.ingredients;\n\tcake.bakeTime = self.bakeTime;\n\tretrn cake;\n}\n```\n\nStrawberryCakeBulider.m 草莓蛋糕\n\n```\n@interface StrawberryCakeBulider():Cake\n@end\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.scream = 10;\n        self.ingredients = @\"strawberry\";\n        self.bakeTime = 10;\n    }\n    return self;\n}\n```\n\nBlackForestCakeBulider.m 黑森林蛋糕\n\n```\n@interface BlackForestCakeBulider():Cake\n@end\n\n- (instancetype)init\n{\n\tself = [super init];\n\tif(self){\n\t\tself.scream = 11;\n\t\tself.ingredients = @\"cholocate\";\n\t\tself.bakeTime = 5;\n\t}\n\treturn self;\n}\n```\n\n(话说大半夜的写蛋糕真的好吗)\n其实QCCloud那个项目说不定就会用到这个模式,所以在这里稍微复习一下,回忆之前的知识.\n\n(明天再去复习别的即将会用到的设计模式)","slug":"建造者模式","published":1,"updated":"2018-05-10T06:51:35.766Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcls0045ldxurbywjem5","content":"<p>关于建造者模式的个人理解<br>建造者模式适用于一个复杂的对象,但是他有多种构建方式,而且每种构建方式都不简单,写在一起不方便维护.建造者模式可以帮助分离对象和它的构建,使得调用相同的一个方法可以创建不同的表示.<br><a id=\"more\"></a><br>比如说 蛋糕 对象,使用者需要通过调用一个方法,只要传入不同的参数,就可以返回草莓蛋糕,黑森林蛋糕,芝士蛋糕(懒得写了)等.</p>\n<p>举蛋糕的例子:<br>怎么做蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[super viewDidLoad];</span><br><span class=\"line\">\t// 想要什么蛋糕就只要实例化这个蛋糕(下订单)</span><br><span class=\"line\">\tCakeBulider *bulider = [[StraberryCakeBulider alloc] init];\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t// 然后让蛋糕店去做蛋糕</span><br><span class=\"line\">\tCake *cake = [CakeStore createCake:bulider];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t// 看看蛋糕长什么样子</span><br><span class=\"line\">\tNSLog(@&quot;%@&quot;,cake.description);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Cake.m 蛋糕实体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Cake : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, assign)NSInteger *self.scream;// 奶油分量</span><br><span class=\"line\">@property (nonatomic, copy)NSString *self.ingredients;// 配料</span><br><span class=\"line\">@property (nonatomic, assign)NSInteger *self.bakeTime;// 烘焙时间</span><br><span class=\"line\">// 还有等等好多好多参数，但是我只关心这些</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Cake</span><br><span class=\"line\"></span><br><span class=\"line\">// 让它做自我介绍</span><br><span class=\"line\">- (NSString *)description&#123;</span><br><span class=\"line\">   return [NSString stringWithFormat:@&quot;我是一个蛋糕:奶油分量%zd 配料%@ 烘焙时间是:%zd&quot;,self.scream,self.ingredients,self.bakeTime];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>CakeStore.m 卖蛋糕的店铺</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (Cake *)createCake:(CakeBulider *)bulider</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tCake *cake = [bulider bakeCake];</span><br><span class=\"line\">\treturn cake;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>CakeBulider.m 蛋糕自动烘焙机</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (Cake *)bakeCake</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tCake *cake = [[Cake alloc] init];</span><br><span class=\"line\">\tcake.scream = self.scream;</span><br><span class=\"line\">\tcake.ingredients = self.ingredients;</span><br><span class=\"line\">\tcake.bakeTime = self.bakeTime;</span><br><span class=\"line\">\tretrn cake;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>StrawberryCakeBulider.m 草莓蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface StrawberryCakeBulider():Cake</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self = [super init];</span><br><span class=\"line\">    if (self) &#123;</span><br><span class=\"line\">        self.scream = 10;</span><br><span class=\"line\">        self.ingredients = @&quot;strawberry&quot;;</span><br><span class=\"line\">        self.bakeTime = 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>BlackForestCakeBulider.m 黑森林蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface BlackForestCakeBulider():Cake</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tself = [super init];</span><br><span class=\"line\">\tif(self)&#123;</span><br><span class=\"line\">\t\tself.scream = 11;</span><br><span class=\"line\">\t\tself.ingredients = @&quot;cholocate&quot;;</span><br><span class=\"line\">\t\tself.bakeTime = 5;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(话说大半夜的写蛋糕真的好吗)<br>其实QCCloud那个项目说不定就会用到这个模式,所以在这里稍微复习一下,回忆之前的知识.</p>\n<p>(明天再去复习别的即将会用到的设计模式)</p>\n","site":{"data":{}},"excerpt":"<p>关于建造者模式的个人理解<br>建造者模式适用于一个复杂的对象,但是他有多种构建方式,而且每种构建方式都不简单,写在一起不方便维护.建造者模式可以帮助分离对象和它的构建,使得调用相同的一个方法可以创建不同的表示.<br>","more":"<br>比如说 蛋糕 对象,使用者需要通过调用一个方法,只要传入不同的参数,就可以返回草莓蛋糕,黑森林蛋糕,芝士蛋糕(懒得写了)等.</p>\n<p>举蛋糕的例子:<br>怎么做蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[super viewDidLoad];</span><br><span class=\"line\">\t// 想要什么蛋糕就只要实例化这个蛋糕(下订单)</span><br><span class=\"line\">\tCakeBulider *bulider = [[StraberryCakeBulider alloc] init];\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t// 然后让蛋糕店去做蛋糕</span><br><span class=\"line\">\tCake *cake = [CakeStore createCake:bulider];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t// 看看蛋糕长什么样子</span><br><span class=\"line\">\tNSLog(@&quot;%@&quot;,cake.description);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Cake.m 蛋糕实体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Cake : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, assign)NSInteger *self.scream;// 奶油分量</span><br><span class=\"line\">@property (nonatomic, copy)NSString *self.ingredients;// 配料</span><br><span class=\"line\">@property (nonatomic, assign)NSInteger *self.bakeTime;// 烘焙时间</span><br><span class=\"line\">// 还有等等好多好多参数，但是我只关心这些</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Cake</span><br><span class=\"line\"></span><br><span class=\"line\">// 让它做自我介绍</span><br><span class=\"line\">- (NSString *)description&#123;</span><br><span class=\"line\">   return [NSString stringWithFormat:@&quot;我是一个蛋糕:奶油分量%zd 配料%@ 烘焙时间是:%zd&quot;,self.scream,self.ingredients,self.bakeTime];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>CakeStore.m 卖蛋糕的店铺</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (Cake *)createCake:(CakeBulider *)bulider</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tCake *cake = [bulider bakeCake];</span><br><span class=\"line\">\treturn cake;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>CakeBulider.m 蛋糕自动烘焙机</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (Cake *)bakeCake</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tCake *cake = [[Cake alloc] init];</span><br><span class=\"line\">\tcake.scream = self.scream;</span><br><span class=\"line\">\tcake.ingredients = self.ingredients;</span><br><span class=\"line\">\tcake.bakeTime = self.bakeTime;</span><br><span class=\"line\">\tretrn cake;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>StrawberryCakeBulider.m 草莓蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface StrawberryCakeBulider():Cake</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self = [super init];</span><br><span class=\"line\">    if (self) &#123;</span><br><span class=\"line\">        self.scream = 10;</span><br><span class=\"line\">        self.ingredients = @&quot;strawberry&quot;;</span><br><span class=\"line\">        self.bakeTime = 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>BlackForestCakeBulider.m 黑森林蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface BlackForestCakeBulider():Cake</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tself = [super init];</span><br><span class=\"line\">\tif(self)&#123;</span><br><span class=\"line\">\t\tself.scream = 11;</span><br><span class=\"line\">\t\tself.ingredients = @&quot;cholocate&quot;;</span><br><span class=\"line\">\t\tself.bakeTime = 5;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>(话说大半夜的写蛋糕真的好吗)<br>其实QCCloud那个项目说不定就会用到这个模式,所以在这里稍微复习一下,回忆之前的知识.</p>\n<p>(明天再去复习别的即将会用到的设计模式)</p>"},{"title":"使用RAC+DKHTTPTool实践","author":"Arclin","abbrlink":"8d52056b","date":"2016-12-25T16:00:00.000Z","_content":"使用RAC+DKHTTP套件实践\n- 这次通过一个简单的例子来解说DKHTTP套件与 RAC 结合的使用\n\n<!-- more -->\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/444.png?raw=true)\n\n- 首先简析下这个界面\n\t- 顶部搜索框部分的背景：广告栏位+图书推荐的图片，这里是一个获取图片的接口（接口 A）\n\t- 图书推荐： 这里也是一个接口，需要显示图书的封面（接口 B）\n\t- 笔记推荐： 这里也是一个接口，需要显示图书笔记的一些简介 （接口 C）\n- 页面渲染\n\n\t- 同页面多接口的渲染方式有多种： \n    \t-\t一是接口的串联，也就是一个接口返回的数据交作为参数给下一个接口去发送请求 ；\n    \t- 二是同时发送请求，根据接口返回的顺序渲染页面；\n    \t- 三是同时请求，等所有的接口返回之后再一次性进行渲染。\n\t- 上面的三种渲染方式，RACSignal都有相应的解决方案，假设这里页面渲染的方式选择的是依次渲染，那么我们使用 DKHTTPChainTool 的executeSignal()来写个例子\n\n```\n RACSignal *signalA = DKHTTPChainInstance.method(@\"POST\")\n                                         .url(@\"\")\n                                         .params(@{@\"did\":@\"1\",@\"page\":@\"1\",@\"num\":@\"100\"})\n                                         .executeSignal();\n\nRACSignal *signalB = DKHTTPChainInstance.method(@\"POST\")\n                                        .url(@\"\")\n                                        .params(@{@\"dis_id\":@\"9\"})\n                                        .executeSignal();\n\nRACSignal *signalC = DKHTTPChainInstance.method(@\"POST\")\n                                        .url(@\"\")\n                                        .params(@{@\"dis_id\":@\"9\"})\n                                        .executeSignal();\n\nRACSignal *mergeSignal = [RACSignal merge:@[signalA,signalB,signalC]];\n[mergeSignal subscribeNext:^(DKResponse *x){\n      DKLog(@\"%zd  %@\",x.taskIdentifier,x.rawData);\n}];\n```\n\n上面这个例子的结果会依次执行三个接口，并且按照接口返回的顺序执行mergeSignal 的 subscribeNext 的 block\n\n### 同时请求接口，等所有接口返回数据之后再进行渲染\n\n> 上面的三个 Signal就不重复写了\n\n```\nRACSignal *mergeSignal  = [RACSignal zip:@[signalA,signalB,signalC]];\n[mergeSignal subscribeNext:^(RACTuple *x){\n     [x.rac_sequence.signal subscribeNext:^(DKResponse *x) {\n         DKLog(@\"%@\",x.rawData);\n     }];\n}];\n```\n\n上面的 `mergeSignal` 里面会发送一个 `RACTuple` ,里面依次包装着三个请求 Signal的 `DKResponse`回调对象\n\n### 接口串联，上一个接口响应的数据作为下一个接口的参数\n\n```\n RACSignal *flattenSignal = [signalA flattenMap:^RACStream *(DKResponse *value) {\n        NSString *did = value.result[@\"content\"][0][@\"d_id\"];\n        return DKHTTPChainInstance.method(@\"GET\")\n                                 .url(@\"\")\n                                 .params(@{@\"did\":did,@\"page\":@\"1\",@\"num\":@\"20\"})\n                                 .executeSignal();\n}];\n[flattenSignal subscribeNext:^(DKResponse *x) {\n    DKLog(@\"%@\",x.rawData);\n}];\n```\n\n平时常用的大概就这么几个，待补充吧，之后我会继续讲讲关于异常处理的问题。","source":"_posts/使用RAC-DKHTTPTool实践.md","raw":"---\ntitle: 使用RAC+DKHTTPTool实践\nauthor: Arclin\ntags:\n  - iOS\n  - Reactive Cocoa\ncategories:\n  - iOS\nabbrlink: 8d52056b\ndate: 2016-12-26 00:00:00\n---\n使用RAC+DKHTTP套件实践\n- 这次通过一个简单的例子来解说DKHTTP套件与 RAC 结合的使用\n\n<!-- more -->\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/444.png?raw=true)\n\n- 首先简析下这个界面\n\t- 顶部搜索框部分的背景：广告栏位+图书推荐的图片，这里是一个获取图片的接口（接口 A）\n\t- 图书推荐： 这里也是一个接口，需要显示图书的封面（接口 B）\n\t- 笔记推荐： 这里也是一个接口，需要显示图书笔记的一些简介 （接口 C）\n- 页面渲染\n\n\t- 同页面多接口的渲染方式有多种： \n    \t-\t一是接口的串联，也就是一个接口返回的数据交作为参数给下一个接口去发送请求 ；\n    \t- 二是同时发送请求，根据接口返回的顺序渲染页面；\n    \t- 三是同时请求，等所有的接口返回之后再一次性进行渲染。\n\t- 上面的三种渲染方式，RACSignal都有相应的解决方案，假设这里页面渲染的方式选择的是依次渲染，那么我们使用 DKHTTPChainTool 的executeSignal()来写个例子\n\n```\n RACSignal *signalA = DKHTTPChainInstance.method(@\"POST\")\n                                         .url(@\"\")\n                                         .params(@{@\"did\":@\"1\",@\"page\":@\"1\",@\"num\":@\"100\"})\n                                         .executeSignal();\n\nRACSignal *signalB = DKHTTPChainInstance.method(@\"POST\")\n                                        .url(@\"\")\n                                        .params(@{@\"dis_id\":@\"9\"})\n                                        .executeSignal();\n\nRACSignal *signalC = DKHTTPChainInstance.method(@\"POST\")\n                                        .url(@\"\")\n                                        .params(@{@\"dis_id\":@\"9\"})\n                                        .executeSignal();\n\nRACSignal *mergeSignal = [RACSignal merge:@[signalA,signalB,signalC]];\n[mergeSignal subscribeNext:^(DKResponse *x){\n      DKLog(@\"%zd  %@\",x.taskIdentifier,x.rawData);\n}];\n```\n\n上面这个例子的结果会依次执行三个接口，并且按照接口返回的顺序执行mergeSignal 的 subscribeNext 的 block\n\n### 同时请求接口，等所有接口返回数据之后再进行渲染\n\n> 上面的三个 Signal就不重复写了\n\n```\nRACSignal *mergeSignal  = [RACSignal zip:@[signalA,signalB,signalC]];\n[mergeSignal subscribeNext:^(RACTuple *x){\n     [x.rac_sequence.signal subscribeNext:^(DKResponse *x) {\n         DKLog(@\"%@\",x.rawData);\n     }];\n}];\n```\n\n上面的 `mergeSignal` 里面会发送一个 `RACTuple` ,里面依次包装着三个请求 Signal的 `DKResponse`回调对象\n\n### 接口串联，上一个接口响应的数据作为下一个接口的参数\n\n```\n RACSignal *flattenSignal = [signalA flattenMap:^RACStream *(DKResponse *value) {\n        NSString *did = value.result[@\"content\"][0][@\"d_id\"];\n        return DKHTTPChainInstance.method(@\"GET\")\n                                 .url(@\"\")\n                                 .params(@{@\"did\":did,@\"page\":@\"1\",@\"num\":@\"20\"})\n                                 .executeSignal();\n}];\n[flattenSignal subscribeNext:^(DKResponse *x) {\n    DKLog(@\"%@\",x.rawData);\n}];\n```\n\n平时常用的大概就这么几个，待补充吧，之后我会继续讲讲关于异常处理的问题。","slug":"使用RAC-DKHTTPTool实践","published":1,"updated":"2018-05-10T06:51:35.757Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbclx0049ldxu2fl343p3","content":"<p>使用RAC+DKHTTP套件实践</p>\n<ul>\n<li>这次通过一个简单的例子来解说DKHTTP套件与 RAC 结合的使用</li>\n</ul>\n<a id=\"more\"></a>\n<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/444.png?raw=true\" alt=\"\"></p>\n<ul>\n<li>首先简析下这个界面<ul>\n<li>顶部搜索框部分的背景：广告栏位+图书推荐的图片，这里是一个获取图片的接口（接口 A）</li>\n<li>图书推荐： 这里也是一个接口，需要显示图书的封面（接口 B）</li>\n<li>笔记推荐： 这里也是一个接口，需要显示图书笔记的一些简介 （接口 C）</li>\n</ul>\n</li>\n<li><p>页面渲染</p>\n<ul>\n<li>同页面多接口的渲染方式有多种： <ul>\n<li>一是接口的串联，也就是一个接口返回的数据交作为参数给下一个接口去发送请求 ；</li>\n<li>二是同时发送请求，根据接口返回的顺序渲染页面；</li>\n<li>三是同时请求，等所有的接口返回之后再一次性进行渲染。</li>\n</ul>\n</li>\n<li>上面的三种渲染方式，RACSignal都有相应的解决方案，假设这里页面渲染的方式选择的是依次渲染，那么我们使用 DKHTTPChainTool 的executeSignal()来写个例子</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> RACSignal *signalA = DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                         .url(@&quot;&quot;)</span><br><span class=\"line\">                                         .params(@&#123;@&quot;did&quot;:@&quot;1&quot;,@&quot;page&quot;:@&quot;1&quot;,@&quot;num&quot;:@&quot;100&quot;&#125;)</span><br><span class=\"line\">                                         .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *signalB = DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url(@&quot;&quot;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;dis_id&quot;:@&quot;9&quot;&#125;)</span><br><span class=\"line\">                                        .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *signalC = DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url(@&quot;&quot;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;dis_id&quot;:@&quot;9&quot;&#125;)</span><br><span class=\"line\">                                        .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *mergeSignal = [RACSignal merge:@[signalA,signalB,signalC]];</span><br><span class=\"line\">[mergeSignal subscribeNext:^(DKResponse *x)&#123;</span><br><span class=\"line\">      DKLog(@&quot;%zd  %@&quot;,x.taskIdentifier,x.rawData);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>上面这个例子的结果会依次执行三个接口，并且按照接口返回的顺序执行mergeSignal 的 subscribeNext 的 block</p>\n<h3 id=\"同时请求接口，等所有接口返回数据之后再进行渲染\"><a href=\"#同时请求接口，等所有接口返回数据之后再进行渲染\" class=\"headerlink\" title=\"同时请求接口，等所有接口返回数据之后再进行渲染\"></a>同时请求接口，等所有接口返回数据之后再进行渲染</h3><blockquote>\n<p>上面的三个 Signal就不重复写了</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *mergeSignal  = [RACSignal zip:@[signalA,signalB,signalC]];</span><br><span class=\"line\">[mergeSignal subscribeNext:^(RACTuple *x)&#123;</span><br><span class=\"line\">     [x.rac_sequence.signal subscribeNext:^(DKResponse *x) &#123;</span><br><span class=\"line\">         DKLog(@&quot;%@&quot;,x.rawData);</span><br><span class=\"line\">     &#125;];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>上面的 <code>mergeSignal</code> 里面会发送一个 <code>RACTuple</code> ,里面依次包装着三个请求 Signal的 <code>DKResponse</code>回调对象</p>\n<h3 id=\"接口串联，上一个接口响应的数据作为下一个接口的参数\"><a href=\"#接口串联，上一个接口响应的数据作为下一个接口的参数\" class=\"headerlink\" title=\"接口串联，上一个接口响应的数据作为下一个接口的参数\"></a>接口串联，上一个接口响应的数据作为下一个接口的参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> RACSignal *flattenSignal = [signalA flattenMap:^RACStream *(DKResponse *value) &#123;</span><br><span class=\"line\">        NSString *did = value.result[@&quot;content&quot;][0][@&quot;d_id&quot;];</span><br><span class=\"line\">        return DKHTTPChainInstance.method(@&quot;GET&quot;)</span><br><span class=\"line\">                                 .url(@&quot;&quot;)</span><br><span class=\"line\">                                 .params(@&#123;@&quot;did&quot;:did,@&quot;page&quot;:@&quot;1&quot;,@&quot;num&quot;:@&quot;20&quot;&#125;)</span><br><span class=\"line\">                                 .executeSignal();</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">[flattenSignal subscribeNext:^(DKResponse *x) &#123;</span><br><span class=\"line\">    DKLog(@&quot;%@&quot;,x.rawData);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>平时常用的大概就这么几个，待补充吧，之后我会继续讲讲关于异常处理的问题。</p>\n","site":{"data":{}},"excerpt":"<p>使用RAC+DKHTTP套件实践</p>\n<ul>\n<li>这次通过一个简单的例子来解说DKHTTP套件与 RAC 结合的使用</li>\n</ul>","more":"<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/444.png?raw=true\" alt=\"\"></p>\n<ul>\n<li>首先简析下这个界面<ul>\n<li>顶部搜索框部分的背景：广告栏位+图书推荐的图片，这里是一个获取图片的接口（接口 A）</li>\n<li>图书推荐： 这里也是一个接口，需要显示图书的封面（接口 B）</li>\n<li>笔记推荐： 这里也是一个接口，需要显示图书笔记的一些简介 （接口 C）</li>\n</ul>\n</li>\n<li><p>页面渲染</p>\n<ul>\n<li>同页面多接口的渲染方式有多种： <ul>\n<li>一是接口的串联，也就是一个接口返回的数据交作为参数给下一个接口去发送请求 ；</li>\n<li>二是同时发送请求，根据接口返回的顺序渲染页面；</li>\n<li>三是同时请求，等所有的接口返回之后再一次性进行渲染。</li>\n</ul>\n</li>\n<li>上面的三种渲染方式，RACSignal都有相应的解决方案，假设这里页面渲染的方式选择的是依次渲染，那么我们使用 DKHTTPChainTool 的executeSignal()来写个例子</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> RACSignal *signalA = DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                         .url(@&quot;&quot;)</span><br><span class=\"line\">                                         .params(@&#123;@&quot;did&quot;:@&quot;1&quot;,@&quot;page&quot;:@&quot;1&quot;,@&quot;num&quot;:@&quot;100&quot;&#125;)</span><br><span class=\"line\">                                         .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *signalB = DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url(@&quot;&quot;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;dis_id&quot;:@&quot;9&quot;&#125;)</span><br><span class=\"line\">                                        .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *signalC = DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url(@&quot;&quot;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;dis_id&quot;:@&quot;9&quot;&#125;)</span><br><span class=\"line\">                                        .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *mergeSignal = [RACSignal merge:@[signalA,signalB,signalC]];</span><br><span class=\"line\">[mergeSignal subscribeNext:^(DKResponse *x)&#123;</span><br><span class=\"line\">      DKLog(@&quot;%zd  %@&quot;,x.taskIdentifier,x.rawData);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>上面这个例子的结果会依次执行三个接口，并且按照接口返回的顺序执行mergeSignal 的 subscribeNext 的 block</p>\n<h3 id=\"同时请求接口，等所有接口返回数据之后再进行渲染\"><a href=\"#同时请求接口，等所有接口返回数据之后再进行渲染\" class=\"headerlink\" title=\"同时请求接口，等所有接口返回数据之后再进行渲染\"></a>同时请求接口，等所有接口返回数据之后再进行渲染</h3><blockquote>\n<p>上面的三个 Signal就不重复写了</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *mergeSignal  = [RACSignal zip:@[signalA,signalB,signalC]];</span><br><span class=\"line\">[mergeSignal subscribeNext:^(RACTuple *x)&#123;</span><br><span class=\"line\">     [x.rac_sequence.signal subscribeNext:^(DKResponse *x) &#123;</span><br><span class=\"line\">         DKLog(@&quot;%@&quot;,x.rawData);</span><br><span class=\"line\">     &#125;];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>上面的 <code>mergeSignal</code> 里面会发送一个 <code>RACTuple</code> ,里面依次包装着三个请求 Signal的 <code>DKResponse</code>回调对象</p>\n<h3 id=\"接口串联，上一个接口响应的数据作为下一个接口的参数\"><a href=\"#接口串联，上一个接口响应的数据作为下一个接口的参数\" class=\"headerlink\" title=\"接口串联，上一个接口响应的数据作为下一个接口的参数\"></a>接口串联，上一个接口响应的数据作为下一个接口的参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> RACSignal *flattenSignal = [signalA flattenMap:^RACStream *(DKResponse *value) &#123;</span><br><span class=\"line\">        NSString *did = value.result[@&quot;content&quot;][0][@&quot;d_id&quot;];</span><br><span class=\"line\">        return DKHTTPChainInstance.method(@&quot;GET&quot;)</span><br><span class=\"line\">                                 .url(@&quot;&quot;)</span><br><span class=\"line\">                                 .params(@&#123;@&quot;did&quot;:did,@&quot;page&quot;:@&quot;1&quot;,@&quot;num&quot;:@&quot;20&quot;&#125;)</span><br><span class=\"line\">                                 .executeSignal();</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">[flattenSignal subscribeNext:^(DKResponse *x) &#123;</span><br><span class=\"line\">    DKLog(@&quot;%@&quot;,x.rawData);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>平时常用的大概就这么几个，待补充吧，之后我会继续讲讲关于异常处理的问题。</p>"},{"title":"什么时候用weakSelf什么时候用strongSelf","author":"Arclin","abbrlink":"f9b1d95c","date":"2016-10-16T16:00:00.000Z","_content":"#### 什么时候用weakSelf 什么时候用 strongSelf\n\n - Objective C 的 Block 是一个很实用的语法，特别是与GCD结合使用，可以很方便地实现并发、异步任务。但是，如果使用不当，Block 也会引起一些循环引用问题(retain cycle)—— Block 会 retain ‘self’，而 ‘self‘ 又 retain 了 Block。因为在 ObjC 中，直接调用一个实例变量，会被编译器处理成 ‘self->theVar’，’self’ 是一个 strong 类型的变量，引用计数会加 1，于是，self retains queue， queue retains block，block retains self。\n\n - 解决 retain circle\n\n \t- Apple 官方的建议是，传进 Block 之前，把 ‘self’ 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。\n示例代码：\n\n```\n__weak typeof(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ \n\t[weakSelf doSomething]; \n});\n```\n\n - clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：\n\n```\n__weak typeof(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n \t[weakSelf doSomething]; \n \t[weakSelf doOtherThing]; \n});\n```\n\n - 在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，于是，strongSelf 就派上用场了：\n\n```\n__weak __typeof__(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n \t__strong typeof(self) strongSelf = weakSelf;\n   [strongSelf doSomething];\n   [strongSelf doOtherThing];\n });\n```\n\n - __strong 确保在 Block 内，strongSelf 不会被释放。\n\n- 总结\n\n\t- 在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。\n\n\t- 如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。","source":"_posts/什么时候用weakSelf什么时候用strongSelf.md","raw":"---\ntitle: 什么时候用weakSelf什么时候用strongSelf\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: f9b1d95c\ndate: 2016-10-17 00:00:00\n---\n#### 什么时候用weakSelf 什么时候用 strongSelf\n\n - Objective C 的 Block 是一个很实用的语法，特别是与GCD结合使用，可以很方便地实现并发、异步任务。但是，如果使用不当，Block 也会引起一些循环引用问题(retain cycle)—— Block 会 retain ‘self’，而 ‘self‘ 又 retain 了 Block。因为在 ObjC 中，直接调用一个实例变量，会被编译器处理成 ‘self->theVar’，’self’ 是一个 strong 类型的变量，引用计数会加 1，于是，self retains queue， queue retains block，block retains self。\n\n - 解决 retain circle\n\n \t- Apple 官方的建议是，传进 Block 之前，把 ‘self’ 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。\n示例代码：\n\n```\n__weak typeof(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ \n\t[weakSelf doSomething]; \n});\n```\n\n - clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：\n\n```\n__weak typeof(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n \t[weakSelf doSomething]; \n \t[weakSelf doOtherThing]; \n});\n```\n\n - 在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，于是，strongSelf 就派上用场了：\n\n```\n__weak __typeof__(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n \t__strong typeof(self) strongSelf = weakSelf;\n   [strongSelf doSomething];\n   [strongSelf doOtherThing];\n });\n```\n\n - __strong 确保在 Block 内，strongSelf 不会被释放。\n\n- 总结\n\n\t- 在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。\n\n\t- 如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。","slug":"什么时候用weakSelf什么时候用strongSelf","published":1,"updated":"2018-05-10T06:51:35.755Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcm1004cldxuksoi7gxv","content":"<h4 id=\"什么时候用weakSelf-什么时候用-strongSelf\"><a href=\"#什么时候用weakSelf-什么时候用-strongSelf\" class=\"headerlink\" title=\"什么时候用weakSelf 什么时候用 strongSelf\"></a>什么时候用weakSelf 什么时候用 strongSelf</h4><ul>\n<li><p>Objective C 的 Block 是一个很实用的语法，特别是与GCD结合使用，可以很方便地实现并发、异步任务。但是，如果使用不当，Block 也会引起一些循环引用问题(retain cycle)—— Block 会 retain ‘self’，而 ‘self‘ 又 retain 了 Block。因为在 ObjC 中，直接调用一个实例变量，会被编译器处理成 ‘self-&gt;theVar’，’self’ 是一个 strong 类型的变量，引用计数会加 1，于是，self retains queue， queue retains block，block retains self。</p>\n</li>\n<li><p>解决 retain circle</p>\n<ul>\n<li>Apple 官方的建议是，传进 Block 之前，把 ‘self’ 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。<br>示例代码：</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak typeof(self) weakSelf = self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; </span><br><span class=\"line\">\t[weakSelf doSomething]; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak typeof(self) weakSelf = self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\"> \t[weakSelf doSomething]; </span><br><span class=\"line\"> \t[weakSelf doOtherThing]; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，于是，strongSelf 就派上用场了：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak __typeof__(self) weakSelf = self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\"> \t__strong typeof(self) strongSelf = weakSelf;</span><br><span class=\"line\">   [strongSelf doSomething];</span><br><span class=\"line\">   [strongSelf doOtherThing];</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>__strong 确保在 Block 内，strongSelf 不会被释放。</li>\n</ul>\n<ul>\n<li><p>总结</p>\n<ul>\n<li><p>在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。</p>\n</li>\n<li><p>如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么时候用weakSelf-什么时候用-strongSelf\"><a href=\"#什么时候用weakSelf-什么时候用-strongSelf\" class=\"headerlink\" title=\"什么时候用weakSelf 什么时候用 strongSelf\"></a>什么时候用weakSelf 什么时候用 strongSelf</h4><ul>\n<li><p>Objective C 的 Block 是一个很实用的语法，特别是与GCD结合使用，可以很方便地实现并发、异步任务。但是，如果使用不当，Block 也会引起一些循环引用问题(retain cycle)—— Block 会 retain ‘self’，而 ‘self‘ 又 retain 了 Block。因为在 ObjC 中，直接调用一个实例变量，会被编译器处理成 ‘self-&gt;theVar’，’self’ 是一个 strong 类型的变量，引用计数会加 1，于是，self retains queue， queue retains block，block retains self。</p>\n</li>\n<li><p>解决 retain circle</p>\n<ul>\n<li>Apple 官方的建议是，传进 Block 之前，把 ‘self’ 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。<br>示例代码：</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak typeof(self) weakSelf = self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; </span><br><span class=\"line\">\t[weakSelf doSomething]; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak typeof(self) weakSelf = self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\"> \t[weakSelf doSomething]; </span><br><span class=\"line\"> \t[weakSelf doOtherThing]; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，于是，strongSelf 就派上用场了：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak __typeof__(self) weakSelf = self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\"> \t__strong typeof(self) strongSelf = weakSelf;</span><br><span class=\"line\">   [strongSelf doSomething];</span><br><span class=\"line\">   [strongSelf doOtherThing];</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>__strong 确保在 Block 内，strongSelf 不会被释放。</li>\n</ul>\n<ul>\n<li><p>总结</p>\n<ul>\n<li><p>在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。</p>\n</li>\n<li><p>如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"用flow.ci做iOS的持续化集成","author":"Arclin","abbrlink":"2281692e","date":"2017-02-23T16:00:00.000Z","_content":"听说flow.ci上线公测了,赶紧拿着一把限时免费资格玩一玩体验一下.\n\n<!-- more -->\n\n结论: 一套下来行云流水,配置上基本没啥大问题,感觉还是挺好用的.可以支持简单的项目\n\n官方中文文档在这里\n\n里面讲的相当详细,在这里我就讲点注意点就好\n\n1. 如果你想达到的功能除了编译打包外,还想上传到fir,并且想拿最新的git commit 信息作为fir版本更新备注,那么你的工作流可以这么配\n![](https://github.com/Arc-lin/BlogImage/blob/master/1012.png?raw=true)\n2. ‘自定义脚本’里面写的是export CHANGE_LOG=$(git log --pretty=format:\"%s\" -1 $describe) 然后 fir.im 上传插件 中 FIR_CHANGELOG就直接写$CHANGE_LOG这样子就可以做到拿最新的git commit 信息作为fir版本更新备注, $FIR_APP_PATH里面就直接写$FIR_APP_PATH就好了\n3. ‘缓存’那里启用一下安装速度会快些\n4. 如果你的git的根目录不是你项目的根目录的话,你要添加一个’环境变量’(就像上面的图),详情看这里\n5. ‘编译’那里的’Workspace’,填的时候记得把’.xcworkspace’后缀带上\n6. ‘编译’那里的’Workspace’和’Project’两个选一个填,不能一起填\n7. 大概就这么多,以后我遇到啥再补充","source":"_posts/用flow-ci做iOS的持续化集成.md","raw":"---\ntitle: 用flow.ci做iOS的持续化集成\nauthor: Arclin\ntags:\n  - Flow.ci\n  - iOS\ncategories:\n  - iOS\nabbrlink: 2281692e\ndate: 2017-02-24 00:00:00\n---\n听说flow.ci上线公测了,赶紧拿着一把限时免费资格玩一玩体验一下.\n\n<!-- more -->\n\n结论: 一套下来行云流水,配置上基本没啥大问题,感觉还是挺好用的.可以支持简单的项目\n\n官方中文文档在这里\n\n里面讲的相当详细,在这里我就讲点注意点就好\n\n1. 如果你想达到的功能除了编译打包外,还想上传到fir,并且想拿最新的git commit 信息作为fir版本更新备注,那么你的工作流可以这么配\n![](https://github.com/Arc-lin/BlogImage/blob/master/1012.png?raw=true)\n2. ‘自定义脚本’里面写的是export CHANGE_LOG=$(git log --pretty=format:\"%s\" -1 $describe) 然后 fir.im 上传插件 中 FIR_CHANGELOG就直接写$CHANGE_LOG这样子就可以做到拿最新的git commit 信息作为fir版本更新备注, $FIR_APP_PATH里面就直接写$FIR_APP_PATH就好了\n3. ‘缓存’那里启用一下安装速度会快些\n4. 如果你的git的根目录不是你项目的根目录的话,你要添加一个’环境变量’(就像上面的图),详情看这里\n5. ‘编译’那里的’Workspace’,填的时候记得把’.xcworkspace’后缀带上\n6. ‘编译’那里的’Workspace’和’Project’两个选一个填,不能一起填\n7. 大概就这么多,以后我遇到啥再补充","slug":"用flow-ci做iOS的持续化集成","published":1,"updated":"2018-05-10T06:51:35.768Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcm4004gldxub4cyzfgs","content":"<p>听说flow.ci上线公测了,赶紧拿着一把限时免费资格玩一玩体验一下.</p>\n<a id=\"more\"></a>\n<p>结论: 一套下来行云流水,配置上基本没啥大问题,感觉还是挺好用的.可以支持简单的项目</p>\n<p>官方中文文档在这里</p>\n<p>里面讲的相当详细,在这里我就讲点注意点就好</p>\n<ol>\n<li>如果你想达到的功能除了编译打包外,还想上传到fir,并且想拿最新的git commit 信息作为fir版本更新备注,那么你的工作流可以这么配<br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/1012.png?raw=true\" alt=\"\"></li>\n<li>‘自定义脚本’里面写的是export CHANGE_LOG=$(git log –pretty=format:”%s” -1 $describe) 然后 fir.im 上传插件 中 FIR_CHANGELOG就直接写$CHANGE_LOG这样子就可以做到拿最新的git commit 信息作为fir版本更新备注, $FIR_APP_PATH里面就直接写$FIR_APP_PATH就好了</li>\n<li>‘缓存’那里启用一下安装速度会快些</li>\n<li>如果你的git的根目录不是你项目的根目录的话,你要添加一个’环境变量’(就像上面的图),详情看这里</li>\n<li>‘编译’那里的’Workspace’,填的时候记得把’.xcworkspace’后缀带上</li>\n<li>‘编译’那里的’Workspace’和’Project’两个选一个填,不能一起填</li>\n<li>大概就这么多,以后我遇到啥再补充</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>听说flow.ci上线公测了,赶紧拿着一把限时免费资格玩一玩体验一下.</p>","more":"<p>结论: 一套下来行云流水,配置上基本没啥大问题,感觉还是挺好用的.可以支持简单的项目</p>\n<p>官方中文文档在这里</p>\n<p>里面讲的相当详细,在这里我就讲点注意点就好</p>\n<ol>\n<li>如果你想达到的功能除了编译打包外,还想上传到fir,并且想拿最新的git commit 信息作为fir版本更新备注,那么你的工作流可以这么配<br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/1012.png?raw=true\" alt=\"\"></li>\n<li>‘自定义脚本’里面写的是export CHANGE_LOG=$(git log –pretty=format:”%s” -1 $describe) 然后 fir.im 上传插件 中 FIR_CHANGELOG就直接写$CHANGE_LOG这样子就可以做到拿最新的git commit 信息作为fir版本更新备注, $FIR_APP_PATH里面就直接写$FIR_APP_PATH就好了</li>\n<li>‘缓存’那里启用一下安装速度会快些</li>\n<li>如果你的git的根目录不是你项目的根目录的话,你要添加一个’环境变量’(就像上面的图),详情看这里</li>\n<li>‘编译’那里的’Workspace’,填的时候记得把’.xcworkspace’后缀带上</li>\n<li>‘编译’那里的’Workspace’和’Project’两个选一个填,不能一起填</li>\n<li>大概就这么多,以后我遇到啥再补充</li>\n</ol>"},{"title":"简易架构设计","author":"Arclin","abbrlink":"4948514e","date":"2016-10-28T16:00:00.000Z","_content":"### 继承关系：\n- UIViewController\n\n\t- DKViewContrller\n\n\t\t- DKLoginBaseViewCotroller\n\n\t\t\t- DKLoginViewController\n\t\t\t- DKRegisterViewController\n\t\t\t- DKFoundPswViewController\n\t\t- DKModuleABaseViewCotroller\n\t\t\t- DKAViewController\n\t\t- DKModuleBBaseViewCotroller\n\t\t\t- DKBViewController\n\n### 常量配置\n\n - DKLoginBaseViewController : DKLoginConfig.h\n\n - DKLoginConfig 里面定义常量\n\n\t相关的常量使用UIKIT_EXTERN / FOUNDATION_EXTERA，并且UIKIT_EXTERN / FOUNDATION_EXTERA建议写在模块外的全局DKConfig.h(会在pch里引入)\n - ps: pch建议只写宏，宏之外的其他东西，写在DKConfig.h里面，然后导入pch\n\n - DKModuelABaseViewController : DKModuelAConfig.h\n\n### 调用(import)\n\n```\nDKHomeViewController\n    |-DKLoginViewController\n        |-DKRegisterViewController\n        |-DKLoginBaseViewController\n            |—DKViewController\n                |_ UIKit\n```","source":"_posts/简易架构设计.md","raw":"---\ntitle: 简易架构设计\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 4948514e\ndate: 2016-10-29 00:00:00\n---\n### 继承关系：\n- UIViewController\n\n\t- DKViewContrller\n\n\t\t- DKLoginBaseViewCotroller\n\n\t\t\t- DKLoginViewController\n\t\t\t- DKRegisterViewController\n\t\t\t- DKFoundPswViewController\n\t\t- DKModuleABaseViewCotroller\n\t\t\t- DKAViewController\n\t\t- DKModuleBBaseViewCotroller\n\t\t\t- DKBViewController\n\n### 常量配置\n\n - DKLoginBaseViewController : DKLoginConfig.h\n\n - DKLoginConfig 里面定义常量\n\n\t相关的常量使用UIKIT_EXTERN / FOUNDATION_EXTERA，并且UIKIT_EXTERN / FOUNDATION_EXTERA建议写在模块外的全局DKConfig.h(会在pch里引入)\n - ps: pch建议只写宏，宏之外的其他东西，写在DKConfig.h里面，然后导入pch\n\n - DKModuelABaseViewController : DKModuelAConfig.h\n\n### 调用(import)\n\n```\nDKHomeViewController\n    |-DKLoginViewController\n        |-DKRegisterViewController\n        |-DKLoginBaseViewController\n            |—DKViewController\n                |_ UIKit\n```","slug":"简易架构设计","published":1,"updated":"2018-05-10T06:51:35.768Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcma004jldxudbfggmk1","content":"<h3 id=\"继承关系：\"><a href=\"#继承关系：\" class=\"headerlink\" title=\"继承关系：\"></a>继承关系：</h3><ul>\n<li><p>UIViewController</p>\n<ul>\n<li><p>DKViewContrller</p>\n<ul>\n<li><p>DKLoginBaseViewCotroller</p>\n<ul>\n<li>DKLoginViewController</li>\n<li>DKRegisterViewController</li>\n<li>DKFoundPswViewController</li>\n</ul>\n</li>\n<li>DKModuleABaseViewCotroller<ul>\n<li>DKAViewController</li>\n</ul>\n</li>\n<li>DKModuleBBaseViewCotroller<ul>\n<li>DKBViewController</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常量配置\"><a href=\"#常量配置\" class=\"headerlink\" title=\"常量配置\"></a>常量配置</h3><ul>\n<li><p>DKLoginBaseViewController : DKLoginConfig.h</p>\n</li>\n<li><p>DKLoginConfig 里面定义常量</p>\n<p> 相关的常量使用UIKIT_EXTERN / FOUNDATION_EXTERA，并且UIKIT_EXTERN / FOUNDATION_EXTERA建议写在模块外的全局DKConfig.h(会在pch里引入)</p>\n</li>\n<li><p>ps: pch建议只写宏，宏之外的其他东西，写在DKConfig.h里面，然后导入pch</p>\n</li>\n<li><p>DKModuelABaseViewController : DKModuelAConfig.h</p>\n</li>\n</ul>\n<h3 id=\"调用-import\"><a href=\"#调用-import\" class=\"headerlink\" title=\"调用(import)\"></a>调用(import)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHomeViewController</span><br><span class=\"line\">    |-DKLoginViewController</span><br><span class=\"line\">        |-DKRegisterViewController</span><br><span class=\"line\">        |-DKLoginBaseViewController</span><br><span class=\"line\">            |—DKViewController</span><br><span class=\"line\">                |_ UIKit</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"继承关系：\"><a href=\"#继承关系：\" class=\"headerlink\" title=\"继承关系：\"></a>继承关系：</h3><ul>\n<li><p>UIViewController</p>\n<ul>\n<li><p>DKViewContrller</p>\n<ul>\n<li><p>DKLoginBaseViewCotroller</p>\n<ul>\n<li>DKLoginViewController</li>\n<li>DKRegisterViewController</li>\n<li>DKFoundPswViewController</li>\n</ul>\n</li>\n<li>DKModuleABaseViewCotroller<ul>\n<li>DKAViewController</li>\n</ul>\n</li>\n<li>DKModuleBBaseViewCotroller<ul>\n<li>DKBViewController</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常量配置\"><a href=\"#常量配置\" class=\"headerlink\" title=\"常量配置\"></a>常量配置</h3><ul>\n<li><p>DKLoginBaseViewController : DKLoginConfig.h</p>\n</li>\n<li><p>DKLoginConfig 里面定义常量</p>\n<p> 相关的常量使用UIKIT_EXTERN / FOUNDATION_EXTERA，并且UIKIT_EXTERN / FOUNDATION_EXTERA建议写在模块外的全局DKConfig.h(会在pch里引入)</p>\n</li>\n<li><p>ps: pch建议只写宏，宏之外的其他东西，写在DKConfig.h里面，然后导入pch</p>\n</li>\n<li><p>DKModuelABaseViewController : DKModuelAConfig.h</p>\n</li>\n</ul>\n<h3 id=\"调用-import\"><a href=\"#调用-import\" class=\"headerlink\" title=\"调用(import)\"></a>调用(import)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHomeViewController</span><br><span class=\"line\">    |-DKLoginViewController</span><br><span class=\"line\">        |-DKRegisterViewController</span><br><span class=\"line\">        |-DKLoginBaseViewController</span><br><span class=\"line\">            |—DKViewController</span><br><span class=\"line\">                |_ UIKit</span><br></pre></td></tr></table></figure>"},{"title":"组合模式","author":"Arclin","abbrlink":"df879792","date":"2016-10-31T16:00:00.000Z","_content":"其实组合模式就是为了便于管理一个树形结构（抽象的）的对象，能让客户端统一处理这个对象的一种设计模式\n\n<!-- more -->\n\n举个例子\n\n```\n帽子\n  |_贝雷帽\n  |_鸭舌帽\n      |_黑色鸭舌\n衣服\n  |_衬衫\n      |_蓝色衬衫\n      |_白色衬衫\n  |_T恤\n裤子\n  |_牛仔裤\n      |_蓝色牛仔裤\n  |_短裤\n\n```\n\n那么这时候如果客户端要拿到一顶黑色鸭舌帽，一件白色衬衫和一条蓝色牛仔裤，那么应该怎么取到呢？或者想从对象中删除这些东西呢？\n\n首先我们需要有一个衣柜\n\n```\nWardrobe *wardrobe = [[Wardrobe alloc] init];\n```\n\n然后为其我们添加子节点\n\n```\n[wardrobe addDress:hat];\n[wardrobe addDress:clothes];\n[wardrobe addDress:trousers];\n```\n\n那 `hat` 和 `clothes` 和 `trousers` 怎么来 (以 hat 举例)\n\n```\nHat *hat = [[Hat alloc] init];\nHat *yashe_hat = [[Hat alloc] initWithType:@\"Yashe\"];\nHat *beilei_hat = [[Hat alloc] initWithType:@\"Beilei\"];\nHat *black_hat = [[Hat alloc] initWithColor:@\"Black Yashe\"];\n\n[hat addDress:beilei_hat];\n\n[yashe_hat addDress:black_hat];\n[hat addDress:yashe_hat];\n```\n\n现在我们需要注意一下\n· 上面的三个对象，必须遵守一个协议，我们姑且命名为 DressProtocol (服饰）\n\n```\n@protocol DressProtocol\n\n- (void)addDress:(id<DressProtocol>)dress;\n- (void)removeDress:(id<DressProtocol>)dress;\n\n- (void)showDresses;\n@end\n\n```\n\n上面经过一轮 AddDress:之后，帽子那块应该就会生成这样子的结构\n\n```\n衣橱\n|_帽子\n  |_贝雷帽\n  |_鸭舌帽\n    |_黑色鸭舌帽\n```\n然后我们来看看里面代理方法的实现\n\n```\n- (void)addDress:(id<DressProtocol>)dress\n{\n\t// 有一个数组成员属性用来储存这些对象\n\t[_child addObject:dress];\n}\n- (void)removeDress:(id<DressProtocol>)dress\n{\n\t[_child removeObject:dress];\n}\n- (void)showDresses\n{\n\tNSLog(@\"%@\",_child);\n}\n```\n\n顺便看看 Init的时候我们使用的两个方法\n\n```\n- (instancetype)initWithType:(NSString *)type\n{\n\tif(self = [super init]){\n\t\tself.type = type;\n\t\tself.color = nil;\n\t}\n\treturn self;\n}\n\n- (instancetype)initWithColor:(NSString *)color\n{\n\tif(self = [super init]){\n\t\tself.type = nil;\n\t\tself.color = color;\n\t}\n\treturn self;\n}\n\n```\n\n大概就是这种感觉\n\n如果不是很清楚的话，可以想想 `UIView`的 `addSubView:`\n`addSubView:`就是把一个新的 View加入到子节点，如果 subView 还有 subView，那就在 subView 上面继续添加 `addSubView:` 最后我们打印 subViews的时候就可以得到该View的所有的subview\n\n","source":"_posts/组合模式.md","raw":"---\ntitle: 组合模式\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: df879792\ndate: 2016-11-01 00:00:00\n---\n其实组合模式就是为了便于管理一个树形结构（抽象的）的对象，能让客户端统一处理这个对象的一种设计模式\n\n<!-- more -->\n\n举个例子\n\n```\n帽子\n  |_贝雷帽\n  |_鸭舌帽\n      |_黑色鸭舌\n衣服\n  |_衬衫\n      |_蓝色衬衫\n      |_白色衬衫\n  |_T恤\n裤子\n  |_牛仔裤\n      |_蓝色牛仔裤\n  |_短裤\n\n```\n\n那么这时候如果客户端要拿到一顶黑色鸭舌帽，一件白色衬衫和一条蓝色牛仔裤，那么应该怎么取到呢？或者想从对象中删除这些东西呢？\n\n首先我们需要有一个衣柜\n\n```\nWardrobe *wardrobe = [[Wardrobe alloc] init];\n```\n\n然后为其我们添加子节点\n\n```\n[wardrobe addDress:hat];\n[wardrobe addDress:clothes];\n[wardrobe addDress:trousers];\n```\n\n那 `hat` 和 `clothes` 和 `trousers` 怎么来 (以 hat 举例)\n\n```\nHat *hat = [[Hat alloc] init];\nHat *yashe_hat = [[Hat alloc] initWithType:@\"Yashe\"];\nHat *beilei_hat = [[Hat alloc] initWithType:@\"Beilei\"];\nHat *black_hat = [[Hat alloc] initWithColor:@\"Black Yashe\"];\n\n[hat addDress:beilei_hat];\n\n[yashe_hat addDress:black_hat];\n[hat addDress:yashe_hat];\n```\n\n现在我们需要注意一下\n· 上面的三个对象，必须遵守一个协议，我们姑且命名为 DressProtocol (服饰）\n\n```\n@protocol DressProtocol\n\n- (void)addDress:(id<DressProtocol>)dress;\n- (void)removeDress:(id<DressProtocol>)dress;\n\n- (void)showDresses;\n@end\n\n```\n\n上面经过一轮 AddDress:之后，帽子那块应该就会生成这样子的结构\n\n```\n衣橱\n|_帽子\n  |_贝雷帽\n  |_鸭舌帽\n    |_黑色鸭舌帽\n```\n然后我们来看看里面代理方法的实现\n\n```\n- (void)addDress:(id<DressProtocol>)dress\n{\n\t// 有一个数组成员属性用来储存这些对象\n\t[_child addObject:dress];\n}\n- (void)removeDress:(id<DressProtocol>)dress\n{\n\t[_child removeObject:dress];\n}\n- (void)showDresses\n{\n\tNSLog(@\"%@\",_child);\n}\n```\n\n顺便看看 Init的时候我们使用的两个方法\n\n```\n- (instancetype)initWithType:(NSString *)type\n{\n\tif(self = [super init]){\n\t\tself.type = type;\n\t\tself.color = nil;\n\t}\n\treturn self;\n}\n\n- (instancetype)initWithColor:(NSString *)color\n{\n\tif(self = [super init]){\n\t\tself.type = nil;\n\t\tself.color = color;\n\t}\n\treturn self;\n}\n\n```\n\n大概就是这种感觉\n\n如果不是很清楚的话，可以想想 `UIView`的 `addSubView:`\n`addSubView:`就是把一个新的 View加入到子节点，如果 subView 还有 subView，那就在 subView 上面继续添加 `addSubView:` 最后我们打印 subViews的时候就可以得到该View的所有的subview\n\n","slug":"组合模式","published":1,"updated":"2018-05-10T06:51:35.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcmf004nldxum8cvulqj","content":"<p>其实组合模式就是为了便于管理一个树形结构（抽象的）的对象，能让客户端统一处理这个对象的一种设计模式</p>\n<a id=\"more\"></a>\n<p>举个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">帽子</span><br><span class=\"line\">  |_贝雷帽</span><br><span class=\"line\">  |_鸭舌帽</span><br><span class=\"line\">      |_黑色鸭舌</span><br><span class=\"line\">衣服</span><br><span class=\"line\">  |_衬衫</span><br><span class=\"line\">      |_蓝色衬衫</span><br><span class=\"line\">      |_白色衬衫</span><br><span class=\"line\">  |_T恤</span><br><span class=\"line\">裤子</span><br><span class=\"line\">  |_牛仔裤</span><br><span class=\"line\">      |_蓝色牛仔裤</span><br><span class=\"line\">  |_短裤</span><br></pre></td></tr></table></figure>\n<p>那么这时候如果客户端要拿到一顶黑色鸭舌帽，一件白色衬衫和一条蓝色牛仔裤，那么应该怎么取到呢？或者想从对象中删除这些东西呢？</p>\n<p>首先我们需要有一个衣柜</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Wardrobe *wardrobe = [[Wardrobe alloc] init];</span><br></pre></td></tr></table></figure>\n<p>然后为其我们添加子节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[wardrobe addDress:hat];</span><br><span class=\"line\">[wardrobe addDress:clothes];</span><br><span class=\"line\">[wardrobe addDress:trousers];</span><br></pre></td></tr></table></figure>\n<p>那 <code>hat</code> 和 <code>clothes</code> 和 <code>trousers</code> 怎么来 (以 hat 举例)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hat *hat = [[Hat alloc] init];</span><br><span class=\"line\">Hat *yashe_hat = [[Hat alloc] initWithType:@&quot;Yashe&quot;];</span><br><span class=\"line\">Hat *beilei_hat = [[Hat alloc] initWithType:@&quot;Beilei&quot;];</span><br><span class=\"line\">Hat *black_hat = [[Hat alloc] initWithColor:@&quot;Black Yashe&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">[hat addDress:beilei_hat];</span><br><span class=\"line\"></span><br><span class=\"line\">[yashe_hat addDress:black_hat];</span><br><span class=\"line\">[hat addDress:yashe_hat];</span><br></pre></td></tr></table></figure>\n<p>现在我们需要注意一下<br>· 上面的三个对象，必须遵守一个协议，我们姑且命名为 DressProtocol (服饰）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@protocol DressProtocol</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)addDress:(id&lt;DressProtocol&gt;)dress;</span><br><span class=\"line\">- (void)removeDress:(id&lt;DressProtocol&gt;)dress;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)showDresses;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>上面经过一轮 AddDress:之后，帽子那块应该就会生成这样子的结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">衣橱</span><br><span class=\"line\">|_帽子</span><br><span class=\"line\">  |_贝雷帽</span><br><span class=\"line\">  |_鸭舌帽</span><br><span class=\"line\">    |_黑色鸭舌帽</span><br></pre></td></tr></table></figure>\n<p>然后我们来看看里面代理方法的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addDress:(id&lt;DressProtocol&gt;)dress</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 有一个数组成员属性用来储存这些对象</span><br><span class=\"line\">\t[_child addObject:dress];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)removeDress:(id&lt;DressProtocol&gt;)dress</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[_child removeObject:dress];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)showDresses</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNSLog(@&quot;%@&quot;,_child);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>顺便看看 Init的时候我们使用的两个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithType:(NSString *)type</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(self = [super init])&#123;</span><br><span class=\"line\">\t\tself.type = type;</span><br><span class=\"line\">\t\tself.color = nil;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithColor:(NSString *)color</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(self = [super init])&#123;</span><br><span class=\"line\">\t\tself.type = nil;</span><br><span class=\"line\">\t\tself.color = color;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大概就是这种感觉</p>\n<p>如果不是很清楚的话，可以想想 <code>UIView</code>的 <code>addSubView:</code><br><code>addSubView:</code>就是把一个新的 View加入到子节点，如果 subView 还有 subView，那就在 subView 上面继续添加 <code>addSubView:</code> 最后我们打印 subViews的时候就可以得到该View的所有的subview</p>\n","site":{"data":{}},"excerpt":"<p>其实组合模式就是为了便于管理一个树形结构（抽象的）的对象，能让客户端统一处理这个对象的一种设计模式</p>","more":"<p>举个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">帽子</span><br><span class=\"line\">  |_贝雷帽</span><br><span class=\"line\">  |_鸭舌帽</span><br><span class=\"line\">      |_黑色鸭舌</span><br><span class=\"line\">衣服</span><br><span class=\"line\">  |_衬衫</span><br><span class=\"line\">      |_蓝色衬衫</span><br><span class=\"line\">      |_白色衬衫</span><br><span class=\"line\">  |_T恤</span><br><span class=\"line\">裤子</span><br><span class=\"line\">  |_牛仔裤</span><br><span class=\"line\">      |_蓝色牛仔裤</span><br><span class=\"line\">  |_短裤</span><br></pre></td></tr></table></figure>\n<p>那么这时候如果客户端要拿到一顶黑色鸭舌帽，一件白色衬衫和一条蓝色牛仔裤，那么应该怎么取到呢？或者想从对象中删除这些东西呢？</p>\n<p>首先我们需要有一个衣柜</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Wardrobe *wardrobe = [[Wardrobe alloc] init];</span><br></pre></td></tr></table></figure>\n<p>然后为其我们添加子节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[wardrobe addDress:hat];</span><br><span class=\"line\">[wardrobe addDress:clothes];</span><br><span class=\"line\">[wardrobe addDress:trousers];</span><br></pre></td></tr></table></figure>\n<p>那 <code>hat</code> 和 <code>clothes</code> 和 <code>trousers</code> 怎么来 (以 hat 举例)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hat *hat = [[Hat alloc] init];</span><br><span class=\"line\">Hat *yashe_hat = [[Hat alloc] initWithType:@&quot;Yashe&quot;];</span><br><span class=\"line\">Hat *beilei_hat = [[Hat alloc] initWithType:@&quot;Beilei&quot;];</span><br><span class=\"line\">Hat *black_hat = [[Hat alloc] initWithColor:@&quot;Black Yashe&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">[hat addDress:beilei_hat];</span><br><span class=\"line\"></span><br><span class=\"line\">[yashe_hat addDress:black_hat];</span><br><span class=\"line\">[hat addDress:yashe_hat];</span><br></pre></td></tr></table></figure>\n<p>现在我们需要注意一下<br>· 上面的三个对象，必须遵守一个协议，我们姑且命名为 DressProtocol (服饰）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@protocol DressProtocol</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)addDress:(id&lt;DressProtocol&gt;)dress;</span><br><span class=\"line\">- (void)removeDress:(id&lt;DressProtocol&gt;)dress;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)showDresses;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>上面经过一轮 AddDress:之后，帽子那块应该就会生成这样子的结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">衣橱</span><br><span class=\"line\">|_帽子</span><br><span class=\"line\">  |_贝雷帽</span><br><span class=\"line\">  |_鸭舌帽</span><br><span class=\"line\">    |_黑色鸭舌帽</span><br></pre></td></tr></table></figure>\n<p>然后我们来看看里面代理方法的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addDress:(id&lt;DressProtocol&gt;)dress</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 有一个数组成员属性用来储存这些对象</span><br><span class=\"line\">\t[_child addObject:dress];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)removeDress:(id&lt;DressProtocol&gt;)dress</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[_child removeObject:dress];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)showDresses</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNSLog(@&quot;%@&quot;,_child);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>顺便看看 Init的时候我们使用的两个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithType:(NSString *)type</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(self = [super init])&#123;</span><br><span class=\"line\">\t\tself.type = type;</span><br><span class=\"line\">\t\tself.color = nil;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithColor:(NSString *)color</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(self = [super init])&#123;</span><br><span class=\"line\">\t\tself.type = nil;</span><br><span class=\"line\">\t\tself.color = color;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大概就是这种感觉</p>\n<p>如果不是很清楚的话，可以想想 <code>UIView</code>的 <code>addSubView:</code><br><code>addSubView:</code>就是把一个新的 View加入到子节点，如果 subView 还有 subView，那就在 subView 上面继续添加 <code>addSubView:</code> 最后我们打印 subViews的时候就可以得到该View的所有的subview</p>"},{"title":"基于DKHTTPTool的业务层设计_尝试版","author":"Arclin","abbrlink":"838ddddd","date":"2016-11-29T16:00:00.000Z","_content":"基于DKHTTPTool的业务层设计_尝试版\n\n由于是尝试版,所以这里只是简单讲下思路.\n\n<!-- more -->\n\n- 首先 DKHTTPTool提供了缓存策略的选择,让方法调用和缓存可以进行统一的处理\n然后业务层进行缓存策略的选择, 但由于 ViewModel实际需要的是一个模型(数组) ,而 `DKHTTPTool`返回的是一个 `DKResponse` 对象,所以业务层除了进行缓存策略的选择外,还需要进行对 `DKResponse`的处理.\n\n- DKResponse 里面有一个成员属性result用来储存后台返回的 json 数据,所以业务层(以下称 Service)需要去对这个属性值进行封装 , 封装的方法我们选择使用 MJExtension 的方法就可以了\n\n- 对于一些数据量比较大,数据结构比较复杂的模型, `MJExtension` 处理之后应该还需要存入数据库,便于日后的筛选,排序等操作.那么,此时逻辑就出现了变化\n\n\t- 对于简单的数据,处理流程是 VM调用Service方法 -> Service 调用 HTTP方法 -> 返回原始数据 -> `MJExtension`处理数据 -> 返回给 VM\n\t- 对于复杂的数据,处理流程是 VM调用Service方法 -> Service 调用 HTTP方法 -> 返回原始数据 -> `MJExtension`处理数据 -> 插入 or 更新 数据库表 - -> 同时返回处理好的数据给 VM\n- 当然第一种是最好处理的,只要套一层方法就可以把数组返回回去了(如果要进行比较简单的数据筛选操作,用 `NSPredicate`,排序用`NSSortDescriptor`也是可以实现的),但是对于第二种方法,那就需要我们新增一个 Service基类去统一处理取数据库数据的操作,包括条件筛选,排序 ,去重的等等的操作","source":"_posts/基于DKHTTPTool的业务层设计-尝试版.md","raw":"---\ntitle: 基于DKHTTPTool的业务层设计_尝试版\nauthor: Arclin\ntags:\n  - iOS\n  - 杂谈\ncategories:\n  - iOS\nabbrlink: 838ddddd\ndate: 2016-11-30 00:00:00\n---\n基于DKHTTPTool的业务层设计_尝试版\n\n由于是尝试版,所以这里只是简单讲下思路.\n\n<!-- more -->\n\n- 首先 DKHTTPTool提供了缓存策略的选择,让方法调用和缓存可以进行统一的处理\n然后业务层进行缓存策略的选择, 但由于 ViewModel实际需要的是一个模型(数组) ,而 `DKHTTPTool`返回的是一个 `DKResponse` 对象,所以业务层除了进行缓存策略的选择外,还需要进行对 `DKResponse`的处理.\n\n- DKResponse 里面有一个成员属性result用来储存后台返回的 json 数据,所以业务层(以下称 Service)需要去对这个属性值进行封装 , 封装的方法我们选择使用 MJExtension 的方法就可以了\n\n- 对于一些数据量比较大,数据结构比较复杂的模型, `MJExtension` 处理之后应该还需要存入数据库,便于日后的筛选,排序等操作.那么,此时逻辑就出现了变化\n\n\t- 对于简单的数据,处理流程是 VM调用Service方法 -> Service 调用 HTTP方法 -> 返回原始数据 -> `MJExtension`处理数据 -> 返回给 VM\n\t- 对于复杂的数据,处理流程是 VM调用Service方法 -> Service 调用 HTTP方法 -> 返回原始数据 -> `MJExtension`处理数据 -> 插入 or 更新 数据库表 - -> 同时返回处理好的数据给 VM\n- 当然第一种是最好处理的,只要套一层方法就可以把数组返回回去了(如果要进行比较简单的数据筛选操作,用 `NSPredicate`,排序用`NSSortDescriptor`也是可以实现的),但是对于第二种方法,那就需要我们新增一个 Service基类去统一处理取数据库数据的操作,包括条件筛选,排序 ,去重的等等的操作","slug":"基于DKHTTPTool的业务层设计-尝试版","published":1,"updated":"2018-05-10T06:51:35.765Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcml004qldxuqji7ti3w","content":"<p>基于DKHTTPTool的业务层设计_尝试版</p>\n<p>由于是尝试版,所以这里只是简单讲下思路.</p>\n<a id=\"more\"></a>\n<ul>\n<li><p>首先 DKHTTPTool提供了缓存策略的选择,让方法调用和缓存可以进行统一的处理<br>然后业务层进行缓存策略的选择, 但由于 ViewModel实际需要的是一个模型(数组) ,而 <code>DKHTTPTool</code>返回的是一个 <code>DKResponse</code> 对象,所以业务层除了进行缓存策略的选择外,还需要进行对 <code>DKResponse</code>的处理.</p>\n</li>\n<li><p>DKResponse 里面有一个成员属性result用来储存后台返回的 json 数据,所以业务层(以下称 Service)需要去对这个属性值进行封装 , 封装的方法我们选择使用 MJExtension 的方法就可以了</p>\n</li>\n<li><p>对于一些数据量比较大,数据结构比较复杂的模型, <code>MJExtension</code> 处理之后应该还需要存入数据库,便于日后的筛选,排序等操作.那么,此时逻辑就出现了变化</p>\n<ul>\n<li>对于简单的数据,处理流程是 VM调用Service方法 -&gt; Service 调用 HTTP方法 -&gt; 返回原始数据 -&gt; <code>MJExtension</code>处理数据 -&gt; 返回给 VM</li>\n<li>对于复杂的数据,处理流程是 VM调用Service方法 -&gt; Service 调用 HTTP方法 -&gt; 返回原始数据 -&gt; <code>MJExtension</code>处理数据 -&gt; 插入 or 更新 数据库表 - -&gt; 同时返回处理好的数据给 VM</li>\n</ul>\n</li>\n<li>当然第一种是最好处理的,只要套一层方法就可以把数组返回回去了(如果要进行比较简单的数据筛选操作,用 <code>NSPredicate</code>,排序用<code>NSSortDescriptor</code>也是可以实现的),但是对于第二种方法,那就需要我们新增一个 Service基类去统一处理取数据库数据的操作,包括条件筛选,排序 ,去重的等等的操作</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>基于DKHTTPTool的业务层设计_尝试版</p>\n<p>由于是尝试版,所以这里只是简单讲下思路.</p>","more":"<ul>\n<li><p>首先 DKHTTPTool提供了缓存策略的选择,让方法调用和缓存可以进行统一的处理<br>然后业务层进行缓存策略的选择, 但由于 ViewModel实际需要的是一个模型(数组) ,而 <code>DKHTTPTool</code>返回的是一个 <code>DKResponse</code> 对象,所以业务层除了进行缓存策略的选择外,还需要进行对 <code>DKResponse</code>的处理.</p>\n</li>\n<li><p>DKResponse 里面有一个成员属性result用来储存后台返回的 json 数据,所以业务层(以下称 Service)需要去对这个属性值进行封装 , 封装的方法我们选择使用 MJExtension 的方法就可以了</p>\n</li>\n<li><p>对于一些数据量比较大,数据结构比较复杂的模型, <code>MJExtension</code> 处理之后应该还需要存入数据库,便于日后的筛选,排序等操作.那么,此时逻辑就出现了变化</p>\n<ul>\n<li>对于简单的数据,处理流程是 VM调用Service方法 -&gt; Service 调用 HTTP方法 -&gt; 返回原始数据 -&gt; <code>MJExtension</code>处理数据 -&gt; 返回给 VM</li>\n<li>对于复杂的数据,处理流程是 VM调用Service方法 -&gt; Service 调用 HTTP方法 -&gt; 返回原始数据 -&gt; <code>MJExtension</code>处理数据 -&gt; 插入 or 更新 数据库表 - -&gt; 同时返回处理好的数据给 VM</li>\n</ul>\n</li>\n<li>当然第一种是最好处理的,只要套一层方法就可以把数组返回回去了(如果要进行比较简单的数据筛选操作,用 <code>NSPredicate</code>,排序用<code>NSSortDescriptor</code>也是可以实现的),但是对于第二种方法,那就需要我们新增一个 Service基类去统一处理取数据库数据的操作,包括条件筛选,排序 ,去重的等等的操作</li>\n</ul>"},{"title":"安装shadowsocks服务端","author":"Arclin","abbrlink":"eb81866c","date":"2018-02-18T14:15:00.000Z","_content":"安装shadowsocks服务端\n\n<!-- more -->\n\n```\nsudo yum install python-pip\nsudo pip install shadowsocks\n```\n\n配置文件\n\n```\n{\n \"server”:”172.93.xx.xx”, # 服务器IP \n \"server_port\":8388, # 端口号\n \"local_address\": \"127.0.0.1\",\n \"local_port”:1080,\n \"password\":\"gtPtAb)Wsss\", # 密码\n \"timeout\":300,\n \"method\":\"aes-256-cfb\",# 加密类型\n \"fast_open\": false\n}\n```","source":"_posts/安装shadowsocks服务端.md","raw":"---\ntitle: 安装shadowsocks服务端\nauthor: Arclin\ntags:\n  - Shadowsocks\ncategories:\n  - Linux\nabbrlink: eb81866c\ndate: 2018-02-18 22:15:00\n---\n安装shadowsocks服务端\n\n<!-- more -->\n\n```\nsudo yum install python-pip\nsudo pip install shadowsocks\n```\n\n配置文件\n\n```\n{\n \"server”:”172.93.xx.xx”, # 服务器IP \n \"server_port\":8388, # 端口号\n \"local_address\": \"127.0.0.1\",\n \"local_port”:1080,\n \"password\":\"gtPtAb)Wsss\", # 密码\n \"timeout\":300,\n \"method\":\"aes-256-cfb\",# 加密类型\n \"fast_open\": false\n}\n```","slug":"安装shadowsocks服务端","published":1,"updated":"2018-05-10T06:51:35.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcmp004tldxuv4eeld2d","content":"<p>安装shadowsocks服务端</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install python-pip</span><br><span class=\"line\">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure>\n<p>配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> &quot;server”:”172.93.xx.xx”, # 服务器IP </span><br><span class=\"line\"> &quot;server_port&quot;:8388, # 端口号</span><br><span class=\"line\"> &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\"> &quot;local_port”:1080,</span><br><span class=\"line\"> &quot;password&quot;:&quot;gtPtAb)Wsss&quot;, # 密码</span><br><span class=\"line\"> &quot;timeout&quot;:300,</span><br><span class=\"line\"> &quot;method&quot;:&quot;aes-256-cfb&quot;,# 加密类型</span><br><span class=\"line\"> &quot;fast_open&quot;: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>安装shadowsocks服务端</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install python-pip</span><br><span class=\"line\">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure>\n<p>配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> &quot;server”:”172.93.xx.xx”, # 服务器IP </span><br><span class=\"line\"> &quot;server_port&quot;:8388, # 端口号</span><br><span class=\"line\"> &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\"> &quot;local_port”:1080,</span><br><span class=\"line\"> &quot;password&quot;:&quot;gtPtAb)Wsss&quot;, # 密码</span><br><span class=\"line\"> &quot;timeout&quot;:300,</span><br><span class=\"line\"> &quot;method&quot;:&quot;aes-256-cfb&quot;,# 加密类型</span><br><span class=\"line\"> &quot;fast_open&quot;: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"给 APP添加外部文件导入功能","author":"Arclin","abbrlink":"d2301e87","date":"2016-10-29T16:00:00.000Z","_content":"给 APP添加外部文件导入功能\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/333.jpeg)\n\n<!-- more -->\n\n修改 info.plist(这里是允许所有文件类型,如果要特定某种类型的文件,那么就得添加多个CFBundleTypeName CFBundleTypeRole LSHandlerRank LSItemContentTypes 具体见百度)\n\n```\n<key>CFBundleDocumentTypes</key>\n   <array>\n       <dict>\n           <key>CFBundleTypeIconFiles</key>\n           <array/>\n           <key>CFBundleTypeName</key>\n           <string>data</string>\n           <key>CFBundleTypeRole</key>\n           <string>Viewer</string>\n           <key>LSHandlerRank</key>\n           <string>Default</string>\n           <key>LSItemContentTypes</key>\n           <array>\n               <string>public.data</string>\n           </array>\n       </dict>\n   </array>\n ```\n \nAPPDelegate.h\n\n获取到根控制器,执行复制到Document文件夹方法\n源路径:url.path\n\n```\n@property (strong, nonatomic) NSURL *sharedURL;\n\n- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary<NSString *,id> *)options\n{\n\tif(url.fileURL){\n        self.sharedURL = url;\n        UIViewController *vc = self.window.rootViewController;\n        if ([vc isKindOfClass:[UINavigationController class]]) {\n            UINavigationController * nav = (UINavigationController *)self.window.rootViewController;\n            UIViewController *topVC = nav.childViewControllers.firstObject;\n            if ([topVC respondsToSelector:@selector(handleSharedFile)]) {\n                [topVC performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];\n            }\n        } else {\n            if ([vc respondsToSelector:@selector(handleSharedFile)]) {\n                [vc performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];\n            }\n        }\n    }\n}\n```\n\n根控制器方法(头文件需要声明方法)\n\n```\n- (void)handleSharedFile {\n    AppDelegate *app = (AppDelegate *)[UIApplication sharedApplication].delegate;\n    if (app.sharedURL != nil) {\n        self.sharedURL = [app.sharedURL copy];\n        app.sharedURL = nil;\n        [self saveSharedFile:self.sharedURL];\n    }\n}\n- (void)saveSharedFile:(NSURL *)url {\n    MBProgressHUD *hud = [MBProgressHUD showButtonHUDAddedTo:self.view animated:YES];\n    DKFile *file = [[DKFile alloc] init];\n    file.fullPath = url.path;\n    file.fileName = url.path.lastPathComponent;\n    [[DKFileManager sharedInstance] copyItemsOfSelectFiles:@[file] fromStorage:DKFileStorageTypeInternal toStorage:DKFileStorageTypeInternal toPath:[DKFileManager defaultPath:kShareDirectory storage:DKFileStorageTypeInternal] progressHUD:hud complete:^{\n        [SVProgressHUD showSuccessWithStatus:@\"已保存到 iPhone -> SharedFiles\"];\n    } failure:^(NSError *errors) {\n        \n    }];\n}\n```","source":"_posts/给-APP添加外部文件导入功能.md","raw":"---\ntitle: 给 APP添加外部文件导入功能\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: d2301e87\ndate: 2016-10-30 00:00:00\n---\n给 APP添加外部文件导入功能\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/333.jpeg)\n\n<!-- more -->\n\n修改 info.plist(这里是允许所有文件类型,如果要特定某种类型的文件,那么就得添加多个CFBundleTypeName CFBundleTypeRole LSHandlerRank LSItemContentTypes 具体见百度)\n\n```\n<key>CFBundleDocumentTypes</key>\n   <array>\n       <dict>\n           <key>CFBundleTypeIconFiles</key>\n           <array/>\n           <key>CFBundleTypeName</key>\n           <string>data</string>\n           <key>CFBundleTypeRole</key>\n           <string>Viewer</string>\n           <key>LSHandlerRank</key>\n           <string>Default</string>\n           <key>LSItemContentTypes</key>\n           <array>\n               <string>public.data</string>\n           </array>\n       </dict>\n   </array>\n ```\n \nAPPDelegate.h\n\n获取到根控制器,执行复制到Document文件夹方法\n源路径:url.path\n\n```\n@property (strong, nonatomic) NSURL *sharedURL;\n\n- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary<NSString *,id> *)options\n{\n\tif(url.fileURL){\n        self.sharedURL = url;\n        UIViewController *vc = self.window.rootViewController;\n        if ([vc isKindOfClass:[UINavigationController class]]) {\n            UINavigationController * nav = (UINavigationController *)self.window.rootViewController;\n            UIViewController *topVC = nav.childViewControllers.firstObject;\n            if ([topVC respondsToSelector:@selector(handleSharedFile)]) {\n                [topVC performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];\n            }\n        } else {\n            if ([vc respondsToSelector:@selector(handleSharedFile)]) {\n                [vc performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];\n            }\n        }\n    }\n}\n```\n\n根控制器方法(头文件需要声明方法)\n\n```\n- (void)handleSharedFile {\n    AppDelegate *app = (AppDelegate *)[UIApplication sharedApplication].delegate;\n    if (app.sharedURL != nil) {\n        self.sharedURL = [app.sharedURL copy];\n        app.sharedURL = nil;\n        [self saveSharedFile:self.sharedURL];\n    }\n}\n- (void)saveSharedFile:(NSURL *)url {\n    MBProgressHUD *hud = [MBProgressHUD showButtonHUDAddedTo:self.view animated:YES];\n    DKFile *file = [[DKFile alloc] init];\n    file.fullPath = url.path;\n    file.fileName = url.path.lastPathComponent;\n    [[DKFileManager sharedInstance] copyItemsOfSelectFiles:@[file] fromStorage:DKFileStorageTypeInternal toStorage:DKFileStorageTypeInternal toPath:[DKFileManager defaultPath:kShareDirectory storage:DKFileStorageTypeInternal] progressHUD:hud complete:^{\n        [SVProgressHUD showSuccessWithStatus:@\"已保存到 iPhone -> SharedFiles\"];\n    } failure:^(NSError *errors) {\n        \n    }];\n}\n```","slug":"给-APP添加外部文件导入功能","published":1,"updated":"2018-05-10T06:51:35.770Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcms004xldxufv82dlfg","content":"<p>给 APP添加外部文件导入功能</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/333.jpeg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>修改 info.plist(这里是允许所有文件类型,如果要特定某种类型的文件,那么就得添加多个CFBundleTypeName CFBundleTypeRole LSHandlerRank LSItemContentTypes 具体见百度)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;CFBundleDocumentTypes&lt;/key&gt;</span><br><span class=\"line\">   &lt;array&gt;</span><br><span class=\"line\">       &lt;dict&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeIconFiles&lt;/key&gt;</span><br><span class=\"line\">           &lt;array/&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeName&lt;/key&gt;</span><br><span class=\"line\">           &lt;string&gt;data&lt;/string&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeRole&lt;/key&gt;</span><br><span class=\"line\">           &lt;string&gt;Viewer&lt;/string&gt;</span><br><span class=\"line\">           &lt;key&gt;LSHandlerRank&lt;/key&gt;</span><br><span class=\"line\">           &lt;string&gt;Default&lt;/string&gt;</span><br><span class=\"line\">           &lt;key&gt;LSItemContentTypes&lt;/key&gt;</span><br><span class=\"line\">           &lt;array&gt;</span><br><span class=\"line\">               &lt;string&gt;public.data&lt;/string&gt;</span><br><span class=\"line\">           &lt;/array&gt;</span><br><span class=\"line\">       &lt;/dict&gt;</span><br><span class=\"line\">   &lt;/array&gt;</span><br></pre></td></tr></table></figure>\n<p>APPDelegate.h</p>\n<p>获取到根控制器,执行复制到Document文件夹方法<br>源路径:url.path</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property (strong, nonatomic) NSURL *sharedURL;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(url.fileURL)&#123;</span><br><span class=\"line\">        self.sharedURL = url;</span><br><span class=\"line\">        UIViewController *vc = self.window.rootViewController;</span><br><span class=\"line\">        if ([vc isKindOfClass:[UINavigationController class]]) &#123;</span><br><span class=\"line\">            UINavigationController * nav = (UINavigationController *)self.window.rootViewController;</span><br><span class=\"line\">            UIViewController *topVC = nav.childViewControllers.firstObject;</span><br><span class=\"line\">            if ([topVC respondsToSelector:@selector(handleSharedFile)]) &#123;</span><br><span class=\"line\">                [topVC performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if ([vc respondsToSelector:@selector(handleSharedFile)]) &#123;</span><br><span class=\"line\">                [vc performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根控制器方法(头文件需要声明方法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)handleSharedFile &#123;</span><br><span class=\"line\">    AppDelegate *app = (AppDelegate *)[UIApplication sharedApplication].delegate;</span><br><span class=\"line\">    if (app.sharedURL != nil) &#123;</span><br><span class=\"line\">        self.sharedURL = [app.sharedURL copy];</span><br><span class=\"line\">        app.sharedURL = nil;</span><br><span class=\"line\">        [self saveSharedFile:self.sharedURL];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)saveSharedFile:(NSURL *)url &#123;</span><br><span class=\"line\">    MBProgressHUD *hud = [MBProgressHUD showButtonHUDAddedTo:self.view animated:YES];</span><br><span class=\"line\">    DKFile *file = [[DKFile alloc] init];</span><br><span class=\"line\">    file.fullPath = url.path;</span><br><span class=\"line\">    file.fileName = url.path.lastPathComponent;</span><br><span class=\"line\">    [[DKFileManager sharedInstance] copyItemsOfSelectFiles:@[file] fromStorage:DKFileStorageTypeInternal toStorage:DKFileStorageTypeInternal toPath:[DKFileManager defaultPath:kShareDirectory storage:DKFileStorageTypeInternal] progressHUD:hud complete:^&#123;</span><br><span class=\"line\">        [SVProgressHUD showSuccessWithStatus:@&quot;已保存到 iPhone -&gt; SharedFiles&quot;];</span><br><span class=\"line\">    &#125; failure:^(NSError *errors) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>给 APP添加外部文件导入功能</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/333.jpeg\" alt=\"\"></p>","more":"<p>修改 info.plist(这里是允许所有文件类型,如果要特定某种类型的文件,那么就得添加多个CFBundleTypeName CFBundleTypeRole LSHandlerRank LSItemContentTypes 具体见百度)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;CFBundleDocumentTypes&lt;/key&gt;</span><br><span class=\"line\">   &lt;array&gt;</span><br><span class=\"line\">       &lt;dict&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeIconFiles&lt;/key&gt;</span><br><span class=\"line\">           &lt;array/&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeName&lt;/key&gt;</span><br><span class=\"line\">           &lt;string&gt;data&lt;/string&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeRole&lt;/key&gt;</span><br><span class=\"line\">           &lt;string&gt;Viewer&lt;/string&gt;</span><br><span class=\"line\">           &lt;key&gt;LSHandlerRank&lt;/key&gt;</span><br><span class=\"line\">           &lt;string&gt;Default&lt;/string&gt;</span><br><span class=\"line\">           &lt;key&gt;LSItemContentTypes&lt;/key&gt;</span><br><span class=\"line\">           &lt;array&gt;</span><br><span class=\"line\">               &lt;string&gt;public.data&lt;/string&gt;</span><br><span class=\"line\">           &lt;/array&gt;</span><br><span class=\"line\">       &lt;/dict&gt;</span><br><span class=\"line\">   &lt;/array&gt;</span><br></pre></td></tr></table></figure>\n<p>APPDelegate.h</p>\n<p>获取到根控制器,执行复制到Document文件夹方法<br>源路径:url.path</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property (strong, nonatomic) NSURL *sharedURL;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(url.fileURL)&#123;</span><br><span class=\"line\">        self.sharedURL = url;</span><br><span class=\"line\">        UIViewController *vc = self.window.rootViewController;</span><br><span class=\"line\">        if ([vc isKindOfClass:[UINavigationController class]]) &#123;</span><br><span class=\"line\">            UINavigationController * nav = (UINavigationController *)self.window.rootViewController;</span><br><span class=\"line\">            UIViewController *topVC = nav.childViewControllers.firstObject;</span><br><span class=\"line\">            if ([topVC respondsToSelector:@selector(handleSharedFile)]) &#123;</span><br><span class=\"line\">                [topVC performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if ([vc respondsToSelector:@selector(handleSharedFile)]) &#123;</span><br><span class=\"line\">                [vc performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根控制器方法(头文件需要声明方法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)handleSharedFile &#123;</span><br><span class=\"line\">    AppDelegate *app = (AppDelegate *)[UIApplication sharedApplication].delegate;</span><br><span class=\"line\">    if (app.sharedURL != nil) &#123;</span><br><span class=\"line\">        self.sharedURL = [app.sharedURL copy];</span><br><span class=\"line\">        app.sharedURL = nil;</span><br><span class=\"line\">        [self saveSharedFile:self.sharedURL];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)saveSharedFile:(NSURL *)url &#123;</span><br><span class=\"line\">    MBProgressHUD *hud = [MBProgressHUD showButtonHUDAddedTo:self.view animated:YES];</span><br><span class=\"line\">    DKFile *file = [[DKFile alloc] init];</span><br><span class=\"line\">    file.fullPath = url.path;</span><br><span class=\"line\">    file.fileName = url.path.lastPathComponent;</span><br><span class=\"line\">    [[DKFileManager sharedInstance] copyItemsOfSelectFiles:@[file] fromStorage:DKFileStorageTypeInternal toStorage:DKFileStorageTypeInternal toPath:[DKFileManager defaultPath:kShareDirectory storage:DKFileStorageTypeInternal] progressHUD:hud complete:^&#123;</span><br><span class=\"line\">        [SVProgressHUD showSuccessWithStatus:@&quot;已保存到 iPhone -&gt; SharedFiles&quot;];</span><br><span class=\"line\">    &#125; failure:^(NSError *errors) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"网络层方法封装","author":"Arclin","abbrlink":"3d9cee8d","date":"2016-10-28T16:00:00.000Z","_content":"网络层的方法封装\n<!-- more -->\n\n## 特点\n - 集成AFNetworking\n - 集成MJExtension\n - 统一回调\n - 方便顶层调用\n - 统一错误处理\n - 适应接口设计\n\n## 设计（以POST和退出登录接口举例）\n1. 接口设计\n  ```\n  typedef void (^DKResponseBlock)(DKResponse *response);\n\n  + (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters success:(nonnull DKResponseBlock)callBack;\n  1.1 DKResponse 回调模型设计（根据接口进行设计）\n\n\n   #import <Foundation/Foundation.h>\n\n  @interface DKResponse : NSObject\n\n  /** state */\n  @property (nonatomic,copy) NSString *state;\n\n  /** result */\n  @property (nonatomic,copy) NSDictionary *result;\n\n  /** message */\n  @property (nonatomic,copy) NSString *message;\n\n  /** 纯数据 */\n  @property (nonatomic, strong) id rawData;\n\n  /** error */\n  @property (nonatomic,copy) NSError *error;\n\n  @end\n  ```\n2. 底层方法实现\n  ```\n  (DKConfiguration.h 或者使用 plist)\n   static NSString *kDKTimeoutInterval = 10.0f;\n   static NSString *kDKSuccessMessage = @\"success\";\n\n  + (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters callBack:(nonnull DKResponseBlock)callBack {\n      AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n      mgr.requestSerializer.timeoutInterval = kDKTimeoutInterval;\n      [mgr POST:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n          DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject]; // 转为响应信息模型\n          resp.rawData = responseObject; // 储存源数据\n          if(callBack){\n              if (![resp.message isEqualToString:kDKSuccessMessage]) { // 判断是否是成功的\n                  resp.error = [NSError errorWithDomain:@\"dankal.cn\" code:[resp.state integerValue] userInfo:@{@\"message\":resp.message}]; // 生成错误对象\n                  callBack(resp);\n              }else{\n                  callBack(resp); // 没有错误直接返回\n              }\n          }\n\n      } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n          DKLog(@\"%@\",error);\n          DKResponse *response = [[DKResponse alloc] init]; // 随便看看\n          response.error = error;\n          if(callBack){\n              callBack(response);\n          }\n      }];\n  }\n  ```\n3. 业务层接口设计\n  ```\n  (DKLogin.h)\n  typedef void (^DKBlockSuccessOrError)(BOOL isSuccessful,NSError *error);\n  // 其他需求可以定制其他回调，如下\n  typedef void (^DKArrayResultBlock)(NSArray *result,NSError *error);\n  typedef void (^DKIntegerResultBlock)(NSInteger number, NSError *error) ;\n  typedef void (^DKUserResultBlock)(DKUser *user, NSError *error); // DKUser为模型\n\n  + (void)logout:(DKBlockSuccessOrError)callBack;\n  ```\n4. 业务层接口实现\n  ```\n  + (void)logout:(DKBlockSuccessOrError)callBack\n  {\n      NSString *url = @\"xxxx\";\n      NSDictionary *params = @{@\"xxx\":@\"xxx\"};\n      [DKHTTPTool POST:url parameters:params success:^(DKResponse *response) {\n          if (callBack) {\n            response.error ? callBack(NO,response.error) : callBack(YES,nil);\n          }\n       }];\n   }\n  ```\n5. ViewModel 或 ViewController 调用\n  ```\n  [DKLoginService logout:^(BOOL isSuccess,NSError *error){\n      if(isSuccess){\n\n      }else{\n\n      }\n  }];\n  ```","source":"_posts/网络层方法封装.md","raw":"---\ntitle: 网络层方法封装\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 3d9cee8d\ndate: 2016-10-29 00:00:00\n---\n网络层的方法封装\n<!-- more -->\n\n## 特点\n - 集成AFNetworking\n - 集成MJExtension\n - 统一回调\n - 方便顶层调用\n - 统一错误处理\n - 适应接口设计\n\n## 设计（以POST和退出登录接口举例）\n1. 接口设计\n  ```\n  typedef void (^DKResponseBlock)(DKResponse *response);\n\n  + (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters success:(nonnull DKResponseBlock)callBack;\n  1.1 DKResponse 回调模型设计（根据接口进行设计）\n\n\n   #import <Foundation/Foundation.h>\n\n  @interface DKResponse : NSObject\n\n  /** state */\n  @property (nonatomic,copy) NSString *state;\n\n  /** result */\n  @property (nonatomic,copy) NSDictionary *result;\n\n  /** message */\n  @property (nonatomic,copy) NSString *message;\n\n  /** 纯数据 */\n  @property (nonatomic, strong) id rawData;\n\n  /** error */\n  @property (nonatomic,copy) NSError *error;\n\n  @end\n  ```\n2. 底层方法实现\n  ```\n  (DKConfiguration.h 或者使用 plist)\n   static NSString *kDKTimeoutInterval = 10.0f;\n   static NSString *kDKSuccessMessage = @\"success\";\n\n  + (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters callBack:(nonnull DKResponseBlock)callBack {\n      AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n      mgr.requestSerializer.timeoutInterval = kDKTimeoutInterval;\n      [mgr POST:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n          DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject]; // 转为响应信息模型\n          resp.rawData = responseObject; // 储存源数据\n          if(callBack){\n              if (![resp.message isEqualToString:kDKSuccessMessage]) { // 判断是否是成功的\n                  resp.error = [NSError errorWithDomain:@\"dankal.cn\" code:[resp.state integerValue] userInfo:@{@\"message\":resp.message}]; // 生成错误对象\n                  callBack(resp);\n              }else{\n                  callBack(resp); // 没有错误直接返回\n              }\n          }\n\n      } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n          DKLog(@\"%@\",error);\n          DKResponse *response = [[DKResponse alloc] init]; // 随便看看\n          response.error = error;\n          if(callBack){\n              callBack(response);\n          }\n      }];\n  }\n  ```\n3. 业务层接口设计\n  ```\n  (DKLogin.h)\n  typedef void (^DKBlockSuccessOrError)(BOOL isSuccessful,NSError *error);\n  // 其他需求可以定制其他回调，如下\n  typedef void (^DKArrayResultBlock)(NSArray *result,NSError *error);\n  typedef void (^DKIntegerResultBlock)(NSInteger number, NSError *error) ;\n  typedef void (^DKUserResultBlock)(DKUser *user, NSError *error); // DKUser为模型\n\n  + (void)logout:(DKBlockSuccessOrError)callBack;\n  ```\n4. 业务层接口实现\n  ```\n  + (void)logout:(DKBlockSuccessOrError)callBack\n  {\n      NSString *url = @\"xxxx\";\n      NSDictionary *params = @{@\"xxx\":@\"xxx\"};\n      [DKHTTPTool POST:url parameters:params success:^(DKResponse *response) {\n          if (callBack) {\n            response.error ? callBack(NO,response.error) : callBack(YES,nil);\n          }\n       }];\n   }\n  ```\n5. ViewModel 或 ViewController 调用\n  ```\n  [DKLoginService logout:^(BOOL isSuccess,NSError *error){\n      if(isSuccess){\n\n      }else{\n\n      }\n  }];\n  ```","slug":"网络层方法封装","published":1,"updated":"2018-05-10T06:51:35.771Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcmv0050ldxuiyq9w0rz","content":"<p>网络层的方法封装<br><a id=\"more\"></a></p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>集成AFNetworking</li>\n<li>集成MJExtension</li>\n<li>统一回调</li>\n<li>方便顶层调用</li>\n<li>统一错误处理</li>\n<li>适应接口设计</li>\n</ul>\n<h2 id=\"设计（以POST和退出登录接口举例）\"><a href=\"#设计（以POST和退出登录接口举例）\" class=\"headerlink\" title=\"设计（以POST和退出登录接口举例）\"></a>设计（以POST和退出登录接口举例）</h2><ol>\n<li><p>接口设计</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef void (^DKResponseBlock)(DKResponse *response);</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters success:(nonnull DKResponseBlock)callBack;</span><br><span class=\"line\">1.1 DKResponse 回调模型设计（根据接口进行设计）</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> #import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface DKResponse : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">/** state */</span><br><span class=\"line\">@property (nonatomic,copy) NSString *state;</span><br><span class=\"line\"></span><br><span class=\"line\">/** result */</span><br><span class=\"line\">@property (nonatomic,copy) NSDictionary *result;</span><br><span class=\"line\"></span><br><span class=\"line\">/** message */</span><br><span class=\"line\">@property (nonatomic,copy) NSString *message;</span><br><span class=\"line\"></span><br><span class=\"line\">/** 纯数据 */</span><br><span class=\"line\">@property (nonatomic, strong) id rawData;</span><br><span class=\"line\"></span><br><span class=\"line\">/** error */</span><br><span class=\"line\">@property (nonatomic,copy) NSError *error;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>底层方法实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(DKConfiguration.h 或者使用 plist)</span><br><span class=\"line\"> static NSString *kDKTimeoutInterval = 10.0f;</span><br><span class=\"line\"> static NSString *kDKSuccessMessage = @&quot;success&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters callBack:(nonnull DKResponseBlock)callBack &#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];</span><br><span class=\"line\">    mgr.requestSerializer.timeoutInterval = kDKTimeoutInterval;</span><br><span class=\"line\">    [mgr POST:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject]; // 转为响应信息模型</span><br><span class=\"line\">        resp.rawData = responseObject; // 储存源数据</span><br><span class=\"line\">        if(callBack)&#123;</span><br><span class=\"line\">            if (![resp.message isEqualToString:kDKSuccessMessage]) &#123; // 判断是否是成功的</span><br><span class=\"line\">                resp.error = [NSError errorWithDomain:@&quot;dankal.cn&quot; code:[resp.state integerValue] userInfo:@&#123;@&quot;message&quot;:resp.message&#125;]; // 生成错误对象</span><br><span class=\"line\">                callBack(resp);</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                callBack(resp); // 没有错误直接返回</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">        DKResponse *response = [[DKResponse alloc] init]; // 随便看看</span><br><span class=\"line\">        response.error = error;</span><br><span class=\"line\">        if(callBack)&#123;</span><br><span class=\"line\">            callBack(response);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>业务层接口设计</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(DKLogin.h)</span><br><span class=\"line\">typedef void (^DKBlockSuccessOrError)(BOOL isSuccessful,NSError *error);</span><br><span class=\"line\">// 其他需求可以定制其他回调，如下</span><br><span class=\"line\">typedef void (^DKArrayResultBlock)(NSArray *result,NSError *error);</span><br><span class=\"line\">typedef void (^DKIntegerResultBlock)(NSInteger number, NSError *error) ;</span><br><span class=\"line\">typedef void (^DKUserResultBlock)(DKUser *user, NSError *error); // DKUser为模型</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)logout:(DKBlockSuccessOrError)callBack;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>业务层接口实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)logout:(DKBlockSuccessOrError)callBack</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSString *url = @&quot;xxxx&quot;;</span><br><span class=\"line\">    NSDictionary *params = @&#123;@&quot;xxx&quot;:@&quot;xxx&quot;&#125;;</span><br><span class=\"line\">    [DKHTTPTool POST:url parameters:params success:^(DKResponse *response) &#123;</span><br><span class=\"line\">        if (callBack) &#123;</span><br><span class=\"line\">          response.error ? callBack(NO,response.error) : callBack(YES,nil);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;];</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ViewModel 或 ViewController 调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKLoginService logout:^(BOOL isSuccess,NSError *error)&#123;</span><br><span class=\"line\">    if(isSuccess)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>网络层的方法封装<br>","more":"</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>集成AFNetworking</li>\n<li>集成MJExtension</li>\n<li>统一回调</li>\n<li>方便顶层调用</li>\n<li>统一错误处理</li>\n<li>适应接口设计</li>\n</ul>\n<h2 id=\"设计（以POST和退出登录接口举例）\"><a href=\"#设计（以POST和退出登录接口举例）\" class=\"headerlink\" title=\"设计（以POST和退出登录接口举例）\"></a>设计（以POST和退出登录接口举例）</h2><ol>\n<li><p>接口设计</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef void (^DKResponseBlock)(DKResponse *response);</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters success:(nonnull DKResponseBlock)callBack;</span><br><span class=\"line\">1.1 DKResponse 回调模型设计（根据接口进行设计）</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> #import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface DKResponse : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">/** state */</span><br><span class=\"line\">@property (nonatomic,copy) NSString *state;</span><br><span class=\"line\"></span><br><span class=\"line\">/** result */</span><br><span class=\"line\">@property (nonatomic,copy) NSDictionary *result;</span><br><span class=\"line\"></span><br><span class=\"line\">/** message */</span><br><span class=\"line\">@property (nonatomic,copy) NSString *message;</span><br><span class=\"line\"></span><br><span class=\"line\">/** 纯数据 */</span><br><span class=\"line\">@property (nonatomic, strong) id rawData;</span><br><span class=\"line\"></span><br><span class=\"line\">/** error */</span><br><span class=\"line\">@property (nonatomic,copy) NSError *error;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>底层方法实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(DKConfiguration.h 或者使用 plist)</span><br><span class=\"line\"> static NSString *kDKTimeoutInterval = 10.0f;</span><br><span class=\"line\"> static NSString *kDKSuccessMessage = @&quot;success&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters callBack:(nonnull DKResponseBlock)callBack &#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];</span><br><span class=\"line\">    mgr.requestSerializer.timeoutInterval = kDKTimeoutInterval;</span><br><span class=\"line\">    [mgr POST:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject]; // 转为响应信息模型</span><br><span class=\"line\">        resp.rawData = responseObject; // 储存源数据</span><br><span class=\"line\">        if(callBack)&#123;</span><br><span class=\"line\">            if (![resp.message isEqualToString:kDKSuccessMessage]) &#123; // 判断是否是成功的</span><br><span class=\"line\">                resp.error = [NSError errorWithDomain:@&quot;dankal.cn&quot; code:[resp.state integerValue] userInfo:@&#123;@&quot;message&quot;:resp.message&#125;]; // 生成错误对象</span><br><span class=\"line\">                callBack(resp);</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                callBack(resp); // 没有错误直接返回</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">        DKResponse *response = [[DKResponse alloc] init]; // 随便看看</span><br><span class=\"line\">        response.error = error;</span><br><span class=\"line\">        if(callBack)&#123;</span><br><span class=\"line\">            callBack(response);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>业务层接口设计</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(DKLogin.h)</span><br><span class=\"line\">typedef void (^DKBlockSuccessOrError)(BOOL isSuccessful,NSError *error);</span><br><span class=\"line\">// 其他需求可以定制其他回调，如下</span><br><span class=\"line\">typedef void (^DKArrayResultBlock)(NSArray *result,NSError *error);</span><br><span class=\"line\">typedef void (^DKIntegerResultBlock)(NSInteger number, NSError *error) ;</span><br><span class=\"line\">typedef void (^DKUserResultBlock)(DKUser *user, NSError *error); // DKUser为模型</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)logout:(DKBlockSuccessOrError)callBack;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>业务层接口实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)logout:(DKBlockSuccessOrError)callBack</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSString *url = @&quot;xxxx&quot;;</span><br><span class=\"line\">    NSDictionary *params = @&#123;@&quot;xxx&quot;:@&quot;xxx&quot;&#125;;</span><br><span class=\"line\">    [DKHTTPTool POST:url parameters:params success:^(DKResponse *response) &#123;</span><br><span class=\"line\">        if (callBack) &#123;</span><br><span class=\"line\">          response.error ? callBack(NO,response.error) : callBack(YES,nil);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;];</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ViewModel 或 ViewController 调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKLoginService logout:^(BOOL isSuccess,NSError *error)&#123;</span><br><span class=\"line\">    if(isSuccess)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></li>\n</ol>"},{"title":"网络层方法封装3","author":"Arclin","abbrlink":"fee6ede8","date":"2016-11-20T16:00:00.000Z","_content":"网络层方法封装3.1\n\n<!-- more -->\n\n** 其实很久之前就想写写这个东西,不过因为项目的原因一直没时间去整理出来,所以决定还是分开几天去写完这个东西吧\n\n- 新增特性:\n\t- 3.0\n\t\t- 多缓存策略\n\t\t- 用宏定义减少代码量\n\t\t- 使用 plist统一错误信息设置\n\t- 3.1\n\t\t- 输出一个漂亮的Log\n\n- 先讲讲本地持久化策略的选择\n\n\t- 数据量小,单一的时候(比如一个模型数组,数组不大而且模型的成员属性不是很多),可以使用 `NSKeyArchive` 归档\n\n\t- `NSUserDefault` 用于储存用户首选项\n\n\t- `KeyChain`储存一些密码之类的东西\n\n\t- 数据库储存数据量比较大,字段比较多的模型数组\n\n- 缓存策略\n\n```\ntypedef NS_ENUM(NSInteger,DKCacheStrategy){\n    DKCacheStrategy_CACHE_ONLY, // 只从本地取数据\n    DKCacheStrategy_NETWORK_ONLY, // 只从网络取数据(不缓存)\n    DKCacheStrategy_NETWORK_AND_CACHE, // 从网络取数据后缓存(缓存结束不回调)\n    DKCacheStrategy_CACHE_ELSE_NETWORK, // 先取缓存,如果没有数据的话,才从网络取数据\n    DKCacheStrategy_CACHE_THEN_NETWORK // 先取缓存,再加载网络数据,网络数据加载完会更新缓存,这个选择会有两次回调\n    DKCacheStrategy_AUTOMATIC // 根据当前网络环境自动选择,如果有网络(WIFI/WLAN)就取网络数据,没网络就取缓存数据\n};\n```\n\n- Demo 说明\n   - github地址:没有\n   - 下载地址: NetworkDemo\n   - 选择本地持久化方式: `YYCache`,如果有更适合的缓存机制,那改一改也挺简单\n \n- 方法接口设计\n\n```\n/**\n *  发送HTTP请求\n *\n *  @param method 请求方法,你可以写@\"get\"或者@\"post\"(不区分大小写)或者已经定义好的 kGET 或 kPOST\n *  @param strategy  缓存策略\n *  @param header 请求头,可为空\n *  @param params 请求参数,可为空\n *  @param block  返回回调,这个就不要空啦\n *\n *  @return 请求标示 id 可以用来取消请求\n */\n- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block;\n```\n\n之前两个方法继续保留,在这里就不说明了\n\n```\n- (void)cancelAllRequest;\n- (void)cancelRequestWithRequestIds:(NSArray *)requestIds;\n```\n\n然后写两个内部方法,分别是取缓存和取网络数据\n\n```\n#pragma mark - 仅本地\n- (NSInteger)requestWithCacheOnlyStrategyWithUrl:(NSString *)URLString params:(NSDictionary *)params requestBlock:(DKHTTPResponseBlock)block\n{\n    DKResponse *response = (DKResponse *)[self.cache objectForKey:[self cacheKeyForRequestUrl:URLString params:params]];\n    if (block) {\n        if (response) {\n            block(response);\n        }else{\n            block(KERROR_RESPONSE(-1));\n        }\n    }\n    return 0;\n}\n\n#pragma mark - 仅网络\n- (NSInteger)requestWithNetworkOnlyStrategyForMethod:(NSString *)method url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block\n{\n    NSNumber *taskIdentifier = 0;\n    if ([method.uppercaseString isEqualToString:@\"GET\"]) {\n        DKCALLAPI(GET, taskIdentifier);\n    }else if([method.uppercaseString isEqualToString:@\"POST\"]){\n        DKCALLAPI(POST, taskIdentifier);\n    }else{\n        return 0;\n    }\n    return taskIdentifier.integerValue;\n}\n```\n\n这里的宏DKCALLAPI 定义 主要是为了不想写 POST和 GET两个方法,在这里写一次就够了\n\n```\n#define DKCALLAPI(REQUEST_METHOD,REQUEST_ID) \\\n{\\\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\\\n    AFHTTPRequestSerializer *requestSerializer = mgr.requestSerializer;\\\n    if (header) {\\\n        [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id obj, BOOL * _Nonnull stop) {\\\n            [requestSerializer setValue:obj forHTTPHeaderField:key];\\\n        }];\\\n    }\\\n    requestSerializer.timeoutInterval = kTimeOutInterval;\\\n    NSURLSessionTask *task = [mgr REQUEST_METHOD:URLString parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\\\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\\\n        resp.rawData = responseObject;\\\n        resp.taskIdentifier = task.taskIdentifier;\\\n        if(block){\\\n            block(resp);\\\n        }\\\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\\\n        DKResponse *resp = [DKResponse responseWithErrorOnly:error.description code:error.code];\\\n        if (block) {\\\n            block(resp);\\\n        }\\\n    }];\\\n    REQUEST_ID = @(task.taskIdentifier);\\\n    [self.dispatchTable setObject:task forKey:REQUEST_ID];\\\n}\n```\n\n然后 就可以实现我们的接口了 switch 里面的东西就就根据注释写吧\n\n```\n- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block\n{\n    __weak typeof(self) weakSelf = self;\n    NSInteger requestId;\n    switch (strategy) {\n        case DKCacheStrategy_CACHE_ONLY:\n        // 调用获取缓存方法\n            break;\n        case DKCacheStrategy_NETWORK_ONLY:\n        // 调用获取网络方法\n            break;\n        case DKCacheStrategy_NETWORK_AND_CACHE:\n        // 调用网络方法,回调后写入本地缓存\n            break;\n        case DKCacheStrategy_CACHE_ELSE_NETWORK:\n        // 调用本地缓存方法,在回调中判断是否有缓存,如果没有的话调用网络方法\n            break;\n        case DKCacheStrategy_CACHE_THEN_NETWORK:\n        // 调用本地方法接着调用网络方法 \n            break;\n        case DKCacheStrategy_AUTOMATICALLY:\n         // 调用网络方法,回调中如果返回错误则调用本地缓存方法\n            break;\n        default:\n            break;\n    }\n    return requestId;\n}\n```\n\n统一错误表处理\n-建立一个plist 文件\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>-2</key>\n\t<string>网络连接失败</string>\n\t<key>-1</key>\n\t<string>没有缓存</string>\n</dict>\n</plist>\n```\n\n一个成员属性加一个方法去调用\n\n```\n- (NSDictionary *)errorDic\n{\n    if (!_errorDic) {\n        NSString *path = [[NSBundle mainBundle] pathForResource:@\"DKError\" ofType:@\"plist\"];\n        _errorDic = [NSDictionary dictionaryWithContentsOfFile:path];\n    }\n    return _errorDic;\n}\n\n- (NSString *)errorDescriptionWithCode:(NSInteger)code\n{\n    NSString *codeStr = [NSString stringWithFormat:@\"%zd\",code];\n    if ([self.errorDic.allKeys containsObject:codeStr]) {\n        return self.errorDic[codeStr];\n    }else{\n        NSLog(@\"没有定义该类型错误\");\n        return nil;\n    }\n}\n```\n\n包装成宏方便调用\n\n```\n#define KERROR_RESPONSE(errCode) [DKResponse responseWithErrorOnly:[self errorDescriptionWithCode:errCode] code:errCode]\n```\n\n3.1 输出一个漂亮的 Log\n\n```\n/**\n *  打印一个漂亮的 log\n *\n *  @param method              请求方法\n *  @param url                 接口地址\n *  @param params              参数\n *  @param response            响应对象\n *  @param showRequestContent  是否显示响应数据\n */\n+ (void)logDebugInfoWithMethod:(NSString *)method URL:(NSString *)url params:(NSDictionary *)params response:(DKResponse *)response showRequestContent:(BOOL)showRequestContent;\n```\n\n里面主要是字符串拼接.要看详细的话就去下载 Demo吧!\n\n","source":"_posts/网络层方法封装3.md","raw":"---\ntitle: 网络层方法封装3\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: fee6ede8\ndate: 2016-11-21 00:00:00\n---\n网络层方法封装3.1\n\n<!-- more -->\n\n** 其实很久之前就想写写这个东西,不过因为项目的原因一直没时间去整理出来,所以决定还是分开几天去写完这个东西吧\n\n- 新增特性:\n\t- 3.0\n\t\t- 多缓存策略\n\t\t- 用宏定义减少代码量\n\t\t- 使用 plist统一错误信息设置\n\t- 3.1\n\t\t- 输出一个漂亮的Log\n\n- 先讲讲本地持久化策略的选择\n\n\t- 数据量小,单一的时候(比如一个模型数组,数组不大而且模型的成员属性不是很多),可以使用 `NSKeyArchive` 归档\n\n\t- `NSUserDefault` 用于储存用户首选项\n\n\t- `KeyChain`储存一些密码之类的东西\n\n\t- 数据库储存数据量比较大,字段比较多的模型数组\n\n- 缓存策略\n\n```\ntypedef NS_ENUM(NSInteger,DKCacheStrategy){\n    DKCacheStrategy_CACHE_ONLY, // 只从本地取数据\n    DKCacheStrategy_NETWORK_ONLY, // 只从网络取数据(不缓存)\n    DKCacheStrategy_NETWORK_AND_CACHE, // 从网络取数据后缓存(缓存结束不回调)\n    DKCacheStrategy_CACHE_ELSE_NETWORK, // 先取缓存,如果没有数据的话,才从网络取数据\n    DKCacheStrategy_CACHE_THEN_NETWORK // 先取缓存,再加载网络数据,网络数据加载完会更新缓存,这个选择会有两次回调\n    DKCacheStrategy_AUTOMATIC // 根据当前网络环境自动选择,如果有网络(WIFI/WLAN)就取网络数据,没网络就取缓存数据\n};\n```\n\n- Demo 说明\n   - github地址:没有\n   - 下载地址: NetworkDemo\n   - 选择本地持久化方式: `YYCache`,如果有更适合的缓存机制,那改一改也挺简单\n \n- 方法接口设计\n\n```\n/**\n *  发送HTTP请求\n *\n *  @param method 请求方法,你可以写@\"get\"或者@\"post\"(不区分大小写)或者已经定义好的 kGET 或 kPOST\n *  @param strategy  缓存策略\n *  @param header 请求头,可为空\n *  @param params 请求参数,可为空\n *  @param block  返回回调,这个就不要空啦\n *\n *  @return 请求标示 id 可以用来取消请求\n */\n- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block;\n```\n\n之前两个方法继续保留,在这里就不说明了\n\n```\n- (void)cancelAllRequest;\n- (void)cancelRequestWithRequestIds:(NSArray *)requestIds;\n```\n\n然后写两个内部方法,分别是取缓存和取网络数据\n\n```\n#pragma mark - 仅本地\n- (NSInteger)requestWithCacheOnlyStrategyWithUrl:(NSString *)URLString params:(NSDictionary *)params requestBlock:(DKHTTPResponseBlock)block\n{\n    DKResponse *response = (DKResponse *)[self.cache objectForKey:[self cacheKeyForRequestUrl:URLString params:params]];\n    if (block) {\n        if (response) {\n            block(response);\n        }else{\n            block(KERROR_RESPONSE(-1));\n        }\n    }\n    return 0;\n}\n\n#pragma mark - 仅网络\n- (NSInteger)requestWithNetworkOnlyStrategyForMethod:(NSString *)method url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block\n{\n    NSNumber *taskIdentifier = 0;\n    if ([method.uppercaseString isEqualToString:@\"GET\"]) {\n        DKCALLAPI(GET, taskIdentifier);\n    }else if([method.uppercaseString isEqualToString:@\"POST\"]){\n        DKCALLAPI(POST, taskIdentifier);\n    }else{\n        return 0;\n    }\n    return taskIdentifier.integerValue;\n}\n```\n\n这里的宏DKCALLAPI 定义 主要是为了不想写 POST和 GET两个方法,在这里写一次就够了\n\n```\n#define DKCALLAPI(REQUEST_METHOD,REQUEST_ID) \\\n{\\\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\\\n    AFHTTPRequestSerializer *requestSerializer = mgr.requestSerializer;\\\n    if (header) {\\\n        [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id obj, BOOL * _Nonnull stop) {\\\n            [requestSerializer setValue:obj forHTTPHeaderField:key];\\\n        }];\\\n    }\\\n    requestSerializer.timeoutInterval = kTimeOutInterval;\\\n    NSURLSessionTask *task = [mgr REQUEST_METHOD:URLString parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\\\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\\\n        resp.rawData = responseObject;\\\n        resp.taskIdentifier = task.taskIdentifier;\\\n        if(block){\\\n            block(resp);\\\n        }\\\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\\\n        DKResponse *resp = [DKResponse responseWithErrorOnly:error.description code:error.code];\\\n        if (block) {\\\n            block(resp);\\\n        }\\\n    }];\\\n    REQUEST_ID = @(task.taskIdentifier);\\\n    [self.dispatchTable setObject:task forKey:REQUEST_ID];\\\n}\n```\n\n然后 就可以实现我们的接口了 switch 里面的东西就就根据注释写吧\n\n```\n- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block\n{\n    __weak typeof(self) weakSelf = self;\n    NSInteger requestId;\n    switch (strategy) {\n        case DKCacheStrategy_CACHE_ONLY:\n        // 调用获取缓存方法\n            break;\n        case DKCacheStrategy_NETWORK_ONLY:\n        // 调用获取网络方法\n            break;\n        case DKCacheStrategy_NETWORK_AND_CACHE:\n        // 调用网络方法,回调后写入本地缓存\n            break;\n        case DKCacheStrategy_CACHE_ELSE_NETWORK:\n        // 调用本地缓存方法,在回调中判断是否有缓存,如果没有的话调用网络方法\n            break;\n        case DKCacheStrategy_CACHE_THEN_NETWORK:\n        // 调用本地方法接着调用网络方法 \n            break;\n        case DKCacheStrategy_AUTOMATICALLY:\n         // 调用网络方法,回调中如果返回错误则调用本地缓存方法\n            break;\n        default:\n            break;\n    }\n    return requestId;\n}\n```\n\n统一错误表处理\n-建立一个plist 文件\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>-2</key>\n\t<string>网络连接失败</string>\n\t<key>-1</key>\n\t<string>没有缓存</string>\n</dict>\n</plist>\n```\n\n一个成员属性加一个方法去调用\n\n```\n- (NSDictionary *)errorDic\n{\n    if (!_errorDic) {\n        NSString *path = [[NSBundle mainBundle] pathForResource:@\"DKError\" ofType:@\"plist\"];\n        _errorDic = [NSDictionary dictionaryWithContentsOfFile:path];\n    }\n    return _errorDic;\n}\n\n- (NSString *)errorDescriptionWithCode:(NSInteger)code\n{\n    NSString *codeStr = [NSString stringWithFormat:@\"%zd\",code];\n    if ([self.errorDic.allKeys containsObject:codeStr]) {\n        return self.errorDic[codeStr];\n    }else{\n        NSLog(@\"没有定义该类型错误\");\n        return nil;\n    }\n}\n```\n\n包装成宏方便调用\n\n```\n#define KERROR_RESPONSE(errCode) [DKResponse responseWithErrorOnly:[self errorDescriptionWithCode:errCode] code:errCode]\n```\n\n3.1 输出一个漂亮的 Log\n\n```\n/**\n *  打印一个漂亮的 log\n *\n *  @param method              请求方法\n *  @param url                 接口地址\n *  @param params              参数\n *  @param response            响应对象\n *  @param showRequestContent  是否显示响应数据\n */\n+ (void)logDebugInfoWithMethod:(NSString *)method URL:(NSString *)url params:(NSDictionary *)params response:(DKResponse *)response showRequestContent:(BOOL)showRequestContent;\n```\n\n里面主要是字符串拼接.要看详细的话就去下载 Demo吧!\n\n","slug":"网络层方法封装3","published":1,"updated":"2018-05-10T06:51:35.772Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcmy0054ldxucdmybys3","content":"<p>网络层方法封装3.1</p>\n<a id=\"more\"></a>\n<p>** 其实很久之前就想写写这个东西,不过因为项目的原因一直没时间去整理出来,所以决定还是分开几天去写完这个东西吧</p>\n<ul>\n<li><p>新增特性:</p>\n<ul>\n<li>3.0<ul>\n<li>多缓存策略</li>\n<li>用宏定义减少代码量</li>\n<li>使用 plist统一错误信息设置</li>\n</ul>\n</li>\n<li>3.1<ul>\n<li>输出一个漂亮的Log</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>先讲讲本地持久化策略的选择</p>\n<ul>\n<li><p>数据量小,单一的时候(比如一个模型数组,数组不大而且模型的成员属性不是很多),可以使用 <code>NSKeyArchive</code> 归档</p>\n</li>\n<li><p><code>NSUserDefault</code> 用于储存用户首选项</p>\n</li>\n<li><p><code>KeyChain</code>储存一些密码之类的东西</p>\n</li>\n<li><p>数据库储存数据量比较大,字段比较多的模型数组</p>\n</li>\n</ul>\n</li>\n<li><p>缓存策略</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_ENUM(NSInteger,DKCacheStrategy)&#123;</span><br><span class=\"line\">    DKCacheStrategy_CACHE_ONLY, // 只从本地取数据</span><br><span class=\"line\">    DKCacheStrategy_NETWORK_ONLY, // 只从网络取数据(不缓存)</span><br><span class=\"line\">    DKCacheStrategy_NETWORK_AND_CACHE, // 从网络取数据后缓存(缓存结束不回调)</span><br><span class=\"line\">    DKCacheStrategy_CACHE_ELSE_NETWORK, // 先取缓存,如果没有数据的话,才从网络取数据</span><br><span class=\"line\">    DKCacheStrategy_CACHE_THEN_NETWORK // 先取缓存,再加载网络数据,网络数据加载完会更新缓存,这个选择会有两次回调</span><br><span class=\"line\">    DKCacheStrategy_AUTOMATIC // 根据当前网络环境自动选择,如果有网络(WIFI/WLAN)就取网络数据,没网络就取缓存数据</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>Demo 说明</p>\n<ul>\n<li>github地址:没有</li>\n<li>下载地址: NetworkDemo</li>\n<li>选择本地持久化方式: <code>YYCache</code>,如果有更适合的缓存机制,那改一改也挺简单</li>\n</ul>\n</li>\n<li><p>方法接口设计</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *  发送HTTP请求</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param method 请求方法,你可以写@&quot;get&quot;或者@&quot;post&quot;(不区分大小写)或者已经定义好的 kGET 或 kPOST</span><br><span class=\"line\"> *  @param strategy  缓存策略</span><br><span class=\"line\"> *  @param header 请求头,可为空</span><br><span class=\"line\"> *  @param params 请求参数,可为空</span><br><span class=\"line\"> *  @param block  返回回调,这个就不要空啦</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @return 请求标示 id 可以用来取消请求</span><br><span class=\"line\"> */</span><br><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n<p>之前两个方法继续保留,在这里就不说明了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)cancelAllRequest;</span><br><span class=\"line\">- (void)cancelRequestWithRequestIds:(NSArray *)requestIds;</span><br></pre></td></tr></table></figure>\n<p>然后写两个内部方法,分别是取缓存和取网络数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - 仅本地</span><br><span class=\"line\">- (NSInteger)requestWithCacheOnlyStrategyWithUrl:(NSString *)URLString params:(NSDictionary *)params requestBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DKResponse *response = (DKResponse *)[self.cache objectForKey:[self cacheKeyForRequestUrl:URLString params:params]];</span><br><span class=\"line\">    if (block) &#123;</span><br><span class=\"line\">        if (response) &#123;</span><br><span class=\"line\">            block(response);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            block(KERROR_RESPONSE(-1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - 仅网络</span><br><span class=\"line\">- (NSInteger)requestWithNetworkOnlyStrategyForMethod:(NSString *)method url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSNumber *taskIdentifier = 0;</span><br><span class=\"line\">    if ([method.uppercaseString isEqualToString:@&quot;GET&quot;]) &#123;</span><br><span class=\"line\">        DKCALLAPI(GET, taskIdentifier);</span><br><span class=\"line\">    &#125;else if([method.uppercaseString isEqualToString:@&quot;POST&quot;])&#123;</span><br><span class=\"line\">        DKCALLAPI(POST, taskIdentifier);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return taskIdentifier.integerValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的宏DKCALLAPI 定义 主要是为了不想写 POST和 GET两个方法,在这里写一次就够了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKCALLAPI(REQUEST_METHOD,REQUEST_ID) \\</span><br><span class=\"line\">&#123;\\</span><br><span class=\"line\">    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\\</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer = mgr.requestSerializer;\\</span><br><span class=\"line\">    if (header) &#123;\\</span><br><span class=\"line\">        [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id obj, BOOL * _Nonnull stop) &#123;\\</span><br><span class=\"line\">            [requestSerializer setValue:obj forHTTPHeaderField:key];\\</span><br><span class=\"line\">        &#125;];\\</span><br><span class=\"line\">    &#125;\\</span><br><span class=\"line\">    requestSerializer.timeoutInterval = kTimeOutInterval;\\</span><br><span class=\"line\">    NSURLSessionTask *task = [mgr REQUEST_METHOD:URLString parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;\\</span><br><span class=\"line\">        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\\</span><br><span class=\"line\">        resp.rawData = responseObject;\\</span><br><span class=\"line\">        resp.taskIdentifier = task.taskIdentifier;\\</span><br><span class=\"line\">        if(block)&#123;\\</span><br><span class=\"line\">            block(resp);\\</span><br><span class=\"line\">        &#125;\\</span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;\\</span><br><span class=\"line\">        DKResponse *resp = [DKResponse responseWithErrorOnly:error.description code:error.code];\\</span><br><span class=\"line\">        if (block) &#123;\\</span><br><span class=\"line\">            block(resp);\\</span><br><span class=\"line\">        &#125;\\</span><br><span class=\"line\">    &#125;];\\</span><br><span class=\"line\">    REQUEST_ID = @(task.taskIdentifier);\\</span><br><span class=\"line\">    [self.dispatchTable setObject:task forKey:REQUEST_ID];\\</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后 就可以实现我们的接口了 switch 里面的东西就就根据注释写吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\">    NSInteger requestId;</span><br><span class=\"line\">    switch (strategy) &#123;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_ONLY:</span><br><span class=\"line\">        // 调用获取缓存方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_NETWORK_ONLY:</span><br><span class=\"line\">        // 调用获取网络方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_NETWORK_AND_CACHE:</span><br><span class=\"line\">        // 调用网络方法,回调后写入本地缓存</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_ELSE_NETWORK:</span><br><span class=\"line\">        // 调用本地缓存方法,在回调中判断是否有缓存,如果没有的话调用网络方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_THEN_NETWORK:</span><br><span class=\"line\">        // 调用本地方法接着调用网络方法 </span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_AUTOMATICALLY:</span><br><span class=\"line\">         // 调用网络方法,回调中如果返回错误则调用本地缓存方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return requestId;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>统一错误表处理<br>-建立一个plist 文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class=\"line\">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class=\"line\">&lt;dict&gt;</span><br><span class=\"line\">\t&lt;key&gt;-2&lt;/key&gt;</span><br><span class=\"line\">\t&lt;string&gt;网络连接失败&lt;/string&gt;</span><br><span class=\"line\">\t&lt;key&gt;-1&lt;/key&gt;</span><br><span class=\"line\">\t&lt;string&gt;没有缓存&lt;/string&gt;</span><br><span class=\"line\">&lt;/dict&gt;</span><br><span class=\"line\">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>\n<p>一个成员属性加一个方法去调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSDictionary *)errorDic</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!_errorDic) &#123;</span><br><span class=\"line\">        NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;DKError&quot; ofType:@&quot;plist&quot;];</span><br><span class=\"line\">        _errorDic = [NSDictionary dictionaryWithContentsOfFile:path];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _errorDic;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)errorDescriptionWithCode:(NSInteger)code</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSString *codeStr = [NSString stringWithFormat:@&quot;%zd&quot;,code];</span><br><span class=\"line\">    if ([self.errorDic.allKeys containsObject:codeStr]) &#123;</span><br><span class=\"line\">        return self.errorDic[codeStr];</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        NSLog(@&quot;没有定义该类型错误&quot;);</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>包装成宏方便调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define KERROR_RESPONSE(errCode) [DKResponse responseWithErrorOnly:[self errorDescriptionWithCode:errCode] code:errCode]</span><br></pre></td></tr></table></figure>\n<p>3.1 输出一个漂亮的 Log</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *  打印一个漂亮的 log</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param method              请求方法</span><br><span class=\"line\"> *  @param url                 接口地址</span><br><span class=\"line\"> *  @param params              参数</span><br><span class=\"line\"> *  @param response            响应对象</span><br><span class=\"line\"> *  @param showRequestContent  是否显示响应数据</span><br><span class=\"line\"> */</span><br><span class=\"line\">+ (void)logDebugInfoWithMethod:(NSString *)method URL:(NSString *)url params:(NSDictionary *)params response:(DKResponse *)response showRequestContent:(BOOL)showRequestContent;</span><br></pre></td></tr></table></figure>\n<p>里面主要是字符串拼接.要看详细的话就去下载 Demo吧!</p>\n","site":{"data":{}},"excerpt":"<p>网络层方法封装3.1</p>","more":"<p>** 其实很久之前就想写写这个东西,不过因为项目的原因一直没时间去整理出来,所以决定还是分开几天去写完这个东西吧</p>\n<ul>\n<li><p>新增特性:</p>\n<ul>\n<li>3.0<ul>\n<li>多缓存策略</li>\n<li>用宏定义减少代码量</li>\n<li>使用 plist统一错误信息设置</li>\n</ul>\n</li>\n<li>3.1<ul>\n<li>输出一个漂亮的Log</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>先讲讲本地持久化策略的选择</p>\n<ul>\n<li><p>数据量小,单一的时候(比如一个模型数组,数组不大而且模型的成员属性不是很多),可以使用 <code>NSKeyArchive</code> 归档</p>\n</li>\n<li><p><code>NSUserDefault</code> 用于储存用户首选项</p>\n</li>\n<li><p><code>KeyChain</code>储存一些密码之类的东西</p>\n</li>\n<li><p>数据库储存数据量比较大,字段比较多的模型数组</p>\n</li>\n</ul>\n</li>\n<li><p>缓存策略</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_ENUM(NSInteger,DKCacheStrategy)&#123;</span><br><span class=\"line\">    DKCacheStrategy_CACHE_ONLY, // 只从本地取数据</span><br><span class=\"line\">    DKCacheStrategy_NETWORK_ONLY, // 只从网络取数据(不缓存)</span><br><span class=\"line\">    DKCacheStrategy_NETWORK_AND_CACHE, // 从网络取数据后缓存(缓存结束不回调)</span><br><span class=\"line\">    DKCacheStrategy_CACHE_ELSE_NETWORK, // 先取缓存,如果没有数据的话,才从网络取数据</span><br><span class=\"line\">    DKCacheStrategy_CACHE_THEN_NETWORK // 先取缓存,再加载网络数据,网络数据加载完会更新缓存,这个选择会有两次回调</span><br><span class=\"line\">    DKCacheStrategy_AUTOMATIC // 根据当前网络环境自动选择,如果有网络(WIFI/WLAN)就取网络数据,没网络就取缓存数据</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>Demo 说明</p>\n<ul>\n<li>github地址:没有</li>\n<li>下载地址: NetworkDemo</li>\n<li>选择本地持久化方式: <code>YYCache</code>,如果有更适合的缓存机制,那改一改也挺简单</li>\n</ul>\n</li>\n<li><p>方法接口设计</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *  发送HTTP请求</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param method 请求方法,你可以写@&quot;get&quot;或者@&quot;post&quot;(不区分大小写)或者已经定义好的 kGET 或 kPOST</span><br><span class=\"line\"> *  @param strategy  缓存策略</span><br><span class=\"line\"> *  @param header 请求头,可为空</span><br><span class=\"line\"> *  @param params 请求参数,可为空</span><br><span class=\"line\"> *  @param block  返回回调,这个就不要空啦</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @return 请求标示 id 可以用来取消请求</span><br><span class=\"line\"> */</span><br><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n<p>之前两个方法继续保留,在这里就不说明了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)cancelAllRequest;</span><br><span class=\"line\">- (void)cancelRequestWithRequestIds:(NSArray *)requestIds;</span><br></pre></td></tr></table></figure>\n<p>然后写两个内部方法,分别是取缓存和取网络数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - 仅本地</span><br><span class=\"line\">- (NSInteger)requestWithCacheOnlyStrategyWithUrl:(NSString *)URLString params:(NSDictionary *)params requestBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DKResponse *response = (DKResponse *)[self.cache objectForKey:[self cacheKeyForRequestUrl:URLString params:params]];</span><br><span class=\"line\">    if (block) &#123;</span><br><span class=\"line\">        if (response) &#123;</span><br><span class=\"line\">            block(response);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            block(KERROR_RESPONSE(-1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - 仅网络</span><br><span class=\"line\">- (NSInteger)requestWithNetworkOnlyStrategyForMethod:(NSString *)method url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSNumber *taskIdentifier = 0;</span><br><span class=\"line\">    if ([method.uppercaseString isEqualToString:@&quot;GET&quot;]) &#123;</span><br><span class=\"line\">        DKCALLAPI(GET, taskIdentifier);</span><br><span class=\"line\">    &#125;else if([method.uppercaseString isEqualToString:@&quot;POST&quot;])&#123;</span><br><span class=\"line\">        DKCALLAPI(POST, taskIdentifier);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return taskIdentifier.integerValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的宏DKCALLAPI 定义 主要是为了不想写 POST和 GET两个方法,在这里写一次就够了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKCALLAPI(REQUEST_METHOD,REQUEST_ID) \\</span><br><span class=\"line\">&#123;\\</span><br><span class=\"line\">    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\\</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer = mgr.requestSerializer;\\</span><br><span class=\"line\">    if (header) &#123;\\</span><br><span class=\"line\">        [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id obj, BOOL * _Nonnull stop) &#123;\\</span><br><span class=\"line\">            [requestSerializer setValue:obj forHTTPHeaderField:key];\\</span><br><span class=\"line\">        &#125;];\\</span><br><span class=\"line\">    &#125;\\</span><br><span class=\"line\">    requestSerializer.timeoutInterval = kTimeOutInterval;\\</span><br><span class=\"line\">    NSURLSessionTask *task = [mgr REQUEST_METHOD:URLString parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;\\</span><br><span class=\"line\">        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\\</span><br><span class=\"line\">        resp.rawData = responseObject;\\</span><br><span class=\"line\">        resp.taskIdentifier = task.taskIdentifier;\\</span><br><span class=\"line\">        if(block)&#123;\\</span><br><span class=\"line\">            block(resp);\\</span><br><span class=\"line\">        &#125;\\</span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;\\</span><br><span class=\"line\">        DKResponse *resp = [DKResponse responseWithErrorOnly:error.description code:error.code];\\</span><br><span class=\"line\">        if (block) &#123;\\</span><br><span class=\"line\">            block(resp);\\</span><br><span class=\"line\">        &#125;\\</span><br><span class=\"line\">    &#125;];\\</span><br><span class=\"line\">    REQUEST_ID = @(task.taskIdentifier);\\</span><br><span class=\"line\">    [self.dispatchTable setObject:task forKey:REQUEST_ID];\\</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后 就可以实现我们的接口了 switch 里面的东西就就根据注释写吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __weak typeof(self) weakSelf = self;</span><br><span class=\"line\">    NSInteger requestId;</span><br><span class=\"line\">    switch (strategy) &#123;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_ONLY:</span><br><span class=\"line\">        // 调用获取缓存方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_NETWORK_ONLY:</span><br><span class=\"line\">        // 调用获取网络方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_NETWORK_AND_CACHE:</span><br><span class=\"line\">        // 调用网络方法,回调后写入本地缓存</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_ELSE_NETWORK:</span><br><span class=\"line\">        // 调用本地缓存方法,在回调中判断是否有缓存,如果没有的话调用网络方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_THEN_NETWORK:</span><br><span class=\"line\">        // 调用本地方法接着调用网络方法 </span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_AUTOMATICALLY:</span><br><span class=\"line\">         // 调用网络方法,回调中如果返回错误则调用本地缓存方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return requestId;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>统一错误表处理<br>-建立一个plist 文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class=\"line\">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class=\"line\">&lt;dict&gt;</span><br><span class=\"line\">\t&lt;key&gt;-2&lt;/key&gt;</span><br><span class=\"line\">\t&lt;string&gt;网络连接失败&lt;/string&gt;</span><br><span class=\"line\">\t&lt;key&gt;-1&lt;/key&gt;</span><br><span class=\"line\">\t&lt;string&gt;没有缓存&lt;/string&gt;</span><br><span class=\"line\">&lt;/dict&gt;</span><br><span class=\"line\">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>\n<p>一个成员属性加一个方法去调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSDictionary *)errorDic</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!_errorDic) &#123;</span><br><span class=\"line\">        NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;DKError&quot; ofType:@&quot;plist&quot;];</span><br><span class=\"line\">        _errorDic = [NSDictionary dictionaryWithContentsOfFile:path];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _errorDic;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)errorDescriptionWithCode:(NSInteger)code</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSString *codeStr = [NSString stringWithFormat:@&quot;%zd&quot;,code];</span><br><span class=\"line\">    if ([self.errorDic.allKeys containsObject:codeStr]) &#123;</span><br><span class=\"line\">        return self.errorDic[codeStr];</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        NSLog(@&quot;没有定义该类型错误&quot;);</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>包装成宏方便调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define KERROR_RESPONSE(errCode) [DKResponse responseWithErrorOnly:[self errorDescriptionWithCode:errCode] code:errCode]</span><br></pre></td></tr></table></figure>\n<p>3.1 输出一个漂亮的 Log</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *  打印一个漂亮的 log</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param method              请求方法</span><br><span class=\"line\"> *  @param url                 接口地址</span><br><span class=\"line\"> *  @param params              参数</span><br><span class=\"line\"> *  @param response            响应对象</span><br><span class=\"line\"> *  @param showRequestContent  是否显示响应数据</span><br><span class=\"line\"> */</span><br><span class=\"line\">+ (void)logDebugInfoWithMethod:(NSString *)method URL:(NSString *)url params:(NSDictionary *)params response:(DKResponse *)response showRequestContent:(BOOL)showRequestContent;</span><br></pre></td></tr></table></figure>\n<p>里面主要是字符串拼接.要看详细的话就去下载 Demo吧!</p>"},{"title":"网络层方法封装2","author":"Arclin","abbrlink":"89e1dd7e","date":"2016-11-02T16:00:00.000Z","_content":"网络层方法封装2\n\n<!-- more -->\n - 为了便于进行请求的管理，特地对之前的网络层方法封装加以改进，为了就是避免请求发送出去之后就管理不了的问题。\n - 其中最为重要的就是请求的取消\n \n> 当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。-Casa\n\n - 另外还添加了请求头，有需求的话就调用有添加请求头的方法\n\n - 接下来说说改造\n\n   1. 添加单例方法，使用 sharedTool 管理请求\n   2. 改原先的类方法为实例方法，并添加 NSInteger的返回值\n   3. 添加取消请求和取消全部请求的方法\n   4. DKResponse 添加 taskIdentifier（NSInteger）属性\n\n- 声明部分\n\n```\n/** 请求头 */\n@property (nonatomic,strong)  NSDictionary *header;\n\n+ (instancetype)sharedTool;\n\n- (NSInteger)GET:(NSString *)URLString parameters:(id)parameters\nresponseBlock:(DKHTTPResponseBlock)block;\n\n- (NSInteger)POST:(NSString *)URLString parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block;\n```\n\n- 方法实现\n\n```\nstatic DKHTTPTool *_tool;\n\n+ (id)allocWithZone:(struct _NSZone *)zone\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        _tool = [super allocWithZone:zone];\n    });\n    return _tool;\n}\n\n+ (instancetype)sharedTool\n{\n    if (_tool == nil) {\n        _tool = [[DKHTTPTool alloc] init];\n    }\n    return _tool;\n}\n```\n\n- GET请求添加请求头\n\n```\n- (NSInteger)GET:(NSString *)URLString header:(NSDictionary *)header parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block\n{\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n    AFHTTPRequestSerializer *requestSerializer = mgr.requestSerializer;\n    [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        [requestSerializer setValue:obj forHTTPHeaderField:key];\n    }];\n    requestSerializer.timeoutInterval = kTimeOutInterval;\n    NSURLSessionTask *task = [mgr GET:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\n        resp.rawData = responseObject;\n        resp.taskIdentifier = task.taskIdentifier;\n        if(block){\n            block(resp);\n        }\n        \n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        DKResponse *resp = [[DKResponse alloc] init];\n        resp.error = error;\n        if (block) {\n            block(resp);\n        }\n    }];\n    NSNumber *requestId = @(task.taskIdentifier);\n    [self.dispatchTable setObject:task forKey:requestId];\n    return task.taskIdentifier;\n}\n```\n\n- 取消请求\n\n```\n- (void)cancelRequestWithRequestIds:(NSArray *)requestIds\n{\n    for (NSInteger i = 0; i < requestIds.count ; i++) {\n        NSInteger requestId = [requestIds[i] integerValue];\n        NSURLSessionTask *task = [self.dispatchTable objectForKey:@(requestId)];\n        [task cancel];\n        [self.dispatchTable removeObjectForKey:@(requestId)];\n    }\n}\n\n- (void)cancelAllRequest\n{\n    [self.dispatchTable enumerateKeysAndObjectsUsingBlock:^(NSNumber * _Nonnull key, NSURLSessionTask * _Nonnull obj, BOOL * _Nonnull stop) {\n        [obj cancel];\n    }];\n}\n```\n\n- 其他方法\n\n```\n#pragma mark - seter & getter\n- (NSMutableDictionary<NSNumber *,NSURLSessionTask *> *)dispatchTable\n{\n    if (!_dispatchTable) {\n        _dispatchTable = [NSMutableDictionary dictionary];\n    }\n    return _dispatchTable;\n}\n```","source":"_posts/网络层方法封装2.md","raw":"---\ntitle: 网络层方法封装2\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 89e1dd7e\ndate: 2016-11-03 00:00:00\n---\n网络层方法封装2\n\n<!-- more -->\n - 为了便于进行请求的管理，特地对之前的网络层方法封装加以改进，为了就是避免请求发送出去之后就管理不了的问题。\n - 其中最为重要的就是请求的取消\n \n> 当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。-Casa\n\n - 另外还添加了请求头，有需求的话就调用有添加请求头的方法\n\n - 接下来说说改造\n\n   1. 添加单例方法，使用 sharedTool 管理请求\n   2. 改原先的类方法为实例方法，并添加 NSInteger的返回值\n   3. 添加取消请求和取消全部请求的方法\n   4. DKResponse 添加 taskIdentifier（NSInteger）属性\n\n- 声明部分\n\n```\n/** 请求头 */\n@property (nonatomic,strong)  NSDictionary *header;\n\n+ (instancetype)sharedTool;\n\n- (NSInteger)GET:(NSString *)URLString parameters:(id)parameters\nresponseBlock:(DKHTTPResponseBlock)block;\n\n- (NSInteger)POST:(NSString *)URLString parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block;\n```\n\n- 方法实现\n\n```\nstatic DKHTTPTool *_tool;\n\n+ (id)allocWithZone:(struct _NSZone *)zone\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        _tool = [super allocWithZone:zone];\n    });\n    return _tool;\n}\n\n+ (instancetype)sharedTool\n{\n    if (_tool == nil) {\n        _tool = [[DKHTTPTool alloc] init];\n    }\n    return _tool;\n}\n```\n\n- GET请求添加请求头\n\n```\n- (NSInteger)GET:(NSString *)URLString header:(NSDictionary *)header parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block\n{\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n    AFHTTPRequestSerializer *requestSerializer = mgr.requestSerializer;\n    [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        [requestSerializer setValue:obj forHTTPHeaderField:key];\n    }];\n    requestSerializer.timeoutInterval = kTimeOutInterval;\n    NSURLSessionTask *task = [mgr GET:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\n        resp.rawData = responseObject;\n        resp.taskIdentifier = task.taskIdentifier;\n        if(block){\n            block(resp);\n        }\n        \n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        DKResponse *resp = [[DKResponse alloc] init];\n        resp.error = error;\n        if (block) {\n            block(resp);\n        }\n    }];\n    NSNumber *requestId = @(task.taskIdentifier);\n    [self.dispatchTable setObject:task forKey:requestId];\n    return task.taskIdentifier;\n}\n```\n\n- 取消请求\n\n```\n- (void)cancelRequestWithRequestIds:(NSArray *)requestIds\n{\n    for (NSInteger i = 0; i < requestIds.count ; i++) {\n        NSInteger requestId = [requestIds[i] integerValue];\n        NSURLSessionTask *task = [self.dispatchTable objectForKey:@(requestId)];\n        [task cancel];\n        [self.dispatchTable removeObjectForKey:@(requestId)];\n    }\n}\n\n- (void)cancelAllRequest\n{\n    [self.dispatchTable enumerateKeysAndObjectsUsingBlock:^(NSNumber * _Nonnull key, NSURLSessionTask * _Nonnull obj, BOOL * _Nonnull stop) {\n        [obj cancel];\n    }];\n}\n```\n\n- 其他方法\n\n```\n#pragma mark - seter & getter\n- (NSMutableDictionary<NSNumber *,NSURLSessionTask *> *)dispatchTable\n{\n    if (!_dispatchTable) {\n        _dispatchTable = [NSMutableDictionary dictionary];\n    }\n    return _dispatchTable;\n}\n```","slug":"网络层方法封装2","published":1,"updated":"2018-05-10T06:51:35.773Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcn00057ldxuukgndjv4","content":"<p>网络层方法封装2</p>\n<a id=\"more\"></a>\n<ul>\n<li>为了便于进行请求的管理，特地对之前的网络层方法封装加以改进，为了就是避免请求发送出去之后就管理不了的问题。</li>\n<li>其中最为重要的就是请求的取消</li>\n</ul>\n<blockquote>\n<p>当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。-Casa</p>\n</blockquote>\n<ul>\n<li><p>另外还添加了请求头，有需求的话就调用有添加请求头的方法</p>\n</li>\n<li><p>接下来说说改造</p>\n<ol>\n<li>添加单例方法，使用 sharedTool 管理请求</li>\n<li>改原先的类方法为实例方法，并添加 NSInteger的返回值</li>\n<li>添加取消请求和取消全部请求的方法</li>\n<li>DKResponse 添加 taskIdentifier（NSInteger）属性</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>声明部分</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 请求头 */</span><br><span class=\"line\">@property (nonatomic,strong)  NSDictionary *header;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)sharedTool;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSInteger)GET:(NSString *)URLString parameters:(id)parameters</span><br><span class=\"line\">responseBlock:(DKHTTPResponseBlock)block;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSInteger)POST:(NSString *)URLString parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法实现</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static DKHTTPTool *_tool;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (id)allocWithZone:(struct _NSZone *)zone</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        _tool = [super allocWithZone:zone];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return _tool;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)sharedTool</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (_tool == nil) &#123;</span><br><span class=\"line\">        _tool = [[DKHTTPTool alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _tool;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>GET请求添加请求头</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)GET:(NSString *)URLString header:(NSDictionary *)header parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer = mgr.requestSerializer;</span><br><span class=\"line\">    [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [requestSerializer setValue:obj forHTTPHeaderField:key];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    requestSerializer.timeoutInterval = kTimeOutInterval;</span><br><span class=\"line\">    NSURLSessionTask *task = [mgr GET:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];</span><br><span class=\"line\">        resp.rawData = responseObject;</span><br><span class=\"line\">        resp.taskIdentifier = task.taskIdentifier;</span><br><span class=\"line\">        if(block)&#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKResponse *resp = [[DKResponse alloc] init];</span><br><span class=\"line\">        resp.error = error;</span><br><span class=\"line\">        if (block) &#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    NSNumber *requestId = @(task.taskIdentifier);</span><br><span class=\"line\">    [self.dispatchTable setObject:task forKey:requestId];</span><br><span class=\"line\">    return task.taskIdentifier;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>取消请求</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)cancelRequestWithRequestIds:(NSArray *)requestIds</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (NSInteger i = 0; i &lt; requestIds.count ; i++) &#123;</span><br><span class=\"line\">        NSInteger requestId = [requestIds[i] integerValue];</span><br><span class=\"line\">        NSURLSessionTask *task = [self.dispatchTable objectForKey:@(requestId)];</span><br><span class=\"line\">        [task cancel];</span><br><span class=\"line\">        [self.dispatchTable removeObjectForKey:@(requestId)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)cancelAllRequest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.dispatchTable enumerateKeysAndObjectsUsingBlock:^(NSNumber * _Nonnull key, NSURLSessionTask * _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [obj cancel];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>其他方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - seter &amp; getter</span><br><span class=\"line\">- (NSMutableDictionary&lt;NSNumber *,NSURLSessionTask *&gt; *)dispatchTable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!_dispatchTable) &#123;</span><br><span class=\"line\">        _dispatchTable = [NSMutableDictionary dictionary];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _dispatchTable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>网络层方法封装2</p>","more":"<ul>\n<li>为了便于进行请求的管理，特地对之前的网络层方法封装加以改进，为了就是避免请求发送出去之后就管理不了的问题。</li>\n<li>其中最为重要的就是请求的取消</li>\n</ul>\n<blockquote>\n<p>当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。-Casa</p>\n</blockquote>\n<ul>\n<li><p>另外还添加了请求头，有需求的话就调用有添加请求头的方法</p>\n</li>\n<li><p>接下来说说改造</p>\n<ol>\n<li>添加单例方法，使用 sharedTool 管理请求</li>\n<li>改原先的类方法为实例方法，并添加 NSInteger的返回值</li>\n<li>添加取消请求和取消全部请求的方法</li>\n<li>DKResponse 添加 taskIdentifier（NSInteger）属性</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>声明部分</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 请求头 */</span><br><span class=\"line\">@property (nonatomic,strong)  NSDictionary *header;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)sharedTool;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSInteger)GET:(NSString *)URLString parameters:(id)parameters</span><br><span class=\"line\">responseBlock:(DKHTTPResponseBlock)block;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSInteger)POST:(NSString *)URLString parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法实现</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static DKHTTPTool *_tool;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (id)allocWithZone:(struct _NSZone *)zone</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        _tool = [super allocWithZone:zone];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return _tool;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)sharedTool</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (_tool == nil) &#123;</span><br><span class=\"line\">        _tool = [[DKHTTPTool alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _tool;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>GET请求添加请求头</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)GET:(NSString *)URLString header:(NSDictionary *)header parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer = mgr.requestSerializer;</span><br><span class=\"line\">    [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [requestSerializer setValue:obj forHTTPHeaderField:key];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    requestSerializer.timeoutInterval = kTimeOutInterval;</span><br><span class=\"line\">    NSURLSessionTask *task = [mgr GET:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];</span><br><span class=\"line\">        resp.rawData = responseObject;</span><br><span class=\"line\">        resp.taskIdentifier = task.taskIdentifier;</span><br><span class=\"line\">        if(block)&#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKResponse *resp = [[DKResponse alloc] init];</span><br><span class=\"line\">        resp.error = error;</span><br><span class=\"line\">        if (block) &#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    NSNumber *requestId = @(task.taskIdentifier);</span><br><span class=\"line\">    [self.dispatchTable setObject:task forKey:requestId];</span><br><span class=\"line\">    return task.taskIdentifier;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>取消请求</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)cancelRequestWithRequestIds:(NSArray *)requestIds</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (NSInteger i = 0; i &lt; requestIds.count ; i++) &#123;</span><br><span class=\"line\">        NSInteger requestId = [requestIds[i] integerValue];</span><br><span class=\"line\">        NSURLSessionTask *task = [self.dispatchTable objectForKey:@(requestId)];</span><br><span class=\"line\">        [task cancel];</span><br><span class=\"line\">        [self.dispatchTable removeObjectForKey:@(requestId)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)cancelAllRequest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.dispatchTable enumerateKeysAndObjectsUsingBlock:^(NSNumber * _Nonnull key, NSURLSessionTask * _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [obj cancel];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>其他方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - seter &amp; getter</span><br><span class=\"line\">- (NSMutableDictionary&lt;NSNumber *,NSURLSessionTask *&gt; *)dispatchTable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!_dispatchTable) &#123;</span><br><span class=\"line\">        _dispatchTable = [NSMutableDictionary dictionary];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _dispatchTable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"网络层方法封装4","author":"Arclin","abbrlink":"6082784b","date":"2016-12-14T16:00:00.000Z","_content":"网络层方法封装4\n<!-- more -->\n\n- 新增特性:\n   - 拦截器和验证器\n   - 封装请求对象\n   \n1. 说明\n\n  拦截器顾名思义就是在请求发送之前拦截请求，拦截到的请求可以进行修改之后进行发送，或者阻止请求的发送。可以用于添加分页参数之类的需求。\n\n  验证器指的是验证参数（验证结果的方法后面再补充），验证参数主要用于判断输入参数的合法性，如果验证不通过则可以返回一个错误信息，由请求方法抛出错误，如果验证通过那就返回一个 nil就可以了。\n\n2. 代码\n\n  先说说请求对象模型\n\n  ```\n  @interface DKRequest : NSObject\n\n  /** 请求地址 */\n  @property (nonatomic,copy) NSString * urlStr;\n\n  /** 请求方法 */\n  @property (nonatomic,copy) NSString * method;\n\n  /** 请求参数 */\n  @property (nonatomic,strong) NSDictionary *params;\n\n  /** 请求头 */\n  @property (nonatomic,strong) NSDictionary *header;\n\n  /** 缓存策略 */\n  @property (nonatomic,assign) DKCacheStrategy cacheStrategy;\n\n  /** 请求回调 */\n  @property (nonatomic,copy) DKHTTPResponseBlock responseBlock;\n\n  + (instancetype)requestWithUrlStr:(NSString *)urlStr method:(NSString *)method header:(NSDictionary *)header params:(NSDictionary *)params strategy:(DKCacheStrategy)strategy;\n  @end\n  ```\n\n  完整的接口示例\n\n  ```\n  /**\n   发送HTTP请求\n\n   @param method 请求方法,你可以写@\"get\"或者@\"post\"(不区分大小写)或者已经定义好的 kGET 或 kPOST\n   @param strategy 缓存策略\n   @param URLString 请求地址\n   @param header 请求头,可为空\n   @param params 请求参数,可为空\n   @param filterBlock  拦截器\n   @param verifyBlock 验证参数\n   @param block 回调\n   @return 请求 Id\n   */\n  - (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params filter:(DKHTTPRequestFilterBlock)filterBlock verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock responseBlock:(DKHTTPResponseBlock)block;\n  ```\n\n  拦截器的 block\n  给你一个对象，你可以修改这个对象然后返回回去\n\n  ```\n  typedef DKRequest *(^DKHTTPRequestFilterBlock)(DKRequest *request);\n  ```\n\n  验证器的 block\n  给你参数，验证参数后你可以返回一个验证不通过的错误信息，也可以返回空表示验证通过\n\n  ```\n  typedef NSString *(^DKHTTPParamsVarifyBlock)(NSDictionary *params);\n  ```\n\n3. 关于验证参数\n\n\t如果只是想单纯地验证参数是否是全部不为空(这里指空字符串，并不是nil,因为nil根本插不进字典)，那这里也提供了一个宏可以快速实现。\n    ```\n    /** 验证参数是否全部不为空 有空值的话会返回错误 */\n    @property (nonatomic,copy) DKHTTPParamsVarifyBlock verifyIsAllNonNullBlock;\n    ```\n  \n4. 关于过滤（验证）响应体\n  过滤响应体主要是为了防止错误的数据传回到 Service层，比如一些JSON 串解析后会传回 NSNull之类的恶心东西，如果误当做字符串操作的话会导致程序崩溃。不过因为 MJExtension 框架里面已经做了之类的处理，所以如果使用了MJExtension 框架的话，一般来说是不会出现问题，所以这个过滤方法作为单例的成员属性加入,设计为全局作用！\n  传给你一个 DKResponse, 你可以经过处理之后返回一个想要的 DKResponse\n\n  ```\n  /** 过滤响应体 */\n  @property (nonatomic,copy) DKHTTPResultFilterBlock resultFilterBlock;\n  ```\n\n今天逼哥放我假，所以我就写了这个.就这样子,demo我还是放在这里\n\n","source":"_posts/网络层方法封装4.md","raw":"---\ntitle: 网络层方法封装4\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 6082784b\ndate: 2016-12-15 00:00:00\n---\n网络层方法封装4\n<!-- more -->\n\n- 新增特性:\n   - 拦截器和验证器\n   - 封装请求对象\n   \n1. 说明\n\n  拦截器顾名思义就是在请求发送之前拦截请求，拦截到的请求可以进行修改之后进行发送，或者阻止请求的发送。可以用于添加分页参数之类的需求。\n\n  验证器指的是验证参数（验证结果的方法后面再补充），验证参数主要用于判断输入参数的合法性，如果验证不通过则可以返回一个错误信息，由请求方法抛出错误，如果验证通过那就返回一个 nil就可以了。\n\n2. 代码\n\n  先说说请求对象模型\n\n  ```\n  @interface DKRequest : NSObject\n\n  /** 请求地址 */\n  @property (nonatomic,copy) NSString * urlStr;\n\n  /** 请求方法 */\n  @property (nonatomic,copy) NSString * method;\n\n  /** 请求参数 */\n  @property (nonatomic,strong) NSDictionary *params;\n\n  /** 请求头 */\n  @property (nonatomic,strong) NSDictionary *header;\n\n  /** 缓存策略 */\n  @property (nonatomic,assign) DKCacheStrategy cacheStrategy;\n\n  /** 请求回调 */\n  @property (nonatomic,copy) DKHTTPResponseBlock responseBlock;\n\n  + (instancetype)requestWithUrlStr:(NSString *)urlStr method:(NSString *)method header:(NSDictionary *)header params:(NSDictionary *)params strategy:(DKCacheStrategy)strategy;\n  @end\n  ```\n\n  完整的接口示例\n\n  ```\n  /**\n   发送HTTP请求\n\n   @param method 请求方法,你可以写@\"get\"或者@\"post\"(不区分大小写)或者已经定义好的 kGET 或 kPOST\n   @param strategy 缓存策略\n   @param URLString 请求地址\n   @param header 请求头,可为空\n   @param params 请求参数,可为空\n   @param filterBlock  拦截器\n   @param verifyBlock 验证参数\n   @param block 回调\n   @return 请求 Id\n   */\n  - (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params filter:(DKHTTPRequestFilterBlock)filterBlock verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock responseBlock:(DKHTTPResponseBlock)block;\n  ```\n\n  拦截器的 block\n  给你一个对象，你可以修改这个对象然后返回回去\n\n  ```\n  typedef DKRequest *(^DKHTTPRequestFilterBlock)(DKRequest *request);\n  ```\n\n  验证器的 block\n  给你参数，验证参数后你可以返回一个验证不通过的错误信息，也可以返回空表示验证通过\n\n  ```\n  typedef NSString *(^DKHTTPParamsVarifyBlock)(NSDictionary *params);\n  ```\n\n3. 关于验证参数\n\n\t如果只是想单纯地验证参数是否是全部不为空(这里指空字符串，并不是nil,因为nil根本插不进字典)，那这里也提供了一个宏可以快速实现。\n    ```\n    /** 验证参数是否全部不为空 有空值的话会返回错误 */\n    @property (nonatomic,copy) DKHTTPParamsVarifyBlock verifyIsAllNonNullBlock;\n    ```\n  \n4. 关于过滤（验证）响应体\n  过滤响应体主要是为了防止错误的数据传回到 Service层，比如一些JSON 串解析后会传回 NSNull之类的恶心东西，如果误当做字符串操作的话会导致程序崩溃。不过因为 MJExtension 框架里面已经做了之类的处理，所以如果使用了MJExtension 框架的话，一般来说是不会出现问题，所以这个过滤方法作为单例的成员属性加入,设计为全局作用！\n  传给你一个 DKResponse, 你可以经过处理之后返回一个想要的 DKResponse\n\n  ```\n  /** 过滤响应体 */\n  @property (nonatomic,copy) DKHTTPResultFilterBlock resultFilterBlock;\n  ```\n\n今天逼哥放我假，所以我就写了这个.就这样子,demo我还是放在这里\n\n","slug":"网络层方法封装4","published":1,"updated":"2018-05-10T06:51:35.774Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcn3005bldxu3yzhu4qk","content":"<p>网络层方法封装4<br><a id=\"more\"></a></p>\n<ul>\n<li>新增特性:<ul>\n<li>拦截器和验证器</li>\n<li>封装请求对象</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>说明</p>\n<p>拦截器顾名思义就是在请求发送之前拦截请求，拦截到的请求可以进行修改之后进行发送，或者阻止请求的发送。可以用于添加分页参数之类的需求。</p>\n<p>验证器指的是验证参数（验证结果的方法后面再补充），验证参数主要用于判断输入参数的合法性，如果验证不通过则可以返回一个错误信息，由请求方法抛出错误，如果验证通过那就返回一个 nil就可以了。</p>\n</li>\n<li><p>代码</p>\n<p>先说说请求对象模型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface DKRequest : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">/** 请求地址 */</span><br><span class=\"line\">@property (nonatomic,copy) NSString * urlStr;</span><br><span class=\"line\"></span><br><span class=\"line\">/** 请求方法 */</span><br><span class=\"line\">@property (nonatomic,copy) NSString * method;</span><br><span class=\"line\"></span><br><span class=\"line\">/** 请求参数 */</span><br><span class=\"line\">@property (nonatomic,strong) NSDictionary *params;</span><br><span class=\"line\"></span><br><span class=\"line\">/** 请求头 */</span><br><span class=\"line\">@property (nonatomic,strong) NSDictionary *header;</span><br><span class=\"line\"></span><br><span class=\"line\">/** 缓存策略 */</span><br><span class=\"line\">@property (nonatomic,assign) DKCacheStrategy cacheStrategy;</span><br><span class=\"line\"></span><br><span class=\"line\">/** 请求回调 */</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPResponseBlock responseBlock;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)requestWithUrlStr:(NSString *)urlStr method:(NSString *)method header:(NSDictionary *)header params:(NSDictionary *)params strategy:(DKCacheStrategy)strategy;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>完整的接口示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> 发送HTTP请求</span><br><span class=\"line\"></span><br><span class=\"line\"> @param method 请求方法,你可以写@&quot;get&quot;或者@&quot;post&quot;(不区分大小写)或者已经定义好的 kGET 或 kPOST</span><br><span class=\"line\"> @param strategy 缓存策略</span><br><span class=\"line\"> @param URLString 请求地址</span><br><span class=\"line\"> @param header 请求头,可为空</span><br><span class=\"line\"> @param params 请求参数,可为空</span><br><span class=\"line\"> @param filterBlock  拦截器</span><br><span class=\"line\"> @param verifyBlock 验证参数</span><br><span class=\"line\"> @param block 回调</span><br><span class=\"line\"> @return 请求 Id</span><br><span class=\"line\"> */</span><br><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params filter:(DKHTTPRequestFilterBlock)filterBlock verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n<p>拦截器的 block<br>给你一个对象，你可以修改这个对象然后返回回去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef DKRequest *(^DKHTTPRequestFilterBlock)(DKRequest *request);</span><br></pre></td></tr></table></figure>\n<p>验证器的 block<br>给你参数，验证参数后你可以返回一个验证不通过的错误信息，也可以返回空表示验证通过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NSString *(^DKHTTPParamsVarifyBlock)(NSDictionary *params);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>关于验证参数</p>\n<p> 如果只是想单纯地验证参数是否是全部不为空(这里指空字符串，并不是nil,因为nil根本插不进字典)，那这里也提供了一个宏可以快速实现。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 验证参数是否全部不为空 有空值的话会返回错误 */</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPParamsVarifyBlock verifyIsAllNonNullBlock;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>关于过滤（验证）响应体<br>过滤响应体主要是为了防止错误的数据传回到 Service层，比如一些JSON 串解析后会传回 NSNull之类的恶心东西，如果误当做字符串操作的话会导致程序崩溃。不过因为 MJExtension 框架里面已经做了之类的处理，所以如果使用了MJExtension 框架的话，一般来说是不会出现问题，所以这个过滤方法作为单例的成员属性加入,设计为全局作用！<br>传给你一个 DKResponse, 你可以经过处理之后返回一个想要的 DKResponse</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 过滤响应体 */</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPResultFilterBlock resultFilterBlock;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>今天逼哥放我假，所以我就写了这个.就这样子,demo我还是放在这里</p>\n","site":{"data":{}},"excerpt":"<p>网络层方法封装4<br>","more":"</p>\n<ul>\n<li>新增特性:<ul>\n<li>拦截器和验证器</li>\n<li>封装请求对象</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li><p>说明</p>\n<p>拦截器顾名思义就是在请求发送之前拦截请求，拦截到的请求可以进行修改之后进行发送，或者阻止请求的发送。可以用于添加分页参数之类的需求。</p>\n<p>验证器指的是验证参数（验证结果的方法后面再补充），验证参数主要用于判断输入参数的合法性，如果验证不通过则可以返回一个错误信息，由请求方法抛出错误，如果验证通过那就返回一个 nil就可以了。</p>\n</li>\n<li><p>代码</p>\n<p>先说说请求对象模型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface DKRequest : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">/** 请求地址 */</span><br><span class=\"line\">@property (nonatomic,copy) NSString * urlStr;</span><br><span class=\"line\"></span><br><span class=\"line\">/** 请求方法 */</span><br><span class=\"line\">@property (nonatomic,copy) NSString * method;</span><br><span class=\"line\"></span><br><span class=\"line\">/** 请求参数 */</span><br><span class=\"line\">@property (nonatomic,strong) NSDictionary *params;</span><br><span class=\"line\"></span><br><span class=\"line\">/** 请求头 */</span><br><span class=\"line\">@property (nonatomic,strong) NSDictionary *header;</span><br><span class=\"line\"></span><br><span class=\"line\">/** 缓存策略 */</span><br><span class=\"line\">@property (nonatomic,assign) DKCacheStrategy cacheStrategy;</span><br><span class=\"line\"></span><br><span class=\"line\">/** 请求回调 */</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPResponseBlock responseBlock;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)requestWithUrlStr:(NSString *)urlStr method:(NSString *)method header:(NSDictionary *)header params:(NSDictionary *)params strategy:(DKCacheStrategy)strategy;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>完整的接口示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> 发送HTTP请求</span><br><span class=\"line\"></span><br><span class=\"line\"> @param method 请求方法,你可以写@&quot;get&quot;或者@&quot;post&quot;(不区分大小写)或者已经定义好的 kGET 或 kPOST</span><br><span class=\"line\"> @param strategy 缓存策略</span><br><span class=\"line\"> @param URLString 请求地址</span><br><span class=\"line\"> @param header 请求头,可为空</span><br><span class=\"line\"> @param params 请求参数,可为空</span><br><span class=\"line\"> @param filterBlock  拦截器</span><br><span class=\"line\"> @param verifyBlock 验证参数</span><br><span class=\"line\"> @param block 回调</span><br><span class=\"line\"> @return 请求 Id</span><br><span class=\"line\"> */</span><br><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params filter:(DKHTTPRequestFilterBlock)filterBlock verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n<p>拦截器的 block<br>给你一个对象，你可以修改这个对象然后返回回去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef DKRequest *(^DKHTTPRequestFilterBlock)(DKRequest *request);</span><br></pre></td></tr></table></figure>\n<p>验证器的 block<br>给你参数，验证参数后你可以返回一个验证不通过的错误信息，也可以返回空表示验证通过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NSString *(^DKHTTPParamsVarifyBlock)(NSDictionary *params);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>关于验证参数</p>\n<p> 如果只是想单纯地验证参数是否是全部不为空(这里指空字符串，并不是nil,因为nil根本插不进字典)，那这里也提供了一个宏可以快速实现。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 验证参数是否全部不为空 有空值的话会返回错误 */</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPParamsVarifyBlock verifyIsAllNonNullBlock;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>关于过滤（验证）响应体<br>过滤响应体主要是为了防止错误的数据传回到 Service层，比如一些JSON 串解析后会传回 NSNull之类的恶心东西，如果误当做字符串操作的话会导致程序崩溃。不过因为 MJExtension 框架里面已经做了之类的处理，所以如果使用了MJExtension 框架的话，一般来说是不会出现问题，所以这个过滤方法作为单例的成员属性加入,设计为全局作用！<br>传给你一个 DKResponse, 你可以经过处理之后返回一个想要的 DKResponse</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** 过滤响应体 */</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPResultFilterBlock resultFilterBlock;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>今天逼哥放我假，所以我就写了这个.就这样子,demo我还是放在这里</p>"},{"title":"网络层方法封装5","author":"Arclin","abbrlink":"178548dd","date":"2016-12-14T19:00:00.000Z","_content":"网络层方法封装5.2.1\n\n- 特性\n\t- 添加链式调用方法\n- 5.1\n\t- 开启/关闭 Log\n\t- 自定义 Logger\n\t- RAC支持\n- 5.2.1\n\t- 修复了一些 bug\n\t- 由于服务器异常而返回的 NSData 转为 HTML 页面并展示出来（需要打开 DebugMode）\n\t- 把链式调用方法抽出为一个 DKHTTPChainTool 类\n    \n<!-- more -->\n    \n1. 添加链式调用方法\n\n链式调用的好处就是要啥参数就添加啥,方便快捷,不用担心代码不够漂亮！\n\n```\n#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]\n\n/** 链式调用 */\n- (DKHTTPChainTool * (^)(NSString *method))method;\n- (DKHTTPChainTool * (^)(NSString *url))url;\n- (DKHTTPChainTool * (^)(NSDictionary *header))header;\n- (DKHTTPChainTool * (^)(DKCacheStrategy strategy))cacheStrategy;\n- (DKHTTPChainTool * (^)(DKHTTPParamsVarifyBlock paramsVerify))verifyParams;\n- (DKHTTPChainTool * (^)(DKHTTPRequestFilterBlock resultFilter))requestFilter;\n- (DKHTTPChainTool * (^)(NSDictionary *params))params;\n/** block返回请求Id */\n- (NSInteger (^)(DKHTTPResponseBlock responseBlock))execute;\n```\n\n使用起来感觉是这样子的\n\n```\nDKHTTPChainInstance.method(@\"POST\")\n           .url(@\"\")\n           .params(@{@\"account\":@\"m13643046965@163.com\",@\"password\":@\"123456\"})\n           .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)\n           .verifyParams(^NSString *(NSDictionary *params){\n               return nil;\n           })\n           .requestFilter(^DKRequest *(DKRequest *request){\n               return request;\n           })\n           .execute(^(DKResponse *response){\n               NSLog(@\"%@\",response.rawData);\n           });\n```\n\n- 5.1\n\n开启/关闭 Log\n\n```\nDKHTTPSharedTool.showLog = YES/NO;\n```\n\n自定义 Logger\n\n```\n#define DKLog(...) NSLog(@\"%s %zd行 %@\",__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])\n\n[DKHTTPTool setLogger:^(NSString *msg) {\n  DKLog(@\"%@\",msg);\n}];\n```\n\nRAC支持\n\n```\n- (RACSignal *(^)())executeSignal;\n```\n\n使用\n```\nRACSignal *signal = DKHTTPChainInstance.method(@\"POST\")\n                                        .url()\n                                        .header(@{@\"token\":@\"0e83179ac83741416e50b0ea12113f6e\"})\n                                        .params(@{@\"account\":@\"\",@\"password\":@\"123456\"})\n                                        .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)\n                                        .verifyParams(^NSString *(NSDictionary *params){\n                                        return nil;\n                                        })\n                                      .requestFilter(^DKRequest *(DKRequest *request){\n                                        return request;\n                                        })\n                                      .executeSignal();\n[signal subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n}];\n```\n\n- 5.2.1\n\n1.DKHTTPTool的链式调用\n\n```\n#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]\n```\n\n使用方法和上面说的一样\n\n2.调试模式\n\n```\nDKHTTPSharedTool.debugMode = YES; // 开启 Log 和 服务器异常弹窗\n如果服务器发生异常，那么就会发生如图情况\n```\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/555.png?raw=true)\n![](https://github.com/Arc-lin/BlogImage/blob/master/666.png?raw=true)\n![](https://github.com/Arc-lin/BlogImage/blob/master/777.png?raw=true)\n\n\n","source":"_posts/网络层方法封装5.md","raw":"---\ntitle: 网络层方法封装5\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 178548dd\ndate: 2016-12-15 03:00:00\n---\n网络层方法封装5.2.1\n\n- 特性\n\t- 添加链式调用方法\n- 5.1\n\t- 开启/关闭 Log\n\t- 自定义 Logger\n\t- RAC支持\n- 5.2.1\n\t- 修复了一些 bug\n\t- 由于服务器异常而返回的 NSData 转为 HTML 页面并展示出来（需要打开 DebugMode）\n\t- 把链式调用方法抽出为一个 DKHTTPChainTool 类\n    \n<!-- more -->\n    \n1. 添加链式调用方法\n\n链式调用的好处就是要啥参数就添加啥,方便快捷,不用担心代码不够漂亮！\n\n```\n#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]\n\n/** 链式调用 */\n- (DKHTTPChainTool * (^)(NSString *method))method;\n- (DKHTTPChainTool * (^)(NSString *url))url;\n- (DKHTTPChainTool * (^)(NSDictionary *header))header;\n- (DKHTTPChainTool * (^)(DKCacheStrategy strategy))cacheStrategy;\n- (DKHTTPChainTool * (^)(DKHTTPParamsVarifyBlock paramsVerify))verifyParams;\n- (DKHTTPChainTool * (^)(DKHTTPRequestFilterBlock resultFilter))requestFilter;\n- (DKHTTPChainTool * (^)(NSDictionary *params))params;\n/** block返回请求Id */\n- (NSInteger (^)(DKHTTPResponseBlock responseBlock))execute;\n```\n\n使用起来感觉是这样子的\n\n```\nDKHTTPChainInstance.method(@\"POST\")\n           .url(@\"\")\n           .params(@{@\"account\":@\"m13643046965@163.com\",@\"password\":@\"123456\"})\n           .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)\n           .verifyParams(^NSString *(NSDictionary *params){\n               return nil;\n           })\n           .requestFilter(^DKRequest *(DKRequest *request){\n               return request;\n           })\n           .execute(^(DKResponse *response){\n               NSLog(@\"%@\",response.rawData);\n           });\n```\n\n- 5.1\n\n开启/关闭 Log\n\n```\nDKHTTPSharedTool.showLog = YES/NO;\n```\n\n自定义 Logger\n\n```\n#define DKLog(...) NSLog(@\"%s %zd行 %@\",__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])\n\n[DKHTTPTool setLogger:^(NSString *msg) {\n  DKLog(@\"%@\",msg);\n}];\n```\n\nRAC支持\n\n```\n- (RACSignal *(^)())executeSignal;\n```\n\n使用\n```\nRACSignal *signal = DKHTTPChainInstance.method(@\"POST\")\n                                        .url()\n                                        .header(@{@\"token\":@\"0e83179ac83741416e50b0ea12113f6e\"})\n                                        .params(@{@\"account\":@\"\",@\"password\":@\"123456\"})\n                                        .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)\n                                        .verifyParams(^NSString *(NSDictionary *params){\n                                        return nil;\n                                        })\n                                      .requestFilter(^DKRequest *(DKRequest *request){\n                                        return request;\n                                        })\n                                      .executeSignal();\n[signal subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n}];\n```\n\n- 5.2.1\n\n1.DKHTTPTool的链式调用\n\n```\n#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]\n```\n\n使用方法和上面说的一样\n\n2.调试模式\n\n```\nDKHTTPSharedTool.debugMode = YES; // 开启 Log 和 服务器异常弹窗\n如果服务器发生异常，那么就会发生如图情况\n```\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/555.png?raw=true)\n![](https://github.com/Arc-lin/BlogImage/blob/master/666.png?raw=true)\n![](https://github.com/Arc-lin/BlogImage/blob/master/777.png?raw=true)\n\n\n","slug":"网络层方法封装5","published":1,"updated":"2018-05-10T06:51:35.775Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcn6005eldxuc1qq4tll","content":"<p>网络层方法封装5.2.1</p>\n<ul>\n<li>特性<ul>\n<li>添加链式调用方法</li>\n</ul>\n</li>\n<li>5.1<ul>\n<li>开启/关闭 Log</li>\n<li>自定义 Logger</li>\n<li>RAC支持</li>\n</ul>\n</li>\n<li>5.2.1<ul>\n<li>修复了一些 bug</li>\n<li>由于服务器异常而返回的 NSData 转为 HTML 页面并展示出来（需要打开 DebugMode）</li>\n<li>把链式调用方法抽出为一个 DKHTTPChainTool 类</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ol>\n<li>添加链式调用方法</li>\n</ol>\n<p>链式调用的好处就是要啥参数就添加啥,方便快捷,不用担心代码不够漂亮！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]</span><br><span class=\"line\"></span><br><span class=\"line\">/** 链式调用 */</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSString *method))method;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSString *url))url;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSDictionary *header))header;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKCacheStrategy strategy))cacheStrategy;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKHTTPParamsVarifyBlock paramsVerify))verifyParams;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKHTTPRequestFilterBlock resultFilter))requestFilter;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSDictionary *params))params;</span><br><span class=\"line\">/** block返回请求Id */</span><br><span class=\"line\">- (NSInteger (^)(DKHTTPResponseBlock responseBlock))execute;</span><br></pre></td></tr></table></figure>\n<p>使用起来感觉是这样子的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">           .url(@&quot;&quot;)</span><br><span class=\"line\">           .params(@&#123;@&quot;account&quot;:@&quot;m13643046965@163.com&quot;,@&quot;password&quot;:@&quot;123456&quot;&#125;)</span><br><span class=\"line\">           .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)</span><br><span class=\"line\">           .verifyParams(^NSString *(NSDictionary *params)&#123;</span><br><span class=\"line\">               return nil;</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">           .requestFilter(^DKRequest *(DKRequest *request)&#123;</span><br><span class=\"line\">               return request;</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">           .execute(^(DKResponse *response)&#123;</span><br><span class=\"line\">               NSLog(@&quot;%@&quot;,response.rawData);</span><br><span class=\"line\">           &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>5.1</li>\n</ul>\n<p>开启/关闭 Log</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPSharedTool.showLog = YES/NO;</span><br></pre></td></tr></table></figure>\n<p>自定义 Logger</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKLog(...) NSLog(@&quot;%s %zd行 %@&quot;,__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])</span><br><span class=\"line\"></span><br><span class=\"line\">[DKHTTPTool setLogger:^(NSString *msg) &#123;</span><br><span class=\"line\">  DKLog(@&quot;%@&quot;,msg);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>RAC支持</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (RACSignal *(^)())executeSignal;</span><br></pre></td></tr></table></figure>\n<p>使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *signal = DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url()</span><br><span class=\"line\">                                        .header(@&#123;@&quot;token&quot;:@&quot;0e83179ac83741416e50b0ea12113f6e&quot;&#125;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;account&quot;:@&quot;&quot;,@&quot;password&quot;:@&quot;123456&quot;&#125;)</span><br><span class=\"line\">                                        .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)</span><br><span class=\"line\">                                        .verifyParams(^NSString *(NSDictionary *params)&#123;</span><br><span class=\"line\">                                        return nil;</span><br><span class=\"line\">                                        &#125;)</span><br><span class=\"line\">                                      .requestFilter(^DKRequest *(DKRequest *request)&#123;</span><br><span class=\"line\">                                        return request;</span><br><span class=\"line\">                                        &#125;)</span><br><span class=\"line\">                                      .executeSignal();</span><br><span class=\"line\">[signal subscribeNext:^(id x) &#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>5.2.1</li>\n</ul>\n<p>1.DKHTTPTool的链式调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]</span><br></pre></td></tr></table></figure>\n<p>使用方法和上面说的一样</p>\n<p>2.调试模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPSharedTool.debugMode = YES; // 开启 Log 和 服务器异常弹窗</span><br><span class=\"line\">如果服务器发生异常，那么就会发生如图情况</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/555.png?raw=true\" alt=\"\"><br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/666.png?raw=true\" alt=\"\"><br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/777.png?raw=true\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>网络层方法封装5.2.1</p>\n<ul>\n<li>特性<ul>\n<li>添加链式调用方法</li>\n</ul>\n</li>\n<li>5.1<ul>\n<li>开启/关闭 Log</li>\n<li>自定义 Logger</li>\n<li>RAC支持</li>\n</ul>\n</li>\n<li>5.2.1<ul>\n<li>修复了一些 bug</li>\n<li>由于服务器异常而返回的 NSData 转为 HTML 页面并展示出来（需要打开 DebugMode）</li>\n<li>把链式调用方法抽出为一个 DKHTTPChainTool 类</li>\n</ul>\n</li>\n</ul>","more":"<ol>\n<li>添加链式调用方法</li>\n</ol>\n<p>链式调用的好处就是要啥参数就添加啥,方便快捷,不用担心代码不够漂亮！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]</span><br><span class=\"line\"></span><br><span class=\"line\">/** 链式调用 */</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSString *method))method;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSString *url))url;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSDictionary *header))header;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKCacheStrategy strategy))cacheStrategy;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKHTTPParamsVarifyBlock paramsVerify))verifyParams;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKHTTPRequestFilterBlock resultFilter))requestFilter;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSDictionary *params))params;</span><br><span class=\"line\">/** block返回请求Id */</span><br><span class=\"line\">- (NSInteger (^)(DKHTTPResponseBlock responseBlock))execute;</span><br></pre></td></tr></table></figure>\n<p>使用起来感觉是这样子的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">           .url(@&quot;&quot;)</span><br><span class=\"line\">           .params(@&#123;@&quot;account&quot;:@&quot;m13643046965@163.com&quot;,@&quot;password&quot;:@&quot;123456&quot;&#125;)</span><br><span class=\"line\">           .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)</span><br><span class=\"line\">           .verifyParams(^NSString *(NSDictionary *params)&#123;</span><br><span class=\"line\">               return nil;</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">           .requestFilter(^DKRequest *(DKRequest *request)&#123;</span><br><span class=\"line\">               return request;</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">           .execute(^(DKResponse *response)&#123;</span><br><span class=\"line\">               NSLog(@&quot;%@&quot;,response.rawData);</span><br><span class=\"line\">           &#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>5.1</li>\n</ul>\n<p>开启/关闭 Log</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPSharedTool.showLog = YES/NO;</span><br></pre></td></tr></table></figure>\n<p>自定义 Logger</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKLog(...) NSLog(@&quot;%s %zd行 %@&quot;,__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])</span><br><span class=\"line\"></span><br><span class=\"line\">[DKHTTPTool setLogger:^(NSString *msg) &#123;</span><br><span class=\"line\">  DKLog(@&quot;%@&quot;,msg);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>RAC支持</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (RACSignal *(^)())executeSignal;</span><br></pre></td></tr></table></figure>\n<p>使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *signal = DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url()</span><br><span class=\"line\">                                        .header(@&#123;@&quot;token&quot;:@&quot;0e83179ac83741416e50b0ea12113f6e&quot;&#125;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;account&quot;:@&quot;&quot;,@&quot;password&quot;:@&quot;123456&quot;&#125;)</span><br><span class=\"line\">                                        .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)</span><br><span class=\"line\">                                        .verifyParams(^NSString *(NSDictionary *params)&#123;</span><br><span class=\"line\">                                        return nil;</span><br><span class=\"line\">                                        &#125;)</span><br><span class=\"line\">                                      .requestFilter(^DKRequest *(DKRequest *request)&#123;</span><br><span class=\"line\">                                        return request;</span><br><span class=\"line\">                                        &#125;)</span><br><span class=\"line\">                                      .executeSignal();</span><br><span class=\"line\">[signal subscribeNext:^(id x) &#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>5.2.1</li>\n</ul>\n<p>1.DKHTTPTool的链式调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]</span><br></pre></td></tr></table></figure>\n<p>使用方法和上面说的一样</p>\n<p>2.调试模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPSharedTool.debugMode = YES; // 开启 Log 和 服务器异常弹窗</span><br><span class=\"line\">如果服务器发生异常，那么就会发生如图情况</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/555.png?raw=true\" alt=\"\"><br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/666.png?raw=true\" alt=\"\"><br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/777.png?raw=true\" alt=\"\"></p>"},{"title":"记录一些关于iOS的一些小技巧","author":"Arclin","abbrlink":"1b8f24c7","date":"2016-06-11T16:30:00.000Z","_content":"记录一些关于iOS的一些小技巧\n\n<!-- more -->\n\nXCode Profile 的路径\nxcode5 provisioning profile path： \n`~/Library/MobileDevice/Provisioning Profiles`\n\n在升级XCode7.0使用UICollectionViewLayout进行自定义布局时，调试台会出现以下的警告打印。\n\n```\nUICollectionViewFlowLayout has cached frame mismatch for index path {length = 2, path = 0 - 0} - cached value: {{122, 15}, {170, 170}}; expected value: {{157, 50}, {100, 100}} \nThis is likely occurring because the flow layout subclass LineLayout is modifying attributes returned by UICollectionViewFlowLayout without copying them\n```\n\n这个警告来源主要是在使用layoutAttributesForElementsInRect：方法返回的数组时，没有使用该数组的拷贝对象，而是直接使用了该数组。解决办法对该数组进行拷贝，并且是深拷贝。拷贝代码如下：\n\n```\n- (NSArray *)deepCopyWithArray:(NSArray *)array\n{\n    NSMutableArray *copys = [NSMutableArray arrayWithCapacity:array.count];\n\n    for (UICollectionViewLayoutAttributes *attris in array) {\n        [copys addObject:[attris copy]];\n    }\n    return copys;\n}\n```\n\n将layoutAttributesForElementsInRect：方法返回的数组扔到这个方法中，并且使用返回后的数组就行了。\n\n- 在navigationController中插入ScrollView后，scrollView的ContentInset的值发生了变化\n\n\t- 解决： self.automaticallyAdjustsScrollViewInsets = NO;\n\t- 原因： self.automaticallyAdjustsScrollViewInsets 默认值是YES，选择YES表示你允许视图控制器调整它内部插入的滑动视图来应对状态栏，导航栏，工具栏，和标签栏所消耗的屏幕区域。如果你设置为NO呢，就代表呀你要自己调整你插入的滑动视图，比如你的视图层次里面有多于一个的滑动视图。\n这大概是个什么意思呢，就是你的视图控制器在没经你允许的情况下调整你的控件位置了","source":"_posts/记录一些关于iOS的一些小技巧.md","raw":"---\ntitle: 记录一些关于iOS的一些小技巧\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 1b8f24c7\ndate: 2016-06-12 00:30:00\n---\n记录一些关于iOS的一些小技巧\n\n<!-- more -->\n\nXCode Profile 的路径\nxcode5 provisioning profile path： \n`~/Library/MobileDevice/Provisioning Profiles`\n\n在升级XCode7.0使用UICollectionViewLayout进行自定义布局时，调试台会出现以下的警告打印。\n\n```\nUICollectionViewFlowLayout has cached frame mismatch for index path {length = 2, path = 0 - 0} - cached value: {{122, 15}, {170, 170}}; expected value: {{157, 50}, {100, 100}} \nThis is likely occurring because the flow layout subclass LineLayout is modifying attributes returned by UICollectionViewFlowLayout without copying them\n```\n\n这个警告来源主要是在使用layoutAttributesForElementsInRect：方法返回的数组时，没有使用该数组的拷贝对象，而是直接使用了该数组。解决办法对该数组进行拷贝，并且是深拷贝。拷贝代码如下：\n\n```\n- (NSArray *)deepCopyWithArray:(NSArray *)array\n{\n    NSMutableArray *copys = [NSMutableArray arrayWithCapacity:array.count];\n\n    for (UICollectionViewLayoutAttributes *attris in array) {\n        [copys addObject:[attris copy]];\n    }\n    return copys;\n}\n```\n\n将layoutAttributesForElementsInRect：方法返回的数组扔到这个方法中，并且使用返回后的数组就行了。\n\n- 在navigationController中插入ScrollView后，scrollView的ContentInset的值发生了变化\n\n\t- 解决： self.automaticallyAdjustsScrollViewInsets = NO;\n\t- 原因： self.automaticallyAdjustsScrollViewInsets 默认值是YES，选择YES表示你允许视图控制器调整它内部插入的滑动视图来应对状态栏，导航栏，工具栏，和标签栏所消耗的屏幕区域。如果你设置为NO呢，就代表呀你要自己调整你插入的滑动视图，比如你的视图层次里面有多于一个的滑动视图。\n这大概是个什么意思呢，就是你的视图控制器在没经你允许的情况下调整你的控件位置了","slug":"记录一些关于iOS的一些小技巧","published":1,"updated":"2018-05-10T06:51:35.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcn9005ildxuweihjri6","content":"<p>记录一些关于iOS的一些小技巧</p>\n<a id=\"more\"></a>\n<p>XCode Profile 的路径<br>xcode5 provisioning profile path：<br><code>~/Library/MobileDevice/Provisioning Profiles</code></p>\n<p>在升级XCode7.0使用UICollectionViewLayout进行自定义布局时，调试台会出现以下的警告打印。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UICollectionViewFlowLayout has cached frame mismatch for index path &#123;length = 2, path = 0 - 0&#125; - cached value: &#123;&#123;122, 15&#125;, &#123;170, 170&#125;&#125;; expected value: &#123;&#123;157, 50&#125;, &#123;100, 100&#125;&#125; </span><br><span class=\"line\">This is likely occurring because the flow layout subclass LineLayout is modifying attributes returned by UICollectionViewFlowLayout without copying them</span><br></pre></td></tr></table></figure>\n<p>这个警告来源主要是在使用layoutAttributesForElementsInRect：方法返回的数组时，没有使用该数组的拷贝对象，而是直接使用了该数组。解决办法对该数组进行拷贝，并且是深拷贝。拷贝代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)deepCopyWithArray:(NSArray *)array</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSMutableArray *copys = [NSMutableArray arrayWithCapacity:array.count];</span><br><span class=\"line\"></span><br><span class=\"line\">    for (UICollectionViewLayoutAttributes *attris in array) &#123;</span><br><span class=\"line\">        [copys addObject:[attris copy]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return copys;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将layoutAttributesForElementsInRect：方法返回的数组扔到这个方法中，并且使用返回后的数组就行了。</p>\n<ul>\n<li><p>在navigationController中插入ScrollView后，scrollView的ContentInset的值发生了变化</p>\n<ul>\n<li>解决： self.automaticallyAdjustsScrollViewInsets = NO;</li>\n<li>原因： self.automaticallyAdjustsScrollViewInsets 默认值是YES，选择YES表示你允许视图控制器调整它内部插入的滑动视图来应对状态栏，导航栏，工具栏，和标签栏所消耗的屏幕区域。如果你设置为NO呢，就代表呀你要自己调整你插入的滑动视图，比如你的视图层次里面有多于一个的滑动视图。<br>这大概是个什么意思呢，就是你的视图控制器在没经你允许的情况下调整你的控件位置了</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>记录一些关于iOS的一些小技巧</p>","more":"<p>XCode Profile 的路径<br>xcode5 provisioning profile path：<br><code>~/Library/MobileDevice/Provisioning Profiles</code></p>\n<p>在升级XCode7.0使用UICollectionViewLayout进行自定义布局时，调试台会出现以下的警告打印。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UICollectionViewFlowLayout has cached frame mismatch for index path &#123;length = 2, path = 0 - 0&#125; - cached value: &#123;&#123;122, 15&#125;, &#123;170, 170&#125;&#125;; expected value: &#123;&#123;157, 50&#125;, &#123;100, 100&#125;&#125; </span><br><span class=\"line\">This is likely occurring because the flow layout subclass LineLayout is modifying attributes returned by UICollectionViewFlowLayout without copying them</span><br></pre></td></tr></table></figure>\n<p>这个警告来源主要是在使用layoutAttributesForElementsInRect：方法返回的数组时，没有使用该数组的拷贝对象，而是直接使用了该数组。解决办法对该数组进行拷贝，并且是深拷贝。拷贝代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)deepCopyWithArray:(NSArray *)array</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSMutableArray *copys = [NSMutableArray arrayWithCapacity:array.count];</span><br><span class=\"line\"></span><br><span class=\"line\">    for (UICollectionViewLayoutAttributes *attris in array) &#123;</span><br><span class=\"line\">        [copys addObject:[attris copy]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return copys;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将layoutAttributesForElementsInRect：方法返回的数组扔到这个方法中，并且使用返回后的数组就行了。</p>\n<ul>\n<li><p>在navigationController中插入ScrollView后，scrollView的ContentInset的值发生了变化</p>\n<ul>\n<li>解决： self.automaticallyAdjustsScrollViewInsets = NO;</li>\n<li>原因： self.automaticallyAdjustsScrollViewInsets 默认值是YES，选择YES表示你允许视图控制器调整它内部插入的滑动视图来应对状态栏，导航栏，工具栏，和标签栏所消耗的屏幕区域。如果你设置为NO呢，就代表呀你要自己调整你插入的滑动视图，比如你的视图层次里面有多于一个的滑动视图。<br>这大概是个什么意思呢，就是你的视图控制器在没经你允许的情况下调整你的控件位置了</li>\n</ul>\n</li>\n</ul>"},{"title":"用Swift的框架Vapor写服务端初体验","author":"Arclin","abbrlink":"73291e5a","date":"2017-03-15T16:00:00.000Z","_content":"咦? 用Swift写后端? 一开始听到的时候懵逼了一秒,一秒自后想了想感觉也没毛病,那就试试看咯.(没看WWDC的后果)\n\n<!-- more -->\n\n## 安装Vapor\n\n`curl -sL toolbox.vapor.sh | bash`\n\n## 创建项目\n\n`vapor new Hello --template=light`\n\n`--template=light` 意思是使用light-template模板,如果不指定模板的话默认使用base-template模板\n\n下载依赖并编译项目\n`vapor build`\n\n50多M的包,好久…\n\n配置服务器\n创建Config文件夹,新建servers.json文件, 指定host地址和端口号\n\n```\n{\n  \"http\": {\n    \"host\": \"0.0.0.0\",\n    \"port\": 8000\n  }\n}\n```\n\n`0.0.0.0` 和 `127.0.0.1` 都表示本机，使用 `0.0.0.0` 的原因是，一个机器可能有多个 IP 地址，`0.0.0.0` 表示监听每个 IP `8000` 端口收到的请求。\n\n`127.0.0.1` 则表示只接受本机发给本机的请求，从网络上其他电脑发过来的请求，不论是请求的哪个 IP，都是不被处理的。\n\n## 打包成一个XCode项目\n`vapor xcode -y` 这样子打包之后就会自动打开了\n\n## 启动服务器\n`vapor run` 或者在XCode运行\n\n看到了控制台输出了\n\n```\nNo command supplied, defaulting to serve...\nNo preparations.\nServer 'http' starting at 0.0.0.0:8000\n```\n\n就可以了\n\n如果说什么`Can not bind to xxxx` 就应该是端口占用的问题,可以用`lsof -i tcp:端口号` 和 `kill -9` 端口号解决这个问题\n\n如果你在浏览器输入`http://localhost:8000`可以看到以下信息就证明服务器启动成功了\n\n```\nRequest  \n- GET / HTTP/1.1\n- Headers:\n    Host: 0.0.0.0:8000\n    Upgrade-Insecure-Requests: 1\n    Connection: keep-alive\n    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36\n    Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2\n    Accept-Encoding: gzip, deflate, sdch\n    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n- Body:\n```\n\n会出现这串东西是因为他执行了`Sources/App/main.swift`的内容,把请求体返回回来.\n\n修改`Sources/App/main.swift`\n把文件改成这样子\n\n```\nimport Vapor\n\nlet drop = Droplet()\n\ndrop.get { _ in\n    return try JSON(node: [\n            \"message\":\"Hello Vapor\"\n        ])\n}\n\ndrop.get(\"Hello\",\"There\") { request in\n    return try JSON (node:[\n            \"message\":\"Hello There\"\n        ])\n}\n\ndrop.get(\"TEST\") { request in\n    return try JSON (node:[\n            \"message\":\"Hello Test\"\n        ])\n}\n\ndrop.run()\n```\n\n然后我们使用Postman测试一下三个地址\n\n`http://localhost:8000/`\n\n![WX20170316-105233@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe803b931.png)\n\n`http://localhost:8000/Hello/There\n\n![WX20170316-105315@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe7f92afc.png)\n\n`http://localhost:8000/TEST`\n\n![WX20170316-105336@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe7fca399.png)\n\n接下来试试接受参数并返回\n\n继续在`drop.run()` 上面补充\n\n```\ndrop.post(\"post\") { request in\n    guard let name = request.data[\"name\"]?.string else {\n        throw Abort.badRequest\n    }\n    return try JSON(node: [\n        \"name\": \"Hello \\(name)!\"\n        ])\n}\n```\n\n> guard近似的看做是Assert，但是你可以优雅的退出而非崩溃。\n\n判断如果没有接收到’name’参数的话就会抛出异常Invalid request,有的话就返回Hello + 参数值 + !\n\n测试一下\n\n![WX20170316-110133@2x.png](https://ooo.0o0.ooo/2017/03/16/58ca001f306a5.png)\n\n部署服务器\nVapor支持Heroku,Ubuntu,Digital Ocean,AWS等等服务器,具体怎么做我还没试过,有时间再去试试看\n\n为什么要用Swift写服务器?\n额,看了一下资料,也没发现有谁说这东西有什么特别突出的优点,不过没试过,觉得挺新鲜,就试试嘛.\n\n> 学习资料 :\n\n> [服务端 Swift - Vapor 篇 （一）](http://www.jianshu.com/p/3fc28570d951)\n\n> [用 Swift 的框架 Vapor 写服务器这事儿怎么样？](http://tips.producter.io/yong-swift-de-kuang-jia-vapor-xie-fu-wu-qi-zhe-shi-er-zen-yao-yang/)","source":"_posts/用Swift的框架Vapor写服务端初体验.md","raw":"---\ntitle: 用Swift的框架Vapor写服务端初体验\nauthor: Arclin\ntags:\n  - Swift\ncategories:\n  - Swift\nabbrlink: 73291e5a\ndate: 2017-03-16 00:00:00\n---\n咦? 用Swift写后端? 一开始听到的时候懵逼了一秒,一秒自后想了想感觉也没毛病,那就试试看咯.(没看WWDC的后果)\n\n<!-- more -->\n\n## 安装Vapor\n\n`curl -sL toolbox.vapor.sh | bash`\n\n## 创建项目\n\n`vapor new Hello --template=light`\n\n`--template=light` 意思是使用light-template模板,如果不指定模板的话默认使用base-template模板\n\n下载依赖并编译项目\n`vapor build`\n\n50多M的包,好久…\n\n配置服务器\n创建Config文件夹,新建servers.json文件, 指定host地址和端口号\n\n```\n{\n  \"http\": {\n    \"host\": \"0.0.0.0\",\n    \"port\": 8000\n  }\n}\n```\n\n`0.0.0.0` 和 `127.0.0.1` 都表示本机，使用 `0.0.0.0` 的原因是，一个机器可能有多个 IP 地址，`0.0.0.0` 表示监听每个 IP `8000` 端口收到的请求。\n\n`127.0.0.1` 则表示只接受本机发给本机的请求，从网络上其他电脑发过来的请求，不论是请求的哪个 IP，都是不被处理的。\n\n## 打包成一个XCode项目\n`vapor xcode -y` 这样子打包之后就会自动打开了\n\n## 启动服务器\n`vapor run` 或者在XCode运行\n\n看到了控制台输出了\n\n```\nNo command supplied, defaulting to serve...\nNo preparations.\nServer 'http' starting at 0.0.0.0:8000\n```\n\n就可以了\n\n如果说什么`Can not bind to xxxx` 就应该是端口占用的问题,可以用`lsof -i tcp:端口号` 和 `kill -9` 端口号解决这个问题\n\n如果你在浏览器输入`http://localhost:8000`可以看到以下信息就证明服务器启动成功了\n\n```\nRequest  \n- GET / HTTP/1.1\n- Headers:\n    Host: 0.0.0.0:8000\n    Upgrade-Insecure-Requests: 1\n    Connection: keep-alive\n    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36\n    Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2\n    Accept-Encoding: gzip, deflate, sdch\n    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n- Body:\n```\n\n会出现这串东西是因为他执行了`Sources/App/main.swift`的内容,把请求体返回回来.\n\n修改`Sources/App/main.swift`\n把文件改成这样子\n\n```\nimport Vapor\n\nlet drop = Droplet()\n\ndrop.get { _ in\n    return try JSON(node: [\n            \"message\":\"Hello Vapor\"\n        ])\n}\n\ndrop.get(\"Hello\",\"There\") { request in\n    return try JSON (node:[\n            \"message\":\"Hello There\"\n        ])\n}\n\ndrop.get(\"TEST\") { request in\n    return try JSON (node:[\n            \"message\":\"Hello Test\"\n        ])\n}\n\ndrop.run()\n```\n\n然后我们使用Postman测试一下三个地址\n\n`http://localhost:8000/`\n\n![WX20170316-105233@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe803b931.png)\n\n`http://localhost:8000/Hello/There\n\n![WX20170316-105315@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe7f92afc.png)\n\n`http://localhost:8000/TEST`\n\n![WX20170316-105336@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe7fca399.png)\n\n接下来试试接受参数并返回\n\n继续在`drop.run()` 上面补充\n\n```\ndrop.post(\"post\") { request in\n    guard let name = request.data[\"name\"]?.string else {\n        throw Abort.badRequest\n    }\n    return try JSON(node: [\n        \"name\": \"Hello \\(name)!\"\n        ])\n}\n```\n\n> guard近似的看做是Assert，但是你可以优雅的退出而非崩溃。\n\n判断如果没有接收到’name’参数的话就会抛出异常Invalid request,有的话就返回Hello + 参数值 + !\n\n测试一下\n\n![WX20170316-110133@2x.png](https://ooo.0o0.ooo/2017/03/16/58ca001f306a5.png)\n\n部署服务器\nVapor支持Heroku,Ubuntu,Digital Ocean,AWS等等服务器,具体怎么做我还没试过,有时间再去试试看\n\n为什么要用Swift写服务器?\n额,看了一下资料,也没发现有谁说这东西有什么特别突出的优点,不过没试过,觉得挺新鲜,就试试嘛.\n\n> 学习资料 :\n\n> [服务端 Swift - Vapor 篇 （一）](http://www.jianshu.com/p/3fc28570d951)\n\n> [用 Swift 的框架 Vapor 写服务器这事儿怎么样？](http://tips.producter.io/yong-swift-de-kuang-jia-vapor-xie-fu-wu-qi-zhe-shi-er-zen-yao-yang/)","slug":"用Swift的框架Vapor写服务端初体验","published":1,"updated":"2018-05-10T06:51:35.767Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcvk006yldxuicyhnvz7","content":"<p>咦? 用Swift写后端? 一开始听到的时候懵逼了一秒,一秒自后想了想感觉也没毛病,那就试试看咯.(没看WWDC的后果)</p>\n<a id=\"more\"></a>\n<h2 id=\"安装Vapor\"><a href=\"#安装Vapor\" class=\"headerlink\" title=\"安装Vapor\"></a>安装Vapor</h2><p><code>curl -sL toolbox.vapor.sh | bash</code></p>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><p><code>vapor new Hello --template=light</code></p>\n<p><code>--template=light</code> 意思是使用light-template模板,如果不指定模板的话默认使用base-template模板</p>\n<p>下载依赖并编译项目<br><code>vapor build</code></p>\n<p>50多M的包,好久…</p>\n<p>配置服务器<br>创建Config文件夹,新建servers.json文件, 指定host地址和端口号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;http&quot;: &#123;</span><br><span class=\"line\">    &quot;host&quot;: &quot;0.0.0.0&quot;,</span><br><span class=\"line\">    &quot;port&quot;: 8000</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>0.0.0.0</code> 和 <code>127.0.0.1</code> 都表示本机，使用 <code>0.0.0.0</code> 的原因是，一个机器可能有多个 IP 地址，<code>0.0.0.0</code> 表示监听每个 IP <code>8000</code> 端口收到的请求。</p>\n<p><code>127.0.0.1</code> 则表示只接受本机发给本机的请求，从网络上其他电脑发过来的请求，不论是请求的哪个 IP，都是不被处理的。</p>\n<h2 id=\"打包成一个XCode项目\"><a href=\"#打包成一个XCode项目\" class=\"headerlink\" title=\"打包成一个XCode项目\"></a>打包成一个XCode项目</h2><p><code>vapor xcode -y</code> 这样子打包之后就会自动打开了</p>\n<h2 id=\"启动服务器\"><a href=\"#启动服务器\" class=\"headerlink\" title=\"启动服务器\"></a>启动服务器</h2><p><code>vapor run</code> 或者在XCode运行</p>\n<p>看到了控制台输出了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No command supplied, defaulting to serve...</span><br><span class=\"line\">No preparations.</span><br><span class=\"line\">Server &apos;http&apos; starting at 0.0.0.0:8000</span><br></pre></td></tr></table></figure>\n<p>就可以了</p>\n<p>如果说什么<code>Can not bind to xxxx</code> 就应该是端口占用的问题,可以用<code>lsof -i tcp:端口号</code> 和 <code>kill -9</code> 端口号解决这个问题</p>\n<p>如果你在浏览器输入<code>http://localhost:8000</code>可以看到以下信息就证明服务器启动成功了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Request  </span><br><span class=\"line\">- GET / HTTP/1.1</span><br><span class=\"line\">- Headers:</span><br><span class=\"line\">    Host: 0.0.0.0:8000</span><br><span class=\"line\">    Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">    Connection: keep-alive</span><br><span class=\"line\">    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36</span><br><span class=\"line\">    Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2</span><br><span class=\"line\">    Accept-Encoding: gzip, deflate, sdch</span><br><span class=\"line\">    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class=\"line\">- Body:</span><br></pre></td></tr></table></figure>\n<p>会出现这串东西是因为他执行了<code>Sources/App/main.swift</code>的内容,把请求体返回回来.</p>\n<p>修改<code>Sources/App/main.swift</code><br>把文件改成这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vapor</span><br><span class=\"line\"></span><br><span class=\"line\">let drop = Droplet()</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get &#123; _ in</span><br><span class=\"line\">    return try JSON(node: [</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello Vapor&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get(&quot;Hello&quot;,&quot;There&quot;) &#123; request in</span><br><span class=\"line\">    return try JSON (node:[</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello There&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get(&quot;TEST&quot;) &#123; request in</span><br><span class=\"line\">    return try JSON (node:[</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello Test&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.run()</span><br></pre></td></tr></table></figure>\n<p>然后我们使用Postman测试一下三个地址</p>\n<p><code>http://localhost:8000/</code></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe803b931.png\" alt=\"WX20170316-105233@2x.png\"></p>\n<p>`<a href=\"http://localhost:8000/Hello/There\" target=\"_blank\" rel=\"noopener\">http://localhost:8000/Hello/There</a></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe7f92afc.png\" alt=\"WX20170316-105315@2x.png\"></p>\n<p><code>http://localhost:8000/TEST</code></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe7fca399.png\" alt=\"WX20170316-105336@2x.png\"></p>\n<p>接下来试试接受参数并返回</p>\n<p>继续在<code>drop.run()</code> 上面补充</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drop.post(&quot;post&quot;) &#123; request in</span><br><span class=\"line\">    guard let name = request.data[&quot;name&quot;]?.string else &#123;</span><br><span class=\"line\">        throw Abort.badRequest</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return try JSON(node: [</span><br><span class=\"line\">        &quot;name&quot;: &quot;Hello \\(name)!&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>guard近似的看做是Assert，但是你可以优雅的退出而非崩溃。</p>\n</blockquote>\n<p>判断如果没有接收到’name’参数的话就会抛出异常Invalid request,有的话就返回Hello + 参数值 + !</p>\n<p>测试一下</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58ca001f306a5.png\" alt=\"WX20170316-110133@2x.png\"></p>\n<p>部署服务器<br>Vapor支持Heroku,Ubuntu,Digital Ocean,AWS等等服务器,具体怎么做我还没试过,有时间再去试试看</p>\n<p>为什么要用Swift写服务器?<br>额,看了一下资料,也没发现有谁说这东西有什么特别突出的优点,不过没试过,觉得挺新鲜,就试试嘛.</p>\n<blockquote>\n<p>学习资料 :</p>\n<p><a href=\"http://www.jianshu.com/p/3fc28570d951\" target=\"_blank\" rel=\"noopener\">服务端 Swift - Vapor 篇 （一）</a></p>\n<p><a href=\"http://tips.producter.io/yong-swift-de-kuang-jia-vapor-xie-fu-wu-qi-zhe-shi-er-zen-yao-yang/\" target=\"_blank\" rel=\"noopener\">用 Swift 的框架 Vapor 写服务器这事儿怎么样？</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>咦? 用Swift写后端? 一开始听到的时候懵逼了一秒,一秒自后想了想感觉也没毛病,那就试试看咯.(没看WWDC的后果)</p>","more":"<h2 id=\"安装Vapor\"><a href=\"#安装Vapor\" class=\"headerlink\" title=\"安装Vapor\"></a>安装Vapor</h2><p><code>curl -sL toolbox.vapor.sh | bash</code></p>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><p><code>vapor new Hello --template=light</code></p>\n<p><code>--template=light</code> 意思是使用light-template模板,如果不指定模板的话默认使用base-template模板</p>\n<p>下载依赖并编译项目<br><code>vapor build</code></p>\n<p>50多M的包,好久…</p>\n<p>配置服务器<br>创建Config文件夹,新建servers.json文件, 指定host地址和端口号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;http&quot;: &#123;</span><br><span class=\"line\">    &quot;host&quot;: &quot;0.0.0.0&quot;,</span><br><span class=\"line\">    &quot;port&quot;: 8000</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>0.0.0.0</code> 和 <code>127.0.0.1</code> 都表示本机，使用 <code>0.0.0.0</code> 的原因是，一个机器可能有多个 IP 地址，<code>0.0.0.0</code> 表示监听每个 IP <code>8000</code> 端口收到的请求。</p>\n<p><code>127.0.0.1</code> 则表示只接受本机发给本机的请求，从网络上其他电脑发过来的请求，不论是请求的哪个 IP，都是不被处理的。</p>\n<h2 id=\"打包成一个XCode项目\"><a href=\"#打包成一个XCode项目\" class=\"headerlink\" title=\"打包成一个XCode项目\"></a>打包成一个XCode项目</h2><p><code>vapor xcode -y</code> 这样子打包之后就会自动打开了</p>\n<h2 id=\"启动服务器\"><a href=\"#启动服务器\" class=\"headerlink\" title=\"启动服务器\"></a>启动服务器</h2><p><code>vapor run</code> 或者在XCode运行</p>\n<p>看到了控制台输出了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No command supplied, defaulting to serve...</span><br><span class=\"line\">No preparations.</span><br><span class=\"line\">Server &apos;http&apos; starting at 0.0.0.0:8000</span><br></pre></td></tr></table></figure>\n<p>就可以了</p>\n<p>如果说什么<code>Can not bind to xxxx</code> 就应该是端口占用的问题,可以用<code>lsof -i tcp:端口号</code> 和 <code>kill -9</code> 端口号解决这个问题</p>\n<p>如果你在浏览器输入<code>http://localhost:8000</code>可以看到以下信息就证明服务器启动成功了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Request  </span><br><span class=\"line\">- GET / HTTP/1.1</span><br><span class=\"line\">- Headers:</span><br><span class=\"line\">    Host: 0.0.0.0:8000</span><br><span class=\"line\">    Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">    Connection: keep-alive</span><br><span class=\"line\">    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36</span><br><span class=\"line\">    Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2</span><br><span class=\"line\">    Accept-Encoding: gzip, deflate, sdch</span><br><span class=\"line\">    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class=\"line\">- Body:</span><br></pre></td></tr></table></figure>\n<p>会出现这串东西是因为他执行了<code>Sources/App/main.swift</code>的内容,把请求体返回回来.</p>\n<p>修改<code>Sources/App/main.swift</code><br>把文件改成这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vapor</span><br><span class=\"line\"></span><br><span class=\"line\">let drop = Droplet()</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get &#123; _ in</span><br><span class=\"line\">    return try JSON(node: [</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello Vapor&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get(&quot;Hello&quot;,&quot;There&quot;) &#123; request in</span><br><span class=\"line\">    return try JSON (node:[</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello There&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get(&quot;TEST&quot;) &#123; request in</span><br><span class=\"line\">    return try JSON (node:[</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello Test&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.run()</span><br></pre></td></tr></table></figure>\n<p>然后我们使用Postman测试一下三个地址</p>\n<p><code>http://localhost:8000/</code></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe803b931.png\" alt=\"WX20170316-105233@2x.png\"></p>\n<p>`<a href=\"http://localhost:8000/Hello/There\" target=\"_blank\" rel=\"noopener\">http://localhost:8000/Hello/There</a></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe7f92afc.png\" alt=\"WX20170316-105315@2x.png\"></p>\n<p><code>http://localhost:8000/TEST</code></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe7fca399.png\" alt=\"WX20170316-105336@2x.png\"></p>\n<p>接下来试试接受参数并返回</p>\n<p>继续在<code>drop.run()</code> 上面补充</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drop.post(&quot;post&quot;) &#123; request in</span><br><span class=\"line\">    guard let name = request.data[&quot;name&quot;]?.string else &#123;</span><br><span class=\"line\">        throw Abort.badRequest</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return try JSON(node: [</span><br><span class=\"line\">        &quot;name&quot;: &quot;Hello \\(name)!&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>guard近似的看做是Assert，但是你可以优雅的退出而非崩溃。</p>\n</blockquote>\n<p>判断如果没有接收到’name’参数的话就会抛出异常Invalid request,有的话就返回Hello + 参数值 + !</p>\n<p>测试一下</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58ca001f306a5.png\" alt=\"WX20170316-110133@2x.png\"></p>\n<p>部署服务器<br>Vapor支持Heroku,Ubuntu,Digital Ocean,AWS等等服务器,具体怎么做我还没试过,有时间再去试试看</p>\n<p>为什么要用Swift写服务器?<br>额,看了一下资料,也没发现有谁说这东西有什么特别突出的优点,不过没试过,觉得挺新鲜,就试试嘛.</p>\n<blockquote>\n<p>学习资料 :</p>\n<p><a href=\"http://www.jianshu.com/p/3fc28570d951\" target=\"_blank\" rel=\"noopener\">服务端 Swift - Vapor 篇 （一）</a></p>\n<p><a href=\"http://tips.producter.io/yong-swift-de-kuang-jia-vapor-xie-fu-wu-qi-zhe-shi-er-zen-yao-yang/\" target=\"_blank\" rel=\"noopener\">用 Swift 的框架 Vapor 写服务器这事儿怎么样？</a></p>\n</blockquote>"},{"title":"解决git status中文问题","author":"Arclin","abbrlink":"93da1b70","date":"2017-08-07T16:00:00.000Z","_content":"在中文情况下`git status`是 `\\344\\272\\247\\345\\223\\201\\351\\234\\200\\346\\261\\202` 差不多这样的。\n\n解决这个问题方法是：\n\n`git config --global core.quotepath false`","source":"_posts/解决git-status中文问题.md","raw":"---\ntitle: 解决git status中文问题\nauthor: Arclin\ntags:\n  - 技巧\n  - git\ncategories:\n  - Git\nabbrlink: 93da1b70\ndate: 2017-08-08 00:00:00\n---\n在中文情况下`git status`是 `\\344\\272\\247\\345\\223\\201\\351\\234\\200\\346\\261\\202` 差不多这样的。\n\n解决这个问题方法是：\n\n`git config --global core.quotepath false`","slug":"解决git-status中文问题","published":1,"updated":"2018-05-10T06:51:35.776Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcvq0070ldxua4zibxjo","content":"<p>在中文情况下<code>git status</code>是 <code>\\344\\272\\247\\345\\223\\201\\351\\234\\200\\346\\261\\202</code> 差不多这样的。</p>\n<p>解决这个问题方法是：</p>\n<p><code>git config --global core.quotepath false</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在中文情况下<code>git status</code>是 <code>\\344\\272\\247\\345\\223\\201\\351\\234\\200\\346\\261\\202</code> 差不多这样的。</p>\n<p>解决这个问题方法是：</p>\n<p><code>git config --global core.quotepath false</code></p>\n"},{"title":"项目里面的库和框架里面的库冲突问题","author":"Arclin","abbrlink":"b072216a","date":"2016-10-28T16:00:00.000Z","_content":"项目里面有一个libFat.a 然后项目里面的KxMovie.framework 里面也有一个libFat.a，编译时会冲突\n如果有用Cocopods,那么只要删掉-ObjC编译选项就可以\n\n<!-- more -->\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/111.png)\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/222.png)","source":"_posts/项目里面的库和框架里面的库冲突问题.md","raw":"---\ntitle: 项目里面的库和框架里面的库冲突问题\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: b072216a\ndate: 2016-10-29 00:00:00\n---\n项目里面有一个libFat.a 然后项目里面的KxMovie.framework 里面也有一个libFat.a，编译时会冲突\n如果有用Cocopods,那么只要删掉-ObjC编译选项就可以\n\n<!-- more -->\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/111.png)\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/222.png)","slug":"项目里面的库和框架里面的库冲突问题","published":1,"updated":"2018-05-10T06:51:35.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcvy0074ldxu11fcpthb","content":"<p>项目里面有一个libFat.a 然后项目里面的KxMovie.framework 里面也有一个libFat.a，编译时会冲突<br>如果有用Cocopods,那么只要删掉-ObjC编译选项就可以</p>\n<a id=\"more\"></a>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/111.png\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/222.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>项目里面有一个libFat.a 然后项目里面的KxMovie.framework 里面也有一个libFat.a，编译时会冲突<br>如果有用Cocopods,那么只要删掉-ObjC编译选项就可以</p>","more":"<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/111.png\" alt=\"\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/222.png\" alt=\"\"></p>"},{"title":"关于iOS组件化的思考","author":"Arclin","abbrlink":"51f93d53","date":"2018-05-11T07:02:35.000Z","_content":"最近公司要对以往App进行组件化处理，本人有幸收到任务，故运用了以往学到的架构思想对进行规划。\n<!--more-->\n\n### 需求分析\n\n1. 公司的业务线非常地多，基本上每个业务都会有一个专门的APP去推广，然后公司还有些平台版APP，用于集合多条业务线，所以说每个业务都需要进行封装，去重复利用，这是需求一。\n2. 每个业务模块是需要有一定的定制性的，毕竟如果几个APP都用到了通过模块，然后UI长得都一样，那这样子就很可能过不了审核，苹果会认为你只是套个马甲发多个几APP，所以说组件设计的时候要分离UI和数据层，中间不要形成依赖，这是需求二。\n3. 组件间不能直接通信，要通过中间层去请求，要做到组件A删除后组件B能照样编译成功，除非说他们之间的耦合成为了产品需求，否则他们不应该直接通信，这是需求三。\n4. 组件需要做好log处理，还要添加埋点，在哪里做切点，这是很重要的需要仔细考虑的事情，是组件内置埋点还是给暴露给主工程去注册埋点，优缺利弊是需要权衡的，这是需求四。\n\n### 已有的组件化\n\n\t之前公司已经有cocoapods的组件化方案了，cocoapods是很好的组件化实践，一个pod install就可以引入组件","source":"_drafts/关于iOS组件化的思考.md","raw":"title: 关于iOS组件化的思考\nauthor: Arclin\nabbrlink: 51f93d53\ndate: 2018-05-11 15:02:35\ntags:\n---\n最近公司要对以往App进行组件化处理，本人有幸收到任务，故运用了以往学到的架构思想对进行规划。\n<!--more-->\n\n### 需求分析\n\n1. 公司的业务线非常地多，基本上每个业务都会有一个专门的APP去推广，然后公司还有些平台版APP，用于集合多条业务线，所以说每个业务都需要进行封装，去重复利用，这是需求一。\n2. 每个业务模块是需要有一定的定制性的，毕竟如果几个APP都用到了通过模块，然后UI长得都一样，那这样子就很可能过不了审核，苹果会认为你只是套个马甲发多个几APP，所以说组件设计的时候要分离UI和数据层，中间不要形成依赖，这是需求二。\n3. 组件间不能直接通信，要通过中间层去请求，要做到组件A删除后组件B能照样编译成功，除非说他们之间的耦合成为了产品需求，否则他们不应该直接通信，这是需求三。\n4. 组件需要做好log处理，还要添加埋点，在哪里做切点，这是很重要的需要仔细考虑的事情，是组件内置埋点还是给暴露给主工程去注册埋点，优缺利弊是需要权衡的，这是需求四。\n\n### 已有的组件化\n\n\t之前公司已经有cocoapods的组件化方案了，cocoapods是很好的组件化实践，一个pod install就可以引入组件","slug":"关于iOS组件化的思考","published":0,"updated":"2018-05-11T07:59:30.951Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcw20076ldxu3eukusm0","content":"<p>最近公司要对以往App进行组件化处理，本人有幸收到任务，故运用了以往学到的架构思想对进行规划。<br><a id=\"more\"></a></p>\n<h3 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h3><ol>\n<li>公司的业务线非常地多，基本上每个业务都会有一个专门的APP去推广，然后公司还有些平台版APP，用于集合多条业务线，所以说每个业务都需要进行封装，去重复利用，这是需求一。</li>\n<li>每个业务模块是需要有一定的定制性的，毕竟如果几个APP都用到了通过模块，然后UI长得都一样，那这样子就很可能过不了审核，苹果会认为你只是套个马甲发多个几APP，所以说组件设计的时候要分离UI和数据层，中间不要形成依赖，这是需求二。</li>\n<li>组件间不能直接通信，要通过中间层去请求，要做到组件A删除后组件B能照样编译成功，除非说他们之间的耦合成为了产品需求，否则他们不应该直接通信，这是需求三。</li>\n<li>组件需要做好log处理，还要添加埋点，在哪里做切点，这是很重要的需要仔细考虑的事情，是组件内置埋点还是给暴露给主工程去注册埋点，优缺利弊是需要权衡的，这是需求四。</li>\n</ol>\n<h3 id=\"已有的组件化\"><a href=\"#已有的组件化\" class=\"headerlink\" title=\"已有的组件化\"></a>已有的组件化</h3><pre><code>之前公司已经有cocoapods的组件化方案了，cocoapods是很好的组件化实践，一个pod install就可以引入组件\n</code></pre>","site":{"data":{}},"excerpt":"<p>最近公司要对以往App进行组件化处理，本人有幸收到任务，故运用了以往学到的架构思想对进行规划。<br>","more":"</p>\n<h3 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h3><ol>\n<li>公司的业务线非常地多，基本上每个业务都会有一个专门的APP去推广，然后公司还有些平台版APP，用于集合多条业务线，所以说每个业务都需要进行封装，去重复利用，这是需求一。</li>\n<li>每个业务模块是需要有一定的定制性的，毕竟如果几个APP都用到了通过模块，然后UI长得都一样，那这样子就很可能过不了审核，苹果会认为你只是套个马甲发多个几APP，所以说组件设计的时候要分离UI和数据层，中间不要形成依赖，这是需求二。</li>\n<li>组件间不能直接通信，要通过中间层去请求，要做到组件A删除后组件B能照样编译成功，除非说他们之间的耦合成为了产品需求，否则他们不应该直接通信，这是需求三。</li>\n<li>组件需要做好log处理，还要添加埋点，在哪里做切点，这是很重要的需要仔细考虑的事情，是组件内置埋点还是给暴露给主工程去注册埋点，优缺利弊是需要权衡的，这是需求四。</li>\n</ol>\n<h3 id=\"已有的组件化\"><a href=\"#已有的组件化\" class=\"headerlink\" title=\"已有的组件化\"></a>已有的组件化</h3><pre><code>之前公司已经有cocoapods的组件化方案了，cocoapods是很好的组件化实践，一个pod install就可以引入组件\n</code></pre>"},{"title":"关于案场管家的技术点总结","author":"Arclin","abbrlink":"8ff6aa28","date":"2016-06-11T16:00:00.000Z","_content":"案场管家的技术点总结\n\n<!-- more -->\n\n### xib与storyboard\n\n1. xib和storyboard均是用于布局所用，其实如果不需要过于复杂的布局的话完全也可以时候用masonry或者直接CGRect定位亦或者NSNSLayoutConstraint进行布局，如果要用代码的话个人觉得masonry是非常好用的，并且该框架所使用的函数式编程思想和链式编程思想也是值得学习的\n\n2. storyboard的作用类似于包含多个xib+视图管理，代码调用storyboard里面的控制器的代码如下\n\n\t```\n\tUIStoryboard *stroyboard = [UIStoryboard storyboardWithName:\"storyboard的文件名\" bundle:nil];\n\tXXXViewController *vc = [storyboard instantiateViewControllerWithIdentifier:“contorller的storyboard Id”];\n\t```\n\t如果是controller类xib，那么就直接 alloc init 一个该xib所绑定的controller就可以了\n\t如果是view类xib\n\t\n\t```\n\t[[[NSBundle mainBundle] loadNibNamed:@\"CMBuildingCell\" owner:nil options:nil] firstObject]\n\t```\n\n3. 之前曾经遇到过一个bug，从xib拖线到类文件的时候他会报错，原因是如果你的xib绑定的是一个继承UIView的类（比如一个cell），那么File Owner就应该保持为空，父view绑定类；如果绑定的是一个controller类，那父view绑定为空，File Owner绑定类，从以上说明我们可以得知，FileOwner就是这个xib所属的controller,如果他没有所属的controller，那么调用这个xib的controller就是他的File Owner，所以上面的代码里面的owner我们一直保持为nil就可以了\n \n### 关于网络获取与数据本地化\n\n1. 关于网络方面的话我之前写过一份xmind，大概流程是这样子的\n\t- 首先定义一个布尔变量，判断是否有存档\n\t- viewDidLoad 取档并刷新数据\n\t- viewWillAppear 中执行 loadDataFromNet\n\t- loadDataFromNet方法中判断是否有存档，没有存档并且获取网络数据失败的时候才提示数据刷新失败\n\t\n\t示例如下\n\t\n\t* 这里用NSCachesDirectory，也就是缓存目录，关于目录的选择看有道云笔记，上面有比较详细的说明 \n\t\n\t```\n\t #define XXFileName [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:@\"xx.data\"]\n\t- (void)viewDidLoad {\t\n\t\t [super viewDidLoad];\n\t\t // 取档\n\t    \tself.dataArray = [NSKeyedUnarchiver unarchiveObjectWithFile:XXFileName];\n\t    \n\t\t if (self.dataArray) {\n\t   \t\t[self.tableView reloadData];\n\t   \t\thasArchive = YES;\n\t\t}else{\n\t    \thasArchive = NO;\n\t    \t// 转菊花  或者 下拉刷新也行 \n\t    \t[SVProgressHUD setDefaultMaskType:SVProgressHUDMaskTypeBlack];\n\t \t    [SVProgressHUD show];\n\t\t}\n\t\t[self loadDataFromNet];\n\t}\n\t- (void)viewWillAppear:(BOOL)animated\n\t{\n\t    **如果能保证这个controller每次进来都会经过viewDidLoad(例如本身自己就是子控制器且自己也没有子控制器)则这里就不用写了**\n\t\t[self loadDataFromNet];\n\t}\t\n\t- (void)loadDataFromNet\n\t{\n\t\t[XXTool fetchMsg:^(XXData *data) {\n\t  \t\tself.data = data;\n\t    \t// 归档\n\t    \t[NSKeyedArchiver archiveRootObject:profile toFile:XXFileName];\n\t    \tdispatch_async(dispatch_get_main_queue(), ^{\n\t    \t\t[SVProgressHUD dismiss];\n\t        \t[self.tableView reloadData];\n\t    \t});\n\t\t } failure:^(NSError *error) {\n\t    \tNSLog(@\"%@\",error);\n\t    \tdispatch_async(dispatch_get_main_queue(), ^{\n\t    \t    if(!_hasArchive)[SVProgressHUD showErrorWithStatus:@\"加载失败\"];\n\t    \t});\n\t\t}];\n\t}\n\t```\n \t* 不过做项目的时候还是看实际情况进行调整吧，上面所说的只是一般情况下的网络处理\n\n\t近期稍微地研究了一下Runtime框架，加上一点脑洞和MJExtendsion的配合，感觉可以做出一个框架，能够实现获取数据之后直接生成跟远程数据库结构相同的本地数据库，一方面可以避开类似salesForce的SOQL语句无法进行多表查询之类的恶心问题，另一方面做数据筛选功能的时候也会简单很多，这个就待我去看看能不能搞出来\n\t\n### 关于单例\n1. 在这个项目里面我导入了一个外部框架（应该说是一个文件？）：Singleton.h\n这个东西使用起来很爽\n只要在你想单例的类的声明h里加 singleton_interface（类名）\n实现m里加 singleton_implementation（类名)\n就可以了\n之后你想调用这个类的时候就直接 [ClassName sharedClassName] 就可以直接获得到这个类的单例\n\n2. 什么情况下要用到单例？\n以案场这个为例子，我每次获取数据都需要加上限制条件，筛选当前项目下和当前登录用户的数据\n那么我就会频繁使用到projectId 和 userId ，__并且这两个值基本不变__\n所以我就给这个单例写了两个方法\n\n\t```\n\t- (NSString *)currentProjectId;\n\t- (NSString *)userId;\n\t- (CMProject *)currentProject\n\t{\t\n\t CMProject*currentProject = [NSKeyedUnarchiverunarchiveObjectWithFile:CMSelectProjectFileName];\n\t   \treturn currentProject;\n\t}\n\t\n\t- (NSString *)userId{ \n\treturn [SFUserAccountManager sharedInstance].currentUser.credentials.userId;\n\t}\n\t\n\t//使用\n\t[[CMUserTool sharedCMUserTool] userId];\n\t```\n\t\n### 关于传值\n\n1. 传值有三宝：代理、通知、block 另外还有storyboard专用segue传值和成员属性传值等，因为前三个比较重要所以我就说说前三个的使用\n\t- 代理用来两个视图之间的传值，最常用的就是自定义view上面的点击事件通过代理告诉调用它的controller，因为一个界面只能有一个controller，一般我们都是抽出另一个controller的view添加到这个controller上面，所以这时候就要用代理进行两个controller之间的数据传递\n通知，先说说使用方法\n\n\t```\n\t**消息接收方**\n\t[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(方法名) name:消息名 object:nil];\n\t\n\t**消息发送方**\n\t//创建一个消息对象\n\tNSNotification * notice = [NSNotification notificationWithName:消息名 object:nil userInfo:nil];\n\t//发送消息\n\t[[NSNotificationCenter defaultCenter]postNotification:notice];\n\t移除通知 \n\t\n\t移除单个通知\n\t[[NSNotificationCenter defaultCenter] removeObserver:self name:消息名 object:self];\n\t\n\t移除当前所有通知:[[NSNotificationCenterdefaultCenter]removeObserver:self];\n\t```\n\n\t但是优缺点并存\n\t\n\t> 优势：\n\t>\n\t> 1. 不需要编写多少代码，实现比较简单\n\t> 2. 对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单\n\t> 3. controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息\n\t\n\t> 缺点：\n\t>\n\t> 1. 在编译期不会检查通知是否能够被观察者正确的处理； \n\t> 2. 在释放注册的对象时，需要在通知中心取消注册；\n\t> 3. 在调试的时候应用的工作以及控制过程难跟踪；\n\t> 4. 需要第三方对象来管理controller与观察者对象之间的联系；\n\t> 5. controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；\n\t> 6. 通知发出后，controller不能从观察者获得任何的反馈信息。\n\t\n\n\t- block 用于反向传值，就是在子控制器操作数据后传值回到父控制器，这时候我们用block，不过block传值也有坑，很容易引起循环引用然后烧内存。解决方法就是用weak修饰对象比如 ` weak typeof(self) weakSelf = self `\n这样子我们用weakSelf.对象就不会引起循环引用\n\t\t- 还有block有一个小地方要注意，如果要在block里面调用外部变量的话，要给外部变量加一个__block修饰符\n\n### 关于枚举\n\n枚举不用讲太多，枚举就是为了方便判断而已，但是命名规范还是要说的,举个栗子\n\n```\ntypedef enum : NSUInteger {\n     CMRelatedTypeOpportunity,\n     CMRelatedTypeBooking,\n     CMRelatedTypeSalesOrder,\n     CMRelatedTypeContract,\n     CMRelatedTypeCollection,\n     CMRelatedTypeTrade\n } CMRelatedType;\n```\n \n枚举的成员名 = 枚举名 + 类型名\n\n### 关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller\n\n案场那个客户界是这个app中逻辑最复杂的一个界面，虽然通过了枚举的判断方便了一个代码的阅读，但总的来说上千行代码着实还是恶心。\n类似的场景应该以后应该还会经常发生，但是虽然开发的时候可能方便了但是维护起来也太费劲了，并且之前项目的种种维护的体验也告诉了我们一个事实：MVC框架不够用了\n\n所以——我们还是换个架构吧~\n\n我大概考虑了一下，逻辑层还是尽可能的细分，多几个类都行，然后耦合性应该低\n之前我们就已经习惯了把业务层从controller中抽取出来,这种方式应该保留\n然后我们可以尝试引入MVCS架构以及MVVM架构等，具体的demo应该会在近期实现","source":"_posts/关于案场管家的技术点总结.md","raw":"---\ntitle: 关于案场管家的技术点总结\nauthor: Arclin\ntags:\n  - iOS\n  - 杂谈\ncategories:\n  - iOS\nabbrlink: 8ff6aa28\ndate: 2016-06-12 00:00:00\n---\n案场管家的技术点总结\n\n<!-- more -->\n\n### xib与storyboard\n\n1. xib和storyboard均是用于布局所用，其实如果不需要过于复杂的布局的话完全也可以时候用masonry或者直接CGRect定位亦或者NSNSLayoutConstraint进行布局，如果要用代码的话个人觉得masonry是非常好用的，并且该框架所使用的函数式编程思想和链式编程思想也是值得学习的\n\n2. storyboard的作用类似于包含多个xib+视图管理，代码调用storyboard里面的控制器的代码如下\n\n\t```\n\tUIStoryboard *stroyboard = [UIStoryboard storyboardWithName:\"storyboard的文件名\" bundle:nil];\n\tXXXViewController *vc = [storyboard instantiateViewControllerWithIdentifier:“contorller的storyboard Id”];\n\t```\n\t如果是controller类xib，那么就直接 alloc init 一个该xib所绑定的controller就可以了\n\t如果是view类xib\n\t\n\t```\n\t[[[NSBundle mainBundle] loadNibNamed:@\"CMBuildingCell\" owner:nil options:nil] firstObject]\n\t```\n\n3. 之前曾经遇到过一个bug，从xib拖线到类文件的时候他会报错，原因是如果你的xib绑定的是一个继承UIView的类（比如一个cell），那么File Owner就应该保持为空，父view绑定类；如果绑定的是一个controller类，那父view绑定为空，File Owner绑定类，从以上说明我们可以得知，FileOwner就是这个xib所属的controller,如果他没有所属的controller，那么调用这个xib的controller就是他的File Owner，所以上面的代码里面的owner我们一直保持为nil就可以了\n \n### 关于网络获取与数据本地化\n\n1. 关于网络方面的话我之前写过一份xmind，大概流程是这样子的\n\t- 首先定义一个布尔变量，判断是否有存档\n\t- viewDidLoad 取档并刷新数据\n\t- viewWillAppear 中执行 loadDataFromNet\n\t- loadDataFromNet方法中判断是否有存档，没有存档并且获取网络数据失败的时候才提示数据刷新失败\n\t\n\t示例如下\n\t\n\t* 这里用NSCachesDirectory，也就是缓存目录，关于目录的选择看有道云笔记，上面有比较详细的说明 \n\t\n\t```\n\t #define XXFileName [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:@\"xx.data\"]\n\t- (void)viewDidLoad {\t\n\t\t [super viewDidLoad];\n\t\t // 取档\n\t    \tself.dataArray = [NSKeyedUnarchiver unarchiveObjectWithFile:XXFileName];\n\t    \n\t\t if (self.dataArray) {\n\t   \t\t[self.tableView reloadData];\n\t   \t\thasArchive = YES;\n\t\t}else{\n\t    \thasArchive = NO;\n\t    \t// 转菊花  或者 下拉刷新也行 \n\t    \t[SVProgressHUD setDefaultMaskType:SVProgressHUDMaskTypeBlack];\n\t \t    [SVProgressHUD show];\n\t\t}\n\t\t[self loadDataFromNet];\n\t}\n\t- (void)viewWillAppear:(BOOL)animated\n\t{\n\t    **如果能保证这个controller每次进来都会经过viewDidLoad(例如本身自己就是子控制器且自己也没有子控制器)则这里就不用写了**\n\t\t[self loadDataFromNet];\n\t}\t\n\t- (void)loadDataFromNet\n\t{\n\t\t[XXTool fetchMsg:^(XXData *data) {\n\t  \t\tself.data = data;\n\t    \t// 归档\n\t    \t[NSKeyedArchiver archiveRootObject:profile toFile:XXFileName];\n\t    \tdispatch_async(dispatch_get_main_queue(), ^{\n\t    \t\t[SVProgressHUD dismiss];\n\t        \t[self.tableView reloadData];\n\t    \t});\n\t\t } failure:^(NSError *error) {\n\t    \tNSLog(@\"%@\",error);\n\t    \tdispatch_async(dispatch_get_main_queue(), ^{\n\t    \t    if(!_hasArchive)[SVProgressHUD showErrorWithStatus:@\"加载失败\"];\n\t    \t});\n\t\t}];\n\t}\n\t```\n \t* 不过做项目的时候还是看实际情况进行调整吧，上面所说的只是一般情况下的网络处理\n\n\t近期稍微地研究了一下Runtime框架，加上一点脑洞和MJExtendsion的配合，感觉可以做出一个框架，能够实现获取数据之后直接生成跟远程数据库结构相同的本地数据库，一方面可以避开类似salesForce的SOQL语句无法进行多表查询之类的恶心问题，另一方面做数据筛选功能的时候也会简单很多，这个就待我去看看能不能搞出来\n\t\n### 关于单例\n1. 在这个项目里面我导入了一个外部框架（应该说是一个文件？）：Singleton.h\n这个东西使用起来很爽\n只要在你想单例的类的声明h里加 singleton_interface（类名）\n实现m里加 singleton_implementation（类名)\n就可以了\n之后你想调用这个类的时候就直接 [ClassName sharedClassName] 就可以直接获得到这个类的单例\n\n2. 什么情况下要用到单例？\n以案场这个为例子，我每次获取数据都需要加上限制条件，筛选当前项目下和当前登录用户的数据\n那么我就会频繁使用到projectId 和 userId ，__并且这两个值基本不变__\n所以我就给这个单例写了两个方法\n\n\t```\n\t- (NSString *)currentProjectId;\n\t- (NSString *)userId;\n\t- (CMProject *)currentProject\n\t{\t\n\t CMProject*currentProject = [NSKeyedUnarchiverunarchiveObjectWithFile:CMSelectProjectFileName];\n\t   \treturn currentProject;\n\t}\n\t\n\t- (NSString *)userId{ \n\treturn [SFUserAccountManager sharedInstance].currentUser.credentials.userId;\n\t}\n\t\n\t//使用\n\t[[CMUserTool sharedCMUserTool] userId];\n\t```\n\t\n### 关于传值\n\n1. 传值有三宝：代理、通知、block 另外还有storyboard专用segue传值和成员属性传值等，因为前三个比较重要所以我就说说前三个的使用\n\t- 代理用来两个视图之间的传值，最常用的就是自定义view上面的点击事件通过代理告诉调用它的controller，因为一个界面只能有一个controller，一般我们都是抽出另一个controller的view添加到这个controller上面，所以这时候就要用代理进行两个controller之间的数据传递\n通知，先说说使用方法\n\n\t```\n\t**消息接收方**\n\t[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(方法名) name:消息名 object:nil];\n\t\n\t**消息发送方**\n\t//创建一个消息对象\n\tNSNotification * notice = [NSNotification notificationWithName:消息名 object:nil userInfo:nil];\n\t//发送消息\n\t[[NSNotificationCenter defaultCenter]postNotification:notice];\n\t移除通知 \n\t\n\t移除单个通知\n\t[[NSNotificationCenter defaultCenter] removeObserver:self name:消息名 object:self];\n\t\n\t移除当前所有通知:[[NSNotificationCenterdefaultCenter]removeObserver:self];\n\t```\n\n\t但是优缺点并存\n\t\n\t> 优势：\n\t>\n\t> 1. 不需要编写多少代码，实现比较简单\n\t> 2. 对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单\n\t> 3. controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息\n\t\n\t> 缺点：\n\t>\n\t> 1. 在编译期不会检查通知是否能够被观察者正确的处理； \n\t> 2. 在释放注册的对象时，需要在通知中心取消注册；\n\t> 3. 在调试的时候应用的工作以及控制过程难跟踪；\n\t> 4. 需要第三方对象来管理controller与观察者对象之间的联系；\n\t> 5. controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；\n\t> 6. 通知发出后，controller不能从观察者获得任何的反馈信息。\n\t\n\n\t- block 用于反向传值，就是在子控制器操作数据后传值回到父控制器，这时候我们用block，不过block传值也有坑，很容易引起循环引用然后烧内存。解决方法就是用weak修饰对象比如 ` weak typeof(self) weakSelf = self `\n这样子我们用weakSelf.对象就不会引起循环引用\n\t\t- 还有block有一个小地方要注意，如果要在block里面调用外部变量的话，要给外部变量加一个__block修饰符\n\n### 关于枚举\n\n枚举不用讲太多，枚举就是为了方便判断而已，但是命名规范还是要说的,举个栗子\n\n```\ntypedef enum : NSUInteger {\n     CMRelatedTypeOpportunity,\n     CMRelatedTypeBooking,\n     CMRelatedTypeSalesOrder,\n     CMRelatedTypeContract,\n     CMRelatedTypeCollection,\n     CMRelatedTypeTrade\n } CMRelatedType;\n```\n \n枚举的成员名 = 枚举名 + 类型名\n\n### 关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller\n\n案场那个客户界是这个app中逻辑最复杂的一个界面，虽然通过了枚举的判断方便了一个代码的阅读，但总的来说上千行代码着实还是恶心。\n类似的场景应该以后应该还会经常发生，但是虽然开发的时候可能方便了但是维护起来也太费劲了，并且之前项目的种种维护的体验也告诉了我们一个事实：MVC框架不够用了\n\n所以——我们还是换个架构吧~\n\n我大概考虑了一下，逻辑层还是尽可能的细分，多几个类都行，然后耦合性应该低\n之前我们就已经习惯了把业务层从controller中抽取出来,这种方式应该保留\n然后我们可以尝试引入MVCS架构以及MVVM架构等，具体的demo应该会在近期实现","slug":"关于案场管家的技术点总结","published":1,"updated":"2018-05-10T06:51:35.762Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cji9qbcw50078ldxu8mafvd66","content":"<p>案场管家的技术点总结</p>\n<a id=\"more\"></a>\n<h3 id=\"xib与storyboard\"><a href=\"#xib与storyboard\" class=\"headerlink\" title=\"xib与storyboard\"></a>xib与storyboard</h3><ol>\n<li><p>xib和storyboard均是用于布局所用，其实如果不需要过于复杂的布局的话完全也可以时候用masonry或者直接CGRect定位亦或者NSNSLayoutConstraint进行布局，如果要用代码的话个人觉得masonry是非常好用的，并且该框架所使用的函数式编程思想和链式编程思想也是值得学习的</p>\n</li>\n<li><p>storyboard的作用类似于包含多个xib+视图管理，代码调用storyboard里面的控制器的代码如下</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIStoryboard *stroyboard = [UIStoryboard storyboardWithName:&quot;storyboard的文件名&quot; bundle:nil];</span><br><span class=\"line\">XXXViewController *vc = [storyboard instantiateViewControllerWithIdentifier:“contorller的storyboard Id”];</span><br></pre></td></tr></table></figure>\n<p> 如果是controller类xib，那么就直接 alloc init 一个该xib所绑定的controller就可以了<br> 如果是view类xib</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[[NSBundle mainBundle] loadNibNamed:@&quot;CMBuildingCell&quot; owner:nil options:nil] firstObject]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>之前曾经遇到过一个bug，从xib拖线到类文件的时候他会报错，原因是如果你的xib绑定的是一个继承UIView的类（比如一个cell），那么File Owner就应该保持为空，父view绑定类；如果绑定的是一个controller类，那父view绑定为空，File Owner绑定类，从以上说明我们可以得知，FileOwner就是这个xib所属的controller,如果他没有所属的controller，那么调用这个xib的controller就是他的File Owner，所以上面的代码里面的owner我们一直保持为nil就可以了</p>\n</li>\n</ol>\n<h3 id=\"关于网络获取与数据本地化\"><a href=\"#关于网络获取与数据本地化\" class=\"headerlink\" title=\"关于网络获取与数据本地化\"></a>关于网络获取与数据本地化</h3><ol>\n<li><p>关于网络方面的话我之前写过一份xmind，大概流程是这样子的</p>\n<ul>\n<li>首先定义一个布尔变量，判断是否有存档</li>\n<li>viewDidLoad 取档并刷新数据</li>\n<li>viewWillAppear 中执行 loadDataFromNet</li>\n<li><p>loadDataFromNet方法中判断是否有存档，没有存档并且获取网络数据失败的时候才提示数据刷新失败</p>\n<p>示例如下</p>\n</li>\n</ul>\n<ul>\n<li><p>这里用NSCachesDirectory，也就是缓存目录，关于目录的选择看有道云笔记，上面有比较详细的说明 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> #define XXFileName [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:@&quot;xx.data&quot;]</span><br><span class=\"line\">- (void)viewDidLoad &#123;\t</span><br><span class=\"line\">\t [super viewDidLoad];</span><br><span class=\"line\">\t // 取档</span><br><span class=\"line\">    \tself.dataArray = [NSKeyedUnarchiver unarchiveObjectWithFile:XXFileName];</span><br><span class=\"line\">    </span><br><span class=\"line\">\t if (self.dataArray) &#123;</span><br><span class=\"line\">   \t\t[self.tableView reloadData];</span><br><span class=\"line\">   \t\thasArchive = YES;</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">    \thasArchive = NO;</span><br><span class=\"line\">    \t// 转菊花  或者 下拉刷新也行 </span><br><span class=\"line\">    \t[SVProgressHUD setDefaultMaskType:SVProgressHUDMaskTypeBlack];</span><br><span class=\"line\"> \t    [SVProgressHUD show];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t[self loadDataFromNet];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)viewWillAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    **如果能保证这个controller每次进来都会经过viewDidLoad(例如本身自己就是子控制器且自己也没有子控制器)则这里就不用写了**</span><br><span class=\"line\">\t[self loadDataFromNet];</span><br><span class=\"line\">&#125;\t</span><br><span class=\"line\">- (void)loadDataFromNet</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[XXTool fetchMsg:^(XXData *data) &#123;</span><br><span class=\"line\">  \t\tself.data = data;</span><br><span class=\"line\">    \t// 归档</span><br><span class=\"line\">    \t[NSKeyedArchiver archiveRootObject:profile toFile:XXFileName];</span><br><span class=\"line\">    \tdispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    \t\t[SVProgressHUD dismiss];</span><br><span class=\"line\">        \t[self.tableView reloadData];</span><br><span class=\"line\">    \t&#125;);</span><br><span class=\"line\">\t &#125; failure:^(NSError *error) &#123;</span><br><span class=\"line\">    \tNSLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">    \tdispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    \t    if(!_hasArchive)[SVProgressHUD showErrorWithStatus:@&quot;加载失败&quot;];</span><br><span class=\"line\">    \t&#125;);</span><br><span class=\"line\">\t&#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>不过做项目的时候还是看实际情况进行调整吧，上面所说的只是一般情况下的网络处理</li>\n</ul>\n<p>近期稍微地研究了一下Runtime框架，加上一点脑洞和MJExtendsion的配合，感觉可以做出一个框架，能够实现获取数据之后直接生成跟远程数据库结构相同的本地数据库，一方面可以避开类似salesForce的SOQL语句无法进行多表查询之类的恶心问题，另一方面做数据筛选功能的时候也会简单很多，这个就待我去看看能不能搞出来</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"关于单例\"><a href=\"#关于单例\" class=\"headerlink\" title=\"关于单例\"></a>关于单例</h3><ol>\n<li><p>在这个项目里面我导入了一个外部框架（应该说是一个文件？）：Singleton.h<br>这个东西使用起来很爽<br>只要在你想单例的类的声明h里加 singleton_interface（类名）<br>实现m里加 singleton_implementation（类名)<br>就可以了<br>之后你想调用这个类的时候就直接 [ClassName sharedClassName] 就可以直接获得到这个类的单例</p>\n</li>\n<li><p>什么情况下要用到单例？<br>以案场这个为例子，我每次获取数据都需要加上限制条件，筛选当前项目下和当前登录用户的数据<br>那么我就会频繁使用到projectId 和 userId ，<strong>并且这两个值基本不变</strong><br>所以我就给这个单例写了两个方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSString *)currentProjectId;</span><br><span class=\"line\">- (NSString *)userId;</span><br><span class=\"line\">- (CMProject *)currentProject</span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\"> CMProject*currentProject = [NSKeyedUnarchiverunarchiveObjectWithFile:CMSelectProjectFileName];</span><br><span class=\"line\">   \treturn currentProject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)userId&#123; </span><br><span class=\"line\">return [SFUserAccountManager sharedInstance].currentUser.credentials.userId;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//使用</span><br><span class=\"line\">[[CMUserTool sharedCMUserTool] userId];</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"关于传值\"><a href=\"#关于传值\" class=\"headerlink\" title=\"关于传值\"></a>关于传值</h3><ol>\n<li><p>传值有三宝：代理、通知、block 另外还有storyboard专用segue传值和成员属性传值等，因为前三个比较重要所以我就说说前三个的使用</p>\n<ul>\n<li><p>代理用来两个视图之间的传值，最常用的就是自定义view上面的点击事件通过代理告诉调用它的controller，因为一个界面只能有一个controller，一般我们都是抽出另一个controller的view添加到这个controller上面，所以这时候就要用代理进行两个controller之间的数据传递<br>通知，先说说使用方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**消息接收方**</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(方法名) name:消息名 object:nil];</span><br><span class=\"line\"></span><br><span class=\"line\">**消息发送方**</span><br><span class=\"line\">//创建一个消息对象</span><br><span class=\"line\">NSNotification * notice = [NSNotification notificationWithName:消息名 object:nil userInfo:nil];</span><br><span class=\"line\">//发送消息</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter]postNotification:notice];</span><br><span class=\"line\">移除通知 </span><br><span class=\"line\"></span><br><span class=\"line\">移除单个通知</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter] removeObserver:self name:消息名 object:self];</span><br><span class=\"line\"></span><br><span class=\"line\">移除当前所有通知:[[NSNotificationCenterdefaultCenter]removeObserver:self];</span><br></pre></td></tr></table></figure>\n<p>但是优缺点并存</p>\n<blockquote>\n<p>优势：</p>\n<ol>\n<li>不需要编写多少代码，实现比较简单</li>\n<li>对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单</li>\n<li>controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>在编译期不会检查通知是否能够被观察者正确的处理； </li>\n<li>在释放注册的对象时，需要在通知中心取消注册；</li>\n<li>在调试的时候应用的工作以及控制过程难跟踪；</li>\n<li>需要第三方对象来管理controller与观察者对象之间的联系；</li>\n<li>controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；</li>\n<li>通知发出后，controller不能从观察者获得任何的反馈信息。</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<pre><code>- block 用于反向传值，就是在子控制器操作数据后传值回到父控制器，这时候我们用block，不过block传值也有坑，很容易引起循环引用然后烧内存。解决方法就是用weak修饰对象比如 ` weak typeof(self) weakSelf = self `\n</code></pre><p>这样子我们用weakSelf.对象就不会引起循环引用</p>\n<pre><code>- 还有block有一个小地方要注意，如果要在block里面调用外部变量的话，要给外部变量加一个__block修饰符\n</code></pre><h3 id=\"关于枚举\"><a href=\"#关于枚举\" class=\"headerlink\" title=\"关于枚举\"></a>关于枚举</h3><p>枚举不用讲太多，枚举就是为了方便判断而已，但是命名规范还是要说的,举个栗子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef enum : NSUInteger &#123;</span><br><span class=\"line\">     CMRelatedTypeOpportunity,</span><br><span class=\"line\">     CMRelatedTypeBooking,</span><br><span class=\"line\">     CMRelatedTypeSalesOrder,</span><br><span class=\"line\">     CMRelatedTypeContract,</span><br><span class=\"line\">     CMRelatedTypeCollection,</span><br><span class=\"line\">     CMRelatedTypeTrade</span><br><span class=\"line\"> &#125; CMRelatedType;</span><br></pre></td></tr></table></figure>\n<p>枚举的成员名 = 枚举名 + 类型名</p>\n<h3 id=\"关于案场的客户界面-——-复杂的逻辑-TO-一个Controller\"><a href=\"#关于案场的客户界面-——-复杂的逻辑-TO-一个Controller\" class=\"headerlink\" title=\"关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller\"></a>关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller</h3><p>案场那个客户界是这个app中逻辑最复杂的一个界面，虽然通过了枚举的判断方便了一个代码的阅读，但总的来说上千行代码着实还是恶心。<br>类似的场景应该以后应该还会经常发生，但是虽然开发的时候可能方便了但是维护起来也太费劲了，并且之前项目的种种维护的体验也告诉了我们一个事实：MVC框架不够用了</p>\n<p>所以——我们还是换个架构吧~</p>\n<p>我大概考虑了一下，逻辑层还是尽可能的细分，多几个类都行，然后耦合性应该低<br>之前我们就已经习惯了把业务层从controller中抽取出来,这种方式应该保留<br>然后我们可以尝试引入MVCS架构以及MVVM架构等，具体的demo应该会在近期实现</p>\n","site":{"data":{}},"excerpt":"<p>案场管家的技术点总结</p>","more":"<h3 id=\"xib与storyboard\"><a href=\"#xib与storyboard\" class=\"headerlink\" title=\"xib与storyboard\"></a>xib与storyboard</h3><ol>\n<li><p>xib和storyboard均是用于布局所用，其实如果不需要过于复杂的布局的话完全也可以时候用masonry或者直接CGRect定位亦或者NSNSLayoutConstraint进行布局，如果要用代码的话个人觉得masonry是非常好用的，并且该框架所使用的函数式编程思想和链式编程思想也是值得学习的</p>\n</li>\n<li><p>storyboard的作用类似于包含多个xib+视图管理，代码调用storyboard里面的控制器的代码如下</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIStoryboard *stroyboard = [UIStoryboard storyboardWithName:&quot;storyboard的文件名&quot; bundle:nil];</span><br><span class=\"line\">XXXViewController *vc = [storyboard instantiateViewControllerWithIdentifier:“contorller的storyboard Id”];</span><br></pre></td></tr></table></figure>\n<p> 如果是controller类xib，那么就直接 alloc init 一个该xib所绑定的controller就可以了<br> 如果是view类xib</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[[NSBundle mainBundle] loadNibNamed:@&quot;CMBuildingCell&quot; owner:nil options:nil] firstObject]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>之前曾经遇到过一个bug，从xib拖线到类文件的时候他会报错，原因是如果你的xib绑定的是一个继承UIView的类（比如一个cell），那么File Owner就应该保持为空，父view绑定类；如果绑定的是一个controller类，那父view绑定为空，File Owner绑定类，从以上说明我们可以得知，FileOwner就是这个xib所属的controller,如果他没有所属的controller，那么调用这个xib的controller就是他的File Owner，所以上面的代码里面的owner我们一直保持为nil就可以了</p>\n</li>\n</ol>\n<h3 id=\"关于网络获取与数据本地化\"><a href=\"#关于网络获取与数据本地化\" class=\"headerlink\" title=\"关于网络获取与数据本地化\"></a>关于网络获取与数据本地化</h3><ol>\n<li><p>关于网络方面的话我之前写过一份xmind，大概流程是这样子的</p>\n<ul>\n<li>首先定义一个布尔变量，判断是否有存档</li>\n<li>viewDidLoad 取档并刷新数据</li>\n<li>viewWillAppear 中执行 loadDataFromNet</li>\n<li><p>loadDataFromNet方法中判断是否有存档，没有存档并且获取网络数据失败的时候才提示数据刷新失败</p>\n<p>示例如下</p>\n</li>\n</ul>\n<ul>\n<li><p>这里用NSCachesDirectory，也就是缓存目录，关于目录的选择看有道云笔记，上面有比较详细的说明 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> #define XXFileName [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:@&quot;xx.data&quot;]</span><br><span class=\"line\">- (void)viewDidLoad &#123;\t</span><br><span class=\"line\">\t [super viewDidLoad];</span><br><span class=\"line\">\t // 取档</span><br><span class=\"line\">    \tself.dataArray = [NSKeyedUnarchiver unarchiveObjectWithFile:XXFileName];</span><br><span class=\"line\">    </span><br><span class=\"line\">\t if (self.dataArray) &#123;</span><br><span class=\"line\">   \t\t[self.tableView reloadData];</span><br><span class=\"line\">   \t\thasArchive = YES;</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">    \thasArchive = NO;</span><br><span class=\"line\">    \t// 转菊花  或者 下拉刷新也行 </span><br><span class=\"line\">    \t[SVProgressHUD setDefaultMaskType:SVProgressHUDMaskTypeBlack];</span><br><span class=\"line\"> \t    [SVProgressHUD show];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t[self loadDataFromNet];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)viewWillAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    **如果能保证这个controller每次进来都会经过viewDidLoad(例如本身自己就是子控制器且自己也没有子控制器)则这里就不用写了**</span><br><span class=\"line\">\t[self loadDataFromNet];</span><br><span class=\"line\">&#125;\t</span><br><span class=\"line\">- (void)loadDataFromNet</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[XXTool fetchMsg:^(XXData *data) &#123;</span><br><span class=\"line\">  \t\tself.data = data;</span><br><span class=\"line\">    \t// 归档</span><br><span class=\"line\">    \t[NSKeyedArchiver archiveRootObject:profile toFile:XXFileName];</span><br><span class=\"line\">    \tdispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    \t\t[SVProgressHUD dismiss];</span><br><span class=\"line\">        \t[self.tableView reloadData];</span><br><span class=\"line\">    \t&#125;);</span><br><span class=\"line\">\t &#125; failure:^(NSError *error) &#123;</span><br><span class=\"line\">    \tNSLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">    \tdispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    \t    if(!_hasArchive)[SVProgressHUD showErrorWithStatus:@&quot;加载失败&quot;];</span><br><span class=\"line\">    \t&#125;);</span><br><span class=\"line\">\t&#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>不过做项目的时候还是看实际情况进行调整吧，上面所说的只是一般情况下的网络处理</li>\n</ul>\n<p>近期稍微地研究了一下Runtime框架，加上一点脑洞和MJExtendsion的配合，感觉可以做出一个框架，能够实现获取数据之后直接生成跟远程数据库结构相同的本地数据库，一方面可以避开类似salesForce的SOQL语句无法进行多表查询之类的恶心问题，另一方面做数据筛选功能的时候也会简单很多，这个就待我去看看能不能搞出来</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"关于单例\"><a href=\"#关于单例\" class=\"headerlink\" title=\"关于单例\"></a>关于单例</h3><ol>\n<li><p>在这个项目里面我导入了一个外部框架（应该说是一个文件？）：Singleton.h<br>这个东西使用起来很爽<br>只要在你想单例的类的声明h里加 singleton_interface（类名）<br>实现m里加 singleton_implementation（类名)<br>就可以了<br>之后你想调用这个类的时候就直接 [ClassName sharedClassName] 就可以直接获得到这个类的单例</p>\n</li>\n<li><p>什么情况下要用到单例？<br>以案场这个为例子，我每次获取数据都需要加上限制条件，筛选当前项目下和当前登录用户的数据<br>那么我就会频繁使用到projectId 和 userId ，<strong>并且这两个值基本不变</strong><br>所以我就给这个单例写了两个方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSString *)currentProjectId;</span><br><span class=\"line\">- (NSString *)userId;</span><br><span class=\"line\">- (CMProject *)currentProject</span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\"> CMProject*currentProject = [NSKeyedUnarchiverunarchiveObjectWithFile:CMSelectProjectFileName];</span><br><span class=\"line\">   \treturn currentProject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)userId&#123; </span><br><span class=\"line\">return [SFUserAccountManager sharedInstance].currentUser.credentials.userId;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//使用</span><br><span class=\"line\">[[CMUserTool sharedCMUserTool] userId];</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"关于传值\"><a href=\"#关于传值\" class=\"headerlink\" title=\"关于传值\"></a>关于传值</h3><ol>\n<li><p>传值有三宝：代理、通知、block 另外还有storyboard专用segue传值和成员属性传值等，因为前三个比较重要所以我就说说前三个的使用</p>\n<ul>\n<li><p>代理用来两个视图之间的传值，最常用的就是自定义view上面的点击事件通过代理告诉调用它的controller，因为一个界面只能有一个controller，一般我们都是抽出另一个controller的view添加到这个controller上面，所以这时候就要用代理进行两个controller之间的数据传递<br>通知，先说说使用方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**消息接收方**</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(方法名) name:消息名 object:nil];</span><br><span class=\"line\"></span><br><span class=\"line\">**消息发送方**</span><br><span class=\"line\">//创建一个消息对象</span><br><span class=\"line\">NSNotification * notice = [NSNotification notificationWithName:消息名 object:nil userInfo:nil];</span><br><span class=\"line\">//发送消息</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter]postNotification:notice];</span><br><span class=\"line\">移除通知 </span><br><span class=\"line\"></span><br><span class=\"line\">移除单个通知</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter] removeObserver:self name:消息名 object:self];</span><br><span class=\"line\"></span><br><span class=\"line\">移除当前所有通知:[[NSNotificationCenterdefaultCenter]removeObserver:self];</span><br></pre></td></tr></table></figure>\n<p>但是优缺点并存</p>\n<blockquote>\n<p>优势：</p>\n<ol>\n<li>不需要编写多少代码，实现比较简单</li>\n<li>对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单</li>\n<li>controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>在编译期不会检查通知是否能够被观察者正确的处理； </li>\n<li>在释放注册的对象时，需要在通知中心取消注册；</li>\n<li>在调试的时候应用的工作以及控制过程难跟踪；</li>\n<li>需要第三方对象来管理controller与观察者对象之间的联系；</li>\n<li>controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；</li>\n<li>通知发出后，controller不能从观察者获得任何的反馈信息。</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<pre><code>- block 用于反向传值，就是在子控制器操作数据后传值回到父控制器，这时候我们用block，不过block传值也有坑，很容易引起循环引用然后烧内存。解决方法就是用weak修饰对象比如 ` weak typeof(self) weakSelf = self `\n</code></pre><p>这样子我们用weakSelf.对象就不会引起循环引用</p>\n<pre><code>- 还有block有一个小地方要注意，如果要在block里面调用外部变量的话，要给外部变量加一个__block修饰符\n</code></pre><h3 id=\"关于枚举\"><a href=\"#关于枚举\" class=\"headerlink\" title=\"关于枚举\"></a>关于枚举</h3><p>枚举不用讲太多，枚举就是为了方便判断而已，但是命名规范还是要说的,举个栗子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef enum : NSUInteger &#123;</span><br><span class=\"line\">     CMRelatedTypeOpportunity,</span><br><span class=\"line\">     CMRelatedTypeBooking,</span><br><span class=\"line\">     CMRelatedTypeSalesOrder,</span><br><span class=\"line\">     CMRelatedTypeContract,</span><br><span class=\"line\">     CMRelatedTypeCollection,</span><br><span class=\"line\">     CMRelatedTypeTrade</span><br><span class=\"line\"> &#125; CMRelatedType;</span><br></pre></td></tr></table></figure>\n<p>枚举的成员名 = 枚举名 + 类型名</p>\n<h3 id=\"关于案场的客户界面-——-复杂的逻辑-TO-一个Controller\"><a href=\"#关于案场的客户界面-——-复杂的逻辑-TO-一个Controller\" class=\"headerlink\" title=\"关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller\"></a>关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller</h3><p>案场那个客户界是这个app中逻辑最复杂的一个界面，虽然通过了枚举的判断方便了一个代码的阅读，但总的来说上千行代码着实还是恶心。<br>类似的场景应该以后应该还会经常发生，但是虽然开发的时候可能方便了但是维护起来也太费劲了，并且之前项目的种种维护的体验也告诉了我们一个事实：MVC框架不够用了</p>\n<p>所以——我们还是换个架构吧~</p>\n<p>我大概考虑了一下，逻辑层还是尽可能的细分，多几个类都行，然后耦合性应该低<br>之前我们就已经习惯了把业务层从controller中抽取出来,这种方式应该保留<br>然后我们可以尝试引入MVCS架构以及MVVM架构等，具体的demo应该会在近期实现</p>"},{"title":"Jenkins分布式构建笔记","author":"Arclin","abbrlink":"34e5df37","date":"2018-06-11T04:00:00.000Z","_content":"","source":"_drafts/Jenkins分布式构建笔记.md","raw":"title: Jenkins分布式构建笔记\nauthor: Arclin\nabbrlink: 34e5df37\ntags:\n  - Jenkins\ncategories:\n  - Jenkins\ndate: 2018-06-11 12:00:00\n---\n","slug":"Jenkins分布式构建笔记","published":0,"updated":"2018-06-11T04:01:43.150Z","_id":"cji9qck8a007lldxup7hysc01","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"application","title":"Application Loader / Fastlane pilot 通过代理上传方案","date":"2018-08-03T08:10:07.000Z","_content":"\n## Application Loader / Fastlane pilot 通过代理上传方案\n\n### 需求分析\n\n为了避免苹果审核马甲包情况, 我们需要通过其他IP去上传包, 这里提供几种方案并记录踩坑过程.\n\n<!-- more -->\n\n### 问题解决思路\n\n1. 用Application Loader(后面简称uploader)上传包, 电脑使用SS, VPN会导致上传失败, 原因是uploader内部自带开启代理配置, 但是默认是关闭的,  所以需要修改内部代理配置, 路径是`/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/java/lib/net.properties`, 配置如下(1086是本地ss的端口)\n\t\n\t```\n\tjava.net.useSystemProxies=true\n\thttp.proxyHost=127.0.0.1\n\thttp.proxyPort=1086\n\thttps.proxyHost=127.0.0.1\n\thttps.proxyPort=1086\n\tjdk.http.auth.tunneling.disabledSchemes=Basic\n\t```\n\t\n2. 本来`net.properties`内是有socks代理的配置的, Shadowsocks开启socks代理后, 在配置文件中配置好ip(127.0.0.1)和端口(1086)之后测试发现无法连接到苹果服务器, 故只能选用`http/https`代理\n\t> 查询shadowsocks本地端口的方法, 执行`lsof -iTCP -sTCP:LISTEN -n -P | grep ss-local`, 就可以查到\n\t\n3. 现在问题在于怎么将socks代理转成http/https代理, 通过查阅资料得知可以通过安装`privoxy`解决, 安装之后配置`/usr/local/etc/privoxy/config`文件, 把`forward-socks5t`那行注释掉, 加上本地socks ip和端口, 就像下面那段一样, 然后把`listen-address  127.0.0.1:8118` 改成 `listen-address  0.0.0.0:8118`就可以实现给局域网内共享你的代理.\n\n\t```\n\tforward           /               127.0.0.1:1086 .\n\tforward-socks4    /               127.0.0.1:1086 .\n\tforward-socks4a   /               127.0.0.1:1086 .\n\tforward-socks5    /               127.0.0.1:1086 .\n\tforward-socks5t   /               127.0.0.1:1086 .\n\t```\n\t\n4. 打开`系统偏好设置-网络-高级-代理`, 把网页代理和安全网页代理勾上, 填上ip `127.0.0.1` 端口 `8118` , 就可以了.  这里的`8118`是刚刚说到的`listen-address  0.0.0.0:8118`里面的端口号, 要改也可以改, 记得同步就行.\n\n### 校验\n\n1. 校验`privoxy`是否代理成功可以通过浏览器访问`http://config.privoxy.org/`这个网址就能看到成功与否了\n\n2. 执行`netstat -an | grep 8118` 查看`8188`是否全局监听着, 如果是就会看到\n\t`tcp4       0      0  *.8118                 *.*                    LISTEN  `执行`ps aux | grep privoxy`, 则可以看到`privoxy`进程是否正在运行中. 可以通过`sudo /Applications/Privoxy/stopPrivoxy.sh`停止`privoxy`和`sudo /Applications/Privoxy/startPrivoxy.sh`启动`privoxy`\n\t\n3. 浏览器访问`https://ip.cn`,就可以得知网页代理是否成功了\n\t\n4. fastlane上传包实际上是调用了`/Applications/Xcode.app/Contents/Applications/Application\\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool`, 也就是Xcode自带的命令行工具 , uploader就不用说了, 反正殊途同归, 最后都会根据`net.properties`去走代理,  那么问题来了 , 如何验证命令行和桌面应用uploader走的都是代理方式呢. 很遗憾苹果并不会弄出一个界面或者打印出一行log告诉你现在是用哪个ip上传, 我现在能想到的办法是通过工具查看上传过程中的流量波动, 通过实验, 两种方式再上传过程中, `ss-local`进程有过较大数据上传的流量波动(会有100k/s以上的上传流量速度), 因此我判定确实是走了代理上传包的.  如果要再证据确凿的话, 只能想办法抓包查看他的信息收集了, 但是`Charles`抓包的原理是再开一个代理, 会造成混乱....所以这就很头疼了.\n\n5. 开启了网页代理之后, 影响的只是网页, 实际上只是为了验证`Privoxy`的可用性, 开启之后你如果在命令行中使用`curl ip.cn`得到的结果会是你真实网络的出网ip, 而不是你想要的代理的ip, 实际上`uploader`和`fastlane pilot`命令行是否真正走了代理, 目前我只能通过`ss-local`这个代理的进程查看他的上传流量去判断, 具有一定风险. 或者通过安装命令行工具`proxychains`, 然后执行`proxychains4 fastlane pilot upload`传包, 但是这种方式100%上传失败 , 原因猜想是`net.properties`的配置没改, `proxychains`怎么转发请求都没用.  所以这是不是从某种意义上证明了`fastlane pilot`是走`net.properties`配置的呢, 至少我觉得按照目前情况可以这么认为,  后续如果有想法我会进行更多实验去证明的.","source":"_posts/通过代理上传方案.md","raw":"---\nlayout: application\ntitle:  Application Loader / Fastlane pilot 通过代理上传方案\ndate: 2018-08-03 16:10:07\ntags: iOS\n---\n\n## Application Loader / Fastlane pilot 通过代理上传方案\n\n### 需求分析\n\n为了避免苹果审核马甲包情况, 我们需要通过其他IP去上传包, 这里提供几种方案并记录踩坑过程.\n\n<!-- more -->\n\n### 问题解决思路\n\n1. 用Application Loader(后面简称uploader)上传包, 电脑使用SS, VPN会导致上传失败, 原因是uploader内部自带开启代理配置, 但是默认是关闭的,  所以需要修改内部代理配置, 路径是`/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/java/lib/net.properties`, 配置如下(1086是本地ss的端口)\n\t\n\t```\n\tjava.net.useSystemProxies=true\n\thttp.proxyHost=127.0.0.1\n\thttp.proxyPort=1086\n\thttps.proxyHost=127.0.0.1\n\thttps.proxyPort=1086\n\tjdk.http.auth.tunneling.disabledSchemes=Basic\n\t```\n\t\n2. 本来`net.properties`内是有socks代理的配置的, Shadowsocks开启socks代理后, 在配置文件中配置好ip(127.0.0.1)和端口(1086)之后测试发现无法连接到苹果服务器, 故只能选用`http/https`代理\n\t> 查询shadowsocks本地端口的方法, 执行`lsof -iTCP -sTCP:LISTEN -n -P | grep ss-local`, 就可以查到\n\t\n3. 现在问题在于怎么将socks代理转成http/https代理, 通过查阅资料得知可以通过安装`privoxy`解决, 安装之后配置`/usr/local/etc/privoxy/config`文件, 把`forward-socks5t`那行注释掉, 加上本地socks ip和端口, 就像下面那段一样, 然后把`listen-address  127.0.0.1:8118` 改成 `listen-address  0.0.0.0:8118`就可以实现给局域网内共享你的代理.\n\n\t```\n\tforward           /               127.0.0.1:1086 .\n\tforward-socks4    /               127.0.0.1:1086 .\n\tforward-socks4a   /               127.0.0.1:1086 .\n\tforward-socks5    /               127.0.0.1:1086 .\n\tforward-socks5t   /               127.0.0.1:1086 .\n\t```\n\t\n4. 打开`系统偏好设置-网络-高级-代理`, 把网页代理和安全网页代理勾上, 填上ip `127.0.0.1` 端口 `8118` , 就可以了.  这里的`8118`是刚刚说到的`listen-address  0.0.0.0:8118`里面的端口号, 要改也可以改, 记得同步就行.\n\n### 校验\n\n1. 校验`privoxy`是否代理成功可以通过浏览器访问`http://config.privoxy.org/`这个网址就能看到成功与否了\n\n2. 执行`netstat -an | grep 8118` 查看`8188`是否全局监听着, 如果是就会看到\n\t`tcp4       0      0  *.8118                 *.*                    LISTEN  `执行`ps aux | grep privoxy`, 则可以看到`privoxy`进程是否正在运行中. 可以通过`sudo /Applications/Privoxy/stopPrivoxy.sh`停止`privoxy`和`sudo /Applications/Privoxy/startPrivoxy.sh`启动`privoxy`\n\t\n3. 浏览器访问`https://ip.cn`,就可以得知网页代理是否成功了\n\t\n4. fastlane上传包实际上是调用了`/Applications/Xcode.app/Contents/Applications/Application\\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool`, 也就是Xcode自带的命令行工具 , uploader就不用说了, 反正殊途同归, 最后都会根据`net.properties`去走代理,  那么问题来了 , 如何验证命令行和桌面应用uploader走的都是代理方式呢. 很遗憾苹果并不会弄出一个界面或者打印出一行log告诉你现在是用哪个ip上传, 我现在能想到的办法是通过工具查看上传过程中的流量波动, 通过实验, 两种方式再上传过程中, `ss-local`进程有过较大数据上传的流量波动(会有100k/s以上的上传流量速度), 因此我判定确实是走了代理上传包的.  如果要再证据确凿的话, 只能想办法抓包查看他的信息收集了, 但是`Charles`抓包的原理是再开一个代理, 会造成混乱....所以这就很头疼了.\n\n5. 开启了网页代理之后, 影响的只是网页, 实际上只是为了验证`Privoxy`的可用性, 开启之后你如果在命令行中使用`curl ip.cn`得到的结果会是你真实网络的出网ip, 而不是你想要的代理的ip, 实际上`uploader`和`fastlane pilot`命令行是否真正走了代理, 目前我只能通过`ss-local`这个代理的进程查看他的上传流量去判断, 具有一定风险. 或者通过安装命令行工具`proxychains`, 然后执行`proxychains4 fastlane pilot upload`传包, 但是这种方式100%上传失败 , 原因猜想是`net.properties`的配置没改, `proxychains`怎么转发请求都没用.  所以这是不是从某种意义上证明了`fastlane pilot`是走`net.properties`配置的呢, 至少我觉得按照目前情况可以这么认为,  后续如果有想法我会进行更多实验去证明的.","slug":"通过代理上传方案","published":1,"updated":"2018-08-03T08:12:38.442Z","_id":"cjkdpl9o80000avxuv1jri77a","comments":1,"photos":[],"link":"","content":"<h2 id=\"Application-Loader-Fastlane-pilot-通过代理上传方案\"><a href=\"#Application-Loader-Fastlane-pilot-通过代理上传方案\" class=\"headerlink\" title=\"Application Loader / Fastlane pilot 通过代理上传方案\"></a>Application Loader / Fastlane pilot 通过代理上传方案</h2><h3 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h3><p>为了避免苹果审核马甲包情况, 我们需要通过其他IP去上传包, 这里提供几种方案并记录踩坑过程.</p>\n<a id=\"more\"></a>\n<h3 id=\"问题解决思路\"><a href=\"#问题解决思路\" class=\"headerlink\" title=\"问题解决思路\"></a>问题解决思路</h3><ol>\n<li><p>用Application Loader(后面简称uploader)上传包, 电脑使用SS, VPN会导致上传失败, 原因是uploader内部自带开启代理配置, 但是默认是关闭的,  所以需要修改内部代理配置, 路径是<code>/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/java/lib/net.properties</code>, 配置如下(1086是本地ss的端口)</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.net.useSystemProxies=true</span><br><span class=\"line\">http.proxyHost=127.0.0.1</span><br><span class=\"line\">http.proxyPort=1086</span><br><span class=\"line\">https.proxyHost=127.0.0.1</span><br><span class=\"line\">https.proxyPort=1086</span><br><span class=\"line\">jdk.http.auth.tunneling.disabledSchemes=Basic</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>本来<code>net.properties</code>内是有socks代理的配置的, Shadowsocks开启socks代理后, 在配置文件中配置好ip(127.0.0.1)和端口(1086)之后测试发现无法连接到苹果服务器, 故只能选用<code>http/https</code>代理</p>\n<blockquote>\n<p>查询shadowsocks本地端口的方法, 执行<code>lsof -iTCP -sTCP:LISTEN -n -P | grep ss-local</code>, 就可以查到</p>\n</blockquote>\n</li>\n<li><p>现在问题在于怎么将socks代理转成http/https代理, 通过查阅资料得知可以通过安装<code>privoxy</code>解决, 安装之后配置<code>/usr/local/etc/privoxy/config</code>文件, 把<code>forward-socks5t</code>那行注释掉, 加上本地socks ip和端口, 就像下面那段一样, 然后把<code>listen-address  127.0.0.1:8118</code> 改成 <code>listen-address  0.0.0.0:8118</code>就可以实现给局域网内共享你的代理.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">forward           /               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks4    /               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks4a   /               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks5    /               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks5t   /               127.0.0.1:1086 .</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li>打开<code>系统偏好设置-网络-高级-代理</code>, 把网页代理和安全网页代理勾上, 填上ip <code>127.0.0.1</code> 端口 <code>8118</code> , 就可以了.  这里的<code>8118</code>是刚刚说到的<code>listen-address  0.0.0.0:8118</code>里面的端口号, 要改也可以改, 记得同步就行.</li>\n</ol>\n<h3 id=\"校验\"><a href=\"#校验\" class=\"headerlink\" title=\"校验\"></a>校验</h3><ol>\n<li><p>校验<code>privoxy</code>是否代理成功可以通过浏览器访问<code>http://config.privoxy.org/</code>这个网址就能看到成功与否了</p>\n</li>\n<li><p>执行<code>netstat -an | grep 8118</code> 查看<code>8188</code>是否全局监听着, 如果是就会看到<br> <code>tcp4       0      0  *.8118                 *.*                    LISTEN</code>执行<code>ps aux | grep privoxy</code>, 则可以看到<code>privoxy</code>进程是否正在运行中. 可以通过<code>sudo /Applications/Privoxy/stopPrivoxy.sh</code>停止<code>privoxy</code>和<code>sudo /Applications/Privoxy/startPrivoxy.sh</code>启动<code>privoxy</code></p>\n</li>\n<li><p>浏览器访问<code>https://ip.cn</code>,就可以得知网页代理是否成功了</p>\n</li>\n<li><p>fastlane上传包实际上是调用了<code>/Applications/Xcode.app/Contents/Applications/Application\\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool</code>, 也就是Xcode自带的命令行工具 , uploader就不用说了, 反正殊途同归, 最后都会根据<code>net.properties</code>去走代理,  那么问题来了 , 如何验证命令行和桌面应用uploader走的都是代理方式呢. 很遗憾苹果并不会弄出一个界面或者打印出一行log告诉你现在是用哪个ip上传, 我现在能想到的办法是通过工具查看上传过程中的流量波动, 通过实验, 两种方式再上传过程中, <code>ss-local</code>进程有过较大数据上传的流量波动(会有100k/s以上的上传流量速度), 因此我判定确实是走了代理上传包的.  如果要再证据确凿的话, 只能想办法抓包查看他的信息收集了, 但是<code>Charles</code>抓包的原理是再开一个代理, 会造成混乱….所以这就很头疼了.</p>\n</li>\n<li><p>开启了网页代理之后, 影响的只是网页, 实际上只是为了验证<code>Privoxy</code>的可用性, 开启之后你如果在命令行中使用<code>curl ip.cn</code>得到的结果会是你真实网络的出网ip, 而不是你想要的代理的ip, 实际上<code>uploader</code>和<code>fastlane pilot</code>命令行是否真正走了代理, 目前我只能通过<code>ss-local</code>这个代理的进程查看他的上传流量去判断, 具有一定风险. 或者通过安装命令行工具<code>proxychains</code>, 然后执行<code>proxychains4 fastlane pilot upload</code>传包, 但是这种方式100%上传失败 , 原因猜想是<code>net.properties</code>的配置没改, <code>proxychains</code>怎么转发请求都没用.  所以这是不是从某种意义上证明了<code>fastlane pilot</code>是走<code>net.properties</code>配置的呢, 至少我觉得按照目前情况可以这么认为,  后续如果有想法我会进行更多实验去证明的.</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"Application-Loader-Fastlane-pilot-通过代理上传方案\"><a href=\"#Application-Loader-Fastlane-pilot-通过代理上传方案\" class=\"headerlink\" title=\"Application Loader / Fastlane pilot 通过代理上传方案\"></a>Application Loader / Fastlane pilot 通过代理上传方案</h2><h3 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h3><p>为了避免苹果审核马甲包情况, 我们需要通过其他IP去上传包, 这里提供几种方案并记录踩坑过程.</p>","more":"<h3 id=\"问题解决思路\"><a href=\"#问题解决思路\" class=\"headerlink\" title=\"问题解决思路\"></a>问题解决思路</h3><ol>\n<li><p>用Application Loader(后面简称uploader)上传包, 电脑使用SS, VPN会导致上传失败, 原因是uploader内部自带开启代理配置, 但是默认是关闭的,  所以需要修改内部代理配置, 路径是<code>/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/java/lib/net.properties</code>, 配置如下(1086是本地ss的端口)</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.net.useSystemProxies=true</span><br><span class=\"line\">http.proxyHost=127.0.0.1</span><br><span class=\"line\">http.proxyPort=1086</span><br><span class=\"line\">https.proxyHost=127.0.0.1</span><br><span class=\"line\">https.proxyPort=1086</span><br><span class=\"line\">jdk.http.auth.tunneling.disabledSchemes=Basic</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li><p>本来<code>net.properties</code>内是有socks代理的配置的, Shadowsocks开启socks代理后, 在配置文件中配置好ip(127.0.0.1)和端口(1086)之后测试发现无法连接到苹果服务器, 故只能选用<code>http/https</code>代理</p>\n<blockquote>\n<p>查询shadowsocks本地端口的方法, 执行<code>lsof -iTCP -sTCP:LISTEN -n -P | grep ss-local</code>, 就可以查到</p>\n</blockquote>\n</li>\n<li><p>现在问题在于怎么将socks代理转成http/https代理, 通过查阅资料得知可以通过安装<code>privoxy</code>解决, 安装之后配置<code>/usr/local/etc/privoxy/config</code>文件, 把<code>forward-socks5t</code>那行注释掉, 加上本地socks ip和端口, 就像下面那段一样, 然后把<code>listen-address  127.0.0.1:8118</code> 改成 <code>listen-address  0.0.0.0:8118</code>就可以实现给局域网内共享你的代理.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">forward           /               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks4    /               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks4a   /               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks5    /               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks5t   /               127.0.0.1:1086 .</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li>打开<code>系统偏好设置-网络-高级-代理</code>, 把网页代理和安全网页代理勾上, 填上ip <code>127.0.0.1</code> 端口 <code>8118</code> , 就可以了.  这里的<code>8118</code>是刚刚说到的<code>listen-address  0.0.0.0:8118</code>里面的端口号, 要改也可以改, 记得同步就行.</li>\n</ol>\n<h3 id=\"校验\"><a href=\"#校验\" class=\"headerlink\" title=\"校验\"></a>校验</h3><ol>\n<li><p>校验<code>privoxy</code>是否代理成功可以通过浏览器访问<code>http://config.privoxy.org/</code>这个网址就能看到成功与否了</p>\n</li>\n<li><p>执行<code>netstat -an | grep 8118</code> 查看<code>8188</code>是否全局监听着, 如果是就会看到<br> <code>tcp4       0      0  *.8118                 *.*                    LISTEN</code>执行<code>ps aux | grep privoxy</code>, 则可以看到<code>privoxy</code>进程是否正在运行中. 可以通过<code>sudo /Applications/Privoxy/stopPrivoxy.sh</code>停止<code>privoxy</code>和<code>sudo /Applications/Privoxy/startPrivoxy.sh</code>启动<code>privoxy</code></p>\n</li>\n<li><p>浏览器访问<code>https://ip.cn</code>,就可以得知网页代理是否成功了</p>\n</li>\n<li><p>fastlane上传包实际上是调用了<code>/Applications/Xcode.app/Contents/Applications/Application\\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool</code>, 也就是Xcode自带的命令行工具 , uploader就不用说了, 反正殊途同归, 最后都会根据<code>net.properties</code>去走代理,  那么问题来了 , 如何验证命令行和桌面应用uploader走的都是代理方式呢. 很遗憾苹果并不会弄出一个界面或者打印出一行log告诉你现在是用哪个ip上传, 我现在能想到的办法是通过工具查看上传过程中的流量波动, 通过实验, 两种方式再上传过程中, <code>ss-local</code>进程有过较大数据上传的流量波动(会有100k/s以上的上传流量速度), 因此我判定确实是走了代理上传包的.  如果要再证据确凿的话, 只能想办法抓包查看他的信息收集了, 但是<code>Charles</code>抓包的原理是再开一个代理, 会造成混乱….所以这就很头疼了.</p>\n</li>\n<li><p>开启了网页代理之后, 影响的只是网页, 实际上只是为了验证<code>Privoxy</code>的可用性, 开启之后你如果在命令行中使用<code>curl ip.cn</code>得到的结果会是你真实网络的出网ip, 而不是你想要的代理的ip, 实际上<code>uploader</code>和<code>fastlane pilot</code>命令行是否真正走了代理, 目前我只能通过<code>ss-local</code>这个代理的进程查看他的上传流量去判断, 具有一定风险. 或者通过安装命令行工具<code>proxychains</code>, 然后执行<code>proxychains4 fastlane pilot upload</code>传包, 但是这种方式100%上传失败 , 原因猜想是<code>net.properties</code>的配置没改, <code>proxychains</code>怎么转发请求都没用.  所以这是不是从某种意义上证明了<code>fastlane pilot</code>是走<code>net.properties</code>配置的呢, 至少我觉得按照目前情况可以这么认为,  后续如果有想法我会进行更多实验去证明的.</p>\n</li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"cji9qbcgv0005ldxu3ifeqvvy","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbchf000cldxuq093w7ou"},{"post_id":"cji9qbcg40000ldxu1rxmz3dp","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbchk000gldxu7f36xylq"},{"post_id":"cji9qbch9000aldxuc1ju8dlz","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbchn000jldxunua24ay9"},{"post_id":"cji9qbcgd0001ldxu400tgpup","category_id":"cji9qbch60007ldxuajm3qodq","_id":"cji9qbchs000oldxuhwb2mkqt"},{"post_id":"cji9qbchd000bldxus0tubkcd","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbchv000rldxu3kre8c3r"},{"post_id":"cji9qbcgq0004ldxux811i77z","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbchz000wldxupcj8p2rv"},{"post_id":"cji9qbchl000ildxuza7euvv7","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbci4000zldxunsxu1zfi"},{"post_id":"cji9qbch30006ldxumcofczfl","category_id":"cji9qbcho000lldxu695u02e5","_id":"cji9qbci90014ldxuh4k5vlyg"},{"post_id":"cji9qbcht000qldxuv5z7tak6","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcip0017ldxu6v2nzc47"},{"post_id":"cji9qbchw000vldxuon4qusd6","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcis001aldxuayf0lxij"},{"post_id":"cji9qbchh000fldxu6a84glt7","category_id":"cji9qbchv000tldxud00xb3o7","_id":"cji9qbciv001fldxu3hp1vi18"},{"post_id":"cji9qbcib0016ldxuo8u506mi","category_id":"cji9qbch60007ldxuajm3qodq","_id":"cji9qbcix001ildxua1dmutwd"},{"post_id":"cji9qbchp000nldxu82fwgmu5","category_id":"cji9qbci50011ldxufvafh0pt","_id":"cji9qbcj0001mldxuz736wsvh"},{"post_id":"cji9qbci1000yldxu08ijuva4","category_id":"cji9qbci50011ldxufvafh0pt","_id":"cji9qbcj6001pldxuq6x5uki4"},{"post_id":"cji9qbciv001hldxujx6t4q8h","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcja001tldxumfuw6l8o"},{"post_id":"cji9qbciz001lldxur07piv6v","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcje001vldxufc408fp8"},{"post_id":"cji9qbci70013ldxuj1n095wr","category_id":"cji9qbcix001jldxuclls4bdq","_id":"cji9qbcjg001yldxuj6yq5owj"},{"post_id":"cji9qbcj1001oldxuvu9udr59","category_id":"cji9qbcix001jldxuclls4bdq","_id":"cji9qbcjj0021ldxuly2wjd0v"},{"post_id":"cji9qbcj8001sldxulnuhrtac","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcjo0025ldxuuaq10ryc"},{"post_id":"cji9qbcit001eldxujuhlay1r","category_id":"cji9qbcix001jldxuclls4bdq","_id":"cji9qbcjs0028ldxu2ub32vun"},{"post_id":"cji9qbcjc001uldxu1q0i7ivt","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcjy002cldxumtrlngr6"},{"post_id":"cji9qbcjl0024ldxuodvs8bhp","category_id":"cji9qbci50011ldxufvafh0pt","_id":"cji9qbck2002gldxu2k4k3fqh"},{"post_id":"cji9qbcjo0027ldxu7rx5src6","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbck5002jldxup4nf0xg3"},{"post_id":"cji9qbcjf001xldxu1hic93e6","category_id":"cji9qbcjk0022ldxui266jsob","_id":"cji9qbck8002nldxueypuf9fo"},{"post_id":"cji9qbcjt002aldxun2kvd1pd","category_id":"cji9qbci50011ldxufvafh0pt","_id":"cji9qbckb002qldxuucia0r1t"},{"post_id":"cji9qbcjz002fldxuwj80ayt2","category_id":"cji9qbci50011ldxufvafh0pt","_id":"cji9qbckh002tldxuzb32o1qv"},{"post_id":"cji9qbcjh0020ldxu8r6b6hep","category_id":"cji9qbcjx002bldxut3b3ng7w","_id":"cji9qbckk002wldxu9jxckvqf"},{"post_id":"cji9qbck6002mldxugujkp3q3","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbckn0030ldxuvjgpqx5i"},{"post_id":"cji9qbck9002pldxua51gv493","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbckp0033ldxuf5i6fr71"},{"post_id":"cji9qbckc002sldxueh82f84s","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcks0036ldxuk2w4v4bp"},{"post_id":"cji9qbcki002vldxu1eccwe0l","category_id":"cji9qbci50011ldxufvafh0pt","_id":"cji9qbckv003aldxuiq53bb60"},{"post_id":"cji9qbckl002zldxuspyi9ipf","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbckz003dldxu1dt4vzf9"},{"post_id":"cji9qbcko0032ldxuuabefgll","category_id":"cji9qbci50011ldxufvafh0pt","_id":"cji9qbcl2003hldxujgs7c91h"},{"post_id":"cji9qbckq0035ldxugdnc8xlx","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcl6003kldxu6grwyld5"},{"post_id":"cji9qbckt0039ldxuc6177nxs","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbclb003pldxu1v1l1one"},{"post_id":"cji9qbckw003cldxuj4y6gdu4","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbclf003sldxuv945mgby"},{"post_id":"cji9qbcl3003jldxung8v40ca","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbclj003wldxur7tfwaxu"},{"post_id":"cji9qbcl9003oldxuy93mo32u","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcln003zldxufkk5e33z"},{"post_id":"cji9qbcld003rldxuqsu2221u","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbclq0043ldxueikdc37z"},{"post_id":"cji9qbcl0003gldxusowkinkt","category_id":"cji9qbcl8003nldxu7ngqx518","_id":"cji9qbclv0046ldxuz34qhmjr"},{"post_id":"cji9qbclh003vldxux2fm7wa9","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcm0004aldxunhe5tz9x"},{"post_id":"cji9qbclj003yldxugl6iabhm","category_id":"cji9qbcjx002bldxut3b3ng7w","_id":"cji9qbcm3004dldxu2ibj4kyv"},{"post_id":"cji9qbclo0042ldxutobpxygq","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcm9004hldxul8a04y9f"},{"post_id":"cji9qbcls0045ldxurbywjem5","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcmd004kldxu3gcos6bt"},{"post_id":"cji9qbclx0049ldxu2fl343p3","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcmj004oldxuhezq8u83"},{"post_id":"cji9qbcm1004cldxuksoi7gxv","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcmo004rldxu275wcwpd"},{"post_id":"cji9qbcm4004gldxub4cyzfgs","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcmr004uldxuvx99ry2w"},{"post_id":"cji9qbcma004jldxudbfggmk1","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcmu004yldxuhuk4w7nx"},{"post_id":"cji9qbcmf004nldxum8cvulqj","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcmw0051ldxuzf0hwy37"},{"post_id":"cji9qbcml004qldxuqji7ti3w","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcmz0055ldxue44yksn8"},{"post_id":"cji9qbcmp004tldxuv4eeld2d","category_id":"cji9qbci50011ldxufvafh0pt","_id":"cji9qbcn20058ldxuad2elixg"},{"post_id":"cji9qbcms004xldxufv82dlfg","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcn5005cldxuw4zkrv0k"},{"post_id":"cji9qbcmv0050ldxuiyq9w0rz","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcn8005fldxu8srdy78s"},{"post_id":"cji9qbcmy0054ldxucdmybys3","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcnb005jldxuyx2b7tb5"},{"post_id":"cji9qbcn00057ldxuukgndjv4","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcnd005lldxunbx6s25a"},{"post_id":"cji9qbcn3005bldxu3yzhu4qk","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcne005oldxubdo63rgy"},{"post_id":"cji9qbcn6005eldxuc1qq4tll","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcne005qldxuvv9r81eb"},{"post_id":"cji9qbcn9005ildxuweihjri6","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcne005sldxuzyz318sn"},{"post_id":"cji9qbcvy0074ldxu11fcpthb","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcw8007cldxu7urwgms5"},{"post_id":"cji9qbcvk006yldxuicyhnvz7","category_id":"cji9qbcvw0072ldxu1et1qk8n","_id":"cji9qbcw9007eldxuplry6j9z"},{"post_id":"cji9qbcw50078ldxu8mafvd66","category_id":"cji9qbcgl0002ldxu4eg7i0zq","_id":"cji9qbcwa007hldxutqf3yldi"},{"post_id":"cji9qbcvq0070ldxua4zibxjo","category_id":"cji9qbcw70079ldxukqi6301q","_id":"cji9qbcwa007ildxuih21c49r"},{"post_id":"cji9qck8a007lldxup7hysc01","category_id":"cji9qbcho000lldxu695u02e5","_id":"cji9qdo19007nldxueop3kg8t"}],"PostTag":[{"post_id":"cji9qbcgv0005ldxu3ifeqvvy","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbch80009ldxuzq9b0mpj"},{"post_id":"cji9qbcg40000ldxu1rxmz3dp","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbchk000hldxueddvlflg"},{"post_id":"cji9qbcg40000ldxu1rxmz3dp","tag_id":"cji9qbch70008ldxua68ug9f5","_id":"cji9qbcho000kldxu8weciuf5"},{"post_id":"cji9qbchd000bldxus0tubkcd","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbchs000pldxuzcckby5l"},{"post_id":"cji9qbchl000ildxuza7euvv7","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbchv000sldxuupk5wnh8"},{"post_id":"cji9qbcgd0001ldxu400tgpup","tag_id":"cji9qbchf000eldxu9z7nyrk8","_id":"cji9qbci0000xldxuy0cpy1lm"},{"post_id":"cji9qbcgd0001ldxu400tgpup","tag_id":"cji9qbchp000mldxu7sbxfy9y","_id":"cji9qbci50010ldxuv8zxepb7"},{"post_id":"cji9qbcht000qldxuv5z7tak6","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcia0015ldxuei0xd4nd"},{"post_id":"cji9qbcgq0004ldxux811i77z","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcip0018ldxu0cms0jip"},{"post_id":"cji9qbcib0016ldxuo8u506mi","tag_id":"cji9qbchf000eldxu9z7nyrk8","_id":"cji9qbcit001dldxuep2ussf6"},{"post_id":"cji9qbch30006ldxumcofczfl","tag_id":"cji9qbci50012ldxu8rpqozf9","_id":"cji9qbciv001gldxue61v5ic3"},{"post_id":"cji9qbciv001hldxujx6t4q8h","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcj0001nldxu9i069qa4"},{"post_id":"cji9qbcjc001uldxu1q0i7ivt","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcjh001zldxu3enpejcp"},{"post_id":"cji9qbch9000aldxuc1ju8dlz","tag_id":"cji9qbci50012ldxu8rpqozf9","_id":"cji9qbcjo0026ldxu29qjlpld"},{"post_id":"cji9qbch9000aldxuc1ju8dlz","tag_id":"cji9qbciy001kldxuy4hts643","_id":"cji9qbcjs0029ldxuqczm2jde"},{"post_id":"cji9qbch9000aldxuc1ju8dlz","tag_id":"cji9qbcj6001rldxuazi5lh0z","_id":"cji9qbcjy002eldxuhbmpsfg8"},{"post_id":"cji9qbch9000aldxuc1ju8dlz","tag_id":"cji9qbcje001wldxuynym99we","_id":"cji9qbck2002hldxuqvrzlc0x"},{"post_id":"cji9qbcjo0027ldxu7rx5src6","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbck6002lldxu31docsle"},{"post_id":"cji9qbchh000fldxu6a84glt7","tag_id":"cji9qbcjk0023ldxucnanfoiw","_id":"cji9qbck8002oldxuwnrzefrt"},{"post_id":"cji9qbchp000nldxu82fwgmu5","tag_id":"cji9qbcjy002dldxuw77rl9ru","_id":"cji9qbckh002uldxu8k55wfqy"},{"post_id":"cji9qbchp000nldxu82fwgmu5","tag_id":"cji9qbck6002kldxu63rmf2kr","_id":"cji9qbckk002xldxuysihsz45"},{"post_id":"cji9qbckc002sldxueh82f84s","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbckn0031ldxupxewui9q"},{"post_id":"cji9qbchw000vldxuon4qusd6","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbckq0034ldxujm9prf9y"},{"post_id":"cji9qbchw000vldxuon4qusd6","tag_id":"cji9qbckc002rldxumjrrqyuf","_id":"cji9qbckt0038ldxue0dr2va4"},{"post_id":"cji9qbckl002zldxuspyi9ipf","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbckw003bldxu0g8m4rhu"},{"post_id":"cji9qbci1000yldxu08ijuva4","tag_id":"cji9qbckk002yldxuts8010d7","_id":"cji9qbckz003fldxuzu05sxc3"},{"post_id":"cji9qbckq0035ldxugdnc8xlx","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcl2003ildxuvyvf06fj"},{"post_id":"cji9qbci70013ldxuj1n095wr","tag_id":"cji9qbcks0037ldxu7m39nr99","_id":"cji9qbcl7003mldxuqzfkkk17"},{"post_id":"cji9qbci70013ldxuj1n095wr","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbclc003qldxuapzet2c3"},{"post_id":"cji9qbckw003cldxuj4y6gdu4","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbclg003uldxujf4fhm4y"},{"post_id":"cji9qbciq0019ldxuvrrqhe5o","tag_id":"cji9qbcks0037ldxu7m39nr99","_id":"cji9qbclj003xldxu45la6t55"},{"post_id":"cji9qbcl3003jldxung8v40ca","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcln0040ldxuwqhxb34z"},{"post_id":"cji9qbcl9003oldxuy93mo32u","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbclr0044ldxu3m6cmwwm"},{"post_id":"cji9qbcit001eldxujuhlay1r","tag_id":"cji9qbcks0037ldxu7m39nr99","_id":"cji9qbclw0047ldxuj0d3xn8y"},{"post_id":"cji9qbcld003rldxuqsu2221u","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcm0004bldxu8dry9esq"},{"post_id":"cji9qbclh003vldxux2fm7wa9","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcm3004eldxuvfpb1qgy"},{"post_id":"cji9qbciz001lldxur07piv6v","tag_id":"cji9qbclg003tldxuw49buzcm","_id":"cji9qbcm9004ildxuquzt9dwp"},{"post_id":"cji9qbclo0042ldxutobpxygq","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcme004lldxujkp5ztvz"},{"post_id":"cji9qbcj1001oldxuvu9udr59","tag_id":"cji9qbcks0037ldxu7m39nr99","_id":"cji9qbcmk004pldxuyk1pflzm"},{"post_id":"cji9qbcls0045ldxurbywjem5","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcmo004sldxush7kyj7w"},{"post_id":"cji9qbclx0049ldxu2fl343p3","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcms004wldxubhwdhmpd"},{"post_id":"cji9qbclx0049ldxu2fl343p3","tag_id":"cji9qbckc002rldxumjrrqyuf","_id":"cji9qbcmu004zldxuaf6w4o2o"},{"post_id":"cji9qbcj8001sldxulnuhrtac","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcmx0053ldxuwsmcfwya"},{"post_id":"cji9qbcj8001sldxulnuhrtac","tag_id":"cji9qbckc002rldxumjrrqyuf","_id":"cji9qbcn00056ldxuly5nigt8"},{"post_id":"cji9qbcm1004cldxuksoi7gxv","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcn2005aldxupz4wux5o"},{"post_id":"cji9qbcjf001xldxu1hic93e6","tag_id":"cji9qbcm4004fldxuoft9619f","_id":"cji9qbcn5005dldxuntgqjzz8"},{"post_id":"cji9qbcma004jldxudbfggmk1","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcn8005gldxun2vfn4u5"},{"post_id":"cji9qbcmf004nldxum8cvulqj","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcnb005kldxuo090gzii"},{"post_id":"cji9qbcml004qldxuqji7ti3w","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcnd005mldxus2b0mjzy"},{"post_id":"cji9qbcml004qldxuqji7ti3w","tag_id":"cji9qbch70008ldxua68ug9f5","_id":"cji9qbcne005pldxux1ntucfz"},{"post_id":"cji9qbcms004xldxufv82dlfg","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcne005rldxu20lr071n"},{"post_id":"cji9qbcjh0020ldxu8r6b6hep","tag_id":"cji9qbcme004mldxu99s9sale","_id":"cji9qbcnf005uldxuhb17lowl"},{"post_id":"cji9qbcjh0020ldxu8r6b6hep","tag_id":"cji9qbcmr004vldxu8x3au1wb","_id":"cji9qbcnf005vldxufz9d7gcw"},{"post_id":"cji9qbcmv0050ldxuiyq9w0rz","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcng005xldxu494que72"},{"post_id":"cji9qbcmy0054ldxucdmybys3","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcng005yldxudhrb1ma6"},{"post_id":"cji9qbcjl0024ldxuodvs8bhp","tag_id":"cji9qbck6002kldxu63rmf2kr","_id":"cji9qbcnh0060ldxuro0e48v6"},{"post_id":"cji9qbcn00057ldxuukgndjv4","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcnh0061ldxu1mlhca5e"},{"post_id":"cji9qbcn3005bldxu3yzhu4qk","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcnh0062ldxu3g3o1x2o"},{"post_id":"cji9qbcjt002aldxun2kvd1pd","tag_id":"cji9qbcn20059ldxu1xdt4lo9","_id":"cji9qbcni0064ldxur7bc9sie"},{"post_id":"cji9qbcn6005eldxuc1qq4tll","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcni0065ldxubngiua1j"},{"post_id":"cji9qbcn9005ildxuweihjri6","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcni0067ldxuk6et9nyl"},{"post_id":"cji9qbcjz002fldxuwj80ayt2","tag_id":"cji9qbcn9005hldxuh8pev6vw","_id":"cji9qbcni0068ldxuet3blhr5"},{"post_id":"cji9qbck6002mldxugujkp3q3","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcnj006aldxu9iry873y"},{"post_id":"cji9qbck6002mldxugujkp3q3","tag_id":"cji9qbcnd005nldxuvssvftg9","_id":"cji9qbcnj006bldxufusudvwh"},{"post_id":"cji9qbck9002pldxua51gv493","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcnj006dldxu54hpf5wt"},{"post_id":"cji9qbck9002pldxua51gv493","tag_id":"cji9qbcnf005tldxupmuz6n4q","_id":"cji9qbcnk006eldxuv3no91l4"},{"post_id":"cji9qbcki002vldxu1eccwe0l","tag_id":"cji9qbckk002yldxuts8010d7","_id":"cji9qbcnk006fldxumrw3sav3"},{"post_id":"cji9qbcko0032ldxuuabefgll","tag_id":"cji9qbcng005zldxujbgpc2te","_id":"cji9qbcnk006hldxuulf3dtr6"},{"post_id":"cji9qbckt0039ldxuc6177nxs","tag_id":"cji9qbcje001wldxuynym99we","_id":"cji9qbcnk006ildxutk9z26nf"},{"post_id":"cji9qbckt0039ldxuc6177nxs","tag_id":"cji9qbcnh0063ldxu6krkmd9m","_id":"cji9qbcnl006kldxuyyep5s46"},{"post_id":"cji9qbcl0003gldxusowkinkt","tag_id":"cji9qbcks0037ldxu7m39nr99","_id":"cji9qbcnl006lldxukigojms0"},{"post_id":"cji9qbcl0003gldxusowkinkt","tag_id":"cji9qbcni0066ldxuzr48m3l5","_id":"cji9qbcnm006nldxu6aqaqmya"},{"post_id":"cji9qbcl0003gldxusowkinkt","tag_id":"cji9qbcnj0069ldxulkqbe3ub","_id":"cji9qbcnm006oldxu1zvjd5fv"},{"post_id":"cji9qbcl0003gldxusowkinkt","tag_id":"cji9qbcnj006cldxuy79sf2zu","_id":"cji9qbcnm006qldxukge7nkth"},{"post_id":"cji9qbcl0003gldxusowkinkt","tag_id":"cji9qbcnk006gldxusowunxze","_id":"cji9qbcnn006rldxue2vmxsyr"},{"post_id":"cji9qbclj003yldxugl6iabhm","tag_id":"cji9qbcnl006jldxu0xv1espt","_id":"cji9qbcnn006sldxuwgfkxicb"},{"post_id":"cji9qbclj003yldxugl6iabhm","tag_id":"cji9qbcnm006mldxuvhe06k86","_id":"cji9qbcno006uldxu7u83vdsk"},{"post_id":"cji9qbcm4004gldxub4cyzfgs","tag_id":"cji9qbcnm006pldxu6kxbgdc5","_id":"cji9qbcno006vldxu9vjsoyug"},{"post_id":"cji9qbcm4004gldxub4cyzfgs","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcno006wldxukky14u9p"},{"post_id":"cji9qbcmp004tldxuv4eeld2d","tag_id":"cji9qbcnn006tldxug7c8d6e5","_id":"cji9qbcnp006xldxu4tb0v7uf"},{"post_id":"cji9qbcvy0074ldxu11fcpthb","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcw40077ldxuicfphfcc"},{"post_id":"cji9qbcvk006yldxuicyhnvz7","tag_id":"cji9qbcvx0073ldxutozr6lx8","_id":"cji9qbcw8007bldxuum1hoqiv"},{"post_id":"cji9qbcw50078ldxu8mafvd66","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cji9qbcw9007dldxup49ame3m"},{"post_id":"cji9qbcw50078ldxu8mafvd66","tag_id":"cji9qbch70008ldxua68ug9f5","_id":"cji9qbcwa007gldxul9ub7l4l"},{"post_id":"cji9qbcvq0070ldxua4zibxjo","tag_id":"cji9qbcw7007aldxufhso6lot","_id":"cji9qbcwb007jldxusuckxx0w"},{"post_id":"cji9qbcvq0070ldxua4zibxjo","tag_id":"cji9qbcwa007fldxurog2e36l","_id":"cji9qbcwb007kldxum0zmhwa1"},{"post_id":"cji9qck8a007lldxup7hysc01","tag_id":"cji9qbci50012ldxu8rpqozf9","_id":"cji9qdo18007mldxuhhmzee2c"},{"post_id":"cjkdpl9o80000avxuv1jri77a","tag_id":"cji9qbcgq0003ldxut0lojbul","_id":"cjkdplyvt0001avxuup9lloej"}],"Tag":[{"name":"iOS","_id":"cji9qbcgq0003ldxut0lojbul"},{"name":"杂谈","_id":"cji9qbch70008ldxua68ug9f5"},{"name":"Node.js","_id":"cji9qbchf000eldxu9z7nyrk8"},{"name":"Express","_id":"cji9qbchp000mldxu7sbxfy9y"},{"name":"Jenkins","_id":"cji9qbci50012ldxu8rpqozf9"},{"name":"Git","_id":"cji9qbciy001kldxuy4hts643"},{"name":"CocoaPods","_id":"cji9qbcj6001rldxuazi5lh0z"},{"name":"Fir","_id":"cji9qbcje001wldxuynym99we"},{"name":"MongoDB","_id":"cji9qbcjk0023ldxucnanfoiw"},{"name":"Let's Encrypt","_id":"cji9qbcjy002dldxuw77rl9ru"},{"name":"https","_id":"cji9qbck6002kldxu63rmf2kr"},{"name":"Reactive Cocoa","_id":"cji9qbckc002rldxumjrrqyuf"},{"name":"nginx","_id":"cji9qbckk002yldxuts8010d7"},{"name":"React Native","_id":"cji9qbcks0037ldxu7m39nr99"},{"name":"Salesforce","_id":"cji9qbclg003tldxuw49buzcm"},{"name":"Vue.js","_id":"cji9qbcm4004fldxuoft9619f"},{"name":"PHP","_id":"cji9qbcme004mldxu99s9sale"},{"name":"WordPress","_id":"cji9qbcmr004vldxu8x3au1wb"},{"name":"docker","_id":"cji9qbcn20059ldxu1xdt4lo9"},{"name":"frp","_id":"cji9qbcn9005hldxuh8pev6vw"},{"name":"XCode","_id":"cji9qbcnd005nldxuvssvftg9"},{"name":"Scene Kit","_id":"cji9qbcnf005tldxupmuz6n4q"},{"name":"ngrok","_id":"cji9qbcng005zldxujbgpc2te"},{"name":"shell","_id":"cji9qbcnh0063ldxu6krkmd9m"},{"name":"Cordova","_id":"cji9qbcni0066ldxuzr48m3l5"},{"name":"AppCan","_id":"cji9qbcnj0069ldxulkqbe3ub"},{"name":"Weex","_id":"cji9qbcnj006cldxuy79sf2zu"},{"name":"HTML5+","_id":"cji9qbcnk006gldxusowunxze"},{"name":"php","_id":"cji9qbcnl006jldxu0xv1espt"},{"name":"webhook","_id":"cji9qbcnm006mldxuvhe06k86"},{"name":"Flow.ci","_id":"cji9qbcnm006pldxu6kxbgdc5"},{"name":"Shadowsocks","_id":"cji9qbcnn006tldxug7c8d6e5"},{"name":"Swift","_id":"cji9qbcvx0073ldxutozr6lx8"},{"name":"技巧","_id":"cji9qbcw7007aldxufhso6lot"},{"name":"git","_id":"cji9qbcwa007fldxurog2e36l"}]}}