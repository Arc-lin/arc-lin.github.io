{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/pasted-0.png","path":"images/pasted-0.png","modified":0,"renderable":0},{"_id":"source/images/pasted-1.png","path":"images/pasted-1.png","modified":0,"renderable":0},{"_id":"source/images/pasted-2.png","path":"images/pasted-2.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/LICENSE","path":"lib/fancybox/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/README.md","path":"lib/fancybox/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.css","path":"lib/fancybox/source/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.js","path":"lib/fancybox/source/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"f75021fa42fa364066ec70133391150a89b406b0","modified":1623005544974},{"_id":"source/.DS_Store","hash":"17537e53709c96943bb61209e8beff188997098d","modified":1623005544959},{"_id":"source/_discarded/Jenkins分布式构建笔记.md","hash":"35b0e3e6c23c2db5e0b22c3b5f18b8bbd0fdf5b2","modified":1623005544958},{"_id":"source/_discarded/关于iOS组件化的思考.md","hash":"1e804a3b34c04216ed89e3844e8b30ff4cece187","modified":1623005544958},{"_id":"source/categories/index.md","hash":"f3d4332e7a31fa7bccda8cdf7d0fc74843a8ede4","modified":1623005544974},{"_id":"source/images/pasted-0.png","hash":"c0918553b8c5976f49ee8776962b2e6337dd9210","modified":1623005544975},{"_id":"source/_drafts/安装shadowsocks服务端.md","hash":"6c6f518393a9afa8d91533a8483c4a9893d32acc","modified":1623338642873},{"_id":"source/_posts/2016-Dankal-iOS-MySummary.md","hash":"75ab37eeb8ff69dc4bed281580e7c4838eff3758","modified":1623005544959},{"_id":"source/_posts/AVFoundation录制视频没声音.md","hash":"79343974faad0a61f46b840f368e6356f284e734","modified":1623005544960},{"_id":"source/_posts/C-基础.md","hash":"cd4559ae3818a19e565eeb4829626104f5bb5efd","modified":1623005544960},{"_id":"source/_posts/ALAsset-Type-Unknown的问题.md","hash":"2d22c0fc59e322e4b7c61959616e24a50266f03c","modified":1623005544959},{"_id":"source/_posts/DKLogger-iOS日志管理框架.md","hash":"10dad822e3a657745ad28b052750985977f7abab","modified":1623005544960},{"_id":"source/_posts/Express学习笔记.md","hash":"06e424af2a5a1679130592f4784ac49154be127b","modified":1623005544961},{"_id":"source/_posts/Dankal-iOS崩溃信息提交.md","hash":"d428024480bfc09bc435d59f821dd6c10096c8b6","modified":1623005544961},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1623005544961},{"_id":"source/_posts/AppDelegate事件分发.md","hash":"c8eb3de7d685141291a5ed386a62c18647fd61eb","modified":1629907506350},{"_id":"source/_posts/Jenkins-Git-CocoaPods-Fir-im实现iOS应用持续集成.md","hash":"3ef15c67b8013ee9b388eafd8477bc7ef975fe90","modified":1623005544965},{"_id":"source/_posts/Let’s-Encrypt-免费https.md","hash":"dbae669477a06be1d37a7134dbdda9033098f658","modified":1623005544966},{"_id":"source/_posts/Jenkins上蒲公英插件中update-description-无法自动写入commit-message问题解决.md","hash":"2a0ab273cb5ce92ce4e01cfcdec0553374fbd445","modified":1623005544965},{"_id":"source/_posts/Nginx-内容替换模块-http-substitutions-filter-module.md","hash":"a34b6839c77c6a5720818a36921e23df0460f2ea","modified":1623005544966},{"_id":"source/_posts/MongoDB笔记.md","hash":"b8fd5e0d872241175d2a279226205a2bde46e50d","modified":1623005544966},{"_id":"source/_posts/Node-js学习笔记.md","hash":"21dd21350c3b5367464dc2e490a415f8284450b8","modified":1623005544966},{"_id":"source/_posts/RACCommand使用注意.md","hash":"95799e327104f37efeb93d9da02ca950cec42d09","modified":1623005544967},{"_id":"source/_posts/ReactNative-ListView-flexWrap不起作用解决办法.md","hash":"71c9f7d3af3af00d7089a1fb20f7dad65f7638a5","modified":1623005544968},{"_id":"source/_posts/React-Native真机运行.md","hash":"7cd8073b7622e120587e4e6480438834f66a25e1","modified":1623005544967},{"_id":"source/_posts/ReactNative与iOS原生代码之间传值.md","hash":"ee7c8fcf5468f2542469471d55c5ec8c6569dbae","modified":1623005544967},{"_id":"source/_posts/ReactNative网络请求.md","hash":"42868f6c90de499bb4aff52f35ee7e1031b976a6","modified":1623005544968},{"_id":"source/_posts/RAC关于cell上的按钮点击后会重复发送信号的问题.md","hash":"acb143b5e3d835d44b9877d443393273cd23acd5","modified":1623005544967},{"_id":"source/_posts/Salesforce-SDK-Bug.md","hash":"b6ec91d313d513d433f78ea87f93f72fc3bcfb2b","modified":1623005544967},{"_id":"source/_posts/Sign-in-with-Apple接入指南.md","hash":"a51b1ae7bcde5aa93b98fc78979bcfd2b70c4471","modified":1623005544968},{"_id":"source/_posts/NavigationController的RootViewController和子ViewController的状态栏颜色不一样或者状态栏显示异常.md","hash":"7ff835e3c50f03bec0ca1b1c75233eae17b6a6b6","modified":1623005544966},{"_id":"source/_posts/Shell-笔记.md","hash":"d4877e5e63fc2128d9b241ca86c69ead52214f5c","modified":1623005544968},{"_id":"source/_posts/UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃的问题.md","hash":"a0fa34339e183190932a5c7e97311f7811f656dd","modified":1623005544968},{"_id":"source/_posts/ReactiveCocoa解决异步串行任务执行中多层嵌套-递归的问题.md","hash":"b200cccaff18936face39e769448b406d9f34c38","modified":1623005544967},{"_id":"source/_posts/Vue学习笔记.md","hash":"75c82eb38d03cfdbeebabf86873734b0800cdfeb","modified":1623005544968},{"_id":"source/_posts/SwiftUI指南.md","hash":"a2161d106051ef1e03e90050146834433d788a55","modified":1623005544968},{"_id":"source/_posts/URLWithString返回空.md","hash":"c9f1c52dc4823b1c9374e0d09db1292c01cd13e2","modified":1623005544969},{"_id":"source/_posts/Untitled.md","hash":"a1d8f74f8b28b54e4288669678afa985c93df782","modified":1623005544969},{"_id":"source/_posts/XCode-添加Target.md","hash":"98fe969b27aca1ea9be504877260a03c610ce0b0","modified":1623005544969},{"_id":"source/_posts/docker笔记.md","hash":"f305188879320e84f106f7327bb91ef9bc14536f","modified":1623005544961},{"_id":"source/_posts/frp-内网穿透.md","hash":"d5c5268aac4d7145c2c17faac9ff16877d5e7875","modified":1623005544962},{"_id":"source/_posts/iOS-定位总结.md","hash":"ac8eb40d883ec13e10b1a8e6ae4ec7ca085bdc1f","modified":1623005544963},{"_id":"source/_posts/iOS-底层原理-KVC.md","hash":"d49149a9062b891c2b521f03b32259e65b860a9e","modified":1623005544963},{"_id":"source/_posts/WordPress常用函数.md","hash":"6069516f30189235e5c06427ba6cd3ac42813ea1","modified":1623005544969},{"_id":"source/_posts/iOS-底层原理-KVO.md","hash":"a4f1f924be0e08fc0c6c357017d5e9ccf20ee069","modified":1623005544965},{"_id":"source/_posts/iOS-底层原理-NSObject.md","hash":"f8a089ed6c31b8b2a5fcc3bd6d794acf96e30521","modified":1623005544963},{"_id":"source/_posts/iOS13新API.md","hash":"f43c61f1aba2303ff1581d304fa55f3e872d9ec8","modified":1623005544964},{"_id":"source/_posts/iOS14-App-Clips.md","hash":"a6df6a10535579febe6f3bda7384dd90226187e6","modified":1623005544965},{"_id":"source/_posts/iOS12-新玩具ShortCut-捷径-使用.md","hash":"0e75111ae668f02731e66a9eac2448b968d495aa","modified":1623005544963},{"_id":"source/_posts/iOS动态加载字体.md","hash":"f5b55c3f21686f28e3cefca09581e7c8af35d213","modified":1629536619407},{"_id":"source/_posts/iOS14新API.md","hash":"eef69a2e925b9f66e35ef8acb4e794b247a35552","modified":1623005544965},{"_id":"source/_posts/iOS-底层原理-Category、-load、-initialize和关联对象.md","hash":"3aa165217d567ec39348d3241ca45508fbca75cb","modified":1623080888999},{"_id":"source/_posts/iOS-底层原理-instance、Class和meta-Class.md","hash":"7a6890cc627ace4d9fd3d5966bc2b9fa1ea778ba","modified":1623005544963},{"_id":"source/_posts/iOS从服务器下载DAE文件并动态加载到SCNScene.md","hash":"285f46e93d86417636ed94567079861887a1945c","modified":1623005544965},{"_id":"source/_posts/iOS-底层原理-Block、-block及其底层实现.md","hash":"05084e612813181a26c279b6532ddf0e20f8e23b","modified":1623655494237},{"_id":"source/_posts/iOS-底层原理-方法缓存与消息发送机制.md","hash":"11236f4f7044c0319d28751439e39cb9a39ea2b1","modified":1629907535774},{"_id":"source/_posts/ipad和iphone使用UIAlertViewController.md","hash":"1c598d0f714d40461c4db83c761ec60602afbcd2","modified":1623005544965},{"_id":"source/_posts/iOS基于Navigation-Base-on-ViewModel的路由搭建——HOOK方式实现.md","hash":"dde899491d68cbc04c8810aaaaa636201c8880c9","modified":1623005544966},{"_id":"source/_posts/iOS-底层原理-isa指针.md","hash":"81f0dc036690337f957fe373a56d86f7d87d9cef","modified":1623772325333},{"_id":"source/_posts/nginx-镜像谷歌.md","hash":"ece28461166dcf251037c8f0b521968f85ca595c","modified":1623005544966},{"_id":"source/_posts/ngrok-内网穿透使用.md","hash":"d2a1bf006ab18427c44f49fb8b60eab875faaa8c","modified":1623005544967},{"_id":"source/_posts/pod-install速度慢的终极解决方案.md","hash":"c21edb07d6a2180cdfe670400ce1d202ec6bd979","modified":1623005544967},{"_id":"source/_posts/pop后强制竖屏.md","hash":"ee03f2db0e4251ab119e8cf9ebb084fc4ae36841","modified":1623005544967},{"_id":"source/_posts/pan手势判断方向.md","hash":"172c310993f3edbd4f34e76e5afff82cdc9d8006","modified":1623005544966},{"_id":"source/_posts/使用DKHTTPTool时的异常处理.md","hash":"72c639bed85a13cf54415d6fff2532bccace6b6a","modified":1623005544969},{"_id":"source/_posts/什么时候用weakSelf什么时候用strongSelf.md","hash":"0768a0e2a0ff84a66e75768006cb7c55c824af55","modified":1623005544969},{"_id":"source/_posts/一句ipack命令解决iOS编译打包上传fir流程.md","hash":"3cd917e60e8b5fdc1a97b42866dd6f67680183fd","modified":1623005544969},{"_id":"source/_posts/使用RAC-DKHTTPTool实践.md","hash":"708abd5f5421f2a371ee12e9303df19e8929eb04","modified":1623005544970},{"_id":"source/_posts/依赖注入与Objection.md","hash":"528fbbd1760a49e78c57aaef332386057e645795","modified":1623005544970},{"_id":"source/_posts/关于App混合开发的介绍.md","hash":"c9fd05d5f77d12ec5ea84345bf95a632a5ba1619","modified":1623005544970},{"_id":"source/_posts/关于案场管家的技术点总结.md","hash":"95acceb6f6d9b4461fe42dda92e52557fa229b1b","modified":1623005544970},{"_id":"source/_posts/关于第三方单元测试框架的简单说明.md","hash":"595b746d29c647ec21869b807d35215affa8006d","modified":1623005544971},{"_id":"source/_posts/使用php的exec方法进行webhook的注意点.md","hash":"22fdd40872f17d19a126550c054416dba3db8834","modified":1623005544969},{"_id":"source/_posts/在-iCloud-Drive中显示-App的iCloud文件夹.md","hash":"01436a01adf15adea7d9e7982a2bbf968e63d0c6","modified":1623005544971},{"_id":"source/_posts/利用MJExtension取出模型数组中的某个属性组成数组.md","hash":"5875e519af86b5105c359e4ee2af779d02296007","modified":1623005544971},{"_id":"source/_posts/发现一个api.md","hash":"bb146d0151224cf8ced6a0bb9c8d8c8af0b6087c","modified":1623005544971},{"_id":"source/_posts/用Swift的框架Vapor写服务端初体验.md","hash":"2b594080c7ecf6ea53fb0cf78111fe4e1b5dcd62","modified":1623005544972},{"_id":"source/_posts/建造者模式.md","hash":"00c6c143728aad71fd4f4fd568477912b5611ee8","modified":1623005544971},{"_id":"source/_posts/用flow-ci做iOS的持续化集成.md","hash":"440898f620a1187b23df4d7278325154b2430622","modified":1623005544972},{"_id":"source/_posts/如何开发-管理一个项目.md","hash":"e1ee2fcdfa80a761ba77b5f74bb719d58ab756c0","modified":1623005544971},{"_id":"source/_posts/组件化方案之强业务组件的设计.md","hash":"228d2d371ffcf31abb18f8efa34f9eefa589c2f8","modified":1623005544973},{"_id":"source/_posts/简易架构设计.md","hash":"66fe37c72788ecfd70ee43669ee3e871ebeeb4f6","modified":1623005544973},{"_id":"source/_posts/组合模式.md","hash":"d9cd6b2ca459ba116b9b900d7c6cc2421ee6ef0c","modified":1623005544973},{"_id":"source/_posts/给-APP添加外部文件导入功能.md","hash":"20774a424accf066ae53ac43bd13be9fa348f880","modified":1623005544973},{"_id":"source/_posts/网络层方法封装.md","hash":"66621328b6d64ee0923848bb736265ea240601a0","modified":1623005544973},{"_id":"source/_posts/基于DKHTTPTool的业务层设计-尝试版.md","hash":"51da67fe25ace8eab907c9b710cc0e97e1c1cf81","modified":1623005544972},{"_id":"source/_posts/网络层方法封装5.md","hash":"51ac773d6d2d4e1419f03dfe1dc08e67425798e3","modified":1623005544973},{"_id":"source/_posts/网络层方法封装3.md","hash":"93d00064ea7d255e55706af1e86981a37c584de8","modified":1623005544973},{"_id":"source/_posts/网络层方法封装4.md","hash":"ef125b7fea230ccaaae48ca0245b9375e8684583","modified":1623005544973},{"_id":"source/_posts/解决git-status中文问题.md","hash":"9df314c6b7cd636feeb738a388720a7953f4b3de","modified":1623005544974},{"_id":"source/_posts/网络层方法封装2.md","hash":"f7e7bad21f617d69c5faa89edb05817d2255d8ac","modified":1623005544973},{"_id":"source/_posts/记录一些关于iOS的一些小技巧.md","hash":"23bc3db95251ebf5c9a7360165ec132899866948","modified":1623005544974},{"_id":"source/about/index.md","hash":"81b514c5ccb0032705e9ab33300262f1390c9b8c","modified":1623005544975},{"_id":"source/_posts/通过代理上传方案.md","hash":"5a8e8f2b859e532ba877ae708280bbd4944b9d13","modified":1623005544974},{"_id":"source/_posts/项目里面的库和框架里面的库冲突问题.md","hash":"dc2ff33ba538a49b08723568ddf1559568a2ad6a","modified":1623005544974},{"_id":"source/tags/index.md","hash":"205f3ebdfd3a3012836cf8f1fc70a8c5979d9387","modified":1623005544976},{"_id":"source/images/pasted-1.png","hash":"9b5536674cfae526b4328c97531dbb81feeb4fae","modified":1623005544976},{"_id":"source/images/pasted-2.png","hash":"c1ea0115ba374112a104d1671bd0933ece3c981a","modified":1624905022021},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1623005544993},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1623005545025},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1623005544997},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1623005544993},{"_id":"themes/next/_config.yml","hash":"6609d07e67cdc1e6bab3c366b5a6673c65404e81","modified":1629536143231},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1623005544994},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1623005545026},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1623005545025},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1623005544998},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1623005544997},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1623005544994},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1623005544997},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1623005544994},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1623005545005},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1623005544996},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1623005544993},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1623005544995},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1623005544994},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1623005544995},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1623005544996},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1623005544996},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1623005544996},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1623005544996},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1623005544999},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1623005544999},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1623005544999},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1623005544998},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1623005544999},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1623005544999},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1623005545003},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1623005545005},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1623005545001},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1623005545005},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1623005545005},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1623005545005},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1623005545005},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1623005545006},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1623005545005},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1623005545006},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1623005545007},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1623005545006},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1623005545005},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1623005545006},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1623005545007},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1623005545007},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1623005545007},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1623005545007},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1623005545000},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1623005545007},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1623005545007},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1623005545007},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1623005545008},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1623005545008},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1623005545024},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1623005545024},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1623005545009},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1623005545022},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1623005545030},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1623005545024},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1623005545024},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1623005545023},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1623005545008},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1623005544995},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1623005544995},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1623005544995},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1623005544994},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1623005545000},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1623005545000},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1623005545003},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1623005545001},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1623005545001},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1623005545003},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1623005545003},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1623005545002},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1623005545003},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1623005545004},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1623005545003},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1623005545004},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1623005545009},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4369b313cbbeae742cb35f86d23d99d4285f7359","modified":1623005545009},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1623005545012},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1623005545003},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1623005545015},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1623005545014},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1623005545011},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1623005545015},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1623005545014},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1623005545010},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1623005545009},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1623005545016},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1623005545015},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1623005545019},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1623005545016},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1623005545009},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1623005545018},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1623005545028},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1623005545019},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1623005545028},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1623005545029},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1623005545029},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1623005545026},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1623005545030},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1623005545029},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1623005545029},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1623005545029},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1623005545031},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1623005545031},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1623005545031},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1623005545030},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1623005545029},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1623005545031},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1623005545030},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1623005545031},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1623005545032},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1623005545032},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1623005545031},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1623005545050},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1623005545054},{"_id":"themes/next/layout/_third-party/.DS_Store","hash":"eefc31c04146e6b15fe9d89408c3793be0f44d23","modified":1618757488238},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1623005545054},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1623005545032},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1623005545054},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1623005545054},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1623005545055},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1623005545055},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1623005545056},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1623005545055},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1623005545055},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1623005545055},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1623005545055},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1623005545056},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1623005545056},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1623005545055},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1623005545056},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1623005545056},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1623005545057},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1623005545056},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1623005545010},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1623005545056},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1623005545009},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1623005545010},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1623005545010},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1623005545013},{"_id":"themes/next/source/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1623005545058},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1623005545011},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1623005545011},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1623005545014},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1623005545013},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1623005545012},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1623005545012},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1623005545058},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1623005545012},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1623005545013},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1623005545014},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1623005545012},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1623005545011},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1623005545012},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1623005545017},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1623005545015},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1623005545015},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1623005545015},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1623005545015},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1623005545017},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1623005545018},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1623005545017},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1623005545011},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1623005545017},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1623005545017},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1623005545018},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1623005545018},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1623005545018},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1623005545017},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1623005545017},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1623005545019},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1623005545021},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1623005545019},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1623005545019},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1623005545017},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1623005545020},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1623005545020},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1623005545019},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1623005545020},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1623005545021},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1623005545020},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1623005545026},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1623005545026},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1623005545023},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1623005545022},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"06766874391f5cb5c4fc67fdf69a7f8e705a3510","modified":1623005545018},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1623005545026},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1623005545018},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1623005545028},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1623005545027},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1623005545028},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1623005545027},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1623005545028},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1623005545027},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1623005545027},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1623005545026},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1623005545022},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1623005545054},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1623005545053},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1623005545054},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1623005545053},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1623005545057},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1623005545059},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1625147879158},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1623005545054},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1623005545059},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"d8bf9cb15d9d91c7ad022ba2954b5b4d326f17f7","modified":1625147879158},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1623005545058},{"_id":"themes/next/source/lib/fancybox/README.md","hash":"8286582ed7c338fce8bb03566b769fba378bce83","modified":1625147879158},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1623005545050},{"_id":"themes/next/source/lib/fancybox/LICENSE","hash":"8624bcdae55baeef00cd11d5dfcfa60f68710a02","modified":1625147879158},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1623005545052},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1623005545050},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1623005545051},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1623005545032},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1623005545051},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1623005545032},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1623005545050},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1623005545052},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1623005545032},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1623005545051},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1623005545051},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1623005545041},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1623005545041},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1623005545051},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1623005545051},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1623005545039},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1623005545045},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1623005545044},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1623005545047},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1623005545052},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1623005545047},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1623005545045},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1623005545050},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1623005545052},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1623005545048},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1623005545052},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1623005545052},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1623005545047},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1623005545053},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1623005545053},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1623005545053},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1623005545059},{"_id":"themes/next/source/lib/fancybox/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1625147879155},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1623005545058},{"_id":"themes/next/source/lib/fancybox/.git/config","hash":"0bd9061daa1ae14bc8c15ccb2616123858620669","modified":1625147879156},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1625147879159},{"_id":"themes/next/source/lib/fancybox/.git/packed-refs","hash":"b6ffcdb23c4f9b3e5576fe104e8596ea71603c84","modified":1625147879153},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"e43435fb9eaa918f5b8e35c9e110124b8bd13751","modified":1625147879159},{"_id":"themes/next/source/lib/fancybox/.git/index","hash":"4698a6c3e62b272dfb75de2a741b021ed65b9734","modified":1625147879160},{"_id":"themes/next/source/lib/fancybox/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1625147866542},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1623005545035},{"_id":"themes/next/source/lib/fancybox/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1625147879158},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1623005545033},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1623005545034},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1623005545033},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1623005545034},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1623005545034},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1623005545037},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1623005545036},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1623005545033},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1623005545037},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1623005545037},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1623005545035},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1623005545038},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1623005545038},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1623005545037},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1623005545038},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1623005545036},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1623005545040},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1623005545038},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1623005545038},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1623005545040},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1623005545040},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1623005545040},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1623005545040},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1623005545039},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1623005545039},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1623005545041},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1623005545041},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1623005545041},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1623005545040},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1623005545042},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1623005545040},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1623005545042},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1623005545042},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1623005545044},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1623005545042},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1623005545043},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1623005545044},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1623005545043},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1623005545046},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1623005545043},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1623005545046},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1623005545046},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1623005545046},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1623005545043},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1623005545048},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1623005545049},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1623005545048},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1623005545049},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1623005545049},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1623005545049},{"_id":"themes/next/source/lib/fancybox/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1625147866543},{"_id":"themes/next/source/lib/fancybox/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1625147866542},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1623005545049},{"_id":"themes/next/source/lib/fancybox/.git/hooks/fsmonitor-watchman.sample","hash":"118ff5509f187039734d04456bf01e44c933ac19","modified":1625147866543},{"_id":"themes/next/source/lib/fancybox/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1625147866542},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1625147866544},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-commit.sample","hash":"a79d057388ee2c2fe6561d7697f1f5efcff96f23","modified":1625147866543},{"_id":"themes/next/source/lib/fancybox/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1625147866544},{"_id":"themes/next/source/lib/fancybox/.git/logs/HEAD","hash":"6ae6b0f669c883ab793325a20950eebe7c323ea6","modified":1625147879156},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-push.sample","hash":"a599b773b930ca83dbc3a5c7c13059ac4a6eaedc","modified":1625147866545},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1625147866543},{"_id":"themes/next/source/lib/fancybox/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1625147866544},{"_id":"themes/next/source/lib/fancybox/.git/hooks/update.sample","hash":"730e6bd5225478bab6147b7a62a6e2ae21d40507","modified":1625147866545},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1625147866543},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-merge-commit.sample","hash":"04c64e58bc25c149482ed45dbd79e40effb89eb7","modified":1625147866544},{"_id":"themes/next/source/lib/fancybox/.git/refs/heads/master","hash":"0b56bdb897316a3b4ec6c120673249f65f4cb420","modified":1625147879155},{"_id":"themes/next/source/lib/fancybox/.git/objects/pack/pack-30cab214c43b61c7f7e6b1f769ac808d67a1ac07.idx","hash":"2e7f35b479ff5f8e559792ca6c1925a5edbcd2f8","modified":1625147879129},{"_id":"themes/next/source/lib/fancybox/.git/logs/refs/heads/master","hash":"6ae6b0f669c883ab793325a20950eebe7c323ea6","modified":1625147879156},{"_id":"themes/next/source/lib/fancybox/.git/logs/refs/remotes/origin/HEAD","hash":"6ae6b0f669c883ab793325a20950eebe7c323ea6","modified":1625147879154},{"_id":"themes/next/source/lib/fancybox/.git/hooks/push-to-checkout.sample","hash":"508240328c8b55f8157c93c43bf5e291e5d2fbcb","modified":1625147866545},{"_id":"themes/next/source/lib/fancybox/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1625147879154},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1623005545059},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1623005545059},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1625147879159},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"27f034e5db8c32e268e2959b9a7c1258d36e4510","modified":1625147879160},{"_id":"themes/next/source/lib/fancybox/.git/objects/pack/pack-30cab214c43b61c7f7e6b1f769ac808d67a1ac07.pack","hash":"293fd150066cec7291b8c720d658605d1a8e6e8b","modified":1625147879129},{"_id":"public/baidusitemap.xml","hash":"246850f1417fd0e86953565494e055b9e94916c7","modified":1632766983686},{"_id":"public/atom.xml","hash":"00ae9b1ef7f5bf348ff1e7c6488f870770ea7842","modified":1632766983686},{"_id":"public/search.xml","hash":"d4cd41b984e299c06e093fa1afc79a7ea6f7bb34","modified":1632766983686},{"_id":"public/sitemap.xml","hash":"40e1608beffcaa5ed507f0c93e9538a1baf1ec1e","modified":1632766983686},{"_id":"public/tags/index.html","hash":"0e44cd80f669275dc039ec67e285693b0d982997","modified":1632766983686},{"_id":"public/about/index.html","hash":"486fb4243f78b248bddcbe76c50c02cd0a752476","modified":1632766983686},{"_id":"public/categories/index.html","hash":"777467e43044ba905e033dda9934fb0340acc71c","modified":1632766983686},{"_id":"public/archives/2016/06/index.html","hash":"6bd9c963d460269c032f8d90f00d6e5bd6be68c3","modified":1632766983686},{"_id":"public/archives/2016/11/index.html","hash":"e2f4c09b8112b08eb417293182eecc709e5e5d80","modified":1632766983686},{"_id":"public/archives/2016/12/index.html","hash":"45c6f25d23917c6f18aa9da0463ef4e0b169c3e5","modified":1632766983686},{"_id":"public/archives/2017/page/3/index.html","hash":"56fd4207aa62c339d112fe546d603fc98d149834","modified":1632766983686},{"_id":"public/archives/2017/01/index.html","hash":"bb7632755eb2c37429e06b5f681ca6047dfc4973","modified":1632766983686},{"_id":"public/archives/2017/08/index.html","hash":"cc273544b0a623e9ceab169e9d08c947438b4abe","modified":1632766983686},{"_id":"public/archives/2017/02/index.html","hash":"72f3fa405ade3668bce1857edab98afa59b65ca3","modified":1632766983686},{"_id":"public/archives/2018/page/2/index.html","hash":"73294b2a6bed5a77648a2e0bcd0a480b9f155b6d","modified":1632766983686},{"_id":"public/archives/2018/02/page/2/index.html","hash":"fafb7d5565b300245482559e4942f93f871f066e","modified":1632766983686},{"_id":"public/archives/2018/05/index.html","hash":"ad5067f0c0e4a5191c8b5015bfd53e53a0fcd8cc","modified":1632766983686},{"_id":"public/archives/2018/08/index.html","hash":"6cf6fdabcf5a277b43e5e5b7369fa0468826f19a","modified":1632766983686},{"_id":"public/archives/2018/09/index.html","hash":"29e7bf5600377d43e7e1ea7b496b5f5ceb2c8e19","modified":1632766983686},{"_id":"public/archives/2019/index.html","hash":"4d26eb3e2d4214182fa4e114bd4d9a4469e9ff77","modified":1632766983686},{"_id":"public/archives/2019/11/index.html","hash":"d8f2513c278b9f71d63e5722e5a448a894bb706b","modified":1632766983686},{"_id":"public/archives/2019/10/index.html","hash":"8a02024c6bca4bd0150e324d68fa9e45ec7c1bc0","modified":1632766983686},{"_id":"public/archives/2019/12/index.html","hash":"2cd0f0fa12ea48a7e840e73167bbf9eb95aaba0e","modified":1632766983686},{"_id":"public/archives/2020/02/index.html","hash":"ce25f561c0d50dabec3511c0d0973cbdc99bfd9c","modified":1632766983686},{"_id":"public/archives/2020/index.html","hash":"c4b503536859db03f8d269b73ab175a94cf3b604","modified":1632766983686},{"_id":"public/archives/2020/03/index.html","hash":"aa1379a898c08cd0d5276fd0ee9be124539d7957","modified":1632766983686},{"_id":"public/archives/2020/04/index.html","hash":"23bb60a1f87fc2d848507cf4245ef422c7ed1689","modified":1632766983686},{"_id":"public/archives/2020/05/index.html","hash":"5d7532c1d343202ec6507df733ffcee27def4ce4","modified":1632766983686},{"_id":"public/archives/2020/06/index.html","hash":"9aae3c5ddda964373b1b4b38bcd40308b54761cf","modified":1632766983686},{"_id":"public/archives/2020/11/index.html","hash":"ef6613bb217ff5700f465239a31f31586012babf","modified":1632766983686},{"_id":"public/archives/2021/03/index.html","hash":"c469df196a901695f36301c9c493bd9b52d72218","modified":1632766983686},{"_id":"public/archives/2021/05/index.html","hash":"279dee0c9446cb155b6f2b1c59a37dcb60e2a144","modified":1632766983686},{"_id":"public/archives/2021/06/index.html","hash":"072bacb2c5e3c422fb3c033fb51259253209abb2","modified":1632766983686},{"_id":"public/categories/iOS/page/7/index.html","hash":"1bf7bbdfae48957b8553eee9eb3707a819954418","modified":1632766983686},{"_id":"public/categories/C/index.html","hash":"8aeab87731905125580387e7c769f42b02c96732","modified":1632766983686},{"_id":"public/categories/Node-js/index.html","hash":"e20e5ca89f0e4eab7f672a721b301186fa553be1","modified":1632766983686},{"_id":"public/categories/Jenkins/index.html","hash":"f668641b5fd4119db1635a54e9e0c0e62784df88","modified":1632766983686},{"_id":"public/categories/MongoDB/index.html","hash":"068ada2a20281374a7aa0c691757458a3a592165","modified":1632766983686},{"_id":"public/categories/前端/index.html","hash":"38dc57a7ae6fa5735233c71461389f8432277cb0","modified":1632766983686},{"_id":"public/categories/PHP/index.html","hash":"11b1b077a03d1ba66c99907dbbb1d40e0975b3c8","modified":1632766983686},{"_id":"public/categories/杂谈/index.html","hash":"b45587f21b47ce61d322c9a664ed920272ff288f","modified":1632766983686},{"_id":"public/categories/React-Native/index.html","hash":"2264d72aed8033c028f08ab870114834e1659e6f","modified":1632766983686},{"_id":"public/categories/Swift/index.html","hash":"0e24f9fab4cd75d561a90a5dcb8f8229e70ed12d","modified":1632766983686},{"_id":"public/categories/Git/index.html","hash":"f42ae2bbf54d68ae0e59fc9bfe9a11edc69fe298","modified":1632766983686},{"_id":"public/tags/杂谈/index.html","hash":"504327d3c441cfd2193399ffa58e8b489296eeb1","modified":1632766983686},{"_id":"public/tags/C/index.html","hash":"93adeb20d08535b523006b02970341651bad6c2f","modified":1632766983686},{"_id":"public/tags/Express/index.html","hash":"61a0acbc1d9a587f5bf5eb4478004f5108afab03","modified":1632766983686},{"_id":"public/tags/架构/index.html","hash":"1e01752c982f880623ed42b26da0d5d23cd0a1ba","modified":1632766983686},{"_id":"public/tags/Git/index.html","hash":"27f162733141248d6f4a94c427044d997509fb46","modified":1632766983686},{"_id":"public/tags/Node-js/index.html","hash":"537f301457ebe4c5499b58de82f2d985ab056c4f","modified":1632766983686},{"_id":"public/tags/Jenkins/index.html","hash":"a1f107c011051eeb3b7543d50d6fd8b0d4f7749a","modified":1632766983686},{"_id":"public/tags/Cocoapods/index.html","hash":"5fb7af59c9799d99dcc30146184517fca65febf5","modified":1632766983686},{"_id":"public/tags/Fir/index.html","hash":"c7cc504bf41d7627a7db6f40c87e6486d13e9a37","modified":1632766983686},{"_id":"public/tags/Let-s-Encrypt/index.html","hash":"617b22478f1e4c25ccc3dad884fa1fdbce805497","modified":1632766983686},{"_id":"public/tags/https/index.html","hash":"7a119d969e9ebabbd1060c6fc0f90bd8ae0cc248","modified":1632766983686},{"_id":"public/tags/MongoDB/index.html","hash":"1b7ec591b42514c3e9ae994b58882ff5d79af988","modified":1632766983686},{"_id":"public/tags/Reactive-Cocoa/index.html","hash":"0736a7ca42588a0a7843904b516db5d8d502386f","modified":1632766983686},{"_id":"public/tags/React-Native/index.html","hash":"dbd2dfcbe8ff1098f014129f2dac70a1154932f1","modified":1632766983686},{"_id":"public/tags/Salesforce/index.html","hash":"421a9ffa6ea4575aa9797db74b95f48d16124e58","modified":1632766983686},{"_id":"public/tags/nginx/index.html","hash":"7375fcbec075511773a7cb3ca14b5f918487a1c4","modified":1632766983686},{"_id":"public/tags/Vue-js/index.html","hash":"97e7b5f8b3f1b20910ba76583c1a59ffe9cb236e","modified":1632766983686},{"_id":"public/tags/Xcode/index.html","hash":"4da80fc231dbb8853700daba545b38fc3f8ea33c","modified":1632766983686},{"_id":"public/tags/frp/index.html","hash":"0cba4870e8fafcd5edeaafd52052362cc715051e","modified":1632766983686},{"_id":"public/tags/docker/index.html","hash":"6a1f6e91f5a5123ddc70f352521021c00fab75df","modified":1632766983686},{"_id":"public/tags/PHP/index.html","hash":"a967ada260e2c3bf97ac833c8600bab293d06776","modified":1632766983686},{"_id":"public/tags/feature/index.html","hash":"6c977d0e9fb1ffbbeb5197a54e851756256d1ace","modified":1632766983686},{"_id":"public/tags/Scene-Kit/index.html","hash":"1ce2c0f016b5d13e4529187257548526d7b714a4","modified":1632766983686},{"_id":"public/tags/ngrok/index.html","hash":"3b22fd2b06d788f17c3d2defc889791d4d6bfb5c","modified":1632766983686},{"_id":"public/tags/技巧/index.html","hash":"d8da16c1071647f91585266a63a370105a4fd287","modified":1632766983686},{"_id":"public/tags/shell/index.html","hash":"cd1b0d7ca59b61dce528a7bbfaca287eba3ce88f","modified":1632766983686},{"_id":"public/tags/WordPress/index.html","hash":"9efaeb0f4eab9f7afeaf23f96841b723a06165b4","modified":1632766983686},{"_id":"public/tags/Cordova/index.html","hash":"089fe329e14a321e2345704fb4b65198bd90bbbe","modified":1632766983686},{"_id":"public/tags/webhook/index.html","hash":"9ea001755011881cf00421b37526263246952959","modified":1632766983686},{"_id":"public/tags/AppCan/index.html","hash":"249ba79a86903ee79cc9cab768c85a444c03e89e","modified":1632766983686},{"_id":"public/tags/php/index.html","hash":"062ac3afa8a2352cbcb485b7391e853a0ac92401","modified":1632766983686},{"_id":"public/tags/HTML5/index.html","hash":"dc12de842b672aa788db9a023883f898b6014c42","modified":1632766983686},{"_id":"public/tags/Weex/index.html","hash":"2bc2df9e4396dac7b123084c4dbd0dbcfaf1f353","modified":1632766983686},{"_id":"public/tags/Swift/index.html","hash":"31e3d4c3202f56802a973ca49c276a7ca4b5a4d8","modified":1632766983686},{"_id":"public/post/5ed61a9.html","hash":"bf52348316b4e3efc1b64fba3ab4deaa19d08720","modified":1632766983686},{"_id":"public/post/78ececc4.html","hash":"646b8fd605ca37fd9a0f169fe0bca9d69a12ede2","modified":1632766983686},{"_id":"public/post/8275b854.html","hash":"c25bc4849a0824319af5e49566ee01366f23c8a8","modified":1632766983686},{"_id":"public/post/2397c268.html","hash":"c8e89a63c63669295cae42a7b53b0bd527da9a5c","modified":1632766983686},{"_id":"public/post/34b9a649.html","hash":"eedc7ff15084a6db4b48c2b735820ad983a86eef","modified":1632766983686},{"_id":"public/post/81c45883.html","hash":"b47364b3c5fa06c497c5f1a5a0688db25df5b732","modified":1632766983686},{"_id":"public/post/fdd98f42.html","hash":"9c5f9658ab98389835545e8aa4757cc2b9a117ab","modified":1632766983686},{"_id":"public/post/70f61b87.html","hash":"a8aac2b8d4b361a71ffa96a1f3e7a079bc49129a","modified":1632766983686},{"_id":"public/post/f82939c6.html","hash":"99330a796f7eae9888ec924429dfdeb6571520af","modified":1632766983686},{"_id":"public/post/a44df9c3.html","hash":"04735fb2c73f018d9932daaa1a975f43f1fbf8ca","modified":1632766983686},{"_id":"public/post/36f1cd4f.html","hash":"d86c4618f66d9e8ba9ff11f5827efaad8c625680","modified":1632766983686},{"_id":"public/post/6ae5f77f.html","hash":"3f7b6ced8f297a4f10d544767cedeaf31dc199a9","modified":1632766983686},{"_id":"public/post/826fbbdd.html","hash":"070ac32b399d2089d0137784cf361b606981b805","modified":1632766983686},{"_id":"public/post/7e5c9fa9.html","hash":"9709d869283caba581b3a69c8651d50e862caeb2","modified":1632766983686},{"_id":"public/post/be708589.html","hash":"c610a9680697a6381933f6f89350c456d0a3a8f3","modified":1632766983686},{"_id":"public/post/f6762f39.html","hash":"3934244f09581f71aa3f47b198f61421c92d2dd6","modified":1632766983686},{"_id":"public/post/ac0a85bd.html","hash":"ba69f271e8a18bdd143d39cc2fbdba48bf1b0842","modified":1632766983686},{"_id":"public/post/f356f3c1.html","hash":"6d38e80a149f02a4c827deb657a97b4179c0fbb7","modified":1632766983686},{"_id":"public/post/3c7b026b.html","hash":"9d303eb2ba7350ee65bf5a1e0d4885d5923c4a1d","modified":1632766983686},{"_id":"public/post/f9a964a9.html","hash":"387a0377ac0613bcfff26ec80d6d67cdb5ebd8b8","modified":1632766983686},{"_id":"public/post/0.html","hash":"2b583203b9d2c13d7063c3b30e2cfc1412e446d2","modified":1632766983686},{"_id":"public/post/undefined.html","hash":"54406bd0f91722320e4934b95efb7d5a094d6e7a","modified":1632766983686},{"_id":"public/post/7daa41d8.html","hash":"125caadcfb51d37dac3896d16b35d8197858e4d4","modified":1632766983686},{"_id":"public/post/5fcbb764.html","hash":"5adff21d00e44542a93da7c4d03a232f9f6a8eed","modified":1632766983686},{"_id":"public/post/4417b09c.html","hash":"d8c7499e93853e7f558ecd16771dc490e73903bf","modified":1632766983686},{"_id":"public/post/cfe784af.html","hash":"8eb901e6768ebb7e48ec1050f3080ae424ba02f8","modified":1632766983686},{"_id":"public/post/a6a89073.html","hash":"3b0efd8fd5fb26c64d36e7a85ecfa1402f798da1","modified":1632766983686},{"_id":"public/post/8cafabb2.html","hash":"3c3e81eff27e29ec1f338f5ced0df43fc9531e6e","modified":1632766983686},{"_id":"public/post/e35ccdb6.html","hash":"4d01b2cf41abc72ed451216696f5b8f048a4d49c","modified":1632766983686},{"_id":"public/post/b72542c2.html","hash":"4610630747d87a1347e0c7f30f3c422d61af3bca","modified":1632766983686},{"_id":"public/post/dda122f4.html","hash":"bd3238bd425a9afe6cea1e307406586ee7db3e77","modified":1632766983686},{"_id":"public/post/e88dc875.html","hash":"2aaa7a78e21dae90ac76cce8ba3045b3d78cfea2","modified":1632766983686},{"_id":"public/post/b3b38c86.html","hash":"39ab070777f06ef0cc5a90f834361ecc0aed8848","modified":1632766983686},{"_id":"public/post/f8291fcc.html","hash":"0a063f9397c44d2bf36c62ee1325c589324b20c1","modified":1632766983686},{"_id":"public/post/feddc8a5.html","hash":"c98b8d006381ad928e1d95f6eb01ba685df8e842","modified":1632766983686},{"_id":"public/post/71513ccb.html","hash":"83a43dfe9c6a578dfd484ec8f2139b208ea9ec35","modified":1632766983686},{"_id":"public/post/93da1b70.html","hash":"152a809da949a4d28b7018a0f3f3951e02c78134","modified":1632766983686},{"_id":"public/post/f6ce3122.html","hash":"143c85d5346a9db0648c88450839dadb3dc1ec89","modified":1632766983686},{"_id":"public/post/5f5664e4.html","hash":"cc49e70210d7beb018d29e27c31c60b04d868ca1","modified":1632766983686},{"_id":"public/post/73291e5a.html","hash":"3062caa82fcf50be0526751fbc68a27d7d235d0d","modified":1632766983686},{"_id":"public/post/b6bd206a.html","hash":"d1018126eeb7f4592e061ecbf2004cafebcc4269","modified":1632766983686},{"_id":"public/post/b179ff40.html","hash":"529d2f25b434a5877ce1939088719860b5a8071a","modified":1632766983686},{"_id":"public/post/7724d1af.html","hash":"75b29e99d6f61e48a6f4da75fb8d84a5f60ab5e6","modified":1632766983686},{"_id":"public/post/dcb90c85.html","hash":"d8927d67c30dc23f7ed92cc1811848667d4b008c","modified":1632766983686},{"_id":"public/post/1aafa723.html","hash":"f5cb06dcad27dc43c6d9b71dcb6cbb2f90e67d95","modified":1632766983686},{"_id":"public/post/efd905d7.html","hash":"04a9dfae7b3bb424d4ea0a8893427dd84c498853","modified":1632766983686},{"_id":"public/post/11785d19.html","hash":"9e672bd81650bc7d2b0a0710ac8465aa62fdc0de","modified":1632766983686},{"_id":"public/post/3fd5c9ca.html","hash":"15ffa4f904606f967284068d64bf4ff442e99ec4","modified":1632766983686},{"_id":"public/post/a8a5ff12.html","hash":"d878aa77c2392cabe7986f6229019736dfa094b4","modified":1632766983686},{"_id":"public/post/2281692e.html","hash":"0ac7340d34ee7ca50b93e3daffa73d91575843ad","modified":1632766983686},{"_id":"public/post/abce56f1.html","hash":"e8b075c80004617f49f817b2b040775eeb5f38c6","modified":1632766983686},{"_id":"public/post/8c9c88ab.html","hash":"137df9bee4fd70b01628396e2c9bfd8c6184d7a5","modified":1632766983686},{"_id":"public/post/4edc914d.html","hash":"40a7f289a906e6d9102b798258d9aa44d0debf0e","modified":1632766983686},{"_id":"public/post/13ecfb47.html","hash":"38a434b196260d52ae9a0a85765673051222395d","modified":1632766983686},{"_id":"public/post/61929cc2.html","hash":"3d79246bb6b2386e0cc56ed99517c1cab0be7dd4","modified":1632766983686},{"_id":"public/post/b111382b.html","hash":"2a4d126779b859dae55fac51d1d506eb3dd63013","modified":1632766983686},{"_id":"public/post/7daccd39.html","hash":"579a0df2eee735ceb566341634232e7539db44db","modified":1632766983686},{"_id":"public/post/8d52056b.html","hash":"81da3462437d2aa92655dab7315eca0646ca5cce","modified":1632766983686},{"_id":"public/post/178548dd.html","hash":"9afb218b8f66d90767df9f53d903cda5457f3a92","modified":1632766983686},{"_id":"public/post/6082784b.html","hash":"eec633612b65011d1dee84f828cae9202ef1e6a8","modified":1632766983686},{"_id":"public/post/838ddddd.html","hash":"578d30aebbd2bcf2807515804f465e0fa763ad08","modified":1632766983686},{"_id":"public/post/fee6ede8.html","hash":"bc6c79187e2515a4f103e1ff16d12fb3f37abfe2","modified":1632766983686},{"_id":"public/post/1787ee1c.html","hash":"7b724c9e7e7385fb8720d80337d4e95aef1e922d","modified":1632766983686},{"_id":"public/post/89e1dd7e.html","hash":"ae823621c120687f3caa1950d117e342e838a7b9","modified":1632766983686},{"_id":"public/post/afeed214.html","hash":"5b1d85b983eaa0df50111a666fe60f797cbad109","modified":1632766983686},{"_id":"public/post/df879792.html","hash":"e95799621ad8bf87b3d2cfbdb2be9ad8b88728e4","modified":1632766983686},{"_id":"public/post/fe816c3c.html","hash":"9c9d525294a34f55f524362bab6e15fc17b91edf","modified":1632766983686},{"_id":"public/post/d2301e87.html","hash":"90263f5afbd4a8a4d157c034bd76224a851d97a9","modified":1632766983686},{"_id":"public/post/2684222a.html","hash":"52f1e9042305edc28df03ca0efb7f4ba324228a9","modified":1632766983686},{"_id":"public/post/3eb7dc04.html","hash":"eda28ac364c28169ad724d8ed5e0ad2dad2df6be","modified":1632766983686},{"_id":"public/post/4948514e.html","hash":"a02e2f9df4b2052c0e887f96eba2de5c5ce01fc4","modified":1632766983686},{"_id":"public/post/3d9cee8d.html","hash":"1a3d2d97784fb1201f590ffd62918f4ca78445fc","modified":1632766983686},{"_id":"public/post/b072216a.html","hash":"a332b030a54cb938a0c6bba27af4f767cdfa65da","modified":1632766983686},{"_id":"public/post/a8ea2211.html","hash":"abd907e3b942271c2d84de8bd75e52c1723f3c09","modified":1632766983686},{"_id":"public/post/cacc49a3.html","hash":"985f249227e37954aeeb122f843c0fe2cee625f5","modified":1632766983686},{"_id":"public/post/79533f9e.html","hash":"c0e5944248df381a5758899d37ae29bb79154419","modified":1632766983686},{"_id":"public/post/452efb32.html","hash":"c7dd0272842ba42d684596205d8279ad2456d9d2","modified":1632766983686},{"_id":"public/post/890a3088.html","hash":"942bccf7b100cdb581939374e513d6a983bda2a9","modified":1632766983686},{"_id":"public/post/f0080c3e.html","hash":"a9abee24d311dcb1a0a967b2ed0cda660002c83b","modified":1632766983686},{"_id":"public/post/34db2dbc.html","hash":"a798b09f105833f321dc5b10af2f3d23480fca0f","modified":1632766983686},{"_id":"public/post/50c5f6e6.html","hash":"26c8942f2d166150cfd83e3cd08916d7d96d1019","modified":1632766983686},{"_id":"public/post/f9b1d95c.html","hash":"30ef41debcf2b9feef17f42994b46c2cfcf0cabc","modified":1632766983686},{"_id":"public/post/54b26395.html","hash":"cee15186a65d161cca27419e3aebead12d7f2755","modified":1632766983686},{"_id":"public/post/8e2ebfdf.html","hash":"b444dc1f0745df31355c23bf8bf40ba3c5e13e8e","modified":1632766983686},{"_id":"public/post/1b8f24c7.html","hash":"574d20a7228842fbf2d20c308c1ee3a76f21bc15","modified":1632766983686},{"_id":"public/post/8ff6aa28.html","hash":"2cf8de4cab43a7f8f22aa71ccf6099a3dd73efc2","modified":1632766983686},{"_id":"public/archives/index.html","hash":"2827168a56ab3a67094ee8607bd30af487e952f7","modified":1632766983686},{"_id":"public/archives/page/2/index.html","hash":"098dd14901de05e722fc776e40ec51a6ceac59a4","modified":1632766983686},{"_id":"public/archives/page/3/index.html","hash":"a2370f155a623d7a11be6e3312cdfadee5907fd5","modified":1632766983686},{"_id":"public/archives/page/4/index.html","hash":"122a2665876f1861b5edf94d05fd262eaee9a4ab","modified":1632766983686},{"_id":"public/archives/page/5/index.html","hash":"ec8902c9d525d49edad51044755cd1ea8a6af510","modified":1632766983686},{"_id":"public/archives/page/6/index.html","hash":"e677e71152fe30558c19b760a5b2227cf2aba6db","modified":1632766983686},{"_id":"public/archives/page/7/index.html","hash":"80b5ea8fce6ecaa4113880455923a714436baebb","modified":1632766983686},{"_id":"public/archives/page/8/index.html","hash":"244f27ada91de8629686455eaa82758cd18f99c9","modified":1632766983686},{"_id":"public/archives/2016/page/2/index.html","hash":"9786dfb0efa5b3252abe613d0383395377b81fd7","modified":1632766983686},{"_id":"public/archives/page/9/index.html","hash":"f38d550873c091751813e92728b50c9451cb7473","modified":1632766983686},{"_id":"public/archives/2016/index.html","hash":"94f1d4debe7a420a65e2d40008fcd68c19e19ab6","modified":1632766983686},{"_id":"public/archives/2016/page/3/index.html","hash":"13b83a8266967d2bf34b29428152ab8823a8ab47","modified":1632766983686},{"_id":"public/archives/2016/10/index.html","hash":"6e69350f3f6c603012d14feb9fe57d72cc57b304","modified":1632766983686},{"_id":"public/archives/2016/10/page/2/index.html","hash":"d077a498169021a5b0e9a865e01d34150531baff","modified":1632766983686},{"_id":"public/archives/2017/index.html","hash":"de7c007f50e48eba2aabdade5e1e0b6329155ce1","modified":1632766983686},{"_id":"public/archives/2017/page/2/index.html","hash":"a59766ffbc2b09eb1c0a38203dea9a4b57c142db","modified":1632766983686},{"_id":"public/archives/2017/03/index.html","hash":"68b5149ecf31ae6a199a9d9bae846e151f0168ff","modified":1632766983686},{"_id":"public/archives/2018/index.html","hash":"ca3ea8e056f4161c6115ff1031639a1979a3c427","modified":1632766983686},{"_id":"public/archives/2018/02/index.html","hash":"0b8527081755ede081ab0b74dc56bdb5588eb3f9","modified":1632766983686},{"_id":"public/archives/2021/index.html","hash":"79ce89eafd002f5945cf65be6346782f3aff1c88","modified":1632766983686},{"_id":"public/categories/iOS/index.html","hash":"463c00b24ad62dcbb863035532690917615f6f3c","modified":1632766983686},{"_id":"public/categories/Linux/index.html","hash":"9aa43b1d28f46ca47676a788b9fc0daf00bcc26b","modified":1632766983686},{"_id":"public/categories/iOS/page/3/index.html","hash":"cc66e379a9826ffa4a5989da6aa4cbb54829f548","modified":1632766983686},{"_id":"public/categories/iOS/page/2/index.html","hash":"3d431d5702987b048654555de413b37e73f7f8d8","modified":1632766983686},{"_id":"public/categories/iOS/page/5/index.html","hash":"8f38edb4088f6a6fa418c7f4eb884bdda2466778","modified":1632766983686},{"_id":"public/categories/iOS/page/4/index.html","hash":"e7dc343cbbd9ddfa8f76af38db24016858d36b36","modified":1632766983686},{"_id":"public/categories/iOS/page/6/index.html","hash":"92729e51fc8d267f0a0e43ad4c5f5a6889411e56","modified":1632766983686},{"_id":"public/index.html","hash":"dbff75ee3776ba693942986908ee1bee68e67cf8","modified":1632766983686},{"_id":"public/page/2/index.html","hash":"46a79ee08002e9b9aa84f5d8f849306948b58042","modified":1632766983686},{"_id":"public/page/3/index.html","hash":"f58595ef48504e8ccd2646b2f5d0a474e6a09bef","modified":1632766983686},{"_id":"public/page/5/index.html","hash":"6c34f912b7ca8b0c355cc7c059775e5e0da1b0e8","modified":1632766983686},{"_id":"public/page/4/index.html","hash":"c31ddcdbfb5f4cfde433fed3508358b7c83012f5","modified":1632766983686},{"_id":"public/page/7/index.html","hash":"d985b10ee59625ee5e0b8fae333fbdec8b490a2f","modified":1632766983686},{"_id":"public/page/6/index.html","hash":"f71b7e9a4d1b611a13e3592f18abcd63830d6611","modified":1632766983686},{"_id":"public/tags/iOS/index.html","hash":"7e9e30b49571f720b22327b9c8ceef3bdfddbe40","modified":1632766983686},{"_id":"public/tags/iOS/page/2/index.html","hash":"2bea3654035f1200e1d7dd25ff5b2341e471c805","modified":1632766983686},{"_id":"public/page/8/index.html","hash":"7c80d089aa55c71c353cd5e4386253761b24407e","modified":1632766983686},{"_id":"public/tags/iOS/page/3/index.html","hash":"f6a754a379e25f609b1408206d494b3d413cc145","modified":1632766983686},{"_id":"public/page/9/index.html","hash":"0421eebe34230d166c4f6e26b5739ac2e3137be5","modified":1632766983686},{"_id":"public/tags/iOS/page/4/index.html","hash":"6cc5c76309e9833aa33944e28285cf94402b6903","modified":1632766983686},{"_id":"public/tags/iOS/page/5/index.html","hash":"eb1357b2919d3aab7b1e8f0d06bfb01162a9c29b","modified":1632766983686},{"_id":"public/tags/iOS/page/6/index.html","hash":"8ce826332c342a651545df72f7b446a61e345509","modified":1632766983686},{"_id":"public/tags/底层原理/index.html","hash":"16d86b248bd95a6c335f1b1f18b884b4524c1ab2","modified":1632766983686},{"_id":"public/tags/Flow-ci/index.html","hash":"adf4f9aed630ca880b64bf2ed919b1a2c3f269a8","modified":1632766983686},{"_id":"public/CNAME","hash":"f75021fa42fa364066ec70133391150a89b406b0","modified":1625508788002},{"_id":"public/images/pasted-0.png","hash":"c0918553b8c5976f49ee8776962b2e6337dd9210","modified":1625508788002},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1625508788002},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1625508788002},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1625508788002},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1625508788002},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1625508788002},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1625508788002},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1625508788002},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1625508788002},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1625508788002},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1625508788002},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1625508788002},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1625508788002},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1625508788002},{"_id":"public/lib/fancybox/LICENSE","hash":"8624bcdae55baeef00cd11d5dfcfa60f68710a02","modified":1625508788002},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1625508788002},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"284416885e4e80e27fa4eae6fc305f4de15b914c","modified":1625508788002},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1625508788002},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1625508788002},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"e56ad6b82caf69066de545201014291fc961635e","modified":1625508788002},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"a3b131a9a47ccc16f4dd8988fabb6d306548db2f","modified":1625508788002},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1625508788002},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1625508788002},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1625508788002},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1625508788002},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1625508788002},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1625508788002},{"_id":"public/lib/fancybox/README.html","hash":"a4aaf51e67fb87df01c2a65f9fc2882bc53a8f54","modified":1625508788002},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1625508788002},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1625508788002},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1625508788002},{"_id":"public/lib/fancybox/source/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1625508788002},{"_id":"public/css/main.css","hash":"640443e2d67d4a93b1c1433d07896c430e4b7274","modified":1625508788002},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1625508788002},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1625508788002},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1625508788002},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"e43435fb9eaa918f5b8e35c9e110124b8bd13751","modified":1625508788002},{"_id":"public/lib/fancybox/source/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1625508788002},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"27f034e5db8c32e268e2959b9a7c1258d36e4510","modified":1625508788002},{"_id":"public/images/pasted-1.png","hash":"9b5536674cfae526b4328c97531dbb81feeb4fae","modified":1625508788002},{"_id":"public/images/pasted-2.png","hash":"c1ea0115ba374112a104d1671bd0933ece3c981a","modified":1625508788002},{"_id":"public/assets/algolia/algoliasearch.js","hash":"6948fcdf071e4983e784e8c458cf201536f77792","modified":1625508788002},{"_id":"source/_drafts/iOS-底层原理-Runtime-API.md","hash":"8b3f4c67f008968274e0fde60dae8ed19c0ee13f","modified":1626536397845},{"_id":"source/_posts/iOS-底层原理-Runtime-API.md","hash":"6bc8857e830bbc2377a999caa0f029f6b79ec42c","modified":1626537189367},{"_id":"public/archives/2021/07/index.html","hash":"359435c750954d62991976dc33a0c8cdf798e055","modified":1632766983686},{"_id":"public/tags/iOS/page/7/index.html","hash":"6c9188bbc84c83d9132e78f064b44bab247bab09","modified":1632766983686},{"_id":"public/post/11ed4e5e.html","hash":"4bc814acdfa174dfb088019bf3a3c7c019610cb6","modified":1632766983686},{"_id":"source/_drafts/Swift-5-4-Result-Builder.md","hash":"42c794233ccd72be7cb9121b89d6afa98afb7def","modified":1626591788805},{"_id":"source/_posts/Swift-5-4-Result-Builder.md","hash":"9172c2a63c8bfd78681bc900a22bdc3cdd91f18d","modified":1629536472999},{"_id":"public/archives/2021/page/2/index.html","hash":"ac3a222b1e73c7fde54830f5fbb4a3ec379da8e5","modified":1632766983686},{"_id":"public/post/4bf15bdf.html","hash":"7baf97caa8a27ff21f6c0020d47e446daac60ac0","modified":1632766983686},{"_id":"source/_drafts/iOS-底层原理-Runloop.md","hash":"52dda5093660d3ce0a5766cfde34fb01f64a39b3","modified":1626880600066},{"_id":"source/_posts/iOS-底层原理-Runloop.md","hash":"554f7644057acc187e3bac15c086216b4351f070","modified":1629907351329},{"_id":"source/_drafts/Swift5-属性包装器.md","hash":"b4b7b537ab4d1303e559bc6a95d17345c2b164f8","modified":1627575289823},{"_id":"source/_posts/Swift5-属性包装器.md","hash":"0b605e20426f1c67573adc2f066340d4af5f9c83","modified":1629536379068},{"_id":"public/post/fee6666f.html","hash":"5b59131e776280d6afc0ec024f6c5afbcffd5cd3","modified":1632766983686},{"_id":"public/post/1bf095f2.html","hash":"f967e0ba41780340ab462b7a3caf4221acd3019e","modified":1632766983686},{"_id":"source/_drafts/iOS-底层原理-多线程.md","hash":"fef135ff8d96a4b3337bd9bee9e7207a82cd7c26","modified":1629731725898},{"_id":"source/_posts/iOS-底层原理-多线程.md","hash":"d1ee671f2ca46be9561d6518bb182e0c4c1a3eb9","modified":1630228895570},{"_id":"themes/next/languages/zh-Hans.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1623005545008},{"_id":"source/_drafts/Swift-5-5-新特性-async与-await.md","hash":"2c32aebb39be1d5bf6eb959abd0023d0007c7e20","modified":1629730517449},{"_id":"source/_posts/Swift-5-5-新特性-async与-await.md","hash":"884d83d85c5de72fa6c79431517f0022f9f02d5f","modified":1629731064323},{"_id":"public/archives/page/10/index.html","hash":"9cba6148d9387898d4d76871e332b1998b3b10a6","modified":1632766983686},{"_id":"public/archives/2021/08/index.html","hash":"b8c97423ad8bbf6798d1235d4886132fa303c9cc","modified":1632766983686},{"_id":"public/page/10/index.html","hash":"c60cee5f861e0766b1b5230d00b93171a125e271","modified":1632766983686},{"_id":"public/post/75996dec.html","hash":"15bc039c3bb018a0a98f80a0b06f8f43adcccae6","modified":1632766983686},{"_id":"public/post/f4b0e2bd.html","hash":"5ceed93474c5cc6f285a0efd5c6cc866d59737ca","modified":1632766983686},{"_id":"public/tags/底层原理/page/2/index.html","hash":"61a287c654f518f823d893894406acd830078892","modified":1632766983686},{"_id":"source/_drafts/iOS-底层原理-内存管理.md","hash":"1e532a2af45be8f9320af646791f2960db50ccd6","modified":1630729472026},{"_id":"source/_drafts/Swift-底层原理.md","hash":"7401db78de1fe882bc7b2d43d43abcd5b456fe5e","modified":1630229215066},{"_id":"source/_posts/最近看了一本书.md","hash":"7edddb7c8b0bfa0b0db7a653187a21e724565d1b","modified":1630249450654},{"_id":"public/post/a4ffdee.html","hash":"b40b263142b627343f7bb6cc4c5fa484036cdc31","modified":1632766983686},{"_id":"source/_posts/iOS-性能优化.md","hash":"c08e445ba268007f73f0a0fe0cdf310f70af1ea2","modified":1630417632428},{"_id":"public/post/a2ff8280.html","hash":"0e404d4c04fe3e2c938ddde4d91829dc9d47c8b0","modified":1632766983686},{"_id":"source/_posts/iOS-底层原理-内存管理.md","hash":"38933d914e77ea8930dbc189ddf0958637d2ff32","modified":1630734207921},{"_id":"source/_posts/LLVM.md","hash":"11798581fde32d34b93010bea5c74bfa75dcda13","modified":1632057382789},{"_id":"public/post/6d8a8bc2.html","hash":"3bd6a4df088750da4e7b0c61d61a4614625a9af7","modified":1632766983686},{"_id":"public/post/56d1bd42.html","hash":"a18982c4070abaf3243d156e2b7c6c804ac90f00","modified":1632766983686},{"_id":"public/archives/2021/09/index.html","hash":"a00554c91c821c974a0647a8187f39a8c8ac8512","modified":1632766983686},{"_id":"source/_posts/函数式Swift-透镜.md","hash":"b655b71d10c50656bf2209cbcf1ffbdb6c02dd20","modified":1632766959872},{"_id":"source/_drafts/汇编分析Swift-inout与函数内联优化.md","hash":"f26922925c61f944d750a1537fe7b9c30ad6d211","modified":1632202387725},{"_id":"source/_discarded/Swift-底层原理.md","hash":"f69527f24206ceeb06a9a4321195dd5129a63d87","modified":1632194618122},{"_id":"public/post/c5814bfc.html","hash":"5dd90a012a497f7db5bfe7eb2a3815e1c2536294","modified":1632766983686}],"Category":[{"name":"Linux","_id":"ckqqxyogl0004tnn034kk191r"},{"name":"iOS","_id":"ckqqxyogo000atnn07g1s383m"},{"name":"C++","_id":"ckqqxyogw000utnn07d4vff0u"},{"name":"Node.js","_id":"ckqqxyogx0012tnn0hwhghjqd"},{"name":"MongoDB","_id":"ckqqxyoh0001atnn0h1b988r8"},{"name":"Jenkins","_id":"ckqqxyoh2001jtnn0177g9wjl"},{"name":"React Native","_id":"ckqqxyoh4001stnn0hjk53tpy"},{"name":"前端","_id":"ckqqxyohl002wtnn08onpakbq"},{"name":"PHP","_id":"ckqqxyohp003ktnn073xcbrc6"},{"name":"杂谈","_id":"ckqqxyoii0064tnn0dssn33kw"},{"name":"Swift","_id":"ckqqxyoiq006xtnn05ihlamjg"},{"name":"Git","_id":"ckqqxyojf0080tnn0hf5jf86p"}],"Data":[],"Page":[{"title":"分类","date":"2018-02-16T14:05:11.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-02-16 22:05:11\ntype: categories\ncomments: false\n---\n","updated":"2021-06-06T18:52:24.974Z","path":"categories/index.html","layout":"page","_id":"ckqqxyogd0000tnn0finyhqxj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-02-16T14:05:25.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-02-16 22:05:25\ntype: tags\ncomments: false\n---\n","updated":"2021-06-06T18:52:24.976Z","path":"tags/index.html","layout":"page","_id":"ckqqxyogi0002tnn0ejlu2234","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于","type":"about","date":"2018-02-16T14:05:46.000Z","_content":"如果你想联系我，发邮件到`arclin325@gmail.com`，有时间我一定会回复你：）","source":"about/index.md","raw":"title: 关于\ntype: about\ndate: 2018-02-16 22:05:46\n---\n如果你想联系我，发邮件到`arclin325@gmail.com`，有时间我一定会回复你：）","updated":"2021-06-06T18:52:24.975Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckqqxyogm0006tnn0csvwh0q0","content":"<p>如果你想联系我，发邮件到<code>arclin325@gmail.com</code>，有时间我一定会回复你：）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>如果你想联系我，发邮件到<code>arclin325@gmail.com</code>，有时间我一定会回复你：）</p>\n"}],"Post":[{"title":"安装shadowsocks服务端","author":"Arclin","abbrlink":"eb81866c","date":"2018-02-18T14:15:00.000Z","_content":"安装shadowsocks服务端\n\n<!-- more -->\n\n```\nsudo yum install python-pip\nsudo pip install shadowsocks\n```\n\n配置文件\n\n```\n{\n \"server”:”172.93.xx.xx”, # 服务器IP \n \"server_port\":8388, # 端口号\n \"local_address\": \"127.0.0.1\",\n \"local_port”:1080,\n \"password\":\"gtPtAb)Wsss\", # 密码\n \"timeout\":300,\n \"method\":\"aes-256-cfb\",# 加密类型\n \"fast_open\": false\n}\n```","source":"_drafts/安装shadowsocks服务端.md","raw":"title: 安装shadowsocks服务端\nauthor: Arclin\ntags:\n  - Shadowsocks\ncategories:\n  - Linux\nabbrlink: eb81866c\ndate: 2018-02-18 22:15:00\n---\n安装shadowsocks服务端\n\n<!-- more -->\n\n```\nsudo yum install python-pip\nsudo pip install shadowsocks\n```\n\n配置文件\n\n```\n{\n \"server”:”172.93.xx.xx”, # 服务器IP \n \"server_port\":8388, # 端口号\n \"local_address\": \"127.0.0.1\",\n \"local_port”:1080,\n \"password\":\"gtPtAb)Wsss\", # 密码\n \"timeout\":300,\n \"method\":\"aes-256-cfb\",# 加密类型\n \"fast_open\": false\n}\n```","slug":"安装shadowsocks服务端","published":0,"updated":"2021-06-10T15:24:02.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyogf0001tnn0b2nv418n","content":"<p>安装shadowsocks服务端</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install python-pip</span><br><span class=\"line\">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure>\n\n<p>配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> &quot;server”:”172.93.xx.xx”, # 服务器IP </span><br><span class=\"line\"> &quot;server_port&quot;:8388, # 端口号</span><br><span class=\"line\"> &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\"> &quot;local_port”:1080,</span><br><span class=\"line\"> &quot;password&quot;:&quot;gtPtAb)Wsss&quot;, # 密码</span><br><span class=\"line\"> &quot;timeout&quot;:300,</span><br><span class=\"line\"> &quot;method&quot;:&quot;aes-256-cfb&quot;,# 加密类型</span><br><span class=\"line\"> &quot;fast_open&quot;: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>安装shadowsocks服务端</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install python-pip</span><br><span class=\"line\">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure>\n\n<p>配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> &quot;server”:”172.93.xx.xx”, # 服务器IP </span><br><span class=\"line\"> &quot;server_port&quot;:8388, # 端口号</span><br><span class=\"line\"> &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\"> &quot;local_port”:1080,</span><br><span class=\"line\"> &quot;password&quot;:&quot;gtPtAb)Wsss&quot;, # 密码</span><br><span class=\"line\"> &quot;timeout&quot;:300,</span><br><span class=\"line\"> &quot;method&quot;:&quot;aes-256-cfb&quot;,# 加密类型</span><br><span class=\"line\"> &quot;fast_open&quot;: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"2016-Dankal-iOS-MySummary","author":"Arclin","abbrlink":"61929cc2","date":"2017-01-23T16:00:00.000Z","_content":"总结2016在 Dankal 工作过程中学习到的东西\n\n<!-- more -->\n\n### Main Argument 主要论点\n中介者\n组件化\n封装\nMVVM\nReactiveCocoa\n\n### 基于MVC的组件化设计 CTMediator + （CTNetworking -> DKNetworking -> DKHTTPTool）\nCTMediator和CTNetworking 是我在5-6月份左右看的一套源码，出处是这里,然后去年年底作者又发布了[基于 CTMediator工程实践](http://casatwy.com/modulization_in_action.html)。总的设计思想如下：\n\n### 组件逻辑\n\n- CTMediator 是一种组件化方案，主要是针对大型项目多人开发情况下的一种方案。路由方式是 Targer-Action，通过这种方式进行模块之间的沟通，模块使用私有 pod 进行封装（这个是在第二篇的实践中提出来的），因为目前我们还没接触过这种大型的项目，所以一直停留在理论阶段（也就是虽然我看懂了源码的设计思想但是却没得地方实现），后来启动了觅书项目，打算尝试这种设计，结果发现过于大材小用了。模块的创建要先通过中介者进行注册，调用要通过中介者进行调用，总结一下大概就像这样子：\n\n```\n             --------------------------------------\n             | [CTMediator sharedInstance]        |\n             |                                    |\n             |                openUrl:       <<<<<<<<<  (AppDelegate)  <<<<  Call From Other App With URL\n             |                                    |\n             |                   |                |\n             |                   |/               |\n             |                parseUrl            |\n             |                                    |\n             |                   |                |\n.................................|...............................\n             |                   |                |\n             |                   |/               |\n             |  performTarget:action:params: <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  Call From Native Module\n             |                   |/               |\n             |             -------------          |\n             |             |  runtime  |          |\n             |             -------------          |\n             ---------------.---------.------------\n                           .           .\n                          .             .\n-------------------------------      --------------------------------\n|                       ·     |      |    ·                         |\n|                     ·       |      |     ·                        |\n|           Target            |      |           Target             |\n|                             |      |                              |\n|         /   |   \\           |      |         /   |   \\            |\n|        /    |    \\          |      |        /    |    \\           |\n|                             |      |                              |\n|   Action Action Action ...  |      |   Action Action Action ...   |\n|                             |      |                              |\n|Service  A                   |      | Service  B                   |\n-------------------------------      --------------------------------\n```\n\n这里面包括了内部调用和远程应用调用，远程应用调用因为我们目前还用不着所以先不管，内部调用的流程为了方便理解我举个例子，fromController通过performTarget:action:params:方法传入toController类名和在toController要执行的方法和所需的参数，这样子组件之间就实现了解耦，fromController 只需要知道他想去的地方是 toController和要给什么值出去，甚至这个 controller 存不存在都无所谓，而 toController 只需要遵循协议方法/重写父类方法去的到参数即可，然后里面就可以直接调这个参数，并且这一系列跳转规则和传参规则都通过 CTMediator 中介者去控制。\n\n### 服务层（Service Layer） 或者叫 业务层（Business Layer）\n\n刚刚总结了一下CTMediator的组件间的逻辑,现在来总结一下业务层与 ViewController 层之间的设计.因为虽然是 MVC，那当然也得尽量避免 Mess View Controller ,Service 在这里可以理解为数据仓库+业务逻辑仓库，为的是令ViewController中避免出现像数据 A处理判断完才显示到控件上的情况，尽量能把最直接的数据给 ViewController 显示,利用像下图这种方式，业务层暴露出 Target 和 action供外界调用，调用方法后就进入了CTMediator 进行处理，接下来的事情就像我上面说的一样了。\n\n```\n         --------------------------------\n         |           Service  A         |\n         ---  ----------  ----------  ---\n           |  |        |  |        |  |\n...........|  |........|  |........|  |...........\n.          |  |        |  |        |  |          .\n.        ---  ---    ---  ---    ---  ---        .\n.        |action|    |action|    |action|        .\n.        ---|----    -----|--    --|-----        .\n.           |             |        |             .\n.           |             |        |             .\n.       ----|------     --|--------|--           .\n.       |Target_A1|     |  Target_A2 |           .\n.       -----------     --------------           .\n..................................................\n```\n\n### CTNetworking -> DKNetworking -> DKHTTPTool\n\n- CTNetworking 是一个基于AFNetworking的开源网络层组件，经过改装之后我组装出了 DKNetworking（虽然后面发现有 RAC神器之后就觉得这个东西不够轻便了）。\n\n- CTNetworking 解决了以下几个问题\n\t- 使用哪种交互模式来跟业务层做对接？\n\t- 是否有必要将API返回的数据封装成对象然后再交付给业务层？\n\t- 使用集约化调用方式还是离散型调用方式去调用API？\n\n- 上面三个问题分别给出的答案是\n\t- 代理模式\n\t- 没必要\n\t- 离散型\n\n- CTNetworking考虑的东西相当地多，除了上面几个问题之外，还考虑到了网络层安全机制（数据传输，HTTPS）,链接环节的优化（链接传输量和链接复用）等，一开始看源码也是看的很懵逼\n- 通过协议的方式进行组件内的方法封装\n\n|协议名|解释|\n|----|----|\n|CTAPIManagerApiCallBackDelegate|回调协议|\n|CTAPIManagerCallbackDataReformer|负责重新组装API数据的对象|\n|CTAPIManagerValidator|验证器验证参数和返回|\n|CTAPIManagerParamSourceDelegate|参数源|\n|CTAPIManager|CTAPIBaseManager的派生类必须符合这个protocal|\n|CTAPIManagerInterceptor|拦截器，拦截参数和回调|\n\n- 用协议的好处就是各取所需。当你想要统一管理所有回调的时候，那你这个类只要遵循`CTAPIManagerApiCallBackDelegate`代理和实现对应的方法，如果你这个类想要拦截参数，那么就遵循`CTAPIManagerInterceptor`协议并实现对应的方法，大抵就是这种思想，然后底层就会进行各种判断并拼接各个协议的方法的返回值，最后发出请求，得到回调然后处理值并返回出去。\n\n- CTNetworking 框架没有使用数据模型，原因就是认为模型嵌入模型的时候处理数据很麻烦，另外模型的复用性很差，容易出现类型爆炸，提高维护成本，还有就是不够NSDictionary、NSArray直观,最最重要的一点就是同一API的数据被不同View展示时，难以控制数据转化的代码，它们有可能会散落在任何需要的地方。所以框架使用了 Reformer 的方法去处理返回的数据（NSDictionary）转成 View 需要的数据（NSDictionary）。\n\n- DKNetworking 把 Refromer 部分的实现给改了，依赖了 MJExtension，去实现数据模型数组，因为总感觉NSDictionary很麻烦，难维护就难维护吧，反正项目也不大。\n\n- DKHTTPTool 是我在近期集成出来的框架，主要特性包括：\n\t- 支持缓存策略选择\n\t- 支持链式调用\n\t- 支持 RACSignal 返回\n\t- 支持拦截器、验证器\n\t- 支持直观的Logger输出\n\t- 支持全局请求头、请求参数\n\t- 服务器异常直接弹出异常数据而不是一坨 NSData\n\t- 支持错误码表，统一处理错误\n    \n还有其他的吗？忘记了\n总的来说，这个还是挺管用的,毕竟能支持 RAC,符合我们现在的 \nMVVM+ReactiveCocoa的架构\n\n### MVVM+ReactiveCocoa\n\n- ReactiveCocoa 博大精深，以致于现在都用不到它提供的功能的一半\n- 第二份优秀的源码（虽然跑不起来）[MVVMReactiveCocoa](https://github.com/leichunfeng/MVVMReactiveCocoa)\n- 产出成品[Poi](https://coding.net/u/Arclin/p/Poi/git)\n\n### Navigation-With-ViewModel\n\n 使用 MVVM 模式应该注意的问题\n\n- 以 ViewModel 为驱动引导着整个应用而不是 ViewController\n- ViewModel 中不应该引入任何 UIKit 框架\n- 模块与模块间通过 服务总线 去沟通 , 减少模块之间的耦合\n\n先看看用 ViewModel 进行 push操作的流程\n\n ```\n--------------------------------    \n|        ViewModel A           |   \n---  ----------  ----------  ---   \n\t|\n\t| \n[- initWithService:params:]\n\t| ---------------\n\t| | service bus | --- > - pushViewModel: animated: \n\t| ---------------                 |\n\t|\t\t\t             （HOOK）[rac_responseToSelector:]\n\t|\t\t\t                     |/\n\t|\t\t\t               <DKNavigationProtocol>-- @{ viewModel:viewController}--->navigationController [pushViewController:animated:]\n\t|/\n --------------------------------\n |        ViewModel B           |\n ---  ----------  ----------  ---\n```\n\n说明： ViewModelA 与 ViewControllerA ，ViewModelB 与 ViewControllerB 在 Router 里面通过字典的方式绑定在了一起，然后通过 RAC的方法监听pushViewModel: animated: 方法的执行，然后通过字典得到viewController从而进行真正的 push 操作，大概就是这样子\n\n### 抽出父类和ReactiveCocoa\n\nMVVMReactiveCocoa 通过封装父类的方式来实现这个架构，这些父类已经被我抽出来了，过几天会传上去，然后先写一些使用说明\n\n1. 每个 Vc 对应一个 ViewModel\n2. TableViewController必须对应 ViewModel\n3. ViewModel 的初始化方法在 - initliazed 中\n4. 初始化之前添加一些额外的方法，需要重写 - initWithServer:params:\n5. DKTableViewController是一个二维数组，里面封装的是 viewmodel\n6. cell 要遵循 DKReactiveView 协议\n7. 绑定 cell与 viewModel 就在 ViewController里面重写 configureCell:withObject\n8. 待补充\n\nReativeCocoa 主要是用来实现 MVVM 的融合剂，当然也不一定要用 RAC去实现 MVVM,说实话 RAC 的学习成本还是相当高的，目前已经在尝试 DKRACHTTPTool,用纯 RAC 的方式去实现网络层和数据持久层的封装，另外还有些异常处理之类的,在这里面使用了filter: ignore: thottle: startWith: doNext: catch: try: doComplete: map: flattenMap: flatten: 等等的方法，非常好使，其他的可以看看我的几篇笔记\"使用RAC-DKHTTPTool实践\"、\"RACCommand使用注意\"\n\n最近的一个个人项目 Poi 就实践了这个架构。UI 结构如下\n\n```\n   \t    --------------------------------\n            |     NavigationConroller0     |\n            ---  ----------  ----------  ---\n\t\t\t    |\n \t    --------------------------------\n            |       TabBarController       |\n            ---  ----------  ----------  ---\n\t\t|\t\t\t |\n--------------------------------     --------------------------------   \n|     NavigationConroller1     |     |     NavigationConroller2     |\n---  ----------  ----------  ---     ---  ----------  ----------  ---\n\t\t|                   \t\t    |\n--------------------------------     --------------------------------\n|       ViewConroller1         |     |       ViewConroller2         |\n---  ----------  ----------  --      --------------------------------\n```\n\n默认整个应用的跳转用的是NavigationConroller0，这样子做的原因是使用了一个第三方框架，为了可以在TabBarController中滑动切换。\n当 pushViewModel 执行的时候，有一个 NavigationStack 会拿到最底部的 NavigationController 进行 push，如果 modal 出一个 navigationController,那么这个 navigationcontroller 将会压入NavigationStack ,然后这个 modal 出来的 viewController 后面的页面跳转就用这个 stack最上层的 NavigationController，dismiss 之后就会就会从栈中移除这个 NavigationController\n\n大概就是长这样子\n\n```\n--------------------------------\n|     NavigationConroller0     |  \n---  ----------  ----------  ---    \n\t\t |\tstack + 1\tpush\n--------------------------------    \n|       TabBarController       |    \n---  ----------  ----------  ---  \n\t\t |\t\t           \n--------------------------------   \n|     NavigationConroller1     |    \n---  ----------  ----------  ---    \n\t\t |      nv0 push     \n--------------------------------    \n|       ViewConroller1         |    \n---  ----------  ----------  ---\t  \n\t\t |   \tv1 modal\n--------------------------------    \n|      NavigationConroller2    |    \n---  ----------  ----------  ---\t  \n\t\t |     stack + 1  push   \n--------------------------------    \n|      ViewConroller2\t       |    \n---  ----------  ----------  ---\t\n\t\t| dismiss\n\tstack - 1 pop\n```\n\n### MVVM WithOut ReacitveCocoa\n用 Block 的方式代替 Reactive 的绑定功能。\n\n### 其他\n- BugReporter For iOS\n\t- 和思华一起开发的基于 iOS 的 bug自动反馈系统，一旦发生崩溃事故就会给开发者发送邮件\n- 自动部署系统Jenkines\n- JSPatch 热修复平台\n- UMeng 用户数据统计\n- 等等","source":"_posts/2016-Dankal-iOS-MySummary.md","raw":"---\ntitle: 2016-Dankal-iOS-MySummary\nauthor: Arclin\ntags:\n  - iOS\n  - 杂谈\ncategories:\n  - iOS\nabbrlink: 61929cc2\ndate: 2017-01-24 00:00:00\n---\n总结2016在 Dankal 工作过程中学习到的东西\n\n<!-- more -->\n\n### Main Argument 主要论点\n中介者\n组件化\n封装\nMVVM\nReactiveCocoa\n\n### 基于MVC的组件化设计 CTMediator + （CTNetworking -> DKNetworking -> DKHTTPTool）\nCTMediator和CTNetworking 是我在5-6月份左右看的一套源码，出处是这里,然后去年年底作者又发布了[基于 CTMediator工程实践](http://casatwy.com/modulization_in_action.html)。总的设计思想如下：\n\n### 组件逻辑\n\n- CTMediator 是一种组件化方案，主要是针对大型项目多人开发情况下的一种方案。路由方式是 Targer-Action，通过这种方式进行模块之间的沟通，模块使用私有 pod 进行封装（这个是在第二篇的实践中提出来的），因为目前我们还没接触过这种大型的项目，所以一直停留在理论阶段（也就是虽然我看懂了源码的设计思想但是却没得地方实现），后来启动了觅书项目，打算尝试这种设计，结果发现过于大材小用了。模块的创建要先通过中介者进行注册，调用要通过中介者进行调用，总结一下大概就像这样子：\n\n```\n             --------------------------------------\n             | [CTMediator sharedInstance]        |\n             |                                    |\n             |                openUrl:       <<<<<<<<<  (AppDelegate)  <<<<  Call From Other App With URL\n             |                                    |\n             |                   |                |\n             |                   |/               |\n             |                parseUrl            |\n             |                                    |\n             |                   |                |\n.................................|...............................\n             |                   |                |\n             |                   |/               |\n             |  performTarget:action:params: <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  Call From Native Module\n             |                   |/               |\n             |             -------------          |\n             |             |  runtime  |          |\n             |             -------------          |\n             ---------------.---------.------------\n                           .           .\n                          .             .\n-------------------------------      --------------------------------\n|                       ·     |      |    ·                         |\n|                     ·       |      |     ·                        |\n|           Target            |      |           Target             |\n|                             |      |                              |\n|         /   |   \\           |      |         /   |   \\            |\n|        /    |    \\          |      |        /    |    \\           |\n|                             |      |                              |\n|   Action Action Action ...  |      |   Action Action Action ...   |\n|                             |      |                              |\n|Service  A                   |      | Service  B                   |\n-------------------------------      --------------------------------\n```\n\n这里面包括了内部调用和远程应用调用，远程应用调用因为我们目前还用不着所以先不管，内部调用的流程为了方便理解我举个例子，fromController通过performTarget:action:params:方法传入toController类名和在toController要执行的方法和所需的参数，这样子组件之间就实现了解耦，fromController 只需要知道他想去的地方是 toController和要给什么值出去，甚至这个 controller 存不存在都无所谓，而 toController 只需要遵循协议方法/重写父类方法去的到参数即可，然后里面就可以直接调这个参数，并且这一系列跳转规则和传参规则都通过 CTMediator 中介者去控制。\n\n### 服务层（Service Layer） 或者叫 业务层（Business Layer）\n\n刚刚总结了一下CTMediator的组件间的逻辑,现在来总结一下业务层与 ViewController 层之间的设计.因为虽然是 MVC，那当然也得尽量避免 Mess View Controller ,Service 在这里可以理解为数据仓库+业务逻辑仓库，为的是令ViewController中避免出现像数据 A处理判断完才显示到控件上的情况，尽量能把最直接的数据给 ViewController 显示,利用像下图这种方式，业务层暴露出 Target 和 action供外界调用，调用方法后就进入了CTMediator 进行处理，接下来的事情就像我上面说的一样了。\n\n```\n         --------------------------------\n         |           Service  A         |\n         ---  ----------  ----------  ---\n           |  |        |  |        |  |\n...........|  |........|  |........|  |...........\n.          |  |        |  |        |  |          .\n.        ---  ---    ---  ---    ---  ---        .\n.        |action|    |action|    |action|        .\n.        ---|----    -----|--    --|-----        .\n.           |             |        |             .\n.           |             |        |             .\n.       ----|------     --|--------|--           .\n.       |Target_A1|     |  Target_A2 |           .\n.       -----------     --------------           .\n..................................................\n```\n\n### CTNetworking -> DKNetworking -> DKHTTPTool\n\n- CTNetworking 是一个基于AFNetworking的开源网络层组件，经过改装之后我组装出了 DKNetworking（虽然后面发现有 RAC神器之后就觉得这个东西不够轻便了）。\n\n- CTNetworking 解决了以下几个问题\n\t- 使用哪种交互模式来跟业务层做对接？\n\t- 是否有必要将API返回的数据封装成对象然后再交付给业务层？\n\t- 使用集约化调用方式还是离散型调用方式去调用API？\n\n- 上面三个问题分别给出的答案是\n\t- 代理模式\n\t- 没必要\n\t- 离散型\n\n- CTNetworking考虑的东西相当地多，除了上面几个问题之外，还考虑到了网络层安全机制（数据传输，HTTPS）,链接环节的优化（链接传输量和链接复用）等，一开始看源码也是看的很懵逼\n- 通过协议的方式进行组件内的方法封装\n\n|协议名|解释|\n|----|----|\n|CTAPIManagerApiCallBackDelegate|回调协议|\n|CTAPIManagerCallbackDataReformer|负责重新组装API数据的对象|\n|CTAPIManagerValidator|验证器验证参数和返回|\n|CTAPIManagerParamSourceDelegate|参数源|\n|CTAPIManager|CTAPIBaseManager的派生类必须符合这个protocal|\n|CTAPIManagerInterceptor|拦截器，拦截参数和回调|\n\n- 用协议的好处就是各取所需。当你想要统一管理所有回调的时候，那你这个类只要遵循`CTAPIManagerApiCallBackDelegate`代理和实现对应的方法，如果你这个类想要拦截参数，那么就遵循`CTAPIManagerInterceptor`协议并实现对应的方法，大抵就是这种思想，然后底层就会进行各种判断并拼接各个协议的方法的返回值，最后发出请求，得到回调然后处理值并返回出去。\n\n- CTNetworking 框架没有使用数据模型，原因就是认为模型嵌入模型的时候处理数据很麻烦，另外模型的复用性很差，容易出现类型爆炸，提高维护成本，还有就是不够NSDictionary、NSArray直观,最最重要的一点就是同一API的数据被不同View展示时，难以控制数据转化的代码，它们有可能会散落在任何需要的地方。所以框架使用了 Reformer 的方法去处理返回的数据（NSDictionary）转成 View 需要的数据（NSDictionary）。\n\n- DKNetworking 把 Refromer 部分的实现给改了，依赖了 MJExtension，去实现数据模型数组，因为总感觉NSDictionary很麻烦，难维护就难维护吧，反正项目也不大。\n\n- DKHTTPTool 是我在近期集成出来的框架，主要特性包括：\n\t- 支持缓存策略选择\n\t- 支持链式调用\n\t- 支持 RACSignal 返回\n\t- 支持拦截器、验证器\n\t- 支持直观的Logger输出\n\t- 支持全局请求头、请求参数\n\t- 服务器异常直接弹出异常数据而不是一坨 NSData\n\t- 支持错误码表，统一处理错误\n    \n还有其他的吗？忘记了\n总的来说，这个还是挺管用的,毕竟能支持 RAC,符合我们现在的 \nMVVM+ReactiveCocoa的架构\n\n### MVVM+ReactiveCocoa\n\n- ReactiveCocoa 博大精深，以致于现在都用不到它提供的功能的一半\n- 第二份优秀的源码（虽然跑不起来）[MVVMReactiveCocoa](https://github.com/leichunfeng/MVVMReactiveCocoa)\n- 产出成品[Poi](https://coding.net/u/Arclin/p/Poi/git)\n\n### Navigation-With-ViewModel\n\n 使用 MVVM 模式应该注意的问题\n\n- 以 ViewModel 为驱动引导着整个应用而不是 ViewController\n- ViewModel 中不应该引入任何 UIKit 框架\n- 模块与模块间通过 服务总线 去沟通 , 减少模块之间的耦合\n\n先看看用 ViewModel 进行 push操作的流程\n\n ```\n--------------------------------    \n|        ViewModel A           |   \n---  ----------  ----------  ---   \n\t|\n\t| \n[- initWithService:params:]\n\t| ---------------\n\t| | service bus | --- > - pushViewModel: animated: \n\t| ---------------                 |\n\t|\t\t\t             （HOOK）[rac_responseToSelector:]\n\t|\t\t\t                     |/\n\t|\t\t\t               <DKNavigationProtocol>-- @{ viewModel:viewController}--->navigationController [pushViewController:animated:]\n\t|/\n --------------------------------\n |        ViewModel B           |\n ---  ----------  ----------  ---\n```\n\n说明： ViewModelA 与 ViewControllerA ，ViewModelB 与 ViewControllerB 在 Router 里面通过字典的方式绑定在了一起，然后通过 RAC的方法监听pushViewModel: animated: 方法的执行，然后通过字典得到viewController从而进行真正的 push 操作，大概就是这样子\n\n### 抽出父类和ReactiveCocoa\n\nMVVMReactiveCocoa 通过封装父类的方式来实现这个架构，这些父类已经被我抽出来了，过几天会传上去，然后先写一些使用说明\n\n1. 每个 Vc 对应一个 ViewModel\n2. TableViewController必须对应 ViewModel\n3. ViewModel 的初始化方法在 - initliazed 中\n4. 初始化之前添加一些额外的方法，需要重写 - initWithServer:params:\n5. DKTableViewController是一个二维数组，里面封装的是 viewmodel\n6. cell 要遵循 DKReactiveView 协议\n7. 绑定 cell与 viewModel 就在 ViewController里面重写 configureCell:withObject\n8. 待补充\n\nReativeCocoa 主要是用来实现 MVVM 的融合剂，当然也不一定要用 RAC去实现 MVVM,说实话 RAC 的学习成本还是相当高的，目前已经在尝试 DKRACHTTPTool,用纯 RAC 的方式去实现网络层和数据持久层的封装，另外还有些异常处理之类的,在这里面使用了filter: ignore: thottle: startWith: doNext: catch: try: doComplete: map: flattenMap: flatten: 等等的方法，非常好使，其他的可以看看我的几篇笔记\"使用RAC-DKHTTPTool实践\"、\"RACCommand使用注意\"\n\n最近的一个个人项目 Poi 就实践了这个架构。UI 结构如下\n\n```\n   \t    --------------------------------\n            |     NavigationConroller0     |\n            ---  ----------  ----------  ---\n\t\t\t    |\n \t    --------------------------------\n            |       TabBarController       |\n            ---  ----------  ----------  ---\n\t\t|\t\t\t |\n--------------------------------     --------------------------------   \n|     NavigationConroller1     |     |     NavigationConroller2     |\n---  ----------  ----------  ---     ---  ----------  ----------  ---\n\t\t|                   \t\t    |\n--------------------------------     --------------------------------\n|       ViewConroller1         |     |       ViewConroller2         |\n---  ----------  ----------  --      --------------------------------\n```\n\n默认整个应用的跳转用的是NavigationConroller0，这样子做的原因是使用了一个第三方框架，为了可以在TabBarController中滑动切换。\n当 pushViewModel 执行的时候，有一个 NavigationStack 会拿到最底部的 NavigationController 进行 push，如果 modal 出一个 navigationController,那么这个 navigationcontroller 将会压入NavigationStack ,然后这个 modal 出来的 viewController 后面的页面跳转就用这个 stack最上层的 NavigationController，dismiss 之后就会就会从栈中移除这个 NavigationController\n\n大概就是长这样子\n\n```\n--------------------------------\n|     NavigationConroller0     |  \n---  ----------  ----------  ---    \n\t\t |\tstack + 1\tpush\n--------------------------------    \n|       TabBarController       |    \n---  ----------  ----------  ---  \n\t\t |\t\t           \n--------------------------------   \n|     NavigationConroller1     |    \n---  ----------  ----------  ---    \n\t\t |      nv0 push     \n--------------------------------    \n|       ViewConroller1         |    \n---  ----------  ----------  ---\t  \n\t\t |   \tv1 modal\n--------------------------------    \n|      NavigationConroller2    |    \n---  ----------  ----------  ---\t  \n\t\t |     stack + 1  push   \n--------------------------------    \n|      ViewConroller2\t       |    \n---  ----------  ----------  ---\t\n\t\t| dismiss\n\tstack - 1 pop\n```\n\n### MVVM WithOut ReacitveCocoa\n用 Block 的方式代替 Reactive 的绑定功能。\n\n### 其他\n- BugReporter For iOS\n\t- 和思华一起开发的基于 iOS 的 bug自动反馈系统，一旦发生崩溃事故就会给开发者发送邮件\n- 自动部署系统Jenkines\n- JSPatch 热修复平台\n- UMeng 用户数据统计\n- 等等","slug":"2016-Dankal-iOS-MySummary","published":1,"updated":"2021-06-06T18:52:24.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyogj0003tnn06gp563wn","content":"<p>总结2016在 Dankal 工作过程中学习到的东西</p>\n<span id=\"more\"></span>\n\n<h3 id=\"Main-Argument-主要论点\"><a href=\"#Main-Argument-主要论点\" class=\"headerlink\" title=\"Main Argument 主要论点\"></a>Main Argument 主要论点</h3><p>中介者<br>组件化<br>封装<br>MVVM<br>ReactiveCocoa</p>\n<h3 id=\"基于MVC的组件化设计-CTMediator-（CTNetworking-gt-DKNetworking-gt-DKHTTPTool）\"><a href=\"#基于MVC的组件化设计-CTMediator-（CTNetworking-gt-DKNetworking-gt-DKHTTPTool）\" class=\"headerlink\" title=\"基于MVC的组件化设计 CTMediator + （CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool）\"></a>基于MVC的组件化设计 CTMediator + （CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool）</h3><p>CTMediator和CTNetworking 是我在5-6月份左右看的一套源码，出处是这里,然后去年年底作者又发布了<a href=\"http://casatwy.com/modulization_in_action.html\">基于 CTMediator工程实践</a>。总的设计思想如下：</p>\n<h3 id=\"组件逻辑\"><a href=\"#组件逻辑\" class=\"headerlink\" title=\"组件逻辑\"></a>组件逻辑</h3><ul>\n<li>CTMediator 是一种组件化方案，主要是针对大型项目多人开发情况下的一种方案。路由方式是 Targer-Action，通过这种方式进行模块之间的沟通，模块使用私有 pod 进行封装（这个是在第二篇的实践中提出来的），因为目前我们还没接触过这种大型的项目，所以一直停留在理论阶段（也就是虽然我看懂了源码的设计思想但是却没得地方实现），后来启动了觅书项目，打算尝试这种设计，结果发现过于大材小用了。模块的创建要先通过中介者进行注册，调用要通过中介者进行调用，总结一下大概就像这样子：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">             --------------------------------------</span><br><span class=\"line\">             | [CTMediator sharedInstance]        |</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                openUrl:       &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  (AppDelegate)  &lt;&lt;&lt;&lt;  Call From Other App With URL</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">             |                   |&#x2F;               |</span><br><span class=\"line\">             |                parseUrl            |</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">.................................|...............................</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">             |                   |&#x2F;               |</span><br><span class=\"line\">             |  performTarget:action:params: &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  Call From Native Module</span><br><span class=\"line\">             |                   |&#x2F;               |</span><br><span class=\"line\">             |             -------------          |</span><br><span class=\"line\">             |             |  runtime  |          |</span><br><span class=\"line\">             |             -------------          |</span><br><span class=\"line\">             ---------------.---------.------------</span><br><span class=\"line\">                           .           .</span><br><span class=\"line\">                          .             .</span><br><span class=\"line\">-------------------------------      --------------------------------</span><br><span class=\"line\">|                       ·     |      |    ·                         |</span><br><span class=\"line\">|                     ·       |      |     ·                        |</span><br><span class=\"line\">|           Target            |      |           Target             |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|         &#x2F;   |   \\           |      |         &#x2F;   |   \\            |</span><br><span class=\"line\">|        &#x2F;    |    \\          |      |        &#x2F;    |    \\           |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|   Action Action Action ...  |      |   Action Action Action ...   |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|Service  A                   |      | Service  B                   |</span><br><span class=\"line\">-------------------------------      --------------------------------</span><br></pre></td></tr></table></figure>\n\n<p>这里面包括了内部调用和远程应用调用，远程应用调用因为我们目前还用不着所以先不管，内部调用的流程为了方便理解我举个例子，fromController通过performTarget:action:params:方法传入toController类名和在toController要执行的方法和所需的参数，这样子组件之间就实现了解耦，fromController 只需要知道他想去的地方是 toController和要给什么值出去，甚至这个 controller 存不存在都无所谓，而 toController 只需要遵循协议方法/重写父类方法去的到参数即可，然后里面就可以直接调这个参数，并且这一系列跳转规则和传参规则都通过 CTMediator 中介者去控制。</p>\n<h3 id=\"服务层（Service-Layer）-或者叫-业务层（Business-Layer）\"><a href=\"#服务层（Service-Layer）-或者叫-业务层（Business-Layer）\" class=\"headerlink\" title=\"服务层（Service Layer） 或者叫 业务层（Business Layer）\"></a>服务层（Service Layer） 或者叫 业务层（Business Layer）</h3><p>刚刚总结了一下CTMediator的组件间的逻辑,现在来总结一下业务层与 ViewController 层之间的设计.因为虽然是 MVC，那当然也得尽量避免 Mess View Controller ,Service 在这里可以理解为数据仓库+业务逻辑仓库，为的是令ViewController中避免出现像数据 A处理判断完才显示到控件上的情况，尽量能把最直接的数据给 ViewController 显示,利用像下图这种方式，业务层暴露出 Target 和 action供外界调用，调用方法后就进入了CTMediator 进行处理，接下来的事情就像我上面说的一样了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         --------------------------------</span><br><span class=\"line\">         |           Service  A         |</span><br><span class=\"line\">         ---  ----------  ----------  ---</span><br><span class=\"line\">           |  |        |  |        |  |</span><br><span class=\"line\">...........|  |........|  |........|  |...........</span><br><span class=\"line\">.          |  |        |  |        |  |          .</span><br><span class=\"line\">.        ---  ---    ---  ---    ---  ---        .</span><br><span class=\"line\">.        |action|    |action|    |action|        .</span><br><span class=\"line\">.        ---|----    -----|--    --|-----        .</span><br><span class=\"line\">.           |             |        |             .</span><br><span class=\"line\">.           |             |        |             .</span><br><span class=\"line\">.       ----|------     --|--------|--           .</span><br><span class=\"line\">.       |Target_A1|     |  Target_A2 |           .</span><br><span class=\"line\">.       -----------     --------------           .</span><br><span class=\"line\">..................................................</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CTNetworking-gt-DKNetworking-gt-DKHTTPTool\"><a href=\"#CTNetworking-gt-DKNetworking-gt-DKHTTPTool\" class=\"headerlink\" title=\"CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool\"></a>CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool</h3><ul>\n<li><p>CTNetworking 是一个基于AFNetworking的开源网络层组件，经过改装之后我组装出了 DKNetworking（虽然后面发现有 RAC神器之后就觉得这个东西不够轻便了）。</p>\n</li>\n<li><p>CTNetworking 解决了以下几个问题</p>\n<ul>\n<li>使用哪种交互模式来跟业务层做对接？</li>\n<li>是否有必要将API返回的数据封装成对象然后再交付给业务层？</li>\n<li>使用集约化调用方式还是离散型调用方式去调用API？</li>\n</ul>\n</li>\n<li><p>上面三个问题分别给出的答案是</p>\n<ul>\n<li>代理模式</li>\n<li>没必要</li>\n<li>离散型</li>\n</ul>\n</li>\n<li><p>CTNetworking考虑的东西相当地多，除了上面几个问题之外，还考虑到了网络层安全机制（数据传输，HTTPS）,链接环节的优化（链接传输量和链接复用）等，一开始看源码也是看的很懵逼</p>\n</li>\n<li><p>通过协议的方式进行组件内的方法封装</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>协议名</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CTAPIManagerApiCallBackDelegate</td>\n<td>回调协议</td>\n</tr>\n<tr>\n<td>CTAPIManagerCallbackDataReformer</td>\n<td>负责重新组装API数据的对象</td>\n</tr>\n<tr>\n<td>CTAPIManagerValidator</td>\n<td>验证器验证参数和返回</td>\n</tr>\n<tr>\n<td>CTAPIManagerParamSourceDelegate</td>\n<td>参数源</td>\n</tr>\n<tr>\n<td>CTAPIManager</td>\n<td>CTAPIBaseManager的派生类必须符合这个protocal</td>\n</tr>\n<tr>\n<td>CTAPIManagerInterceptor</td>\n<td>拦截器，拦截参数和回调</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>用协议的好处就是各取所需。当你想要统一管理所有回调的时候，那你这个类只要遵循<code>CTAPIManagerApiCallBackDelegate</code>代理和实现对应的方法，如果你这个类想要拦截参数，那么就遵循<code>CTAPIManagerInterceptor</code>协议并实现对应的方法，大抵就是这种思想，然后底层就会进行各种判断并拼接各个协议的方法的返回值，最后发出请求，得到回调然后处理值并返回出去。</p>\n</li>\n<li><p>CTNetworking 框架没有使用数据模型，原因就是认为模型嵌入模型的时候处理数据很麻烦，另外模型的复用性很差，容易出现类型爆炸，提高维护成本，还有就是不够NSDictionary、NSArray直观,最最重要的一点就是同一API的数据被不同View展示时，难以控制数据转化的代码，它们有可能会散落在任何需要的地方。所以框架使用了 Reformer 的方法去处理返回的数据（NSDictionary）转成 View 需要的数据（NSDictionary）。</p>\n</li>\n<li><p>DKNetworking 把 Refromer 部分的实现给改了，依赖了 MJExtension，去实现数据模型数组，因为总感觉NSDictionary很麻烦，难维护就难维护吧，反正项目也不大。</p>\n</li>\n<li><p>DKHTTPTool 是我在近期集成出来的框架，主要特性包括：</p>\n<ul>\n<li>支持缓存策略选择</li>\n<li>支持链式调用</li>\n<li>支持 RACSignal 返回</li>\n<li>支持拦截器、验证器</li>\n<li>支持直观的Logger输出</li>\n<li>支持全局请求头、请求参数</li>\n<li>服务器异常直接弹出异常数据而不是一坨 NSData</li>\n<li>支持错误码表，统一处理错误</li>\n</ul>\n</li>\n</ul>\n<p>还有其他的吗？忘记了<br>总的来说，这个还是挺管用的,毕竟能支持 RAC,符合我们现在的<br>MVVM+ReactiveCocoa的架构</p>\n<h3 id=\"MVVM-ReactiveCocoa\"><a href=\"#MVVM-ReactiveCocoa\" class=\"headerlink\" title=\"MVVM+ReactiveCocoa\"></a>MVVM+ReactiveCocoa</h3><ul>\n<li>ReactiveCocoa 博大精深，以致于现在都用不到它提供的功能的一半</li>\n<li>第二份优秀的源码（虽然跑不起来）<a href=\"https://github.com/leichunfeng/MVVMReactiveCocoa\">MVVMReactiveCocoa</a></li>\n<li>产出成品<a href=\"https://coding.net/u/Arclin/p/Poi/git\">Poi</a></li>\n</ul>\n<h3 id=\"Navigation-With-ViewModel\"><a href=\"#Navigation-With-ViewModel\" class=\"headerlink\" title=\"Navigation-With-ViewModel\"></a>Navigation-With-ViewModel</h3><p> 使用 MVVM 模式应该注意的问题</p>\n<ul>\n<li>以 ViewModel 为驱动引导着整个应用而不是 ViewController</li>\n<li>ViewModel 中不应该引入任何 UIKit 框架</li>\n<li>模块与模块间通过 服务总线 去沟通 , 减少模块之间的耦合</li>\n</ul>\n<p>先看看用 ViewModel 进行 push操作的流程</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|        ViewModel A           |   </span><br><span class=\"line\">---  ----------  ----------  ---   </span><br><span class=\"line\">\t|</span><br><span class=\"line\">\t| </span><br><span class=\"line\">[- initWithService:params:]</span><br><span class=\"line\">\t| ---------------</span><br><span class=\"line\">\t| | service bus | --- &gt; - pushViewModel: animated: </span><br><span class=\"line\">\t| ---------------                 |</span><br><span class=\"line\">\t|\t\t\t             （HOOK）[rac_responseToSelector:]</span><br><span class=\"line\">\t|\t\t\t                     |&#x2F;</span><br><span class=\"line\">\t|\t\t\t               &lt;DKNavigationProtocol&gt;-- @&#123; viewModel:viewController&#125;---&gt;navigationController [pushViewController:animated:]</span><br><span class=\"line\">\t|&#x2F;</span><br><span class=\"line\"> --------------------------------</span><br><span class=\"line\"> |        ViewModel B           |</span><br><span class=\"line\"> ---  ----------  ----------  ---</span><br></pre></td></tr></table></figure>\n\n<p>说明： ViewModelA 与 ViewControllerA ，ViewModelB 与 ViewControllerB 在 Router 里面通过字典的方式绑定在了一起，然后通过 RAC的方法监听pushViewModel: animated: 方法的执行，然后通过字典得到viewController从而进行真正的 push 操作，大概就是这样子</p>\n<h3 id=\"抽出父类和ReactiveCocoa\"><a href=\"#抽出父类和ReactiveCocoa\" class=\"headerlink\" title=\"抽出父类和ReactiveCocoa\"></a>抽出父类和ReactiveCocoa</h3><p>MVVMReactiveCocoa 通过封装父类的方式来实现这个架构，这些父类已经被我抽出来了，过几天会传上去，然后先写一些使用说明</p>\n<ol>\n<li>每个 Vc 对应一个 ViewModel</li>\n<li>TableViewController必须对应 ViewModel</li>\n<li>ViewModel 的初始化方法在 - initliazed 中</li>\n<li>初始化之前添加一些额外的方法，需要重写 - initWithServer:params:</li>\n<li>DKTableViewController是一个二维数组，里面封装的是 viewmodel</li>\n<li>cell 要遵循 DKReactiveView 协议</li>\n<li>绑定 cell与 viewModel 就在 ViewController里面重写 configureCell:withObject</li>\n<li>待补充</li>\n</ol>\n<p>ReativeCocoa 主要是用来实现 MVVM 的融合剂，当然也不一定要用 RAC去实现 MVVM,说实话 RAC 的学习成本还是相当高的，目前已经在尝试 DKRACHTTPTool,用纯 RAC 的方式去实现网络层和数据持久层的封装，另外还有些异常处理之类的,在这里面使用了filter: ignore: thottle: startWith: doNext: catch: try: doComplete: map: flattenMap: flatten: 等等的方法，非常好使，其他的可以看看我的几篇笔记”使用RAC-DKHTTPTool实践”、”RACCommand使用注意”</p>\n<p>最近的一个个人项目 Poi 就实践了这个架构。UI 结构如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   \t    --------------------------------</span><br><span class=\"line\">            |     NavigationConroller0     |</span><br><span class=\"line\">            ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t\t    |</span><br><span class=\"line\"> \t    --------------------------------</span><br><span class=\"line\">            |       TabBarController       |</span><br><span class=\"line\">            ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t|\t\t\t |</span><br><span class=\"line\">--------------------------------     --------------------------------   </span><br><span class=\"line\">|     NavigationConroller1     |     |     NavigationConroller2     |</span><br><span class=\"line\">---  ----------  ----------  ---     ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t|                   \t\t    |</span><br><span class=\"line\">--------------------------------     --------------------------------</span><br><span class=\"line\">|       ViewConroller1         |     |       ViewConroller2         |</span><br><span class=\"line\">---  ----------  ----------  --      --------------------------------</span><br></pre></td></tr></table></figure>\n\n<p>默认整个应用的跳转用的是NavigationConroller0，这样子做的原因是使用了一个第三方框架，为了可以在TabBarController中滑动切换。<br>当 pushViewModel 执行的时候，有一个 NavigationStack 会拿到最底部的 NavigationController 进行 push，如果 modal 出一个 navigationController,那么这个 navigationcontroller 将会压入NavigationStack ,然后这个 modal 出来的 viewController 后面的页面跳转就用这个 stack最上层的 NavigationController，dismiss 之后就会就会从栈中移除这个 NavigationController</p>\n<p>大概就是长这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------------------------------</span><br><span class=\"line\">|     NavigationConroller0     |  </span><br><span class=\"line\">---  ----------  ----------  ---    </span><br><span class=\"line\">\t\t |\tstack + 1\tpush</span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|       TabBarController       |    </span><br><span class=\"line\">---  ----------  ----------  ---  </span><br><span class=\"line\">\t\t |\t\t           </span><br><span class=\"line\">--------------------------------   </span><br><span class=\"line\">|     NavigationConroller1     |    </span><br><span class=\"line\">---  ----------  ----------  ---    </span><br><span class=\"line\">\t\t |      nv0 push     </span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|       ViewConroller1         |    </span><br><span class=\"line\">---  ----------  ----------  ---\t  </span><br><span class=\"line\">\t\t |   \tv1 modal</span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|      NavigationConroller2    |    </span><br><span class=\"line\">---  ----------  ----------  ---\t  </span><br><span class=\"line\">\t\t |     stack + 1  push   </span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|      ViewConroller2\t       |    </span><br><span class=\"line\">---  ----------  ----------  ---\t</span><br><span class=\"line\">\t\t| dismiss</span><br><span class=\"line\">\tstack - 1 pop</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MVVM-WithOut-ReacitveCocoa\"><a href=\"#MVVM-WithOut-ReacitveCocoa\" class=\"headerlink\" title=\"MVVM WithOut ReacitveCocoa\"></a>MVVM WithOut ReacitveCocoa</h3><p>用 Block 的方式代替 Reactive 的绑定功能。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>BugReporter For iOS<ul>\n<li>和思华一起开发的基于 iOS 的 bug自动反馈系统，一旦发生崩溃事故就会给开发者发送邮件</li>\n</ul>\n</li>\n<li>自动部署系统Jenkines</li>\n<li>JSPatch 热修复平台</li>\n<li>UMeng 用户数据统计</li>\n<li>等等</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>总结2016在 Dankal 工作过程中学习到的东西</p>","more":"<h3 id=\"Main-Argument-主要论点\"><a href=\"#Main-Argument-主要论点\" class=\"headerlink\" title=\"Main Argument 主要论点\"></a>Main Argument 主要论点</h3><p>中介者<br>组件化<br>封装<br>MVVM<br>ReactiveCocoa</p>\n<h3 id=\"基于MVC的组件化设计-CTMediator-（CTNetworking-gt-DKNetworking-gt-DKHTTPTool）\"><a href=\"#基于MVC的组件化设计-CTMediator-（CTNetworking-gt-DKNetworking-gt-DKHTTPTool）\" class=\"headerlink\" title=\"基于MVC的组件化设计 CTMediator + （CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool）\"></a>基于MVC的组件化设计 CTMediator + （CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool）</h3><p>CTMediator和CTNetworking 是我在5-6月份左右看的一套源码，出处是这里,然后去年年底作者又发布了<a href=\"http://casatwy.com/modulization_in_action.html\">基于 CTMediator工程实践</a>。总的设计思想如下：</p>\n<h3 id=\"组件逻辑\"><a href=\"#组件逻辑\" class=\"headerlink\" title=\"组件逻辑\"></a>组件逻辑</h3><ul>\n<li>CTMediator 是一种组件化方案，主要是针对大型项目多人开发情况下的一种方案。路由方式是 Targer-Action，通过这种方式进行模块之间的沟通，模块使用私有 pod 进行封装（这个是在第二篇的实践中提出来的），因为目前我们还没接触过这种大型的项目，所以一直停留在理论阶段（也就是虽然我看懂了源码的设计思想但是却没得地方实现），后来启动了觅书项目，打算尝试这种设计，结果发现过于大材小用了。模块的创建要先通过中介者进行注册，调用要通过中介者进行调用，总结一下大概就像这样子：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">             --------------------------------------</span><br><span class=\"line\">             | [CTMediator sharedInstance]        |</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                openUrl:       &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  (AppDelegate)  &lt;&lt;&lt;&lt;  Call From Other App With URL</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">             |                   |&#x2F;               |</span><br><span class=\"line\">             |                parseUrl            |</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">.................................|...............................</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">             |                   |&#x2F;               |</span><br><span class=\"line\">             |  performTarget:action:params: &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  Call From Native Module</span><br><span class=\"line\">             |                   |&#x2F;               |</span><br><span class=\"line\">             |             -------------          |</span><br><span class=\"line\">             |             |  runtime  |          |</span><br><span class=\"line\">             |             -------------          |</span><br><span class=\"line\">             ---------------.---------.------------</span><br><span class=\"line\">                           .           .</span><br><span class=\"line\">                          .             .</span><br><span class=\"line\">-------------------------------      --------------------------------</span><br><span class=\"line\">|                       ·     |      |    ·                         |</span><br><span class=\"line\">|                     ·       |      |     ·                        |</span><br><span class=\"line\">|           Target            |      |           Target             |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|         &#x2F;   |   \\           |      |         &#x2F;   |   \\            |</span><br><span class=\"line\">|        &#x2F;    |    \\          |      |        &#x2F;    |    \\           |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|   Action Action Action ...  |      |   Action Action Action ...   |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|Service  A                   |      | Service  B                   |</span><br><span class=\"line\">-------------------------------      --------------------------------</span><br></pre></td></tr></table></figure>\n\n<p>这里面包括了内部调用和远程应用调用，远程应用调用因为我们目前还用不着所以先不管，内部调用的流程为了方便理解我举个例子，fromController通过performTarget:action:params:方法传入toController类名和在toController要执行的方法和所需的参数，这样子组件之间就实现了解耦，fromController 只需要知道他想去的地方是 toController和要给什么值出去，甚至这个 controller 存不存在都无所谓，而 toController 只需要遵循协议方法/重写父类方法去的到参数即可，然后里面就可以直接调这个参数，并且这一系列跳转规则和传参规则都通过 CTMediator 中介者去控制。</p>\n<h3 id=\"服务层（Service-Layer）-或者叫-业务层（Business-Layer）\"><a href=\"#服务层（Service-Layer）-或者叫-业务层（Business-Layer）\" class=\"headerlink\" title=\"服务层（Service Layer） 或者叫 业务层（Business Layer）\"></a>服务层（Service Layer） 或者叫 业务层（Business Layer）</h3><p>刚刚总结了一下CTMediator的组件间的逻辑,现在来总结一下业务层与 ViewController 层之间的设计.因为虽然是 MVC，那当然也得尽量避免 Mess View Controller ,Service 在这里可以理解为数据仓库+业务逻辑仓库，为的是令ViewController中避免出现像数据 A处理判断完才显示到控件上的情况，尽量能把最直接的数据给 ViewController 显示,利用像下图这种方式，业务层暴露出 Target 和 action供外界调用，调用方法后就进入了CTMediator 进行处理，接下来的事情就像我上面说的一样了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         --------------------------------</span><br><span class=\"line\">         |           Service  A         |</span><br><span class=\"line\">         ---  ----------  ----------  ---</span><br><span class=\"line\">           |  |        |  |        |  |</span><br><span class=\"line\">...........|  |........|  |........|  |...........</span><br><span class=\"line\">.          |  |        |  |        |  |          .</span><br><span class=\"line\">.        ---  ---    ---  ---    ---  ---        .</span><br><span class=\"line\">.        |action|    |action|    |action|        .</span><br><span class=\"line\">.        ---|----    -----|--    --|-----        .</span><br><span class=\"line\">.           |             |        |             .</span><br><span class=\"line\">.           |             |        |             .</span><br><span class=\"line\">.       ----|------     --|--------|--           .</span><br><span class=\"line\">.       |Target_A1|     |  Target_A2 |           .</span><br><span class=\"line\">.       -----------     --------------           .</span><br><span class=\"line\">..................................................</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CTNetworking-gt-DKNetworking-gt-DKHTTPTool\"><a href=\"#CTNetworking-gt-DKNetworking-gt-DKHTTPTool\" class=\"headerlink\" title=\"CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool\"></a>CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool</h3><ul>\n<li><p>CTNetworking 是一个基于AFNetworking的开源网络层组件，经过改装之后我组装出了 DKNetworking（虽然后面发现有 RAC神器之后就觉得这个东西不够轻便了）。</p>\n</li>\n<li><p>CTNetworking 解决了以下几个问题</p>\n<ul>\n<li>使用哪种交互模式来跟业务层做对接？</li>\n<li>是否有必要将API返回的数据封装成对象然后再交付给业务层？</li>\n<li>使用集约化调用方式还是离散型调用方式去调用API？</li>\n</ul>\n</li>\n<li><p>上面三个问题分别给出的答案是</p>\n<ul>\n<li>代理模式</li>\n<li>没必要</li>\n<li>离散型</li>\n</ul>\n</li>\n<li><p>CTNetworking考虑的东西相当地多，除了上面几个问题之外，还考虑到了网络层安全机制（数据传输，HTTPS）,链接环节的优化（链接传输量和链接复用）等，一开始看源码也是看的很懵逼</p>\n</li>\n<li><p>通过协议的方式进行组件内的方法封装</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>协议名</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CTAPIManagerApiCallBackDelegate</td>\n<td>回调协议</td>\n</tr>\n<tr>\n<td>CTAPIManagerCallbackDataReformer</td>\n<td>负责重新组装API数据的对象</td>\n</tr>\n<tr>\n<td>CTAPIManagerValidator</td>\n<td>验证器验证参数和返回</td>\n</tr>\n<tr>\n<td>CTAPIManagerParamSourceDelegate</td>\n<td>参数源</td>\n</tr>\n<tr>\n<td>CTAPIManager</td>\n<td>CTAPIBaseManager的派生类必须符合这个protocal</td>\n</tr>\n<tr>\n<td>CTAPIManagerInterceptor</td>\n<td>拦截器，拦截参数和回调</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>用协议的好处就是各取所需。当你想要统一管理所有回调的时候，那你这个类只要遵循<code>CTAPIManagerApiCallBackDelegate</code>代理和实现对应的方法，如果你这个类想要拦截参数，那么就遵循<code>CTAPIManagerInterceptor</code>协议并实现对应的方法，大抵就是这种思想，然后底层就会进行各种判断并拼接各个协议的方法的返回值，最后发出请求，得到回调然后处理值并返回出去。</p>\n</li>\n<li><p>CTNetworking 框架没有使用数据模型，原因就是认为模型嵌入模型的时候处理数据很麻烦，另外模型的复用性很差，容易出现类型爆炸，提高维护成本，还有就是不够NSDictionary、NSArray直观,最最重要的一点就是同一API的数据被不同View展示时，难以控制数据转化的代码，它们有可能会散落在任何需要的地方。所以框架使用了 Reformer 的方法去处理返回的数据（NSDictionary）转成 View 需要的数据（NSDictionary）。</p>\n</li>\n<li><p>DKNetworking 把 Refromer 部分的实现给改了，依赖了 MJExtension，去实现数据模型数组，因为总感觉NSDictionary很麻烦，难维护就难维护吧，反正项目也不大。</p>\n</li>\n<li><p>DKHTTPTool 是我在近期集成出来的框架，主要特性包括：</p>\n<ul>\n<li>支持缓存策略选择</li>\n<li>支持链式调用</li>\n<li>支持 RACSignal 返回</li>\n<li>支持拦截器、验证器</li>\n<li>支持直观的Logger输出</li>\n<li>支持全局请求头、请求参数</li>\n<li>服务器异常直接弹出异常数据而不是一坨 NSData</li>\n<li>支持错误码表，统一处理错误</li>\n</ul>\n</li>\n</ul>\n<p>还有其他的吗？忘记了<br>总的来说，这个还是挺管用的,毕竟能支持 RAC,符合我们现在的<br>MVVM+ReactiveCocoa的架构</p>\n<h3 id=\"MVVM-ReactiveCocoa\"><a href=\"#MVVM-ReactiveCocoa\" class=\"headerlink\" title=\"MVVM+ReactiveCocoa\"></a>MVVM+ReactiveCocoa</h3><ul>\n<li>ReactiveCocoa 博大精深，以致于现在都用不到它提供的功能的一半</li>\n<li>第二份优秀的源码（虽然跑不起来）<a href=\"https://github.com/leichunfeng/MVVMReactiveCocoa\">MVVMReactiveCocoa</a></li>\n<li>产出成品<a href=\"https://coding.net/u/Arclin/p/Poi/git\">Poi</a></li>\n</ul>\n<h3 id=\"Navigation-With-ViewModel\"><a href=\"#Navigation-With-ViewModel\" class=\"headerlink\" title=\"Navigation-With-ViewModel\"></a>Navigation-With-ViewModel</h3><p> 使用 MVVM 模式应该注意的问题</p>\n<ul>\n<li>以 ViewModel 为驱动引导着整个应用而不是 ViewController</li>\n<li>ViewModel 中不应该引入任何 UIKit 框架</li>\n<li>模块与模块间通过 服务总线 去沟通 , 减少模块之间的耦合</li>\n</ul>\n<p>先看看用 ViewModel 进行 push操作的流程</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|        ViewModel A           |   </span><br><span class=\"line\">---  ----------  ----------  ---   </span><br><span class=\"line\">\t|</span><br><span class=\"line\">\t| </span><br><span class=\"line\">[- initWithService:params:]</span><br><span class=\"line\">\t| ---------------</span><br><span class=\"line\">\t| | service bus | --- &gt; - pushViewModel: animated: </span><br><span class=\"line\">\t| ---------------                 |</span><br><span class=\"line\">\t|\t\t\t             （HOOK）[rac_responseToSelector:]</span><br><span class=\"line\">\t|\t\t\t                     |&#x2F;</span><br><span class=\"line\">\t|\t\t\t               &lt;DKNavigationProtocol&gt;-- @&#123; viewModel:viewController&#125;---&gt;navigationController [pushViewController:animated:]</span><br><span class=\"line\">\t|&#x2F;</span><br><span class=\"line\"> --------------------------------</span><br><span class=\"line\"> |        ViewModel B           |</span><br><span class=\"line\"> ---  ----------  ----------  ---</span><br></pre></td></tr></table></figure>\n\n<p>说明： ViewModelA 与 ViewControllerA ，ViewModelB 与 ViewControllerB 在 Router 里面通过字典的方式绑定在了一起，然后通过 RAC的方法监听pushViewModel: animated: 方法的执行，然后通过字典得到viewController从而进行真正的 push 操作，大概就是这样子</p>\n<h3 id=\"抽出父类和ReactiveCocoa\"><a href=\"#抽出父类和ReactiveCocoa\" class=\"headerlink\" title=\"抽出父类和ReactiveCocoa\"></a>抽出父类和ReactiveCocoa</h3><p>MVVMReactiveCocoa 通过封装父类的方式来实现这个架构，这些父类已经被我抽出来了，过几天会传上去，然后先写一些使用说明</p>\n<ol>\n<li>每个 Vc 对应一个 ViewModel</li>\n<li>TableViewController必须对应 ViewModel</li>\n<li>ViewModel 的初始化方法在 - initliazed 中</li>\n<li>初始化之前添加一些额外的方法，需要重写 - initWithServer:params:</li>\n<li>DKTableViewController是一个二维数组，里面封装的是 viewmodel</li>\n<li>cell 要遵循 DKReactiveView 协议</li>\n<li>绑定 cell与 viewModel 就在 ViewController里面重写 configureCell:withObject</li>\n<li>待补充</li>\n</ol>\n<p>ReativeCocoa 主要是用来实现 MVVM 的融合剂，当然也不一定要用 RAC去实现 MVVM,说实话 RAC 的学习成本还是相当高的，目前已经在尝试 DKRACHTTPTool,用纯 RAC 的方式去实现网络层和数据持久层的封装，另外还有些异常处理之类的,在这里面使用了filter: ignore: thottle: startWith: doNext: catch: try: doComplete: map: flattenMap: flatten: 等等的方法，非常好使，其他的可以看看我的几篇笔记”使用RAC-DKHTTPTool实践”、”RACCommand使用注意”</p>\n<p>最近的一个个人项目 Poi 就实践了这个架构。UI 结构如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   \t    --------------------------------</span><br><span class=\"line\">            |     NavigationConroller0     |</span><br><span class=\"line\">            ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t\t    |</span><br><span class=\"line\"> \t    --------------------------------</span><br><span class=\"line\">            |       TabBarController       |</span><br><span class=\"line\">            ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t|\t\t\t |</span><br><span class=\"line\">--------------------------------     --------------------------------   </span><br><span class=\"line\">|     NavigationConroller1     |     |     NavigationConroller2     |</span><br><span class=\"line\">---  ----------  ----------  ---     ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t|                   \t\t    |</span><br><span class=\"line\">--------------------------------     --------------------------------</span><br><span class=\"line\">|       ViewConroller1         |     |       ViewConroller2         |</span><br><span class=\"line\">---  ----------  ----------  --      --------------------------------</span><br></pre></td></tr></table></figure>\n\n<p>默认整个应用的跳转用的是NavigationConroller0，这样子做的原因是使用了一个第三方框架，为了可以在TabBarController中滑动切换。<br>当 pushViewModel 执行的时候，有一个 NavigationStack 会拿到最底部的 NavigationController 进行 push，如果 modal 出一个 navigationController,那么这个 navigationcontroller 将会压入NavigationStack ,然后这个 modal 出来的 viewController 后面的页面跳转就用这个 stack最上层的 NavigationController，dismiss 之后就会就会从栈中移除这个 NavigationController</p>\n<p>大概就是长这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------------------------------</span><br><span class=\"line\">|     NavigationConroller0     |  </span><br><span class=\"line\">---  ----------  ----------  ---    </span><br><span class=\"line\">\t\t |\tstack + 1\tpush</span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|       TabBarController       |    </span><br><span class=\"line\">---  ----------  ----------  ---  </span><br><span class=\"line\">\t\t |\t\t           </span><br><span class=\"line\">--------------------------------   </span><br><span class=\"line\">|     NavigationConroller1     |    </span><br><span class=\"line\">---  ----------  ----------  ---    </span><br><span class=\"line\">\t\t |      nv0 push     </span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|       ViewConroller1         |    </span><br><span class=\"line\">---  ----------  ----------  ---\t  </span><br><span class=\"line\">\t\t |   \tv1 modal</span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|      NavigationConroller2    |    </span><br><span class=\"line\">---  ----------  ----------  ---\t  </span><br><span class=\"line\">\t\t |     stack + 1  push   </span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|      ViewConroller2\t       |    </span><br><span class=\"line\">---  ----------  ----------  ---\t</span><br><span class=\"line\">\t\t| dismiss</span><br><span class=\"line\">\tstack - 1 pop</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MVVM-WithOut-ReacitveCocoa\"><a href=\"#MVVM-WithOut-ReacitveCocoa\" class=\"headerlink\" title=\"MVVM WithOut ReacitveCocoa\"></a>MVVM WithOut ReacitveCocoa</h3><p>用 Block 的方式代替 Reactive 的绑定功能。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>BugReporter For iOS<ul>\n<li>和思华一起开发的基于 iOS 的 bug自动反馈系统，一旦发生崩溃事故就会给开发者发送邮件</li>\n</ul>\n</li>\n<li>自动部署系统Jenkines</li>\n<li>JSPatch 热修复平台</li>\n<li>UMeng 用户数据统计</li>\n<li>等等</li>\n</ul>"},{"title":"AVFoundation录制视频没声音?","author":"Arclin","abbrlink":"efd905d7","date":"2017-03-03T16:00:00.000Z","_content":"先说结论 , 加一行代码 \n\n```\n_captureMovieFileOutput.movieFragmentInterval = kCMTimeInvalid\n```\n\n<!-- more -->\n\n看看`movieFragmentInterval` 属性的说明\n\n```\n/*!\n @property movieFragmentInterval\n @abstract\n    Specifies the frequency with which movie fragments should be written.\n\n @discussion\n    When movie fragments are used, a partially written QuickTime movie file whose writing is unexpectedly interrupted can be successfully opened and played up to multiples of the specified time interval. A value of kCMTimeInvalid indicates that movie fragments should not be used, but that only a movie atom describing all of the media in the file should be written. The default value of this property is ten seconds.\n\n    Changing the value of this property will not affect the movie fragment interval of the file currently being written, if there is one.\n */\n@property(nonatomic) CMTime movieFragmentInterval;\n```\n\n用拙略的英语水平翻译一下就是,`movieFragmentInterval`这东西代表一个时间间隔,每隔x秒就会把视频片段写入内存,这是为了保证当意外中断视频文件写入的时候还可以有一个可以播放的视频片段,默认是十秒,如果你给他赋了这个值`kCMTimeInvalid`,就表示要一直写入直到调用某个方法结束视频录制,之后他就会给视频文件加上文件尾部,所以如果没有设置这个值的话,十秒到二十秒的视频中间就会出现没声音的状况.\n","source":"_posts/AVFoundation录制视频没声音.md","raw":"---\ntitle: AVFoundation录制视频没声音?\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: efd905d7\ndate: 2017-03-04 00:00:00\n---\n先说结论 , 加一行代码 \n\n```\n_captureMovieFileOutput.movieFragmentInterval = kCMTimeInvalid\n```\n\n<!-- more -->\n\n看看`movieFragmentInterval` 属性的说明\n\n```\n/*!\n @property movieFragmentInterval\n @abstract\n    Specifies the frequency with which movie fragments should be written.\n\n @discussion\n    When movie fragments are used, a partially written QuickTime movie file whose writing is unexpectedly interrupted can be successfully opened and played up to multiples of the specified time interval. A value of kCMTimeInvalid indicates that movie fragments should not be used, but that only a movie atom describing all of the media in the file should be written. The default value of this property is ten seconds.\n\n    Changing the value of this property will not affect the movie fragment interval of the file currently being written, if there is one.\n */\n@property(nonatomic) CMTime movieFragmentInterval;\n```\n\n用拙略的英语水平翻译一下就是,`movieFragmentInterval`这东西代表一个时间间隔,每隔x秒就会把视频片段写入内存,这是为了保证当意外中断视频文件写入的时候还可以有一个可以播放的视频片段,默认是十秒,如果你给他赋了这个值`kCMTimeInvalid`,就表示要一直写入直到调用某个方法结束视频录制,之后他就会给视频文件加上文件尾部,所以如果没有设置这个值的话,十秒到二十秒的视频中间就会出现没声音的状况.\n","slug":"AVFoundation录制视频没声音","published":1,"updated":"2021-06-06T18:52:24.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyogn0007tnn0acse7ubp","content":"<p>先说结论 , 加一行代码 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_captureMovieFileOutput.movieFragmentInterval &#x3D; kCMTimeInvalid</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<p>看看<code>movieFragmentInterval</code> 属性的说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*!</span><br><span class=\"line\"> @property movieFragmentInterval</span><br><span class=\"line\"> @abstract</span><br><span class=\"line\">    Specifies the frequency with which movie fragments should be written.</span><br><span class=\"line\"></span><br><span class=\"line\"> @discussion</span><br><span class=\"line\">    When movie fragments are used, a partially written QuickTime movie file whose writing is unexpectedly interrupted can be successfully opened and played up to multiples of the specified time interval. A value of kCMTimeInvalid indicates that movie fragments should not be used, but that only a movie atom describing all of the media in the file should be written. The default value of this property is ten seconds.</span><br><span class=\"line\"></span><br><span class=\"line\">    Changing the value of this property will not affect the movie fragment interval of the file currently being written, if there is one.</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">@property(nonatomic) CMTime movieFragmentInterval;</span><br></pre></td></tr></table></figure>\n\n<p>用拙略的英语水平翻译一下就是,<code>movieFragmentInterval</code>这东西代表一个时间间隔,每隔x秒就会把视频片段写入内存,这是为了保证当意外中断视频文件写入的时候还可以有一个可以播放的视频片段,默认是十秒,如果你给他赋了这个值<code>kCMTimeInvalid</code>,就表示要一直写入直到调用某个方法结束视频录制,之后他就会给视频文件加上文件尾部,所以如果没有设置这个值的话,十秒到二十秒的视频中间就会出现没声音的状况.</p>\n","site":{"data":{}},"excerpt":"<p>先说结论 , 加一行代码 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_captureMovieFileOutput.movieFragmentInterval &#x3D; kCMTimeInvalid</span><br></pre></td></tr></table></figure>","more":"<p>看看<code>movieFragmentInterval</code> 属性的说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*!</span><br><span class=\"line\"> @property movieFragmentInterval</span><br><span class=\"line\"> @abstract</span><br><span class=\"line\">    Specifies the frequency with which movie fragments should be written.</span><br><span class=\"line\"></span><br><span class=\"line\"> @discussion</span><br><span class=\"line\">    When movie fragments are used, a partially written QuickTime movie file whose writing is unexpectedly interrupted can be successfully opened and played up to multiples of the specified time interval. A value of kCMTimeInvalid indicates that movie fragments should not be used, but that only a movie atom describing all of the media in the file should be written. The default value of this property is ten seconds.</span><br><span class=\"line\"></span><br><span class=\"line\">    Changing the value of this property will not affect the movie fragment interval of the file currently being written, if there is one.</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">@property(nonatomic) CMTime movieFragmentInterval;</span><br></pre></td></tr></table></figure>\n\n<p>用拙略的英语水平翻译一下就是,<code>movieFragmentInterval</code>这东西代表一个时间间隔,每隔x秒就会把视频片段写入内存,这是为了保证当意外中断视频文件写入的时候还可以有一个可以播放的视频片段,默认是十秒,如果你给他赋了这个值<code>kCMTimeInvalid</code>,就表示要一直写入直到调用某个方法结束视频录制,之后他就会给视频文件加上文件尾部,所以如果没有设置这个值的话,十秒到二十秒的视频中间就会出现没声音的状况.</p>"},{"title":"ALAsset-Type:Unknown的问题","author":"Arclin","abbrlink":"a8ea2211","date":"2016-10-16T16:00:00.000Z","_content":"- 利用ALAssetsLibrary时候，将得到的`ALAsset`存到数组里，会出现`ALAsset - Type:Unknown, URLs:(null)`的问题\n\n解决方案：初始化ALAssetsLibrary的时候，不要用alloc-init，用一个单例，如下：\n\n```\n+ (ALAssetsLibrary *)defaultAssetsLibrary\n{\n    static dispatch_once_t pred = 0;\n    static ALAssetsLibrary *library = nil;\n    dispatch_once(&pred,\n                  ^{\n                      library = [[ALAssetsLibrary alloc] init];\n                  });\n    return library;\n}\n```","source":"_posts/ALAsset-Type-Unknown的问题.md","raw":"---\ntitle: 'ALAsset-Type:Unknown的问题'\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: a8ea2211\ndate: 2016-10-17 00:00:00\n---\n- 利用ALAssetsLibrary时候，将得到的`ALAsset`存到数组里，会出现`ALAsset - Type:Unknown, URLs:(null)`的问题\n\n解决方案：初始化ALAssetsLibrary的时候，不要用alloc-init，用一个单例，如下：\n\n```\n+ (ALAssetsLibrary *)defaultAssetsLibrary\n{\n    static dispatch_once_t pred = 0;\n    static ALAssetsLibrary *library = nil;\n    dispatch_once(&pred,\n                  ^{\n                      library = [[ALAssetsLibrary alloc] init];\n                  });\n    return library;\n}\n```","slug":"ALAsset-Type-Unknown的问题","published":1,"updated":"2021-06-06T18:52:24.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyogn0008tnn0c8w3flnp","content":"<ul>\n<li>利用ALAssetsLibrary时候，将得到的<code>ALAsset</code>存到数组里，会出现<code>ALAsset - Type:Unknown, URLs:(null)</code>的问题</li>\n</ul>\n<p>解决方案：初始化ALAssetsLibrary的时候，不要用alloc-init，用一个单例，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (ALAssetsLibrary *)defaultAssetsLibrary</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static dispatch_once_t pred &#x3D; 0;</span><br><span class=\"line\">    static ALAssetsLibrary *library &#x3D; nil;</span><br><span class=\"line\">    dispatch_once(&amp;pred,</span><br><span class=\"line\">                  ^&#123;</span><br><span class=\"line\">                      library &#x3D; [[ALAssetsLibrary alloc] init];</span><br><span class=\"line\">                  &#125;);</span><br><span class=\"line\">    return library;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>利用ALAssetsLibrary时候，将得到的<code>ALAsset</code>存到数组里，会出现<code>ALAsset - Type:Unknown, URLs:(null)</code>的问题</li>\n</ul>\n<p>解决方案：初始化ALAssetsLibrary的时候，不要用alloc-init，用一个单例，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (ALAssetsLibrary *)defaultAssetsLibrary</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static dispatch_once_t pred &#x3D; 0;</span><br><span class=\"line\">    static ALAssetsLibrary *library &#x3D; nil;</span><br><span class=\"line\">    dispatch_once(&amp;pred,</span><br><span class=\"line\">                  ^&#123;</span><br><span class=\"line\">                      library &#x3D; [[ALAssetsLibrary alloc] init];</span><br><span class=\"line\">                  &#125;);</span><br><span class=\"line\">    return library;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"C++基础","author":"Arclin","abbrlink":"f9a964a9","date":"2019-10-15T05:17:00.000Z","_content":"在iOS开发过程中，有时候会用到一些C++的库，为了避免大家用到这种库的时候一脸懵逼，这里总结一些基础知识，不写C++没关系，起码当库出了什么问题的时候至少能看懂逻辑（或许吧）。\n\n这里全部都是基础语法知识，没事的时候可以看看熟悉一下。\n\n<!-- more -->\n\n## 指针和引用\n\n略\n\n还是简单说一下：`.`是对象访问属性的操作符，`->`是指针访问指针属性的操作符，\n`(*a).b`=>`a->b`\n\n## 权限访问\n\npublic:   可以被任意实体访问\n\nprotected:只允许子类及本类的成员函数访问\n\nprivate:只允许本类的成员函数访问\n\n## 函数\n\n### 默认参数\n\n跟Swift差不多\n\n```\nint func (int a , int b = 10, int c = 10); // 声明中有默认参数，实现中不能有默认参数，比如下面这么写就会报错\n// 声明和实现只能其中一个有默认参数\nint func (int a , int b = 10, int c = 10) { // 形参默认值，当b有默认值的时候，后面的参数都需要有默认值，不能b有c没有，但是可以c有b没有\n\t return a + b + c;\n}\n```\n\n### 占位参数（没啥用）\n\n```\nvoid func(int a,int = 0) { // 占位参数可以有默认参数，也可以没有\n\tcout << a << endl;\n}\n\nfunc(1,2);\n```\n\n其实主要是用与兼容C语言的不规范写法，因为在C语言中，传参个数可以比函数声明的参数个数还多，比如`func(1,2,3,4,5)`,会警告但是不会报错，但是C++这么写就会报错，所以为了兼容C语言的调用方式，就用占位参数，占个位但是不用它，这样子就不会报错。\n\n### 函数重载\n\n同一个作用域，函数名相同，参数个数不同/类型不同/顺序不同\n\n**函数的返回值不可以作为函数重载的条件**\n\n#### 语法\n\n```\nvoid func() {}\nvoid func(int a) {}\nvoid func(double a) {}\nvoid func(int a, double b) {}\nvoid func(double a, int b) {}\nint func() {} // 这个会报错\n```\n\n#### 特殊情况\n\n```\n// 引用作为重载的条件\nvoid func(int &a) { // 方法1\n\tcout << \"func(int &a)\" << endl;\n}\nvoid func(cont int &a) {  // 方法2\n\tcout << \"func(cont int &a)\" << endl;\n}\n\nint a = 10;\nfunc(a); // 方法1\n\nfunc(10); // 方法2 因为 const int &a = 10; 合法，int &a = 10; 不合法\n\n// 函数重载碰到默认参数\nvoid func2(int a) {\n\tcout << \"func2(int a)\" << endl;\n}\n\nvoid func2(int a,int b = 10) {\n\tcout << \"func2(int a, int b)\" << endl;\n}\n\nfunc2(10); // 出现歧义（二义性），两个方法都能走，报错，所以建议函数重载的时候不要带默认参数\n```\n\n## struct 和 class 的区别\n\n`struct`默认权限为`public`\n`class`默认权限为`private`\n\n## 构造函数和析构函数\n\n```\n#include <iostream>\nclass Person\n{\npublic:\n\tPerson() {\n       cout << \"默认构造函数：系统会默认生成\" << endl;\n    }\n\t\n\tPerson(int age) {\n\t\tcout << \"带参数构造函数，写了这个系统就不生成无参构造函数\" << endl;\n\t\tthis->_age = age;\n\t}\n\t\n\tPerson(int age) : _height(15) {\n\t\tcout << \"初始化部分参数的构造函数\" << endl;\n\t\tthis->_age = age;\n\t}\n\t\n\tPerson(int age, int height) : _height(height) {\n\t\tcout << \"初始化部分参数的构造函数,并且顺便赋值了_height属性\" << endl;\n\t\tthis->_age = age;\n\t}\n\t\n\tPerson(const Person &person) {\n\t\tcout << \"浅拷贝函数：系统会默认生成\" << endl;\n\t\t// 如果要深拷贝的话自己手动生成、赋值对象属性。\n\t\t//如果自己写拷贝构造函数的话，系统不提供其他普通构造函数（有/无参）\n\t}\n\t\n\t~Person() {\n       cout<<\"析构函数：系统默认生成\"<<endl;\n    }\n\t\n\t//int age; // 不建议使用跟形参同名的成员变量\n\tint _age; // 带个下划线吧\n\tint _height;\n\tSomeClass property; // 别的类的属性：构造时会优先进入该类构造函数，析构时会优先进入Person的析构函数，再走这个类的析构函数\n};\n\n\nint main() {\n\tPerson p1; // 这样子就实例化了\n\tPerson p2(11); // age = 11\n\tPerson p3(11,160); // age = 11 height = 160\n\treturn 0;\n}\n```\n\n## 链式调用函数\n\n在上面的Person类内加多这么一个方法\n```\nPerson& addAge(Person &p) {\n\tthis->_age += p._Age;\n\treturn *this; // 返回当前对象指针！！！\n}\n\n\nPerson pp(20);\nPerson pp2(10);\npp.addAge(pp2).addAge(pp2).addAge(pp2); // 爽快地链式调用\n```\n\n## 静态方法\n\n```\nclass Person {\npublic:\n\tstatic void func() {\n\t\tcout << \"静态方法只能访问静态常量\" << test << endl;\n\t}\n\t\n\tstatic int test;\n};\n\nint main() {\n\tPerson p;\n\tp.func(); // 可以这么调\n\tPerson::func(); // 也可以通过类名直接调\n\treturn 0;\n}\n```\n\n## 常函数和常对象\n\n```\n#include <string>\nclass Person {\npublic:\n\tvoid funcA() const {\n//\t\tthis->_name = \"test\";  常函数不可以访问普通成员属性\n\t\tthis->_age = 1; //常函数可以访问被mutable修饰的成员属性\n\t}\n\tstring _name;\n\tmutable int _age;\n\t\n\tvoid funcB() {\n\t\t\n\t}\n}\n\nint main() {\n\tconst Person p;\n//\tp.funcB(); // 常对象不能访问普通函数\n\tp.funcA(); // 常对象只能访问常函数\n\treutrn 0;\n}\n```\n\n## 在类外部实现函数\n\n```\nclass Person {\npublic: // 需要是public函数才可以这么玩\n\tPerson(); // 要在外部实现的都得事先声明\n\tvoid test();\n};\n\nPerson::Person() {\n\n}\n\nvoid Person::test() {\n\n}\n```\n\n## 友元函数\n\n友元函数可以访问被`private`修饰的属性\n\n\n### 全局函数做友元\n```\n\nclass Building {\n    // 友元函数 可以访问私有属性\n    friend void visitor(Building &building);\npublic:\n    Building() {\n        m_SittingRoom = \"客厅\";\n        m_Bedroom = \"卧室\";\n    }\n    string m_SittingRoom;\nprivate:\n    string m_Bedroom;\n};\n\nvoid visitor(Building &building) {\n\tcout << \"全局函数\" << building.m_SittingRoom << endl;\n    cout << \"全局函数\" << building.m_Bedroom << endl;\n}\n```\n\n> 顺带一提：如果入参是引用的话（`&building`）,那么可以直接通过点语法访问成员属性，如果入参是指针的话（`*building`），那么就通过`->`访问，如（building->m_Bedroom）\n\n> 顺带再提，两种函数声明和调用方式的不同\n\n```\nvoid visitor(Building &building) {\n    cout << \"全局函数\" << building.m_SittingRoom << endl;\n}\n\nvoid visitor2(Building *building) {\n    cout << \"全局函数\" << building->m_SittingRoom << endl;\n}\n\nint main() {\n    \n    Building building;  // 生成对象\n    visitor(building);  // 直接传对象\n    visitor2(&building); // 传对象地址\n}\n\n```\n\n### 友元类\n\n```\nclass Building {\n    friend class Visitor; // 这个类下的所有函数都可以访问它的私有属性\npublic:\n    Building() {\n        m_Bedroom = \"卧室\";\n    }\nprivate:\n    string m_Bedroom;\n};\n\nclass Visitor\n{\npublic:\n\tVisitor() {\n\t\tbuilding = new Building;\n\t}\n\tvoid visit();\n\tBuilding *building;\n};\n\nvoid Visitor::visit() {\n\tcout << building->m_Bedroom << endl;\n}\n\nint main() {\n\tVisitor v;\n\tv.visit();\n\treturn 0;\n}\n\n```\n\n### 成员函数做友元函数\n\n```\nclass Building;\nclass Visitor\n{\npublic:\n    Visitor();\n    void visit();\n    Building *building;\n};\n\nclass Building {\n    friend void Visitor::visit(); // 指定Visitor的visit成员函数可以访问私有属性\npublic:\n    Building() {\n        m_Bedroom = \"卧室\";\n    }\nprivate:\n    string m_Bedroom;\n};\n\n// 为什么这个构造函数要写外面，不能写里面？\n// 因为Visitor需要在Building上面定义，不然不给定义Visitor上的友元函数，然后因为Visitor内有Building的属性，所以要声明一下class Building; 但是因为只是声明没有实现，所以就不能new Building;了，那就只能把这个通过类外实现的方式写在Building定义的下面。\nVisitor::Visitor() {  \n    building = new Building;\n}\n\nvoid Visitor::visit() {\n    cout << building->m_Bedroom << endl;\n}\n\nint main() {\n    Visitor v;\n    v.visit();\n    return 0;\n}\n\n```\n\n## 运算符重载\n\n跟Swift差不多\n\n### 成员函数的运算符重载\n\n```\nclass Animal {\npublic:\n    Animal operator + (Animal &a) {\n        Animal temp;\n        temp.m_A = this -> m_A + a.m_A;\n        return temp;\n    }\n    int m_A;\n};\n\nAnimal a;\na.m_A = 1;\nAnimal b;\nb.m_A = 2;\nAnimal c = a + b;\ncout << c.m_A << endl; // 输出 3\n```\n\n本质：`Animal c = a.operator+(b);`\n\n### 全局函数的运算符重载\n\n```\nAnimal operator - (Animal &a, Animal &b) {\n    Animal temp;\n    temp.m_A = a.m_A - b.m_A;\n    return temp;\n}\n\nAnimal a;\na.m_A = 1;\nAnimal b;\nb.m_A = 2;\nAnimal c = a - b;\ncout << c.m_A << endl; // 输出 -1\n```\n\n本质：`Animal c = operator-(a,b);`\n\n### 运算符重载也可以发生函数重载\n\n```\nAnimal operator + (int a, Animal &b) {\n    Animal temp;\n    temp.m_A = a + b.m_A;\n    return temp;\n}\nAnimal a;\na.m_A = 1;\nAnimal d = 10 + a;\ncout << d.m_A << endl; // 输出 11\n```\n\n本质：`Animal d = operator+(10,a);`\n\n\n### 左移运算符重载（比较常见输出对象细节）\n\n```\nclass MyInteger {\n    friend ostream& operator<<(ostream& cout,MyInteger myInt);\npublic:\n    MyInteger() {\n        this->my_int = 0;\n    }\nprivate:\n    int my_int;\n};\n\n// 必须是全局函数重载 ostream是cout的类型，为了能链式调用所以返回引用ostream&\nostream& operator<<(ostream& cout,MyInteger myInt) {\n    cout << myInt.my_int; // 返回对象细节\n    return cout;\n}\n\nint main() {\n    MyInteger myInt;\n    cout << myInt << endl; // 输出 my_int 的值 0\n\treturn 0;\n}\n```\n\n### 关系运算符重载\n\nSwift经常使用，参见`Equable`，`Comparable`协议\n\n```\nclass Person\n{\npublic:\n    bool operator==(Person &p) {\n        if (this->m_Name == p.m_Name) {\n            return true;\n        }\n        return false;\n    }\n    bool operator!=(Person &p) {\n        if (this->m_Name != p.m_Name) {\n            return true;\n        }\n        return false;\n    }\n\tstring m_Name;\n};\n\nint main() {\n\tPerson p1; p1.m_Name = \"A\";\n    Person p2; p2.m_Name = \"A\";\n    if (p1 == p2) {\n        cout << \"Equal\" << endl; // 输出\n    } else {\n        cout << \"Different\" << endl;\n    }\n\n    if (p1 != p2) {\n        cout << \"Different\" << endl;\n    } else {\n        cout << \"Equal\" << endl; // 输出\n    }\n\treturn 0;\n}\n```\n\n### 函数调用运算符的重载（骚操作）\n\n因为用起来很像函数，所以又叫做仿函数，STL里相当多这种骚操作\n\n```\nclass MyInteger {\n\tint operator()(int a,int b) {\n        return a + b;\n    }\n};\n\nint main() {\n    // MyInteger() ：匿名对象\n    int result = MyInteger()(1,2);\n\n    MyInteger i;\n    int result2 = i(5,2);\n\n    cout << result << endl;  // 5\n    cout << result2 << endl; // 7\n}\n\n```\n\n## 继承\n\nC++有多继承，灰常厉害\n\n### 继承方式\n\n三种继承方式`public`,`protected`,`private`，决定着继承下来的属性和方法以什么形式修饰，`class`默认`private`,`struct`默认`public`（没错，C++中结构体可以被继承）\n父类的所有非静态属性会被继承，包括`private`类型的，但是`private`类型的默认隐藏，子类无法访问。\n\n继承语法：\n\n```\nclass SubClass : public SuperClass {\n\n};\n```\n\n### 构造和析构\n\n父类先构造，子类先析构\n\n```\nsuperClass()\nsubClass()\n~subClass()\n~superClass()\n```\n\n### 同名属性/函数/静态属性/静态函数的访问\n\n假如子类和父类拥有相同的名字的属性/函数/静态属性/静态函数，则直接调用子类对象的话都是访问子类的，如果要访问父类的话要添加作用域。\n\n```\nclass Base {\npublic:\n    int _a = 1;\n    static int _b;\n    static void staticFunc() {\n        cout << \"Base staticFunc()\" << endl;\n    }\n    void Func() {\n        cout << \"Base Func()\" << endl;\n    }\n};\nint Base::_b = 10; // 静态成员变量要在外面赋值\n\nclass Sub1 : public Base {\npublic:\n    int _a = 2;\n    static int _b;\n    static void staticFunc() {\n        cout << \"SubClass staticFunc()\" << endl;\n    }\n    void Func() {\n        cout << \"SucClass Func()\" << endl;\n    }\n};\nint Sub1::_b = 20;\n\nint main() {\n\n    Sub1 s;\n    // 直接调用\n    cout << s._a << endl;\n    // 调用父类的\n    cout << s.Base::_a << endl;\n\n    // 静态直接调用\n    cout << s._b << endl;\n    // 静态调用父类的\n    cout << s.Base::_b << endl;\n\n    // 静态直接调用\n    cout << Sub1::_b << endl;\n    // 静态调用父类的\n    cout << Sub1::Base::_b << endl;\n\n    // 直接调用\n    s.Func();\n    // 调用父类的\n    s.Base::Func();\n\n    // 静态直接调用\n    s.staticFunc();\n    // 静态调用父类的\n    s.Base::staticFunc();\n\n    // 静态直接调用\n    Sub1::staticFunc();\n    // 静态调用父类的\n    Sub1::Base::staticFunc();\n\n    return 0;\n}\n```\n\n### 多继承\n\n不建议使用，因为麻烦事多\n\n语法：(参照上面的代码)\n```\nclass Other {\npublic:\n    void Func() {\n        cout << \"Ohter Func()\" << endl;\n    }\n};\n//...略\nclass Sub1 : public Base , public Other {\n//...略\n}\n```\n\n当多个父类中出现同名属性/方法时，需要加作用域指定父类`s.Base::Func(); / s.Other::Func();`\n\n### 菱形继承（钻石继承）\n\n两个子类继承同一个基类，\n又有某个类同时继承着两个子类\n\n举例\n```\nclass Base { int age };\n\nclass Sub1: public Base {};\nclass Sub2: public Base {};\n\nclass SubSub: public Sub1, public Sub2 {};\n```\n\n这时候SubSub会有两个父类，有两份 age 属性，造成资源浪费\n\n这时候用虚继承(`virtual`)解决问题\n\n```\nclass Base { public: int age }; // 这时候成为虚基类\n\nclass Sub1: virtual public Base {};\nclass Sub2: virtual public Base {};\n\nclass SubSub: public Sub1, public Sub2 {};\n```\n这时候age属性成为共享属性，最后谁改了就是谁的值\n\n```\nSubSub s;\ns.Sub1::age = 1;\ns.Sub2::age = 10;\ncout << s.Sub1::age << endl; // 10\ncout << s.Sub2::age << endl; // 10\ncout << s.age << endl; // 10\n```\n\n## 多态\n\nC++中，多态分两类\n\n静态多态：函数重载和运算符重载属于静态多态，复用函数名\n动态多态：子类和虚函数实现运行时多态\n\n区别：\n\n静态多态的函数地址早绑定，编译阶段确定函数地址\n动态多态的函数地址晚绑定，运行阶段确定函数地址\n\n动态多态满足条件：\n1. 有继承关系\n2. 子类重写父类虚函数\n\n动态多态使用\n父类的指针或者引用指向子类对象\n\n\n静态多态举例：\n```\nclass Animal {\npublic:\n    void speak() {\n        cout << \"Animal Speak\" << endl;\n    }\n};\nclass Cat: public Animal\n{\npublic:\n    void speak() {\n        cout << \"Cat Speak\" << endl;\n    }\n};\nvoid SomeoneSpeak(Animal &animal) {\n    animal.speak();\n}\n\nint main() {\n    Cat c;\n    SomeoneSpeak(c); // 由于SomeoneSpeak(Animal &animal)，编译期间已经确定入参类型，所以输出 Animal Speak\n```\n\n如果想输出`Cat Speak`，只需进行如下修改\n\n```\nclass Animal {\npublic:\n    virtual void speak() { // 虚函数，可以告知由于SomeoneSpeak(Animal &animal)运行时再确定入参类型\n        cout << \"Animal Speak\" << endl;\n    }\n};\n```\n\n经常地，这种情况下也是动态多态，最后会输出`Cat Speak`\n```\nAnimal *a = new Cat;\na->speak();\n```\n\n### 纯虚函数和抽象类\n\n父类的虚函数的实现没什么意义，所以上面的虚函数代码改写为`纯虚函数`\n\n```\nvirtual void speak() = 0;\n```\n\n当类中有了纯虚函数，则这个类称为`抽象类`\n\n抽象类**无法实例化对象**，并且**子类必须重写父类的纯虚函数**，否则也成为`抽象类`\n\n### 虚析构和纯虚析构\n\n当子类在堆区创建数据的时候，需要手动释放，父类需要添加虚析构或者纯虚析构函数，否则子类可能不走析构函数\n\n比如上面的`Animate`父类，我们补充一下\n\n```\nclass Animal {\npublic:\n    virtual ~Animal() = 0; // 纯虚析构\n};\n\nAnimal::~Animal() { // 析构实现\n    cout << \"Animal is Delete\" << endl;\n}\n```\n\n## 文件操作\n\n文件打开方式\n\n`ios::in`:读文件\n`ios::out`:写文件\n`ios::ate`:初始位置，文件尾\n`ios:app`:追加写文件\n`ios:trunc`:如果文件存在先删除，再创建\n`ios:binary`:二进制方式\n\n同时两种方式则使用`|`的方式，比如`ios::in|ios:binary`\n\n### 写文件\n\n```\nofstream stream;\n\nstream.open(\"Test.txt\",ios::out);\n\nstream << \"Line 1\" << endl;\nstream << \"Line 2\" << endl;\nstream << \"Line 3\" << endl;\n\nstream.close();\n\n```\n\n### 读文件\n\n```\nifstream ifs;\nifs.open(\"Test.txt\",ios::out);\n\nif(!ifs.is_open()) {\n\tcout << \"打开文件失败\" << endl;\n\treturn 0;\n}\n\nstring buf;\nwhile (getline(ifs, buf)) { // 一行行读取\n\tcout << buf << endl;\n}\n\nifs.close();\n```\n\n## 类模板\n\n### 构建类模板与类模板做参数\n\n```\ntemplate<class NameType,class AgeType>\n\nclass Person {\npublic:\n    Person(NameType name, AgeType age) {\n        this->_age = age;\n        this->_name = name;\n    }\n    AgeType _age;\n    NameType _name;\n};\n\nint main() {\n\n\t// 不会自动类型推导，需要自己显式声明类型\n    Person<string,int> p(\"Haha\",123);\n\n    cout << p._name << \" \" << p._age << endl;\n\n    return 0;\n}\n\n```\n\n可以给类模板添加默认类型\n\n`template<class NameType,class AgeType = int>`\n\n这样子调用的时候就可以不全声明类型了\n\n`Person<string> p(\"Haha\",123);`\n\n类模板做参数\n```\n// 指定类型的类模板做参数\nvoid print(Person<string,int> &p) {\n    p.showPerson();\n}\n\n// 模板化参数的类模板做参数\ntemplate<class T1,class T2>\nvoid print2(Person<T1, T2> &p) {\n    p.showPerson();\n}\n\n// 模板化类做参数\ntemplate<class T>\nvoid print3(T &p) {\n    p.showPerson();\n}\n\nint main() {\n    Person<string,int> p(\"Haha\",123);\n    print(p);\n    print2(p);\n    print3(p);\n    return 0;\n}\n```\n\n### 类模板与继承\n\n继承时需要指定类型\n\n```\ntemplate<class T>\nclass Base\n{\npublic:\n    T m;\n};\n\nclass SubClass: public Base<int> { // 指定T的类型\npublic:\n    void print() {\n        cout << m << endl;\n    }\n};\n```\n\n如果不想指定类型，那么可以模板化子类\n\n```\n\ntemplate<class T>\nclass Base\n{\npublic:\n    T m;\n};\n\ntemplate<class T1,class T2>\nclass SubClass: public Base<T1> {\npublic:\n    SubClass(T1 a, T2 b) {\n\n    }\n    T2 k;\n};\n\nint main() {\n\tSubClass<string, int> c(\"String\",1);\n\treturn 0;\n}\n```\n\n\n## STL 之 Vector容器\n\n```\nvector<int> v1; // 初始化指定容器内元素类型\nv1.assign(10, 1); // 插入10个1，也可以传入其他vector,比如v1.assign(v0.begin,v0.end); 或者直接 v1 = v0; 只要保证是同种类型就好\nfor (vector<int>::iterator i = v1.begin(); i != v1.end() ; i++) {\n\tcout << *i << endl;\n} // 打印10个1\ncout << \"Size = \" << v1.size() << endl; // 长度 10\ncout << \"isEmpty = \" << v1.empty() << endl; // 判空 0\ncout << \"capacity = \" << v1.capacity() << endl; // 容量 10\nv1.resize(20,20); // 调整容量为20，多出来的位置用20填充，这里的20可以不传，默认0\ncout << \"capacity = \" << v1.capacity() << endl; // 现在容量变成20\n\nv1.pop_back(); // 删除最后一个元素\n\ncout << \"Size = \" << v1.size() << endl; // 长度 19\ncout << \"capacity = \" << v1.capacity() << endl; // 容量不变 20\n\nv1.insert(v1.begin() + 1, 199); // 下标为1的位置插入元素199\nv1.insert(v1.begin() + 1, 2, 199); // 下标为1的位置插入两个元素199\nv1.erase(v1.begin() + 2); // 删除第二个元素\nv1.erase(v1.begin() + 2 , v1.begin() + 3); // 删除第二个到第三个元素\nv1.clear(); // 清空容器\n\ncout << \"第二个元素是\" << v1.at(1) << endl;\ncout << \"第三个元素是\" << v1[2] << endl;\ncout << \"第一个元素\" << v1.front() << endl;\ncout << \"最后一个元素\" << v1.back() << endl;\n\nv1.reverse(100000); // 预留空间，减少以后动态拓展的次数\n\nv1.swap(v0); // 交换元素，假如v1的预留空间很大，可以通过交换一个小预留空间的容器达到压缩内存的效果\n\n```","source":"_posts/C-基础.md","raw":"title: C++基础\nauthor: Arclin\nabbrlink: f9a964a9\ntags:\n  - C++\ncategories:\n  - C++\ndate: 2019-10-15 13:17:00\n---\n在iOS开发过程中，有时候会用到一些C++的库，为了避免大家用到这种库的时候一脸懵逼，这里总结一些基础知识，不写C++没关系，起码当库出了什么问题的时候至少能看懂逻辑（或许吧）。\n\n这里全部都是基础语法知识，没事的时候可以看看熟悉一下。\n\n<!-- more -->\n\n## 指针和引用\n\n略\n\n还是简单说一下：`.`是对象访问属性的操作符，`->`是指针访问指针属性的操作符，\n`(*a).b`=>`a->b`\n\n## 权限访问\n\npublic:   可以被任意实体访问\n\nprotected:只允许子类及本类的成员函数访问\n\nprivate:只允许本类的成员函数访问\n\n## 函数\n\n### 默认参数\n\n跟Swift差不多\n\n```\nint func (int a , int b = 10, int c = 10); // 声明中有默认参数，实现中不能有默认参数，比如下面这么写就会报错\n// 声明和实现只能其中一个有默认参数\nint func (int a , int b = 10, int c = 10) { // 形参默认值，当b有默认值的时候，后面的参数都需要有默认值，不能b有c没有，但是可以c有b没有\n\t return a + b + c;\n}\n```\n\n### 占位参数（没啥用）\n\n```\nvoid func(int a,int = 0) { // 占位参数可以有默认参数，也可以没有\n\tcout << a << endl;\n}\n\nfunc(1,2);\n```\n\n其实主要是用与兼容C语言的不规范写法，因为在C语言中，传参个数可以比函数声明的参数个数还多，比如`func(1,2,3,4,5)`,会警告但是不会报错，但是C++这么写就会报错，所以为了兼容C语言的调用方式，就用占位参数，占个位但是不用它，这样子就不会报错。\n\n### 函数重载\n\n同一个作用域，函数名相同，参数个数不同/类型不同/顺序不同\n\n**函数的返回值不可以作为函数重载的条件**\n\n#### 语法\n\n```\nvoid func() {}\nvoid func(int a) {}\nvoid func(double a) {}\nvoid func(int a, double b) {}\nvoid func(double a, int b) {}\nint func() {} // 这个会报错\n```\n\n#### 特殊情况\n\n```\n// 引用作为重载的条件\nvoid func(int &a) { // 方法1\n\tcout << \"func(int &a)\" << endl;\n}\nvoid func(cont int &a) {  // 方法2\n\tcout << \"func(cont int &a)\" << endl;\n}\n\nint a = 10;\nfunc(a); // 方法1\n\nfunc(10); // 方法2 因为 const int &a = 10; 合法，int &a = 10; 不合法\n\n// 函数重载碰到默认参数\nvoid func2(int a) {\n\tcout << \"func2(int a)\" << endl;\n}\n\nvoid func2(int a,int b = 10) {\n\tcout << \"func2(int a, int b)\" << endl;\n}\n\nfunc2(10); // 出现歧义（二义性），两个方法都能走，报错，所以建议函数重载的时候不要带默认参数\n```\n\n## struct 和 class 的区别\n\n`struct`默认权限为`public`\n`class`默认权限为`private`\n\n## 构造函数和析构函数\n\n```\n#include <iostream>\nclass Person\n{\npublic:\n\tPerson() {\n       cout << \"默认构造函数：系统会默认生成\" << endl;\n    }\n\t\n\tPerson(int age) {\n\t\tcout << \"带参数构造函数，写了这个系统就不生成无参构造函数\" << endl;\n\t\tthis->_age = age;\n\t}\n\t\n\tPerson(int age) : _height(15) {\n\t\tcout << \"初始化部分参数的构造函数\" << endl;\n\t\tthis->_age = age;\n\t}\n\t\n\tPerson(int age, int height) : _height(height) {\n\t\tcout << \"初始化部分参数的构造函数,并且顺便赋值了_height属性\" << endl;\n\t\tthis->_age = age;\n\t}\n\t\n\tPerson(const Person &person) {\n\t\tcout << \"浅拷贝函数：系统会默认生成\" << endl;\n\t\t// 如果要深拷贝的话自己手动生成、赋值对象属性。\n\t\t//如果自己写拷贝构造函数的话，系统不提供其他普通构造函数（有/无参）\n\t}\n\t\n\t~Person() {\n       cout<<\"析构函数：系统默认生成\"<<endl;\n    }\n\t\n\t//int age; // 不建议使用跟形参同名的成员变量\n\tint _age; // 带个下划线吧\n\tint _height;\n\tSomeClass property; // 别的类的属性：构造时会优先进入该类构造函数，析构时会优先进入Person的析构函数，再走这个类的析构函数\n};\n\n\nint main() {\n\tPerson p1; // 这样子就实例化了\n\tPerson p2(11); // age = 11\n\tPerson p3(11,160); // age = 11 height = 160\n\treturn 0;\n}\n```\n\n## 链式调用函数\n\n在上面的Person类内加多这么一个方法\n```\nPerson& addAge(Person &p) {\n\tthis->_age += p._Age;\n\treturn *this; // 返回当前对象指针！！！\n}\n\n\nPerson pp(20);\nPerson pp2(10);\npp.addAge(pp2).addAge(pp2).addAge(pp2); // 爽快地链式调用\n```\n\n## 静态方法\n\n```\nclass Person {\npublic:\n\tstatic void func() {\n\t\tcout << \"静态方法只能访问静态常量\" << test << endl;\n\t}\n\t\n\tstatic int test;\n};\n\nint main() {\n\tPerson p;\n\tp.func(); // 可以这么调\n\tPerson::func(); // 也可以通过类名直接调\n\treturn 0;\n}\n```\n\n## 常函数和常对象\n\n```\n#include <string>\nclass Person {\npublic:\n\tvoid funcA() const {\n//\t\tthis->_name = \"test\";  常函数不可以访问普通成员属性\n\t\tthis->_age = 1; //常函数可以访问被mutable修饰的成员属性\n\t}\n\tstring _name;\n\tmutable int _age;\n\t\n\tvoid funcB() {\n\t\t\n\t}\n}\n\nint main() {\n\tconst Person p;\n//\tp.funcB(); // 常对象不能访问普通函数\n\tp.funcA(); // 常对象只能访问常函数\n\treutrn 0;\n}\n```\n\n## 在类外部实现函数\n\n```\nclass Person {\npublic: // 需要是public函数才可以这么玩\n\tPerson(); // 要在外部实现的都得事先声明\n\tvoid test();\n};\n\nPerson::Person() {\n\n}\n\nvoid Person::test() {\n\n}\n```\n\n## 友元函数\n\n友元函数可以访问被`private`修饰的属性\n\n\n### 全局函数做友元\n```\n\nclass Building {\n    // 友元函数 可以访问私有属性\n    friend void visitor(Building &building);\npublic:\n    Building() {\n        m_SittingRoom = \"客厅\";\n        m_Bedroom = \"卧室\";\n    }\n    string m_SittingRoom;\nprivate:\n    string m_Bedroom;\n};\n\nvoid visitor(Building &building) {\n\tcout << \"全局函数\" << building.m_SittingRoom << endl;\n    cout << \"全局函数\" << building.m_Bedroom << endl;\n}\n```\n\n> 顺带一提：如果入参是引用的话（`&building`）,那么可以直接通过点语法访问成员属性，如果入参是指针的话（`*building`），那么就通过`->`访问，如（building->m_Bedroom）\n\n> 顺带再提，两种函数声明和调用方式的不同\n\n```\nvoid visitor(Building &building) {\n    cout << \"全局函数\" << building.m_SittingRoom << endl;\n}\n\nvoid visitor2(Building *building) {\n    cout << \"全局函数\" << building->m_SittingRoom << endl;\n}\n\nint main() {\n    \n    Building building;  // 生成对象\n    visitor(building);  // 直接传对象\n    visitor2(&building); // 传对象地址\n}\n\n```\n\n### 友元类\n\n```\nclass Building {\n    friend class Visitor; // 这个类下的所有函数都可以访问它的私有属性\npublic:\n    Building() {\n        m_Bedroom = \"卧室\";\n    }\nprivate:\n    string m_Bedroom;\n};\n\nclass Visitor\n{\npublic:\n\tVisitor() {\n\t\tbuilding = new Building;\n\t}\n\tvoid visit();\n\tBuilding *building;\n};\n\nvoid Visitor::visit() {\n\tcout << building->m_Bedroom << endl;\n}\n\nint main() {\n\tVisitor v;\n\tv.visit();\n\treturn 0;\n}\n\n```\n\n### 成员函数做友元函数\n\n```\nclass Building;\nclass Visitor\n{\npublic:\n    Visitor();\n    void visit();\n    Building *building;\n};\n\nclass Building {\n    friend void Visitor::visit(); // 指定Visitor的visit成员函数可以访问私有属性\npublic:\n    Building() {\n        m_Bedroom = \"卧室\";\n    }\nprivate:\n    string m_Bedroom;\n};\n\n// 为什么这个构造函数要写外面，不能写里面？\n// 因为Visitor需要在Building上面定义，不然不给定义Visitor上的友元函数，然后因为Visitor内有Building的属性，所以要声明一下class Building; 但是因为只是声明没有实现，所以就不能new Building;了，那就只能把这个通过类外实现的方式写在Building定义的下面。\nVisitor::Visitor() {  \n    building = new Building;\n}\n\nvoid Visitor::visit() {\n    cout << building->m_Bedroom << endl;\n}\n\nint main() {\n    Visitor v;\n    v.visit();\n    return 0;\n}\n\n```\n\n## 运算符重载\n\n跟Swift差不多\n\n### 成员函数的运算符重载\n\n```\nclass Animal {\npublic:\n    Animal operator + (Animal &a) {\n        Animal temp;\n        temp.m_A = this -> m_A + a.m_A;\n        return temp;\n    }\n    int m_A;\n};\n\nAnimal a;\na.m_A = 1;\nAnimal b;\nb.m_A = 2;\nAnimal c = a + b;\ncout << c.m_A << endl; // 输出 3\n```\n\n本质：`Animal c = a.operator+(b);`\n\n### 全局函数的运算符重载\n\n```\nAnimal operator - (Animal &a, Animal &b) {\n    Animal temp;\n    temp.m_A = a.m_A - b.m_A;\n    return temp;\n}\n\nAnimal a;\na.m_A = 1;\nAnimal b;\nb.m_A = 2;\nAnimal c = a - b;\ncout << c.m_A << endl; // 输出 -1\n```\n\n本质：`Animal c = operator-(a,b);`\n\n### 运算符重载也可以发生函数重载\n\n```\nAnimal operator + (int a, Animal &b) {\n    Animal temp;\n    temp.m_A = a + b.m_A;\n    return temp;\n}\nAnimal a;\na.m_A = 1;\nAnimal d = 10 + a;\ncout << d.m_A << endl; // 输出 11\n```\n\n本质：`Animal d = operator+(10,a);`\n\n\n### 左移运算符重载（比较常见输出对象细节）\n\n```\nclass MyInteger {\n    friend ostream& operator<<(ostream& cout,MyInteger myInt);\npublic:\n    MyInteger() {\n        this->my_int = 0;\n    }\nprivate:\n    int my_int;\n};\n\n// 必须是全局函数重载 ostream是cout的类型，为了能链式调用所以返回引用ostream&\nostream& operator<<(ostream& cout,MyInteger myInt) {\n    cout << myInt.my_int; // 返回对象细节\n    return cout;\n}\n\nint main() {\n    MyInteger myInt;\n    cout << myInt << endl; // 输出 my_int 的值 0\n\treturn 0;\n}\n```\n\n### 关系运算符重载\n\nSwift经常使用，参见`Equable`，`Comparable`协议\n\n```\nclass Person\n{\npublic:\n    bool operator==(Person &p) {\n        if (this->m_Name == p.m_Name) {\n            return true;\n        }\n        return false;\n    }\n    bool operator!=(Person &p) {\n        if (this->m_Name != p.m_Name) {\n            return true;\n        }\n        return false;\n    }\n\tstring m_Name;\n};\n\nint main() {\n\tPerson p1; p1.m_Name = \"A\";\n    Person p2; p2.m_Name = \"A\";\n    if (p1 == p2) {\n        cout << \"Equal\" << endl; // 输出\n    } else {\n        cout << \"Different\" << endl;\n    }\n\n    if (p1 != p2) {\n        cout << \"Different\" << endl;\n    } else {\n        cout << \"Equal\" << endl; // 输出\n    }\n\treturn 0;\n}\n```\n\n### 函数调用运算符的重载（骚操作）\n\n因为用起来很像函数，所以又叫做仿函数，STL里相当多这种骚操作\n\n```\nclass MyInteger {\n\tint operator()(int a,int b) {\n        return a + b;\n    }\n};\n\nint main() {\n    // MyInteger() ：匿名对象\n    int result = MyInteger()(1,2);\n\n    MyInteger i;\n    int result2 = i(5,2);\n\n    cout << result << endl;  // 5\n    cout << result2 << endl; // 7\n}\n\n```\n\n## 继承\n\nC++有多继承，灰常厉害\n\n### 继承方式\n\n三种继承方式`public`,`protected`,`private`，决定着继承下来的属性和方法以什么形式修饰，`class`默认`private`,`struct`默认`public`（没错，C++中结构体可以被继承）\n父类的所有非静态属性会被继承，包括`private`类型的，但是`private`类型的默认隐藏，子类无法访问。\n\n继承语法：\n\n```\nclass SubClass : public SuperClass {\n\n};\n```\n\n### 构造和析构\n\n父类先构造，子类先析构\n\n```\nsuperClass()\nsubClass()\n~subClass()\n~superClass()\n```\n\n### 同名属性/函数/静态属性/静态函数的访问\n\n假如子类和父类拥有相同的名字的属性/函数/静态属性/静态函数，则直接调用子类对象的话都是访问子类的，如果要访问父类的话要添加作用域。\n\n```\nclass Base {\npublic:\n    int _a = 1;\n    static int _b;\n    static void staticFunc() {\n        cout << \"Base staticFunc()\" << endl;\n    }\n    void Func() {\n        cout << \"Base Func()\" << endl;\n    }\n};\nint Base::_b = 10; // 静态成员变量要在外面赋值\n\nclass Sub1 : public Base {\npublic:\n    int _a = 2;\n    static int _b;\n    static void staticFunc() {\n        cout << \"SubClass staticFunc()\" << endl;\n    }\n    void Func() {\n        cout << \"SucClass Func()\" << endl;\n    }\n};\nint Sub1::_b = 20;\n\nint main() {\n\n    Sub1 s;\n    // 直接调用\n    cout << s._a << endl;\n    // 调用父类的\n    cout << s.Base::_a << endl;\n\n    // 静态直接调用\n    cout << s._b << endl;\n    // 静态调用父类的\n    cout << s.Base::_b << endl;\n\n    // 静态直接调用\n    cout << Sub1::_b << endl;\n    // 静态调用父类的\n    cout << Sub1::Base::_b << endl;\n\n    // 直接调用\n    s.Func();\n    // 调用父类的\n    s.Base::Func();\n\n    // 静态直接调用\n    s.staticFunc();\n    // 静态调用父类的\n    s.Base::staticFunc();\n\n    // 静态直接调用\n    Sub1::staticFunc();\n    // 静态调用父类的\n    Sub1::Base::staticFunc();\n\n    return 0;\n}\n```\n\n### 多继承\n\n不建议使用，因为麻烦事多\n\n语法：(参照上面的代码)\n```\nclass Other {\npublic:\n    void Func() {\n        cout << \"Ohter Func()\" << endl;\n    }\n};\n//...略\nclass Sub1 : public Base , public Other {\n//...略\n}\n```\n\n当多个父类中出现同名属性/方法时，需要加作用域指定父类`s.Base::Func(); / s.Other::Func();`\n\n### 菱形继承（钻石继承）\n\n两个子类继承同一个基类，\n又有某个类同时继承着两个子类\n\n举例\n```\nclass Base { int age };\n\nclass Sub1: public Base {};\nclass Sub2: public Base {};\n\nclass SubSub: public Sub1, public Sub2 {};\n```\n\n这时候SubSub会有两个父类，有两份 age 属性，造成资源浪费\n\n这时候用虚继承(`virtual`)解决问题\n\n```\nclass Base { public: int age }; // 这时候成为虚基类\n\nclass Sub1: virtual public Base {};\nclass Sub2: virtual public Base {};\n\nclass SubSub: public Sub1, public Sub2 {};\n```\n这时候age属性成为共享属性，最后谁改了就是谁的值\n\n```\nSubSub s;\ns.Sub1::age = 1;\ns.Sub2::age = 10;\ncout << s.Sub1::age << endl; // 10\ncout << s.Sub2::age << endl; // 10\ncout << s.age << endl; // 10\n```\n\n## 多态\n\nC++中，多态分两类\n\n静态多态：函数重载和运算符重载属于静态多态，复用函数名\n动态多态：子类和虚函数实现运行时多态\n\n区别：\n\n静态多态的函数地址早绑定，编译阶段确定函数地址\n动态多态的函数地址晚绑定，运行阶段确定函数地址\n\n动态多态满足条件：\n1. 有继承关系\n2. 子类重写父类虚函数\n\n动态多态使用\n父类的指针或者引用指向子类对象\n\n\n静态多态举例：\n```\nclass Animal {\npublic:\n    void speak() {\n        cout << \"Animal Speak\" << endl;\n    }\n};\nclass Cat: public Animal\n{\npublic:\n    void speak() {\n        cout << \"Cat Speak\" << endl;\n    }\n};\nvoid SomeoneSpeak(Animal &animal) {\n    animal.speak();\n}\n\nint main() {\n    Cat c;\n    SomeoneSpeak(c); // 由于SomeoneSpeak(Animal &animal)，编译期间已经确定入参类型，所以输出 Animal Speak\n```\n\n如果想输出`Cat Speak`，只需进行如下修改\n\n```\nclass Animal {\npublic:\n    virtual void speak() { // 虚函数，可以告知由于SomeoneSpeak(Animal &animal)运行时再确定入参类型\n        cout << \"Animal Speak\" << endl;\n    }\n};\n```\n\n经常地，这种情况下也是动态多态，最后会输出`Cat Speak`\n```\nAnimal *a = new Cat;\na->speak();\n```\n\n### 纯虚函数和抽象类\n\n父类的虚函数的实现没什么意义，所以上面的虚函数代码改写为`纯虚函数`\n\n```\nvirtual void speak() = 0;\n```\n\n当类中有了纯虚函数，则这个类称为`抽象类`\n\n抽象类**无法实例化对象**，并且**子类必须重写父类的纯虚函数**，否则也成为`抽象类`\n\n### 虚析构和纯虚析构\n\n当子类在堆区创建数据的时候，需要手动释放，父类需要添加虚析构或者纯虚析构函数，否则子类可能不走析构函数\n\n比如上面的`Animate`父类，我们补充一下\n\n```\nclass Animal {\npublic:\n    virtual ~Animal() = 0; // 纯虚析构\n};\n\nAnimal::~Animal() { // 析构实现\n    cout << \"Animal is Delete\" << endl;\n}\n```\n\n## 文件操作\n\n文件打开方式\n\n`ios::in`:读文件\n`ios::out`:写文件\n`ios::ate`:初始位置，文件尾\n`ios:app`:追加写文件\n`ios:trunc`:如果文件存在先删除，再创建\n`ios:binary`:二进制方式\n\n同时两种方式则使用`|`的方式，比如`ios::in|ios:binary`\n\n### 写文件\n\n```\nofstream stream;\n\nstream.open(\"Test.txt\",ios::out);\n\nstream << \"Line 1\" << endl;\nstream << \"Line 2\" << endl;\nstream << \"Line 3\" << endl;\n\nstream.close();\n\n```\n\n### 读文件\n\n```\nifstream ifs;\nifs.open(\"Test.txt\",ios::out);\n\nif(!ifs.is_open()) {\n\tcout << \"打开文件失败\" << endl;\n\treturn 0;\n}\n\nstring buf;\nwhile (getline(ifs, buf)) { // 一行行读取\n\tcout << buf << endl;\n}\n\nifs.close();\n```\n\n## 类模板\n\n### 构建类模板与类模板做参数\n\n```\ntemplate<class NameType,class AgeType>\n\nclass Person {\npublic:\n    Person(NameType name, AgeType age) {\n        this->_age = age;\n        this->_name = name;\n    }\n    AgeType _age;\n    NameType _name;\n};\n\nint main() {\n\n\t// 不会自动类型推导，需要自己显式声明类型\n    Person<string,int> p(\"Haha\",123);\n\n    cout << p._name << \" \" << p._age << endl;\n\n    return 0;\n}\n\n```\n\n可以给类模板添加默认类型\n\n`template<class NameType,class AgeType = int>`\n\n这样子调用的时候就可以不全声明类型了\n\n`Person<string> p(\"Haha\",123);`\n\n类模板做参数\n```\n// 指定类型的类模板做参数\nvoid print(Person<string,int> &p) {\n    p.showPerson();\n}\n\n// 模板化参数的类模板做参数\ntemplate<class T1,class T2>\nvoid print2(Person<T1, T2> &p) {\n    p.showPerson();\n}\n\n// 模板化类做参数\ntemplate<class T>\nvoid print3(T &p) {\n    p.showPerson();\n}\n\nint main() {\n    Person<string,int> p(\"Haha\",123);\n    print(p);\n    print2(p);\n    print3(p);\n    return 0;\n}\n```\n\n### 类模板与继承\n\n继承时需要指定类型\n\n```\ntemplate<class T>\nclass Base\n{\npublic:\n    T m;\n};\n\nclass SubClass: public Base<int> { // 指定T的类型\npublic:\n    void print() {\n        cout << m << endl;\n    }\n};\n```\n\n如果不想指定类型，那么可以模板化子类\n\n```\n\ntemplate<class T>\nclass Base\n{\npublic:\n    T m;\n};\n\ntemplate<class T1,class T2>\nclass SubClass: public Base<T1> {\npublic:\n    SubClass(T1 a, T2 b) {\n\n    }\n    T2 k;\n};\n\nint main() {\n\tSubClass<string, int> c(\"String\",1);\n\treturn 0;\n}\n```\n\n\n## STL 之 Vector容器\n\n```\nvector<int> v1; // 初始化指定容器内元素类型\nv1.assign(10, 1); // 插入10个1，也可以传入其他vector,比如v1.assign(v0.begin,v0.end); 或者直接 v1 = v0; 只要保证是同种类型就好\nfor (vector<int>::iterator i = v1.begin(); i != v1.end() ; i++) {\n\tcout << *i << endl;\n} // 打印10个1\ncout << \"Size = \" << v1.size() << endl; // 长度 10\ncout << \"isEmpty = \" << v1.empty() << endl; // 判空 0\ncout << \"capacity = \" << v1.capacity() << endl; // 容量 10\nv1.resize(20,20); // 调整容量为20，多出来的位置用20填充，这里的20可以不传，默认0\ncout << \"capacity = \" << v1.capacity() << endl; // 现在容量变成20\n\nv1.pop_back(); // 删除最后一个元素\n\ncout << \"Size = \" << v1.size() << endl; // 长度 19\ncout << \"capacity = \" << v1.capacity() << endl; // 容量不变 20\n\nv1.insert(v1.begin() + 1, 199); // 下标为1的位置插入元素199\nv1.insert(v1.begin() + 1, 2, 199); // 下标为1的位置插入两个元素199\nv1.erase(v1.begin() + 2); // 删除第二个元素\nv1.erase(v1.begin() + 2 , v1.begin() + 3); // 删除第二个到第三个元素\nv1.clear(); // 清空容器\n\ncout << \"第二个元素是\" << v1.at(1) << endl;\ncout << \"第三个元素是\" << v1[2] << endl;\ncout << \"第一个元素\" << v1.front() << endl;\ncout << \"最后一个元素\" << v1.back() << endl;\n\nv1.reverse(100000); // 预留空间，减少以后动态拓展的次数\n\nv1.swap(v0); // 交换元素，假如v1的预留空间很大，可以通过交换一个小预留空间的容器达到压缩内存的效果\n\n```","slug":"C-基础","published":1,"updated":"2021-06-06T18:52:24.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyogo0009tnn07mrg5b7g","content":"<p>在iOS开发过程中，有时候会用到一些C++的库，为了避免大家用到这种库的时候一脸懵逼，这里总结一些基础知识，不写C++没关系，起码当库出了什么问题的时候至少能看懂逻辑（或许吧）。</p>\n<p>这里全部都是基础语法知识，没事的时候可以看看熟悉一下。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"指针和引用\"><a href=\"#指针和引用\" class=\"headerlink\" title=\"指针和引用\"></a>指针和引用</h2><p>略</p>\n<p>还是简单说一下：<code>.</code>是对象访问属性的操作符，<code>-&gt;</code>是指针访问指针属性的操作符，<br><code>(*a).b</code>=&gt;<code>a-&gt;b</code></p>\n<h2 id=\"权限访问\"><a href=\"#权限访问\" class=\"headerlink\" title=\"权限访问\"></a>权限访问</h2><p>public:   可以被任意实体访问</p>\n<p>protected:只允许子类及本类的成员函数访问</p>\n<p>private:只允许本类的成员函数访问</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><p>跟Swift差不多</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int func (int a , int b &#x3D; 10, int c &#x3D; 10); &#x2F;&#x2F; 声明中有默认参数，实现中不能有默认参数，比如下面这么写就会报错</span><br><span class=\"line\">&#x2F;&#x2F; 声明和实现只能其中一个有默认参数</span><br><span class=\"line\">int func (int a , int b &#x3D; 10, int c &#x3D; 10) &#123; &#x2F;&#x2F; 形参默认值，当b有默认值的时候，后面的参数都需要有默认值，不能b有c没有，但是可以c有b没有</span><br><span class=\"line\">\t return a + b + c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"占位参数（没啥用）\"><a href=\"#占位参数（没啥用）\" class=\"headerlink\" title=\"占位参数（没啥用）\"></a>占位参数（没啥用）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void func(int a,int &#x3D; 0) &#123; &#x2F;&#x2F; 占位参数可以有默认参数，也可以没有</span><br><span class=\"line\">\tcout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func(1,2);</span><br></pre></td></tr></table></figure>\n\n<p>其实主要是用与兼容C语言的不规范写法，因为在C语言中，传参个数可以比函数声明的参数个数还多，比如<code>func(1,2,3,4,5)</code>,会警告但是不会报错，但是C++这么写就会报错，所以为了兼容C语言的调用方式，就用占位参数，占个位但是不用它，这样子就不会报错。</p>\n<h3 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h3><p>同一个作用域，函数名相同，参数个数不同/类型不同/顺序不同</p>\n<p><strong>函数的返回值不可以作为函数重载的条件</strong></p>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void func() &#123;&#125;</span><br><span class=\"line\">void func(int a) &#123;&#125;</span><br><span class=\"line\">void func(double a) &#123;&#125;</span><br><span class=\"line\">void func(int a, double b) &#123;&#125;</span><br><span class=\"line\">void func(double a, int b) &#123;&#125;</span><br><span class=\"line\">int func() &#123;&#125; &#x2F;&#x2F; 这个会报错</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"特殊情况\"><a href=\"#特殊情况\" class=\"headerlink\" title=\"特殊情况\"></a>特殊情况</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 引用作为重载的条件</span><br><span class=\"line\">void func(int &amp;a) &#123; &#x2F;&#x2F; 方法1</span><br><span class=\"line\">\tcout &lt;&lt; &quot;func(int &amp;a)&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void func(cont int &amp;a) &#123;  &#x2F;&#x2F; 方法2</span><br><span class=\"line\">\tcout &lt;&lt; &quot;func(cont int &amp;a)&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int a &#x3D; 10;</span><br><span class=\"line\">func(a); &#x2F;&#x2F; 方法1</span><br><span class=\"line\"></span><br><span class=\"line\">func(10); &#x2F;&#x2F; 方法2 因为 const int &amp;a &#x3D; 10; 合法，int &amp;a &#x3D; 10; 不合法</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 函数重载碰到默认参数</span><br><span class=\"line\">void func2(int a) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;func2(int a)&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void func2(int a,int b &#x3D; 10) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;func2(int a, int b)&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func2(10); &#x2F;&#x2F; 出现歧义（二义性），两个方法都能走，报错，所以建议函数重载的时候不要带默认参数</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"struct-和-class-的区别\"><a href=\"#struct-和-class-的区别\" class=\"headerlink\" title=\"struct 和 class 的区别\"></a>struct 和 class 的区别</h2><p><code>struct</code>默认权限为<code>public</code><br><code>class</code>默认权限为<code>private</code></p>\n<h2 id=\"构造函数和析构函数\"><a href=\"#构造函数和析构函数\" class=\"headerlink\" title=\"构造函数和析构函数\"></a>构造函数和析构函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tPerson() &#123;</span><br><span class=\"line\">       cout &lt;&lt; &quot;默认构造函数：系统会默认生成&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPerson(int age) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;带参数构造函数，写了这个系统就不生成无参构造函数&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tthis-&gt;_age &#x3D; age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPerson(int age) : _height(15) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;初始化部分参数的构造函数&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tthis-&gt;_age &#x3D; age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPerson(int age, int height) : _height(height) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;初始化部分参数的构造函数,并且顺便赋值了_height属性&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tthis-&gt;_age &#x3D; age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPerson(const Person &amp;person) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;浅拷贝函数：系统会默认生成&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 如果要深拷贝的话自己手动生成、赋值对象属性。</span><br><span class=\"line\">\t\t&#x2F;&#x2F;如果自己写拷贝构造函数的话，系统不提供其他普通构造函数（有&#x2F;无参）</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t~Person() &#123;</span><br><span class=\"line\">       cout&lt;&lt;&quot;析构函数：系统默认生成&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;int age; &#x2F;&#x2F; 不建议使用跟形参同名的成员变量</span><br><span class=\"line\">\tint _age; &#x2F;&#x2F; 带个下划线吧</span><br><span class=\"line\">\tint _height;</span><br><span class=\"line\">\tSomeClass property; &#x2F;&#x2F; 别的类的属性：构造时会优先进入该类构造函数，析构时会优先进入Person的析构函数，再走这个类的析构函数</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tPerson p1; &#x2F;&#x2F; 这样子就实例化了</span><br><span class=\"line\">\tPerson p2(11); &#x2F;&#x2F; age &#x3D; 11</span><br><span class=\"line\">\tPerson p3(11,160); &#x2F;&#x2F; age &#x3D; 11 height &#x3D; 160</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"链式调用函数\"><a href=\"#链式调用函数\" class=\"headerlink\" title=\"链式调用函数\"></a>链式调用函数</h2><p>在上面的Person类内加多这么一个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person&amp; addAge(Person &amp;p) &#123;</span><br><span class=\"line\">\tthis-&gt;_age +&#x3D; p._Age;</span><br><span class=\"line\">\treturn *this; &#x2F;&#x2F; 返回当前对象指针！！！</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Person pp(20);</span><br><span class=\"line\">Person pp2(10);</span><br><span class=\"line\">pp.addAge(pp2).addAge(pp2).addAge(pp2); &#x2F;&#x2F; 爽快地链式调用</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tstatic void func() &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;静态方法只能访问静态常量&quot; &lt;&lt; test &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tstatic int test;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tPerson p;</span><br><span class=\"line\">\tp.func(); &#x2F;&#x2F; 可以这么调</span><br><span class=\"line\">\tPerson::func(); &#x2F;&#x2F; 也可以通过类名直接调</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常函数和常对象\"><a href=\"#常函数和常对象\" class=\"headerlink\" title=\"常函数和常对象\"></a>常函数和常对象</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid funcA() const &#123;</span><br><span class=\"line\">&#x2F;&#x2F;\t\tthis-&gt;_name &#x3D; &quot;test&quot;;  常函数不可以访问普通成员属性</span><br><span class=\"line\">\t\tthis-&gt;_age &#x3D; 1; &#x2F;&#x2F;常函数可以访问被mutable修饰的成员属性</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstring _name;</span><br><span class=\"line\">\tmutable int _age;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tvoid funcB() &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tconst Person p;</span><br><span class=\"line\">&#x2F;&#x2F;\tp.funcB(); &#x2F;&#x2F; 常对象不能访问普通函数</span><br><span class=\"line\">\tp.funcA(); &#x2F;&#x2F; 常对象只能访问常函数</span><br><span class=\"line\">\treutrn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在类外部实现函数\"><a href=\"#在类外部实现函数\" class=\"headerlink\" title=\"在类外部实现函数\"></a>在类外部实现函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public: &#x2F;&#x2F; 需要是public函数才可以这么玩</span><br><span class=\"line\">\tPerson(); &#x2F;&#x2F; 要在外部实现的都得事先声明</span><br><span class=\"line\">\tvoid test();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person::Person() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Person::test() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"友元函数\"><a href=\"#友元函数\" class=\"headerlink\" title=\"友元函数\"></a>友元函数</h2><p>友元函数可以访问被<code>private</code>修饰的属性</p>\n<h3 id=\"全局函数做友元\"><a href=\"#全局函数做友元\" class=\"headerlink\" title=\"全局函数做友元\"></a>全局函数做友元</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">class Building &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 友元函数 可以访问私有属性</span><br><span class=\"line\">    friend void visitor(Building &amp;building);</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Building() &#123;</span><br><span class=\"line\">        m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class=\"line\">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    string m_SittingRoom;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    string m_Bedroom;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void visitor(Building &amp;building) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_SittingRoom &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_Bedroom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>顺带一提：如果入参是引用的话（<code>&amp;building</code>）,那么可以直接通过点语法访问成员属性，如果入参是指针的话（<code>*building</code>），那么就通过<code>-&gt;</code>访问，如（building-&gt;m_Bedroom）</p>\n</blockquote>\n<blockquote>\n<p>顺带再提，两种函数声明和调用方式的不同</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void visitor(Building &amp;building) &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_SittingRoom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void visitor2(Building *building) &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Building building;  &#x2F;&#x2F; 生成对象</span><br><span class=\"line\">    visitor(building);  &#x2F;&#x2F; 直接传对象</span><br><span class=\"line\">    visitor2(&amp;building); &#x2F;&#x2F; 传对象地址</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"友元类\"><a href=\"#友元类\" class=\"headerlink\" title=\"友元类\"></a>友元类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Building &#123;</span><br><span class=\"line\">    friend class Visitor; &#x2F;&#x2F; 这个类下的所有函数都可以访问它的私有属性</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Building() &#123;</span><br><span class=\"line\">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    string m_Bedroom;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Visitor</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tVisitor() &#123;</span><br><span class=\"line\">\t\tbuilding &#x3D; new Building;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid visit();</span><br><span class=\"line\">\tBuilding *building;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void Visitor::visit() &#123;</span><br><span class=\"line\">\tcout &lt;&lt; building-&gt;m_Bedroom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tVisitor v;</span><br><span class=\"line\">\tv.visit();</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"成员函数做友元函数\"><a href=\"#成员函数做友元函数\" class=\"headerlink\" title=\"成员函数做友元函数\"></a>成员函数做友元函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Building;</span><br><span class=\"line\">class Visitor</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Visitor();</span><br><span class=\"line\">    void visit();</span><br><span class=\"line\">    Building *building;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Building &#123;</span><br><span class=\"line\">    friend void Visitor::visit(); &#x2F;&#x2F; 指定Visitor的visit成员函数可以访问私有属性</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Building() &#123;</span><br><span class=\"line\">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    string m_Bedroom;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 为什么这个构造函数要写外面，不能写里面？</span><br><span class=\"line\">&#x2F;&#x2F; 因为Visitor需要在Building上面定义，不然不给定义Visitor上的友元函数，然后因为Visitor内有Building的属性，所以要声明一下class Building; 但是因为只是声明没有实现，所以就不能new Building;了，那就只能把这个通过类外实现的方式写在Building定义的下面。</span><br><span class=\"line\">Visitor::Visitor() &#123;  </span><br><span class=\"line\">    building &#x3D; new Building;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Visitor::visit() &#123;</span><br><span class=\"line\">    cout &lt;&lt; building-&gt;m_Bedroom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Visitor v;</span><br><span class=\"line\">    v.visit();</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运算符重载\"><a href=\"#运算符重载\" class=\"headerlink\" title=\"运算符重载\"></a>运算符重载</h2><p>跟Swift差不多</p>\n<h3 id=\"成员函数的运算符重载\"><a href=\"#成员函数的运算符重载\" class=\"headerlink\" title=\"成员函数的运算符重载\"></a>成员函数的运算符重载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Animal operator + (Animal &amp;a) &#123;</span><br><span class=\"line\">        Animal temp;</span><br><span class=\"line\">        temp.m_A &#x3D; this -&gt; m_A + a.m_A;</span><br><span class=\"line\">        return temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int m_A;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal a;</span><br><span class=\"line\">a.m_A &#x3D; 1;</span><br><span class=\"line\">Animal b;</span><br><span class=\"line\">b.m_A &#x3D; 2;</span><br><span class=\"line\">Animal c &#x3D; a + b;</span><br><span class=\"line\">cout &lt;&lt; c.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 3</span><br></pre></td></tr></table></figure>\n\n<p>本质：<code>Animal c = a.operator+(b);</code></p>\n<h3 id=\"全局函数的运算符重载\"><a href=\"#全局函数的运算符重载\" class=\"headerlink\" title=\"全局函数的运算符重载\"></a>全局函数的运算符重载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal operator - (Animal &amp;a, Animal &amp;b) &#123;</span><br><span class=\"line\">    Animal temp;</span><br><span class=\"line\">    temp.m_A &#x3D; a.m_A - b.m_A;</span><br><span class=\"line\">    return temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal a;</span><br><span class=\"line\">a.m_A &#x3D; 1;</span><br><span class=\"line\">Animal b;</span><br><span class=\"line\">b.m_A &#x3D; 2;</span><br><span class=\"line\">Animal c &#x3D; a - b;</span><br><span class=\"line\">cout &lt;&lt; c.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 -1</span><br></pre></td></tr></table></figure>\n\n<p>本质：<code>Animal c = operator-(a,b);</code></p>\n<h3 id=\"运算符重载也可以发生函数重载\"><a href=\"#运算符重载也可以发生函数重载\" class=\"headerlink\" title=\"运算符重载也可以发生函数重载\"></a>运算符重载也可以发生函数重载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal operator + (int a, Animal &amp;b) &#123;</span><br><span class=\"line\">    Animal temp;</span><br><span class=\"line\">    temp.m_A &#x3D; a + b.m_A;</span><br><span class=\"line\">    return temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal a;</span><br><span class=\"line\">a.m_A &#x3D; 1;</span><br><span class=\"line\">Animal d &#x3D; 10 + a;</span><br><span class=\"line\">cout &lt;&lt; d.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 11</span><br></pre></td></tr></table></figure>\n\n<p>本质：<code>Animal d = operator+(10,a);</code></p>\n<h3 id=\"左移运算符重载（比较常见输出对象细节）\"><a href=\"#左移运算符重载（比较常见输出对象细节）\" class=\"headerlink\" title=\"左移运算符重载（比较常见输出对象细节）\"></a>左移运算符重载（比较常见输出对象细节）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyInteger &#123;</span><br><span class=\"line\">    friend ostream&amp; operator&lt;&lt;(ostream&amp; cout,MyInteger myInt);</span><br><span class=\"line\">public:</span><br><span class=\"line\">    MyInteger() &#123;</span><br><span class=\"line\">        this-&gt;my_int &#x3D; 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    int my_int;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 必须是全局函数重载 ostream是cout的类型，为了能链式调用所以返回引用ostream&amp;</span><br><span class=\"line\">ostream&amp; operator&lt;&lt;(ostream&amp; cout,MyInteger myInt) &#123;</span><br><span class=\"line\">    cout &lt;&lt; myInt.my_int; &#x2F;&#x2F; 返回对象细节</span><br><span class=\"line\">    return cout;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    MyInteger myInt;</span><br><span class=\"line\">    cout &lt;&lt; myInt &lt;&lt; endl; &#x2F;&#x2F; 输出 my_int 的值 0</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关系运算符重载\"><a href=\"#关系运算符重载\" class=\"headerlink\" title=\"关系运算符重载\"></a>关系运算符重载</h3><p>Swift经常使用，参见<code>Equable</code>，<code>Comparable</code>协议</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool operator&#x3D;&#x3D;(Person &amp;p) &#123;</span><br><span class=\"line\">        if (this-&gt;m_Name &#x3D;&#x3D; p.m_Name) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bool operator!&#x3D;(Person &amp;p) &#123;</span><br><span class=\"line\">        if (this-&gt;m_Name !&#x3D; p.m_Name) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\tstring m_Name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tPerson p1; p1.m_Name &#x3D; &quot;A&quot;;</span><br><span class=\"line\">    Person p2; p2.m_Name &#x3D; &quot;A&quot;;</span><br><span class=\"line\">    if (p1 &#x3D;&#x3D; p2) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Equal&quot; &lt;&lt; endl; &#x2F;&#x2F; 输出</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Different&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (p1 !&#x3D; p2) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Different&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Equal&quot; &lt;&lt; endl; &#x2F;&#x2F; 输出</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数调用运算符的重载（骚操作）\"><a href=\"#函数调用运算符的重载（骚操作）\" class=\"headerlink\" title=\"函数调用运算符的重载（骚操作）\"></a>函数调用运算符的重载（骚操作）</h3><p>因为用起来很像函数，所以又叫做仿函数，STL里相当多这种骚操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyInteger &#123;</span><br><span class=\"line\">\tint operator()(int a,int b) &#123;</span><br><span class=\"line\">        return a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; MyInteger() ：匿名对象</span><br><span class=\"line\">    int result &#x3D; MyInteger()(1,2);</span><br><span class=\"line\"></span><br><span class=\"line\">    MyInteger i;</span><br><span class=\"line\">    int result2 &#x3D; i(5,2);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; result &lt;&lt; endl;  &#x2F;&#x2F; 5</span><br><span class=\"line\">    cout &lt;&lt; result2 &lt;&lt; endl; &#x2F;&#x2F; 7</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>C++有多继承，灰常厉害</p>\n<h3 id=\"继承方式\"><a href=\"#继承方式\" class=\"headerlink\" title=\"继承方式\"></a>继承方式</h3><p>三种继承方式<code>public</code>,<code>protected</code>,<code>private</code>，决定着继承下来的属性和方法以什么形式修饰，<code>class</code>默认<code>private</code>,<code>struct</code>默认<code>public</code>（没错，C++中结构体可以被继承）<br>父类的所有非静态属性会被继承，包括<code>private</code>类型的，但是<code>private</code>类型的默认隐藏，子类无法访问。</p>\n<p>继承语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class SubClass : public SuperClass &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构造和析构\"><a href=\"#构造和析构\" class=\"headerlink\" title=\"构造和析构\"></a>构造和析构</h3><p>父类先构造，子类先析构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">superClass()</span><br><span class=\"line\">subClass()</span><br><span class=\"line\">~subClass()</span><br><span class=\"line\">~superClass()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"同名属性-函数-静态属性-静态函数的访问\"><a href=\"#同名属性-函数-静态属性-静态函数的访问\" class=\"headerlink\" title=\"同名属性/函数/静态属性/静态函数的访问\"></a>同名属性/函数/静态属性/静态函数的访问</h3><p>假如子类和父类拥有相同的名字的属性/函数/静态属性/静态函数，则直接调用子类对象的话都是访问子类的，如果要访问父类的话要添加作用域。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int _a &#x3D; 1;</span><br><span class=\"line\">    static int _b;</span><br><span class=\"line\">    static void staticFunc() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Base staticFunc()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void Func() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Base Func()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int Base::_b &#x3D; 10; &#x2F;&#x2F; 静态成员变量要在外面赋值</span><br><span class=\"line\"></span><br><span class=\"line\">class Sub1 : public Base &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int _a &#x3D; 2;</span><br><span class=\"line\">    static int _b;</span><br><span class=\"line\">    static void staticFunc() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;SubClass staticFunc()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void Func() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;SucClass Func()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int Sub1::_b &#x3D; 20;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Sub1 s;</span><br><span class=\"line\">    &#x2F;&#x2F; 直接调用</span><br><span class=\"line\">    cout &lt;&lt; s._a &lt;&lt; endl;</span><br><span class=\"line\">    &#x2F;&#x2F; 调用父类的</span><br><span class=\"line\">    cout &lt;&lt; s.Base::_a &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 静态直接调用</span><br><span class=\"line\">    cout &lt;&lt; s._b &lt;&lt; endl;</span><br><span class=\"line\">    &#x2F;&#x2F; 静态调用父类的</span><br><span class=\"line\">    cout &lt;&lt; s.Base::_b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 静态直接调用</span><br><span class=\"line\">    cout &lt;&lt; Sub1::_b &lt;&lt; endl;</span><br><span class=\"line\">    &#x2F;&#x2F; 静态调用父类的</span><br><span class=\"line\">    cout &lt;&lt; Sub1::Base::_b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 直接调用</span><br><span class=\"line\">    s.Func();</span><br><span class=\"line\">    &#x2F;&#x2F; 调用父类的</span><br><span class=\"line\">    s.Base::Func();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 静态直接调用</span><br><span class=\"line\">    s.staticFunc();</span><br><span class=\"line\">    &#x2F;&#x2F; 静态调用父类的</span><br><span class=\"line\">    s.Base::staticFunc();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 静态直接调用</span><br><span class=\"line\">    Sub1::staticFunc();</span><br><span class=\"line\">    &#x2F;&#x2F; 静态调用父类的</span><br><span class=\"line\">    Sub1::Base::staticFunc();</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h3><p>不建议使用，因为麻烦事多</p>\n<p>语法：(参照上面的代码)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Other &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void Func() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Ohter Func()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#x2F;&#x2F;...略</span><br><span class=\"line\">class Sub1 : public Base , public Other &#123;</span><br><span class=\"line\">&#x2F;&#x2F;...略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当多个父类中出现同名属性/方法时，需要加作用域指定父类<code>s.Base::Func(); / s.Other::Func();</code></p>\n<h3 id=\"菱形继承（钻石继承）\"><a href=\"#菱形继承（钻石继承）\" class=\"headerlink\" title=\"菱形继承（钻石继承）\"></a>菱形继承（钻石继承）</h3><p>两个子类继承同一个基类，<br>又有某个类同时继承着两个子类</p>\n<p>举例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base &#123; int age &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Sub1: public Base &#123;&#125;;</span><br><span class=\"line\">class Sub2: public Base &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class SubSub: public Sub1, public Sub2 &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这时候SubSub会有两个父类，有两份 age 属性，造成资源浪费</p>\n<p>这时候用虚继承(<code>virtual</code>)解决问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base &#123; public: int age &#125;; &#x2F;&#x2F; 这时候成为虚基类</span><br><span class=\"line\"></span><br><span class=\"line\">class Sub1: virtual public Base &#123;&#125;;</span><br><span class=\"line\">class Sub2: virtual public Base &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class SubSub: public Sub1, public Sub2 &#123;&#125;;</span><br></pre></td></tr></table></figure>\n<p>这时候age属性成为共享属性，最后谁改了就是谁的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SubSub s;</span><br><span class=\"line\">s.Sub1::age &#x3D; 1;</span><br><span class=\"line\">s.Sub2::age &#x3D; 10;</span><br><span class=\"line\">cout &lt;&lt; s.Sub1::age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br><span class=\"line\">cout &lt;&lt; s.Sub2::age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br><span class=\"line\">cout &lt;&lt; s.age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p>C++中，多态分两类</p>\n<p>静态多态：函数重载和运算符重载属于静态多态，复用函数名<br>动态多态：子类和虚函数实现运行时多态</p>\n<p>区别：</p>\n<p>静态多态的函数地址早绑定，编译阶段确定函数地址<br>动态多态的函数地址晚绑定，运行阶段确定函数地址</p>\n<p>动态多态满足条件：</p>\n<ol>\n<li>有继承关系</li>\n<li>子类重写父类虚函数</li>\n</ol>\n<p>动态多态使用<br>父类的指针或者引用指向子类对象</p>\n<p>静态多态举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void speak() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Animal Speak&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Cat: public Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void speak() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Cat Speak&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">void SomeoneSpeak(Animal &amp;animal) &#123;</span><br><span class=\"line\">    animal.speak();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Cat c;</span><br><span class=\"line\">    SomeoneSpeak(c); &#x2F;&#x2F; 由于SomeoneSpeak(Animal &amp;animal)，编译期间已经确定入参类型，所以输出 Animal Speak</span><br></pre></td></tr></table></figure>\n\n<p>如果想输出<code>Cat Speak</code>，只需进行如下修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    virtual void speak() &#123; &#x2F;&#x2F; 虚函数，可以告知由于SomeoneSpeak(Animal &amp;animal)运行时再确定入参类型</span><br><span class=\"line\">        cout &lt;&lt; &quot;Animal Speak&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>经常地，这种情况下也是动态多态，最后会输出<code>Cat Speak</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal *a &#x3D; new Cat;</span><br><span class=\"line\">a-&gt;speak();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"纯虚函数和抽象类\"><a href=\"#纯虚函数和抽象类\" class=\"headerlink\" title=\"纯虚函数和抽象类\"></a>纯虚函数和抽象类</h3><p>父类的虚函数的实现没什么意义，所以上面的虚函数代码改写为<code>纯虚函数</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">virtual void speak() &#x3D; 0;</span><br></pre></td></tr></table></figure>\n\n<p>当类中有了纯虚函数，则这个类称为<code>抽象类</code></p>\n<p>抽象类<strong>无法实例化对象</strong>，并且<strong>子类必须重写父类的纯虚函数</strong>，否则也成为<code>抽象类</code></p>\n<h3 id=\"虚析构和纯虚析构\"><a href=\"#虚析构和纯虚析构\" class=\"headerlink\" title=\"虚析构和纯虚析构\"></a>虚析构和纯虚析构</h3><p>当子类在堆区创建数据的时候，需要手动释放，父类需要添加虚析构或者纯虚析构函数，否则子类可能不走析构函数</p>\n<p>比如上面的<code>Animate</code>父类，我们补充一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    virtual ~Animal() &#x3D; 0; &#x2F;&#x2F; 纯虚析构</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal::~Animal() &#123; &#x2F;&#x2F; 析构实现</span><br><span class=\"line\">    cout &lt;&lt; &quot;Animal is Delete&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><p>文件打开方式</p>\n<p><code>ios::in</code>:读文件<br><code>ios::out</code>:写文件<br><code>ios::ate</code>:初始位置，文件尾<br><code>ios:app</code>:追加写文件<br><code>ios:trunc</code>:如果文件存在先删除，再创建<br><code>ios:binary</code>:二进制方式</p>\n<p>同时两种方式则使用<code>|</code>的方式，比如<code>ios::in|ios:binary</code></p>\n<h3 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ofstream stream;</span><br><span class=\"line\"></span><br><span class=\"line\">stream.open(&quot;Test.txt&quot;,ios::out);</span><br><span class=\"line\"></span><br><span class=\"line\">stream &lt;&lt; &quot;Line 1&quot; &lt;&lt; endl;</span><br><span class=\"line\">stream &lt;&lt; &quot;Line 2&quot; &lt;&lt; endl;</span><br><span class=\"line\">stream &lt;&lt; &quot;Line 3&quot; &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">stream.close();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifstream ifs;</span><br><span class=\"line\">ifs.open(&quot;Test.txt&quot;,ios::out);</span><br><span class=\"line\"></span><br><span class=\"line\">if(!ifs.is_open()) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;打开文件失败&quot; &lt;&lt; endl;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">string buf;</span><br><span class=\"line\">while (getline(ifs, buf)) &#123; &#x2F;&#x2F; 一行行读取</span><br><span class=\"line\">\tcout &lt;&lt; buf &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ifs.close();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h2><h3 id=\"构建类模板与类模板做参数\"><a href=\"#构建类模板与类模板做参数\" class=\"headerlink\" title=\"构建类模板与类模板做参数\"></a>构建类模板与类模板做参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class NameType,class AgeType&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Person(NameType name, AgeType age) &#123;</span><br><span class=\"line\">        this-&gt;_age &#x3D; age;</span><br><span class=\"line\">        this-&gt;_name &#x3D; name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    AgeType _age;</span><br><span class=\"line\">    NameType _name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 不会自动类型推导，需要自己显式声明类型</span><br><span class=\"line\">    Person&lt;string,int&gt; p(&quot;Haha&quot;,123);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; p._name &lt;&lt; &quot; &quot; &lt;&lt; p._age &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可以给类模板添加默认类型</p>\n<p><code>template&lt;class NameType,class AgeType = int&gt;</code></p>\n<p>这样子调用的时候就可以不全声明类型了</p>\n<p><code>Person&lt;string&gt; p(&quot;Haha&quot;,123);</code></p>\n<p>类模板做参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 指定类型的类模板做参数</span><br><span class=\"line\">void print(Person&lt;string,int&gt; &amp;p) &#123;</span><br><span class=\"line\">    p.showPerson();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 模板化参数的类模板做参数</span><br><span class=\"line\">template&lt;class T1,class T2&gt;</span><br><span class=\"line\">void print2(Person&lt;T1, T2&gt; &amp;p) &#123;</span><br><span class=\"line\">    p.showPerson();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 模板化类做参数</span><br><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">void print3(T &amp;p) &#123;</span><br><span class=\"line\">    p.showPerson();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Person&lt;string,int&gt; p(&quot;Haha&quot;,123);</span><br><span class=\"line\">    print(p);</span><br><span class=\"line\">    print2(p);</span><br><span class=\"line\">    print3(p);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类模板与继承\"><a href=\"#类模板与继承\" class=\"headerlink\" title=\"类模板与继承\"></a>类模板与继承</h3><p>继承时需要指定类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">class Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    T m;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class SubClass: public Base&lt;int&gt; &#123; &#x2F;&#x2F; 指定T的类型</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void print() &#123;</span><br><span class=\"line\">        cout &lt;&lt; m &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果不想指定类型，那么可以模板化子类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">class Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    T m;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;class T1,class T2&gt;</span><br><span class=\"line\">class SubClass: public Base&lt;T1&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    SubClass(T1 a, T2 b) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    T2 k;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tSubClass&lt;string, int&gt; c(&quot;String&quot;,1);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"STL-之-Vector容器\"><a href=\"#STL-之-Vector容器\" class=\"headerlink\" title=\"STL 之 Vector容器\"></a>STL 之 Vector容器</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int&gt; v1; &#x2F;&#x2F; 初始化指定容器内元素类型</span><br><span class=\"line\">v1.assign(10, 1); &#x2F;&#x2F; 插入10个1，也可以传入其他vector,比如v1.assign(v0.begin,v0.end); 或者直接 v1 &#x3D; v0; 只要保证是同种类型就好</span><br><span class=\"line\">for (vector&lt;int&gt;::iterator i &#x3D; v1.begin(); i !&#x3D; v1.end() ; i++) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; *i &lt;&lt; endl;</span><br><span class=\"line\">&#125; &#x2F;&#x2F; 打印10个1</span><br><span class=\"line\">cout &lt;&lt; &quot;Size &#x3D; &quot; &lt;&lt; v1.size() &lt;&lt; endl; &#x2F;&#x2F; 长度 10</span><br><span class=\"line\">cout &lt;&lt; &quot;isEmpty &#x3D; &quot; &lt;&lt; v1.empty() &lt;&lt; endl; &#x2F;&#x2F; 判空 0</span><br><span class=\"line\">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 容量 10</span><br><span class=\"line\">v1.resize(20,20); &#x2F;&#x2F; 调整容量为20，多出来的位置用20填充，这里的20可以不传，默认0</span><br><span class=\"line\">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 现在容量变成20</span><br><span class=\"line\"></span><br><span class=\"line\">v1.pop_back(); &#x2F;&#x2F; 删除最后一个元素</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; &quot;Size &#x3D; &quot; &lt;&lt; v1.size() &lt;&lt; endl; &#x2F;&#x2F; 长度 19</span><br><span class=\"line\">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 容量不变 20</span><br><span class=\"line\"></span><br><span class=\"line\">v1.insert(v1.begin() + 1, 199); &#x2F;&#x2F; 下标为1的位置插入元素199</span><br><span class=\"line\">v1.insert(v1.begin() + 1, 2, 199); &#x2F;&#x2F; 下标为1的位置插入两个元素199</span><br><span class=\"line\">v1.erase(v1.begin() + 2); &#x2F;&#x2F; 删除第二个元素</span><br><span class=\"line\">v1.erase(v1.begin() + 2 , v1.begin() + 3); &#x2F;&#x2F; 删除第二个到第三个元素</span><br><span class=\"line\">v1.clear(); &#x2F;&#x2F; 清空容器</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; &quot;第二个元素是&quot; &lt;&lt; v1.at(1) &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; &quot;第三个元素是&quot; &lt;&lt; v1[2] &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; &quot;第一个元素&quot; &lt;&lt; v1.front() &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; &quot;最后一个元素&quot; &lt;&lt; v1.back() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">v1.reverse(100000); &#x2F;&#x2F; 预留空间，减少以后动态拓展的次数</span><br><span class=\"line\"></span><br><span class=\"line\">v1.swap(v0); &#x2F;&#x2F; 交换元素，假如v1的预留空间很大，可以通过交换一个小预留空间的容器达到压缩内存的效果</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>在iOS开发过程中，有时候会用到一些C++的库，为了避免大家用到这种库的时候一脸懵逼，这里总结一些基础知识，不写C++没关系，起码当库出了什么问题的时候至少能看懂逻辑（或许吧）。</p>\n<p>这里全部都是基础语法知识，没事的时候可以看看熟悉一下。</p>","more":"<h2 id=\"指针和引用\"><a href=\"#指针和引用\" class=\"headerlink\" title=\"指针和引用\"></a>指针和引用</h2><p>略</p>\n<p>还是简单说一下：<code>.</code>是对象访问属性的操作符，<code>-&gt;</code>是指针访问指针属性的操作符，<br><code>(*a).b</code>=&gt;<code>a-&gt;b</code></p>\n<h2 id=\"权限访问\"><a href=\"#权限访问\" class=\"headerlink\" title=\"权限访问\"></a>权限访问</h2><p>public:   可以被任意实体访问</p>\n<p>protected:只允许子类及本类的成员函数访问</p>\n<p>private:只允许本类的成员函数访问</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><p>跟Swift差不多</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int func (int a , int b &#x3D; 10, int c &#x3D; 10); &#x2F;&#x2F; 声明中有默认参数，实现中不能有默认参数，比如下面这么写就会报错</span><br><span class=\"line\">&#x2F;&#x2F; 声明和实现只能其中一个有默认参数</span><br><span class=\"line\">int func (int a , int b &#x3D; 10, int c &#x3D; 10) &#123; &#x2F;&#x2F; 形参默认值，当b有默认值的时候，后面的参数都需要有默认值，不能b有c没有，但是可以c有b没有</span><br><span class=\"line\">\t return a + b + c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"占位参数（没啥用）\"><a href=\"#占位参数（没啥用）\" class=\"headerlink\" title=\"占位参数（没啥用）\"></a>占位参数（没啥用）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void func(int a,int &#x3D; 0) &#123; &#x2F;&#x2F; 占位参数可以有默认参数，也可以没有</span><br><span class=\"line\">\tcout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func(1,2);</span><br></pre></td></tr></table></figure>\n\n<p>其实主要是用与兼容C语言的不规范写法，因为在C语言中，传参个数可以比函数声明的参数个数还多，比如<code>func(1,2,3,4,5)</code>,会警告但是不会报错，但是C++这么写就会报错，所以为了兼容C语言的调用方式，就用占位参数，占个位但是不用它，这样子就不会报错。</p>\n<h3 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h3><p>同一个作用域，函数名相同，参数个数不同/类型不同/顺序不同</p>\n<p><strong>函数的返回值不可以作为函数重载的条件</strong></p>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void func() &#123;&#125;</span><br><span class=\"line\">void func(int a) &#123;&#125;</span><br><span class=\"line\">void func(double a) &#123;&#125;</span><br><span class=\"line\">void func(int a, double b) &#123;&#125;</span><br><span class=\"line\">void func(double a, int b) &#123;&#125;</span><br><span class=\"line\">int func() &#123;&#125; &#x2F;&#x2F; 这个会报错</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"特殊情况\"><a href=\"#特殊情况\" class=\"headerlink\" title=\"特殊情况\"></a>特殊情况</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 引用作为重载的条件</span><br><span class=\"line\">void func(int &amp;a) &#123; &#x2F;&#x2F; 方法1</span><br><span class=\"line\">\tcout &lt;&lt; &quot;func(int &amp;a)&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void func(cont int &amp;a) &#123;  &#x2F;&#x2F; 方法2</span><br><span class=\"line\">\tcout &lt;&lt; &quot;func(cont int &amp;a)&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int a &#x3D; 10;</span><br><span class=\"line\">func(a); &#x2F;&#x2F; 方法1</span><br><span class=\"line\"></span><br><span class=\"line\">func(10); &#x2F;&#x2F; 方法2 因为 const int &amp;a &#x3D; 10; 合法，int &amp;a &#x3D; 10; 不合法</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 函数重载碰到默认参数</span><br><span class=\"line\">void func2(int a) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;func2(int a)&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void func2(int a,int b &#x3D; 10) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;func2(int a, int b)&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func2(10); &#x2F;&#x2F; 出现歧义（二义性），两个方法都能走，报错，所以建议函数重载的时候不要带默认参数</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"struct-和-class-的区别\"><a href=\"#struct-和-class-的区别\" class=\"headerlink\" title=\"struct 和 class 的区别\"></a>struct 和 class 的区别</h2><p><code>struct</code>默认权限为<code>public</code><br><code>class</code>默认权限为<code>private</code></p>\n<h2 id=\"构造函数和析构函数\"><a href=\"#构造函数和析构函数\" class=\"headerlink\" title=\"构造函数和析构函数\"></a>构造函数和析构函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tPerson() &#123;</span><br><span class=\"line\">       cout &lt;&lt; &quot;默认构造函数：系统会默认生成&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPerson(int age) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;带参数构造函数，写了这个系统就不生成无参构造函数&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tthis-&gt;_age &#x3D; age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPerson(int age) : _height(15) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;初始化部分参数的构造函数&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tthis-&gt;_age &#x3D; age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPerson(int age, int height) : _height(height) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;初始化部分参数的构造函数,并且顺便赋值了_height属性&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tthis-&gt;_age &#x3D; age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPerson(const Person &amp;person) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;浅拷贝函数：系统会默认生成&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 如果要深拷贝的话自己手动生成、赋值对象属性。</span><br><span class=\"line\">\t\t&#x2F;&#x2F;如果自己写拷贝构造函数的话，系统不提供其他普通构造函数（有&#x2F;无参）</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t~Person() &#123;</span><br><span class=\"line\">       cout&lt;&lt;&quot;析构函数：系统默认生成&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;int age; &#x2F;&#x2F; 不建议使用跟形参同名的成员变量</span><br><span class=\"line\">\tint _age; &#x2F;&#x2F; 带个下划线吧</span><br><span class=\"line\">\tint _height;</span><br><span class=\"line\">\tSomeClass property; &#x2F;&#x2F; 别的类的属性：构造时会优先进入该类构造函数，析构时会优先进入Person的析构函数，再走这个类的析构函数</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tPerson p1; &#x2F;&#x2F; 这样子就实例化了</span><br><span class=\"line\">\tPerson p2(11); &#x2F;&#x2F; age &#x3D; 11</span><br><span class=\"line\">\tPerson p3(11,160); &#x2F;&#x2F; age &#x3D; 11 height &#x3D; 160</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"链式调用函数\"><a href=\"#链式调用函数\" class=\"headerlink\" title=\"链式调用函数\"></a>链式调用函数</h2><p>在上面的Person类内加多这么一个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person&amp; addAge(Person &amp;p) &#123;</span><br><span class=\"line\">\tthis-&gt;_age +&#x3D; p._Age;</span><br><span class=\"line\">\treturn *this; &#x2F;&#x2F; 返回当前对象指针！！！</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Person pp(20);</span><br><span class=\"line\">Person pp2(10);</span><br><span class=\"line\">pp.addAge(pp2).addAge(pp2).addAge(pp2); &#x2F;&#x2F; 爽快地链式调用</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tstatic void func() &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;静态方法只能访问静态常量&quot; &lt;&lt; test &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tstatic int test;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tPerson p;</span><br><span class=\"line\">\tp.func(); &#x2F;&#x2F; 可以这么调</span><br><span class=\"line\">\tPerson::func(); &#x2F;&#x2F; 也可以通过类名直接调</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常函数和常对象\"><a href=\"#常函数和常对象\" class=\"headerlink\" title=\"常函数和常对象\"></a>常函数和常对象</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid funcA() const &#123;</span><br><span class=\"line\">&#x2F;&#x2F;\t\tthis-&gt;_name &#x3D; &quot;test&quot;;  常函数不可以访问普通成员属性</span><br><span class=\"line\">\t\tthis-&gt;_age &#x3D; 1; &#x2F;&#x2F;常函数可以访问被mutable修饰的成员属性</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstring _name;</span><br><span class=\"line\">\tmutable int _age;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tvoid funcB() &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tconst Person p;</span><br><span class=\"line\">&#x2F;&#x2F;\tp.funcB(); &#x2F;&#x2F; 常对象不能访问普通函数</span><br><span class=\"line\">\tp.funcA(); &#x2F;&#x2F; 常对象只能访问常函数</span><br><span class=\"line\">\treutrn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在类外部实现函数\"><a href=\"#在类外部实现函数\" class=\"headerlink\" title=\"在类外部实现函数\"></a>在类外部实现函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public: &#x2F;&#x2F; 需要是public函数才可以这么玩</span><br><span class=\"line\">\tPerson(); &#x2F;&#x2F; 要在外部实现的都得事先声明</span><br><span class=\"line\">\tvoid test();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person::Person() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Person::test() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"友元函数\"><a href=\"#友元函数\" class=\"headerlink\" title=\"友元函数\"></a>友元函数</h2><p>友元函数可以访问被<code>private</code>修饰的属性</p>\n<h3 id=\"全局函数做友元\"><a href=\"#全局函数做友元\" class=\"headerlink\" title=\"全局函数做友元\"></a>全局函数做友元</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">class Building &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 友元函数 可以访问私有属性</span><br><span class=\"line\">    friend void visitor(Building &amp;building);</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Building() &#123;</span><br><span class=\"line\">        m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class=\"line\">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    string m_SittingRoom;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    string m_Bedroom;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void visitor(Building &amp;building) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_SittingRoom &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_Bedroom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>顺带一提：如果入参是引用的话（<code>&amp;building</code>）,那么可以直接通过点语法访问成员属性，如果入参是指针的话（<code>*building</code>），那么就通过<code>-&gt;</code>访问，如（building-&gt;m_Bedroom）</p>\n</blockquote>\n<blockquote>\n<p>顺带再提，两种函数声明和调用方式的不同</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void visitor(Building &amp;building) &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_SittingRoom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void visitor2(Building *building) &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Building building;  &#x2F;&#x2F; 生成对象</span><br><span class=\"line\">    visitor(building);  &#x2F;&#x2F; 直接传对象</span><br><span class=\"line\">    visitor2(&amp;building); &#x2F;&#x2F; 传对象地址</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"友元类\"><a href=\"#友元类\" class=\"headerlink\" title=\"友元类\"></a>友元类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Building &#123;</span><br><span class=\"line\">    friend class Visitor; &#x2F;&#x2F; 这个类下的所有函数都可以访问它的私有属性</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Building() &#123;</span><br><span class=\"line\">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    string m_Bedroom;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Visitor</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tVisitor() &#123;</span><br><span class=\"line\">\t\tbuilding &#x3D; new Building;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid visit();</span><br><span class=\"line\">\tBuilding *building;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void Visitor::visit() &#123;</span><br><span class=\"line\">\tcout &lt;&lt; building-&gt;m_Bedroom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tVisitor v;</span><br><span class=\"line\">\tv.visit();</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"成员函数做友元函数\"><a href=\"#成员函数做友元函数\" class=\"headerlink\" title=\"成员函数做友元函数\"></a>成员函数做友元函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Building;</span><br><span class=\"line\">class Visitor</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Visitor();</span><br><span class=\"line\">    void visit();</span><br><span class=\"line\">    Building *building;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Building &#123;</span><br><span class=\"line\">    friend void Visitor::visit(); &#x2F;&#x2F; 指定Visitor的visit成员函数可以访问私有属性</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Building() &#123;</span><br><span class=\"line\">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    string m_Bedroom;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 为什么这个构造函数要写外面，不能写里面？</span><br><span class=\"line\">&#x2F;&#x2F; 因为Visitor需要在Building上面定义，不然不给定义Visitor上的友元函数，然后因为Visitor内有Building的属性，所以要声明一下class Building; 但是因为只是声明没有实现，所以就不能new Building;了，那就只能把这个通过类外实现的方式写在Building定义的下面。</span><br><span class=\"line\">Visitor::Visitor() &#123;  </span><br><span class=\"line\">    building &#x3D; new Building;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Visitor::visit() &#123;</span><br><span class=\"line\">    cout &lt;&lt; building-&gt;m_Bedroom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Visitor v;</span><br><span class=\"line\">    v.visit();</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运算符重载\"><a href=\"#运算符重载\" class=\"headerlink\" title=\"运算符重载\"></a>运算符重载</h2><p>跟Swift差不多</p>\n<h3 id=\"成员函数的运算符重载\"><a href=\"#成员函数的运算符重载\" class=\"headerlink\" title=\"成员函数的运算符重载\"></a>成员函数的运算符重载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Animal operator + (Animal &amp;a) &#123;</span><br><span class=\"line\">        Animal temp;</span><br><span class=\"line\">        temp.m_A &#x3D; this -&gt; m_A + a.m_A;</span><br><span class=\"line\">        return temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int m_A;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal a;</span><br><span class=\"line\">a.m_A &#x3D; 1;</span><br><span class=\"line\">Animal b;</span><br><span class=\"line\">b.m_A &#x3D; 2;</span><br><span class=\"line\">Animal c &#x3D; a + b;</span><br><span class=\"line\">cout &lt;&lt; c.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 3</span><br></pre></td></tr></table></figure>\n\n<p>本质：<code>Animal c = a.operator+(b);</code></p>\n<h3 id=\"全局函数的运算符重载\"><a href=\"#全局函数的运算符重载\" class=\"headerlink\" title=\"全局函数的运算符重载\"></a>全局函数的运算符重载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal operator - (Animal &amp;a, Animal &amp;b) &#123;</span><br><span class=\"line\">    Animal temp;</span><br><span class=\"line\">    temp.m_A &#x3D; a.m_A - b.m_A;</span><br><span class=\"line\">    return temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal a;</span><br><span class=\"line\">a.m_A &#x3D; 1;</span><br><span class=\"line\">Animal b;</span><br><span class=\"line\">b.m_A &#x3D; 2;</span><br><span class=\"line\">Animal c &#x3D; a - b;</span><br><span class=\"line\">cout &lt;&lt; c.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 -1</span><br></pre></td></tr></table></figure>\n\n<p>本质：<code>Animal c = operator-(a,b);</code></p>\n<h3 id=\"运算符重载也可以发生函数重载\"><a href=\"#运算符重载也可以发生函数重载\" class=\"headerlink\" title=\"运算符重载也可以发生函数重载\"></a>运算符重载也可以发生函数重载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal operator + (int a, Animal &amp;b) &#123;</span><br><span class=\"line\">    Animal temp;</span><br><span class=\"line\">    temp.m_A &#x3D; a + b.m_A;</span><br><span class=\"line\">    return temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal a;</span><br><span class=\"line\">a.m_A &#x3D; 1;</span><br><span class=\"line\">Animal d &#x3D; 10 + a;</span><br><span class=\"line\">cout &lt;&lt; d.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 11</span><br></pre></td></tr></table></figure>\n\n<p>本质：<code>Animal d = operator+(10,a);</code></p>\n<h3 id=\"左移运算符重载（比较常见输出对象细节）\"><a href=\"#左移运算符重载（比较常见输出对象细节）\" class=\"headerlink\" title=\"左移运算符重载（比较常见输出对象细节）\"></a>左移运算符重载（比较常见输出对象细节）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyInteger &#123;</span><br><span class=\"line\">    friend ostream&amp; operator&lt;&lt;(ostream&amp; cout,MyInteger myInt);</span><br><span class=\"line\">public:</span><br><span class=\"line\">    MyInteger() &#123;</span><br><span class=\"line\">        this-&gt;my_int &#x3D; 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    int my_int;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 必须是全局函数重载 ostream是cout的类型，为了能链式调用所以返回引用ostream&amp;</span><br><span class=\"line\">ostream&amp; operator&lt;&lt;(ostream&amp; cout,MyInteger myInt) &#123;</span><br><span class=\"line\">    cout &lt;&lt; myInt.my_int; &#x2F;&#x2F; 返回对象细节</span><br><span class=\"line\">    return cout;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    MyInteger myInt;</span><br><span class=\"line\">    cout &lt;&lt; myInt &lt;&lt; endl; &#x2F;&#x2F; 输出 my_int 的值 0</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关系运算符重载\"><a href=\"#关系运算符重载\" class=\"headerlink\" title=\"关系运算符重载\"></a>关系运算符重载</h3><p>Swift经常使用，参见<code>Equable</code>，<code>Comparable</code>协议</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool operator&#x3D;&#x3D;(Person &amp;p) &#123;</span><br><span class=\"line\">        if (this-&gt;m_Name &#x3D;&#x3D; p.m_Name) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bool operator!&#x3D;(Person &amp;p) &#123;</span><br><span class=\"line\">        if (this-&gt;m_Name !&#x3D; p.m_Name) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\tstring m_Name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tPerson p1; p1.m_Name &#x3D; &quot;A&quot;;</span><br><span class=\"line\">    Person p2; p2.m_Name &#x3D; &quot;A&quot;;</span><br><span class=\"line\">    if (p1 &#x3D;&#x3D; p2) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Equal&quot; &lt;&lt; endl; &#x2F;&#x2F; 输出</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Different&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (p1 !&#x3D; p2) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Different&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Equal&quot; &lt;&lt; endl; &#x2F;&#x2F; 输出</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数调用运算符的重载（骚操作）\"><a href=\"#函数调用运算符的重载（骚操作）\" class=\"headerlink\" title=\"函数调用运算符的重载（骚操作）\"></a>函数调用运算符的重载（骚操作）</h3><p>因为用起来很像函数，所以又叫做仿函数，STL里相当多这种骚操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyInteger &#123;</span><br><span class=\"line\">\tint operator()(int a,int b) &#123;</span><br><span class=\"line\">        return a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; MyInteger() ：匿名对象</span><br><span class=\"line\">    int result &#x3D; MyInteger()(1,2);</span><br><span class=\"line\"></span><br><span class=\"line\">    MyInteger i;</span><br><span class=\"line\">    int result2 &#x3D; i(5,2);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; result &lt;&lt; endl;  &#x2F;&#x2F; 5</span><br><span class=\"line\">    cout &lt;&lt; result2 &lt;&lt; endl; &#x2F;&#x2F; 7</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>C++有多继承，灰常厉害</p>\n<h3 id=\"继承方式\"><a href=\"#继承方式\" class=\"headerlink\" title=\"继承方式\"></a>继承方式</h3><p>三种继承方式<code>public</code>,<code>protected</code>,<code>private</code>，决定着继承下来的属性和方法以什么形式修饰，<code>class</code>默认<code>private</code>,<code>struct</code>默认<code>public</code>（没错，C++中结构体可以被继承）<br>父类的所有非静态属性会被继承，包括<code>private</code>类型的，但是<code>private</code>类型的默认隐藏，子类无法访问。</p>\n<p>继承语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class SubClass : public SuperClass &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构造和析构\"><a href=\"#构造和析构\" class=\"headerlink\" title=\"构造和析构\"></a>构造和析构</h3><p>父类先构造，子类先析构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">superClass()</span><br><span class=\"line\">subClass()</span><br><span class=\"line\">~subClass()</span><br><span class=\"line\">~superClass()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"同名属性-函数-静态属性-静态函数的访问\"><a href=\"#同名属性-函数-静态属性-静态函数的访问\" class=\"headerlink\" title=\"同名属性/函数/静态属性/静态函数的访问\"></a>同名属性/函数/静态属性/静态函数的访问</h3><p>假如子类和父类拥有相同的名字的属性/函数/静态属性/静态函数，则直接调用子类对象的话都是访问子类的，如果要访问父类的话要添加作用域。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int _a &#x3D; 1;</span><br><span class=\"line\">    static int _b;</span><br><span class=\"line\">    static void staticFunc() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Base staticFunc()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void Func() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Base Func()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int Base::_b &#x3D; 10; &#x2F;&#x2F; 静态成员变量要在外面赋值</span><br><span class=\"line\"></span><br><span class=\"line\">class Sub1 : public Base &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int _a &#x3D; 2;</span><br><span class=\"line\">    static int _b;</span><br><span class=\"line\">    static void staticFunc() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;SubClass staticFunc()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void Func() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;SucClass Func()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int Sub1::_b &#x3D; 20;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Sub1 s;</span><br><span class=\"line\">    &#x2F;&#x2F; 直接调用</span><br><span class=\"line\">    cout &lt;&lt; s._a &lt;&lt; endl;</span><br><span class=\"line\">    &#x2F;&#x2F; 调用父类的</span><br><span class=\"line\">    cout &lt;&lt; s.Base::_a &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 静态直接调用</span><br><span class=\"line\">    cout &lt;&lt; s._b &lt;&lt; endl;</span><br><span class=\"line\">    &#x2F;&#x2F; 静态调用父类的</span><br><span class=\"line\">    cout &lt;&lt; s.Base::_b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 静态直接调用</span><br><span class=\"line\">    cout &lt;&lt; Sub1::_b &lt;&lt; endl;</span><br><span class=\"line\">    &#x2F;&#x2F; 静态调用父类的</span><br><span class=\"line\">    cout &lt;&lt; Sub1::Base::_b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 直接调用</span><br><span class=\"line\">    s.Func();</span><br><span class=\"line\">    &#x2F;&#x2F; 调用父类的</span><br><span class=\"line\">    s.Base::Func();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 静态直接调用</span><br><span class=\"line\">    s.staticFunc();</span><br><span class=\"line\">    &#x2F;&#x2F; 静态调用父类的</span><br><span class=\"line\">    s.Base::staticFunc();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 静态直接调用</span><br><span class=\"line\">    Sub1::staticFunc();</span><br><span class=\"line\">    &#x2F;&#x2F; 静态调用父类的</span><br><span class=\"line\">    Sub1::Base::staticFunc();</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h3><p>不建议使用，因为麻烦事多</p>\n<p>语法：(参照上面的代码)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Other &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void Func() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Ohter Func()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#x2F;&#x2F;...略</span><br><span class=\"line\">class Sub1 : public Base , public Other &#123;</span><br><span class=\"line\">&#x2F;&#x2F;...略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当多个父类中出现同名属性/方法时，需要加作用域指定父类<code>s.Base::Func(); / s.Other::Func();</code></p>\n<h3 id=\"菱形继承（钻石继承）\"><a href=\"#菱形继承（钻石继承）\" class=\"headerlink\" title=\"菱形继承（钻石继承）\"></a>菱形继承（钻石继承）</h3><p>两个子类继承同一个基类，<br>又有某个类同时继承着两个子类</p>\n<p>举例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base &#123; int age &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Sub1: public Base &#123;&#125;;</span><br><span class=\"line\">class Sub2: public Base &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class SubSub: public Sub1, public Sub2 &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这时候SubSub会有两个父类，有两份 age 属性，造成资源浪费</p>\n<p>这时候用虚继承(<code>virtual</code>)解决问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base &#123; public: int age &#125;; &#x2F;&#x2F; 这时候成为虚基类</span><br><span class=\"line\"></span><br><span class=\"line\">class Sub1: virtual public Base &#123;&#125;;</span><br><span class=\"line\">class Sub2: virtual public Base &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class SubSub: public Sub1, public Sub2 &#123;&#125;;</span><br></pre></td></tr></table></figure>\n<p>这时候age属性成为共享属性，最后谁改了就是谁的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SubSub s;</span><br><span class=\"line\">s.Sub1::age &#x3D; 1;</span><br><span class=\"line\">s.Sub2::age &#x3D; 10;</span><br><span class=\"line\">cout &lt;&lt; s.Sub1::age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br><span class=\"line\">cout &lt;&lt; s.Sub2::age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br><span class=\"line\">cout &lt;&lt; s.age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p>C++中，多态分两类</p>\n<p>静态多态：函数重载和运算符重载属于静态多态，复用函数名<br>动态多态：子类和虚函数实现运行时多态</p>\n<p>区别：</p>\n<p>静态多态的函数地址早绑定，编译阶段确定函数地址<br>动态多态的函数地址晚绑定，运行阶段确定函数地址</p>\n<p>动态多态满足条件：</p>\n<ol>\n<li>有继承关系</li>\n<li>子类重写父类虚函数</li>\n</ol>\n<p>动态多态使用<br>父类的指针或者引用指向子类对象</p>\n<p>静态多态举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void speak() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Animal Speak&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Cat: public Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void speak() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Cat Speak&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">void SomeoneSpeak(Animal &amp;animal) &#123;</span><br><span class=\"line\">    animal.speak();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Cat c;</span><br><span class=\"line\">    SomeoneSpeak(c); &#x2F;&#x2F; 由于SomeoneSpeak(Animal &amp;animal)，编译期间已经确定入参类型，所以输出 Animal Speak</span><br></pre></td></tr></table></figure>\n\n<p>如果想输出<code>Cat Speak</code>，只需进行如下修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    virtual void speak() &#123; &#x2F;&#x2F; 虚函数，可以告知由于SomeoneSpeak(Animal &amp;animal)运行时再确定入参类型</span><br><span class=\"line\">        cout &lt;&lt; &quot;Animal Speak&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>经常地，这种情况下也是动态多态，最后会输出<code>Cat Speak</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal *a &#x3D; new Cat;</span><br><span class=\"line\">a-&gt;speak();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"纯虚函数和抽象类\"><a href=\"#纯虚函数和抽象类\" class=\"headerlink\" title=\"纯虚函数和抽象类\"></a>纯虚函数和抽象类</h3><p>父类的虚函数的实现没什么意义，所以上面的虚函数代码改写为<code>纯虚函数</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">virtual void speak() &#x3D; 0;</span><br></pre></td></tr></table></figure>\n\n<p>当类中有了纯虚函数，则这个类称为<code>抽象类</code></p>\n<p>抽象类<strong>无法实例化对象</strong>，并且<strong>子类必须重写父类的纯虚函数</strong>，否则也成为<code>抽象类</code></p>\n<h3 id=\"虚析构和纯虚析构\"><a href=\"#虚析构和纯虚析构\" class=\"headerlink\" title=\"虚析构和纯虚析构\"></a>虚析构和纯虚析构</h3><p>当子类在堆区创建数据的时候，需要手动释放，父类需要添加虚析构或者纯虚析构函数，否则子类可能不走析构函数</p>\n<p>比如上面的<code>Animate</code>父类，我们补充一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    virtual ~Animal() &#x3D; 0; &#x2F;&#x2F; 纯虚析构</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal::~Animal() &#123; &#x2F;&#x2F; 析构实现</span><br><span class=\"line\">    cout &lt;&lt; &quot;Animal is Delete&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><p>文件打开方式</p>\n<p><code>ios::in</code>:读文件<br><code>ios::out</code>:写文件<br><code>ios::ate</code>:初始位置，文件尾<br><code>ios:app</code>:追加写文件<br><code>ios:trunc</code>:如果文件存在先删除，再创建<br><code>ios:binary</code>:二进制方式</p>\n<p>同时两种方式则使用<code>|</code>的方式，比如<code>ios::in|ios:binary</code></p>\n<h3 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ofstream stream;</span><br><span class=\"line\"></span><br><span class=\"line\">stream.open(&quot;Test.txt&quot;,ios::out);</span><br><span class=\"line\"></span><br><span class=\"line\">stream &lt;&lt; &quot;Line 1&quot; &lt;&lt; endl;</span><br><span class=\"line\">stream &lt;&lt; &quot;Line 2&quot; &lt;&lt; endl;</span><br><span class=\"line\">stream &lt;&lt; &quot;Line 3&quot; &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">stream.close();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifstream ifs;</span><br><span class=\"line\">ifs.open(&quot;Test.txt&quot;,ios::out);</span><br><span class=\"line\"></span><br><span class=\"line\">if(!ifs.is_open()) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;打开文件失败&quot; &lt;&lt; endl;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">string buf;</span><br><span class=\"line\">while (getline(ifs, buf)) &#123; &#x2F;&#x2F; 一行行读取</span><br><span class=\"line\">\tcout &lt;&lt; buf &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ifs.close();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h2><h3 id=\"构建类模板与类模板做参数\"><a href=\"#构建类模板与类模板做参数\" class=\"headerlink\" title=\"构建类模板与类模板做参数\"></a>构建类模板与类模板做参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class NameType,class AgeType&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Person(NameType name, AgeType age) &#123;</span><br><span class=\"line\">        this-&gt;_age &#x3D; age;</span><br><span class=\"line\">        this-&gt;_name &#x3D; name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    AgeType _age;</span><br><span class=\"line\">    NameType _name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 不会自动类型推导，需要自己显式声明类型</span><br><span class=\"line\">    Person&lt;string,int&gt; p(&quot;Haha&quot;,123);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; p._name &lt;&lt; &quot; &quot; &lt;&lt; p._age &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可以给类模板添加默认类型</p>\n<p><code>template&lt;class NameType,class AgeType = int&gt;</code></p>\n<p>这样子调用的时候就可以不全声明类型了</p>\n<p><code>Person&lt;string&gt; p(&quot;Haha&quot;,123);</code></p>\n<p>类模板做参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 指定类型的类模板做参数</span><br><span class=\"line\">void print(Person&lt;string,int&gt; &amp;p) &#123;</span><br><span class=\"line\">    p.showPerson();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 模板化参数的类模板做参数</span><br><span class=\"line\">template&lt;class T1,class T2&gt;</span><br><span class=\"line\">void print2(Person&lt;T1, T2&gt; &amp;p) &#123;</span><br><span class=\"line\">    p.showPerson();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 模板化类做参数</span><br><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">void print3(T &amp;p) &#123;</span><br><span class=\"line\">    p.showPerson();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Person&lt;string,int&gt; p(&quot;Haha&quot;,123);</span><br><span class=\"line\">    print(p);</span><br><span class=\"line\">    print2(p);</span><br><span class=\"line\">    print3(p);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类模板与继承\"><a href=\"#类模板与继承\" class=\"headerlink\" title=\"类模板与继承\"></a>类模板与继承</h3><p>继承时需要指定类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">class Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    T m;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class SubClass: public Base&lt;int&gt; &#123; &#x2F;&#x2F; 指定T的类型</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void print() &#123;</span><br><span class=\"line\">        cout &lt;&lt; m &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果不想指定类型，那么可以模板化子类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">class Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    T m;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;class T1,class T2&gt;</span><br><span class=\"line\">class SubClass: public Base&lt;T1&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    SubClass(T1 a, T2 b) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    T2 k;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tSubClass&lt;string, int&gt; c(&quot;String&quot;,1);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"STL-之-Vector容器\"><a href=\"#STL-之-Vector容器\" class=\"headerlink\" title=\"STL 之 Vector容器\"></a>STL 之 Vector容器</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int&gt; v1; &#x2F;&#x2F; 初始化指定容器内元素类型</span><br><span class=\"line\">v1.assign(10, 1); &#x2F;&#x2F; 插入10个1，也可以传入其他vector,比如v1.assign(v0.begin,v0.end); 或者直接 v1 &#x3D; v0; 只要保证是同种类型就好</span><br><span class=\"line\">for (vector&lt;int&gt;::iterator i &#x3D; v1.begin(); i !&#x3D; v1.end() ; i++) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; *i &lt;&lt; endl;</span><br><span class=\"line\">&#125; &#x2F;&#x2F; 打印10个1</span><br><span class=\"line\">cout &lt;&lt; &quot;Size &#x3D; &quot; &lt;&lt; v1.size() &lt;&lt; endl; &#x2F;&#x2F; 长度 10</span><br><span class=\"line\">cout &lt;&lt; &quot;isEmpty &#x3D; &quot; &lt;&lt; v1.empty() &lt;&lt; endl; &#x2F;&#x2F; 判空 0</span><br><span class=\"line\">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 容量 10</span><br><span class=\"line\">v1.resize(20,20); &#x2F;&#x2F; 调整容量为20，多出来的位置用20填充，这里的20可以不传，默认0</span><br><span class=\"line\">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 现在容量变成20</span><br><span class=\"line\"></span><br><span class=\"line\">v1.pop_back(); &#x2F;&#x2F; 删除最后一个元素</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; &quot;Size &#x3D; &quot; &lt;&lt; v1.size() &lt;&lt; endl; &#x2F;&#x2F; 长度 19</span><br><span class=\"line\">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 容量不变 20</span><br><span class=\"line\"></span><br><span class=\"line\">v1.insert(v1.begin() + 1, 199); &#x2F;&#x2F; 下标为1的位置插入元素199</span><br><span class=\"line\">v1.insert(v1.begin() + 1, 2, 199); &#x2F;&#x2F; 下标为1的位置插入两个元素199</span><br><span class=\"line\">v1.erase(v1.begin() + 2); &#x2F;&#x2F; 删除第二个元素</span><br><span class=\"line\">v1.erase(v1.begin() + 2 , v1.begin() + 3); &#x2F;&#x2F; 删除第二个到第三个元素</span><br><span class=\"line\">v1.clear(); &#x2F;&#x2F; 清空容器</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; &quot;第二个元素是&quot; &lt;&lt; v1.at(1) &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; &quot;第三个元素是&quot; &lt;&lt; v1[2] &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; &quot;第一个元素&quot; &lt;&lt; v1.front() &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; &quot;最后一个元素&quot; &lt;&lt; v1.back() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">v1.reverse(100000); &#x2F;&#x2F; 预留空间，减少以后动态拓展的次数</span><br><span class=\"line\"></span><br><span class=\"line\">v1.swap(v0); &#x2F;&#x2F; 交换元素，假如v1的预留空间很大，可以通过交换一个小预留空间的容器达到压缩内存的效果</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"AppDelegate事件分发","abbrlink":"7e5c9fa9","date":"2020-03-22T03:27:11.000Z","_content":"## 引言\n\n当App发展庞大的时候，势必会导致AppDelegate类的庞大，所以如何去优化AppDelegate成为组件化工作中的主要部分之一。\n\n<!--more-->\n\n## 现状\n\n举个例子，比如App中拥有\n1. 用户管理组件\n2. 首页组件\n3. 消息组件\n\n那么他们分别需要在`- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions`中实现\n\n1. 访问接口更新用户信息\n2. 配置首页弹窗\n3. 访问接口获取用户未读消息数\n\n假设这三个事件之间无关联，只是在初始化自己的模块后做准备工作，但是同时他们堆叠在同一个方法内，必然会导致方法臃肿。设想另外一个场景，假如开发者A只负责维护AppDelegate及主工程项目，开发者B只负责维护用户管理组件，那么开发者B要在App初始化的时候，再加入一个`将用户信息传到大数据中心统计`的功能，那么由于他不拥有`AppDelegate`的修改权限，只能让A排期去协助工作，同理可得，当组件变多，团队庞大的时候，开发者A将会有很多协助工作要做，这就是这次要讨论的问题。\n\n## 想法\n\n是否可以将组件的初始化安排到组件内部中，而不在AppDelegate类中直接进行维护呢？\n\n想法1. 组件新增一个类，然后在该类里面进行初始化。AppDelegate import 这个类，调用这个类中的方法。\n\n缺点：AppDelegate需要耦合该组件，如果要去掉该组件或者新增别的组件，AppDelegate需要增加维护成本。\n\n想法2. AppDelegate主动分发事件，用通知的形式分发给每个组件消息。\n\n缺点：由于组件无法依赖主工程，所以通知名无法维护，另外通知会分发到不需要在AppDelgate初始化的组件，属于通知滥用。\n\n想法3. AppDelegate主动分发事件，组件新增一个类，将AppDelegate事件通过协议的方式分发到这个类中，类遵循该协议。\n\n缺点：技术上不可行，无法得知哪些类实现了协议。\n\n想法4. 组件新增一个类，在`+ (void)load`中将类名注册进入管理类，AppDelegate执行的时候取出所有类名，进行实例化和事件分发。\n\n缺点：在`+ (void)load`中进行工作会增加App启动耗时\n\n想法5. 组件新增一个类，在主工程维护一个plist，将类名写进该plist，AppDelegate执行的时候取出所有类名，进行实例化和事件分发。\n\n缺点：plist在主工程，同样无法满足无缝对接的需求，A同事仍然需要对接维护。\n\n## 解决方案\n\n目前能得出的最优解决方案：\n\n将类名注入mach-o文件中，在编译期写入，在AppDelegate事件分发的时候取出并实例化，不占用App启动耗时，也不用维护多一个plist文件。\n\n## 试验\n\n1. 新建 MacOS - Command Line Tool 项目，命名为`TestC`\n2. 加入我们想注入字符串`ModuleAModule`,将其存储在名为`TestModes`的section内，那么在main.m中写如下代码：\n\n\t```\n\tchar * kModuleAModule_mod __attribute((used, section(\"__DATA, \"\"TestModes\"\" \"))) = \"\"\"ModuleAModule\"\"\";\n\n\tint main(int argc, const char * argv[]) {\n\t\t// insert code here...\n\t\tprintf(\"Hello, World!\\n\");\n\t\treturn 0;\n\t}\n\n\t```\n3. 输出这个mach-o文件的所有segment和section`otool -l TestC`\n\t\n\t部分结果：\n\n\t```\n\tSection\n\t  sectname TestModes\n\t   segname __DATA\n\t\t  addr 0x0000000100002008\n\t\t  size 0x0000000000000008\n\t\toffset 8200\n\t\t align 2^3 (8)\n\t\treloff 0\n\t\tnreloc 0\n\t\t flags 0x00000000\n\t reserved1 0\n\t reserved2 0\n\t```\n\t\n\t看到了`Test Modes`了，继续看一下section的内容`otool -s __DATA TestModes TestC`\n\t\n\t结果\n\t\n\t```\n\tTestC:\nContents of (__DATA,TestModes) section\n0000000100002008\t92 0f 00 00 01 00 00 00 \n\t```\n\t发现`0000000100002008`这个地址可能是我们要的东西，再看看这个地址里有啥\n\t`otool -V -s __TEXT __cstring TestC `打印所有字符串数据内容\n\t看到了\n\t\n\t```\n\tContents of (__TEXT,__cstring) section\n\t\t0000000100000f92  ModuleAModule\n\t\t0000000100000fa0  Hello, World!\\n\n\t```\n\t找到了我们想注入的类名`ModuleAModule`\n\t这样，类名就被存储在mach-o文件的section中了。\n\t\n4. 取出类名， 代码如下\n\n\t```objectivec\n\tNSArray<NSString *>* readConfiguration(char *sectionName,const struct mach_header *mhp)\n\t{\n\t\tNSMutableArray *configs = [NSMutableArray array];\n\t\tunsigned long size = 0;\n\t#ifndef __LP64__\n\t\tuintptr_t *memory = (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &size);\n\t#else\n\t\tconst struct mach_header_64 *mhp64 = (const struct mach_header_64 *)mhp;\n\t\tuintptr_t *memory = (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &size);\n\t#endif\n\n\t\tunsigned long counter = size/sizeof(void*);\n\t\tfor(int idx = 0; idx < counter; ++idx){\n\t\t\tchar *string = (char*)memory[idx];\n\t\t\tNSString *str = [NSString stringWithUTF8String:string];\n\t\t\tif(!str)continue;\n\t\t\tif(str) [configs addObject:str];\n\t\t}\n\n\t\treturn configs;\n\t}\n\t\n\tstatic void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide)\n\t{\n\t\tNSArray *mods = readConfiguration(\"TestModes\", mhp);\n\t\tfor (NSString *modName in mods) {\n\t\t\tif (modName) {\n\t\t\t\tNSLog(@\"取得：%@\",modName);\n\t\t\t}\n\t\t}\n\t}\n\n\t__attribute__((constructor))\n\tvoid initProphet() {\n\t\t_dyld_register_func_for_add_image(dyld_callback);\n\t}\n\t```\n\t\n\t当一个函数被`__attribute__((constructor))`修饰时，表示这个函数是这个镜像的初始化函数，在镜像被加载时，首先会调用这个函数。（镜像指的是mach-o和动态共享库，在工程运行时，可以使用lldb命令`image list`查看这个工程中加载的所有镜像。）\n上述代码表示`initProphet`函数被指定为mach-o的初始化函数，当dyld（动态链接器）加载mach-o时，执行`initProphet`函数，其执行时机在main函数和类的load方法之前。\n\n\t当`_dyld_register_func_for_add_image(dyld_callback);`被执行时，如果已经加载了镜像，则每存在一个已经加载的镜像就执行一次`dyld_callback`函数，在此之后，每当有一个新的镜像被加载时，也会执行一次`dyld_callback`函数。\n（`dyld_callback`函数在镜像的初始化函数之前被调用，mach-o是第一个被加载的镜像，调用顺序是：`load mach-o -> initProphet -> dyld_callback -> load other_image -> dyld_callback -> other_image_initializers -> ......`）\n\n\t所以，当程序启动时，会多次调用dyld_callback函数。\n\t在dyld_callback函数中，使用下列函数来获取[步骤2]中存储的类名\n\t```\n\textern uint8_t *getsectiondata(\n    const struct mach_header_64 *mhp,\n    const char *segname,\n    const char *sectname,\n    unsigned long *size);\n\t```\n\tsegname的值为`__DATA`，sectname的值为`TestMods`\n\t\n## 封装组件\n\n有了上面的指导思想，那么我们就可以封装组件了，具体内容见[ALComponentManager](https://github.com/Arc-lin/ALComponentManager)\n\n### 使用方法\n\n#### AppDelegate继承自ALAppDelegate\n\n只需要在实现`UIApplicationDelegate`的方法内部调用super方法即可，如\n\n```objectivec\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n    [super application:application didFinishLaunchingWithOptions:launchOptions];\n    \n    return YES;\n}\n\n- (void)applicationWillResignActive:(UIApplication *)application\n{\n    [super applicationWillResignActive:application];\n}\n\n```\n\n#### AppDelegate继承自UIResponder\n\n在AppDelegate的各个方法做分发埋点，触发到埋点后事件会分发到各个组件类里面\n\t\n如\n```objectivec\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions;\n```\n埋点如下\n```objectivec\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n  {\n      [[ALComponentManager sharedManager] triggerEvent:ALSetupEvent];\n      [[ALComponentManager sharedManager] triggerEvent:ALInitEvent];\n\n      dispatch_async(dispatch_get_main_queue(), ^{\n          [[ALComponentManager sharedManager] triggerEvent:ALSplashEvent];\n      });\n  #if __IPHONE_OS_VERSION_MAX_ALLOWED >= 100000\n      if ([UIDevice currentDevice].systemVersion.floatValue >= 10.0f) {\n          [UNUserNotificationCenter currentNotificationCenter].delegate = self;\n      }\n  #endif\n      return YES;\n  }\n  ```\n\t\n其他埋点见组件Demo\n\t\n#### 给每个组件创建组件管理类\n\n1. 给每个组件创建一个类并写上注解，如`ALComponentA.m`\n\n\t```objectivec\n\t@ALMod(ALComponentA);\n\t@interface ALComponentA()<ALComponentProtocol>\n\n\t@end\n\n\t@implementation ALComponentA\n\n\t@end\n\t```\n\t\n2. 实现协议`ALComponentProtocol`和需要的协议方法。\n\t这个协议里面蕴含了基本所有的`AppDelegate`方法，当然要触发这些方法都是要预先在AppDelegate写上埋点。\n\t\n\t```objectivec\n\t@implementation ALComponentA\n\n\t+ (void)load\n\t{\n\t\tNSLog(@\"Component A Load\");    \n\t}\n\n\t- (instancetype)init\n\t{\n\t\tif (self = [super init]) {\n\t\t\tNSLog(@\"ComponentA Init\");\n\t\t}\n\t\treturn self;\n\t}\n\n\t- (void)modSetUp:(ALContext *)context\n\t{\n\t\tNSLog(@\"ComponentA setup\");\n\t}\n\n\t@end\n\t```\n\t\n3. 接下来你就可以尝试使用了。\n\n## 疑问\n\n要是组件间的初始化互相依赖怎么办？\n\n还能怎么办，已经违背了组件隔离的原则，就只能按原来的方法处理了。\n\n## 参考\n\n[BeeHive](https://github.com/alibaba/BeeHive)","source":"_posts/AppDelegate事件分发.md","raw":"title: AppDelegate事件分发\ntags:\n  - iOS\n  - 架构\ncategories:\n  - iOS\nabbrlink: 7e5c9fa9\ndate: 2020-03-22 11:27:11\n---\n## 引言\n\n当App发展庞大的时候，势必会导致AppDelegate类的庞大，所以如何去优化AppDelegate成为组件化工作中的主要部分之一。\n\n<!--more-->\n\n## 现状\n\n举个例子，比如App中拥有\n1. 用户管理组件\n2. 首页组件\n3. 消息组件\n\n那么他们分别需要在`- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions`中实现\n\n1. 访问接口更新用户信息\n2. 配置首页弹窗\n3. 访问接口获取用户未读消息数\n\n假设这三个事件之间无关联，只是在初始化自己的模块后做准备工作，但是同时他们堆叠在同一个方法内，必然会导致方法臃肿。设想另外一个场景，假如开发者A只负责维护AppDelegate及主工程项目，开发者B只负责维护用户管理组件，那么开发者B要在App初始化的时候，再加入一个`将用户信息传到大数据中心统计`的功能，那么由于他不拥有`AppDelegate`的修改权限，只能让A排期去协助工作，同理可得，当组件变多，团队庞大的时候，开发者A将会有很多协助工作要做，这就是这次要讨论的问题。\n\n## 想法\n\n是否可以将组件的初始化安排到组件内部中，而不在AppDelegate类中直接进行维护呢？\n\n想法1. 组件新增一个类，然后在该类里面进行初始化。AppDelegate import 这个类，调用这个类中的方法。\n\n缺点：AppDelegate需要耦合该组件，如果要去掉该组件或者新增别的组件，AppDelegate需要增加维护成本。\n\n想法2. AppDelegate主动分发事件，用通知的形式分发给每个组件消息。\n\n缺点：由于组件无法依赖主工程，所以通知名无法维护，另外通知会分发到不需要在AppDelgate初始化的组件，属于通知滥用。\n\n想法3. AppDelegate主动分发事件，组件新增一个类，将AppDelegate事件通过协议的方式分发到这个类中，类遵循该协议。\n\n缺点：技术上不可行，无法得知哪些类实现了协议。\n\n想法4. 组件新增一个类，在`+ (void)load`中将类名注册进入管理类，AppDelegate执行的时候取出所有类名，进行实例化和事件分发。\n\n缺点：在`+ (void)load`中进行工作会增加App启动耗时\n\n想法5. 组件新增一个类，在主工程维护一个plist，将类名写进该plist，AppDelegate执行的时候取出所有类名，进行实例化和事件分发。\n\n缺点：plist在主工程，同样无法满足无缝对接的需求，A同事仍然需要对接维护。\n\n## 解决方案\n\n目前能得出的最优解决方案：\n\n将类名注入mach-o文件中，在编译期写入，在AppDelegate事件分发的时候取出并实例化，不占用App启动耗时，也不用维护多一个plist文件。\n\n## 试验\n\n1. 新建 MacOS - Command Line Tool 项目，命名为`TestC`\n2. 加入我们想注入字符串`ModuleAModule`,将其存储在名为`TestModes`的section内，那么在main.m中写如下代码：\n\n\t```\n\tchar * kModuleAModule_mod __attribute((used, section(\"__DATA, \"\"TestModes\"\" \"))) = \"\"\"ModuleAModule\"\"\";\n\n\tint main(int argc, const char * argv[]) {\n\t\t// insert code here...\n\t\tprintf(\"Hello, World!\\n\");\n\t\treturn 0;\n\t}\n\n\t```\n3. 输出这个mach-o文件的所有segment和section`otool -l TestC`\n\t\n\t部分结果：\n\n\t```\n\tSection\n\t  sectname TestModes\n\t   segname __DATA\n\t\t  addr 0x0000000100002008\n\t\t  size 0x0000000000000008\n\t\toffset 8200\n\t\t align 2^3 (8)\n\t\treloff 0\n\t\tnreloc 0\n\t\t flags 0x00000000\n\t reserved1 0\n\t reserved2 0\n\t```\n\t\n\t看到了`Test Modes`了，继续看一下section的内容`otool -s __DATA TestModes TestC`\n\t\n\t结果\n\t\n\t```\n\tTestC:\nContents of (__DATA,TestModes) section\n0000000100002008\t92 0f 00 00 01 00 00 00 \n\t```\n\t发现`0000000100002008`这个地址可能是我们要的东西，再看看这个地址里有啥\n\t`otool -V -s __TEXT __cstring TestC `打印所有字符串数据内容\n\t看到了\n\t\n\t```\n\tContents of (__TEXT,__cstring) section\n\t\t0000000100000f92  ModuleAModule\n\t\t0000000100000fa0  Hello, World!\\n\n\t```\n\t找到了我们想注入的类名`ModuleAModule`\n\t这样，类名就被存储在mach-o文件的section中了。\n\t\n4. 取出类名， 代码如下\n\n\t```objectivec\n\tNSArray<NSString *>* readConfiguration(char *sectionName,const struct mach_header *mhp)\n\t{\n\t\tNSMutableArray *configs = [NSMutableArray array];\n\t\tunsigned long size = 0;\n\t#ifndef __LP64__\n\t\tuintptr_t *memory = (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &size);\n\t#else\n\t\tconst struct mach_header_64 *mhp64 = (const struct mach_header_64 *)mhp;\n\t\tuintptr_t *memory = (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &size);\n\t#endif\n\n\t\tunsigned long counter = size/sizeof(void*);\n\t\tfor(int idx = 0; idx < counter; ++idx){\n\t\t\tchar *string = (char*)memory[idx];\n\t\t\tNSString *str = [NSString stringWithUTF8String:string];\n\t\t\tif(!str)continue;\n\t\t\tif(str) [configs addObject:str];\n\t\t}\n\n\t\treturn configs;\n\t}\n\t\n\tstatic void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide)\n\t{\n\t\tNSArray *mods = readConfiguration(\"TestModes\", mhp);\n\t\tfor (NSString *modName in mods) {\n\t\t\tif (modName) {\n\t\t\t\tNSLog(@\"取得：%@\",modName);\n\t\t\t}\n\t\t}\n\t}\n\n\t__attribute__((constructor))\n\tvoid initProphet() {\n\t\t_dyld_register_func_for_add_image(dyld_callback);\n\t}\n\t```\n\t\n\t当一个函数被`__attribute__((constructor))`修饰时，表示这个函数是这个镜像的初始化函数，在镜像被加载时，首先会调用这个函数。（镜像指的是mach-o和动态共享库，在工程运行时，可以使用lldb命令`image list`查看这个工程中加载的所有镜像。）\n上述代码表示`initProphet`函数被指定为mach-o的初始化函数，当dyld（动态链接器）加载mach-o时，执行`initProphet`函数，其执行时机在main函数和类的load方法之前。\n\n\t当`_dyld_register_func_for_add_image(dyld_callback);`被执行时，如果已经加载了镜像，则每存在一个已经加载的镜像就执行一次`dyld_callback`函数，在此之后，每当有一个新的镜像被加载时，也会执行一次`dyld_callback`函数。\n（`dyld_callback`函数在镜像的初始化函数之前被调用，mach-o是第一个被加载的镜像，调用顺序是：`load mach-o -> initProphet -> dyld_callback -> load other_image -> dyld_callback -> other_image_initializers -> ......`）\n\n\t所以，当程序启动时，会多次调用dyld_callback函数。\n\t在dyld_callback函数中，使用下列函数来获取[步骤2]中存储的类名\n\t```\n\textern uint8_t *getsectiondata(\n    const struct mach_header_64 *mhp,\n    const char *segname,\n    const char *sectname,\n    unsigned long *size);\n\t```\n\tsegname的值为`__DATA`，sectname的值为`TestMods`\n\t\n## 封装组件\n\n有了上面的指导思想，那么我们就可以封装组件了，具体内容见[ALComponentManager](https://github.com/Arc-lin/ALComponentManager)\n\n### 使用方法\n\n#### AppDelegate继承自ALAppDelegate\n\n只需要在实现`UIApplicationDelegate`的方法内部调用super方法即可，如\n\n```objectivec\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n    [super application:application didFinishLaunchingWithOptions:launchOptions];\n    \n    return YES;\n}\n\n- (void)applicationWillResignActive:(UIApplication *)application\n{\n    [super applicationWillResignActive:application];\n}\n\n```\n\n#### AppDelegate继承自UIResponder\n\n在AppDelegate的各个方法做分发埋点，触发到埋点后事件会分发到各个组件类里面\n\t\n如\n```objectivec\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions;\n```\n埋点如下\n```objectivec\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n  {\n      [[ALComponentManager sharedManager] triggerEvent:ALSetupEvent];\n      [[ALComponentManager sharedManager] triggerEvent:ALInitEvent];\n\n      dispatch_async(dispatch_get_main_queue(), ^{\n          [[ALComponentManager sharedManager] triggerEvent:ALSplashEvent];\n      });\n  #if __IPHONE_OS_VERSION_MAX_ALLOWED >= 100000\n      if ([UIDevice currentDevice].systemVersion.floatValue >= 10.0f) {\n          [UNUserNotificationCenter currentNotificationCenter].delegate = self;\n      }\n  #endif\n      return YES;\n  }\n  ```\n\t\n其他埋点见组件Demo\n\t\n#### 给每个组件创建组件管理类\n\n1. 给每个组件创建一个类并写上注解，如`ALComponentA.m`\n\n\t```objectivec\n\t@ALMod(ALComponentA);\n\t@interface ALComponentA()<ALComponentProtocol>\n\n\t@end\n\n\t@implementation ALComponentA\n\n\t@end\n\t```\n\t\n2. 实现协议`ALComponentProtocol`和需要的协议方法。\n\t这个协议里面蕴含了基本所有的`AppDelegate`方法，当然要触发这些方法都是要预先在AppDelegate写上埋点。\n\t\n\t```objectivec\n\t@implementation ALComponentA\n\n\t+ (void)load\n\t{\n\t\tNSLog(@\"Component A Load\");    \n\t}\n\n\t- (instancetype)init\n\t{\n\t\tif (self = [super init]) {\n\t\t\tNSLog(@\"ComponentA Init\");\n\t\t}\n\t\treturn self;\n\t}\n\n\t- (void)modSetUp:(ALContext *)context\n\t{\n\t\tNSLog(@\"ComponentA setup\");\n\t}\n\n\t@end\n\t```\n\t\n3. 接下来你就可以尝试使用了。\n\n## 疑问\n\n要是组件间的初始化互相依赖怎么办？\n\n还能怎么办，已经违背了组件隔离的原则，就只能按原来的方法处理了。\n\n## 参考\n\n[BeeHive](https://github.com/alibaba/BeeHive)","slug":"AppDelegate事件分发","published":1,"updated":"2021-08-25T16:05:06.350Z","_id":"ckqqxyogq000dtnn0c0ktgjqv","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>当App发展庞大的时候，势必会导致AppDelegate类的庞大，所以如何去优化AppDelegate成为组件化工作中的主要部分之一。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h2><p>举个例子，比如App中拥有</p>\n<ol>\n<li>用户管理组件</li>\n<li>首页组件</li>\n<li>消息组件</li>\n</ol>\n<p>那么他们分别需要在<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>中实现</p>\n<ol>\n<li>访问接口更新用户信息</li>\n<li>配置首页弹窗</li>\n<li>访问接口获取用户未读消息数</li>\n</ol>\n<p>假设这三个事件之间无关联，只是在初始化自己的模块后做准备工作，但是同时他们堆叠在同一个方法内，必然会导致方法臃肿。设想另外一个场景，假如开发者A只负责维护AppDelegate及主工程项目，开发者B只负责维护用户管理组件，那么开发者B要在App初始化的时候，再加入一个<code>将用户信息传到大数据中心统计</code>的功能，那么由于他不拥有<code>AppDelegate</code>的修改权限，只能让A排期去协助工作，同理可得，当组件变多，团队庞大的时候，开发者A将会有很多协助工作要做，这就是这次要讨论的问题。</p>\n<h2 id=\"想法\"><a href=\"#想法\" class=\"headerlink\" title=\"想法\"></a>想法</h2><p>是否可以将组件的初始化安排到组件内部中，而不在AppDelegate类中直接进行维护呢？</p>\n<p>想法1. 组件新增一个类，然后在该类里面进行初始化。AppDelegate import 这个类，调用这个类中的方法。</p>\n<p>缺点：AppDelegate需要耦合该组件，如果要去掉该组件或者新增别的组件，AppDelegate需要增加维护成本。</p>\n<p>想法2. AppDelegate主动分发事件，用通知的形式分发给每个组件消息。</p>\n<p>缺点：由于组件无法依赖主工程，所以通知名无法维护，另外通知会分发到不需要在AppDelgate初始化的组件，属于通知滥用。</p>\n<p>想法3. AppDelegate主动分发事件，组件新增一个类，将AppDelegate事件通过协议的方式分发到这个类中，类遵循该协议。</p>\n<p>缺点：技术上不可行，无法得知哪些类实现了协议。</p>\n<p>想法4. 组件新增一个类，在<code>+ (void)load</code>中将类名注册进入管理类，AppDelegate执行的时候取出所有类名，进行实例化和事件分发。</p>\n<p>缺点：在<code>+ (void)load</code>中进行工作会增加App启动耗时</p>\n<p>想法5. 组件新增一个类，在主工程维护一个plist，将类名写进该plist，AppDelegate执行的时候取出所有类名，进行实例化和事件分发。</p>\n<p>缺点：plist在主工程，同样无法满足无缝对接的需求，A同事仍然需要对接维护。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>目前能得出的最优解决方案：</p>\n<p>将类名注入mach-o文件中，在编译期写入，在AppDelegate事件分发的时候取出并实例化，不占用App启动耗时，也不用维护多一个plist文件。</p>\n<h2 id=\"试验\"><a href=\"#试验\" class=\"headerlink\" title=\"试验\"></a>试验</h2><ol>\n<li><p>新建 MacOS - Command Line Tool 项目，命名为<code>TestC</code></p>\n</li>\n<li><p>加入我们想注入字符串<code>ModuleAModule</code>,将其存储在名为<code>TestModes</code>的section内，那么在main.m中写如下代码：</p>\n <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char * kModuleAModule_mod __attribute((used, section(<span class=\"string\">&quot;__DATA, &quot;</span><span class=\"string\">&quot;TestModes&quot;</span><span class=\"string\">&quot; &quot;</span>))) = <span class=\"string\">&quot;&quot;&quot;ModuleAModule&quot;&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> main(<span class=\"built_in\">int</span> argc, const char * argv[]) &#123;</span><br><span class=\"line\">\t// insert code here...</span><br><span class=\"line\">\tprintf(<span class=\"string\">&quot;Hello, World!\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>输出这个mach-o文件的所有segment和section<code>otool -l TestC</code></p>\n<p> 部分结果：</p>\n <figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Section</span></span><br><span class=\"line\">  <span class=\"attribute\">sectname</span> TestModes</span><br><span class=\"line\">   <span class=\"attribute\">segname</span> __DATA</span><br><span class=\"line\">\t  <span class=\"attribute\">addr</span> <span class=\"number\">0</span>x<span class=\"number\">0000000100002008</span></span><br><span class=\"line\">\t  <span class=\"attribute\">size</span> <span class=\"number\">0</span>x<span class=\"number\">0000000000000008</span></span><br><span class=\"line\">\t<span class=\"attribute\">offset</span> <span class=\"number\">8200</span></span><br><span class=\"line\">\t <span class=\"attribute\">align</span> <span class=\"number\">2</span>^<span class=\"number\">3</span> (<span class=\"number\">8</span>)</span><br><span class=\"line\">\t<span class=\"attribute\">reloff</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"attribute\">nreloc</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t <span class=\"attribute\">flags</span> <span class=\"number\">0</span>x<span class=\"number\">00000000</span></span><br><span class=\"line\"> <span class=\"attribute\">reserved1</span> <span class=\"number\">0</span></span><br><span class=\"line\"> <span class=\"attribute\">reserved2</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p> 看到了<code>Test Modes</code>了，继续看一下section的内容<code>otool -s __DATA TestModes TestC</code></p>\n<p> 结果</p>\n <figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"attribute\">TestC</span>:</span><br><span class=\"line\"><span class=\"attribute\">Contents</span> of (__DATA,TestModes) section</span><br><span class=\"line\"><span class=\"attribute\">0000000100002008</span>\t<span class=\"number\">92</span> <span class=\"number\">0</span>f <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">01</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br></pre></td></tr></table></figure>\n<p> 发现<code>0000000100002008</code>这个地址可能是我们要的东西，再看看这个地址里有啥<br> <code>otool -V -s __TEXT __cstring TestC </code>打印所有字符串数据内容<br> 看到了</p>\n <figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">Contents</span> <span class=\"selector-tag\">of</span> (__TEXT,__cstring) <span class=\"selector-tag\">section</span></span><br><span class=\"line\">\t<span class=\"selector-tag\">0000000100000f92</span>  <span class=\"selector-tag\">ModuleAModule</span></span><br><span class=\"line\">\t<span class=\"selector-tag\">0000000100000fa0</span>  <span class=\"selector-tag\">Hello</span>, <span class=\"selector-tag\">World</span>!\\<span class=\"selector-tag\">n</span></span><br></pre></td></tr></table></figure>\n<p> 找到了我们想注入的类名<code>ModuleAModule</code><br> 这样，类名就被存储在mach-o文件的section中了。</p>\n</li>\n<li><p>取出类名， 代码如下</p>\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt;* readConfiguration(<span class=\"keyword\">char</span> *sectionName,<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> mach_header *mhp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableArray</span> *configs = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __LP64__</span></span><br><span class=\"line\">\tuintptr_t *memory = (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> mach_header_64 *mhp64 = (<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> mach_header_64 *)mhp;</span><br><span class=\"line\">\tuintptr_t *memory = (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> counter = size/<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">void</span>*);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> idx = <span class=\"number\">0</span>; idx &lt; counter; ++idx)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> *string = (<span class=\"keyword\">char</span>*)memory[idx];</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSString</span> *str = [<span class=\"built_in\">NSString</span> stringWithUTF8String:string];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!str)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(str) [configs addObject:str];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> configs;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> dyld_callback(<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> mach_header *mhp, intptr_t vmaddr_slide)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSArray</span> *mods = readConfiguration(<span class=\"string\">&quot;TestModes&quot;</span>, mhp);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *modName <span class=\"keyword\">in</span> mods) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (modName) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;取得：%@&quot;</span>,modName);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">__attribute__((constructor))</span><br><span class=\"line\"><span class=\"keyword\">void</span> initProphet() &#123;</span><br><span class=\"line\">\t_dyld_register_func_for_add_image(dyld_callback);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 当一个函数被<code>__attribute__((constructor))</code>修饰时，表示这个函数是这个镜像的初始化函数，在镜像被加载时，首先会调用这个函数。（镜像指的是mach-o和动态共享库，在工程运行时，可以使用lldb命令<code>image list</code>查看这个工程中加载的所有镜像。）<br>上述代码表示<code>initProphet</code>函数被指定为mach-o的初始化函数，当dyld（动态链接器）加载mach-o时，执行<code>initProphet</code>函数，其执行时机在main函数和类的load方法之前。</p>\n<p> 当<code>_dyld_register_func_for_add_image(dyld_callback);</code>被执行时，如果已经加载了镜像，则每存在一个已经加载的镜像就执行一次<code>dyld_callback</code>函数，在此之后，每当有一个新的镜像被加载时，也会执行一次<code>dyld_callback</code>函数。<br>（<code>dyld_callback</code>函数在镜像的初始化函数之前被调用，mach-o是第一个被加载的镜像，调用顺序是：<code>load mach-o -&gt; initProphet -&gt; dyld_callback -&gt; load other_image -&gt; dyld_callback -&gt; other_image_initializers -&gt; ......</code>）</p>\n<p> 所以，当程序启动时，会多次调用dyld_callback函数。<br> 在dyld_callback函数中，使用下列函数来获取[步骤2]中存储的类名</p>\n <figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">uint8_t</span> *<span class=\"title\">getsectiondata</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   <span class=\"keyword\">const</span> struct mach_header_64 *mhp,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *segname,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *sectname,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> *size)</span></span>;</span><br></pre></td></tr></table></figure>\n<p> segname的值为<code>__DATA</code>，sectname的值为<code>TestMods</code></p>\n</li>\n</ol>\n<h2 id=\"封装组件\"><a href=\"#封装组件\" class=\"headerlink\" title=\"封装组件\"></a>封装组件</h2><p>有了上面的指导思想，那么我们就可以封装组件了，具体内容见<a href=\"https://github.com/Arc-lin/ALComponentManager\">ALComponentManager</a></p>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><h4 id=\"AppDelegate继承自ALAppDelegate\"><a href=\"#AppDelegate继承自ALAppDelegate\" class=\"headerlink\" title=\"AppDelegate继承自ALAppDelegate\"></a>AppDelegate继承自ALAppDelegate</h4><p>只需要在实现<code>UIApplicationDelegate</code>的方法内部调用super方法即可，如</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)applicationWillResignActive:(<span class=\"built_in\">UIApplication</span> *)application</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> applicationWillResignActive:application];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"AppDelegate继承自UIResponder\"><a href=\"#AppDelegate继承自UIResponder\" class=\"headerlink\" title=\"AppDelegate继承自UIResponder\"></a>AppDelegate继承自UIResponder</h4><p>在AppDelegate的各个方法做分发埋点，触发到埋点后事件会分发到各个组件类里面</p>\n<p>如</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions;</span><br></pre></td></tr></table></figure>\n<p>埋点如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      [[ALComponentManager sharedManager] triggerEvent:ALSetupEvent];</span><br><span class=\"line\">      [[ALComponentManager sharedManager] triggerEvent:ALInitEvent];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">          [[ALComponentManager sharedManager] triggerEvent:ALSplashEvent];</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"meta-keyword\">if</span> __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 100000</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ([<span class=\"built_in\">UIDevice</span> currentDevice].systemVersion.floatValue &gt;= <span class=\"number\">10.0</span>f) &#123;</span><br><span class=\"line\">          [UNUserNotificationCenter currentNotificationCenter].delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其他埋点见组件Demo</p>\n<h4 id=\"给每个组件创建组件管理类\"><a href=\"#给每个组件创建组件管理类\" class=\"headerlink\" title=\"给每个组件创建组件管理类\"></a>给每个组件创建组件管理类</h4><ol>\n<li><p>给每个组件创建一个类并写上注解，如<code>ALComponentA.m</code></p>\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ALMod(ALComponentA);</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ALComponentA</span>()&lt;<span class=\"title\">ALComponentProtocol</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ALComponentA</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现协议<code>ALComponentProtocol</code>和需要的协议方法。<br> 这个协议里面蕴含了基本所有的<code>AppDelegate</code>方法，当然要触发这些方法都是要预先在AppDelegate写上埋点。</p>\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ALComponentA</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)load</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;Component A Load&quot;</span>);    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;ComponentA Init&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)modSetUp:(ALContext *)context</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;ComponentA setup&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接下来你就可以尝试使用了。</p>\n</li>\n</ol>\n<h2 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h2><p>要是组件间的初始化互相依赖怎么办？</p>\n<p>还能怎么办，已经违背了组件隔离的原则，就只能按原来的方法处理了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://github.com/alibaba/BeeHive\">BeeHive</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>当App发展庞大的时候，势必会导致AppDelegate类的庞大，所以如何去优化AppDelegate成为组件化工作中的主要部分之一。</p>","more":"<h2 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h2><p>举个例子，比如App中拥有</p>\n<ol>\n<li>用户管理组件</li>\n<li>首页组件</li>\n<li>消息组件</li>\n</ol>\n<p>那么他们分别需要在<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>中实现</p>\n<ol>\n<li>访问接口更新用户信息</li>\n<li>配置首页弹窗</li>\n<li>访问接口获取用户未读消息数</li>\n</ol>\n<p>假设这三个事件之间无关联，只是在初始化自己的模块后做准备工作，但是同时他们堆叠在同一个方法内，必然会导致方法臃肿。设想另外一个场景，假如开发者A只负责维护AppDelegate及主工程项目，开发者B只负责维护用户管理组件，那么开发者B要在App初始化的时候，再加入一个<code>将用户信息传到大数据中心统计</code>的功能，那么由于他不拥有<code>AppDelegate</code>的修改权限，只能让A排期去协助工作，同理可得，当组件变多，团队庞大的时候，开发者A将会有很多协助工作要做，这就是这次要讨论的问题。</p>\n<h2 id=\"想法\"><a href=\"#想法\" class=\"headerlink\" title=\"想法\"></a>想法</h2><p>是否可以将组件的初始化安排到组件内部中，而不在AppDelegate类中直接进行维护呢？</p>\n<p>想法1. 组件新增一个类，然后在该类里面进行初始化。AppDelegate import 这个类，调用这个类中的方法。</p>\n<p>缺点：AppDelegate需要耦合该组件，如果要去掉该组件或者新增别的组件，AppDelegate需要增加维护成本。</p>\n<p>想法2. AppDelegate主动分发事件，用通知的形式分发给每个组件消息。</p>\n<p>缺点：由于组件无法依赖主工程，所以通知名无法维护，另外通知会分发到不需要在AppDelgate初始化的组件，属于通知滥用。</p>\n<p>想法3. AppDelegate主动分发事件，组件新增一个类，将AppDelegate事件通过协议的方式分发到这个类中，类遵循该协议。</p>\n<p>缺点：技术上不可行，无法得知哪些类实现了协议。</p>\n<p>想法4. 组件新增一个类，在<code>+ (void)load</code>中将类名注册进入管理类，AppDelegate执行的时候取出所有类名，进行实例化和事件分发。</p>\n<p>缺点：在<code>+ (void)load</code>中进行工作会增加App启动耗时</p>\n<p>想法5. 组件新增一个类，在主工程维护一个plist，将类名写进该plist，AppDelegate执行的时候取出所有类名，进行实例化和事件分发。</p>\n<p>缺点：plist在主工程，同样无法满足无缝对接的需求，A同事仍然需要对接维护。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>目前能得出的最优解决方案：</p>\n<p>将类名注入mach-o文件中，在编译期写入，在AppDelegate事件分发的时候取出并实例化，不占用App启动耗时，也不用维护多一个plist文件。</p>\n<h2 id=\"试验\"><a href=\"#试验\" class=\"headerlink\" title=\"试验\"></a>试验</h2><ol>\n<li><p>新建 MacOS - Command Line Tool 项目，命名为<code>TestC</code></p>\n</li>\n<li><p>加入我们想注入字符串<code>ModuleAModule</code>,将其存储在名为<code>TestModes</code>的section内，那么在main.m中写如下代码：</p>\n <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char * kModuleAModule_mod __attribute((used, section(<span class=\"string\">&quot;__DATA, &quot;</span><span class=\"string\">&quot;TestModes&quot;</span><span class=\"string\">&quot; &quot;</span>))) = <span class=\"string\">&quot;&quot;&quot;ModuleAModule&quot;&quot;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> main(<span class=\"built_in\">int</span> argc, const char * argv[]) &#123;</span><br><span class=\"line\">\t// insert code here...</span><br><span class=\"line\">\tprintf(<span class=\"string\">&quot;Hello, World!\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n<li><p>输出这个mach-o文件的所有segment和section<code>otool -l TestC</code></p>\n<p> 部分结果：</p>\n <figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Section</span></span><br><span class=\"line\">  <span class=\"attribute\">sectname</span> TestModes</span><br><span class=\"line\">   <span class=\"attribute\">segname</span> __DATA</span><br><span class=\"line\">\t  <span class=\"attribute\">addr</span> <span class=\"number\">0</span>x<span class=\"number\">0000000100002008</span></span><br><span class=\"line\">\t  <span class=\"attribute\">size</span> <span class=\"number\">0</span>x<span class=\"number\">0000000000000008</span></span><br><span class=\"line\">\t<span class=\"attribute\">offset</span> <span class=\"number\">8200</span></span><br><span class=\"line\">\t <span class=\"attribute\">align</span> <span class=\"number\">2</span>^<span class=\"number\">3</span> (<span class=\"number\">8</span>)</span><br><span class=\"line\">\t<span class=\"attribute\">reloff</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"attribute\">nreloc</span> <span class=\"number\">0</span></span><br><span class=\"line\">\t <span class=\"attribute\">flags</span> <span class=\"number\">0</span>x<span class=\"number\">00000000</span></span><br><span class=\"line\"> <span class=\"attribute\">reserved1</span> <span class=\"number\">0</span></span><br><span class=\"line\"> <span class=\"attribute\">reserved2</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p> 看到了<code>Test Modes</code>了，继续看一下section的内容<code>otool -s __DATA TestModes TestC</code></p>\n<p> 结果</p>\n <figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"attribute\">TestC</span>:</span><br><span class=\"line\"><span class=\"attribute\">Contents</span> of (__DATA,TestModes) section</span><br><span class=\"line\"><span class=\"attribute\">0000000100002008</span>\t<span class=\"number\">92</span> <span class=\"number\">0</span>f <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">01</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> </span><br></pre></td></tr></table></figure>\n<p> 发现<code>0000000100002008</code>这个地址可能是我们要的东西，再看看这个地址里有啥<br> <code>otool -V -s __TEXT __cstring TestC </code>打印所有字符串数据内容<br> 看到了</p>\n <figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">Contents</span> <span class=\"selector-tag\">of</span> (__TEXT,__cstring) <span class=\"selector-tag\">section</span></span><br><span class=\"line\">\t<span class=\"selector-tag\">0000000100000f92</span>  <span class=\"selector-tag\">ModuleAModule</span></span><br><span class=\"line\">\t<span class=\"selector-tag\">0000000100000fa0</span>  <span class=\"selector-tag\">Hello</span>, <span class=\"selector-tag\">World</span>!\\<span class=\"selector-tag\">n</span></span><br></pre></td></tr></table></figure>\n<p> 找到了我们想注入的类名<code>ModuleAModule</code><br> 这样，类名就被存储在mach-o文件的section中了。</p>\n</li>\n<li><p>取出类名， 代码如下</p>\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSArray</span>&lt;<span class=\"built_in\">NSString</span> *&gt;* readConfiguration(<span class=\"keyword\">char</span> *sectionName,<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> mach_header *mhp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSMutableArray</span> *configs = [<span class=\"built_in\">NSMutableArray</span> array];</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __LP64__</span></span><br><span class=\"line\">\tuintptr_t *memory = (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> mach_header_64 *mhp64 = (<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> mach_header_64 *)mhp;</span><br><span class=\"line\">\tuintptr_t *memory = (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> counter = size/<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">void</span>*);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> idx = <span class=\"number\">0</span>; idx &lt; counter; ++idx)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> *string = (<span class=\"keyword\">char</span>*)memory[idx];</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSString</span> *str = [<span class=\"built_in\">NSString</span> stringWithUTF8String:string];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!str)<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(str) [configs addObject:str];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> configs;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> dyld_callback(<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> mach_header *mhp, intptr_t vmaddr_slide)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSArray</span> *mods = readConfiguration(<span class=\"string\">&quot;TestModes&quot;</span>, mhp);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"built_in\">NSString</span> *modName <span class=\"keyword\">in</span> mods) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (modName) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;取得：%@&quot;</span>,modName);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">__attribute__((constructor))</span><br><span class=\"line\"><span class=\"keyword\">void</span> initProphet() &#123;</span><br><span class=\"line\">\t_dyld_register_func_for_add_image(dyld_callback);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 当一个函数被<code>__attribute__((constructor))</code>修饰时，表示这个函数是这个镜像的初始化函数，在镜像被加载时，首先会调用这个函数。（镜像指的是mach-o和动态共享库，在工程运行时，可以使用lldb命令<code>image list</code>查看这个工程中加载的所有镜像。）<br>上述代码表示<code>initProphet</code>函数被指定为mach-o的初始化函数，当dyld（动态链接器）加载mach-o时，执行<code>initProphet</code>函数，其执行时机在main函数和类的load方法之前。</p>\n<p> 当<code>_dyld_register_func_for_add_image(dyld_callback);</code>被执行时，如果已经加载了镜像，则每存在一个已经加载的镜像就执行一次<code>dyld_callback</code>函数，在此之后，每当有一个新的镜像被加载时，也会执行一次<code>dyld_callback</code>函数。<br>（<code>dyld_callback</code>函数在镜像的初始化函数之前被调用，mach-o是第一个被加载的镜像，调用顺序是：<code>load mach-o -&gt; initProphet -&gt; dyld_callback -&gt; load other_image -&gt; dyld_callback -&gt; other_image_initializers -&gt; ......</code>）</p>\n<p> 所以，当程序启动时，会多次调用dyld_callback函数。<br> 在dyld_callback函数中，使用下列函数来获取[步骤2]中存储的类名</p>\n <figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">uint8_t</span> *<span class=\"title\">getsectiondata</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   <span class=\"keyword\">const</span> struct mach_header_64 *mhp,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *segname,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *sectname,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> *size)</span></span>;</span><br></pre></td></tr></table></figure>\n<p> segname的值为<code>__DATA</code>，sectname的值为<code>TestMods</code></p>\n</li>\n</ol>\n<h2 id=\"封装组件\"><a href=\"#封装组件\" class=\"headerlink\" title=\"封装组件\"></a>封装组件</h2><p>有了上面的指导思想，那么我们就可以封装组件了，具体内容见<a href=\"https://github.com/Arc-lin/ALComponentManager\">ALComponentManager</a></p>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><h4 id=\"AppDelegate继承自ALAppDelegate\"><a href=\"#AppDelegate继承自ALAppDelegate\" class=\"headerlink\" title=\"AppDelegate继承自ALAppDelegate\"></a>AppDelegate继承自ALAppDelegate</h4><p>只需要在实现<code>UIApplicationDelegate</code>的方法内部调用super方法即可，如</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)applicationWillResignActive:(<span class=\"built_in\">UIApplication</span> *)application</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> applicationWillResignActive:application];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"AppDelegate继承自UIResponder\"><a href=\"#AppDelegate继承自UIResponder\" class=\"headerlink\" title=\"AppDelegate继承自UIResponder\"></a>AppDelegate继承自UIResponder</h4><p>在AppDelegate的各个方法做分发埋点，触发到埋点后事件会分发到各个组件类里面</p>\n<p>如</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions;</span><br></pre></td></tr></table></figure>\n<p>埋点如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class=\"built_in\">NSDictionary</span> *)launchOptions</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      [[ALComponentManager sharedManager] triggerEvent:ALSetupEvent];</span><br><span class=\"line\">      [[ALComponentManager sharedManager] triggerEvent:ALInitEvent];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">          [[ALComponentManager sharedManager] triggerEvent:ALSplashEvent];</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"meta-keyword\">if</span> __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 100000</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ([<span class=\"built_in\">UIDevice</span> currentDevice].systemVersion.floatValue &gt;= <span class=\"number\">10.0</span>f) &#123;</span><br><span class=\"line\">          [UNUserNotificationCenter currentNotificationCenter].delegate = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其他埋点见组件Demo</p>\n<h4 id=\"给每个组件创建组件管理类\"><a href=\"#给每个组件创建组件管理类\" class=\"headerlink\" title=\"给每个组件创建组件管理类\"></a>给每个组件创建组件管理类</h4><ol>\n<li><p>给每个组件创建一个类并写上注解，如<code>ALComponentA.m</code></p>\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@ALMod(ALComponentA);</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ALComponentA</span>()&lt;<span class=\"title\">ALComponentProtocol</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ALComponentA</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>实现协议<code>ALComponentProtocol</code>和需要的协议方法。<br> 这个协议里面蕴含了基本所有的<code>AppDelegate</code>方法，当然要触发这些方法都是要预先在AppDelegate写上埋点。</p>\n <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ALComponentA</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">void</span>)load</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;Component A Load&quot;</span>);    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;ComponentA Init&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)modSetUp:(ALContext *)context</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;ComponentA setup&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接下来你就可以尝试使用了。</p>\n</li>\n</ol>\n<h2 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h2><p>要是组件间的初始化互相依赖怎么办？</p>\n<p>还能怎么办，已经违背了组件隔离的原则，就只能按原来的方法处理了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://github.com/alibaba/BeeHive\">BeeHive</a></p>"},{"title":"DKLogger--iOS日志管理框架","author":"Arclin","abbrlink":"abce56f1","date":"2017-02-22T16:00:00.000Z","_content":"用于管理iOS的Log信息的框架\n\n<!-- more -->\n可以用在平时的调试中,另外如果app在用户使用过程中发生一些意外事件或者程序崩溃事件,那我们也可以通过服务器的文件得知问题所在\n\n特性\n- 支持四个Log等级 `DEBUG`,`INFO`,`WARN`,`ERROR`\n- 支持储存Log文件到本地和上传到服务器\n- 支持自定义打印Log类型和写入Log类型\n- 支持捕获&发送崩溃信息\n- 在界面长按2秒可以查看Log信息\n- 可以获取用户的在App内的查看轨迹(进入了哪些控制器)\n- 崩溃的时候重启RunLoop,进入ANR状态,不闪退\n- 支持服务器端同步显示Log信息(建议搭建本地服务器,因为这样子Log发送快)\n\n使用\n\n```\nDKLog(@\"...\"); 普通log\nDKInfoLog(@\"...\"); 包含特殊信息的log\nDKWRANLog(@\"...\"); 警告log\nDKERRLog(@\"...\"); 错误log\n```\n```\n/**\t\n 初始化: 创建Txt的Log文件并写入输出\n \n @param path  文件夹路径,默认Documents\n @param url   上传log地址 当发生崩溃事故的时候就会提示用户是否上传Log到服务器\n @param debug 调试模式 */\n- (void)registerLoggerInPath:(NSString *)path uploadUrlStr:(NSString *)url debug:(BOOL)debug;\neg:\n[[DKSharedLogger registerLoggerInPath:[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] uploadUrlStr:@\"http://192.168.1.91/public/index/Index/hello\" debug:YES];\n```\n\n```\n[DKSharedLogger printLevel:DKLoggerLevelInfo|DKLoggerLevelWARN]; 在控制器只打印Info和Warn等级的Log\n```\n```\n[DKSharedLogger saveLevel:DKLoggerLevelError|DKLoggerLevelInfo]; 在文件中之写入Info和Error等级的Log\n```\n\n```\nDK_VAR_DUMP(arr); 查看对象信息,例如变量arr\n```\n\n长按界面2秒弹出log信息界面\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/1011.png?raw=true)","source":"_posts/DKLogger-iOS日志管理框架.md","raw":"---\ntitle: DKLogger--iOS日志管理框架\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: abce56f1\ndate: 2017-02-23 00:00:00\n---\n用于管理iOS的Log信息的框架\n\n<!-- more -->\n可以用在平时的调试中,另外如果app在用户使用过程中发生一些意外事件或者程序崩溃事件,那我们也可以通过服务器的文件得知问题所在\n\n特性\n- 支持四个Log等级 `DEBUG`,`INFO`,`WARN`,`ERROR`\n- 支持储存Log文件到本地和上传到服务器\n- 支持自定义打印Log类型和写入Log类型\n- 支持捕获&发送崩溃信息\n- 在界面长按2秒可以查看Log信息\n- 可以获取用户的在App内的查看轨迹(进入了哪些控制器)\n- 崩溃的时候重启RunLoop,进入ANR状态,不闪退\n- 支持服务器端同步显示Log信息(建议搭建本地服务器,因为这样子Log发送快)\n\n使用\n\n```\nDKLog(@\"...\"); 普通log\nDKInfoLog(@\"...\"); 包含特殊信息的log\nDKWRANLog(@\"...\"); 警告log\nDKERRLog(@\"...\"); 错误log\n```\n```\n/**\t\n 初始化: 创建Txt的Log文件并写入输出\n \n @param path  文件夹路径,默认Documents\n @param url   上传log地址 当发生崩溃事故的时候就会提示用户是否上传Log到服务器\n @param debug 调试模式 */\n- (void)registerLoggerInPath:(NSString *)path uploadUrlStr:(NSString *)url debug:(BOOL)debug;\neg:\n[[DKSharedLogger registerLoggerInPath:[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] uploadUrlStr:@\"http://192.168.1.91/public/index/Index/hello\" debug:YES];\n```\n\n```\n[DKSharedLogger printLevel:DKLoggerLevelInfo|DKLoggerLevelWARN]; 在控制器只打印Info和Warn等级的Log\n```\n```\n[DKSharedLogger saveLevel:DKLoggerLevelError|DKLoggerLevelInfo]; 在文件中之写入Info和Error等级的Log\n```\n\n```\nDK_VAR_DUMP(arr); 查看对象信息,例如变量arr\n```\n\n长按界面2秒弹出log信息界面\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/1011.png?raw=true)","slug":"DKLogger-iOS日志管理框架","published":1,"updated":"2021-06-06T18:52:24.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyogr000etnn0f9a7a4js","content":"<p>用于管理iOS的Log信息的框架</p>\n<span id=\"more\"></span>\n<p>可以用在平时的调试中,另外如果app在用户使用过程中发生一些意外事件或者程序崩溃事件,那我们也可以通过服务器的文件得知问题所在</p>\n<p>特性</p>\n<ul>\n<li>支持四个Log等级 <code>DEBUG</code>,<code>INFO</code>,<code>WARN</code>,<code>ERROR</code></li>\n<li>支持储存Log文件到本地和上传到服务器</li>\n<li>支持自定义打印Log类型和写入Log类型</li>\n<li>支持捕获&amp;发送崩溃信息</li>\n<li>在界面长按2秒可以查看Log信息</li>\n<li>可以获取用户的在App内的查看轨迹(进入了哪些控制器)</li>\n<li>崩溃的时候重启RunLoop,进入ANR状态,不闪退</li>\n<li>支持服务器端同步显示Log信息(建议搭建本地服务器,因为这样子Log发送快)</li>\n</ul>\n<p>使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKLog(@&quot;...&quot;); 普通log</span><br><span class=\"line\">DKInfoLog(@&quot;...&quot;); 包含特殊信息的log</span><br><span class=\"line\">DKWRANLog(@&quot;...&quot;); 警告log</span><br><span class=\"line\">DKERRLog(@&quot;...&quot;); 错误log</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**\t</span><br><span class=\"line\"> 初始化: 创建Txt的Log文件并写入输出</span><br><span class=\"line\"> </span><br><span class=\"line\"> @param path  文件夹路径,默认Documents</span><br><span class=\"line\"> @param url   上传log地址 当发生崩溃事故的时候就会提示用户是否上传Log到服务器</span><br><span class=\"line\"> @param debug 调试模式 *&#x2F;</span><br><span class=\"line\">- (void)registerLoggerInPath:(NSString *)path uploadUrlStr:(NSString *)url debug:(BOOL)debug;</span><br><span class=\"line\">eg:</span><br><span class=\"line\">[[DKSharedLogger registerLoggerInPath:[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] uploadUrlStr:@&quot;http:&#x2F;&#x2F;192.168.1.91&#x2F;public&#x2F;index&#x2F;Index&#x2F;hello&quot; debug:YES];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKSharedLogger printLevel:DKLoggerLevelInfo|DKLoggerLevelWARN]; 在控制器只打印Info和Warn等级的Log</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKSharedLogger saveLevel:DKLoggerLevelError|DKLoggerLevelInfo]; 在文件中之写入Info和Error等级的Log</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DK_VAR_DUMP(arr); 查看对象信息,例如变量arr</span><br></pre></td></tr></table></figure>\n\n<p>长按界面2秒弹出log信息界面</p>\n<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/1011.png?raw=true\"></p>\n","site":{"data":{}},"excerpt":"<p>用于管理iOS的Log信息的框架</p>","more":"<p>可以用在平时的调试中,另外如果app在用户使用过程中发生一些意外事件或者程序崩溃事件,那我们也可以通过服务器的文件得知问题所在</p>\n<p>特性</p>\n<ul>\n<li>支持四个Log等级 <code>DEBUG</code>,<code>INFO</code>,<code>WARN</code>,<code>ERROR</code></li>\n<li>支持储存Log文件到本地和上传到服务器</li>\n<li>支持自定义打印Log类型和写入Log类型</li>\n<li>支持捕获&amp;发送崩溃信息</li>\n<li>在界面长按2秒可以查看Log信息</li>\n<li>可以获取用户的在App内的查看轨迹(进入了哪些控制器)</li>\n<li>崩溃的时候重启RunLoop,进入ANR状态,不闪退</li>\n<li>支持服务器端同步显示Log信息(建议搭建本地服务器,因为这样子Log发送快)</li>\n</ul>\n<p>使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKLog(@&quot;...&quot;); 普通log</span><br><span class=\"line\">DKInfoLog(@&quot;...&quot;); 包含特殊信息的log</span><br><span class=\"line\">DKWRANLog(@&quot;...&quot;); 警告log</span><br><span class=\"line\">DKERRLog(@&quot;...&quot;); 错误log</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**\t</span><br><span class=\"line\"> 初始化: 创建Txt的Log文件并写入输出</span><br><span class=\"line\"> </span><br><span class=\"line\"> @param path  文件夹路径,默认Documents</span><br><span class=\"line\"> @param url   上传log地址 当发生崩溃事故的时候就会提示用户是否上传Log到服务器</span><br><span class=\"line\"> @param debug 调试模式 *&#x2F;</span><br><span class=\"line\">- (void)registerLoggerInPath:(NSString *)path uploadUrlStr:(NSString *)url debug:(BOOL)debug;</span><br><span class=\"line\">eg:</span><br><span class=\"line\">[[DKSharedLogger registerLoggerInPath:[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] uploadUrlStr:@&quot;http:&#x2F;&#x2F;192.168.1.91&#x2F;public&#x2F;index&#x2F;Index&#x2F;hello&quot; debug:YES];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKSharedLogger printLevel:DKLoggerLevelInfo|DKLoggerLevelWARN]; 在控制器只打印Info和Warn等级的Log</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKSharedLogger saveLevel:DKLoggerLevelError|DKLoggerLevelInfo]; 在文件中之写入Info和Error等级的Log</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DK_VAR_DUMP(arr); 查看对象信息,例如变量arr</span><br></pre></td></tr></table></figure>\n\n<p>长按界面2秒弹出log信息界面</p>\n<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/1011.png?raw=true\"></p>"},{"title":"Dankal_iOS崩溃信息提交","author":"Arclin","abbrlink":"afeed214","date":"2016-10-31T16:00:00.000Z","_content":"Dankal_iOS 崩溃信息提交\n<!-- more -->\n\n1. 获取到崩溃信息（异常原因，异常方法，异常类名，堆栈）\n2. 获取到本机信息（型号，系统）\n3. 保存为 plist到本地\n4. 下次启动应用的时候发送信息到服务器(POST发送，记得添加 token 到HEADER)\n5. 发送完之后删除掉 plist 文件\n\n---\n\n## 如何捕获崩溃信息\n\nC 语言捕获\n\n```\n#include <libkern/OSAtomic.h>\n#include <execinfo.h>\n\n// 系统信号截获处理方法\nvoid signalHandler(int signal);\n// 异常截获处理方法\nvoid exceptionHandler(NSException *exception);\nconst int32_t _uncaughtExceptionMaximum = 20;\n\nNSString * const UncaughtExceptionHandlerSignalKey = @\"UncaughtExceptionHandlerSignalKey\";\nNSString *const SingalExceptionHandlerAddressesKey = @\"SingalExceptionHandlerAddressesKey\";\nNSString *const ExceptionHandlerAddressesKey = @\"ExceptionHandlerAddressesKey\";\n\nvoid signalHandler(int signal)\n{\n    volatile int32_t _uncaughtExceptionCount = 0;\n    int32_t exceptionCount = OSAtomicIncrement32(&_uncaughtExceptionCount);\n    if (exceptionCount > _uncaughtExceptionMaximum) // 如果太多不用处理\n    {\n        return;\n    }\n    // 获取信息\n    NSMutableDictionary *userInfo =\n    [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey];\n    \n    NSArray *callStack = [DKUncaughtExceptionHandler backtrace];\n    [userInfo  setObject:callStack  forKey:SingalExceptionHandlerAddressesKey];\n    \n}\n\nvoid exceptionHandler(NSException *exception)\n{\n    volatile int32_t _uncaughtExceptionCount = 0;\n    int32_t exceptionCount = OSAtomicIncrement32(&_uncaughtExceptionCount);\n    if (exceptionCount > _uncaughtExceptionMaximum) // 如果太多不用处理\n    {\n        return;\n    }\n    \n    NSArray *callStack = [DKUncaughtExceptionHandler backtrace];\n    NSMutableDictionary *userInfo =[NSMutableDictionary dictionaryWithDictionary:[exception userInfo]];\n    [userInfo setObject:callStack forKey:ExceptionHandlerAddressesKey];\n    \n    // 保存信息到本地\n    NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] stringByAppendingPathComponent:@\"crash.plist\"];\n    \n    // 获取本机信息\n    struct utsname systemInfo;\n    uname(&systemInfo);\n    \n    NSDictionary *crashInfo = @{@\"crash_time\":[NSDate dateStringWithDateFormat:@\"yyyy-MM-dd HH:mm:ss\"],\n                                @\"device_type\": [DKUncaughtExceptionHandler deviceVersion:[NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]],\n                                @\"device_system\": [UIDevice currentDevice].systemVersion,\n                                @\"crash_type\":exception.name,\n                                @\"crash_reason\":exception.reason,\n                                @\"crash_stack\":userInfo.descriptionInStringsFileFormat};\n    [crashInfo writeToFile:path atomically:YES];\n}\n```\n\n## OC 部分获取调用堆栈和注册崩溃拦截\n\n```\n//获取调用堆栈\n+ (NSArray *)backtrace\n{\n    void* callstack[128];\n    int frames = backtrace(callstack, 128);\n    char **strs = backtrace_symbols(callstack,frames);\n    \n    NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames];\n    for (int i=0;i<frames;i++)\n    {\n        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];\n    }\n    free(strs);\n    \n    return backtrace;\n}\n\n// 注册崩溃拦截\n- (void)installExceptionHandler\n{\n    NSSetUncaughtExceptionHandler(&exceptionHandler);\n    signal(SIGHUP, signalHandler);\n    signal(SIGINT, signalHandler);\n    signal(SIGQUIT, signalHandler);\n    \n    signal(SIGABRT, signalHandler);\n    signal(SIGILL, signalHandler);\n    signal(SIGSEGV, signalHandler);\n    signal(SIGFPE, signalHandler);\n    signal(SIGBUS, signalHandler);\n    signal(SIGPIPE, signalHandler);\n    \n    NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] stringByAppendingPathComponent:@\"crash.plist\"];\n    if([[NSFileManager defaultManager] fileExistsAtPath:path]){\n        NSDictionary *params = [[NSDictionary alloc] initWithContentsOfFile:path];\n        [DKHTTPTool POST:去看 Coding 的Crash Reporter项目说明文档  parameters:params header:@{@\"token\":去看 Coding的Crash Reporter项目说明文档} responseBlock:^(DKResponse *response) {\n            if (!response.error) {\n                NSError *error;\n                [[NSFileManager defaultManager] removeItemAtPath:path error:&error];\n                if(error)DKLog(@\"%@\",error);\n            }\n        }];\n    }\n}\n```\n\n## 发送请求的AFN封装方法\n\n```\n+ (void)POST:(NSString *)URLString parameters:(id)parameters header:(NSDictionary *)headerField responseBlock:(DKHTTPResponseBlock)block\n{\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n    AFHTTPRequestSerializer *requestSerializer =  [AFJSONRequestSerializer serializer];\n    [headerField enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        [requestSerializer setValue:obj forHTTPHeaderField:key];\n    }];\n    mgr.requestSerializer = requestSerializer;\n    [mgr POST:URLString parameters:parameters  progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\n        resp.rawData = responseObject;\n        if(block){\n            block(resp);\n        }\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        DKResponse *resp = [[DKResponse alloc] init];\n        resp.error = error;\n        if (block) {\n            block(resp);\n        }\n    }];\n} \n```    \n\n## 在 AppDelegte内注册\n\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n  [[[DKUncaughtExceptionHandler alloc] init] installExceptionHandler];\n\treturn YES:\n}\n```\n\n## iOS设备测试编号转机型\n\n```\n+ (NSString *) deviceVersion:(NSString *)deviceString\n{\n    //iPhone\n    if ([deviceString isEqualToString:@\"iPhone1,1\"])    return @\"iPhone 1G\";\n    if ([deviceString isEqualToString:@\"iPhone1,2\"])    return @\"iPhone 3G\";\n    if ([deviceString isEqualToString:@\"iPhone2,1\"])    return @\"iPhone 3GS\";\n    if ([deviceString isEqualToString:@\"iPhone3,1\"])    return @\"iPhone 4\";\n    if ([deviceString isEqualToString:@\"iPhone3,2\"])    return @\"Verizon iPhone 4\";\n    if ([deviceString isEqualToString:@\"iPhone4,1\"])    return @\"iPhone 4S\";\n    if ([deviceString isEqualToString:@\"iPhone5,1\"])    return @\"iPhone 5\";\n    if ([deviceString isEqualToString:@\"iPhone5,2\"])    return @\"iPhone 5\";\n    if ([deviceString isEqualToString:@\"iPhone5,3\"])    return @\"iPhone 5C\";\n    if ([deviceString isEqualToString:@\"iPhone5,4\"])    return @\"iPhone 5C\";\n    if ([deviceString isEqualToString:@\"iPhone6,1\"])    return @\"iPhone 5S\";\n    if ([deviceString isEqualToString:@\"iPhone6,2\"])    return @\"iPhone 5S\";\n    if ([deviceString isEqualToString:@\"iPhone7,1\"])    return @\"iPhone 6 Plus\";\n    if ([deviceString isEqualToString:@\"iPhone7,2\"])    return @\"iPhone 6\";\n    if ([deviceString isEqualToString:@\"iPhone8,1\"])    return @\"iPhone 6s\";\n    if ([deviceString isEqualToString:@\"iPhone8,2\"])    return @\"iPhone 6s Plus\";\n    if ([deviceString isEqualToString:@\"iPhone8,4\"])    return @\"iPhone SE\";\n    if ([deviceString isEqualToString:@\"iPhone9,1\"])    return @\"iPhone 7\";\n    if ([deviceString isEqualToString:@\"iPhone9,3\"])    return @\"iPhone 7\";\n    if ([deviceString isEqualToString:@\"iPhone9,2\"])    return @\"iPhone 7 Plus\";\n    if ([deviceString isEqualToString:@\"iPhone9,4\"])    return @\"iPhone 7 Plus\";\n    \n    //iPod\n    if ([deviceString isEqualToString:@\"iPod1,1\"])      return @\"iPod Touch 1G\";\n    if ([deviceString isEqualToString:@\"iPod2,1\"])      return @\"iPod Touch 2G\";\n    if ([deviceString isEqualToString:@\"iPod3,1\"])      return @\"iPod Touch 3G\";\n    if ([deviceString isEqualToString:@\"iPod4,1\"])      return @\"iPod Touch 4G\";\n    if ([deviceString isEqualToString:@\"iPod5,1\"])      return @\"iPod Touch 5G\";\n    \n    //iPad\n    if ([deviceString isEqualToString:@\"iPad1,1\"])      return @\"iPad\";\n    if ([deviceString isEqualToString:@\"iPad2,1\"])      return @\"iPad 2 (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad2,2\"])      return @\"iPad 2 (GSM)\";\n    if ([deviceString isEqualToString:@\"iPad2,3\"])      return @\"iPad 2 (CDMA)\";\n    if ([deviceString isEqualToString:@\"iPad2,4\"])      return @\"iPad 2 (32nm)\";\n    if ([deviceString isEqualToString:@\"iPad2,5\"])      return @\"iPad mini (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad2,6\"])      return @\"iPad mini (GSM)\";\n    if ([deviceString isEqualToString:@\"iPad2,7\"])      return @\"iPad mini (CDMA)\";\n    \n    if ([deviceString isEqualToString:@\"iPad3,1\"])      return @\"iPad 3(WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad3,2\"])      return @\"iPad 3(CDMA)\";\n    if ([deviceString isEqualToString:@\"iPad3,3\"])      return @\"iPad 3(4G)\";\n    if ([deviceString isEqualToString:@\"iPad3,4\"])      return @\"iPad 4 (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad3,5\"])      return @\"iPad 4 (4G)\";\n    if ([deviceString isEqualToString:@\"iPad3,6\"])      return @\"iPad 4 (CDMA)\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,1\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad4,2\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad4,3\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad5,3\"])      return @\"iPad Air 2\";\n    if ([deviceString isEqualToString:@\"iPad5,4\"])      return @\"iPad Air 2\";\n    if ([deviceString isEqualToString:@\"i386\"])         return @\"Simulator\";\n    if ([deviceString isEqualToString:@\"x86_64\"])       return @\"Simulator\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,4\"]\n        ||[deviceString isEqualToString:@\"iPad4,5\"]\n        ||[deviceString isEqualToString:@\"iPad4,6\"])      return @\"iPad mini 2\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,7\"]\n        ||[deviceString isEqualToString:@\"iPad4,8\"]\n        ||[deviceString isEqualToString:@\"iPad4,9\"])      return @\"iPad mini 3\";\n    \n    return deviceString;\n}\n```","source":"_posts/Dankal-iOS崩溃信息提交.md","raw":"---\ntitle: Dankal_iOS崩溃信息提交\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: afeed214\ndate: 2016-11-01 00:00:00\n---\nDankal_iOS 崩溃信息提交\n<!-- more -->\n\n1. 获取到崩溃信息（异常原因，异常方法，异常类名，堆栈）\n2. 获取到本机信息（型号，系统）\n3. 保存为 plist到本地\n4. 下次启动应用的时候发送信息到服务器(POST发送，记得添加 token 到HEADER)\n5. 发送完之后删除掉 plist 文件\n\n---\n\n## 如何捕获崩溃信息\n\nC 语言捕获\n\n```\n#include <libkern/OSAtomic.h>\n#include <execinfo.h>\n\n// 系统信号截获处理方法\nvoid signalHandler(int signal);\n// 异常截获处理方法\nvoid exceptionHandler(NSException *exception);\nconst int32_t _uncaughtExceptionMaximum = 20;\n\nNSString * const UncaughtExceptionHandlerSignalKey = @\"UncaughtExceptionHandlerSignalKey\";\nNSString *const SingalExceptionHandlerAddressesKey = @\"SingalExceptionHandlerAddressesKey\";\nNSString *const ExceptionHandlerAddressesKey = @\"ExceptionHandlerAddressesKey\";\n\nvoid signalHandler(int signal)\n{\n    volatile int32_t _uncaughtExceptionCount = 0;\n    int32_t exceptionCount = OSAtomicIncrement32(&_uncaughtExceptionCount);\n    if (exceptionCount > _uncaughtExceptionMaximum) // 如果太多不用处理\n    {\n        return;\n    }\n    // 获取信息\n    NSMutableDictionary *userInfo =\n    [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey];\n    \n    NSArray *callStack = [DKUncaughtExceptionHandler backtrace];\n    [userInfo  setObject:callStack  forKey:SingalExceptionHandlerAddressesKey];\n    \n}\n\nvoid exceptionHandler(NSException *exception)\n{\n    volatile int32_t _uncaughtExceptionCount = 0;\n    int32_t exceptionCount = OSAtomicIncrement32(&_uncaughtExceptionCount);\n    if (exceptionCount > _uncaughtExceptionMaximum) // 如果太多不用处理\n    {\n        return;\n    }\n    \n    NSArray *callStack = [DKUncaughtExceptionHandler backtrace];\n    NSMutableDictionary *userInfo =[NSMutableDictionary dictionaryWithDictionary:[exception userInfo]];\n    [userInfo setObject:callStack forKey:ExceptionHandlerAddressesKey];\n    \n    // 保存信息到本地\n    NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] stringByAppendingPathComponent:@\"crash.plist\"];\n    \n    // 获取本机信息\n    struct utsname systemInfo;\n    uname(&systemInfo);\n    \n    NSDictionary *crashInfo = @{@\"crash_time\":[NSDate dateStringWithDateFormat:@\"yyyy-MM-dd HH:mm:ss\"],\n                                @\"device_type\": [DKUncaughtExceptionHandler deviceVersion:[NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]],\n                                @\"device_system\": [UIDevice currentDevice].systemVersion,\n                                @\"crash_type\":exception.name,\n                                @\"crash_reason\":exception.reason,\n                                @\"crash_stack\":userInfo.descriptionInStringsFileFormat};\n    [crashInfo writeToFile:path atomically:YES];\n}\n```\n\n## OC 部分获取调用堆栈和注册崩溃拦截\n\n```\n//获取调用堆栈\n+ (NSArray *)backtrace\n{\n    void* callstack[128];\n    int frames = backtrace(callstack, 128);\n    char **strs = backtrace_symbols(callstack,frames);\n    \n    NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames];\n    for (int i=0;i<frames;i++)\n    {\n        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];\n    }\n    free(strs);\n    \n    return backtrace;\n}\n\n// 注册崩溃拦截\n- (void)installExceptionHandler\n{\n    NSSetUncaughtExceptionHandler(&exceptionHandler);\n    signal(SIGHUP, signalHandler);\n    signal(SIGINT, signalHandler);\n    signal(SIGQUIT, signalHandler);\n    \n    signal(SIGABRT, signalHandler);\n    signal(SIGILL, signalHandler);\n    signal(SIGSEGV, signalHandler);\n    signal(SIGFPE, signalHandler);\n    signal(SIGBUS, signalHandler);\n    signal(SIGPIPE, signalHandler);\n    \n    NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] stringByAppendingPathComponent:@\"crash.plist\"];\n    if([[NSFileManager defaultManager] fileExistsAtPath:path]){\n        NSDictionary *params = [[NSDictionary alloc] initWithContentsOfFile:path];\n        [DKHTTPTool POST:去看 Coding 的Crash Reporter项目说明文档  parameters:params header:@{@\"token\":去看 Coding的Crash Reporter项目说明文档} responseBlock:^(DKResponse *response) {\n            if (!response.error) {\n                NSError *error;\n                [[NSFileManager defaultManager] removeItemAtPath:path error:&error];\n                if(error)DKLog(@\"%@\",error);\n            }\n        }];\n    }\n}\n```\n\n## 发送请求的AFN封装方法\n\n```\n+ (void)POST:(NSString *)URLString parameters:(id)parameters header:(NSDictionary *)headerField responseBlock:(DKHTTPResponseBlock)block\n{\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n    AFHTTPRequestSerializer *requestSerializer =  [AFJSONRequestSerializer serializer];\n    [headerField enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        [requestSerializer setValue:obj forHTTPHeaderField:key];\n    }];\n    mgr.requestSerializer = requestSerializer;\n    [mgr POST:URLString parameters:parameters  progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\n        resp.rawData = responseObject;\n        if(block){\n            block(resp);\n        }\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        DKResponse *resp = [[DKResponse alloc] init];\n        resp.error = error;\n        if (block) {\n            block(resp);\n        }\n    }];\n} \n```    \n\n## 在 AppDelegte内注册\n\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n  [[[DKUncaughtExceptionHandler alloc] init] installExceptionHandler];\n\treturn YES:\n}\n```\n\n## iOS设备测试编号转机型\n\n```\n+ (NSString *) deviceVersion:(NSString *)deviceString\n{\n    //iPhone\n    if ([deviceString isEqualToString:@\"iPhone1,1\"])    return @\"iPhone 1G\";\n    if ([deviceString isEqualToString:@\"iPhone1,2\"])    return @\"iPhone 3G\";\n    if ([deviceString isEqualToString:@\"iPhone2,1\"])    return @\"iPhone 3GS\";\n    if ([deviceString isEqualToString:@\"iPhone3,1\"])    return @\"iPhone 4\";\n    if ([deviceString isEqualToString:@\"iPhone3,2\"])    return @\"Verizon iPhone 4\";\n    if ([deviceString isEqualToString:@\"iPhone4,1\"])    return @\"iPhone 4S\";\n    if ([deviceString isEqualToString:@\"iPhone5,1\"])    return @\"iPhone 5\";\n    if ([deviceString isEqualToString:@\"iPhone5,2\"])    return @\"iPhone 5\";\n    if ([deviceString isEqualToString:@\"iPhone5,3\"])    return @\"iPhone 5C\";\n    if ([deviceString isEqualToString:@\"iPhone5,4\"])    return @\"iPhone 5C\";\n    if ([deviceString isEqualToString:@\"iPhone6,1\"])    return @\"iPhone 5S\";\n    if ([deviceString isEqualToString:@\"iPhone6,2\"])    return @\"iPhone 5S\";\n    if ([deviceString isEqualToString:@\"iPhone7,1\"])    return @\"iPhone 6 Plus\";\n    if ([deviceString isEqualToString:@\"iPhone7,2\"])    return @\"iPhone 6\";\n    if ([deviceString isEqualToString:@\"iPhone8,1\"])    return @\"iPhone 6s\";\n    if ([deviceString isEqualToString:@\"iPhone8,2\"])    return @\"iPhone 6s Plus\";\n    if ([deviceString isEqualToString:@\"iPhone8,4\"])    return @\"iPhone SE\";\n    if ([deviceString isEqualToString:@\"iPhone9,1\"])    return @\"iPhone 7\";\n    if ([deviceString isEqualToString:@\"iPhone9,3\"])    return @\"iPhone 7\";\n    if ([deviceString isEqualToString:@\"iPhone9,2\"])    return @\"iPhone 7 Plus\";\n    if ([deviceString isEqualToString:@\"iPhone9,4\"])    return @\"iPhone 7 Plus\";\n    \n    //iPod\n    if ([deviceString isEqualToString:@\"iPod1,1\"])      return @\"iPod Touch 1G\";\n    if ([deviceString isEqualToString:@\"iPod2,1\"])      return @\"iPod Touch 2G\";\n    if ([deviceString isEqualToString:@\"iPod3,1\"])      return @\"iPod Touch 3G\";\n    if ([deviceString isEqualToString:@\"iPod4,1\"])      return @\"iPod Touch 4G\";\n    if ([deviceString isEqualToString:@\"iPod5,1\"])      return @\"iPod Touch 5G\";\n    \n    //iPad\n    if ([deviceString isEqualToString:@\"iPad1,1\"])      return @\"iPad\";\n    if ([deviceString isEqualToString:@\"iPad2,1\"])      return @\"iPad 2 (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad2,2\"])      return @\"iPad 2 (GSM)\";\n    if ([deviceString isEqualToString:@\"iPad2,3\"])      return @\"iPad 2 (CDMA)\";\n    if ([deviceString isEqualToString:@\"iPad2,4\"])      return @\"iPad 2 (32nm)\";\n    if ([deviceString isEqualToString:@\"iPad2,5\"])      return @\"iPad mini (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad2,6\"])      return @\"iPad mini (GSM)\";\n    if ([deviceString isEqualToString:@\"iPad2,7\"])      return @\"iPad mini (CDMA)\";\n    \n    if ([deviceString isEqualToString:@\"iPad3,1\"])      return @\"iPad 3(WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad3,2\"])      return @\"iPad 3(CDMA)\";\n    if ([deviceString isEqualToString:@\"iPad3,3\"])      return @\"iPad 3(4G)\";\n    if ([deviceString isEqualToString:@\"iPad3,4\"])      return @\"iPad 4 (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad3,5\"])      return @\"iPad 4 (4G)\";\n    if ([deviceString isEqualToString:@\"iPad3,6\"])      return @\"iPad 4 (CDMA)\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,1\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad4,2\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad4,3\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad5,3\"])      return @\"iPad Air 2\";\n    if ([deviceString isEqualToString:@\"iPad5,4\"])      return @\"iPad Air 2\";\n    if ([deviceString isEqualToString:@\"i386\"])         return @\"Simulator\";\n    if ([deviceString isEqualToString:@\"x86_64\"])       return @\"Simulator\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,4\"]\n        ||[deviceString isEqualToString:@\"iPad4,5\"]\n        ||[deviceString isEqualToString:@\"iPad4,6\"])      return @\"iPad mini 2\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,7\"]\n        ||[deviceString isEqualToString:@\"iPad4,8\"]\n        ||[deviceString isEqualToString:@\"iPad4,9\"])      return @\"iPad mini 3\";\n    \n    return deviceString;\n}\n```","slug":"Dankal-iOS崩溃信息提交","published":1,"updated":"2021-06-06T18:52:24.961Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyogs000itnn00hpn8zx4","content":"<p>Dankal_iOS 崩溃信息提交</p>\n<span id=\"more\"></span>\n\n<ol>\n<li>获取到崩溃信息（异常原因，异常方法，异常类名，堆栈）</li>\n<li>获取到本机信息（型号，系统）</li>\n<li>保存为 plist到本地</li>\n<li>下次启动应用的时候发送信息到服务器(POST发送，记得添加 token 到HEADER)</li>\n<li>发送完之后删除掉 plist 文件</li>\n</ol>\n<hr>\n<h2 id=\"如何捕获崩溃信息\"><a href=\"#如何捕获崩溃信息\" class=\"headerlink\" title=\"如何捕获崩溃信息\"></a>如何捕获崩溃信息</h2><p>C 语言捕获</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;libkern&#x2F;OSAtomic.h&gt;</span><br><span class=\"line\">#include &lt;execinfo.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 系统信号截获处理方法</span><br><span class=\"line\">void signalHandler(int signal);</span><br><span class=\"line\">&#x2F;&#x2F; 异常截获处理方法</span><br><span class=\"line\">void exceptionHandler(NSException *exception);</span><br><span class=\"line\">const int32_t _uncaughtExceptionMaximum &#x3D; 20;</span><br><span class=\"line\"></span><br><span class=\"line\">NSString * const UncaughtExceptionHandlerSignalKey &#x3D; @&quot;UncaughtExceptionHandlerSignalKey&quot;;</span><br><span class=\"line\">NSString *const SingalExceptionHandlerAddressesKey &#x3D; @&quot;SingalExceptionHandlerAddressesKey&quot;;</span><br><span class=\"line\">NSString *const ExceptionHandlerAddressesKey &#x3D; @&quot;ExceptionHandlerAddressesKey&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">void signalHandler(int signal)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    volatile int32_t _uncaughtExceptionCount &#x3D; 0;</span><br><span class=\"line\">    int32_t exceptionCount &#x3D; OSAtomicIncrement32(&amp;_uncaughtExceptionCount);</span><br><span class=\"line\">    if (exceptionCount &gt; _uncaughtExceptionMaximum) &#x2F;&#x2F; 如果太多不用处理</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 获取信息</span><br><span class=\"line\">    NSMutableDictionary *userInfo &#x3D;</span><br><span class=\"line\">    [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSArray *callStack &#x3D; [DKUncaughtExceptionHandler backtrace];</span><br><span class=\"line\">    [userInfo  setObject:callStack  forKey:SingalExceptionHandlerAddressesKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void exceptionHandler(NSException *exception)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    volatile int32_t _uncaughtExceptionCount &#x3D; 0;</span><br><span class=\"line\">    int32_t exceptionCount &#x3D; OSAtomicIncrement32(&amp;_uncaughtExceptionCount);</span><br><span class=\"line\">    if (exceptionCount &gt; _uncaughtExceptionMaximum) &#x2F;&#x2F; 如果太多不用处理</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSArray *callStack &#x3D; [DKUncaughtExceptionHandler backtrace];</span><br><span class=\"line\">    NSMutableDictionary *userInfo &#x3D;[NSMutableDictionary dictionaryWithDictionary:[exception userInfo]];</span><br><span class=\"line\">    [userInfo setObject:callStack forKey:ExceptionHandlerAddressesKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 保存信息到本地</span><br><span class=\"line\">    NSString *path &#x3D; [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] stringByAppendingPathComponent:@&quot;crash.plist&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 获取本机信息</span><br><span class=\"line\">    struct utsname systemInfo;</span><br><span class=\"line\">    uname(&amp;systemInfo);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSDictionary *crashInfo &#x3D; @&#123;@&quot;crash_time&quot;:[NSDate dateStringWithDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;],</span><br><span class=\"line\">                                @&quot;device_type&quot;: [DKUncaughtExceptionHandler deviceVersion:[NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]],</span><br><span class=\"line\">                                @&quot;device_system&quot;: [UIDevice currentDevice].systemVersion,</span><br><span class=\"line\">                                @&quot;crash_type&quot;:exception.name,</span><br><span class=\"line\">                                @&quot;crash_reason&quot;:exception.reason,</span><br><span class=\"line\">                                @&quot;crash_stack&quot;:userInfo.descriptionInStringsFileFormat&#125;;</span><br><span class=\"line\">    [crashInfo writeToFile:path atomically:YES];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"OC-部分获取调用堆栈和注册崩溃拦截\"><a href=\"#OC-部分获取调用堆栈和注册崩溃拦截\" class=\"headerlink\" title=\"OC 部分获取调用堆栈和注册崩溃拦截\"></a>OC 部分获取调用堆栈和注册崩溃拦截</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;获取调用堆栈</span><br><span class=\"line\">+ (NSArray *)backtrace</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    void* callstack[128];</span><br><span class=\"line\">    int frames &#x3D; backtrace(callstack, 128);</span><br><span class=\"line\">    char **strs &#x3D; backtrace_symbols(callstack,frames);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSMutableArray *backtrace &#x3D; [NSMutableArray arrayWithCapacity:frames];</span><br><span class=\"line\">    for (int i&#x3D;0;i&lt;frames;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free(strs);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return backtrace;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 注册崩溃拦截</span><br><span class=\"line\">- (void)installExceptionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSSetUncaughtExceptionHandler(&amp;exceptionHandler);</span><br><span class=\"line\">    signal(SIGHUP, signalHandler);</span><br><span class=\"line\">    signal(SIGINT, signalHandler);</span><br><span class=\"line\">    signal(SIGQUIT, signalHandler);</span><br><span class=\"line\">    </span><br><span class=\"line\">    signal(SIGABRT, signalHandler);</span><br><span class=\"line\">    signal(SIGILL, signalHandler);</span><br><span class=\"line\">    signal(SIGSEGV, signalHandler);</span><br><span class=\"line\">    signal(SIGFPE, signalHandler);</span><br><span class=\"line\">    signal(SIGBUS, signalHandler);</span><br><span class=\"line\">    signal(SIGPIPE, signalHandler);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSString *path &#x3D; [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] stringByAppendingPathComponent:@&quot;crash.plist&quot;];</span><br><span class=\"line\">    if([[NSFileManager defaultManager] fileExistsAtPath:path])&#123;</span><br><span class=\"line\">        NSDictionary *params &#x3D; [[NSDictionary alloc] initWithContentsOfFile:path];</span><br><span class=\"line\">        [DKHTTPTool POST:去看 Coding 的Crash Reporter项目说明文档  parameters:params header:@&#123;@&quot;token&quot;:去看 Coding的Crash Reporter项目说明文档&#125; responseBlock:^(DKResponse *response) &#123;</span><br><span class=\"line\">            if (!response.error) &#123;</span><br><span class=\"line\">                NSError *error;</span><br><span class=\"line\">                [[NSFileManager defaultManager] removeItemAtPath:path error:&amp;error];</span><br><span class=\"line\">                if(error)DKLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"发送请求的AFN封装方法\"><a href=\"#发送请求的AFN封装方法\" class=\"headerlink\" title=\"发送请求的AFN封装方法\"></a>发送请求的AFN封装方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)POST:(NSString *)URLString parameters:(id)parameters header:(NSDictionary *)headerField responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer &#x3D;  [AFJSONRequestSerializer serializer];</span><br><span class=\"line\">    [headerField enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [requestSerializer setValue:obj forHTTPHeaderField:key];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    mgr.requestSerializer &#x3D; requestSerializer;</span><br><span class=\"line\">    [mgr POST:URLString parameters:parameters  progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject];</span><br><span class=\"line\">        resp.rawData &#x3D; responseObject;</span><br><span class=\"line\">        if(block)&#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [[DKResponse alloc] init];</span><br><span class=\"line\">        resp.error &#x3D; error;</span><br><span class=\"line\">        if (block) &#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">&#96;&#96;&#96;    </span><br><span class=\"line\"></span><br><span class=\"line\">## 在 AppDelegte内注册</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions<br>{<br>[[[DKUncaughtExceptionHandler alloc] init] installExceptionHandler];<br>  return YES:<br>}<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## iOS设备测试编号转机型</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li>(NSString *) deviceVersion:(NSString *)deviceString<br>{<br>  //iPhone<br>  if ([deviceString isEqualToString:@”iPhone1,1”])    return @”iPhone 1G”;<br>  if ([deviceString isEqualToString:@”iPhone1,2”])    return @”iPhone 3G”;<br>  if ([deviceString isEqualToString:@”iPhone2,1”])    return @”iPhone 3GS”;<br>  if ([deviceString isEqualToString:@”iPhone3,1”])    return @”iPhone 4”;<br>  if ([deviceString isEqualToString:@”iPhone3,2”])    return @”Verizon iPhone 4”;<br>  if ([deviceString isEqualToString:@”iPhone4,1”])    return @”iPhone 4S”;<br>  if ([deviceString isEqualToString:@”iPhone5,1”])    return @”iPhone 5”;<br>  if ([deviceString isEqualToString:@”iPhone5,2”])    return @”iPhone 5”;<br>  if ([deviceString isEqualToString:@”iPhone5,3”])    return @”iPhone 5C”;<br>  if ([deviceString isEqualToString:@”iPhone5,4”])    return @”iPhone 5C”;<br>  if ([deviceString isEqualToString:@”iPhone6,1”])    return @”iPhone 5S”;<br>  if ([deviceString isEqualToString:@”iPhone6,2”])    return @”iPhone 5S”;<br>  if ([deviceString isEqualToString:@”iPhone7,1”])    return @”iPhone 6 Plus”;<br>  if ([deviceString isEqualToString:@”iPhone7,2”])    return @”iPhone 6”;<br>  if ([deviceString isEqualToString:@”iPhone8,1”])    return @”iPhone 6s”;<br>  if ([deviceString isEqualToString:@”iPhone8,2”])    return @”iPhone 6s Plus”;<br>  if ([deviceString isEqualToString:@”iPhone8,4”])    return @”iPhone SE”;<br>  if ([deviceString isEqualToString:@”iPhone9,1”])    return @”iPhone 7”;<br>  if ([deviceString isEqualToString:@”iPhone9,3”])    return @”iPhone 7”;<br>  if ([deviceString isEqualToString:@”iPhone9,2”])    return @”iPhone 7 Plus”;<br>  if ([deviceString isEqualToString:@”iPhone9,4”])    return @”iPhone 7 Plus”;  //iPod<br>  if ([deviceString isEqualToString:@”iPod1,1”])      return @”iPod Touch 1G”;<br>  if ([deviceString isEqualToString:@”iPod2,1”])      return @”iPod Touch 2G”;<br>  if ([deviceString isEqualToString:@”iPod3,1”])      return @”iPod Touch 3G”;<br>  if ([deviceString isEqualToString:@”iPod4,1”])      return @”iPod Touch 4G”;<br>  if ([deviceString isEqualToString:@”iPod5,1”])      return @”iPod Touch 5G”;  //iPad<br>  if ([deviceString isEqualToString:@”iPad1,1”])      return @”iPad”;<br>  if ([deviceString isEqualToString:@”iPad2,1”])      return @”iPad 2 (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad2,2”])      return @”iPad 2 (GSM)”;<br>  if ([deviceString isEqualToString:@”iPad2,3”])      return @”iPad 2 (CDMA)”;<br>  if ([deviceString isEqualToString:@”iPad2,4”])      return @”iPad 2 (32nm)”;<br>  if ([deviceString isEqualToString:@”iPad2,5”])      return @”iPad mini (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad2,6”])      return @”iPad mini (GSM)”;<br>  if ([deviceString isEqualToString:@”iPad2,7”])      return @”iPad mini (CDMA)”;  if ([deviceString isEqualToString:@”iPad3,1”])      return @”iPad 3(WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad3,2”])      return @”iPad 3(CDMA)”;<br>  if ([deviceString isEqualToString:@”iPad3,3”])      return @”iPad 3(4G)”;<br>  if ([deviceString isEqualToString:@”iPad3,4”])      return @”iPad 4 (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad3,5”])      return @”iPad 4 (4G)”;<br>  if ([deviceString isEqualToString:@”iPad3,6”])      return @”iPad 4 (CDMA)”;  if ([deviceString isEqualToString:@”iPad4,1”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad4,2”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad4,3”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad5,3”])      return @”iPad Air 2”;<br>  if ([deviceString isEqualToString:@”iPad5,4”])      return @”iPad Air 2”;<br>  if ([deviceString isEqualToString:@”i386”])         return @”Simulator”;<br>  if ([deviceString isEqualToString:@”x86_64”])       return @”Simulator”;  if ([deviceString isEqualToString:@”iPad4,4”]<pre><code>  ||[deviceString isEqualToString:@&quot;iPad4,5&quot;]\n  ||[deviceString isEqualToString:@&quot;iPad4,6&quot;])      return @&quot;iPad mini 2&quot;;\n</code></pre>\n  if ([deviceString isEqualToString:@”iPad4,7”]<pre><code>  ||[deviceString isEqualToString:@&quot;iPad4,8&quot;]\n  ||[deviceString isEqualToString:@&quot;iPad4,9&quot;])      return @&quot;iPad mini 3&quot;;\n</code></pre>\n  return deviceString;<br>}<br>```</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Dankal_iOS 崩溃信息提交</p>","more":"<ol>\n<li>获取到崩溃信息（异常原因，异常方法，异常类名，堆栈）</li>\n<li>获取到本机信息（型号，系统）</li>\n<li>保存为 plist到本地</li>\n<li>下次启动应用的时候发送信息到服务器(POST发送，记得添加 token 到HEADER)</li>\n<li>发送完之后删除掉 plist 文件</li>\n</ol>\n<hr>\n<h2 id=\"如何捕获崩溃信息\"><a href=\"#如何捕获崩溃信息\" class=\"headerlink\" title=\"如何捕获崩溃信息\"></a>如何捕获崩溃信息</h2><p>C 语言捕获</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;libkern&#x2F;OSAtomic.h&gt;</span><br><span class=\"line\">#include &lt;execinfo.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 系统信号截获处理方法</span><br><span class=\"line\">void signalHandler(int signal);</span><br><span class=\"line\">&#x2F;&#x2F; 异常截获处理方法</span><br><span class=\"line\">void exceptionHandler(NSException *exception);</span><br><span class=\"line\">const int32_t _uncaughtExceptionMaximum &#x3D; 20;</span><br><span class=\"line\"></span><br><span class=\"line\">NSString * const UncaughtExceptionHandlerSignalKey &#x3D; @&quot;UncaughtExceptionHandlerSignalKey&quot;;</span><br><span class=\"line\">NSString *const SingalExceptionHandlerAddressesKey &#x3D; @&quot;SingalExceptionHandlerAddressesKey&quot;;</span><br><span class=\"line\">NSString *const ExceptionHandlerAddressesKey &#x3D; @&quot;ExceptionHandlerAddressesKey&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">void signalHandler(int signal)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    volatile int32_t _uncaughtExceptionCount &#x3D; 0;</span><br><span class=\"line\">    int32_t exceptionCount &#x3D; OSAtomicIncrement32(&amp;_uncaughtExceptionCount);</span><br><span class=\"line\">    if (exceptionCount &gt; _uncaughtExceptionMaximum) &#x2F;&#x2F; 如果太多不用处理</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 获取信息</span><br><span class=\"line\">    NSMutableDictionary *userInfo &#x3D;</span><br><span class=\"line\">    [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSArray *callStack &#x3D; [DKUncaughtExceptionHandler backtrace];</span><br><span class=\"line\">    [userInfo  setObject:callStack  forKey:SingalExceptionHandlerAddressesKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void exceptionHandler(NSException *exception)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    volatile int32_t _uncaughtExceptionCount &#x3D; 0;</span><br><span class=\"line\">    int32_t exceptionCount &#x3D; OSAtomicIncrement32(&amp;_uncaughtExceptionCount);</span><br><span class=\"line\">    if (exceptionCount &gt; _uncaughtExceptionMaximum) &#x2F;&#x2F; 如果太多不用处理</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSArray *callStack &#x3D; [DKUncaughtExceptionHandler backtrace];</span><br><span class=\"line\">    NSMutableDictionary *userInfo &#x3D;[NSMutableDictionary dictionaryWithDictionary:[exception userInfo]];</span><br><span class=\"line\">    [userInfo setObject:callStack forKey:ExceptionHandlerAddressesKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 保存信息到本地</span><br><span class=\"line\">    NSString *path &#x3D; [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] stringByAppendingPathComponent:@&quot;crash.plist&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 获取本机信息</span><br><span class=\"line\">    struct utsname systemInfo;</span><br><span class=\"line\">    uname(&amp;systemInfo);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSDictionary *crashInfo &#x3D; @&#123;@&quot;crash_time&quot;:[NSDate dateStringWithDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;],</span><br><span class=\"line\">                                @&quot;device_type&quot;: [DKUncaughtExceptionHandler deviceVersion:[NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]],</span><br><span class=\"line\">                                @&quot;device_system&quot;: [UIDevice currentDevice].systemVersion,</span><br><span class=\"line\">                                @&quot;crash_type&quot;:exception.name,</span><br><span class=\"line\">                                @&quot;crash_reason&quot;:exception.reason,</span><br><span class=\"line\">                                @&quot;crash_stack&quot;:userInfo.descriptionInStringsFileFormat&#125;;</span><br><span class=\"line\">    [crashInfo writeToFile:path atomically:YES];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"OC-部分获取调用堆栈和注册崩溃拦截\"><a href=\"#OC-部分获取调用堆栈和注册崩溃拦截\" class=\"headerlink\" title=\"OC 部分获取调用堆栈和注册崩溃拦截\"></a>OC 部分获取调用堆栈和注册崩溃拦截</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;获取调用堆栈</span><br><span class=\"line\">+ (NSArray *)backtrace</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    void* callstack[128];</span><br><span class=\"line\">    int frames &#x3D; backtrace(callstack, 128);</span><br><span class=\"line\">    char **strs &#x3D; backtrace_symbols(callstack,frames);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSMutableArray *backtrace &#x3D; [NSMutableArray arrayWithCapacity:frames];</span><br><span class=\"line\">    for (int i&#x3D;0;i&lt;frames;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free(strs);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return backtrace;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 注册崩溃拦截</span><br><span class=\"line\">- (void)installExceptionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSSetUncaughtExceptionHandler(&amp;exceptionHandler);</span><br><span class=\"line\">    signal(SIGHUP, signalHandler);</span><br><span class=\"line\">    signal(SIGINT, signalHandler);</span><br><span class=\"line\">    signal(SIGQUIT, signalHandler);</span><br><span class=\"line\">    </span><br><span class=\"line\">    signal(SIGABRT, signalHandler);</span><br><span class=\"line\">    signal(SIGILL, signalHandler);</span><br><span class=\"line\">    signal(SIGSEGV, signalHandler);</span><br><span class=\"line\">    signal(SIGFPE, signalHandler);</span><br><span class=\"line\">    signal(SIGBUS, signalHandler);</span><br><span class=\"line\">    signal(SIGPIPE, signalHandler);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSString *path &#x3D; [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] stringByAppendingPathComponent:@&quot;crash.plist&quot;];</span><br><span class=\"line\">    if([[NSFileManager defaultManager] fileExistsAtPath:path])&#123;</span><br><span class=\"line\">        NSDictionary *params &#x3D; [[NSDictionary alloc] initWithContentsOfFile:path];</span><br><span class=\"line\">        [DKHTTPTool POST:去看 Coding 的Crash Reporter项目说明文档  parameters:params header:@&#123;@&quot;token&quot;:去看 Coding的Crash Reporter项目说明文档&#125; responseBlock:^(DKResponse *response) &#123;</span><br><span class=\"line\">            if (!response.error) &#123;</span><br><span class=\"line\">                NSError *error;</span><br><span class=\"line\">                [[NSFileManager defaultManager] removeItemAtPath:path error:&amp;error];</span><br><span class=\"line\">                if(error)DKLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"发送请求的AFN封装方法\"><a href=\"#发送请求的AFN封装方法\" class=\"headerlink\" title=\"发送请求的AFN封装方法\"></a>发送请求的AFN封装方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)POST:(NSString *)URLString parameters:(id)parameters header:(NSDictionary *)headerField responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer &#x3D;  [AFJSONRequestSerializer serializer];</span><br><span class=\"line\">    [headerField enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [requestSerializer setValue:obj forHTTPHeaderField:key];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    mgr.requestSerializer &#x3D; requestSerializer;</span><br><span class=\"line\">    [mgr POST:URLString parameters:parameters  progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject];</span><br><span class=\"line\">        resp.rawData &#x3D; responseObject;</span><br><span class=\"line\">        if(block)&#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [[DKResponse alloc] init];</span><br><span class=\"line\">        resp.error &#x3D; error;</span><br><span class=\"line\">        if (block) &#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">&#96;&#96;&#96;    </span><br><span class=\"line\"></span><br><span class=\"line\">## 在 AppDelegte内注册</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions<br>{<br>[[[DKUncaughtExceptionHandler alloc] init] installExceptionHandler];<br>  return YES:<br>}<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## iOS设备测试编号转机型</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li>(NSString *) deviceVersion:(NSString *)deviceString<br>{<br>  //iPhone<br>  if ([deviceString isEqualToString:@”iPhone1,1”])    return @”iPhone 1G”;<br>  if ([deviceString isEqualToString:@”iPhone1,2”])    return @”iPhone 3G”;<br>  if ([deviceString isEqualToString:@”iPhone2,1”])    return @”iPhone 3GS”;<br>  if ([deviceString isEqualToString:@”iPhone3,1”])    return @”iPhone 4”;<br>  if ([deviceString isEqualToString:@”iPhone3,2”])    return @”Verizon iPhone 4”;<br>  if ([deviceString isEqualToString:@”iPhone4,1”])    return @”iPhone 4S”;<br>  if ([deviceString isEqualToString:@”iPhone5,1”])    return @”iPhone 5”;<br>  if ([deviceString isEqualToString:@”iPhone5,2”])    return @”iPhone 5”;<br>  if ([deviceString isEqualToString:@”iPhone5,3”])    return @”iPhone 5C”;<br>  if ([deviceString isEqualToString:@”iPhone5,4”])    return @”iPhone 5C”;<br>  if ([deviceString isEqualToString:@”iPhone6,1”])    return @”iPhone 5S”;<br>  if ([deviceString isEqualToString:@”iPhone6,2”])    return @”iPhone 5S”;<br>  if ([deviceString isEqualToString:@”iPhone7,1”])    return @”iPhone 6 Plus”;<br>  if ([deviceString isEqualToString:@”iPhone7,2”])    return @”iPhone 6”;<br>  if ([deviceString isEqualToString:@”iPhone8,1”])    return @”iPhone 6s”;<br>  if ([deviceString isEqualToString:@”iPhone8,2”])    return @”iPhone 6s Plus”;<br>  if ([deviceString isEqualToString:@”iPhone8,4”])    return @”iPhone SE”;<br>  if ([deviceString isEqualToString:@”iPhone9,1”])    return @”iPhone 7”;<br>  if ([deviceString isEqualToString:@”iPhone9,3”])    return @”iPhone 7”;<br>  if ([deviceString isEqualToString:@”iPhone9,2”])    return @”iPhone 7 Plus”;<br>  if ([deviceString isEqualToString:@”iPhone9,4”])    return @”iPhone 7 Plus”;  //iPod<br>  if ([deviceString isEqualToString:@”iPod1,1”])      return @”iPod Touch 1G”;<br>  if ([deviceString isEqualToString:@”iPod2,1”])      return @”iPod Touch 2G”;<br>  if ([deviceString isEqualToString:@”iPod3,1”])      return @”iPod Touch 3G”;<br>  if ([deviceString isEqualToString:@”iPod4,1”])      return @”iPod Touch 4G”;<br>  if ([deviceString isEqualToString:@”iPod5,1”])      return @”iPod Touch 5G”;  //iPad<br>  if ([deviceString isEqualToString:@”iPad1,1”])      return @”iPad”;<br>  if ([deviceString isEqualToString:@”iPad2,1”])      return @”iPad 2 (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad2,2”])      return @”iPad 2 (GSM)”;<br>  if ([deviceString isEqualToString:@”iPad2,3”])      return @”iPad 2 (CDMA)”;<br>  if ([deviceString isEqualToString:@”iPad2,4”])      return @”iPad 2 (32nm)”;<br>  if ([deviceString isEqualToString:@”iPad2,5”])      return @”iPad mini (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad2,6”])      return @”iPad mini (GSM)”;<br>  if ([deviceString isEqualToString:@”iPad2,7”])      return @”iPad mini (CDMA)”;  if ([deviceString isEqualToString:@”iPad3,1”])      return @”iPad 3(WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad3,2”])      return @”iPad 3(CDMA)”;<br>  if ([deviceString isEqualToString:@”iPad3,3”])      return @”iPad 3(4G)”;<br>  if ([deviceString isEqualToString:@”iPad3,4”])      return @”iPad 4 (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad3,5”])      return @”iPad 4 (4G)”;<br>  if ([deviceString isEqualToString:@”iPad3,6”])      return @”iPad 4 (CDMA)”;  if ([deviceString isEqualToString:@”iPad4,1”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad4,2”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad4,3”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad5,3”])      return @”iPad Air 2”;<br>  if ([deviceString isEqualToString:@”iPad5,4”])      return @”iPad Air 2”;<br>  if ([deviceString isEqualToString:@”i386”])         return @”Simulator”;<br>  if ([deviceString isEqualToString:@”x86_64”])       return @”Simulator”;  if ([deviceString isEqualToString:@”iPad4,4”]<pre><code>  ||[deviceString isEqualToString:@&quot;iPad4,5&quot;]\n  ||[deviceString isEqualToString:@&quot;iPad4,6&quot;])      return @&quot;iPad mini 2&quot;;\n</code></pre>\n  if ([deviceString isEqualToString:@”iPad4,7”]<pre><code>  ||[deviceString isEqualToString:@&quot;iPad4,8&quot;]\n  ||[deviceString isEqualToString:@&quot;iPad4,9&quot;])      return @&quot;iPad mini 3&quot;;\n</code></pre>\n  return deviceString;<br>}<br>```</li>\n</ul>"},{"title":"Express学习笔记","author":"Arclin","abbrlink":"dcb90c85","date":"2017-03-06T16:00:00.000Z","_content":"Express 是 Node.js 的一个轻量级web框架,目前使用EJS模板引擎,该笔记持续更新\n\n<!-- more -->\n\n## supervisor\n\n使用supervisor监听文件改变然后自动重启node服务器,这样子就不用每改一次代码run一遍服务器了\n\n`sudo npm install -g supervisor`\n\n### WebStrom配置supervisor\n\n文件目录结构\n```\n├── app.js        项目入口及程序启动文件。\n├── bin\n│   └── www       存放启动项目的脚本文件，默认www。\n├── package.json  项目依赖配置及开发者信息。\n├── public        静态资源文件夹，默认images、javascripts、stylesheets。\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n├── routes        路由文件相当于MVC中的Controller，默认index.js、users.js。\n│   ├── index.js\n│   └── users.js\n└── views         页面文件，相当于MVC中的view，Ejs模板默认error.ejs、index.ejs\n    ├── error.ejs\n    └── index.ejs\n```\n\n项目依赖配置 `package.json`\n\n`package.json` 里面有项目依赖配置及开发者信息。\n在dependencies后面写上依赖的包名和版本号,然后在项目根目录执行npm install就可以像cocopods一样一次性安装包依赖\n\n## 路由 Routes\n路由用来处理URL的访问\n\n`index.js`\n\n```\nvar express = require('express');   获取express对象\nvar router = express.Router();      获取router对象\n```\n\nrouter有get(),post(),put(),delete()对象,代表接受的请求方式,对应查,增,改,删\n\n```\nrouter.get('/getSomething',function(req,res,next) {});\nrouter.post('/post', function (req,res) {});\nrouter.put('/put',function(req,res,next) {});\nrouter.delete('/delete',function(req,res,next) {});\n```\n\n方法中第一个参数意味着请求路径,例如第一个的请求路径是`http://localhost:3000/getSomething`,第二个参数是获取请求内容和准备返回的响应体.\n\n## Request获取请求参数\n\n例如请求发送了id参数,则`var id = req.params.id;`可以取得\nResponse返回响应体\n\n`send()`方法向浏览器发送一个响应信息\n例如想返回一个json,则res.send({test:id = ${id},name = ${name}});\n当参数为一个Number时，并且没有上面提到的任何一条在响应体里，Express会帮你设置一个响应 体，比如：200会返回字符”OK”。\nres.send(200); // OK\nres.send(404); // Not Found\nres.send(500); // Internal Server Error\n\n## Response重定向\n\n`res.redirect(\"http://www.hubwiz.com\");`\n\n## Response渲染页面\n\n如果想渲染`hello.ejs`页面,`res.render('hello',{title:\"MySQL\",test_params:'aaa'});`\n`hello.ejs`页面通过`<%= title %>`的方式取得title等参数\n\nRequest获取主机名,路径名\n\n`req.host`获取主机名，`req.path`获取请求路径名\n\n## restful 方式路由\n\n```\nrouter.post('/restful/:id/name/:name', function (req,res) {\n  var id  = req.params.id;\n  var name = req.params.name;\n  console.log(JSON.stringify(req.params));\n  res.send({test:`id = ${id},name = ${name}`});\n});\nJSON.stringify() 把js对象转成json\n```\n\n## 数据库\n\n### MySQL\n安装MySQL\n\n`$ npm install mysql`\n\n引入MySQL并配置\n```\nvar mysql      = require('mysql');\nvar connection = mysql.createConnection({\n    host     : 'localhost',\n    user     : 'root',\n    password : '123456',\n    database : 'csdn_test',\n    port     : 3306\n});\n```\n\n连接数据库\n\n```\nconnection.connect()\n```\n\n这个方法可以接受一个回调用来判断是否连接成功\n\n```\nconnection.connect(function(err) {\n    if (!err) {\n   \t\t// 连接成功\n     } else {\n      // 连接失败 \n     }\n});\nconnection.end();\n```\n\n#### 查询\n\n```\nconnection.query('SELECT 1 + 1 AS solution', function(err, rows, fields) {\n  if (err) throw err;\n  console.log('The solution is: ', rows[0].solution);\n});\n```\n\n同上,接受一个回调来判断是否成功关闭连接\n\n`connection.end(err => console.log(`连接中断${err}`));'\n\n### MongoDB\n\n安装\n\n`npm install -g mongoose`\n配置\n\n```\nvar mongoose = require('mongoose');\nvar options = {\n    db_user: \"root\",\n    db_pwd: \"123456\",\n    db_host: \"localhost\",\n    db_port: 27017,\n    db_name: \"csdn_test\"\n};\n```\n\n#### 连接\n\n```\nvar dbURL = \"mongodb://\" + options.db_user + \":\" + options.db_pwd + \"@\" + options.db_host + \":\" + options.db_port + \"/\" + options.db_name;\n\n// 连接\nmongoose.connect(dbURL);\n\n// 监听连接事件\nmongoose.connection.on('connected', function (err) {\n    if (err) logger.error('Database connection failure');\n});\n\n// 监听错误事件\nmongoose.connection.on('error', function (err) {\n    logger.error('Mongoose connected error ' + err);\n});\n\n// 监听断开事件\nmongoose.connection.on('disconnected', function () {\n    logger.error('Mongoose disconnected');\n});\n查询\n\nmongoose.collection('mamals').find().toArray(function(err, result) {\n  if (err) throw err;\n  console.log(result);\n});\n```\n\n其他方法以后遇到再补充.","source":"_posts/Express学习笔记.md","raw":"---\ntitle: Express学习笔记\nauthor: Arclin\ntags:\n  - Node.js\n  - Express\ncategories:\n  - Node.js\nabbrlink: dcb90c85\ndate: 2017-03-07 00:00:00\n---\nExpress 是 Node.js 的一个轻量级web框架,目前使用EJS模板引擎,该笔记持续更新\n\n<!-- more -->\n\n## supervisor\n\n使用supervisor监听文件改变然后自动重启node服务器,这样子就不用每改一次代码run一遍服务器了\n\n`sudo npm install -g supervisor`\n\n### WebStrom配置supervisor\n\n文件目录结构\n```\n├── app.js        项目入口及程序启动文件。\n├── bin\n│   └── www       存放启动项目的脚本文件，默认www。\n├── package.json  项目依赖配置及开发者信息。\n├── public        静态资源文件夹，默认images、javascripts、stylesheets。\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n├── routes        路由文件相当于MVC中的Controller，默认index.js、users.js。\n│   ├── index.js\n│   └── users.js\n└── views         页面文件，相当于MVC中的view，Ejs模板默认error.ejs、index.ejs\n    ├── error.ejs\n    └── index.ejs\n```\n\n项目依赖配置 `package.json`\n\n`package.json` 里面有项目依赖配置及开发者信息。\n在dependencies后面写上依赖的包名和版本号,然后在项目根目录执行npm install就可以像cocopods一样一次性安装包依赖\n\n## 路由 Routes\n路由用来处理URL的访问\n\n`index.js`\n\n```\nvar express = require('express');   获取express对象\nvar router = express.Router();      获取router对象\n```\n\nrouter有get(),post(),put(),delete()对象,代表接受的请求方式,对应查,增,改,删\n\n```\nrouter.get('/getSomething',function(req,res,next) {});\nrouter.post('/post', function (req,res) {});\nrouter.put('/put',function(req,res,next) {});\nrouter.delete('/delete',function(req,res,next) {});\n```\n\n方法中第一个参数意味着请求路径,例如第一个的请求路径是`http://localhost:3000/getSomething`,第二个参数是获取请求内容和准备返回的响应体.\n\n## Request获取请求参数\n\n例如请求发送了id参数,则`var id = req.params.id;`可以取得\nResponse返回响应体\n\n`send()`方法向浏览器发送一个响应信息\n例如想返回一个json,则res.send({test:id = ${id},name = ${name}});\n当参数为一个Number时，并且没有上面提到的任何一条在响应体里，Express会帮你设置一个响应 体，比如：200会返回字符”OK”。\nres.send(200); // OK\nres.send(404); // Not Found\nres.send(500); // Internal Server Error\n\n## Response重定向\n\n`res.redirect(\"http://www.hubwiz.com\");`\n\n## Response渲染页面\n\n如果想渲染`hello.ejs`页面,`res.render('hello',{title:\"MySQL\",test_params:'aaa'});`\n`hello.ejs`页面通过`<%= title %>`的方式取得title等参数\n\nRequest获取主机名,路径名\n\n`req.host`获取主机名，`req.path`获取请求路径名\n\n## restful 方式路由\n\n```\nrouter.post('/restful/:id/name/:name', function (req,res) {\n  var id  = req.params.id;\n  var name = req.params.name;\n  console.log(JSON.stringify(req.params));\n  res.send({test:`id = ${id},name = ${name}`});\n});\nJSON.stringify() 把js对象转成json\n```\n\n## 数据库\n\n### MySQL\n安装MySQL\n\n`$ npm install mysql`\n\n引入MySQL并配置\n```\nvar mysql      = require('mysql');\nvar connection = mysql.createConnection({\n    host     : 'localhost',\n    user     : 'root',\n    password : '123456',\n    database : 'csdn_test',\n    port     : 3306\n});\n```\n\n连接数据库\n\n```\nconnection.connect()\n```\n\n这个方法可以接受一个回调用来判断是否连接成功\n\n```\nconnection.connect(function(err) {\n    if (!err) {\n   \t\t// 连接成功\n     } else {\n      // 连接失败 \n     }\n});\nconnection.end();\n```\n\n#### 查询\n\n```\nconnection.query('SELECT 1 + 1 AS solution', function(err, rows, fields) {\n  if (err) throw err;\n  console.log('The solution is: ', rows[0].solution);\n});\n```\n\n同上,接受一个回调来判断是否成功关闭连接\n\n`connection.end(err => console.log(`连接中断${err}`));'\n\n### MongoDB\n\n安装\n\n`npm install -g mongoose`\n配置\n\n```\nvar mongoose = require('mongoose');\nvar options = {\n    db_user: \"root\",\n    db_pwd: \"123456\",\n    db_host: \"localhost\",\n    db_port: 27017,\n    db_name: \"csdn_test\"\n};\n```\n\n#### 连接\n\n```\nvar dbURL = \"mongodb://\" + options.db_user + \":\" + options.db_pwd + \"@\" + options.db_host + \":\" + options.db_port + \"/\" + options.db_name;\n\n// 连接\nmongoose.connect(dbURL);\n\n// 监听连接事件\nmongoose.connection.on('connected', function (err) {\n    if (err) logger.error('Database connection failure');\n});\n\n// 监听错误事件\nmongoose.connection.on('error', function (err) {\n    logger.error('Mongoose connected error ' + err);\n});\n\n// 监听断开事件\nmongoose.connection.on('disconnected', function () {\n    logger.error('Mongoose disconnected');\n});\n查询\n\nmongoose.collection('mamals').find().toArray(function(err, result) {\n  if (err) throw err;\n  console.log(result);\n});\n```\n\n其他方法以后遇到再补充.","slug":"Express学习笔记","published":1,"updated":"2021-06-06T18:52:24.961Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyogt000ktnn0h187f7yp","content":"<p>Express 是 Node.js 的一个轻量级web框架,目前使用EJS模板引擎,该笔记持续更新</p>\n<span id=\"more\"></span>\n\n<h2 id=\"supervisor\"><a href=\"#supervisor\" class=\"headerlink\" title=\"supervisor\"></a>supervisor</h2><p>使用supervisor监听文件改变然后自动重启node服务器,这样子就不用每改一次代码run一遍服务器了</p>\n<p><code>sudo npm install -g supervisor</code></p>\n<h3 id=\"WebStrom配置supervisor\"><a href=\"#WebStrom配置supervisor\" class=\"headerlink\" title=\"WebStrom配置supervisor\"></a>WebStrom配置supervisor</h3><p>文件目录结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── app.js        项目入口及程序启动文件。</span><br><span class=\"line\">├── bin</span><br><span class=\"line\">│   └── www       存放启动项目的脚本文件，默认www。</span><br><span class=\"line\">├── package.json  项目依赖配置及开发者信息。</span><br><span class=\"line\">├── public        静态资源文件夹，默认images、javascripts、stylesheets。</span><br><span class=\"line\">│   ├── images</span><br><span class=\"line\">│   ├── javascripts</span><br><span class=\"line\">│   └── stylesheets</span><br><span class=\"line\">├── routes        路由文件相当于MVC中的Controller，默认index.js、users.js。</span><br><span class=\"line\">│   ├── index.js</span><br><span class=\"line\">│   └── users.js</span><br><span class=\"line\">└── views         页面文件，相当于MVC中的view，Ejs模板默认error.ejs、index.ejs</span><br><span class=\"line\">    ├── error.ejs</span><br><span class=\"line\">    └── index.ejs</span><br></pre></td></tr></table></figure>\n\n<p>项目依赖配置 <code>package.json</code></p>\n<p><code>package.json</code> 里面有项目依赖配置及开发者信息。<br>在dependencies后面写上依赖的包名和版本号,然后在项目根目录执行npm install就可以像cocopods一样一次性安装包依赖</p>\n<h2 id=\"路由-Routes\"><a href=\"#路由-Routes\" class=\"headerlink\" title=\"路由 Routes\"></a>路由 Routes</h2><p>路由用来处理URL的访问</p>\n<p><code>index.js</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express &#x3D; require(&#39;express&#39;);   获取express对象</span><br><span class=\"line\">var router &#x3D; express.Router();      获取router对象</span><br></pre></td></tr></table></figure>\n\n<p>router有get(),post(),put(),delete()对象,代表接受的请求方式,对应查,增,改,删</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.get(&#39;&#x2F;getSomething&#39;,function(req,res,next) &#123;&#125;);</span><br><span class=\"line\">router.post(&#39;&#x2F;post&#39;, function (req,res) &#123;&#125;);</span><br><span class=\"line\">router.put(&#39;&#x2F;put&#39;,function(req,res,next) &#123;&#125;);</span><br><span class=\"line\">router.delete(&#39;&#x2F;delete&#39;,function(req,res,next) &#123;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>方法中第一个参数意味着请求路径,例如第一个的请求路径是<code>http://localhost:3000/getSomething</code>,第二个参数是获取请求内容和准备返回的响应体.</p>\n<h2 id=\"Request获取请求参数\"><a href=\"#Request获取请求参数\" class=\"headerlink\" title=\"Request获取请求参数\"></a>Request获取请求参数</h2><p>例如请求发送了id参数,则<code>var id = req.params.id;</code>可以取得<br>Response返回响应体</p>\n<p><code>send()</code>方法向浏览器发送一个响应信息<br>例如想返回一个json,则res.send({test:id = ${id},name = ${name}});<br>当参数为一个Number时，并且没有上面提到的任何一条在响应体里，Express会帮你设置一个响应 体，比如：200会返回字符”OK”。<br>res.send(200); // OK<br>res.send(404); // Not Found<br>res.send(500); // Internal Server Error</p>\n<h2 id=\"Response重定向\"><a href=\"#Response重定向\" class=\"headerlink\" title=\"Response重定向\"></a>Response重定向</h2><p><code>res.redirect(&quot;http://www.hubwiz.com&quot;);</code></p>\n<h2 id=\"Response渲染页面\"><a href=\"#Response渲染页面\" class=\"headerlink\" title=\"Response渲染页面\"></a>Response渲染页面</h2><p>如果想渲染<code>hello.ejs</code>页面,<code>res.render(&#39;hello&#39;,&#123;title:&quot;MySQL&quot;,test_params:&#39;aaa&#39;&#125;);</code><br><code>hello.ejs</code>页面通过<code>&lt;%= title %&gt;</code>的方式取得title等参数</p>\n<p>Request获取主机名,路径名</p>\n<p><code>req.host</code>获取主机名，<code>req.path</code>获取请求路径名</p>\n<h2 id=\"restful-方式路由\"><a href=\"#restful-方式路由\" class=\"headerlink\" title=\"restful 方式路由\"></a>restful 方式路由</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.post(&#39;&#x2F;restful&#x2F;:id&#x2F;name&#x2F;:name&#39;, function (req,res) &#123;</span><br><span class=\"line\">  var id  &#x3D; req.params.id;</span><br><span class=\"line\">  var name &#x3D; req.params.name;</span><br><span class=\"line\">  console.log(JSON.stringify(req.params));</span><br><span class=\"line\">  res.send(&#123;test:&#96;id &#x3D; $&#123;id&#125;,name &#x3D; $&#123;name&#125;&#96;&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">JSON.stringify() 把js对象转成json</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><p>安装MySQL</p>\n<p><code>$ npm install mysql</code></p>\n<p>引入MySQL并配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mysql      &#x3D; require(&#39;mysql&#39;);</span><br><span class=\"line\">var connection &#x3D; mysql.createConnection(&#123;</span><br><span class=\"line\">    host     : &#39;localhost&#39;,</span><br><span class=\"line\">    user     : &#39;root&#39;,</span><br><span class=\"line\">    password : &#39;123456&#39;,</span><br><span class=\"line\">    database : &#39;csdn_test&#39;,</span><br><span class=\"line\">    port     : 3306</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>连接数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.connect()</span><br></pre></td></tr></table></figure>\n\n<p>这个方法可以接受一个回调用来判断是否连接成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.connect(function(err) &#123;</span><br><span class=\"line\">    if (!err) &#123;</span><br><span class=\"line\">   \t\t&#x2F;&#x2F; 连接成功</span><br><span class=\"line\">     &#125; else &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; 连接失败 </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.end();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.query(&#39;SELECT 1 + 1 AS solution&#39;, function(err, rows, fields) &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(&#39;The solution is: &#39;, rows[0].solution);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>同上,接受一个回调来判断是否成功关闭连接</p>\n<p><code>connection.end(err =&gt; console.log(</code>连接中断${err}`));’</p>\n<h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><p>安装</p>\n<p><code>npm install -g mongoose</code><br>配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class=\"line\">var options &#x3D; &#123;</span><br><span class=\"line\">    db_user: &quot;root&quot;,</span><br><span class=\"line\">    db_pwd: &quot;123456&quot;,</span><br><span class=\"line\">    db_host: &quot;localhost&quot;,</span><br><span class=\"line\">    db_port: 27017,</span><br><span class=\"line\">    db_name: &quot;csdn_test&quot;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dbURL &#x3D; &quot;mongodb:&#x2F;&#x2F;&quot; + options.db_user + &quot;:&quot; + options.db_pwd + &quot;@&quot; + options.db_host + &quot;:&quot; + options.db_port + &quot;&#x2F;&quot; + options.db_name;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 连接</span><br><span class=\"line\">mongoose.connect(dbURL);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 监听连接事件</span><br><span class=\"line\">mongoose.connection.on(&#39;connected&#39;, function (err) &#123;</span><br><span class=\"line\">    if (err) logger.error(&#39;Database connection failure&#39;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 监听错误事件</span><br><span class=\"line\">mongoose.connection.on(&#39;error&#39;, function (err) &#123;</span><br><span class=\"line\">    logger.error(&#39;Mongoose connected error &#39; + err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 监听断开事件</span><br><span class=\"line\">mongoose.connection.on(&#39;disconnected&#39;, function () &#123;</span><br><span class=\"line\">    logger.error(&#39;Mongoose disconnected&#39;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">查询</span><br><span class=\"line\"></span><br><span class=\"line\">mongoose.collection(&#39;mamals&#39;).find().toArray(function(err, result) &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>其他方法以后遇到再补充.</p>\n","site":{"data":{}},"excerpt":"<p>Express 是 Node.js 的一个轻量级web框架,目前使用EJS模板引擎,该笔记持续更新</p>","more":"<h2 id=\"supervisor\"><a href=\"#supervisor\" class=\"headerlink\" title=\"supervisor\"></a>supervisor</h2><p>使用supervisor监听文件改变然后自动重启node服务器,这样子就不用每改一次代码run一遍服务器了</p>\n<p><code>sudo npm install -g supervisor</code></p>\n<h3 id=\"WebStrom配置supervisor\"><a href=\"#WebStrom配置supervisor\" class=\"headerlink\" title=\"WebStrom配置supervisor\"></a>WebStrom配置supervisor</h3><p>文件目录结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── app.js        项目入口及程序启动文件。</span><br><span class=\"line\">├── bin</span><br><span class=\"line\">│   └── www       存放启动项目的脚本文件，默认www。</span><br><span class=\"line\">├── package.json  项目依赖配置及开发者信息。</span><br><span class=\"line\">├── public        静态资源文件夹，默认images、javascripts、stylesheets。</span><br><span class=\"line\">│   ├── images</span><br><span class=\"line\">│   ├── javascripts</span><br><span class=\"line\">│   └── stylesheets</span><br><span class=\"line\">├── routes        路由文件相当于MVC中的Controller，默认index.js、users.js。</span><br><span class=\"line\">│   ├── index.js</span><br><span class=\"line\">│   └── users.js</span><br><span class=\"line\">└── views         页面文件，相当于MVC中的view，Ejs模板默认error.ejs、index.ejs</span><br><span class=\"line\">    ├── error.ejs</span><br><span class=\"line\">    └── index.ejs</span><br></pre></td></tr></table></figure>\n\n<p>项目依赖配置 <code>package.json</code></p>\n<p><code>package.json</code> 里面有项目依赖配置及开发者信息。<br>在dependencies后面写上依赖的包名和版本号,然后在项目根目录执行npm install就可以像cocopods一样一次性安装包依赖</p>\n<h2 id=\"路由-Routes\"><a href=\"#路由-Routes\" class=\"headerlink\" title=\"路由 Routes\"></a>路由 Routes</h2><p>路由用来处理URL的访问</p>\n<p><code>index.js</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express &#x3D; require(&#39;express&#39;);   获取express对象</span><br><span class=\"line\">var router &#x3D; express.Router();      获取router对象</span><br></pre></td></tr></table></figure>\n\n<p>router有get(),post(),put(),delete()对象,代表接受的请求方式,对应查,增,改,删</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.get(&#39;&#x2F;getSomething&#39;,function(req,res,next) &#123;&#125;);</span><br><span class=\"line\">router.post(&#39;&#x2F;post&#39;, function (req,res) &#123;&#125;);</span><br><span class=\"line\">router.put(&#39;&#x2F;put&#39;,function(req,res,next) &#123;&#125;);</span><br><span class=\"line\">router.delete(&#39;&#x2F;delete&#39;,function(req,res,next) &#123;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>方法中第一个参数意味着请求路径,例如第一个的请求路径是<code>http://localhost:3000/getSomething</code>,第二个参数是获取请求内容和准备返回的响应体.</p>\n<h2 id=\"Request获取请求参数\"><a href=\"#Request获取请求参数\" class=\"headerlink\" title=\"Request获取请求参数\"></a>Request获取请求参数</h2><p>例如请求发送了id参数,则<code>var id = req.params.id;</code>可以取得<br>Response返回响应体</p>\n<p><code>send()</code>方法向浏览器发送一个响应信息<br>例如想返回一个json,则res.send({test:id = ${id},name = ${name}});<br>当参数为一个Number时，并且没有上面提到的任何一条在响应体里，Express会帮你设置一个响应 体，比如：200会返回字符”OK”。<br>res.send(200); // OK<br>res.send(404); // Not Found<br>res.send(500); // Internal Server Error</p>\n<h2 id=\"Response重定向\"><a href=\"#Response重定向\" class=\"headerlink\" title=\"Response重定向\"></a>Response重定向</h2><p><code>res.redirect(&quot;http://www.hubwiz.com&quot;);</code></p>\n<h2 id=\"Response渲染页面\"><a href=\"#Response渲染页面\" class=\"headerlink\" title=\"Response渲染页面\"></a>Response渲染页面</h2><p>如果想渲染<code>hello.ejs</code>页面,<code>res.render(&#39;hello&#39;,&#123;title:&quot;MySQL&quot;,test_params:&#39;aaa&#39;&#125;);</code><br><code>hello.ejs</code>页面通过<code>&lt;%= title %&gt;</code>的方式取得title等参数</p>\n<p>Request获取主机名,路径名</p>\n<p><code>req.host</code>获取主机名，<code>req.path</code>获取请求路径名</p>\n<h2 id=\"restful-方式路由\"><a href=\"#restful-方式路由\" class=\"headerlink\" title=\"restful 方式路由\"></a>restful 方式路由</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.post(&#39;&#x2F;restful&#x2F;:id&#x2F;name&#x2F;:name&#39;, function (req,res) &#123;</span><br><span class=\"line\">  var id  &#x3D; req.params.id;</span><br><span class=\"line\">  var name &#x3D; req.params.name;</span><br><span class=\"line\">  console.log(JSON.stringify(req.params));</span><br><span class=\"line\">  res.send(&#123;test:&#96;id &#x3D; $&#123;id&#125;,name &#x3D; $&#123;name&#125;&#96;&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">JSON.stringify() 把js对象转成json</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><p>安装MySQL</p>\n<p><code>$ npm install mysql</code></p>\n<p>引入MySQL并配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mysql      &#x3D; require(&#39;mysql&#39;);</span><br><span class=\"line\">var connection &#x3D; mysql.createConnection(&#123;</span><br><span class=\"line\">    host     : &#39;localhost&#39;,</span><br><span class=\"line\">    user     : &#39;root&#39;,</span><br><span class=\"line\">    password : &#39;123456&#39;,</span><br><span class=\"line\">    database : &#39;csdn_test&#39;,</span><br><span class=\"line\">    port     : 3306</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>连接数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.connect()</span><br></pre></td></tr></table></figure>\n\n<p>这个方法可以接受一个回调用来判断是否连接成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.connect(function(err) &#123;</span><br><span class=\"line\">    if (!err) &#123;</span><br><span class=\"line\">   \t\t&#x2F;&#x2F; 连接成功</span><br><span class=\"line\">     &#125; else &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; 连接失败 </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.end();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.query(&#39;SELECT 1 + 1 AS solution&#39;, function(err, rows, fields) &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(&#39;The solution is: &#39;, rows[0].solution);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>同上,接受一个回调来判断是否成功关闭连接</p>\n<p><code>connection.end(err =&gt; console.log(</code>连接中断${err}`));’</p>\n<h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><p>安装</p>\n<p><code>npm install -g mongoose</code><br>配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class=\"line\">var options &#x3D; &#123;</span><br><span class=\"line\">    db_user: &quot;root&quot;,</span><br><span class=\"line\">    db_pwd: &quot;123456&quot;,</span><br><span class=\"line\">    db_host: &quot;localhost&quot;,</span><br><span class=\"line\">    db_port: 27017,</span><br><span class=\"line\">    db_name: &quot;csdn_test&quot;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dbURL &#x3D; &quot;mongodb:&#x2F;&#x2F;&quot; + options.db_user + &quot;:&quot; + options.db_pwd + &quot;@&quot; + options.db_host + &quot;:&quot; + options.db_port + &quot;&#x2F;&quot; + options.db_name;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 连接</span><br><span class=\"line\">mongoose.connect(dbURL);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 监听连接事件</span><br><span class=\"line\">mongoose.connection.on(&#39;connected&#39;, function (err) &#123;</span><br><span class=\"line\">    if (err) logger.error(&#39;Database connection failure&#39;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 监听错误事件</span><br><span class=\"line\">mongoose.connection.on(&#39;error&#39;, function (err) &#123;</span><br><span class=\"line\">    logger.error(&#39;Mongoose connected error &#39; + err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 监听断开事件</span><br><span class=\"line\">mongoose.connection.on(&#39;disconnected&#39;, function () &#123;</span><br><span class=\"line\">    logger.error(&#39;Mongoose disconnected&#39;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">查询</span><br><span class=\"line\"></span><br><span class=\"line\">mongoose.collection(&#39;mamals&#39;).find().toArray(function(err, result) &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>其他方法以后遇到再补充.</p>"},{"title":"Jenkins+Git+Cocoapods+Fir.im实现iOS应用持续集成","author":"Arclin","abbrlink":"13ecfb47","date":"2017-02-07T16:00:00.000Z","_content":"Jenkins 可以定时检测 Git 上的某个分支的代码，打包生成 ipa 后直接上传到 Fir.im\n\n<!-- more -->\n\n### 安装 Jenkins\n\n#### JDK\nJenkins 是基于 Java 的一个应用，所以你需要先有JDK ，安装 JDK 网上有很多资料这里就跳过了\n\n使用 Brew 安装 Jenkins\n\n```\nbrew install jenkins\n```\n\n### 启动 Jenkins\n\n`jenkins` 或者 `java -jar /usr/local/opt/jenkins/libexec/jenkins.war --httpPort=8088` 这种方法可以指定端口号执行\n\n如果想自动启动，需要先执行以下命令，创建启动项\n`ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents`\n\n可以编辑一下`~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist`这个文件\n`open ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist`\n\n想要让局域网都可以访问，需要把`–httpListenAddress=127.0.0.1`改成自己的局域网IP\n\n手动启动启动项可以执行\n\n```\nlaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist\n```\n\n### 配置Xcode项目\n\n使用 CocoaPods\n终端进入已有项目的目录下，执行\n\n填写 podfile 类似下面这样子\n\n```\ntarget 'TestJenkins' do\n\tpod 'MJExtension'\n  target 'TestJenkinsTests' do\n    inherit! :search_paths\n  end\nend\n```\n\n然后执行 `pod install`\n\n执行完成之后打开`TestJenkins.xcworkspace`\n\n打开 `Product - Scheme - Manage Scheme`\n\n把 `Share` 下面的勾都打上\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/888.png)\n\n\n### 上传到Git\n在终端进入该项目根目录，执行`git init`\n\n在 Git托管平台上新建一个项目，得到 git 远程仓库地址，然后在项目中添加该远程地址\n\n`git remote add origin git@git.coding.net:Arclin/TestJenkins.git`\n\n新的项目或许还需要`git pull origin master` pull一下Readme等东西\n\n1. `git add . ` 添加项目文件\n2. `git git commit -m \"initial\"` 提交更改\n3. `git push origin master` 推送到 master远程分支\n\n### 配置 Jenkins\n\n在浏览器中打开 Jenkins,比如我指定了8088端口的话，那就打开`http://localhost:8088/`,然后根据提示安装，注意里面有一个选择插件的界面，根据需要选择就好。\n\n#### 安装插件\n系统管理 - 插件管理 可以安装插件,建议安装\n\n- Git Server Plugin  \n- Git Client Plugin  \n- fir-plugin  （安装教程看 http://www.jianshu.com/p/9a245918a219）\n- Xcode integration\n- Keychains and Provisioning Profiles Management\n\n下面我们就会用上这些插件\n\n#### 新建一个Job\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/999.png)\n\n进行一系列配置\n设置包的保留天数还有天数。\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1001.png)\n\n源码管理\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1002.png)\n\n要先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。\n\n![](http://upload-images.jianshu.io/upload_images/1194012-6d1b6f56e4dac318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n构建触发器\n构建触发器设置这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。\n\n不过这里有两个配置还是需要是配置的\n\nPoll SCM (poll source code management) 轮询源码管理\n需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次\nBuild periodically (定时build)\n一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。\n\n格式是这样的\n\n分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日)\n\n例如 `H/10 * * * *` 就是每十分钟一次\n\n#### 构建环境\niOS打包需要签名文件和证书，所以这部分我们勾选“Keychains and Code Signing Identities”和“Mobile Provisioning Profiles”。\n\n在这之前\n\n在系统设置中进入Keychains and Provisioning Profiles Management页面，点击“浏览”按钮，分别上传自己的keychain和证书（是这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下）。上传成功后，我们再为keychain指明签名文件的名称。点击“Add Code Signing Identity”，最后添加成功后如下图所示\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1003.png)\n\npassword 填写你的用户密码\n\nCode Signing Identity 的内容来源是这里\n\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_1.png?version=1&modificationDate=1375867279000)\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_2.png?version=2&modificationDate=1375868440000)\n\nProvision Profiles Directory Path 的内容填上\n\n`/Users/Shared/Jenkins/Library/MobileDevice`\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/Screen+Shot+2013-08-07+at+14.17.05.png?version=1&modificationDate=1375877888000)\n\n回到项目配置\n\n这样子填写\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1004.png)\n\n#### 构建\n点击”增加构建步骤”,先后选择 XCode 和 Execute Shell\n\nXCode 配置如下\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1005.png)\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1006.png)\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1007.png)\n\nExecute Shell 只要写入这个命令就好\n\n`fir publish /Users/Arclin/.jenkins/workspace/TestJenkins/build/TestJenkins.ipa --token=你的fir.im Token`\n\n如果没安装 fir 命令行工具的话\n\n用`gem install fir-cli` 安装\n如果发现问题就看这里\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1008.png)\n\n然后保存回到Jenkins项目首页，点击立即构建，然后如果成功的话就会像下图那样子\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1009.png)\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1010.png)\n\n每隔一个触发器设定的时间，他就会检查一下 git 上面的代码，如果有发现更新就会自动 pull然后打包并上传到 fir.im\n\n结束","source":"_posts/Jenkins-Git-CocoaPods-Fir-im实现iOS应用持续集成.md","raw":"---\ntitle: Jenkins+Git+Cocoapods+Fir.im实现iOS应用持续集成\nauthor: Arclin\ntags:\n  - Jenkins\n  - Git\n  - Cocoapods\n  - Fir\ncategories:\n  - iOS\nabbrlink: 13ecfb47\ndate: 2017-02-08 00:00:00\n---\nJenkins 可以定时检测 Git 上的某个分支的代码，打包生成 ipa 后直接上传到 Fir.im\n\n<!-- more -->\n\n### 安装 Jenkins\n\n#### JDK\nJenkins 是基于 Java 的一个应用，所以你需要先有JDK ，安装 JDK 网上有很多资料这里就跳过了\n\n使用 Brew 安装 Jenkins\n\n```\nbrew install jenkins\n```\n\n### 启动 Jenkins\n\n`jenkins` 或者 `java -jar /usr/local/opt/jenkins/libexec/jenkins.war --httpPort=8088` 这种方法可以指定端口号执行\n\n如果想自动启动，需要先执行以下命令，创建启动项\n`ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents`\n\n可以编辑一下`~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist`这个文件\n`open ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist`\n\n想要让局域网都可以访问，需要把`–httpListenAddress=127.0.0.1`改成自己的局域网IP\n\n手动启动启动项可以执行\n\n```\nlaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist\n```\n\n### 配置Xcode项目\n\n使用 CocoaPods\n终端进入已有项目的目录下，执行\n\n填写 podfile 类似下面这样子\n\n```\ntarget 'TestJenkins' do\n\tpod 'MJExtension'\n  target 'TestJenkinsTests' do\n    inherit! :search_paths\n  end\nend\n```\n\n然后执行 `pod install`\n\n执行完成之后打开`TestJenkins.xcworkspace`\n\n打开 `Product - Scheme - Manage Scheme`\n\n把 `Share` 下面的勾都打上\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/888.png)\n\n\n### 上传到Git\n在终端进入该项目根目录，执行`git init`\n\n在 Git托管平台上新建一个项目，得到 git 远程仓库地址，然后在项目中添加该远程地址\n\n`git remote add origin git@git.coding.net:Arclin/TestJenkins.git`\n\n新的项目或许还需要`git pull origin master` pull一下Readme等东西\n\n1. `git add . ` 添加项目文件\n2. `git git commit -m \"initial\"` 提交更改\n3. `git push origin master` 推送到 master远程分支\n\n### 配置 Jenkins\n\n在浏览器中打开 Jenkins,比如我指定了8088端口的话，那就打开`http://localhost:8088/`,然后根据提示安装，注意里面有一个选择插件的界面，根据需要选择就好。\n\n#### 安装插件\n系统管理 - 插件管理 可以安装插件,建议安装\n\n- Git Server Plugin  \n- Git Client Plugin  \n- fir-plugin  （安装教程看 http://www.jianshu.com/p/9a245918a219）\n- Xcode integration\n- Keychains and Provisioning Profiles Management\n\n下面我们就会用上这些插件\n\n#### 新建一个Job\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/999.png)\n\n进行一系列配置\n设置包的保留天数还有天数。\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1001.png)\n\n源码管理\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1002.png)\n\n要先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。\n\n![](http://upload-images.jianshu.io/upload_images/1194012-6d1b6f56e4dac318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n构建触发器\n构建触发器设置这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。\n\n不过这里有两个配置还是需要是配置的\n\nPoll SCM (poll source code management) 轮询源码管理\n需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次\nBuild periodically (定时build)\n一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。\n\n格式是这样的\n\n分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日)\n\n例如 `H/10 * * * *` 就是每十分钟一次\n\n#### 构建环境\niOS打包需要签名文件和证书，所以这部分我们勾选“Keychains and Code Signing Identities”和“Mobile Provisioning Profiles”。\n\n在这之前\n\n在系统设置中进入Keychains and Provisioning Profiles Management页面，点击“浏览”按钮，分别上传自己的keychain和证书（是这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下）。上传成功后，我们再为keychain指明签名文件的名称。点击“Add Code Signing Identity”，最后添加成功后如下图所示\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1003.png)\n\npassword 填写你的用户密码\n\nCode Signing Identity 的内容来源是这里\n\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_1.png?version=1&modificationDate=1375867279000)\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_2.png?version=2&modificationDate=1375868440000)\n\nProvision Profiles Directory Path 的内容填上\n\n`/Users/Shared/Jenkins/Library/MobileDevice`\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/Screen+Shot+2013-08-07+at+14.17.05.png?version=1&modificationDate=1375877888000)\n\n回到项目配置\n\n这样子填写\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1004.png)\n\n#### 构建\n点击”增加构建步骤”,先后选择 XCode 和 Execute Shell\n\nXCode 配置如下\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1005.png)\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1006.png)\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1007.png)\n\nExecute Shell 只要写入这个命令就好\n\n`fir publish /Users/Arclin/.jenkins/workspace/TestJenkins/build/TestJenkins.ipa --token=你的fir.im Token`\n\n如果没安装 fir 命令行工具的话\n\n用`gem install fir-cli` 安装\n如果发现问题就看这里\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1008.png)\n\n然后保存回到Jenkins项目首页，点击立即构建，然后如果成功的话就会像下图那样子\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1009.png)\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1010.png)\n\n每隔一个触发器设定的时间，他就会检查一下 git 上面的代码，如果有发现更新就会自动 pull然后打包并上传到 fir.im\n\n结束","slug":"Jenkins-Git-CocoaPods-Fir-im实现iOS应用持续集成","published":1,"updated":"2021-06-06T18:52:24.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyogu000ptnn07wf4akn8","content":"<p>Jenkins 可以定时检测 Git 上的某个分支的代码，打包生成 ipa 后直接上传到 Fir.im</p>\n<span id=\"more\"></span>\n\n<h3 id=\"安装-Jenkins\"><a href=\"#安装-Jenkins\" class=\"headerlink\" title=\"安装 Jenkins\"></a>安装 Jenkins</h3><h4 id=\"JDK\"><a href=\"#JDK\" class=\"headerlink\" title=\"JDK\"></a>JDK</h4><p>Jenkins 是基于 Java 的一个应用，所以你需要先有JDK ，安装 JDK 网上有很多资料这里就跳过了</p>\n<p>使用 Brew 安装 Jenkins</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install jenkins</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动-Jenkins\"><a href=\"#启动-Jenkins\" class=\"headerlink\" title=\"启动 Jenkins\"></a>启动 Jenkins</h3><p><code>jenkins</code> 或者 <code>java -jar /usr/local/opt/jenkins/libexec/jenkins.war --httpPort=8088</code> 这种方法可以指定端口号执行</p>\n<p>如果想自动启动，需要先执行以下命令，创建启动项<br><code>ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents</code></p>\n<p>可以编辑一下<code>~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</code>这个文件<br><code>open ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</code></p>\n<p>想要让局域网都可以访问，需要把<code>–httpListenAddress=127.0.0.1</code>改成自己的局域网IP</p>\n<p>手动启动启动项可以执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">launchctl load ~&#x2F;Library&#x2F;LaunchAgents&#x2F;homebrew.mxcl.jenkins.plist</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置Xcode项目\"><a href=\"#配置Xcode项目\" class=\"headerlink\" title=\"配置Xcode项目\"></a>配置Xcode项目</h3><p>使用 CocoaPods<br>终端进入已有项目的目录下，执行</p>\n<p>填写 podfile 类似下面这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target &#39;TestJenkins&#39; do</span><br><span class=\"line\">\tpod &#39;MJExtension&#39;</span><br><span class=\"line\">  target &#39;TestJenkinsTests&#39; do</span><br><span class=\"line\">    inherit! :search_paths</span><br><span class=\"line\">  end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>然后执行 <code>pod install</code></p>\n<p>执行完成之后打开<code>TestJenkins.xcworkspace</code></p>\n<p>打开 <code>Product - Scheme - Manage Scheme</code></p>\n<p>把 <code>Share</code> 下面的勾都打上</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/888.png\"></p>\n<h3 id=\"上传到Git\"><a href=\"#上传到Git\" class=\"headerlink\" title=\"上传到Git\"></a>上传到Git</h3><p>在终端进入该项目根目录，执行<code>git init</code></p>\n<p>在 Git托管平台上新建一个项目，得到 git 远程仓库地址，然后在项目中添加该远程地址</p>\n<p><code>git remote add origin git@git.coding.net:Arclin/TestJenkins.git</code></p>\n<p>新的项目或许还需要<code>git pull origin master</code> pull一下Readme等东西</p>\n<ol>\n<li><code>git add . </code> 添加项目文件</li>\n<li><code>git git commit -m &quot;initial&quot;</code> 提交更改</li>\n<li><code>git push origin master</code> 推送到 master远程分支</li>\n</ol>\n<h3 id=\"配置-Jenkins\"><a href=\"#配置-Jenkins\" class=\"headerlink\" title=\"配置 Jenkins\"></a>配置 Jenkins</h3><p>在浏览器中打开 Jenkins,比如我指定了8088端口的话，那就打开<code>http://localhost:8088/</code>,然后根据提示安装，注意里面有一个选择插件的界面，根据需要选择就好。</p>\n<h4 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h4><p>系统管理 - 插件管理 可以安装插件,建议安装</p>\n<ul>\n<li>Git Server Plugin  </li>\n<li>Git Client Plugin  </li>\n<li>fir-plugin  （安装教程看 <a href=\"http://www.jianshu.com/p/9a245918a219%EF%BC%89\">http://www.jianshu.com/p/9a245918a219）</a></li>\n<li>Xcode integration</li>\n<li>Keychains and Provisioning Profiles Management</li>\n</ul>\n<p>下面我们就会用上这些插件</p>\n<h4 id=\"新建一个Job\"><a href=\"#新建一个Job\" class=\"headerlink\" title=\"新建一个Job\"></a>新建一个Job</h4><p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/999.png\"></p>\n<p>进行一系列配置<br>设置包的保留天数还有天数。</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1001.png\"></p>\n<p>源码管理</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1002.png\"></p>\n<p>要先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1194012-6d1b6f56e4dac318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>构建触发器<br>构建触发器设置这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。</p>\n<p>不过这里有两个配置还是需要是配置的</p>\n<p>Poll SCM (poll source code management) 轮询源码管理<br>需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次<br>Build periodically (定时build)<br>一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。</p>\n<p>格式是这样的</p>\n<p>分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日)</p>\n<p>例如 <code>H/10 * * * *</code> 就是每十分钟一次</p>\n<h4 id=\"构建环境\"><a href=\"#构建环境\" class=\"headerlink\" title=\"构建环境\"></a>构建环境</h4><p>iOS打包需要签名文件和证书，所以这部分我们勾选“Keychains and Code Signing Identities”和“Mobile Provisioning Profiles”。</p>\n<p>在这之前</p>\n<p>在系统设置中进入Keychains and Provisioning Profiles Management页面，点击“浏览”按钮，分别上传自己的keychain和证书（是这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下）。上传成功后，我们再为keychain指明签名文件的名称。点击“Add Code Signing Identity”，最后添加成功后如下图所示</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1003.png\"></p>\n<p>password 填写你的用户密码</p>\n<p>Code Signing Identity 的内容来源是这里</p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_1.png?version=1&modificationDate=1375867279000\"></p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_2.png?version=2&modificationDate=1375868440000\"></p>\n<p>Provision Profiles Directory Path 的内容填上</p>\n<p><code>/Users/Shared/Jenkins/Library/MobileDevice</code></p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/Screen+Shot+2013-08-07+at+14.17.05.png?version=1&modificationDate=1375877888000\"></p>\n<p>回到项目配置</p>\n<p>这样子填写</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1004.png\"></p>\n<h4 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h4><p>点击”增加构建步骤”,先后选择 XCode 和 Execute Shell</p>\n<p>XCode 配置如下</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1005.png\"><br><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1006.png\"><br><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1007.png\"></p>\n<p>Execute Shell 只要写入这个命令就好</p>\n<p><code>fir publish /Users/Arclin/.jenkins/workspace/TestJenkins/build/TestJenkins.ipa --token=你的fir.im Token</code></p>\n<p>如果没安装 fir 命令行工具的话</p>\n<p>用<code>gem install fir-cli</code> 安装<br>如果发现问题就看这里</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1008.png\"></p>\n<p>然后保存回到Jenkins项目首页，点击立即构建，然后如果成功的话就会像下图那样子</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1009.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1010.png\"></p>\n<p>每隔一个触发器设定的时间，他就会检查一下 git 上面的代码，如果有发现更新就会自动 pull然后打包并上传到 fir.im</p>\n<p>结束</p>\n","site":{"data":{}},"excerpt":"<p>Jenkins 可以定时检测 Git 上的某个分支的代码，打包生成 ipa 后直接上传到 Fir.im</p>","more":"<h3 id=\"安装-Jenkins\"><a href=\"#安装-Jenkins\" class=\"headerlink\" title=\"安装 Jenkins\"></a>安装 Jenkins</h3><h4 id=\"JDK\"><a href=\"#JDK\" class=\"headerlink\" title=\"JDK\"></a>JDK</h4><p>Jenkins 是基于 Java 的一个应用，所以你需要先有JDK ，安装 JDK 网上有很多资料这里就跳过了</p>\n<p>使用 Brew 安装 Jenkins</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install jenkins</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动-Jenkins\"><a href=\"#启动-Jenkins\" class=\"headerlink\" title=\"启动 Jenkins\"></a>启动 Jenkins</h3><p><code>jenkins</code> 或者 <code>java -jar /usr/local/opt/jenkins/libexec/jenkins.war --httpPort=8088</code> 这种方法可以指定端口号执行</p>\n<p>如果想自动启动，需要先执行以下命令，创建启动项<br><code>ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents</code></p>\n<p>可以编辑一下<code>~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</code>这个文件<br><code>open ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</code></p>\n<p>想要让局域网都可以访问，需要把<code>–httpListenAddress=127.0.0.1</code>改成自己的局域网IP</p>\n<p>手动启动启动项可以执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">launchctl load ~&#x2F;Library&#x2F;LaunchAgents&#x2F;homebrew.mxcl.jenkins.plist</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置Xcode项目\"><a href=\"#配置Xcode项目\" class=\"headerlink\" title=\"配置Xcode项目\"></a>配置Xcode项目</h3><p>使用 CocoaPods<br>终端进入已有项目的目录下，执行</p>\n<p>填写 podfile 类似下面这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target &#39;TestJenkins&#39; do</span><br><span class=\"line\">\tpod &#39;MJExtension&#39;</span><br><span class=\"line\">  target &#39;TestJenkinsTests&#39; do</span><br><span class=\"line\">    inherit! :search_paths</span><br><span class=\"line\">  end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>然后执行 <code>pod install</code></p>\n<p>执行完成之后打开<code>TestJenkins.xcworkspace</code></p>\n<p>打开 <code>Product - Scheme - Manage Scheme</code></p>\n<p>把 <code>Share</code> 下面的勾都打上</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/888.png\"></p>\n<h3 id=\"上传到Git\"><a href=\"#上传到Git\" class=\"headerlink\" title=\"上传到Git\"></a>上传到Git</h3><p>在终端进入该项目根目录，执行<code>git init</code></p>\n<p>在 Git托管平台上新建一个项目，得到 git 远程仓库地址，然后在项目中添加该远程地址</p>\n<p><code>git remote add origin git@git.coding.net:Arclin/TestJenkins.git</code></p>\n<p>新的项目或许还需要<code>git pull origin master</code> pull一下Readme等东西</p>\n<ol>\n<li><code>git add . </code> 添加项目文件</li>\n<li><code>git git commit -m &quot;initial&quot;</code> 提交更改</li>\n<li><code>git push origin master</code> 推送到 master远程分支</li>\n</ol>\n<h3 id=\"配置-Jenkins\"><a href=\"#配置-Jenkins\" class=\"headerlink\" title=\"配置 Jenkins\"></a>配置 Jenkins</h3><p>在浏览器中打开 Jenkins,比如我指定了8088端口的话，那就打开<code>http://localhost:8088/</code>,然后根据提示安装，注意里面有一个选择插件的界面，根据需要选择就好。</p>\n<h4 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h4><p>系统管理 - 插件管理 可以安装插件,建议安装</p>\n<ul>\n<li>Git Server Plugin  </li>\n<li>Git Client Plugin  </li>\n<li>fir-plugin  （安装教程看 <a href=\"http://www.jianshu.com/p/9a245918a219%EF%BC%89\">http://www.jianshu.com/p/9a245918a219）</a></li>\n<li>Xcode integration</li>\n<li>Keychains and Provisioning Profiles Management</li>\n</ul>\n<p>下面我们就会用上这些插件</p>\n<h4 id=\"新建一个Job\"><a href=\"#新建一个Job\" class=\"headerlink\" title=\"新建一个Job\"></a>新建一个Job</h4><p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/999.png\"></p>\n<p>进行一系列配置<br>设置包的保留天数还有天数。</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1001.png\"></p>\n<p>源码管理</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1002.png\"></p>\n<p>要先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1194012-6d1b6f56e4dac318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>构建触发器<br>构建触发器设置这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。</p>\n<p>不过这里有两个配置还是需要是配置的</p>\n<p>Poll SCM (poll source code management) 轮询源码管理<br>需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次<br>Build periodically (定时build)<br>一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。</p>\n<p>格式是这样的</p>\n<p>分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日)</p>\n<p>例如 <code>H/10 * * * *</code> 就是每十分钟一次</p>\n<h4 id=\"构建环境\"><a href=\"#构建环境\" class=\"headerlink\" title=\"构建环境\"></a>构建环境</h4><p>iOS打包需要签名文件和证书，所以这部分我们勾选“Keychains and Code Signing Identities”和“Mobile Provisioning Profiles”。</p>\n<p>在这之前</p>\n<p>在系统设置中进入Keychains and Provisioning Profiles Management页面，点击“浏览”按钮，分别上传自己的keychain和证书（是这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下）。上传成功后，我们再为keychain指明签名文件的名称。点击“Add Code Signing Identity”，最后添加成功后如下图所示</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1003.png\"></p>\n<p>password 填写你的用户密码</p>\n<p>Code Signing Identity 的内容来源是这里</p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_1.png?version=1&modificationDate=1375867279000\"></p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_2.png?version=2&modificationDate=1375868440000\"></p>\n<p>Provision Profiles Directory Path 的内容填上</p>\n<p><code>/Users/Shared/Jenkins/Library/MobileDevice</code></p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/Screen+Shot+2013-08-07+at+14.17.05.png?version=1&modificationDate=1375877888000\"></p>\n<p>回到项目配置</p>\n<p>这样子填写</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1004.png\"></p>\n<h4 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h4><p>点击”增加构建步骤”,先后选择 XCode 和 Execute Shell</p>\n<p>XCode 配置如下</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1005.png\"><br><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1006.png\"><br><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1007.png\"></p>\n<p>Execute Shell 只要写入这个命令就好</p>\n<p><code>fir publish /Users/Arclin/.jenkins/workspace/TestJenkins/build/TestJenkins.ipa --token=你的fir.im Token</code></p>\n<p>如果没安装 fir 命令行工具的话</p>\n<p>用<code>gem install fir-cli</code> 安装<br>如果发现问题就看这里</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1008.png\"></p>\n<p>然后保存回到Jenkins项目首页，点击立即构建，然后如果成功的话就会像下图那样子</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1009.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1010.png\"></p>\n<p>每隔一个触发器设定的时间，他就会检查一下 git 上面的代码，如果有发现更新就会自动 pull然后打包并上传到 fir.im</p>\n<p>结束</p>"},{"title":"Let’s Encrypt 免费https","author":"Arclin","abbrlink":"feddc8a5","date":"2018-02-18T13:34:00.000Z","_content":"在服务器配置免费的CA证书\n\n<!-- more -->\n\n下载源码\n\n```\ngit clone https://github.com/letsencrypt/letsencrypt\n```\n\n生成证书\n\n```\ncd letsencrypt/\n\n./letsencrypt-auto certonly --standalone --email arclin@dankal.cn -d arclin.me -d g.arclin.me \n```\n\n默认有效期90天\n\n自动续期\n\n```\n./letsencrypt-auto certonly --renew-by-default --email arclin@dankal.cn -d arclin.me -d g.arclin.me\n```\n\n报错及解决\n\n- 报错\nProblem binding to port 443: Could not bind to IPv4 or IPv6.\n\n- 解决\n停止443端口\n比如 关闭ShadowSocks服务(ssserver)  关闭nginx\n\n- 报错 \nFailed authorization procedure. arclin.me (tls-sni-01): urn:acme:error:connection :: The server could not connect to the client to verify the domain :: Connection refused\n\n- 解决\n在DNSPod 绑定 arclin.me域名到本服务器\n\n修改Nginx 配置\n\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    listen 443 ssl http2; #443这里是https的端口  开启http2服务需要安装http_v2_module模块\n    ssl_certificate /etc/letsencrypt/live/arclin.me/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/arclin.me/privkey.pem;\n    resolver 8.8.8.8;\n    location / {\n        google on;\n    }\n  }\n```\n\n重启服务\n\n```\nnginx -c /usr/local/nginx/conf/nginx.conf\nnginx -s reload\nservice nginx restart\n```","source":"_posts/Let’s-Encrypt-免费https.md","raw":"---\ntitle: Let’s Encrypt 免费https\nauthor: Arclin\ntags:\n  - Let's Encrypt\n  - https\ncategories:\n  - Linux\nabbrlink: feddc8a5\ndate: 2018-02-18 21:34:00\n---\n在服务器配置免费的CA证书\n\n<!-- more -->\n\n下载源码\n\n```\ngit clone https://github.com/letsencrypt/letsencrypt\n```\n\n生成证书\n\n```\ncd letsencrypt/\n\n./letsencrypt-auto certonly --standalone --email arclin@dankal.cn -d arclin.me -d g.arclin.me \n```\n\n默认有效期90天\n\n自动续期\n\n```\n./letsencrypt-auto certonly --renew-by-default --email arclin@dankal.cn -d arclin.me -d g.arclin.me\n```\n\n报错及解决\n\n- 报错\nProblem binding to port 443: Could not bind to IPv4 or IPv6.\n\n- 解决\n停止443端口\n比如 关闭ShadowSocks服务(ssserver)  关闭nginx\n\n- 报错 \nFailed authorization procedure. arclin.me (tls-sni-01): urn:acme:error:connection :: The server could not connect to the client to verify the domain :: Connection refused\n\n- 解决\n在DNSPod 绑定 arclin.me域名到本服务器\n\n修改Nginx 配置\n\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    listen 443 ssl http2; #443这里是https的端口  开启http2服务需要安装http_v2_module模块\n    ssl_certificate /etc/letsencrypt/live/arclin.me/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/arclin.me/privkey.pem;\n    resolver 8.8.8.8;\n    location / {\n        google on;\n    }\n  }\n```\n\n重启服务\n\n```\nnginx -c /usr/local/nginx/conf/nginx.conf\nnginx -s reload\nservice nginx restart\n```","slug":"Let’s-Encrypt-免费https","published":1,"updated":"2021-06-06T18:52:24.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyogv000stnn00vno3fu6","content":"<p>在服务器配置免费的CA证书</p>\n<span id=\"more\"></span>\n\n<p>下载源码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;letsencrypt&#x2F;letsencrypt</span><br></pre></td></tr></table></figure>\n\n<p>生成证书</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd letsencrypt&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">.&#x2F;letsencrypt-auto certonly --standalone --email arclin@dankal.cn -d arclin.me -d g.arclin.me </span><br></pre></td></tr></table></figure>\n\n<p>默认有效期90天</p>\n<p>自动续期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;letsencrypt-auto certonly --renew-by-default --email arclin@dankal.cn -d arclin.me -d g.arclin.me</span><br></pre></td></tr></table></figure>\n\n<p>报错及解决</p>\n<ul>\n<li><p>报错<br>Problem binding to port 443: Could not bind to IPv4 or IPv6.</p>\n</li>\n<li><p>解决<br>停止443端口<br>比如 关闭ShadowSocks服务(ssserver)  关闭nginx</p>\n</li>\n<li><p>报错<br>Failed authorization procedure. arclin.me (tls-sni-01): urn:acme:error:connection :: The server could not connect to the client to verify the domain :: Connection refused</p>\n</li>\n<li><p>解决<br>在DNSPod 绑定 arclin.me域名到本服务器</p>\n</li>\n</ul>\n<p>修改Nginx 配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    listen 443 ssl http2; #443这里是https的端口  开启http2服务需要安装http_v2_module模块</span><br><span class=\"line\">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;fullchain.pem;</span><br><span class=\"line\">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;privkey.pem;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location &#x2F; &#123;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>重启服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class=\"line\">nginx -s reload</span><br><span class=\"line\">service nginx restart</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>在服务器配置免费的CA证书</p>","more":"<p>下载源码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;letsencrypt&#x2F;letsencrypt</span><br></pre></td></tr></table></figure>\n\n<p>生成证书</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd letsencrypt&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">.&#x2F;letsencrypt-auto certonly --standalone --email arclin@dankal.cn -d arclin.me -d g.arclin.me </span><br></pre></td></tr></table></figure>\n\n<p>默认有效期90天</p>\n<p>自动续期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;letsencrypt-auto certonly --renew-by-default --email arclin@dankal.cn -d arclin.me -d g.arclin.me</span><br></pre></td></tr></table></figure>\n\n<p>报错及解决</p>\n<ul>\n<li><p>报错<br>Problem binding to port 443: Could not bind to IPv4 or IPv6.</p>\n</li>\n<li><p>解决<br>停止443端口<br>比如 关闭ShadowSocks服务(ssserver)  关闭nginx</p>\n</li>\n<li><p>报错<br>Failed authorization procedure. arclin.me (tls-sni-01): urn:acme:error:connection :: The server could not connect to the client to verify the domain :: Connection refused</p>\n</li>\n<li><p>解决<br>在DNSPod 绑定 arclin.me域名到本服务器</p>\n</li>\n</ul>\n<p>修改Nginx 配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    listen 443 ssl http2; #443这里是https的端口  开启http2服务需要安装http_v2_module模块</span><br><span class=\"line\">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;fullchain.pem;</span><br><span class=\"line\">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;privkey.pem;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location &#x2F; &#123;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>重启服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class=\"line\">nginx -s reload</span><br><span class=\"line\">service nginx restart</span><br></pre></td></tr></table></figure>"},{"title":"MongoDB笔记","author":"Arclin","abbrlink":"b3b38c86","date":"2018-02-18T13:58:00.000Z","_content":"MongoDB笔记\n\n<!-- more -->\n\nOS X安装\n\n`brew install mongodb`\n\n进入mongodb\n\n`mongo`\n\n查看所有数据库\n\n`db`\n\n查看所有*有数据的*数据库并带上内存信息\n\n`show dbs`\n\n创建/进入某个数据库\n\n`use DATABASE_NAME`\n\n删除数据库(需要先`use DATABASE_NAME` 进入数据库)\n\n`db.dropDatabase()`\n\n插入数据\n\n`db.DATABASE_NAME.insert({“COLUMN_NAME”:”VALUE”,”COLUMN_NAME_SECOND”:”SECOND_VALUE”})`\n\n查询所有数据\n\n`db.DATABASE_NAME.find()`\n\n查询所有数据并pretty形式打印\n\n`db.DATABASE_NAME.find().pretty()`\n\n更新满足条件的第一条数据\n\n`db.DATABASE_NAME.update({‘条件字段’:’条件值’},{$set:{‘更新字段’:’更新值’,‘更新字段2’:’更新值2’}})`\n\n更新满足条件的所有数据\n\n`db.DATABASE_NAME.update({‘条件字段’:’条件值’},{$set:{‘更新字段’:’更新值’,‘更新字段2’:’更新值2’},{multi:true}})`\n\n替换整条数据的内容(根据ID查找)\n\n`db.DATABASE_NAME.save({“_id”:ObjectId(“xxxxx”),”要替换的字段名”:”要替换的字段名”,”要替换的字段名2”:”要替换的字段名2”})`\n\n删除数据\n\n`db.DATABASE_NAME.remove({‘条件字段’:’条件值’})`\n\n删除第一条找到的记录\n\n`db.DATABASE_NAME.remove({‘条件字段’:’条件值’},1)`\n\n删除所有数据(请空表)\n\n`db.DATABASE_NAME.remove({})`\n\n\n\n\n\n\n","source":"_posts/MongoDB笔记.md","raw":"---\ntitle: MongoDB笔记\nauthor: Arclin\ntags:\n  - MongoDB\ncategories:\n  - MongoDB\nabbrlink: b3b38c86\ndate: 2018-02-18 21:58:00\n---\nMongoDB笔记\n\n<!-- more -->\n\nOS X安装\n\n`brew install mongodb`\n\n进入mongodb\n\n`mongo`\n\n查看所有数据库\n\n`db`\n\n查看所有*有数据的*数据库并带上内存信息\n\n`show dbs`\n\n创建/进入某个数据库\n\n`use DATABASE_NAME`\n\n删除数据库(需要先`use DATABASE_NAME` 进入数据库)\n\n`db.dropDatabase()`\n\n插入数据\n\n`db.DATABASE_NAME.insert({“COLUMN_NAME”:”VALUE”,”COLUMN_NAME_SECOND”:”SECOND_VALUE”})`\n\n查询所有数据\n\n`db.DATABASE_NAME.find()`\n\n查询所有数据并pretty形式打印\n\n`db.DATABASE_NAME.find().pretty()`\n\n更新满足条件的第一条数据\n\n`db.DATABASE_NAME.update({‘条件字段’:’条件值’},{$set:{‘更新字段’:’更新值’,‘更新字段2’:’更新值2’}})`\n\n更新满足条件的所有数据\n\n`db.DATABASE_NAME.update({‘条件字段’:’条件值’},{$set:{‘更新字段’:’更新值’,‘更新字段2’:’更新值2’},{multi:true}})`\n\n替换整条数据的内容(根据ID查找)\n\n`db.DATABASE_NAME.save({“_id”:ObjectId(“xxxxx”),”要替换的字段名”:”要替换的字段名”,”要替换的字段名2”:”要替换的字段名2”})`\n\n删除数据\n\n`db.DATABASE_NAME.remove({‘条件字段’:’条件值’})`\n\n删除第一条找到的记录\n\n`db.DATABASE_NAME.remove({‘条件字段’:’条件值’},1)`\n\n删除所有数据(请空表)\n\n`db.DATABASE_NAME.remove({})`\n\n\n\n\n\n\n","slug":"MongoDB笔记","published":1,"updated":"2021-06-06T18:52:24.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyogw000xtnn0f8852l16","content":"<p>MongoDB笔记</p>\n<span id=\"more\"></span>\n\n<p>OS X安装</p>\n<p><code>brew install mongodb</code></p>\n<p>进入mongodb</p>\n<p><code>mongo</code></p>\n<p>查看所有数据库</p>\n<p><code>db</code></p>\n<p>查看所有<em>有数据的</em>数据库并带上内存信息</p>\n<p><code>show dbs</code></p>\n<p>创建/进入某个数据库</p>\n<p><code>use DATABASE_NAME</code></p>\n<p>删除数据库(需要先<code>use DATABASE_NAME</code> 进入数据库)</p>\n<p><code>db.dropDatabase()</code></p>\n<p>插入数据</p>\n<p><code>db.DATABASE_NAME.insert(&#123;“COLUMN_NAME”:”VALUE”,”COLUMN_NAME_SECOND”:”SECOND_VALUE”&#125;)</code></p>\n<p>查询所有数据</p>\n<p><code>db.DATABASE_NAME.find()</code></p>\n<p>查询所有数据并pretty形式打印</p>\n<p><code>db.DATABASE_NAME.find().pretty()</code></p>\n<p>更新满足条件的第一条数据</p>\n<p><code>db.DATABASE_NAME.update(&#123;‘条件字段’:’条件值’&#125;,&#123;$set:&#123;‘更新字段’:’更新值’,‘更新字段2’:’更新值2’&#125;&#125;)</code></p>\n<p>更新满足条件的所有数据</p>\n<p><code>db.DATABASE_NAME.update(&#123;‘条件字段’:’条件值’&#125;,&#123;$set:&#123;‘更新字段’:’更新值’,‘更新字段2’:’更新值2’&#125;,&#123;multi:true&#125;&#125;)</code></p>\n<p>替换整条数据的内容(根据ID查找)</p>\n<p><code>db.DATABASE_NAME.save(&#123;“_id”:ObjectId(“xxxxx”),”要替换的字段名”:”要替换的字段名”,”要替换的字段名2”:”要替换的字段名2”&#125;)</code></p>\n<p>删除数据</p>\n<p><code>db.DATABASE_NAME.remove(&#123;‘条件字段’:’条件值’&#125;)</code></p>\n<p>删除第一条找到的记录</p>\n<p><code>db.DATABASE_NAME.remove(&#123;‘条件字段’:’条件值’&#125;,1)</code></p>\n<p>删除所有数据(请空表)</p>\n<p><code>db.DATABASE_NAME.remove(&#123;&#125;)</code></p>\n","site":{"data":{}},"excerpt":"<p>MongoDB笔记</p>","more":"<p>OS X安装</p>\n<p><code>brew install mongodb</code></p>\n<p>进入mongodb</p>\n<p><code>mongo</code></p>\n<p>查看所有数据库</p>\n<p><code>db</code></p>\n<p>查看所有<em>有数据的</em>数据库并带上内存信息</p>\n<p><code>show dbs</code></p>\n<p>创建/进入某个数据库</p>\n<p><code>use DATABASE_NAME</code></p>\n<p>删除数据库(需要先<code>use DATABASE_NAME</code> 进入数据库)</p>\n<p><code>db.dropDatabase()</code></p>\n<p>插入数据</p>\n<p><code>db.DATABASE_NAME.insert(&#123;“COLUMN_NAME”:”VALUE”,”COLUMN_NAME_SECOND”:”SECOND_VALUE”&#125;)</code></p>\n<p>查询所有数据</p>\n<p><code>db.DATABASE_NAME.find()</code></p>\n<p>查询所有数据并pretty形式打印</p>\n<p><code>db.DATABASE_NAME.find().pretty()</code></p>\n<p>更新满足条件的第一条数据</p>\n<p><code>db.DATABASE_NAME.update(&#123;‘条件字段’:’条件值’&#125;,&#123;$set:&#123;‘更新字段’:’更新值’,‘更新字段2’:’更新值2’&#125;&#125;)</code></p>\n<p>更新满足条件的所有数据</p>\n<p><code>db.DATABASE_NAME.update(&#123;‘条件字段’:’条件值’&#125;,&#123;$set:&#123;‘更新字段’:’更新值’,‘更新字段2’:’更新值2’&#125;,&#123;multi:true&#125;&#125;)</code></p>\n<p>替换整条数据的内容(根据ID查找)</p>\n<p><code>db.DATABASE_NAME.save(&#123;“_id”:ObjectId(“xxxxx”),”要替换的字段名”:”要替换的字段名”,”要替换的字段名2”:”要替换的字段名2”&#125;)</code></p>\n<p>删除数据</p>\n<p><code>db.DATABASE_NAME.remove(&#123;‘条件字段’:’条件值’&#125;)</code></p>\n<p>删除第一条找到的记录</p>\n<p><code>db.DATABASE_NAME.remove(&#123;‘条件字段’:’条件值’&#125;,1)</code></p>\n<p>删除所有数据(请空表)</p>\n<p><code>db.DATABASE_NAME.remove(&#123;&#125;)</code></p>"},{"title":"NavigationController的RootViewController和子ViewController的状态栏颜色不一样或者状态栏显示异常","author":"Arclin","abbrlink":"cacc49a3","date":"2016-10-16T16:00:00.000Z","_content":"如果NavigationController的状态栏颜色跟子ViewController的状态栏颜色不一样，那么就像下面这么写\n\n在UINavigationController的子类写这个\n\n```\n- (UIViewController *)childViewControllerForStatusBarStyle{\n    return self.topViewController;\n}\n```","source":"_posts/NavigationController的RootViewController和子ViewController的状态栏颜色不一样或者状态栏显示异常.md","raw":"---\ntitle: NavigationController的RootViewController和子ViewController的状态栏颜色不一样或者状态栏显示异常\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: cacc49a3\ndate: 2016-10-17 00:00:00\n---\n如果NavigationController的状态栏颜色跟子ViewController的状态栏颜色不一样，那么就像下面这么写\n\n在UINavigationController的子类写这个\n\n```\n- (UIViewController *)childViewControllerForStatusBarStyle{\n    return self.topViewController;\n}\n```","slug":"NavigationController的RootViewController和子ViewController的状态栏颜色不一样或者状态栏显示异常","published":1,"updated":"2021-06-06T18:52:24.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyogx0010tnn0gt084ulv","content":"<p>如果NavigationController的状态栏颜色跟子ViewController的状态栏颜色不一样，那么就像下面这么写</p>\n<p>在UINavigationController的子类写这个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIViewController *)childViewControllerForStatusBarStyle&#123;</span><br><span class=\"line\">    return self.topViewController;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>如果NavigationController的状态栏颜色跟子ViewController的状态栏颜色不一样，那么就像下面这么写</p>\n<p>在UINavigationController的子类写这个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIViewController *)childViewControllerForStatusBarStyle&#123;</span><br><span class=\"line\">    return self.topViewController;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Jenkins上蒲公英插件中update description 无法自动写入commit message问题解决","author":"Arclin","abbrlink":"5fcbb764","date":"2018-05-10T02:46:00.000Z","_content":"花了一天时间解决这个问题，找了好多资料都没找到，最后终于想到了办法。\n<!--more-->\n\n### 背景\n\n在Jenkins上使用蒲公英上传软件安装包有两种方法，一种是使用命令行的方式\n类似下面这种\n\n```\nIPANAME=\"jinkens-myapp\"\nfastlane gym --export_method ad-hoc --output_name ${IPANAME}\n\nMSG=`git log -1 --pretty=%B`\nPASSWORD=123456\ncurl -F \"file=@${IPANAME}\" -F \"uKey=USER_KEY\" -F \"_api_key=API_KEY\" -F \"updateDescription=${MSG}\" -F \"password=${PASSWORD}\" https://qiniu-storage.pgyer.com/apiv1/app/upload\n```\n\n这种方式的话就可以直接通过命令行获得`commit message`作为版本更新说明，但是缺点是无法直接通过环境变量获得上传后的App的各种信息，比如安装包地址，app二维码图片的等等。\n\n第二种方式是通过蒲公英在Jenkins上发布的插件`Upload to pgyer`，优点是上传后的各种App的信息都会被注入到环境变量中，可以在邮件模板中直接调用。缺点是Upload description必须写死为某个值，或者使用某个环境变量，但是Jenkins的Git插件又不提供给你最后一条`commit message`的环境变量。\n\n所以说为了结合两种方式的优点，想出了如下办法解决了。\n\n### 方法\n\n1. 安装插件\t`Environment Injector Plugin`\n2. 构建步骤添加`Execute Shell`，填写\n\t```\n\t# 把commit message写入文件中\n\tMSG=$(git log -1 --pretty=%B)\n\techo \"commitMessage=\"${MSG} > commitMessage.txt\n    ```\n3. 构件步骤中添加`Inject Environment variables`，`Properties File Path`填写`${WORKSPACE}/commitMessage.txt`(也有可能是别的路径，不要写错了)\n4. 最后在蒲公英插件`Upload to pgyer`上`updateDescription`中填写`${commitMessage}`\n\n\n就这样子就可以了，就是把message写到文件中，然后通过文件注入环境变量，然后蒲公英插件再去用就行了。","source":"_posts/Jenkins上蒲公英插件中update-description-无法自动写入commit-message问题解决.md","raw":"title: Jenkins上蒲公英插件中update description 无法自动写入commit message问题解决\nauthor: Arclin\ntags:\n  - Jenkins\ncategories:\n  - Jenkins\nabbrlink: 5fcbb764\ndate: 2018-05-10 10:46:00\n---\n花了一天时间解决这个问题，找了好多资料都没找到，最后终于想到了办法。\n<!--more-->\n\n### 背景\n\n在Jenkins上使用蒲公英上传软件安装包有两种方法，一种是使用命令行的方式\n类似下面这种\n\n```\nIPANAME=\"jinkens-myapp\"\nfastlane gym --export_method ad-hoc --output_name ${IPANAME}\n\nMSG=`git log -1 --pretty=%B`\nPASSWORD=123456\ncurl -F \"file=@${IPANAME}\" -F \"uKey=USER_KEY\" -F \"_api_key=API_KEY\" -F \"updateDescription=${MSG}\" -F \"password=${PASSWORD}\" https://qiniu-storage.pgyer.com/apiv1/app/upload\n```\n\n这种方式的话就可以直接通过命令行获得`commit message`作为版本更新说明，但是缺点是无法直接通过环境变量获得上传后的App的各种信息，比如安装包地址，app二维码图片的等等。\n\n第二种方式是通过蒲公英在Jenkins上发布的插件`Upload to pgyer`，优点是上传后的各种App的信息都会被注入到环境变量中，可以在邮件模板中直接调用。缺点是Upload description必须写死为某个值，或者使用某个环境变量，但是Jenkins的Git插件又不提供给你最后一条`commit message`的环境变量。\n\n所以说为了结合两种方式的优点，想出了如下办法解决了。\n\n### 方法\n\n1. 安装插件\t`Environment Injector Plugin`\n2. 构建步骤添加`Execute Shell`，填写\n\t```\n\t# 把commit message写入文件中\n\tMSG=$(git log -1 --pretty=%B)\n\techo \"commitMessage=\"${MSG} > commitMessage.txt\n    ```\n3. 构件步骤中添加`Inject Environment variables`，`Properties File Path`填写`${WORKSPACE}/commitMessage.txt`(也有可能是别的路径，不要写错了)\n4. 最后在蒲公英插件`Upload to pgyer`上`updateDescription`中填写`${commitMessage}`\n\n\n就这样子就可以了，就是把message写到文件中，然后通过文件注入环境变量，然后蒲公英插件再去用就行了。","slug":"Jenkins上蒲公英插件中update-description-无法自动写入commit-message问题解决","published":1,"updated":"2021-06-06T18:52:24.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyogy0014tnn07vm3cipf","content":"<p>花了一天时间解决这个问题，找了好多资料都没找到，最后终于想到了办法。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>在Jenkins上使用蒲公英上传软件安装包有两种方法，一种是使用命令行的方式<br>类似下面这种</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IPANAME&#x3D;&quot;jinkens-myapp&quot;</span><br><span class=\"line\">fastlane gym --export_method ad-hoc --output_name $&#123;IPANAME&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MSG&#x3D;&#96;git log -1 --pretty&#x3D;%B&#96;</span><br><span class=\"line\">PASSWORD&#x3D;123456</span><br><span class=\"line\">curl -F &quot;file&#x3D;@$&#123;IPANAME&#125;&quot; -F &quot;uKey&#x3D;USER_KEY&quot; -F &quot;_api_key&#x3D;API_KEY&quot; -F &quot;updateDescription&#x3D;$&#123;MSG&#125;&quot; -F &quot;password&#x3D;$&#123;PASSWORD&#125;&quot; https:&#x2F;&#x2F;qiniu-storage.pgyer.com&#x2F;apiv1&#x2F;app&#x2F;upload</span><br></pre></td></tr></table></figure>\n\n<p>这种方式的话就可以直接通过命令行获得<code>commit message</code>作为版本更新说明，但是缺点是无法直接通过环境变量获得上传后的App的各种信息，比如安装包地址，app二维码图片的等等。</p>\n<p>第二种方式是通过蒲公英在Jenkins上发布的插件<code>Upload to pgyer</code>，优点是上传后的各种App的信息都会被注入到环境变量中，可以在邮件模板中直接调用。缺点是Upload description必须写死为某个值，或者使用某个环境变量，但是Jenkins的Git插件又不提供给你最后一条<code>commit message</code>的环境变量。</p>\n<p>所以说为了结合两种方式的优点，想出了如下办法解决了。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><ol>\n<li>安装插件    <code>Environment Injector Plugin</code></li>\n<li>构建步骤添加<code>Execute Shell</code>，填写 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 把commit message写入文件中</span><br><span class=\"line\">MSG&#x3D;$(git log -1 --pretty&#x3D;%B)</span><br><span class=\"line\">echo &quot;commitMessage&#x3D;&quot;$&#123;MSG&#125; &gt; commitMessage.txt</span><br></pre></td></tr></table></figure></li>\n<li>构件步骤中添加<code>Inject Environment variables</code>，<code>Properties File Path</code>填写<code>$&#123;WORKSPACE&#125;/commitMessage.txt</code>(也有可能是别的路径，不要写错了)</li>\n<li>最后在蒲公英插件<code>Upload to pgyer</code>上<code>updateDescription</code>中填写<code>$&#123;commitMessage&#125;</code></li>\n</ol>\n<p>就这样子就可以了，就是把message写到文件中，然后通过文件注入环境变量，然后蒲公英插件再去用就行了。</p>\n","site":{"data":{}},"excerpt":"<p>花了一天时间解决这个问题，找了好多资料都没找到，最后终于想到了办法。</p>","more":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>在Jenkins上使用蒲公英上传软件安装包有两种方法，一种是使用命令行的方式<br>类似下面这种</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IPANAME&#x3D;&quot;jinkens-myapp&quot;</span><br><span class=\"line\">fastlane gym --export_method ad-hoc --output_name $&#123;IPANAME&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MSG&#x3D;&#96;git log -1 --pretty&#x3D;%B&#96;</span><br><span class=\"line\">PASSWORD&#x3D;123456</span><br><span class=\"line\">curl -F &quot;file&#x3D;@$&#123;IPANAME&#125;&quot; -F &quot;uKey&#x3D;USER_KEY&quot; -F &quot;_api_key&#x3D;API_KEY&quot; -F &quot;updateDescription&#x3D;$&#123;MSG&#125;&quot; -F &quot;password&#x3D;$&#123;PASSWORD&#125;&quot; https:&#x2F;&#x2F;qiniu-storage.pgyer.com&#x2F;apiv1&#x2F;app&#x2F;upload</span><br></pre></td></tr></table></figure>\n\n<p>这种方式的话就可以直接通过命令行获得<code>commit message</code>作为版本更新说明，但是缺点是无法直接通过环境变量获得上传后的App的各种信息，比如安装包地址，app二维码图片的等等。</p>\n<p>第二种方式是通过蒲公英在Jenkins上发布的插件<code>Upload to pgyer</code>，优点是上传后的各种App的信息都会被注入到环境变量中，可以在邮件模板中直接调用。缺点是Upload description必须写死为某个值，或者使用某个环境变量，但是Jenkins的Git插件又不提供给你最后一条<code>commit message</code>的环境变量。</p>\n<p>所以说为了结合两种方式的优点，想出了如下办法解决了。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><ol>\n<li>安装插件    <code>Environment Injector Plugin</code></li>\n<li>构建步骤添加<code>Execute Shell</code>，填写 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 把commit message写入文件中</span><br><span class=\"line\">MSG&#x3D;$(git log -1 --pretty&#x3D;%B)</span><br><span class=\"line\">echo &quot;commitMessage&#x3D;&quot;$&#123;MSG&#125; &gt; commitMessage.txt</span><br></pre></td></tr></table></figure></li>\n<li>构件步骤中添加<code>Inject Environment variables</code>，<code>Properties File Path</code>填写<code>$&#123;WORKSPACE&#125;/commitMessage.txt</code>(也有可能是别的路径，不要写错了)</li>\n<li>最后在蒲公英插件<code>Upload to pgyer</code>上<code>updateDescription</code>中填写<code>$&#123;commitMessage&#125;</code></li>\n</ol>\n<p>就这样子就可以了，就是把message写到文件中，然后通过文件注入环境变量，然后蒲公英插件再去用就行了。</p>"},{"title":"Node.js学习笔记","author":"Arclin","abbrlink":"1aafa723","date":"2017-03-05T16:00:00.000Z","_content":"Node.js的学习笔记,持续更新\n\n<!-- more -->\n\n> Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型\n>\n> 事件驱动\n>> 所谓事件驱动，简单地说就是你点什么按钮（即产生什么事件），电脑执行什么操作（即调用什么函数）.当然事件不仅限于用户的操作. 事件驱动的核心自然是事件。从事件角度说，事件驱动程序的基本结构是由一个事件收集器、一个事件发送器和一个_事件处理器组成。\n\n>> 事件收集器专门负责收集所有事件，包括来自用户的（如鼠标、键盘事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。\n事件发送器负责将收集器收集到的事件分发到目标对象中。\n事件处理器做具体的事件响应工作，它往往要到实现阶段才完全确定，因而需要运用虚函数机制（函数名往往取为类似于HandleMsg的一个名字）。对于框架的使用者来说，他们唯一能够看到的是事件处理器。这也是他们所关心的内容。\n\n> 非阻塞式 I/O\n\n>> I/O 即Input/Output 的缩写\n\n>> 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.\n\n>> 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。\n非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。\n\n>>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。\n在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。\n\n## let var const\n\n`let` 允许把变量的作用域限制在块级域中。与 `var` 不同处是：`var` 申明变量要么是全局的，要么是函数级的，而无法是块级的。\n\n`let`的作用域是块，而`var`的作用域是函数\n\n```\n'use strict';\nfor (let i = 0; i < 10; i++) {\n  console.log(i); // 0, 1, 2, 3, 4 ... 9\n}\nconsole.log(i); // i is not defined\nconst这个声明创建一个常量,可以全局或局部的函数声明,不可以被重新赋值.\n```\n\n## Map WeakMap Set WeakSet\n\n### Map\nMap原生提供三个遍历器生成函数和一个遍历方法。\n\n`keys()` 返回键名的遍历器。\n`values()` 返回键值的遍历器。\n`entries()` 返回所有成员的遍历器。\n`forEach()` 遍历Map的所有成员。\n\n```\nvar myMap = new Map();\nmyMap.set(0, \"zero\");\nmyMap.set(1, \"one\");\n \nfor (var key of myMap.keys()) {\n  console.log(key);\n}\n// 0 1\n \nfor (var value of myMap.values()) {\n  console.log(value);\n}\n// zero one\n \nfor (var item of myMap.entries()) {\n  console.log(item[0] + \" = \" + item[1]);\n}\n// 0 = zero 1 = one\n \nmyMap.forEach(function(value, key) {\n  console.log(key + \" = \" + value);\n}, myMap)\n// 0 = zero 1 = one\n```\n\n### WeakMap\nWeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。\nWeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。\nWeakMap只有四个方法可用：get()、set()、has()、delete()。\n\n### Set\n`add(value)` 添加某个值，返回Set结构本身。\n`delete(value)` 删除某个值，返回一个布尔值，表示删除是否成功。\n`has(value)` 返回一个布尔值，表示该值是否为Set的成员。\n`clear()` 清除所有成员，没有返回值。 上面这些属性和方法的实例如下。\n\n```\nvar s = new Set();\ns.add(1).add(2).add(2);\n// 注意2被加入了两次\nconsole.log(s.size); // 2\nconsole.log(s.has(1)); // true\nconsole.log(s.has(2)); // true\nconsole.log(s.has(3)); // false\nconsole.log(s.delete(2));\nconsole.log(s.has(2)); // false\n```\n\nSet的遍历跟Map差不多,但是如果使用`set.entries()`去遍历的话,出来的结果会是像这样子[\"red\", \"red\"] [\"green\", \"green\"] [\"blue\", \"blue\"],包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。\n### WeakSet\nweakSet和WeakMap的道理也差不多,WeakSet的成员只能是对象，而不能是其他类型的值.WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用\nWeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。\n\n```\nvar ws = new WeakSet();\nvar obj = {};\nvar foo = {};\nws.add(obj);\nws.has(foo);    // false\nWeakSet没有size属性，没有办法遍历它的成员。\nws.size // undefined\nws.forEach // undefined\nws.forEach(function(item){ console.log('WeakSet has ' + item)})\n```\n\n```\n// TypeError: undefined is not a function\n```\n## Generator Promise Symbol\n### Generator\nGenerator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。\n\n执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。\n\n```\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\nvar hw = helloWorldGenerator();\nconsole.log(hw.next()); \\\\ { value: 'hello', done: false }\nconsole.log(hw.next()); \\\\ { value: 'world', done: false }\nconsole.log(hw.next()); \\\\ { value: 'ending', done: true }\nconsole.log(hw.next()); \\\\ { value: undefined, done: true }\n```\n\n`yield` 意为’产出’ 是用来定义不同的内部状态,调用next()方法的时候会返回Generator的下一个状态,直到return为止,输出的done中的值表示Generator函数是否已经执行结束.\n\n`yield *` 语句 : 用来在一个Generator中执行另外一个Generator函数\n\n```\nfunction* anotherGenerator(i) {\n  yield i + 1;\n  yield i + 2;\n  yield i + 3;\n}\nfunction* generator(i){\n  yield i;\n  yield* anotherGenerator(i);\n  yield i + 10;\n}\nvar gen = generator(10);\nconsole.log(gen.next().value); // 10\nconsole.log(gen.next().value); // 11\nconsole.log(gen.next().value); // 12\nconsole.log(gen.next().value); // 13\nconsole.log(gen.next().value); // 20\n```\n运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。\n\n### Promise\nPromise 是一个构造函数\n\n```\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\nPromise函数自带两个参数: `resolve`意为返回一个成功的回调,`reject`意为返回一个错误的回调\n然后订阅回调的方法如下\n\n```\npromise.then(function(value) {\n  // success\n}, function(value) {\n  // failure\n});\n```\n\nPS: 这个函数很像OC的block方法,上面的函数就类似OC的如下写法\n\n```\n- (void)promise:(void(^)(id success))resolve failure:(void(^)(id failure))reject {\n\tif(...){\n\t\tresolve(resolveValue);\n\t}else {\n\t\treject(rejectValue);\n\t}\n} \n\n//订阅\n[self promise:^(id success){\n\tNSLog(success);\n} failure:^(id failure){\n\tNSLog(failure);\n}];\n// 纯脑补,也不知道有没有写对\n```\n\n#### catch() 方法\n专门用来捕获异常的回调,会捕获到`then()`的第二个参数的回调\n\n如果在`then()`中使用了throw xxx;语句,那么也会走`catch()`回调\n\n`catch()`和`then()`方法都会返回Promise对象,所以可以链式调用\n\n```\npromise.then(function(value) {\n    console.log(value);      \n},null).catch(function(value){\n\tconsole.log(value);\n});\n```\n\nOR\n\n```\np1.then(function(value) {\n  console.log(value); // \"成功!\"\n  throw \"哦，不!\";\n}).catch(function(e) {\n  console.log(e); // \"哦，不!\"\n});\n```\n\n你还可以`then()`完再`then()`\n\n```\nvar p2 = new Promise(function(resolve, reject) {\n  resolve(1);\n});\n\np2.then(function(value) {\n  console.log(value); // 1\n  return value + 1;\n}).then(function(value) {\n  console.log(value); // 2\n});\n```\n#### all() 方法\n\nPromise.all方法用于将多个Promise实例，包装成一个新的Promise实例。\n\n```\nvar p = Promise.all([p1,p2,p3]);\n```\n\n只要有一个reject了,那么p就会抛出失败的回调,只有全部都resolve了,才会抛出成功的回调\n\n#### race() 方法\n顾名思义 赛跑\n\n同样是来绑定多个Promise实例,不同的是谁先返回就走谁的回调,如果p1五秒后发失败回调,p2一秒后发成功回调,那么Promise.race([p1, p2])就等于p2.\n\n```\nPromise.race([p1, p2]).then(function(value) {\n  console.log(value); // \"two\"\n  // Both resolve, but p2 is faster\n});\n```\n\n### Symbol\n符号\n\n用Symbol生成的对象,绝对不会重复!!!\n\n```\nvar s1 = Symbol(\"foo\");\nvar s2 = Symbol(\"foo\");\nconsole.log(s1 === s2); // false\ngetOwnPropertySymbols()\n```\n\n这个方法可以获得对象的所有Symbol类型的成员属性名\n\n```\nvar obj = {};\nvar a = Symbol('a');\nvar b = Symbol('b');\n \nobj[a] = 'Hello';\nobj[b] = 'World';\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\nconsole.log(objectSymbols);\n// [Symbol(a), Symbol(b)]\n```\n\n#### Symbol.for()\n这个方法用来搜索之前有没有定义过某个Symbol名,如果有的话就返回值没有的话就就新建一个Symbol,有种取缓存的感觉\n\n```\nvar s1 = Symbol.for('foo'); // 定义一下\nvar s2 = Symbol.for('foo'); // 取出之前定义的值\nconsole.log(s1 === s2); // true\nSymbol.keyFor()\n跟上面的是相反的,通过值来取键\n\nvar s1 = Symbol.for(\"foo\");\nSymbol.keyFor(s1) // \"foo\"\n \nvar s2 = Symbol(\"foo\");\nSymbol.keyFor(s2) // undefined\n```\n\n## 箭头函数\n其实就是简写方法而已\n\n```\nvar  f = function(v1,v2) {\n\treturn v1+v2;\n}\n```\n\n等同于\n\n```\nvar f = (v1,v2) => v1+v2;\n```\n\n### 注意事项\n\n函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。\n不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。\n不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用`Rest`参数代替。\n不可以使用`yield`命令，因此箭头函数不能用作Generator函数。\n\n## 网络请求\n\n### 方式一 使用 http.request()\n\n```\nvar http = require('http');  \n  \nvar qs = require('querystring');  \n  \nvar data = {  \n    a: 123,  \n    time: new Date().getTime()};//这是需要提交的数据  \n    \nvar content = qs.stringify(data);   \nvar options = {  \n    hostname: '127.0.0.1',  \n    port: 10086,  \n    path: '/pay/pay_callback?' + content,  \n    method: 'GET'  \n};  \n  \nvar req = http.request(options, function (res) {  \n    console.log('STATUS: ' + res.statusCode);  \n    console.log('HEADERS: ' + JSON.stringify(res.headers));  \n    res.setEncoding('utf8');  \n    res.on('data', function (chunk) {  \n        console.log('BODY: ' + chunk);  \n    });  \n});  \n  \nreq.on('error', function (e) {  \n    console.log('problem with request: ' + e.message);  \n});  \n  \nreq.end();\n```\n\n### 方式二 使用 http.get() 发送GET请求\n\n```\nvar httpRequest = http.get('http://localhost:8088/tempFile/LocalData.json',function(request,response){\n      var html='';\n      request.on('data',function(data){\n        \thtml+=data;\n      });\n      request.on('end',function(){\n\t\t\tconsole.log(html);\n      });\n  });\n```\n\n> 学习资料来自:[http://www.hubwiz.com](http://www.hubwiz.com) 等","source":"_posts/Node-js学习笔记.md","raw":"---\ntitle: Node.js学习笔记\nauthor: Arclin\ntags:\n  - Node.js\ncategories:\n  - Node.js\nabbrlink: 1aafa723\ndate: 2017-03-06 00:00:00\n---\nNode.js的学习笔记,持续更新\n\n<!-- more -->\n\n> Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型\n>\n> 事件驱动\n>> 所谓事件驱动，简单地说就是你点什么按钮（即产生什么事件），电脑执行什么操作（即调用什么函数）.当然事件不仅限于用户的操作. 事件驱动的核心自然是事件。从事件角度说，事件驱动程序的基本结构是由一个事件收集器、一个事件发送器和一个_事件处理器组成。\n\n>> 事件收集器专门负责收集所有事件，包括来自用户的（如鼠标、键盘事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。\n事件发送器负责将收集器收集到的事件分发到目标对象中。\n事件处理器做具体的事件响应工作，它往往要到实现阶段才完全确定，因而需要运用虚函数机制（函数名往往取为类似于HandleMsg的一个名字）。对于框架的使用者来说，他们唯一能够看到的是事件处理器。这也是他们所关心的内容。\n\n> 非阻塞式 I/O\n\n>> I/O 即Input/Output 的缩写\n\n>> 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.\n\n>> 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。\n非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。\n\n>>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。\n在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。\n\n## let var const\n\n`let` 允许把变量的作用域限制在块级域中。与 `var` 不同处是：`var` 申明变量要么是全局的，要么是函数级的，而无法是块级的。\n\n`let`的作用域是块，而`var`的作用域是函数\n\n```\n'use strict';\nfor (let i = 0; i < 10; i++) {\n  console.log(i); // 0, 1, 2, 3, 4 ... 9\n}\nconsole.log(i); // i is not defined\nconst这个声明创建一个常量,可以全局或局部的函数声明,不可以被重新赋值.\n```\n\n## Map WeakMap Set WeakSet\n\n### Map\nMap原生提供三个遍历器生成函数和一个遍历方法。\n\n`keys()` 返回键名的遍历器。\n`values()` 返回键值的遍历器。\n`entries()` 返回所有成员的遍历器。\n`forEach()` 遍历Map的所有成员。\n\n```\nvar myMap = new Map();\nmyMap.set(0, \"zero\");\nmyMap.set(1, \"one\");\n \nfor (var key of myMap.keys()) {\n  console.log(key);\n}\n// 0 1\n \nfor (var value of myMap.values()) {\n  console.log(value);\n}\n// zero one\n \nfor (var item of myMap.entries()) {\n  console.log(item[0] + \" = \" + item[1]);\n}\n// 0 = zero 1 = one\n \nmyMap.forEach(function(value, key) {\n  console.log(key + \" = \" + value);\n}, myMap)\n// 0 = zero 1 = one\n```\n\n### WeakMap\nWeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。\nWeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。\nWeakMap只有四个方法可用：get()、set()、has()、delete()。\n\n### Set\n`add(value)` 添加某个值，返回Set结构本身。\n`delete(value)` 删除某个值，返回一个布尔值，表示删除是否成功。\n`has(value)` 返回一个布尔值，表示该值是否为Set的成员。\n`clear()` 清除所有成员，没有返回值。 上面这些属性和方法的实例如下。\n\n```\nvar s = new Set();\ns.add(1).add(2).add(2);\n// 注意2被加入了两次\nconsole.log(s.size); // 2\nconsole.log(s.has(1)); // true\nconsole.log(s.has(2)); // true\nconsole.log(s.has(3)); // false\nconsole.log(s.delete(2));\nconsole.log(s.has(2)); // false\n```\n\nSet的遍历跟Map差不多,但是如果使用`set.entries()`去遍历的话,出来的结果会是像这样子[\"red\", \"red\"] [\"green\", \"green\"] [\"blue\", \"blue\"],包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。\n### WeakSet\nweakSet和WeakMap的道理也差不多,WeakSet的成员只能是对象，而不能是其他类型的值.WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用\nWeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。\n\n```\nvar ws = new WeakSet();\nvar obj = {};\nvar foo = {};\nws.add(obj);\nws.has(foo);    // false\nWeakSet没有size属性，没有办法遍历它的成员。\nws.size // undefined\nws.forEach // undefined\nws.forEach(function(item){ console.log('WeakSet has ' + item)})\n```\n\n```\n// TypeError: undefined is not a function\n```\n## Generator Promise Symbol\n### Generator\nGenerator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。\n\n执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。\n\n```\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\nvar hw = helloWorldGenerator();\nconsole.log(hw.next()); \\\\ { value: 'hello', done: false }\nconsole.log(hw.next()); \\\\ { value: 'world', done: false }\nconsole.log(hw.next()); \\\\ { value: 'ending', done: true }\nconsole.log(hw.next()); \\\\ { value: undefined, done: true }\n```\n\n`yield` 意为’产出’ 是用来定义不同的内部状态,调用next()方法的时候会返回Generator的下一个状态,直到return为止,输出的done中的值表示Generator函数是否已经执行结束.\n\n`yield *` 语句 : 用来在一个Generator中执行另外一个Generator函数\n\n```\nfunction* anotherGenerator(i) {\n  yield i + 1;\n  yield i + 2;\n  yield i + 3;\n}\nfunction* generator(i){\n  yield i;\n  yield* anotherGenerator(i);\n  yield i + 10;\n}\nvar gen = generator(10);\nconsole.log(gen.next().value); // 10\nconsole.log(gen.next().value); // 11\nconsole.log(gen.next().value); // 12\nconsole.log(gen.next().value); // 13\nconsole.log(gen.next().value); // 20\n```\n运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。\n\n### Promise\nPromise 是一个构造函数\n\n```\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\nPromise函数自带两个参数: `resolve`意为返回一个成功的回调,`reject`意为返回一个错误的回调\n然后订阅回调的方法如下\n\n```\npromise.then(function(value) {\n  // success\n}, function(value) {\n  // failure\n});\n```\n\nPS: 这个函数很像OC的block方法,上面的函数就类似OC的如下写法\n\n```\n- (void)promise:(void(^)(id success))resolve failure:(void(^)(id failure))reject {\n\tif(...){\n\t\tresolve(resolveValue);\n\t}else {\n\t\treject(rejectValue);\n\t}\n} \n\n//订阅\n[self promise:^(id success){\n\tNSLog(success);\n} failure:^(id failure){\n\tNSLog(failure);\n}];\n// 纯脑补,也不知道有没有写对\n```\n\n#### catch() 方法\n专门用来捕获异常的回调,会捕获到`then()`的第二个参数的回调\n\n如果在`then()`中使用了throw xxx;语句,那么也会走`catch()`回调\n\n`catch()`和`then()`方法都会返回Promise对象,所以可以链式调用\n\n```\npromise.then(function(value) {\n    console.log(value);      \n},null).catch(function(value){\n\tconsole.log(value);\n});\n```\n\nOR\n\n```\np1.then(function(value) {\n  console.log(value); // \"成功!\"\n  throw \"哦，不!\";\n}).catch(function(e) {\n  console.log(e); // \"哦，不!\"\n});\n```\n\n你还可以`then()`完再`then()`\n\n```\nvar p2 = new Promise(function(resolve, reject) {\n  resolve(1);\n});\n\np2.then(function(value) {\n  console.log(value); // 1\n  return value + 1;\n}).then(function(value) {\n  console.log(value); // 2\n});\n```\n#### all() 方法\n\nPromise.all方法用于将多个Promise实例，包装成一个新的Promise实例。\n\n```\nvar p = Promise.all([p1,p2,p3]);\n```\n\n只要有一个reject了,那么p就会抛出失败的回调,只有全部都resolve了,才会抛出成功的回调\n\n#### race() 方法\n顾名思义 赛跑\n\n同样是来绑定多个Promise实例,不同的是谁先返回就走谁的回调,如果p1五秒后发失败回调,p2一秒后发成功回调,那么Promise.race([p1, p2])就等于p2.\n\n```\nPromise.race([p1, p2]).then(function(value) {\n  console.log(value); // \"two\"\n  // Both resolve, but p2 is faster\n});\n```\n\n### Symbol\n符号\n\n用Symbol生成的对象,绝对不会重复!!!\n\n```\nvar s1 = Symbol(\"foo\");\nvar s2 = Symbol(\"foo\");\nconsole.log(s1 === s2); // false\ngetOwnPropertySymbols()\n```\n\n这个方法可以获得对象的所有Symbol类型的成员属性名\n\n```\nvar obj = {};\nvar a = Symbol('a');\nvar b = Symbol('b');\n \nobj[a] = 'Hello';\nobj[b] = 'World';\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\nconsole.log(objectSymbols);\n// [Symbol(a), Symbol(b)]\n```\n\n#### Symbol.for()\n这个方法用来搜索之前有没有定义过某个Symbol名,如果有的话就返回值没有的话就就新建一个Symbol,有种取缓存的感觉\n\n```\nvar s1 = Symbol.for('foo'); // 定义一下\nvar s2 = Symbol.for('foo'); // 取出之前定义的值\nconsole.log(s1 === s2); // true\nSymbol.keyFor()\n跟上面的是相反的,通过值来取键\n\nvar s1 = Symbol.for(\"foo\");\nSymbol.keyFor(s1) // \"foo\"\n \nvar s2 = Symbol(\"foo\");\nSymbol.keyFor(s2) // undefined\n```\n\n## 箭头函数\n其实就是简写方法而已\n\n```\nvar  f = function(v1,v2) {\n\treturn v1+v2;\n}\n```\n\n等同于\n\n```\nvar f = (v1,v2) => v1+v2;\n```\n\n### 注意事项\n\n函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。\n不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。\n不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用`Rest`参数代替。\n不可以使用`yield`命令，因此箭头函数不能用作Generator函数。\n\n## 网络请求\n\n### 方式一 使用 http.request()\n\n```\nvar http = require('http');  \n  \nvar qs = require('querystring');  \n  \nvar data = {  \n    a: 123,  \n    time: new Date().getTime()};//这是需要提交的数据  \n    \nvar content = qs.stringify(data);   \nvar options = {  \n    hostname: '127.0.0.1',  \n    port: 10086,  \n    path: '/pay/pay_callback?' + content,  \n    method: 'GET'  \n};  \n  \nvar req = http.request(options, function (res) {  \n    console.log('STATUS: ' + res.statusCode);  \n    console.log('HEADERS: ' + JSON.stringify(res.headers));  \n    res.setEncoding('utf8');  \n    res.on('data', function (chunk) {  \n        console.log('BODY: ' + chunk);  \n    });  \n});  \n  \nreq.on('error', function (e) {  \n    console.log('problem with request: ' + e.message);  \n});  \n  \nreq.end();\n```\n\n### 方式二 使用 http.get() 发送GET请求\n\n```\nvar httpRequest = http.get('http://localhost:8088/tempFile/LocalData.json',function(request,response){\n      var html='';\n      request.on('data',function(data){\n        \thtml+=data;\n      });\n      request.on('end',function(){\n\t\t\tconsole.log(html);\n      });\n  });\n```\n\n> 学习资料来自:[http://www.hubwiz.com](http://www.hubwiz.com) 等","slug":"Node-js学习笔记","published":1,"updated":"2021-06-06T18:52:24.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyogy0017tnn015rwbcnc","content":"<p>Node.js的学习笔记,持续更新</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型</p>\n<p>事件驱动</p>\n<blockquote>\n<p>所谓事件驱动，简单地说就是你点什么按钮（即产生什么事件），电脑执行什么操作（即调用什么函数）.当然事件不仅限于用户的操作. 事件驱动的核心自然是事件。从事件角度说，事件驱动程序的基本结构是由一个事件收集器、一个事件发送器和一个_事件处理器组成。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>事件收集器专门负责收集所有事件，包括来自用户的（如鼠标、键盘事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。<br>事件发送器负责将收集器收集到的事件分发到目标对象中。<br>事件处理器做具体的事件响应工作，它往往要到实现阶段才完全确定，因而需要运用虚函数机制（函数名往往取为类似于HandleMsg的一个名字）。对于框架的使用者来说，他们唯一能够看到的是事件处理器。这也是他们所关心的内容。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>非阻塞式 I/O</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>I/O 即Input/Output 的缩写</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>\n</blockquote>\n</blockquote>\n<h2 id=\"let-var-const\"><a href=\"#let-var-const\" class=\"headerlink\" title=\"let var const\"></a>let var const</h2><p><code>let</code> 允许把变量的作用域限制在块级域中。与 <code>var</code> 不同处是：<code>var</code> 申明变量要么是全局的，要么是函数级的，而无法是块级的。</p>\n<p><code>let</code>的作用域是块，而<code>var</code>的作用域是函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;use strict&#39;;</span><br><span class=\"line\">for (let i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">  console.log(i); &#x2F;&#x2F; 0, 1, 2, 3, 4 ... 9</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(i); &#x2F;&#x2F; i is not defined</span><br><span class=\"line\">const这个声明创建一个常量,可以全局或局部的函数声明,不可以被重新赋值.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Map-WeakMap-Set-WeakSet\"><a href=\"#Map-WeakMap-Set-WeakSet\" class=\"headerlink\" title=\"Map WeakMap Set WeakSet\"></a>Map WeakMap Set WeakSet</h2><h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>Map原生提供三个遍历器生成函数和一个遍历方法。</p>\n<p><code>keys()</code> 返回键名的遍历器。<br><code>values()</code> 返回键值的遍历器。<br><code>entries()</code> 返回所有成员的遍历器。<br><code>forEach()</code> 遍历Map的所有成员。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myMap &#x3D; new Map();</span><br><span class=\"line\">myMap.set(0, &quot;zero&quot;);</span><br><span class=\"line\">myMap.set(1, &quot;one&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var key of myMap.keys()) &#123;</span><br><span class=\"line\">  console.log(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 0 1</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var value of myMap.values()) &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; zero one</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var item of myMap.entries()) &#123;</span><br><span class=\"line\">  console.log(item[0] + &quot; &#x3D; &quot; + item[1]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 0 &#x3D; zero 1 &#x3D; one</span><br><span class=\"line\"> </span><br><span class=\"line\">myMap.forEach(function(value, key) &#123;</span><br><span class=\"line\">  console.log(key + &quot; &#x3D; &quot; + value);</span><br><span class=\"line\">&#125;, myMap)</span><br><span class=\"line\">&#x2F;&#x2F; 0 &#x3D; zero 1 &#x3D; one</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h3><p>WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。<br>WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。<br>WeakMap只有四个方法可用：get()、set()、has()、delete()。</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p><code>add(value)</code> 添加某个值，返回Set结构本身。<br><code>delete(value)</code> 删除某个值，返回一个布尔值，表示删除是否成功。<br><code>has(value)</code> 返回一个布尔值，表示该值是否为Set的成员。<br><code>clear()</code> 清除所有成员，没有返回值。 上面这些属性和方法的实例如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s &#x3D; new Set();</span><br><span class=\"line\">s.add(1).add(2).add(2);</span><br><span class=\"line\">&#x2F;&#x2F; 注意2被加入了两次</span><br><span class=\"line\">console.log(s.size); &#x2F;&#x2F; 2</span><br><span class=\"line\">console.log(s.has(1)); &#x2F;&#x2F; true</span><br><span class=\"line\">console.log(s.has(2)); &#x2F;&#x2F; true</span><br><span class=\"line\">console.log(s.has(3)); &#x2F;&#x2F; false</span><br><span class=\"line\">console.log(s.delete(2));</span><br><span class=\"line\">console.log(s.has(2)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>\n\n<p>Set的遍历跟Map差不多,但是如果使用<code>set.entries()</code>去遍历的话,出来的结果会是像这样子[“red”, “red”] [“green”, “green”] [“blue”, “blue”],包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p>weakSet和WeakMap的道理也差不多,WeakSet的成员只能是对象，而不能是其他类型的值.WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用<br>WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ws &#x3D; new WeakSet();</span><br><span class=\"line\">var obj &#x3D; &#123;&#125;;</span><br><span class=\"line\">var foo &#x3D; &#123;&#125;;</span><br><span class=\"line\">ws.add(obj);</span><br><span class=\"line\">ws.has(foo);    &#x2F;&#x2F; false</span><br><span class=\"line\">WeakSet没有size属性，没有办法遍历它的成员。</span><br><span class=\"line\">ws.size &#x2F;&#x2F; undefined</span><br><span class=\"line\">ws.forEach &#x2F;&#x2F; undefined</span><br><span class=\"line\">ws.forEach(function(item)&#123; console.log(&#39;WeakSet has &#39; + item)&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; TypeError: undefined is not a function</span><br></pre></td></tr></table></figure>\n<h2 id=\"Generator-Promise-Symbol\"><a href=\"#Generator-Promise-Symbol\" class=\"headerlink\" title=\"Generator Promise Symbol\"></a>Generator Promise Symbol</h2><h3 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h3><p>Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。</p>\n<p>执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* helloWorldGenerator() &#123;</span><br><span class=\"line\">  yield &#39;hello&#39;;</span><br><span class=\"line\">  yield &#39;world&#39;;</span><br><span class=\"line\">  return &#39;ending&#39;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var hw &#x3D; helloWorldGenerator();</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &#39;hello&#39;, done: false &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &#39;world&#39;, done: false &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &#39;ending&#39;, done: true &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>yield</code> 意为’产出’ 是用来定义不同的内部状态,调用next()方法的时候会返回Generator的下一个状态,直到return为止,输出的done中的值表示Generator函数是否已经执行结束.</p>\n<p><code>yield *</code> 语句 : 用来在一个Generator中执行另外一个Generator函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* anotherGenerator(i) &#123;</span><br><span class=\"line\">  yield i + 1;</span><br><span class=\"line\">  yield i + 2;</span><br><span class=\"line\">  yield i + 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function* generator(i)&#123;</span><br><span class=\"line\">  yield i;</span><br><span class=\"line\">  yield* anotherGenerator(i);</span><br><span class=\"line\">  yield i + 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var gen &#x3D; generator(10);</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 10</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 11</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 12</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 13</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 20</span><br></pre></td></tr></table></figure>\n<p>运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。</p>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>Promise 是一个构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ... some code</span><br><span class=\"line\">  if (&#x2F;* 异步操作成功 *&#x2F;)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>Promise函数自带两个参数: <code>resolve</code>意为返回一个成功的回调,<code>reject</code>意为返回一个错误的回调<br>然后订阅回调的方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(function(value) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; success</span><br><span class=\"line\">&#125;, function(value) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; failure</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>PS: 这个函数很像OC的block方法,上面的函数就类似OC的如下写法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)promise:(void(^)(id success))resolve failure:(void(^)(id failure))reject &#123;</span><br><span class=\"line\">\tif(...)&#123;</span><br><span class=\"line\">\t\tresolve(resolveValue);</span><br><span class=\"line\">\t&#125;else &#123;</span><br><span class=\"line\">\t\treject(rejectValue);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;订阅</span><br><span class=\"line\">[self promise:^(id success)&#123;</span><br><span class=\"line\">\tNSLog(success);</span><br><span class=\"line\">&#125; failure:^(id failure)&#123;</span><br><span class=\"line\">\tNSLog(failure);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">&#x2F;&#x2F; 纯脑补,也不知道有没有写对</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"catch-方法\"><a href=\"#catch-方法\" class=\"headerlink\" title=\"catch() 方法\"></a>catch() 方法</h4><p>专门用来捕获异常的回调,会捕获到<code>then()</code>的第二个参数的回调</p>\n<p>如果在<code>then()</code>中使用了throw xxx;语句,那么也会走<code>catch()</code>回调</p>\n<p><code>catch()</code>和<code>then()</code>方法都会返回Promise对象,所以可以链式调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(function(value) &#123;</span><br><span class=\"line\">    console.log(value);      </span><br><span class=\"line\">&#125;,null).catch(function(value)&#123;</span><br><span class=\"line\">\tconsole.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>OR</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p1.then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); &#x2F;&#x2F; &quot;成功!&quot;</span><br><span class=\"line\">  throw &quot;哦，不!&quot;;</span><br><span class=\"line\">&#125;).catch(function(e) &#123;</span><br><span class=\"line\">  console.log(e); &#x2F;&#x2F; &quot;哦，不!&quot;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>你还可以<code>then()</code>完再<code>then()</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p2 &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">  resolve(1);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p2.then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); &#x2F;&#x2F; 1</span><br><span class=\"line\">  return value + 1;</span><br><span class=\"line\">&#125;).then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); &#x2F;&#x2F; 2</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"all-方法\"><a href=\"#all-方法\" class=\"headerlink\" title=\"all() 方法\"></a>all() 方法</h4><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p &#x3D; Promise.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>\n\n<p>只要有一个reject了,那么p就会抛出失败的回调,只有全部都resolve了,才会抛出成功的回调</p>\n<h4 id=\"race-方法\"><a href=\"#race-方法\" class=\"headerlink\" title=\"race() 方法\"></a>race() 方法</h4><p>顾名思义 赛跑</p>\n<p>同样是来绑定多个Promise实例,不同的是谁先返回就走谁的回调,如果p1五秒后发失败回调,p2一秒后发成功回调,那么Promise.race([p1, p2])就等于p2.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.race([p1, p2]).then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); &#x2F;&#x2F; &quot;two&quot;</span><br><span class=\"line\">  &#x2F;&#x2F; Both resolve, but p2 is faster</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h3><p>符号</p>\n<p>用Symbol生成的对象,绝对不会重复!!!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class=\"line\">var s2 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class=\"line\">console.log(s1 &#x3D;&#x3D;&#x3D; s2); &#x2F;&#x2F; false</span><br><span class=\"line\">getOwnPropertySymbols()</span><br></pre></td></tr></table></figure>\n\n<p>这个方法可以获得对象的所有Symbol类型的成员属性名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj &#x3D; &#123;&#125;;</span><br><span class=\"line\">var a &#x3D; Symbol(&#39;a&#39;);</span><br><span class=\"line\">var b &#x3D; Symbol(&#39;b&#39;);</span><br><span class=\"line\"> </span><br><span class=\"line\">obj[a] &#x3D; &#39;Hello&#39;;</span><br><span class=\"line\">obj[b] &#x3D; &#39;World&#39;;</span><br><span class=\"line\">var objectSymbols &#x3D; Object.getOwnPropertySymbols(obj);</span><br><span class=\"line\">console.log(objectSymbols);</span><br><span class=\"line\">&#x2F;&#x2F; [Symbol(a), Symbol(b)]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Symbol-for\"><a href=\"#Symbol-for\" class=\"headerlink\" title=\"Symbol.for()\"></a>Symbol.for()</h4><p>这个方法用来搜索之前有没有定义过某个Symbol名,如果有的话就返回值没有的话就就新建一个Symbol,有种取缓存的感觉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1 &#x3D; Symbol.for(&#39;foo&#39;); &#x2F;&#x2F; 定义一下</span><br><span class=\"line\">var s2 &#x3D; Symbol.for(&#39;foo&#39;); &#x2F;&#x2F; 取出之前定义的值</span><br><span class=\"line\">console.log(s1 &#x3D;&#x3D;&#x3D; s2); &#x2F;&#x2F; true</span><br><span class=\"line\">Symbol.keyFor()</span><br><span class=\"line\">跟上面的是相反的,通过值来取键</span><br><span class=\"line\"></span><br><span class=\"line\">var s1 &#x3D; Symbol.for(&quot;foo&quot;);</span><br><span class=\"line\">Symbol.keyFor(s1) &#x2F;&#x2F; &quot;foo&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">var s2 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class=\"line\">Symbol.keyFor(s2) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>其实就是简写方法而已</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var  f &#x3D; function(v1,v2) &#123;</span><br><span class=\"line\">\treturn v1+v2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; (v1,v2) &#x3D;&gt; v1+v2;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。<br>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。<br>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用<code>Rest</code>参数代替。<br>不可以使用<code>yield</code>命令，因此箭头函数不能用作Generator函数。</p>\n<h2 id=\"网络请求\"><a href=\"#网络请求\" class=\"headerlink\" title=\"网络请求\"></a>网络请求</h2><h3 id=\"方式一-使用-http-request\"><a href=\"#方式一-使用-http-request\" class=\"headerlink\" title=\"方式一 使用 http.request()\"></a>方式一 使用 http.request()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var http &#x3D; require(&#39;http&#39;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">var qs &#x3D; require(&#39;querystring&#39;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">var data &#x3D; &#123;  </span><br><span class=\"line\">    a: 123,  </span><br><span class=\"line\">    time: new Date().getTime()&#125;;&#x2F;&#x2F;这是需要提交的数据  </span><br><span class=\"line\">    </span><br><span class=\"line\">var content &#x3D; qs.stringify(data);   </span><br><span class=\"line\">var options &#x3D; &#123;  </span><br><span class=\"line\">    hostname: &#39;127.0.0.1&#39;,  </span><br><span class=\"line\">    port: 10086,  </span><br><span class=\"line\">    path: &#39;&#x2F;pay&#x2F;pay_callback?&#39; + content,  </span><br><span class=\"line\">    method: &#39;GET&#39;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">var req &#x3D; http.request(options, function (res) &#123;  </span><br><span class=\"line\">    console.log(&#39;STATUS: &#39; + res.statusCode);  </span><br><span class=\"line\">    console.log(&#39;HEADERS: &#39; + JSON.stringify(res.headers));  </span><br><span class=\"line\">    res.setEncoding(&#39;utf8&#39;);  </span><br><span class=\"line\">    res.on(&#39;data&#39;, function (chunk) &#123;  </span><br><span class=\"line\">        console.log(&#39;BODY: &#39; + chunk);  </span><br><span class=\"line\">    &#125;);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">req.on(&#39;error&#39;, function (e) &#123;  </span><br><span class=\"line\">    console.log(&#39;problem with request: &#39; + e.message);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">req.end();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方式二-使用-http-get-发送GET请求\"><a href=\"#方式二-使用-http-get-发送GET请求\" class=\"headerlink\" title=\"方式二 使用 http.get() 发送GET请求\"></a>方式二 使用 http.get() 发送GET请求</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var httpRequest &#x3D; http.get(&#39;http:&#x2F;&#x2F;localhost:8088&#x2F;tempFile&#x2F;LocalData.json&#39;,function(request,response)&#123;</span><br><span class=\"line\">      var html&#x3D;&#39;&#39;;</span><br><span class=\"line\">      request.on(&#39;data&#39;,function(data)&#123;</span><br><span class=\"line\">        \thtml+&#x3D;data;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      request.on(&#39;end&#39;,function()&#123;</span><br><span class=\"line\">\t\t\tconsole.log(html);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>学习资料来自:<a href=\"http://www.hubwiz.com/\">http://www.hubwiz.com</a> 等</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>Node.js的学习笔记,持续更新</p>","more":"<blockquote>\n<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型</p>\n<p>事件驱动</p>\n<blockquote>\n<p>所谓事件驱动，简单地说就是你点什么按钮（即产生什么事件），电脑执行什么操作（即调用什么函数）.当然事件不仅限于用户的操作. 事件驱动的核心自然是事件。从事件角度说，事件驱动程序的基本结构是由一个事件收集器、一个事件发送器和一个_事件处理器组成。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>事件收集器专门负责收集所有事件，包括来自用户的（如鼠标、键盘事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。<br>事件发送器负责将收集器收集到的事件分发到目标对象中。<br>事件处理器做具体的事件响应工作，它往往要到实现阶段才完全确定，因而需要运用虚函数机制（函数名往往取为类似于HandleMsg的一个名字）。对于框架的使用者来说，他们唯一能够看到的是事件处理器。这也是他们所关心的内容。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>非阻塞式 I/O</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>I/O 即Input/Output 的缩写</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>\n</blockquote>\n</blockquote>\n<h2 id=\"let-var-const\"><a href=\"#let-var-const\" class=\"headerlink\" title=\"let var const\"></a>let var const</h2><p><code>let</code> 允许把变量的作用域限制在块级域中。与 <code>var</code> 不同处是：<code>var</code> 申明变量要么是全局的，要么是函数级的，而无法是块级的。</p>\n<p><code>let</code>的作用域是块，而<code>var</code>的作用域是函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;use strict&#39;;</span><br><span class=\"line\">for (let i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">  console.log(i); &#x2F;&#x2F; 0, 1, 2, 3, 4 ... 9</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(i); &#x2F;&#x2F; i is not defined</span><br><span class=\"line\">const这个声明创建一个常量,可以全局或局部的函数声明,不可以被重新赋值.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Map-WeakMap-Set-WeakSet\"><a href=\"#Map-WeakMap-Set-WeakSet\" class=\"headerlink\" title=\"Map WeakMap Set WeakSet\"></a>Map WeakMap Set WeakSet</h2><h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>Map原生提供三个遍历器生成函数和一个遍历方法。</p>\n<p><code>keys()</code> 返回键名的遍历器。<br><code>values()</code> 返回键值的遍历器。<br><code>entries()</code> 返回所有成员的遍历器。<br><code>forEach()</code> 遍历Map的所有成员。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myMap &#x3D; new Map();</span><br><span class=\"line\">myMap.set(0, &quot;zero&quot;);</span><br><span class=\"line\">myMap.set(1, &quot;one&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var key of myMap.keys()) &#123;</span><br><span class=\"line\">  console.log(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 0 1</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var value of myMap.values()) &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; zero one</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var item of myMap.entries()) &#123;</span><br><span class=\"line\">  console.log(item[0] + &quot; &#x3D; &quot; + item[1]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 0 &#x3D; zero 1 &#x3D; one</span><br><span class=\"line\"> </span><br><span class=\"line\">myMap.forEach(function(value, key) &#123;</span><br><span class=\"line\">  console.log(key + &quot; &#x3D; &quot; + value);</span><br><span class=\"line\">&#125;, myMap)</span><br><span class=\"line\">&#x2F;&#x2F; 0 &#x3D; zero 1 &#x3D; one</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h3><p>WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。<br>WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。<br>WeakMap只有四个方法可用：get()、set()、has()、delete()。</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p><code>add(value)</code> 添加某个值，返回Set结构本身。<br><code>delete(value)</code> 删除某个值，返回一个布尔值，表示删除是否成功。<br><code>has(value)</code> 返回一个布尔值，表示该值是否为Set的成员。<br><code>clear()</code> 清除所有成员，没有返回值。 上面这些属性和方法的实例如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s &#x3D; new Set();</span><br><span class=\"line\">s.add(1).add(2).add(2);</span><br><span class=\"line\">&#x2F;&#x2F; 注意2被加入了两次</span><br><span class=\"line\">console.log(s.size); &#x2F;&#x2F; 2</span><br><span class=\"line\">console.log(s.has(1)); &#x2F;&#x2F; true</span><br><span class=\"line\">console.log(s.has(2)); &#x2F;&#x2F; true</span><br><span class=\"line\">console.log(s.has(3)); &#x2F;&#x2F; false</span><br><span class=\"line\">console.log(s.delete(2));</span><br><span class=\"line\">console.log(s.has(2)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>\n\n<p>Set的遍历跟Map差不多,但是如果使用<code>set.entries()</code>去遍历的话,出来的结果会是像这样子[“red”, “red”] [“green”, “green”] [“blue”, “blue”],包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p>weakSet和WeakMap的道理也差不多,WeakSet的成员只能是对象，而不能是其他类型的值.WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用<br>WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ws &#x3D; new WeakSet();</span><br><span class=\"line\">var obj &#x3D; &#123;&#125;;</span><br><span class=\"line\">var foo &#x3D; &#123;&#125;;</span><br><span class=\"line\">ws.add(obj);</span><br><span class=\"line\">ws.has(foo);    &#x2F;&#x2F; false</span><br><span class=\"line\">WeakSet没有size属性，没有办法遍历它的成员。</span><br><span class=\"line\">ws.size &#x2F;&#x2F; undefined</span><br><span class=\"line\">ws.forEach &#x2F;&#x2F; undefined</span><br><span class=\"line\">ws.forEach(function(item)&#123; console.log(&#39;WeakSet has &#39; + item)&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; TypeError: undefined is not a function</span><br></pre></td></tr></table></figure>\n<h2 id=\"Generator-Promise-Symbol\"><a href=\"#Generator-Promise-Symbol\" class=\"headerlink\" title=\"Generator Promise Symbol\"></a>Generator Promise Symbol</h2><h3 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h3><p>Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。</p>\n<p>执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* helloWorldGenerator() &#123;</span><br><span class=\"line\">  yield &#39;hello&#39;;</span><br><span class=\"line\">  yield &#39;world&#39;;</span><br><span class=\"line\">  return &#39;ending&#39;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var hw &#x3D; helloWorldGenerator();</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &#39;hello&#39;, done: false &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &#39;world&#39;, done: false &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &#39;ending&#39;, done: true &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>yield</code> 意为’产出’ 是用来定义不同的内部状态,调用next()方法的时候会返回Generator的下一个状态,直到return为止,输出的done中的值表示Generator函数是否已经执行结束.</p>\n<p><code>yield *</code> 语句 : 用来在一个Generator中执行另外一个Generator函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* anotherGenerator(i) &#123;</span><br><span class=\"line\">  yield i + 1;</span><br><span class=\"line\">  yield i + 2;</span><br><span class=\"line\">  yield i + 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function* generator(i)&#123;</span><br><span class=\"line\">  yield i;</span><br><span class=\"line\">  yield* anotherGenerator(i);</span><br><span class=\"line\">  yield i + 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var gen &#x3D; generator(10);</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 10</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 11</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 12</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 13</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 20</span><br></pre></td></tr></table></figure>\n<p>运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。</p>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>Promise 是一个构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ... some code</span><br><span class=\"line\">  if (&#x2F;* 异步操作成功 *&#x2F;)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>Promise函数自带两个参数: <code>resolve</code>意为返回一个成功的回调,<code>reject</code>意为返回一个错误的回调<br>然后订阅回调的方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(function(value) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; success</span><br><span class=\"line\">&#125;, function(value) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; failure</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>PS: 这个函数很像OC的block方法,上面的函数就类似OC的如下写法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)promise:(void(^)(id success))resolve failure:(void(^)(id failure))reject &#123;</span><br><span class=\"line\">\tif(...)&#123;</span><br><span class=\"line\">\t\tresolve(resolveValue);</span><br><span class=\"line\">\t&#125;else &#123;</span><br><span class=\"line\">\t\treject(rejectValue);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;订阅</span><br><span class=\"line\">[self promise:^(id success)&#123;</span><br><span class=\"line\">\tNSLog(success);</span><br><span class=\"line\">&#125; failure:^(id failure)&#123;</span><br><span class=\"line\">\tNSLog(failure);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">&#x2F;&#x2F; 纯脑补,也不知道有没有写对</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"catch-方法\"><a href=\"#catch-方法\" class=\"headerlink\" title=\"catch() 方法\"></a>catch() 方法</h4><p>专门用来捕获异常的回调,会捕获到<code>then()</code>的第二个参数的回调</p>\n<p>如果在<code>then()</code>中使用了throw xxx;语句,那么也会走<code>catch()</code>回调</p>\n<p><code>catch()</code>和<code>then()</code>方法都会返回Promise对象,所以可以链式调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(function(value) &#123;</span><br><span class=\"line\">    console.log(value);      </span><br><span class=\"line\">&#125;,null).catch(function(value)&#123;</span><br><span class=\"line\">\tconsole.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>OR</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p1.then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); &#x2F;&#x2F; &quot;成功!&quot;</span><br><span class=\"line\">  throw &quot;哦，不!&quot;;</span><br><span class=\"line\">&#125;).catch(function(e) &#123;</span><br><span class=\"line\">  console.log(e); &#x2F;&#x2F; &quot;哦，不!&quot;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>你还可以<code>then()</code>完再<code>then()</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p2 &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">  resolve(1);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p2.then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); &#x2F;&#x2F; 1</span><br><span class=\"line\">  return value + 1;</span><br><span class=\"line\">&#125;).then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); &#x2F;&#x2F; 2</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"all-方法\"><a href=\"#all-方法\" class=\"headerlink\" title=\"all() 方法\"></a>all() 方法</h4><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p &#x3D; Promise.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>\n\n<p>只要有一个reject了,那么p就会抛出失败的回调,只有全部都resolve了,才会抛出成功的回调</p>\n<h4 id=\"race-方法\"><a href=\"#race-方法\" class=\"headerlink\" title=\"race() 方法\"></a>race() 方法</h4><p>顾名思义 赛跑</p>\n<p>同样是来绑定多个Promise实例,不同的是谁先返回就走谁的回调,如果p1五秒后发失败回调,p2一秒后发成功回调,那么Promise.race([p1, p2])就等于p2.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.race([p1, p2]).then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); &#x2F;&#x2F; &quot;two&quot;</span><br><span class=\"line\">  &#x2F;&#x2F; Both resolve, but p2 is faster</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h3><p>符号</p>\n<p>用Symbol生成的对象,绝对不会重复!!!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class=\"line\">var s2 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class=\"line\">console.log(s1 &#x3D;&#x3D;&#x3D; s2); &#x2F;&#x2F; false</span><br><span class=\"line\">getOwnPropertySymbols()</span><br></pre></td></tr></table></figure>\n\n<p>这个方法可以获得对象的所有Symbol类型的成员属性名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj &#x3D; &#123;&#125;;</span><br><span class=\"line\">var a &#x3D; Symbol(&#39;a&#39;);</span><br><span class=\"line\">var b &#x3D; Symbol(&#39;b&#39;);</span><br><span class=\"line\"> </span><br><span class=\"line\">obj[a] &#x3D; &#39;Hello&#39;;</span><br><span class=\"line\">obj[b] &#x3D; &#39;World&#39;;</span><br><span class=\"line\">var objectSymbols &#x3D; Object.getOwnPropertySymbols(obj);</span><br><span class=\"line\">console.log(objectSymbols);</span><br><span class=\"line\">&#x2F;&#x2F; [Symbol(a), Symbol(b)]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Symbol-for\"><a href=\"#Symbol-for\" class=\"headerlink\" title=\"Symbol.for()\"></a>Symbol.for()</h4><p>这个方法用来搜索之前有没有定义过某个Symbol名,如果有的话就返回值没有的话就就新建一个Symbol,有种取缓存的感觉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1 &#x3D; Symbol.for(&#39;foo&#39;); &#x2F;&#x2F; 定义一下</span><br><span class=\"line\">var s2 &#x3D; Symbol.for(&#39;foo&#39;); &#x2F;&#x2F; 取出之前定义的值</span><br><span class=\"line\">console.log(s1 &#x3D;&#x3D;&#x3D; s2); &#x2F;&#x2F; true</span><br><span class=\"line\">Symbol.keyFor()</span><br><span class=\"line\">跟上面的是相反的,通过值来取键</span><br><span class=\"line\"></span><br><span class=\"line\">var s1 &#x3D; Symbol.for(&quot;foo&quot;);</span><br><span class=\"line\">Symbol.keyFor(s1) &#x2F;&#x2F; &quot;foo&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">var s2 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class=\"line\">Symbol.keyFor(s2) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>其实就是简写方法而已</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var  f &#x3D; function(v1,v2) &#123;</span><br><span class=\"line\">\treturn v1+v2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; (v1,v2) &#x3D;&gt; v1+v2;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。<br>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。<br>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用<code>Rest</code>参数代替。<br>不可以使用<code>yield</code>命令，因此箭头函数不能用作Generator函数。</p>\n<h2 id=\"网络请求\"><a href=\"#网络请求\" class=\"headerlink\" title=\"网络请求\"></a>网络请求</h2><h3 id=\"方式一-使用-http-request\"><a href=\"#方式一-使用-http-request\" class=\"headerlink\" title=\"方式一 使用 http.request()\"></a>方式一 使用 http.request()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var http &#x3D; require(&#39;http&#39;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">var qs &#x3D; require(&#39;querystring&#39;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">var data &#x3D; &#123;  </span><br><span class=\"line\">    a: 123,  </span><br><span class=\"line\">    time: new Date().getTime()&#125;;&#x2F;&#x2F;这是需要提交的数据  </span><br><span class=\"line\">    </span><br><span class=\"line\">var content &#x3D; qs.stringify(data);   </span><br><span class=\"line\">var options &#x3D; &#123;  </span><br><span class=\"line\">    hostname: &#39;127.0.0.1&#39;,  </span><br><span class=\"line\">    port: 10086,  </span><br><span class=\"line\">    path: &#39;&#x2F;pay&#x2F;pay_callback?&#39; + content,  </span><br><span class=\"line\">    method: &#39;GET&#39;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">var req &#x3D; http.request(options, function (res) &#123;  </span><br><span class=\"line\">    console.log(&#39;STATUS: &#39; + res.statusCode);  </span><br><span class=\"line\">    console.log(&#39;HEADERS: &#39; + JSON.stringify(res.headers));  </span><br><span class=\"line\">    res.setEncoding(&#39;utf8&#39;);  </span><br><span class=\"line\">    res.on(&#39;data&#39;, function (chunk) &#123;  </span><br><span class=\"line\">        console.log(&#39;BODY: &#39; + chunk);  </span><br><span class=\"line\">    &#125;);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">req.on(&#39;error&#39;, function (e) &#123;  </span><br><span class=\"line\">    console.log(&#39;problem with request: &#39; + e.message);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">req.end();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方式二-使用-http-get-发送GET请求\"><a href=\"#方式二-使用-http-get-发送GET请求\" class=\"headerlink\" title=\"方式二 使用 http.get() 发送GET请求\"></a>方式二 使用 http.get() 发送GET请求</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var httpRequest &#x3D; http.get(&#39;http:&#x2F;&#x2F;localhost:8088&#x2F;tempFile&#x2F;LocalData.json&#39;,function(request,response)&#123;</span><br><span class=\"line\">      var html&#x3D;&#39;&#39;;</span><br><span class=\"line\">      request.on(&#39;data&#39;,function(data)&#123;</span><br><span class=\"line\">        \thtml+&#x3D;data;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      request.on(&#39;end&#39;,function()&#123;</span><br><span class=\"line\">\t\t\tconsole.log(html);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>学习资料来自:<a href=\"http://www.hubwiz.com/\">http://www.hubwiz.com</a> 等</p>\n</blockquote>"},{"title":"Nginx 内容替换模块 http_substitutions_filter_module","author":"Arclin","abbrlink":"e35ccdb6","date":"2018-02-18T14:16:00.000Z","_content":"在镜像了某个网站之后,想要改变这个网站上某些元素的显示内容, 这是我们可以使用nginx的一个第三方模块`http_substitutions_filter_module`\n\n<!-- more -->\n\n修改nginx配置文件\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    listen 443 ssl http2;\n    ssl_certificate /etc/letsencrypt/live/arclin.me/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/arclin.me/privkey.pem;\n    resolver 8.8.8.8;\n    location / {\n        subs_filter Google\\s提供 Arclin提供 r;\n        google on;\n    }\n  }\n```","source":"_posts/Nginx-内容替换模块-http-substitutions-filter-module.md","raw":"---\ntitle: Nginx 内容替换模块 http_substitutions_filter_module\nauthor: Arclin\ntags:\n  - nginx\ncategories:\n  - Linux\nabbrlink: e35ccdb6\ndate: 2018-02-18 22:16:00\n---\n在镜像了某个网站之后,想要改变这个网站上某些元素的显示内容, 这是我们可以使用nginx的一个第三方模块`http_substitutions_filter_module`\n\n<!-- more -->\n\n修改nginx配置文件\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    listen 443 ssl http2;\n    ssl_certificate /etc/letsencrypt/live/arclin.me/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/arclin.me/privkey.pem;\n    resolver 8.8.8.8;\n    location / {\n        subs_filter Google\\s提供 Arclin提供 r;\n        google on;\n    }\n  }\n```","slug":"Nginx-内容替换模块-http-substitutions-filter-module","published":1,"updated":"2021-06-06T18:52:24.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoh1001ctnn008bs0f2m","content":"<p>在镜像了某个网站之后,想要改变这个网站上某些元素的显示内容, 这是我们可以使用nginx的一个第三方模块<code>http_substitutions_filter_module</code></p>\n<span id=\"more\"></span>\n\n<p>修改nginx配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    listen 443 ssl http2;</span><br><span class=\"line\">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;fullchain.pem;</span><br><span class=\"line\">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;privkey.pem;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location &#x2F; &#123;</span><br><span class=\"line\">        subs_filter Google\\s提供 Arclin提供 r;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>在镜像了某个网站之后,想要改变这个网站上某些元素的显示内容, 这是我们可以使用nginx的一个第三方模块<code>http_substitutions_filter_module</code></p>","more":"<p>修改nginx配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    listen 443 ssl http2;</span><br><span class=\"line\">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;fullchain.pem;</span><br><span class=\"line\">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;privkey.pem;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location &#x2F; &#123;</span><br><span class=\"line\">        subs_filter Google\\s提供 Arclin提供 r;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>"},{"title":"RACCommand使用注意","author":"Arclin","abbrlink":"79533f9e","date":"2016-10-16T16:00:00.000Z","_content":"RACCommand使用注意\n\n<!-- more -->\n\n 1. `signalBlock`必须要返回一个信号，不能传nil. \n 2. 如果不想要传递信号，直接创建空的信号`[RACSignal empty]`;\n 3. RACCommand中信号如果数据传递完，必须调用`[subscriber sendCompleted]`，这时命令才会执行完毕，否则永远处于执行中。\n 4. `RACCommand`需要被强引用，否则接收不到`RACCommand`中的信号，因此RACCommand中的信号是延迟发送的。\n\n- `RACCommand`设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。\n\n \t1. 在RAC开发中，通常会把网络请求封装到`RACCommand`，直接执行某个RACCommand就能发送请求。\n \t2. 当`RACCommand`内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。\n\n- 如何拿到RACCommand中返回信号发出的数据。\n\n \t1. RACCommand有个执行信号源`executionSignals`，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。\n \t2. 订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。\n\n- 监听当前命令是否正在执行`executing`\n- 使用场景,监听按钮点击，网络请求","source":"_posts/RACCommand使用注意.md","raw":"---\ntitle: RACCommand使用注意\nauthor: Arclin\ntags:\n  - iOS\n  - Reactive Cocoa\ncategories:\n  - iOS\nabbrlink: 79533f9e\ndate: 2016-10-17 00:00:00\n---\nRACCommand使用注意\n\n<!-- more -->\n\n 1. `signalBlock`必须要返回一个信号，不能传nil. \n 2. 如果不想要传递信号，直接创建空的信号`[RACSignal empty]`;\n 3. RACCommand中信号如果数据传递完，必须调用`[subscriber sendCompleted]`，这时命令才会执行完毕，否则永远处于执行中。\n 4. `RACCommand`需要被强引用，否则接收不到`RACCommand`中的信号，因此RACCommand中的信号是延迟发送的。\n\n- `RACCommand`设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。\n\n \t1. 在RAC开发中，通常会把网络请求封装到`RACCommand`，直接执行某个RACCommand就能发送请求。\n \t2. 当`RACCommand`内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。\n\n- 如何拿到RACCommand中返回信号发出的数据。\n\n \t1. RACCommand有个执行信号源`executionSignals`，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。\n \t2. 订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。\n\n- 监听当前命令是否正在执行`executing`\n- 使用场景,监听按钮点击，网络请求","slug":"RACCommand使用注意","published":1,"updated":"2021-06-06T18:52:24.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoh2001ftnn0gbeyag74","content":"<p>RACCommand使用注意</p>\n<span id=\"more\"></span>\n\n<ol>\n<li><code>signalBlock</code>必须要返回一个信号，不能传nil. </li>\n<li>如果不想要传递信号，直接创建空的信号<code>[RACSignal empty]</code>;</li>\n<li>RACCommand中信号如果数据传递完，必须调用<code>[subscriber sendCompleted]</code>，这时命令才会执行完毕，否则永远处于执行中。</li>\n<li><code>RACCommand</code>需要被强引用，否则接收不到<code>RACCommand</code>中的信号，因此RACCommand中的信号是延迟发送的。</li>\n</ol>\n<ul>\n<li><p><code>RACCommand</code>设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。</p>\n<ol>\n<li>在RAC开发中，通常会把网络请求封装到<code>RACCommand</code>，直接执行某个RACCommand就能发送请求。</li>\n<li>当<code>RACCommand</code>内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。</li>\n</ol>\n</li>\n<li><p>如何拿到RACCommand中返回信号发出的数据。</p>\n<ol>\n<li>RACCommand有个执行信号源<code>executionSignals</code>，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。</li>\n<li>订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。</li>\n</ol>\n</li>\n<li><p>监听当前命令是否正在执行<code>executing</code></p>\n</li>\n<li><p>使用场景,监听按钮点击，网络请求</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>RACCommand使用注意</p>","more":"<ol>\n<li><code>signalBlock</code>必须要返回一个信号，不能传nil. </li>\n<li>如果不想要传递信号，直接创建空的信号<code>[RACSignal empty]</code>;</li>\n<li>RACCommand中信号如果数据传递完，必须调用<code>[subscriber sendCompleted]</code>，这时命令才会执行完毕，否则永远处于执行中。</li>\n<li><code>RACCommand</code>需要被强引用，否则接收不到<code>RACCommand</code>中的信号，因此RACCommand中的信号是延迟发送的。</li>\n</ol>\n<ul>\n<li><p><code>RACCommand</code>设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。</p>\n<ol>\n<li>在RAC开发中，通常会把网络请求封装到<code>RACCommand</code>，直接执行某个RACCommand就能发送请求。</li>\n<li>当<code>RACCommand</code>内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。</li>\n</ol>\n</li>\n<li><p>如何拿到RACCommand中返回信号发出的数据。</p>\n<ol>\n<li>RACCommand有个执行信号源<code>executionSignals</code>，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。</li>\n<li>订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。</li>\n</ol>\n</li>\n<li><p>监听当前命令是否正在执行<code>executing</code></p>\n</li>\n<li><p>使用场景,监听按钮点击，网络请求</p>\n</li>\n</ul>"},{"title":"ReactNative ListView flexWrap不起作用解决办法","author":"Arclin","abbrlink":"11785d19","date":"2017-03-01T16:00:00.000Z","_content":"`flexWrap:’wrap’ `作用是让超出页面的元素进行换行显示,但是在RN 0.28之后就发生了改变\n\n<!-- more -->\n\n|RN0.28之前|RN0.28之后|\n|----|----|\n|contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems: ‘stretch’,<br/>// 屏幕宽度<br/>width:width,<br/>},|contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems:’flex-start’,<br/>// 屏幕宽度<br/> width:width,<br/>},|\n\n`alignItems: ‘stretch’` 变成了 `alignItems:’flex-start’`,\n\n但是现在的教程基本上不会加上`alignItems`…只有一个`flexWrap`,但是放到现在就实现不了了","source":"_posts/ReactNative-ListView-flexWrap不起作用解决办法.md","raw":"---\ntitle: ReactNative ListView flexWrap不起作用解决办法\nauthor: Arclin\ntags:\n  - React Native\ncategories: []\nabbrlink: 11785d19\ndate: 2017-03-02 00:00:00\n---\n`flexWrap:’wrap’ `作用是让超出页面的元素进行换行显示,但是在RN 0.28之后就发生了改变\n\n<!-- more -->\n\n|RN0.28之前|RN0.28之后|\n|----|----|\n|contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems: ‘stretch’,<br/>// 屏幕宽度<br/>width:width,<br/>},|contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems:’flex-start’,<br/>// 屏幕宽度<br/> width:width,<br/>},|\n\n`alignItems: ‘stretch’` 变成了 `alignItems:’flex-start’`,\n\n但是现在的教程基本上不会加上`alignItems`…只有一个`flexWrap`,但是放到现在就实现不了了","slug":"ReactNative-ListView-flexWrap不起作用解决办法","published":1,"updated":"2021-06-06T18:52:24.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoh2001htnn05bkq68fa","content":"<p><code>flexWrap:’wrap’ </code>作用是让超出页面的元素进行换行显示,但是在RN 0.28之后就发生了改变</p>\n<span id=\"more\"></span>\n\n<table>\n<thead>\n<tr>\n<th>RN0.28之前</th>\n<th>RN0.28之后</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems: ‘stretch’,<br/>// 屏幕宽度<br/>width:width,<br/>},</td>\n<td>contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems:’flex-start’,<br/>// 屏幕宽度<br/> width:width,<br/>},</td>\n</tr>\n</tbody></table>\n<p><code>alignItems: ‘stretch’</code> 变成了 <code>alignItems:’flex-start’</code>,</p>\n<p>但是现在的教程基本上不会加上<code>alignItems</code>…只有一个<code>flexWrap</code>,但是放到现在就实现不了了</p>\n","site":{"data":{}},"excerpt":"<p><code>flexWrap:’wrap’ </code>作用是让超出页面的元素进行换行显示,但是在RN 0.28之后就发生了改变</p>","more":"<table>\n<thead>\n<tr>\n<th>RN0.28之前</th>\n<th>RN0.28之后</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems: ‘stretch’,<br/>// 屏幕宽度<br/>width:width,<br/>},</td>\n<td>contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems:’flex-start’,<br/>// 屏幕宽度<br/> width:width,<br/>},</td>\n</tr>\n</tbody></table>\n<p><code>alignItems: ‘stretch’</code> 变成了 <code>alignItems:’flex-start’</code>,</p>\n<p>但是现在的教程基本上不会加上<code>alignItems</code>…只有一个<code>flexWrap</code>,但是放到现在就实现不了了</p>"},{"title":"React Native真机运行","author":"Arclin","abbrlink":"7724d1af","date":"2017-03-07T16:00:00.000Z","_content":"三步即可\n\n在项目根目录使用终端执行\n\n```\n$ curl http://localhost:8081/index.ios.bundle -o main.jsbundle\n```\n\n`AppDelegate.m` 找到这一行并注释\n\n```\njsCodeLocation = [NSURL URLWithString:@\"http://localhost:8081/index.ios.bundle?platform=ios&dev=true\"];\n```\n\n`AppDelegate.m` 写上或反注释这一行\n\n```\njsCodeLocation = [[NSBundle mainBundle] URLForResource:@\"main\" withExtension:@\"jsbundle\"];\n```\n","source":"_posts/React-Native真机运行.md","raw":"---\ntitle: React Native真机运行\nauthor: Arclin\ntags:\n  - React Native\n  - iOS\ncategories:\n  - React Native\nabbrlink: 7724d1af\ndate: 2017-03-08 00:00:00\n---\n三步即可\n\n在项目根目录使用终端执行\n\n```\n$ curl http://localhost:8081/index.ios.bundle -o main.jsbundle\n```\n\n`AppDelegate.m` 找到这一行并注释\n\n```\njsCodeLocation = [NSURL URLWithString:@\"http://localhost:8081/index.ios.bundle?platform=ios&dev=true\"];\n```\n\n`AppDelegate.m` 写上或反注释这一行\n\n```\njsCodeLocation = [[NSBundle mainBundle] URLForResource:@\"main\" withExtension:@\"jsbundle\"];\n```\n","slug":"React-Native真机运行","published":1,"updated":"2021-06-06T18:52:24.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoh3001mtnn095qq76x2","content":"<p>三步即可</p>\n<p>在项目根目录使用终端执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl http:&#x2F;&#x2F;localhost:8081&#x2F;index.ios.bundle -o main.jsbundle</span><br></pre></td></tr></table></figure>\n\n<p><code>AppDelegate.m</code> 找到这一行并注释</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsCodeLocation &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;localhost:8081&#x2F;index.ios.bundle?platform&#x3D;ios&amp;dev&#x3D;true&quot;];</span><br></pre></td></tr></table></figure>\n\n<p><code>AppDelegate.m</code> 写上或反注释这一行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsCodeLocation &#x3D; [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;];</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>三步即可</p>\n<p>在项目根目录使用终端执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl http:&#x2F;&#x2F;localhost:8081&#x2F;index.ios.bundle -o main.jsbundle</span><br></pre></td></tr></table></figure>\n\n<p><code>AppDelegate.m</code> 找到这一行并注释</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsCodeLocation &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;localhost:8081&#x2F;index.ios.bundle?platform&#x3D;ios&amp;dev&#x3D;true&quot;];</span><br></pre></td></tr></table></figure>\n\n<p><code>AppDelegate.m</code> 写上或反注释这一行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsCodeLocation &#x3D; [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;];</span><br></pre></td></tr></table></figure>\n"},{"title":"ReactNative与iOS原生代码之间传值","author":"Arclin","abbrlink":"a8a5ff12","date":"2017-02-25T16:00:00.000Z","_content":"本文包含两部分:\n\n- 原生传值到RN\n- RN传值到原生\n\n<!-- more -->\n\n### 原生传值到RN\n\n加载`RCTRootView`的时候在`initialProperties`内传值\n\n```\nNSDictionary *params = @{@\"image\":@\"https://dn-coding-net-production-static.qbox.me/ac823dee-6303-4745-9216-711ab4d83753.png?imageMogr2/auto-orient/format/png/crop/!651x651a0a0\"};\n\nRCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\n                                                         moduleName:@\"Test\"\n                                                  initialProperties:params\n                                                      launchOptions:nil];\n```\n\n发送的值可以在`this.props`内得到,像上面的例子就是`this.props.image`\n\n```\n<View style={[styles.tabContent,{backgroundColor:color}]}>\n            <Text style={styles.tabText}>{pageText}</Text>\n            <Text style={styles.tabText}>第{num}次重复渲染{pageText}</Text>\n            <Text stype={styles.tabText}>{this._renderImage(this.props.image)}</Text>\n</View>\n```\n\n### RN传值到原生\n\n原生代码实现协议`RCTBridgeModule`,如下\n\n```\n#import <React/RCTBridgeModule.h>\n\n@interface ReactViewController : UIViewController<RCTBridgeModule>\n\n@end\n```\n\n添加方法,下面代码中的`testPassValue`给这个Controller声明一个`testPassValue`方法,在RN中可以调用这个方法\n\n```\n// 导出模块\nRCT_EXPORT_MODULE(); // 此处不添加参数默认为这个类的类名\n\nRCT_EXPORT_METHOD(testPassValue:(NSString *)value)\n{\n    NSLog(@\"%@\",value);\n}\n```\n\nRN中调用原生的`testPassValue`方法\n\n```\nimport {\n    NativeModules,\n} from 'react-native';\n\nvar ReactViewController = NativeModules.ReactViewController;\n\n//方法调用\nReactViewController.testPassValue('I pass this value to controller');\n```\n\n注意: RN调用原生方法的时候,如果涉及到UI操作,记得使用`dispatch_async(dispatch_get_main_queue(), ^{});`拉回主线程,另外在被调用方法中调用的self的地址和真正的这个controller的地址是不一样的,所以在进入RN的controller的时候要把self保存起来,比如另外创建一个单例之类的,然后RN回调原生的时候取出控制器对象才可使用.\n\n类似下面这个例子是pop掉RN所在的控制器\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 保存到单例\n    [RNSingleton sharedInstance].rnvc = self;\n    \n    // Do any additional setup after loading the view.\n    self.navigationController.navigationBarHidden = YES;\n    NSString * strUrl = @\"http://localhost:8081/index.ios.bundle?platform=ios&dev=true\";\n    NSURL * jsCodeLocation = [NSURL URLWithString:strUrl];\n    \n    RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\n                                                         moduleName:@\"Test\"\n                                                  initialProperties:self.params\n                                                      launchOptions:nil];\n    self.view = rootView;\n}\n\n// 导出模块\nRCT_EXPORT_MODULE(); // 此处不添加参数默认为这个类的类名\n\nRCT_EXPORT_METHOD(testPassValue:(NSString *)value)\n{\n    NSLog(@\"%@\",value);\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [[RNSingleton sharedInstance].rnvc.navigationController popViewControllerAnimated:YES];\n    });\n}\n\n```","source":"_posts/ReactNative与iOS原生代码之间传值.md","raw":"---\ntitle: ReactNative与iOS原生代码之间传值\nauthor: Arclin\ntags:\n  - React Native\ncategories:\n  - React Native\nabbrlink: a8a5ff12\ndate: 2017-02-26 00:00:00\n---\n本文包含两部分:\n\n- 原生传值到RN\n- RN传值到原生\n\n<!-- more -->\n\n### 原生传值到RN\n\n加载`RCTRootView`的时候在`initialProperties`内传值\n\n```\nNSDictionary *params = @{@\"image\":@\"https://dn-coding-net-production-static.qbox.me/ac823dee-6303-4745-9216-711ab4d83753.png?imageMogr2/auto-orient/format/png/crop/!651x651a0a0\"};\n\nRCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\n                                                         moduleName:@\"Test\"\n                                                  initialProperties:params\n                                                      launchOptions:nil];\n```\n\n发送的值可以在`this.props`内得到,像上面的例子就是`this.props.image`\n\n```\n<View style={[styles.tabContent,{backgroundColor:color}]}>\n            <Text style={styles.tabText}>{pageText}</Text>\n            <Text style={styles.tabText}>第{num}次重复渲染{pageText}</Text>\n            <Text stype={styles.tabText}>{this._renderImage(this.props.image)}</Text>\n</View>\n```\n\n### RN传值到原生\n\n原生代码实现协议`RCTBridgeModule`,如下\n\n```\n#import <React/RCTBridgeModule.h>\n\n@interface ReactViewController : UIViewController<RCTBridgeModule>\n\n@end\n```\n\n添加方法,下面代码中的`testPassValue`给这个Controller声明一个`testPassValue`方法,在RN中可以调用这个方法\n\n```\n// 导出模块\nRCT_EXPORT_MODULE(); // 此处不添加参数默认为这个类的类名\n\nRCT_EXPORT_METHOD(testPassValue:(NSString *)value)\n{\n    NSLog(@\"%@\",value);\n}\n```\n\nRN中调用原生的`testPassValue`方法\n\n```\nimport {\n    NativeModules,\n} from 'react-native';\n\nvar ReactViewController = NativeModules.ReactViewController;\n\n//方法调用\nReactViewController.testPassValue('I pass this value to controller');\n```\n\n注意: RN调用原生方法的时候,如果涉及到UI操作,记得使用`dispatch_async(dispatch_get_main_queue(), ^{});`拉回主线程,另外在被调用方法中调用的self的地址和真正的这个controller的地址是不一样的,所以在进入RN的controller的时候要把self保存起来,比如另外创建一个单例之类的,然后RN回调原生的时候取出控制器对象才可使用.\n\n类似下面这个例子是pop掉RN所在的控制器\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 保存到单例\n    [RNSingleton sharedInstance].rnvc = self;\n    \n    // Do any additional setup after loading the view.\n    self.navigationController.navigationBarHidden = YES;\n    NSString * strUrl = @\"http://localhost:8081/index.ios.bundle?platform=ios&dev=true\";\n    NSURL * jsCodeLocation = [NSURL URLWithString:strUrl];\n    \n    RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\n                                                         moduleName:@\"Test\"\n                                                  initialProperties:self.params\n                                                      launchOptions:nil];\n    self.view = rootView;\n}\n\n// 导出模块\nRCT_EXPORT_MODULE(); // 此处不添加参数默认为这个类的类名\n\nRCT_EXPORT_METHOD(testPassValue:(NSString *)value)\n{\n    NSLog(@\"%@\",value);\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [[RNSingleton sharedInstance].rnvc.navigationController popViewControllerAnimated:YES];\n    });\n}\n\n```","slug":"ReactNative与iOS原生代码之间传值","published":1,"updated":"2021-06-06T18:52:24.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoh3001ptnn0attgf3gr","content":"<p>本文包含两部分:</p>\n<ul>\n<li>原生传值到RN</li>\n<li>RN传值到原生</li>\n</ul>\n<span id=\"more\"></span>\n\n<h3 id=\"原生传值到RN\"><a href=\"#原生传值到RN\" class=\"headerlink\" title=\"原生传值到RN\"></a>原生传值到RN</h3><p>加载<code>RCTRootView</code>的时候在<code>initialProperties</code>内传值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSDictionary *params &#x3D; @&#123;@&quot;image&quot;:@&quot;https:&#x2F;&#x2F;dn-coding-net-production-static.qbox.me&#x2F;ac823dee-6303-4745-9216-711ab4d83753.png?imageMogr2&#x2F;auto-orient&#x2F;format&#x2F;png&#x2F;crop&#x2F;!651x651a0a0&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">RCTRootView * rootView &#x3D; [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class=\"line\">                                                         moduleName:@&quot;Test&quot;</span><br><span class=\"line\">                                                  initialProperties:params</span><br><span class=\"line\">                                                      launchOptions:nil];</span><br></pre></td></tr></table></figure>\n\n<p>发送的值可以在<code>this.props</code>内得到,像上面的例子就是<code>this.props.image</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;View style&#x3D;&#123;[styles.tabContent,&#123;backgroundColor:color&#125;]&#125;&gt;</span><br><span class=\"line\">            &lt;Text style&#x3D;&#123;styles.tabText&#125;&gt;&#123;pageText&#125;&lt;&#x2F;Text&gt;</span><br><span class=\"line\">            &lt;Text style&#x3D;&#123;styles.tabText&#125;&gt;第&#123;num&#125;次重复渲染&#123;pageText&#125;&lt;&#x2F;Text&gt;</span><br><span class=\"line\">            &lt;Text stype&#x3D;&#123;styles.tabText&#125;&gt;&#123;this._renderImage(this.props.image)&#125;&lt;&#x2F;Text&gt;</span><br><span class=\"line\">&lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RN传值到原生\"><a href=\"#RN传值到原生\" class=\"headerlink\" title=\"RN传值到原生\"></a>RN传值到原生</h3><p>原生代码实现协议<code>RCTBridgeModule</code>,如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;React&#x2F;RCTBridgeModule.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface ReactViewController : UIViewController&lt;RCTBridgeModule&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>添加方法,下面代码中的<code>testPassValue</code>给这个Controller声明一个<code>testPassValue</code>方法,在RN中可以调用这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 导出模块</span><br><span class=\"line\">RCT_EXPORT_MODULE(); &#x2F;&#x2F; 此处不添加参数默认为这个类的类名</span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_METHOD(testPassValue:(NSString *)value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>RN中调用原生的<code>testPassValue</code>方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;</span><br><span class=\"line\">    NativeModules,</span><br><span class=\"line\">&#125; from &#39;react-native&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">var ReactViewController &#x3D; NativeModules.ReactViewController;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;方法调用</span><br><span class=\"line\">ReactViewController.testPassValue(&#39;I pass this value to controller&#39;);</span><br></pre></td></tr></table></figure>\n\n<p>注意: RN调用原生方法的时候,如果涉及到UI操作,记得使用<code>dispatch_async(dispatch_get_main_queue(), ^&#123;&#125;);</code>拉回主线程,另外在被调用方法中调用的self的地址和真正的这个controller的地址是不一样的,所以在进入RN的controller的时候要把self保存起来,比如另外创建一个单例之类的,然后RN回调原生的时候取出控制器对象才可使用.</p>\n<p>类似下面这个例子是pop掉RN所在的控制器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 保存到单例</span><br><span class=\"line\">    [RNSingleton sharedInstance].rnvc &#x3D; self;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class=\"line\">    self.navigationController.navigationBarHidden &#x3D; YES;</span><br><span class=\"line\">    NSString * strUrl &#x3D; @&quot;http:&#x2F;&#x2F;localhost:8081&#x2F;index.ios.bundle?platform&#x3D;ios&amp;dev&#x3D;true&quot;;</span><br><span class=\"line\">    NSURL * jsCodeLocation &#x3D; [NSURL URLWithString:strUrl];</span><br><span class=\"line\">    </span><br><span class=\"line\">    RCTRootView * rootView &#x3D; [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class=\"line\">                                                         moduleName:@&quot;Test&quot;</span><br><span class=\"line\">                                                  initialProperties:self.params</span><br><span class=\"line\">                                                      launchOptions:nil];</span><br><span class=\"line\">    self.view &#x3D; rootView;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 导出模块</span><br><span class=\"line\">RCT_EXPORT_MODULE(); &#x2F;&#x2F; 此处不添加参数默认为这个类的类名</span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_METHOD(testPassValue:(NSString *)value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,value);</span><br><span class=\"line\">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        [[RNSingleton sharedInstance].rnvc.navigationController popViewControllerAnimated:YES];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>本文包含两部分:</p>\n<ul>\n<li>原生传值到RN</li>\n<li>RN传值到原生</li>\n</ul>","more":"<h3 id=\"原生传值到RN\"><a href=\"#原生传值到RN\" class=\"headerlink\" title=\"原生传值到RN\"></a>原生传值到RN</h3><p>加载<code>RCTRootView</code>的时候在<code>initialProperties</code>内传值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSDictionary *params &#x3D; @&#123;@&quot;image&quot;:@&quot;https:&#x2F;&#x2F;dn-coding-net-production-static.qbox.me&#x2F;ac823dee-6303-4745-9216-711ab4d83753.png?imageMogr2&#x2F;auto-orient&#x2F;format&#x2F;png&#x2F;crop&#x2F;!651x651a0a0&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">RCTRootView * rootView &#x3D; [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class=\"line\">                                                         moduleName:@&quot;Test&quot;</span><br><span class=\"line\">                                                  initialProperties:params</span><br><span class=\"line\">                                                      launchOptions:nil];</span><br></pre></td></tr></table></figure>\n\n<p>发送的值可以在<code>this.props</code>内得到,像上面的例子就是<code>this.props.image</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;View style&#x3D;&#123;[styles.tabContent,&#123;backgroundColor:color&#125;]&#125;&gt;</span><br><span class=\"line\">            &lt;Text style&#x3D;&#123;styles.tabText&#125;&gt;&#123;pageText&#125;&lt;&#x2F;Text&gt;</span><br><span class=\"line\">            &lt;Text style&#x3D;&#123;styles.tabText&#125;&gt;第&#123;num&#125;次重复渲染&#123;pageText&#125;&lt;&#x2F;Text&gt;</span><br><span class=\"line\">            &lt;Text stype&#x3D;&#123;styles.tabText&#125;&gt;&#123;this._renderImage(this.props.image)&#125;&lt;&#x2F;Text&gt;</span><br><span class=\"line\">&lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RN传值到原生\"><a href=\"#RN传值到原生\" class=\"headerlink\" title=\"RN传值到原生\"></a>RN传值到原生</h3><p>原生代码实现协议<code>RCTBridgeModule</code>,如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;React&#x2F;RCTBridgeModule.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface ReactViewController : UIViewController&lt;RCTBridgeModule&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>添加方法,下面代码中的<code>testPassValue</code>给这个Controller声明一个<code>testPassValue</code>方法,在RN中可以调用这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 导出模块</span><br><span class=\"line\">RCT_EXPORT_MODULE(); &#x2F;&#x2F; 此处不添加参数默认为这个类的类名</span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_METHOD(testPassValue:(NSString *)value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>RN中调用原生的<code>testPassValue</code>方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;</span><br><span class=\"line\">    NativeModules,</span><br><span class=\"line\">&#125; from &#39;react-native&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">var ReactViewController &#x3D; NativeModules.ReactViewController;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;方法调用</span><br><span class=\"line\">ReactViewController.testPassValue(&#39;I pass this value to controller&#39;);</span><br></pre></td></tr></table></figure>\n\n<p>注意: RN调用原生方法的时候,如果涉及到UI操作,记得使用<code>dispatch_async(dispatch_get_main_queue(), ^&#123;&#125;);</code>拉回主线程,另外在被调用方法中调用的self的地址和真正的这个controller的地址是不一样的,所以在进入RN的controller的时候要把self保存起来,比如另外创建一个单例之类的,然后RN回调原生的时候取出控制器对象才可使用.</p>\n<p>类似下面这个例子是pop掉RN所在的控制器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 保存到单例</span><br><span class=\"line\">    [RNSingleton sharedInstance].rnvc &#x3D; self;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class=\"line\">    self.navigationController.navigationBarHidden &#x3D; YES;</span><br><span class=\"line\">    NSString * strUrl &#x3D; @&quot;http:&#x2F;&#x2F;localhost:8081&#x2F;index.ios.bundle?platform&#x3D;ios&amp;dev&#x3D;true&quot;;</span><br><span class=\"line\">    NSURL * jsCodeLocation &#x3D; [NSURL URLWithString:strUrl];</span><br><span class=\"line\">    </span><br><span class=\"line\">    RCTRootView * rootView &#x3D; [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class=\"line\">                                                         moduleName:@&quot;Test&quot;</span><br><span class=\"line\">                                                  initialProperties:self.params</span><br><span class=\"line\">                                                      launchOptions:nil];</span><br><span class=\"line\">    self.view &#x3D; rootView;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 导出模块</span><br><span class=\"line\">RCT_EXPORT_MODULE(); &#x2F;&#x2F; 此处不添加参数默认为这个类的类名</span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_METHOD(testPassValue:(NSString *)value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,value);</span><br><span class=\"line\">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        [[RNSingleton sharedInstance].rnvc.navigationController popViewControllerAnimated:YES];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"ReactNative网络请求","author":"Arclin","abbrlink":"b6bd206a","date":"2017-03-14T16:00:00.000Z","_content":"关于React Native 的网络请求的总结\n\n<!-- more -->\n\n因为这里使用的是`fetch()`方法,返回的是一个`Promise`对象,所以可以使用`then()`和`catch()`方法进行链式调用,也可以用`all()`,`race()` 去包装多个请求\n\n具体的话可以看这里\n\n### GET\n```\nfetch(\"http://localhost:3000/get\")\n\t.then((response) => response.json()) // 这里取出响应体的JSON数据并返回\n\t.then((responseJSON) => { // 处理上面返回的JSON数据\n\t\t// do something\n\t\t\n\t})\n\t.catch((err) => { // 捕获错误\n\t\t// catch err\n\t});\n```\n### POST\n网上说有两种,不过我一般用第二种比较多\n\n#### application/json\n```\nvar fetchOptions = {\n           method: 'POST',\n           headers: {\n               'Accept': 'application/json',\n               //json形式\n               'Content-Type': 'application/json'\n           },\n           body:JSON.stringify('data=test') // 这里是请求参数,键值对形式\n       };\n\nfetch(\"http://localhost:3000/post\", fetchOptions)\n   .then((response) => response.json())\n   .then((responseText) => {\n        console.log(responseText);\n   });\n```\n\n#### application/x-www-form-urlencoded\n\n```\n var fetchOptions = {\n           method: 'POST',\n           headers: {\n               'Accept': 'application/json',\n               //表单\n               'Content-Type': 'application/x-www-form-urlencoded'\n           },\n           body:'data=test' // 这里是请求参数,键值对形式\n       };\n\nfetch(\"http://localhost:3000/post\", fetchOptions)\n   .then((response) => response.json())\n   .then((responseText) => {\n        console.log(responseText);\n   });\n```\n如果使用的是Restful的API的话,那么只要把上面`fetchOption`里面的`method`改成对应的方法就好.\n\n当然,封装一个网络请求工具是有必要的,等我有时间写一下.","source":"_posts/ReactNative网络请求.md","raw":"---\ntitle: ReactNative网络请求\nauthor: Arclin\ntags:\n  - React Native\ncategories:\n  - React Native\nabbrlink: b6bd206a\ndate: 2017-03-15 00:00:00\n---\n关于React Native 的网络请求的总结\n\n<!-- more -->\n\n因为这里使用的是`fetch()`方法,返回的是一个`Promise`对象,所以可以使用`then()`和`catch()`方法进行链式调用,也可以用`all()`,`race()` 去包装多个请求\n\n具体的话可以看这里\n\n### GET\n```\nfetch(\"http://localhost:3000/get\")\n\t.then((response) => response.json()) // 这里取出响应体的JSON数据并返回\n\t.then((responseJSON) => { // 处理上面返回的JSON数据\n\t\t// do something\n\t\t\n\t})\n\t.catch((err) => { // 捕获错误\n\t\t// catch err\n\t});\n```\n### POST\n网上说有两种,不过我一般用第二种比较多\n\n#### application/json\n```\nvar fetchOptions = {\n           method: 'POST',\n           headers: {\n               'Accept': 'application/json',\n               //json形式\n               'Content-Type': 'application/json'\n           },\n           body:JSON.stringify('data=test') // 这里是请求参数,键值对形式\n       };\n\nfetch(\"http://localhost:3000/post\", fetchOptions)\n   .then((response) => response.json())\n   .then((responseText) => {\n        console.log(responseText);\n   });\n```\n\n#### application/x-www-form-urlencoded\n\n```\n var fetchOptions = {\n           method: 'POST',\n           headers: {\n               'Accept': 'application/json',\n               //表单\n               'Content-Type': 'application/x-www-form-urlencoded'\n           },\n           body:'data=test' // 这里是请求参数,键值对形式\n       };\n\nfetch(\"http://localhost:3000/post\", fetchOptions)\n   .then((response) => response.json())\n   .then((responseText) => {\n        console.log(responseText);\n   });\n```\n如果使用的是Restful的API的话,那么只要把上面`fetchOption`里面的`method`改成对应的方法就好.\n\n当然,封装一个网络请求工具是有必要的,等我有时间写一下.","slug":"ReactNative网络请求","published":1,"updated":"2021-06-06T18:52:24.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoh4001ttnn0d3f746sh","content":"<p>关于React Native 的网络请求的总结</p>\n<span id=\"more\"></span>\n\n<p>因为这里使用的是<code>fetch()</code>方法,返回的是一个<code>Promise</code>对象,所以可以使用<code>then()</code>和<code>catch()</code>方法进行链式调用,也可以用<code>all()</code>,<code>race()</code> 去包装多个请求</p>\n<p>具体的话可以看这里</p>\n<h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;get&quot;)</span><br><span class=\"line\">\t.then((response) &#x3D;&gt; response.json()) &#x2F;&#x2F; 这里取出响应体的JSON数据并返回</span><br><span class=\"line\">\t.then((responseJSON) &#x3D;&gt; &#123; &#x2F;&#x2F; 处理上面返回的JSON数据</span><br><span class=\"line\">\t\t&#x2F;&#x2F; do something</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.catch((err) &#x3D;&gt; &#123; &#x2F;&#x2F; 捕获错误</span><br><span class=\"line\">\t\t&#x2F;&#x2F; catch err</span><br><span class=\"line\">\t&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h3><p>网上说有两种,不过我一般用第二种比较多</p>\n<h4 id=\"application-json\"><a href=\"#application-json\" class=\"headerlink\" title=\"application/json\"></a>application/json</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fetchOptions &#x3D; &#123;</span><br><span class=\"line\">           method: &#39;POST&#39;,</span><br><span class=\"line\">           headers: &#123;</span><br><span class=\"line\">               &#39;Accept&#39;: &#39;application&#x2F;json&#39;,</span><br><span class=\"line\">               &#x2F;&#x2F;json形式</span><br><span class=\"line\">               &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           body:JSON.stringify(&#39;data&#x3D;test&#39;) &#x2F;&#x2F; 这里是请求参数,键值对形式</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fetch(&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;post&quot;, fetchOptions)</span><br><span class=\"line\">   .then((response) &#x3D;&gt; response.json())</span><br><span class=\"line\">   .then((responseText) &#x3D;&gt; &#123;</span><br><span class=\"line\">        console.log(responseText);</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"application-x-www-form-urlencoded\"><a href=\"#application-x-www-form-urlencoded\" class=\"headerlink\" title=\"application/x-www-form-urlencoded\"></a>application/x-www-form-urlencoded</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var fetchOptions &#x3D; &#123;</span><br><span class=\"line\">           method: &#39;POST&#39;,</span><br><span class=\"line\">           headers: &#123;</span><br><span class=\"line\">               &#39;Accept&#39;: &#39;application&#x2F;json&#39;,</span><br><span class=\"line\">               &#x2F;&#x2F;表单</span><br><span class=\"line\">               &#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39;</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           body:&#39;data&#x3D;test&#39; &#x2F;&#x2F; 这里是请求参数,键值对形式</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fetch(&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;post&quot;, fetchOptions)</span><br><span class=\"line\">   .then((response) &#x3D;&gt; response.json())</span><br><span class=\"line\">   .then((responseText) &#x3D;&gt; &#123;</span><br><span class=\"line\">        console.log(responseText);</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n<p>如果使用的是Restful的API的话,那么只要把上面<code>fetchOption</code>里面的<code>method</code>改成对应的方法就好.</p>\n<p>当然,封装一个网络请求工具是有必要的,等我有时间写一下.</p>\n","site":{"data":{}},"excerpt":"<p>关于React Native 的网络请求的总结</p>","more":"<p>因为这里使用的是<code>fetch()</code>方法,返回的是一个<code>Promise</code>对象,所以可以使用<code>then()</code>和<code>catch()</code>方法进行链式调用,也可以用<code>all()</code>,<code>race()</code> 去包装多个请求</p>\n<p>具体的话可以看这里</p>\n<h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;get&quot;)</span><br><span class=\"line\">\t.then((response) &#x3D;&gt; response.json()) &#x2F;&#x2F; 这里取出响应体的JSON数据并返回</span><br><span class=\"line\">\t.then((responseJSON) &#x3D;&gt; &#123; &#x2F;&#x2F; 处理上面返回的JSON数据</span><br><span class=\"line\">\t\t&#x2F;&#x2F; do something</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.catch((err) &#x3D;&gt; &#123; &#x2F;&#x2F; 捕获错误</span><br><span class=\"line\">\t\t&#x2F;&#x2F; catch err</span><br><span class=\"line\">\t&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h3><p>网上说有两种,不过我一般用第二种比较多</p>\n<h4 id=\"application-json\"><a href=\"#application-json\" class=\"headerlink\" title=\"application/json\"></a>application/json</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fetchOptions &#x3D; &#123;</span><br><span class=\"line\">           method: &#39;POST&#39;,</span><br><span class=\"line\">           headers: &#123;</span><br><span class=\"line\">               &#39;Accept&#39;: &#39;application&#x2F;json&#39;,</span><br><span class=\"line\">               &#x2F;&#x2F;json形式</span><br><span class=\"line\">               &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           body:JSON.stringify(&#39;data&#x3D;test&#39;) &#x2F;&#x2F; 这里是请求参数,键值对形式</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fetch(&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;post&quot;, fetchOptions)</span><br><span class=\"line\">   .then((response) &#x3D;&gt; response.json())</span><br><span class=\"line\">   .then((responseText) &#x3D;&gt; &#123;</span><br><span class=\"line\">        console.log(responseText);</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"application-x-www-form-urlencoded\"><a href=\"#application-x-www-form-urlencoded\" class=\"headerlink\" title=\"application/x-www-form-urlencoded\"></a>application/x-www-form-urlencoded</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var fetchOptions &#x3D; &#123;</span><br><span class=\"line\">           method: &#39;POST&#39;,</span><br><span class=\"line\">           headers: &#123;</span><br><span class=\"line\">               &#39;Accept&#39;: &#39;application&#x2F;json&#39;,</span><br><span class=\"line\">               &#x2F;&#x2F;表单</span><br><span class=\"line\">               &#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39;</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           body:&#39;data&#x3D;test&#39; &#x2F;&#x2F; 这里是请求参数,键值对形式</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fetch(&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;post&quot;, fetchOptions)</span><br><span class=\"line\">   .then((response) &#x3D;&gt; response.json())</span><br><span class=\"line\">   .then((responseText) &#x3D;&gt; &#123;</span><br><span class=\"line\">        console.log(responseText);</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n<p>如果使用的是Restful的API的话,那么只要把上面<code>fetchOption</code>里面的<code>method</code>改成对应的方法就好.</p>\n<p>当然,封装一个网络请求工具是有必要的,等我有时间写一下.</p>"},{"title":"RAC关于cell上的按钮点击后会重复发送信号的问题","author":"Arclin","abbrlink":"452efb32","date":"2016-10-16T16:00:00.000Z","_content":"关于cell上的按钮点击后会重复发送信号的问题\n\nRAC给`UITableViewCell`提供了一个方法：`rac_prepareForReuseSignal`，它的作用是当Cell即将要被重用时，告诉Cell。想象Cell上有多个button，Cell在初始化时给每个button都`addTarget:action:forControlEvents`，被重用时需要先移除这些target，下面这段代码就可以很方便地解决这个问题：\n\n```\n[[[self.cancelButton\n    rac_signalForControlEvents:UIControlEventTouchUpInside]\n    takeUntil:self.rac_prepareForReuseSignal]\n    subscribeNext:^(UIButton *x) {\n    // do other things\n}];\n```","source":"_posts/RAC关于cell上的按钮点击后会重复发送信号的问题.md","raw":"---\ntitle: RAC关于cell上的按钮点击后会重复发送信号的问题\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 452efb32\ndate: 2016-10-17 00:00:00\n---\n关于cell上的按钮点击后会重复发送信号的问题\n\nRAC给`UITableViewCell`提供了一个方法：`rac_prepareForReuseSignal`，它的作用是当Cell即将要被重用时，告诉Cell。想象Cell上有多个button，Cell在初始化时给每个button都`addTarget:action:forControlEvents`，被重用时需要先移除这些target，下面这段代码就可以很方便地解决这个问题：\n\n```\n[[[self.cancelButton\n    rac_signalForControlEvents:UIControlEventTouchUpInside]\n    takeUntil:self.rac_prepareForReuseSignal]\n    subscribeNext:^(UIButton *x) {\n    // do other things\n}];\n```","slug":"RAC关于cell上的按钮点击后会重复发送信号的问题","published":1,"updated":"2021-06-06T18:52:24.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoh5001vtnn0g4uwelg1","content":"<p>关于cell上的按钮点击后会重复发送信号的问题</p>\n<p>RAC给<code>UITableViewCell</code>提供了一个方法：<code>rac_prepareForReuseSignal</code>，它的作用是当Cell即将要被重用时，告诉Cell。想象Cell上有多个button，Cell在初始化时给每个button都<code>addTarget:action:forControlEvents</code>，被重用时需要先移除这些target，下面这段代码就可以很方便地解决这个问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[[self.cancelButton</span><br><span class=\"line\">    rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class=\"line\">    takeUntil:self.rac_prepareForReuseSignal]</span><br><span class=\"line\">    subscribeNext:^(UIButton *x) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; do other things</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>关于cell上的按钮点击后会重复发送信号的问题</p>\n<p>RAC给<code>UITableViewCell</code>提供了一个方法：<code>rac_prepareForReuseSignal</code>，它的作用是当Cell即将要被重用时，告诉Cell。想象Cell上有多个button，Cell在初始化时给每个button都<code>addTarget:action:forControlEvents</code>，被重用时需要先移除这些target，下面这段代码就可以很方便地解决这个问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[[self.cancelButton</span><br><span class=\"line\">    rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class=\"line\">    takeUntil:self.rac_prepareForReuseSignal]</span><br><span class=\"line\">    subscribeNext:^(UIButton *x) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; do other things</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>"},{"title":"Sign in with Apple接入指南","author":"Arclin","abbrlink":"ac0a85bd","date":"2019-11-01T05:15:00.000Z","_content":"如果你的应用接入了第三方登陆，那么请同时接入苹果登录。\n\n<!-- more -->\n\n[苹果审核指南的相关内容](https://developer.apple.com/app-store/review/guidelines/#sign-in-with-apple)\n[新闻：2020年4月前需要适配好苹果登录](https://developer.apple.com/news/?id=09122019b)\n\n## 简单接入\n\n[苹果登录官方文档](https://developer.apple.com/sign-in-with-apple/)\n\n流程：\n\n用户点击按钮 --- 调起苹果登录 --- 授权成功 --- 获取唯一标识符和其他信息 --- 返回给后端 --- 后端注册/登录 --- 返回token --- 登录成功\n\n### 必要的工作\n\n1. 首先去苹果后台开启`Sign in with apple`选项，然后重新导出`provisionprofile`证书\n\n2. 授权\n\t```\n\tASAuthorizationAppleIDProvider *provider = [[ASAuthorizationAppleIDProvider alloc] init];\n\tASAuthorizationAppleIDRequest *request = [provider createRequest];\n\trequest.requestedScopes = @[ASAuthorizationScopeFullName, ASAuthorizationScopeEmail];\n\n\tNSMutableArray <ASAuthorizationRequest *>* array = [NSMutableArray arrayWithCapacity:2];\n\tif (request) [array addObject:request];\n\n\tNSArray<ASAuthorizationRequest *> *requests = [array copy];\n\tASAuthorizationController *authorizationController = [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];\n\tauthorizationController.delegate = self;\n\tauthorizationController.presentationContextProvider = input;\n\t[authorizationController performRequests];\n\t```\n\n3. 回调，遵循回调`ASAuthorizationControllerPresentationContextProviding`\n\n\t```\n\t- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization API_AVAILABLE(ios(13.0))\n\t{\n\tif ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) {\n\t\t// 用户登录使用ASAuthorizationAppleIDCredential\n\t\tASAuthorizationAppleIDCredential *appleIDCredential = (ASAuthorizationAppleIDCredential *)authorization.credential;\n\t\tNSString *user = appleIDCredential.user;\n\t\tNSString *namePerfix = appleIDCredential.fullName.namePrefix;\n\t\tNSString *givenName = appleIDCredential.fullName.givenName;\n\t\tNSString *middleName = appleIDCredential.fullName.middleName;\n\t\tNSString *familyName = appleIDCredential.fullName.familyName;\n\t\tNSString *nameSuffix = appleIDCredential.fullName.nameSuffix;\n\t\tNSString *email = appleIDCredential.email;\n\t\tNSString *nickname = appleIDCredential.fullName.nickname;\n\n\t\tif (!nickname || nickname.length == 0) {\n\t\t\tnickname = [NSString stringWithFormat:@\"%@%@%@%@%@\",namePerfix?:@\"\",familyName?:@\"\",givenName?:@\"\",middleName?:@\"\",nameSuffix?:@\"\"];\n\t\t}\n\t} else {\n\t\t[self.errorSubject sendNext:LMError(@\"授权信息有误\")];\n\t}\n\t}\n\t- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithError:(NSError *)error API_AVAILABLE(ios(13.0))\n\t{\n\tNSString *errorMsg = nil;\n\tswitch (error.code) {\n\t\tcase ASAuthorizationErrorCanceled:\n\t\t\t\terrorMsg = @\"用户取消了授权请求\";\n\t\t\t\treturn;\n\t\t\tcase ASAuthorizationErrorFailed:\n\t\t\t\terrorMsg = @\"授权请求失败\";\n\t\t\t\tbreak;\n\t\t\tcase ASAuthorizationErrorInvalidResponse:\n\t\t\t\terrorMsg = @\"授权请求响应无效\";\n\t\t\t\tbreak;\n\t\t\tcase ASAuthorizationErrorNotHandled:\n\t\t\t\terrorMsg = @\"未能处理授权请求\";\n\t\t\t\tbreak;\n\t\t\tcase ASAuthorizationErrorUnknown:\n\t\t\t\terrorMsg = @\"授权请求失败未知原因\";\n\t\t\t\tbreak;\n\t\t}\n\t\t[self.errorSubject sendNext:LMError(errorMsg)];\n\t}\n\t```\n\n## 其他可选项\n\n### 苹果提供的登录按钮\n\n```\nASAuthorizationAppleIDButton *button = [ASAuthorizationAppleIDButton buttonWithType:ASAuthorizationAppleIDButtonTypeSignIn style:ASAuthorizationAppleIDButtonStyleWhiteOutline];\n```\n\n其中\n\n```\ntypedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonType) {\n    ASAuthorizationAppleIDButtonTypeSignIn, // 按钮文字显示 ：通过Apple登录\n    ASAuthorizationAppleIDButtonTypeContinue, // 按钮文字显示 ：通过Apple继续\n\n    ASAuthorizationAppleIDButtonTypeDefault = // 默认第一个 ASAuthorizationAppleIDButtonTypeSignIn,\n}\n\ntypedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonStyle) {\n    ASAuthorizationAppleIDButtonStyleWhite, // 白底黑字\n    ASAuthorizationAppleIDButtonStyleWhiteOutline, // 黑字白框\n    ASAuthorizationAppleIDButtonStyleBlack, // 黑底白字\n}\n\n```\n\n### 授权成功的回调可以来自于其他地方\n\n```\n//! 授权成功地回调\n- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization  API_AVAILABLE(ios(13.0)){\n    \n    NSLog(@\"%s\", __FUNCTION__);\n    NSLog(@\"%@\", controller);\n    NSLog(@\"%@\", authorization);\n    \n    NSLog(@\"authorization.credential：%@\", authorization.credential);\n    \n    NSMutableString *mStr = [NSMutableString string];\n    mStr = [_appleIDInfoTextView.text mutableCopy];\n    \n    if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) {\n        // 用户登录使用ASAuthorizationAppleIDCredential\n        ASAuthorizationAppleIDCredential *appleIDCredential = authorization.credential;\n        NSString *user = appleIDCredential.user;\n        //  最好使用钥匙串的方式保存用户的唯一信息 这里暂且处于测试阶段，用NSUserDefaults\n        [[NSUserDefaults standardUserDefaults] setValue:user forKey:QiShareCurrentIdentifier];\n        [mStr appendString:user?:@\"\"];\n        NSString *familyName = appleIDCredential.fullName.familyName;\n        [mStr appendString:familyName?:@\"\"];\n        NSString *givenName = appleIDCredential.fullName.givenName;\n        [mStr appendString:givenName?:@\"\"];\n        NSString *email = appleIDCredential.email;\n        [mStr appendString:email?:@\"\"];\n        NSLog(@\"mStr：%@\", mStr);\n        [mStr appendString:@\"\\n\"];\n        _appleIDInfoTextView.text = mStr;\n        \n    } else if ([authorization.credential isKindOfClass:[ASPasswordCredential class]]) {\n        // 用户登录使用现有的密码凭证\n        ASPasswordCredential *passwordCredential = authorization.credential;\n        // 密码凭证对象的用户标识 用户的唯一标识\n        NSString *user = passwordCredential.user;\n        // 密码凭证对象的密码\n        NSString *password = passwordCredential.password;\n        [mStr appendString:user?:@\"\"];\n        [mStr appendString:password?:@\"\"];\n        [mStr appendString:@\"\\n\"];\n        NSLog(@\"mStr：%@\", mStr);\n        _appleIDInfoTextView.text = mStr;\n    } else {\n        NSLog(@\"授权信息均不符\");\n        mStr = [@\"授权信息均不符\" mutableCopy];\n        _appleIDInfoTextView.text = mStr;\n    }\n}\n```\n\n### 已经使用Sign In With Apple登录过app的用户\n\n执行已经登录过的场景。如果设备中存在iCloud Keychain 凭证或者AppleID 凭证提示用户直接使用TouchID或FaceID登录即可。\n\n```\n- (void)perfomExistingAccountSetupFlows {\n    if (@available(iOS 13.0, *)) {\n        // A mechanism for generating requests to authenticate users based on their Apple ID.\n        // 基于用户的Apple ID授权用户，生成用户授权请求的一种机制\n        ASAuthorizationAppleIDProvider *appleIDProvider = [ASAuthorizationAppleIDProvider new];\n        // An OpenID authorization request that relies on the user’s Apple ID.\n        // 授权请求依赖于用于的AppleID\n        ASAuthorizationAppleIDRequest *authAppleIDRequest = [appleIDProvider createRequest];\n        // A mechanism for generating requests to perform keychain credential sharing.\n        // 为了执行钥匙串凭证分享生成请求的一种机制\n        ASAuthorizationPasswordRequest *passwordRequest = [[ASAuthorizationPasswordProvider new] createRequest];\n        \n        NSMutableArray <ASAuthorizationRequest *>* mArr = [NSMutableArray arrayWithCapacity:2];\n        if (authAppleIDRequest) {\n            [mArr addObject:authAppleIDRequest];\n        }\n        if (passwordRequest) {\n            [mArr addObject:passwordRequest];\n        }\n        // ASAuthorizationRequest：A base class for different kinds of authorization requests.\n        // ASAuthorizationRequest：对于不同种类授权请求的基类\n        NSArray <ASAuthorizationRequest *>* requests = [mArr copy];\n        \n        // A controller that manages authorization requests created by a provider.\n        // 由ASAuthorizationAppleIDProvider创建的授权请求 管理授权请求的控制器\n        // Creates a controller from a collection of authorization requests.\n        // 从一系列授权请求中创建授权控制器\n        ASAuthorizationController *authorizationController = [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];\n        // A delegate that the authorization controller informs about the success or failure of an authorization attempt.\n        // 设置授权控制器通知授权请求的成功与失败的代理\n        authorizationController.delegate = self;\n        // A delegate that provides a display context in which the system can present an authorization interface to the user.\n        // 设置提供 展示上下文的代理，在这个上下文中 系统可以展示授权界面给用户\n        authorizationController.presentationContextProvider = self;\n        // starts the authorization flows named during controller initialization.\n        // 在控制器初始化期间启动授权流\n        [authorizationController performRequests];\n    }\n}\n```\n\n### 监听授权状态变化\n\n监听授权状态改变，并且做出相应处理。授权状态有：\n\n```\nASAuthorizationAppleIDProviderCredentialRevoked：授权状态失效（用户停止使用AppID 登录App）\nASAuthorizationAppleIDProviderCredentialAuthorized：已授权(已使用AppleID 登录过App）\nASAuthorizationAppleIDProviderCredentialNotFound：授权凭证缺失（可能是使用AppleID 登录过App）\n```\n\n```\n//! 观察授权状态\n- (void)observeAuthticationState {\n    \n    if (@available(iOS 13.0, *)) {\n        // A mechanism for generating requests to authenticate users based on their Apple ID.\n        // 基于用户的Apple ID 生成授权用户请求的机制\n        ASAuthorizationAppleIDProvider *appleIDProvider = [ASAuthorizationAppleIDProvider new];\n        // 注意 存储用户标识信息需要使用钥匙串来存储 这里笔者简单期间 使用NSUserDefaults 做的简单示例\n        NSString *userIdentifier = [[NSUserDefaults standardUserDefaults] valueForKey:QiShareCurrentIdentifier];\n        \n        if (userIdentifier) {\n            NSString* __block errorMsg = nil;\n            //Returns the credential state for the given user in a completion handler.\n            // 在回调中返回用户的授权状态\n            [appleIDProvider getCredentialStateForUserID:userIdentifier completion:^(ASAuthorizationAppleIDProviderCredentialState credentialState, NSError * _Nullable error) {\n                switch (credentialState) {\n                        // 苹果证书的授权状态\n                    case ASAuthorizationAppleIDProviderCredentialRevoked:\n                        // 苹果授权凭证失效\n                        errorMsg = @\"苹果授权凭证失效\";\n                        break;\n                    case ASAuthorizationAppleIDProviderCredentialAuthorized:\n                        // 苹果授权凭证状态良好\n                        errorMsg = @\"苹果授权凭证状态良好\";\n                        break;\n                    case ASAuthorizationAppleIDProviderCredentialNotFound:\n                        // 未发现苹果授权凭证\n                        errorMsg = @\"未发现苹果授权凭证\";\n                        // 可以引导用户重新登录\n                        break;\n                }\n                dispatch_async(dispatch_get_main_queue(), ^{\n                    NSLog(@\"SignInWithApple授权状态变化情况\");\n                    NSLog(@\"%@\", errorMsg);\n                });\n            }];\n            \n        }\n    }\n}\n```\n\n使用通知的方式检测是否授权应用支持Sign In With Apple变化情况。如下的代码可以根据自己的业务场景去考虑放置的位置。\n\n```\n//! 添加苹果登录的状态通知\n- (void)observeAppleSignInState {\n    if (@available(iOS 13.0, *)) {\n        NSNotificationCenter *center = [NSNotificationCenter defaultCenter];\n        [center addObserver:self selector:@selector(handleSignInWithAppleStateChanged:) name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];\n    }\n}\n \n//! 观察SignInWithApple状态改变\n- (void)handleSignInWithAppleStateChanged:(id)noti {\n    \n    NSLog(@\"%s\", __FUNCTION__);\n    NSLog(@\"%@\", noti);\n}\n \n- (void)dealloc {\n    \n    if (@available(iOS 13.0, *)) {\n        [[NSNotificationCenter defaultCenter] removeObserver:self name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];\n    }\n}\n```\n\n## 重要（Important！）\n1. 最好使用苹果提供的按钮 `ASAuthorizationAppleIDButton` （只有黑白两种颜色）\n2. 不用他的按钮的话建议使用显眼的颜色 \n3. 尽量放在显眼位置（第一位）\n4. **不能比其他任何登录按钮要小**\n5. 保证登录页面一屏就能看到苹果登录按钮，不能滚动后才能看到\n6. 按钮的最小宽高有需求（看[苹果人机交互指南相关文档](https://developer.apple.com/design/human-interface-guidelines/sign-in-with-apple/overview/)）\n7. 如果登录后要绑定手机的话，就在备注里面写好 依据来源 http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm  指明(截图)第二十四条（苹果一般不会打开网页，建议下载个pdf给他）\n8. 如果不好好跟苹果爸爸的规矩来，那么可能会吃到2.1和4.0 (不要问我为什么知道)\n\n(更新至2019/11/01)\n\n|  最小宽度 | 最小高度  | 最小间距|\n| ------------ | ------------ | ------------ |\n| 140pt (140px @1x, 280px @2x)  |  30pt (30px @1x, 60px @2x) | 1/10 of the button's height）| \n\n## 参考其他教程\n\n[掘金](https://juejin.im/post/5d8c64d151882509606d6b17)\n","source":"_posts/Sign-in-with-Apple接入指南.md","raw":"title: Sign in with Apple接入指南\nauthor: Arclin\nabbrlink: ac0a85bd\ntags:\n  - iOS\ncategories:\n  - iOS\ndate: 2019-11-01 13:15:00\n---\n如果你的应用接入了第三方登陆，那么请同时接入苹果登录。\n\n<!-- more -->\n\n[苹果审核指南的相关内容](https://developer.apple.com/app-store/review/guidelines/#sign-in-with-apple)\n[新闻：2020年4月前需要适配好苹果登录](https://developer.apple.com/news/?id=09122019b)\n\n## 简单接入\n\n[苹果登录官方文档](https://developer.apple.com/sign-in-with-apple/)\n\n流程：\n\n用户点击按钮 --- 调起苹果登录 --- 授权成功 --- 获取唯一标识符和其他信息 --- 返回给后端 --- 后端注册/登录 --- 返回token --- 登录成功\n\n### 必要的工作\n\n1. 首先去苹果后台开启`Sign in with apple`选项，然后重新导出`provisionprofile`证书\n\n2. 授权\n\t```\n\tASAuthorizationAppleIDProvider *provider = [[ASAuthorizationAppleIDProvider alloc] init];\n\tASAuthorizationAppleIDRequest *request = [provider createRequest];\n\trequest.requestedScopes = @[ASAuthorizationScopeFullName, ASAuthorizationScopeEmail];\n\n\tNSMutableArray <ASAuthorizationRequest *>* array = [NSMutableArray arrayWithCapacity:2];\n\tif (request) [array addObject:request];\n\n\tNSArray<ASAuthorizationRequest *> *requests = [array copy];\n\tASAuthorizationController *authorizationController = [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];\n\tauthorizationController.delegate = self;\n\tauthorizationController.presentationContextProvider = input;\n\t[authorizationController performRequests];\n\t```\n\n3. 回调，遵循回调`ASAuthorizationControllerPresentationContextProviding`\n\n\t```\n\t- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization API_AVAILABLE(ios(13.0))\n\t{\n\tif ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) {\n\t\t// 用户登录使用ASAuthorizationAppleIDCredential\n\t\tASAuthorizationAppleIDCredential *appleIDCredential = (ASAuthorizationAppleIDCredential *)authorization.credential;\n\t\tNSString *user = appleIDCredential.user;\n\t\tNSString *namePerfix = appleIDCredential.fullName.namePrefix;\n\t\tNSString *givenName = appleIDCredential.fullName.givenName;\n\t\tNSString *middleName = appleIDCredential.fullName.middleName;\n\t\tNSString *familyName = appleIDCredential.fullName.familyName;\n\t\tNSString *nameSuffix = appleIDCredential.fullName.nameSuffix;\n\t\tNSString *email = appleIDCredential.email;\n\t\tNSString *nickname = appleIDCredential.fullName.nickname;\n\n\t\tif (!nickname || nickname.length == 0) {\n\t\t\tnickname = [NSString stringWithFormat:@\"%@%@%@%@%@\",namePerfix?:@\"\",familyName?:@\"\",givenName?:@\"\",middleName?:@\"\",nameSuffix?:@\"\"];\n\t\t}\n\t} else {\n\t\t[self.errorSubject sendNext:LMError(@\"授权信息有误\")];\n\t}\n\t}\n\t- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithError:(NSError *)error API_AVAILABLE(ios(13.0))\n\t{\n\tNSString *errorMsg = nil;\n\tswitch (error.code) {\n\t\tcase ASAuthorizationErrorCanceled:\n\t\t\t\terrorMsg = @\"用户取消了授权请求\";\n\t\t\t\treturn;\n\t\t\tcase ASAuthorizationErrorFailed:\n\t\t\t\terrorMsg = @\"授权请求失败\";\n\t\t\t\tbreak;\n\t\t\tcase ASAuthorizationErrorInvalidResponse:\n\t\t\t\terrorMsg = @\"授权请求响应无效\";\n\t\t\t\tbreak;\n\t\t\tcase ASAuthorizationErrorNotHandled:\n\t\t\t\terrorMsg = @\"未能处理授权请求\";\n\t\t\t\tbreak;\n\t\t\tcase ASAuthorizationErrorUnknown:\n\t\t\t\terrorMsg = @\"授权请求失败未知原因\";\n\t\t\t\tbreak;\n\t\t}\n\t\t[self.errorSubject sendNext:LMError(errorMsg)];\n\t}\n\t```\n\n## 其他可选项\n\n### 苹果提供的登录按钮\n\n```\nASAuthorizationAppleIDButton *button = [ASAuthorizationAppleIDButton buttonWithType:ASAuthorizationAppleIDButtonTypeSignIn style:ASAuthorizationAppleIDButtonStyleWhiteOutline];\n```\n\n其中\n\n```\ntypedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonType) {\n    ASAuthorizationAppleIDButtonTypeSignIn, // 按钮文字显示 ：通过Apple登录\n    ASAuthorizationAppleIDButtonTypeContinue, // 按钮文字显示 ：通过Apple继续\n\n    ASAuthorizationAppleIDButtonTypeDefault = // 默认第一个 ASAuthorizationAppleIDButtonTypeSignIn,\n}\n\ntypedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonStyle) {\n    ASAuthorizationAppleIDButtonStyleWhite, // 白底黑字\n    ASAuthorizationAppleIDButtonStyleWhiteOutline, // 黑字白框\n    ASAuthorizationAppleIDButtonStyleBlack, // 黑底白字\n}\n\n```\n\n### 授权成功的回调可以来自于其他地方\n\n```\n//! 授权成功地回调\n- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization  API_AVAILABLE(ios(13.0)){\n    \n    NSLog(@\"%s\", __FUNCTION__);\n    NSLog(@\"%@\", controller);\n    NSLog(@\"%@\", authorization);\n    \n    NSLog(@\"authorization.credential：%@\", authorization.credential);\n    \n    NSMutableString *mStr = [NSMutableString string];\n    mStr = [_appleIDInfoTextView.text mutableCopy];\n    \n    if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) {\n        // 用户登录使用ASAuthorizationAppleIDCredential\n        ASAuthorizationAppleIDCredential *appleIDCredential = authorization.credential;\n        NSString *user = appleIDCredential.user;\n        //  最好使用钥匙串的方式保存用户的唯一信息 这里暂且处于测试阶段，用NSUserDefaults\n        [[NSUserDefaults standardUserDefaults] setValue:user forKey:QiShareCurrentIdentifier];\n        [mStr appendString:user?:@\"\"];\n        NSString *familyName = appleIDCredential.fullName.familyName;\n        [mStr appendString:familyName?:@\"\"];\n        NSString *givenName = appleIDCredential.fullName.givenName;\n        [mStr appendString:givenName?:@\"\"];\n        NSString *email = appleIDCredential.email;\n        [mStr appendString:email?:@\"\"];\n        NSLog(@\"mStr：%@\", mStr);\n        [mStr appendString:@\"\\n\"];\n        _appleIDInfoTextView.text = mStr;\n        \n    } else if ([authorization.credential isKindOfClass:[ASPasswordCredential class]]) {\n        // 用户登录使用现有的密码凭证\n        ASPasswordCredential *passwordCredential = authorization.credential;\n        // 密码凭证对象的用户标识 用户的唯一标识\n        NSString *user = passwordCredential.user;\n        // 密码凭证对象的密码\n        NSString *password = passwordCredential.password;\n        [mStr appendString:user?:@\"\"];\n        [mStr appendString:password?:@\"\"];\n        [mStr appendString:@\"\\n\"];\n        NSLog(@\"mStr：%@\", mStr);\n        _appleIDInfoTextView.text = mStr;\n    } else {\n        NSLog(@\"授权信息均不符\");\n        mStr = [@\"授权信息均不符\" mutableCopy];\n        _appleIDInfoTextView.text = mStr;\n    }\n}\n```\n\n### 已经使用Sign In With Apple登录过app的用户\n\n执行已经登录过的场景。如果设备中存在iCloud Keychain 凭证或者AppleID 凭证提示用户直接使用TouchID或FaceID登录即可。\n\n```\n- (void)perfomExistingAccountSetupFlows {\n    if (@available(iOS 13.0, *)) {\n        // A mechanism for generating requests to authenticate users based on their Apple ID.\n        // 基于用户的Apple ID授权用户，生成用户授权请求的一种机制\n        ASAuthorizationAppleIDProvider *appleIDProvider = [ASAuthorizationAppleIDProvider new];\n        // An OpenID authorization request that relies on the user’s Apple ID.\n        // 授权请求依赖于用于的AppleID\n        ASAuthorizationAppleIDRequest *authAppleIDRequest = [appleIDProvider createRequest];\n        // A mechanism for generating requests to perform keychain credential sharing.\n        // 为了执行钥匙串凭证分享生成请求的一种机制\n        ASAuthorizationPasswordRequest *passwordRequest = [[ASAuthorizationPasswordProvider new] createRequest];\n        \n        NSMutableArray <ASAuthorizationRequest *>* mArr = [NSMutableArray arrayWithCapacity:2];\n        if (authAppleIDRequest) {\n            [mArr addObject:authAppleIDRequest];\n        }\n        if (passwordRequest) {\n            [mArr addObject:passwordRequest];\n        }\n        // ASAuthorizationRequest：A base class for different kinds of authorization requests.\n        // ASAuthorizationRequest：对于不同种类授权请求的基类\n        NSArray <ASAuthorizationRequest *>* requests = [mArr copy];\n        \n        // A controller that manages authorization requests created by a provider.\n        // 由ASAuthorizationAppleIDProvider创建的授权请求 管理授权请求的控制器\n        // Creates a controller from a collection of authorization requests.\n        // 从一系列授权请求中创建授权控制器\n        ASAuthorizationController *authorizationController = [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];\n        // A delegate that the authorization controller informs about the success or failure of an authorization attempt.\n        // 设置授权控制器通知授权请求的成功与失败的代理\n        authorizationController.delegate = self;\n        // A delegate that provides a display context in which the system can present an authorization interface to the user.\n        // 设置提供 展示上下文的代理，在这个上下文中 系统可以展示授权界面给用户\n        authorizationController.presentationContextProvider = self;\n        // starts the authorization flows named during controller initialization.\n        // 在控制器初始化期间启动授权流\n        [authorizationController performRequests];\n    }\n}\n```\n\n### 监听授权状态变化\n\n监听授权状态改变，并且做出相应处理。授权状态有：\n\n```\nASAuthorizationAppleIDProviderCredentialRevoked：授权状态失效（用户停止使用AppID 登录App）\nASAuthorizationAppleIDProviderCredentialAuthorized：已授权(已使用AppleID 登录过App）\nASAuthorizationAppleIDProviderCredentialNotFound：授权凭证缺失（可能是使用AppleID 登录过App）\n```\n\n```\n//! 观察授权状态\n- (void)observeAuthticationState {\n    \n    if (@available(iOS 13.0, *)) {\n        // A mechanism for generating requests to authenticate users based on their Apple ID.\n        // 基于用户的Apple ID 生成授权用户请求的机制\n        ASAuthorizationAppleIDProvider *appleIDProvider = [ASAuthorizationAppleIDProvider new];\n        // 注意 存储用户标识信息需要使用钥匙串来存储 这里笔者简单期间 使用NSUserDefaults 做的简单示例\n        NSString *userIdentifier = [[NSUserDefaults standardUserDefaults] valueForKey:QiShareCurrentIdentifier];\n        \n        if (userIdentifier) {\n            NSString* __block errorMsg = nil;\n            //Returns the credential state for the given user in a completion handler.\n            // 在回调中返回用户的授权状态\n            [appleIDProvider getCredentialStateForUserID:userIdentifier completion:^(ASAuthorizationAppleIDProviderCredentialState credentialState, NSError * _Nullable error) {\n                switch (credentialState) {\n                        // 苹果证书的授权状态\n                    case ASAuthorizationAppleIDProviderCredentialRevoked:\n                        // 苹果授权凭证失效\n                        errorMsg = @\"苹果授权凭证失效\";\n                        break;\n                    case ASAuthorizationAppleIDProviderCredentialAuthorized:\n                        // 苹果授权凭证状态良好\n                        errorMsg = @\"苹果授权凭证状态良好\";\n                        break;\n                    case ASAuthorizationAppleIDProviderCredentialNotFound:\n                        // 未发现苹果授权凭证\n                        errorMsg = @\"未发现苹果授权凭证\";\n                        // 可以引导用户重新登录\n                        break;\n                }\n                dispatch_async(dispatch_get_main_queue(), ^{\n                    NSLog(@\"SignInWithApple授权状态变化情况\");\n                    NSLog(@\"%@\", errorMsg);\n                });\n            }];\n            \n        }\n    }\n}\n```\n\n使用通知的方式检测是否授权应用支持Sign In With Apple变化情况。如下的代码可以根据自己的业务场景去考虑放置的位置。\n\n```\n//! 添加苹果登录的状态通知\n- (void)observeAppleSignInState {\n    if (@available(iOS 13.0, *)) {\n        NSNotificationCenter *center = [NSNotificationCenter defaultCenter];\n        [center addObserver:self selector:@selector(handleSignInWithAppleStateChanged:) name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];\n    }\n}\n \n//! 观察SignInWithApple状态改变\n- (void)handleSignInWithAppleStateChanged:(id)noti {\n    \n    NSLog(@\"%s\", __FUNCTION__);\n    NSLog(@\"%@\", noti);\n}\n \n- (void)dealloc {\n    \n    if (@available(iOS 13.0, *)) {\n        [[NSNotificationCenter defaultCenter] removeObserver:self name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];\n    }\n}\n```\n\n## 重要（Important！）\n1. 最好使用苹果提供的按钮 `ASAuthorizationAppleIDButton` （只有黑白两种颜色）\n2. 不用他的按钮的话建议使用显眼的颜色 \n3. 尽量放在显眼位置（第一位）\n4. **不能比其他任何登录按钮要小**\n5. 保证登录页面一屏就能看到苹果登录按钮，不能滚动后才能看到\n6. 按钮的最小宽高有需求（看[苹果人机交互指南相关文档](https://developer.apple.com/design/human-interface-guidelines/sign-in-with-apple/overview/)）\n7. 如果登录后要绑定手机的话，就在备注里面写好 依据来源 http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm  指明(截图)第二十四条（苹果一般不会打开网页，建议下载个pdf给他）\n8. 如果不好好跟苹果爸爸的规矩来，那么可能会吃到2.1和4.0 (不要问我为什么知道)\n\n(更新至2019/11/01)\n\n|  最小宽度 | 最小高度  | 最小间距|\n| ------------ | ------------ | ------------ |\n| 140pt (140px @1x, 280px @2x)  |  30pt (30px @1x, 60px @2x) | 1/10 of the button's height）| \n\n## 参考其他教程\n\n[掘金](https://juejin.im/post/5d8c64d151882509606d6b17)\n","slug":"Sign-in-with-Apple接入指南","published":1,"updated":"2021-06-06T18:52:24.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoh5001ytnn01da2bid7","content":"<p>如果你的应用接入了第三方登陆，那么请同时接入苹果登录。</p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://developer.apple.com/app-store/review/guidelines/#sign-in-with-apple\">苹果审核指南的相关内容</a><br><a href=\"https://developer.apple.com/news/?id=09122019b\">新闻：2020年4月前需要适配好苹果登录</a></p>\n<h2 id=\"简单接入\"><a href=\"#简单接入\" class=\"headerlink\" title=\"简单接入\"></a>简单接入</h2><p><a href=\"https://developer.apple.com/sign-in-with-apple/\">苹果登录官方文档</a></p>\n<p>流程：</p>\n<p>用户点击按钮 — 调起苹果登录 — 授权成功 — 获取唯一标识符和其他信息 — 返回给后端 — 后端注册/登录 — 返回token — 登录成功</p>\n<h3 id=\"必要的工作\"><a href=\"#必要的工作\" class=\"headerlink\" title=\"必要的工作\"></a>必要的工作</h3><ol>\n<li><p>首先去苹果后台开启<code>Sign in with apple</code>选项，然后重新导出<code>provisionprofile</code>证书</p>\n</li>\n<li><p>授权</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASAuthorizationAppleIDProvider *provider &#x3D; [[ASAuthorizationAppleIDProvider alloc] init];</span><br><span class=\"line\">ASAuthorizationAppleIDRequest *request &#x3D; [provider createRequest];</span><br><span class=\"line\">request.requestedScopes &#x3D; @[ASAuthorizationScopeFullName, ASAuthorizationScopeEmail];</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableArray &lt;ASAuthorizationRequest *&gt;* array &#x3D; [NSMutableArray arrayWithCapacity:2];</span><br><span class=\"line\">if (request) [array addObject:request];</span><br><span class=\"line\"></span><br><span class=\"line\">NSArray&lt;ASAuthorizationRequest *&gt; *requests &#x3D; [array copy];</span><br><span class=\"line\">ASAuthorizationController *authorizationController &#x3D; [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];</span><br><span class=\"line\">authorizationController.delegate &#x3D; self;</span><br><span class=\"line\">authorizationController.presentationContextProvider &#x3D; input;</span><br><span class=\"line\">[authorizationController performRequests];</span><br></pre></td></tr></table></figure></li>\n<li><p>回调，遵循回调<code>ASAuthorizationControllerPresentationContextProviding</code></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization API_AVAILABLE(ios(13.0))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 用户登录使用ASAuthorizationAppleIDCredential</span><br><span class=\"line\">\tASAuthorizationAppleIDCredential *appleIDCredential &#x3D; (ASAuthorizationAppleIDCredential *)authorization.credential;</span><br><span class=\"line\">\tNSString *user &#x3D; appleIDCredential.user;</span><br><span class=\"line\">\tNSString *namePerfix &#x3D; appleIDCredential.fullName.namePrefix;</span><br><span class=\"line\">\tNSString *givenName &#x3D; appleIDCredential.fullName.givenName;</span><br><span class=\"line\">\tNSString *middleName &#x3D; appleIDCredential.fullName.middleName;</span><br><span class=\"line\">\tNSString *familyName &#x3D; appleIDCredential.fullName.familyName;</span><br><span class=\"line\">\tNSString *nameSuffix &#x3D; appleIDCredential.fullName.nameSuffix;</span><br><span class=\"line\">\tNSString *email &#x3D; appleIDCredential.email;</span><br><span class=\"line\">\tNSString *nickname &#x3D; appleIDCredential.fullName.nickname;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!nickname || nickname.length &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">\t\tnickname &#x3D; [NSString stringWithFormat:@&quot;%@%@%@%@%@&quot;,namePerfix?:@&quot;&quot;,familyName?:@&quot;&quot;,givenName?:@&quot;&quot;,middleName?:@&quot;&quot;,nameSuffix?:@&quot;&quot;];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">\t[self.errorSubject sendNext:LMError(@&quot;授权信息有误&quot;)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithError:(NSError *)error API_AVAILABLE(ios(13.0))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">NSString *errorMsg &#x3D; nil;</span><br><span class=\"line\">switch (error.code) &#123;</span><br><span class=\"line\">\tcase ASAuthorizationErrorCanceled:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;用户取消了授权请求&quot;;</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\tcase ASAuthorizationErrorFailed:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;授权请求失败&quot;;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase ASAuthorizationErrorInvalidResponse:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;授权请求响应无效&quot;;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase ASAuthorizationErrorNotHandled:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;未能处理授权请求&quot;;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase ASAuthorizationErrorUnknown:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;授权请求失败未知原因&quot;;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t[self.errorSubject sendNext:LMError(errorMsg)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"其他可选项\"><a href=\"#其他可选项\" class=\"headerlink\" title=\"其他可选项\"></a>其他可选项</h2><h3 id=\"苹果提供的登录按钮\"><a href=\"#苹果提供的登录按钮\" class=\"headerlink\" title=\"苹果提供的登录按钮\"></a>苹果提供的登录按钮</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASAuthorizationAppleIDButton *button &#x3D; [ASAuthorizationAppleIDButton buttonWithType:ASAuthorizationAppleIDButtonTypeSignIn style:ASAuthorizationAppleIDButtonStyleWhiteOutline];</span><br></pre></td></tr></table></figure>\n\n<p>其中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonType) &#123;</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonTypeSignIn, &#x2F;&#x2F; 按钮文字显示 ：通过Apple登录</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonTypeContinue, &#x2F;&#x2F; 按钮文字显示 ：通过Apple继续</span><br><span class=\"line\"></span><br><span class=\"line\">    ASAuthorizationAppleIDButtonTypeDefault &#x3D; &#x2F;&#x2F; 默认第一个 ASAuthorizationAppleIDButtonTypeSignIn,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonStyle) &#123;</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonStyleWhite, &#x2F;&#x2F; 白底黑字</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonStyleWhiteOutline, &#x2F;&#x2F; 黑字白框</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonStyleBlack, &#x2F;&#x2F; 黑底白字</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"授权成功的回调可以来自于其他地方\"><a href=\"#授权成功的回调可以来自于其他地方\" class=\"headerlink\" title=\"授权成功的回调可以来自于其他地方\"></a>授权成功的回调可以来自于其他地方</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;! 授权成功地回调</span><br><span class=\"line\">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization  API_AVAILABLE(ios(13.0))&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;, controller);</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;, authorization);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;authorization.credential：%@&quot;, authorization.credential);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSMutableString *mStr &#x3D; [NSMutableString string];</span><br><span class=\"line\">    mStr &#x3D; [_appleIDInfoTextView.text mutableCopy];</span><br><span class=\"line\">    </span><br><span class=\"line\">    if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 用户登录使用ASAuthorizationAppleIDCredential</span><br><span class=\"line\">        ASAuthorizationAppleIDCredential *appleIDCredential &#x3D; authorization.credential;</span><br><span class=\"line\">        NSString *user &#x3D; appleIDCredential.user;</span><br><span class=\"line\">        &#x2F;&#x2F;  最好使用钥匙串的方式保存用户的唯一信息 这里暂且处于测试阶段，用NSUserDefaults</span><br><span class=\"line\">        [[NSUserDefaults standardUserDefaults] setValue:user forKey:QiShareCurrentIdentifier];</span><br><span class=\"line\">        [mStr appendString:user?:@&quot;&quot;];</span><br><span class=\"line\">        NSString *familyName &#x3D; appleIDCredential.fullName.familyName;</span><br><span class=\"line\">        [mStr appendString:familyName?:@&quot;&quot;];</span><br><span class=\"line\">        NSString *givenName &#x3D; appleIDCredential.fullName.givenName;</span><br><span class=\"line\">        [mStr appendString:givenName?:@&quot;&quot;];</span><br><span class=\"line\">        NSString *email &#x3D; appleIDCredential.email;</span><br><span class=\"line\">        [mStr appendString:email?:@&quot;&quot;];</span><br><span class=\"line\">        NSLog(@&quot;mStr：%@&quot;, mStr);</span><br><span class=\"line\">        [mStr appendString:@&quot;\\n&quot;];</span><br><span class=\"line\">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; else if ([authorization.credential isKindOfClass:[ASPasswordCredential class]]) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 用户登录使用现有的密码凭证</span><br><span class=\"line\">        ASPasswordCredential *passwordCredential &#x3D; authorization.credential;</span><br><span class=\"line\">        &#x2F;&#x2F; 密码凭证对象的用户标识 用户的唯一标识</span><br><span class=\"line\">        NSString *user &#x3D; passwordCredential.user;</span><br><span class=\"line\">        &#x2F;&#x2F; 密码凭证对象的密码</span><br><span class=\"line\">        NSString *password &#x3D; passwordCredential.password;</span><br><span class=\"line\">        [mStr appendString:user?:@&quot;&quot;];</span><br><span class=\"line\">        [mStr appendString:password?:@&quot;&quot;];</span><br><span class=\"line\">        [mStr appendString:@&quot;\\n&quot;];</span><br><span class=\"line\">        NSLog(@&quot;mStr：%@&quot;, mStr);</span><br><span class=\"line\">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        NSLog(@&quot;授权信息均不符&quot;);</span><br><span class=\"line\">        mStr &#x3D; [@&quot;授权信息均不符&quot; mutableCopy];</span><br><span class=\"line\">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"已经使用Sign-In-With-Apple登录过app的用户\"><a href=\"#已经使用Sign-In-With-Apple登录过app的用户\" class=\"headerlink\" title=\"已经使用Sign In With Apple登录过app的用户\"></a>已经使用Sign In With Apple登录过app的用户</h3><p>执行已经登录过的场景。如果设备中存在iCloud Keychain 凭证或者AppleID 凭证提示用户直接使用TouchID或FaceID登录即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)perfomExistingAccountSetupFlows &#123;</span><br><span class=\"line\">    if (@available(iOS 13.0, *)) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; A mechanism for generating requests to authenticate users based on their Apple ID.</span><br><span class=\"line\">        &#x2F;&#x2F; 基于用户的Apple ID授权用户，生成用户授权请求的一种机制</span><br><span class=\"line\">        ASAuthorizationAppleIDProvider *appleIDProvider &#x3D; [ASAuthorizationAppleIDProvider new];</span><br><span class=\"line\">        &#x2F;&#x2F; An OpenID authorization request that relies on the user’s Apple ID.</span><br><span class=\"line\">        &#x2F;&#x2F; 授权请求依赖于用于的AppleID</span><br><span class=\"line\">        ASAuthorizationAppleIDRequest *authAppleIDRequest &#x3D; [appleIDProvider createRequest];</span><br><span class=\"line\">        &#x2F;&#x2F; A mechanism for generating requests to perform keychain credential sharing.</span><br><span class=\"line\">        &#x2F;&#x2F; 为了执行钥匙串凭证分享生成请求的一种机制</span><br><span class=\"line\">        ASAuthorizationPasswordRequest *passwordRequest &#x3D; [[ASAuthorizationPasswordProvider new] createRequest];</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSMutableArray &lt;ASAuthorizationRequest *&gt;* mArr &#x3D; [NSMutableArray arrayWithCapacity:2];</span><br><span class=\"line\">        if (authAppleIDRequest) &#123;</span><br><span class=\"line\">            [mArr addObject:authAppleIDRequest];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (passwordRequest) &#123;</span><br><span class=\"line\">            [mArr addObject:passwordRequest];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; ASAuthorizationRequest：A base class for different kinds of authorization requests.</span><br><span class=\"line\">        &#x2F;&#x2F; ASAuthorizationRequest：对于不同种类授权请求的基类</span><br><span class=\"line\">        NSArray &lt;ASAuthorizationRequest *&gt;* requests &#x3D; [mArr copy];</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#x2F;&#x2F; A controller that manages authorization requests created by a provider.</span><br><span class=\"line\">        &#x2F;&#x2F; 由ASAuthorizationAppleIDProvider创建的授权请求 管理授权请求的控制器</span><br><span class=\"line\">        &#x2F;&#x2F; Creates a controller from a collection of authorization requests.</span><br><span class=\"line\">        &#x2F;&#x2F; 从一系列授权请求中创建授权控制器</span><br><span class=\"line\">        ASAuthorizationController *authorizationController &#x3D; [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];</span><br><span class=\"line\">        &#x2F;&#x2F; A delegate that the authorization controller informs about the success or failure of an authorization attempt.</span><br><span class=\"line\">        &#x2F;&#x2F; 设置授权控制器通知授权请求的成功与失败的代理</span><br><span class=\"line\">        authorizationController.delegate &#x3D; self;</span><br><span class=\"line\">        &#x2F;&#x2F; A delegate that provides a display context in which the system can present an authorization interface to the user.</span><br><span class=\"line\">        &#x2F;&#x2F; 设置提供 展示上下文的代理，在这个上下文中 系统可以展示授权界面给用户</span><br><span class=\"line\">        authorizationController.presentationContextProvider &#x3D; self;</span><br><span class=\"line\">        &#x2F;&#x2F; starts the authorization flows named during controller initialization.</span><br><span class=\"line\">        &#x2F;&#x2F; 在控制器初始化期间启动授权流</span><br><span class=\"line\">        [authorizationController performRequests];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"监听授权状态变化\"><a href=\"#监听授权状态变化\" class=\"headerlink\" title=\"监听授权状态变化\"></a>监听授权状态变化</h3><p>监听授权状态改变，并且做出相应处理。授权状态有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASAuthorizationAppleIDProviderCredentialRevoked：授权状态失效（用户停止使用AppID 登录App）</span><br><span class=\"line\">ASAuthorizationAppleIDProviderCredentialAuthorized：已授权(已使用AppleID 登录过App）</span><br><span class=\"line\">ASAuthorizationAppleIDProviderCredentialNotFound：授权凭证缺失（可能是使用AppleID 登录过App）</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;! 观察授权状态</span><br><span class=\"line\">- (void)observeAuthticationState &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (@available(iOS 13.0, *)) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; A mechanism for generating requests to authenticate users based on their Apple ID.</span><br><span class=\"line\">        &#x2F;&#x2F; 基于用户的Apple ID 生成授权用户请求的机制</span><br><span class=\"line\">        ASAuthorizationAppleIDProvider *appleIDProvider &#x3D; [ASAuthorizationAppleIDProvider new];</span><br><span class=\"line\">        &#x2F;&#x2F; 注意 存储用户标识信息需要使用钥匙串来存储 这里笔者简单期间 使用NSUserDefaults 做的简单示例</span><br><span class=\"line\">        NSString *userIdentifier &#x3D; [[NSUserDefaults standardUserDefaults] valueForKey:QiShareCurrentIdentifier];</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (userIdentifier) &#123;</span><br><span class=\"line\">            NSString* __block errorMsg &#x3D; nil;</span><br><span class=\"line\">            &#x2F;&#x2F;Returns the credential state for the given user in a completion handler.</span><br><span class=\"line\">            &#x2F;&#x2F; 在回调中返回用户的授权状态</span><br><span class=\"line\">            [appleIDProvider getCredentialStateForUserID:userIdentifier completion:^(ASAuthorizationAppleIDProviderCredentialState credentialState, NSError * _Nullable error) &#123;</span><br><span class=\"line\">                switch (credentialState) &#123;</span><br><span class=\"line\">                        &#x2F;&#x2F; 苹果证书的授权状态</span><br><span class=\"line\">                    case ASAuthorizationAppleIDProviderCredentialRevoked:</span><br><span class=\"line\">                        &#x2F;&#x2F; 苹果授权凭证失效</span><br><span class=\"line\">                        errorMsg &#x3D; @&quot;苹果授权凭证失效&quot;;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case ASAuthorizationAppleIDProviderCredentialAuthorized:</span><br><span class=\"line\">                        &#x2F;&#x2F; 苹果授权凭证状态良好</span><br><span class=\"line\">                        errorMsg &#x3D; @&quot;苹果授权凭证状态良好&quot;;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case ASAuthorizationAppleIDProviderCredentialNotFound:</span><br><span class=\"line\">                        &#x2F;&#x2F; 未发现苹果授权凭证</span><br><span class=\"line\">                        errorMsg &#x3D; @&quot;未发现苹果授权凭证&quot;;</span><br><span class=\"line\">                        &#x2F;&#x2F; 可以引导用户重新登录</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">                    NSLog(@&quot;SignInWithApple授权状态变化情况&quot;);</span><br><span class=\"line\">                    NSLog(@&quot;%@&quot;, errorMsg);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;];</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用通知的方式检测是否授权应用支持Sign In With Apple变化情况。如下的代码可以根据自己的业务场景去考虑放置的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;! 添加苹果登录的状态通知</span><br><span class=\"line\">- (void)observeAppleSignInState &#123;</span><br><span class=\"line\">    if (@available(iOS 13.0, *)) &#123;</span><br><span class=\"line\">        NSNotificationCenter *center &#x3D; [NSNotificationCenter defaultCenter];</span><br><span class=\"line\">        [center addObserver:self selector:@selector(handleSignInWithAppleStateChanged:) name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F;! 观察SignInWithApple状态改变</span><br><span class=\"line\">- (void)handleSignInWithAppleStateChanged:(id)noti &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;, noti);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">- (void)dealloc &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (@available(iOS 13.0, *)) &#123;</span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] removeObserver:self name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重要（Important！）\"><a href=\"#重要（Important！）\" class=\"headerlink\" title=\"重要（Important！）\"></a>重要（Important！）</h2><ol>\n<li>最好使用苹果提供的按钮 <code>ASAuthorizationAppleIDButton</code> （只有黑白两种颜色）</li>\n<li>不用他的按钮的话建议使用显眼的颜色 </li>\n<li>尽量放在显眼位置（第一位）</li>\n<li><strong>不能比其他任何登录按钮要小</strong></li>\n<li>保证登录页面一屏就能看到苹果登录按钮，不能滚动后才能看到</li>\n<li>按钮的最小宽高有需求（看<a href=\"https://developer.apple.com/design/human-interface-guidelines/sign-in-with-apple/overview/\">苹果人机交互指南相关文档</a>）</li>\n<li>如果登录后要绑定手机的话，就在备注里面写好 依据来源 <a href=\"http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm\">http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm</a>  指明(截图)第二十四条（苹果一般不会打开网页，建议下载个pdf给他）</li>\n<li>如果不好好跟苹果爸爸的规矩来，那么可能会吃到2.1和4.0 (不要问我为什么知道)</li>\n</ol>\n<p>(更新至2019/11/01)</p>\n<table>\n<thead>\n<tr>\n<th>最小宽度</th>\n<th>最小高度</th>\n<th>最小间距</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>140pt (140px @1x, 280px @2x)</td>\n<td>30pt (30px @1x, 60px @2x)</td>\n<td>1/10 of the button’s height）</td>\n</tr>\n</tbody></table>\n<h2 id=\"参考其他教程\"><a href=\"#参考其他教程\" class=\"headerlink\" title=\"参考其他教程\"></a>参考其他教程</h2><p><a href=\"https://juejin.im/post/5d8c64d151882509606d6b17\">掘金</a></p>\n","site":{"data":{}},"excerpt":"<p>如果你的应用接入了第三方登陆，那么请同时接入苹果登录。</p>","more":"<p><a href=\"https://developer.apple.com/app-store/review/guidelines/#sign-in-with-apple\">苹果审核指南的相关内容</a><br><a href=\"https://developer.apple.com/news/?id=09122019b\">新闻：2020年4月前需要适配好苹果登录</a></p>\n<h2 id=\"简单接入\"><a href=\"#简单接入\" class=\"headerlink\" title=\"简单接入\"></a>简单接入</h2><p><a href=\"https://developer.apple.com/sign-in-with-apple/\">苹果登录官方文档</a></p>\n<p>流程：</p>\n<p>用户点击按钮 — 调起苹果登录 — 授权成功 — 获取唯一标识符和其他信息 — 返回给后端 — 后端注册/登录 — 返回token — 登录成功</p>\n<h3 id=\"必要的工作\"><a href=\"#必要的工作\" class=\"headerlink\" title=\"必要的工作\"></a>必要的工作</h3><ol>\n<li><p>首先去苹果后台开启<code>Sign in with apple</code>选项，然后重新导出<code>provisionprofile</code>证书</p>\n</li>\n<li><p>授权</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASAuthorizationAppleIDProvider *provider &#x3D; [[ASAuthorizationAppleIDProvider alloc] init];</span><br><span class=\"line\">ASAuthorizationAppleIDRequest *request &#x3D; [provider createRequest];</span><br><span class=\"line\">request.requestedScopes &#x3D; @[ASAuthorizationScopeFullName, ASAuthorizationScopeEmail];</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableArray &lt;ASAuthorizationRequest *&gt;* array &#x3D; [NSMutableArray arrayWithCapacity:2];</span><br><span class=\"line\">if (request) [array addObject:request];</span><br><span class=\"line\"></span><br><span class=\"line\">NSArray&lt;ASAuthorizationRequest *&gt; *requests &#x3D; [array copy];</span><br><span class=\"line\">ASAuthorizationController *authorizationController &#x3D; [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];</span><br><span class=\"line\">authorizationController.delegate &#x3D; self;</span><br><span class=\"line\">authorizationController.presentationContextProvider &#x3D; input;</span><br><span class=\"line\">[authorizationController performRequests];</span><br></pre></td></tr></table></figure></li>\n<li><p>回调，遵循回调<code>ASAuthorizationControllerPresentationContextProviding</code></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization API_AVAILABLE(ios(13.0))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 用户登录使用ASAuthorizationAppleIDCredential</span><br><span class=\"line\">\tASAuthorizationAppleIDCredential *appleIDCredential &#x3D; (ASAuthorizationAppleIDCredential *)authorization.credential;</span><br><span class=\"line\">\tNSString *user &#x3D; appleIDCredential.user;</span><br><span class=\"line\">\tNSString *namePerfix &#x3D; appleIDCredential.fullName.namePrefix;</span><br><span class=\"line\">\tNSString *givenName &#x3D; appleIDCredential.fullName.givenName;</span><br><span class=\"line\">\tNSString *middleName &#x3D; appleIDCredential.fullName.middleName;</span><br><span class=\"line\">\tNSString *familyName &#x3D; appleIDCredential.fullName.familyName;</span><br><span class=\"line\">\tNSString *nameSuffix &#x3D; appleIDCredential.fullName.nameSuffix;</span><br><span class=\"line\">\tNSString *email &#x3D; appleIDCredential.email;</span><br><span class=\"line\">\tNSString *nickname &#x3D; appleIDCredential.fullName.nickname;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!nickname || nickname.length &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">\t\tnickname &#x3D; [NSString stringWithFormat:@&quot;%@%@%@%@%@&quot;,namePerfix?:@&quot;&quot;,familyName?:@&quot;&quot;,givenName?:@&quot;&quot;,middleName?:@&quot;&quot;,nameSuffix?:@&quot;&quot;];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">\t[self.errorSubject sendNext:LMError(@&quot;授权信息有误&quot;)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithError:(NSError *)error API_AVAILABLE(ios(13.0))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">NSString *errorMsg &#x3D; nil;</span><br><span class=\"line\">switch (error.code) &#123;</span><br><span class=\"line\">\tcase ASAuthorizationErrorCanceled:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;用户取消了授权请求&quot;;</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\tcase ASAuthorizationErrorFailed:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;授权请求失败&quot;;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase ASAuthorizationErrorInvalidResponse:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;授权请求响应无效&quot;;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase ASAuthorizationErrorNotHandled:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;未能处理授权请求&quot;;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase ASAuthorizationErrorUnknown:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;授权请求失败未知原因&quot;;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t[self.errorSubject sendNext:LMError(errorMsg)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"其他可选项\"><a href=\"#其他可选项\" class=\"headerlink\" title=\"其他可选项\"></a>其他可选项</h2><h3 id=\"苹果提供的登录按钮\"><a href=\"#苹果提供的登录按钮\" class=\"headerlink\" title=\"苹果提供的登录按钮\"></a>苹果提供的登录按钮</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASAuthorizationAppleIDButton *button &#x3D; [ASAuthorizationAppleIDButton buttonWithType:ASAuthorizationAppleIDButtonTypeSignIn style:ASAuthorizationAppleIDButtonStyleWhiteOutline];</span><br></pre></td></tr></table></figure>\n\n<p>其中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonType) &#123;</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonTypeSignIn, &#x2F;&#x2F; 按钮文字显示 ：通过Apple登录</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonTypeContinue, &#x2F;&#x2F; 按钮文字显示 ：通过Apple继续</span><br><span class=\"line\"></span><br><span class=\"line\">    ASAuthorizationAppleIDButtonTypeDefault &#x3D; &#x2F;&#x2F; 默认第一个 ASAuthorizationAppleIDButtonTypeSignIn,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonStyle) &#123;</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonStyleWhite, &#x2F;&#x2F; 白底黑字</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonStyleWhiteOutline, &#x2F;&#x2F; 黑字白框</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonStyleBlack, &#x2F;&#x2F; 黑底白字</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"授权成功的回调可以来自于其他地方\"><a href=\"#授权成功的回调可以来自于其他地方\" class=\"headerlink\" title=\"授权成功的回调可以来自于其他地方\"></a>授权成功的回调可以来自于其他地方</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;! 授权成功地回调</span><br><span class=\"line\">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization  API_AVAILABLE(ios(13.0))&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;, controller);</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;, authorization);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;authorization.credential：%@&quot;, authorization.credential);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSMutableString *mStr &#x3D; [NSMutableString string];</span><br><span class=\"line\">    mStr &#x3D; [_appleIDInfoTextView.text mutableCopy];</span><br><span class=\"line\">    </span><br><span class=\"line\">    if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 用户登录使用ASAuthorizationAppleIDCredential</span><br><span class=\"line\">        ASAuthorizationAppleIDCredential *appleIDCredential &#x3D; authorization.credential;</span><br><span class=\"line\">        NSString *user &#x3D; appleIDCredential.user;</span><br><span class=\"line\">        &#x2F;&#x2F;  最好使用钥匙串的方式保存用户的唯一信息 这里暂且处于测试阶段，用NSUserDefaults</span><br><span class=\"line\">        [[NSUserDefaults standardUserDefaults] setValue:user forKey:QiShareCurrentIdentifier];</span><br><span class=\"line\">        [mStr appendString:user?:@&quot;&quot;];</span><br><span class=\"line\">        NSString *familyName &#x3D; appleIDCredential.fullName.familyName;</span><br><span class=\"line\">        [mStr appendString:familyName?:@&quot;&quot;];</span><br><span class=\"line\">        NSString *givenName &#x3D; appleIDCredential.fullName.givenName;</span><br><span class=\"line\">        [mStr appendString:givenName?:@&quot;&quot;];</span><br><span class=\"line\">        NSString *email &#x3D; appleIDCredential.email;</span><br><span class=\"line\">        [mStr appendString:email?:@&quot;&quot;];</span><br><span class=\"line\">        NSLog(@&quot;mStr：%@&quot;, mStr);</span><br><span class=\"line\">        [mStr appendString:@&quot;\\n&quot;];</span><br><span class=\"line\">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; else if ([authorization.credential isKindOfClass:[ASPasswordCredential class]]) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 用户登录使用现有的密码凭证</span><br><span class=\"line\">        ASPasswordCredential *passwordCredential &#x3D; authorization.credential;</span><br><span class=\"line\">        &#x2F;&#x2F; 密码凭证对象的用户标识 用户的唯一标识</span><br><span class=\"line\">        NSString *user &#x3D; passwordCredential.user;</span><br><span class=\"line\">        &#x2F;&#x2F; 密码凭证对象的密码</span><br><span class=\"line\">        NSString *password &#x3D; passwordCredential.password;</span><br><span class=\"line\">        [mStr appendString:user?:@&quot;&quot;];</span><br><span class=\"line\">        [mStr appendString:password?:@&quot;&quot;];</span><br><span class=\"line\">        [mStr appendString:@&quot;\\n&quot;];</span><br><span class=\"line\">        NSLog(@&quot;mStr：%@&quot;, mStr);</span><br><span class=\"line\">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        NSLog(@&quot;授权信息均不符&quot;);</span><br><span class=\"line\">        mStr &#x3D; [@&quot;授权信息均不符&quot; mutableCopy];</span><br><span class=\"line\">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"已经使用Sign-In-With-Apple登录过app的用户\"><a href=\"#已经使用Sign-In-With-Apple登录过app的用户\" class=\"headerlink\" title=\"已经使用Sign In With Apple登录过app的用户\"></a>已经使用Sign In With Apple登录过app的用户</h3><p>执行已经登录过的场景。如果设备中存在iCloud Keychain 凭证或者AppleID 凭证提示用户直接使用TouchID或FaceID登录即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)perfomExistingAccountSetupFlows &#123;</span><br><span class=\"line\">    if (@available(iOS 13.0, *)) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; A mechanism for generating requests to authenticate users based on their Apple ID.</span><br><span class=\"line\">        &#x2F;&#x2F; 基于用户的Apple ID授权用户，生成用户授权请求的一种机制</span><br><span class=\"line\">        ASAuthorizationAppleIDProvider *appleIDProvider &#x3D; [ASAuthorizationAppleIDProvider new];</span><br><span class=\"line\">        &#x2F;&#x2F; An OpenID authorization request that relies on the user’s Apple ID.</span><br><span class=\"line\">        &#x2F;&#x2F; 授权请求依赖于用于的AppleID</span><br><span class=\"line\">        ASAuthorizationAppleIDRequest *authAppleIDRequest &#x3D; [appleIDProvider createRequest];</span><br><span class=\"line\">        &#x2F;&#x2F; A mechanism for generating requests to perform keychain credential sharing.</span><br><span class=\"line\">        &#x2F;&#x2F; 为了执行钥匙串凭证分享生成请求的一种机制</span><br><span class=\"line\">        ASAuthorizationPasswordRequest *passwordRequest &#x3D; [[ASAuthorizationPasswordProvider new] createRequest];</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSMutableArray &lt;ASAuthorizationRequest *&gt;* mArr &#x3D; [NSMutableArray arrayWithCapacity:2];</span><br><span class=\"line\">        if (authAppleIDRequest) &#123;</span><br><span class=\"line\">            [mArr addObject:authAppleIDRequest];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (passwordRequest) &#123;</span><br><span class=\"line\">            [mArr addObject:passwordRequest];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; ASAuthorizationRequest：A base class for different kinds of authorization requests.</span><br><span class=\"line\">        &#x2F;&#x2F; ASAuthorizationRequest：对于不同种类授权请求的基类</span><br><span class=\"line\">        NSArray &lt;ASAuthorizationRequest *&gt;* requests &#x3D; [mArr copy];</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#x2F;&#x2F; A controller that manages authorization requests created by a provider.</span><br><span class=\"line\">        &#x2F;&#x2F; 由ASAuthorizationAppleIDProvider创建的授权请求 管理授权请求的控制器</span><br><span class=\"line\">        &#x2F;&#x2F; Creates a controller from a collection of authorization requests.</span><br><span class=\"line\">        &#x2F;&#x2F; 从一系列授权请求中创建授权控制器</span><br><span class=\"line\">        ASAuthorizationController *authorizationController &#x3D; [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];</span><br><span class=\"line\">        &#x2F;&#x2F; A delegate that the authorization controller informs about the success or failure of an authorization attempt.</span><br><span class=\"line\">        &#x2F;&#x2F; 设置授权控制器通知授权请求的成功与失败的代理</span><br><span class=\"line\">        authorizationController.delegate &#x3D; self;</span><br><span class=\"line\">        &#x2F;&#x2F; A delegate that provides a display context in which the system can present an authorization interface to the user.</span><br><span class=\"line\">        &#x2F;&#x2F; 设置提供 展示上下文的代理，在这个上下文中 系统可以展示授权界面给用户</span><br><span class=\"line\">        authorizationController.presentationContextProvider &#x3D; self;</span><br><span class=\"line\">        &#x2F;&#x2F; starts the authorization flows named during controller initialization.</span><br><span class=\"line\">        &#x2F;&#x2F; 在控制器初始化期间启动授权流</span><br><span class=\"line\">        [authorizationController performRequests];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"监听授权状态变化\"><a href=\"#监听授权状态变化\" class=\"headerlink\" title=\"监听授权状态变化\"></a>监听授权状态变化</h3><p>监听授权状态改变，并且做出相应处理。授权状态有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASAuthorizationAppleIDProviderCredentialRevoked：授权状态失效（用户停止使用AppID 登录App）</span><br><span class=\"line\">ASAuthorizationAppleIDProviderCredentialAuthorized：已授权(已使用AppleID 登录过App）</span><br><span class=\"line\">ASAuthorizationAppleIDProviderCredentialNotFound：授权凭证缺失（可能是使用AppleID 登录过App）</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;! 观察授权状态</span><br><span class=\"line\">- (void)observeAuthticationState &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (@available(iOS 13.0, *)) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; A mechanism for generating requests to authenticate users based on their Apple ID.</span><br><span class=\"line\">        &#x2F;&#x2F; 基于用户的Apple ID 生成授权用户请求的机制</span><br><span class=\"line\">        ASAuthorizationAppleIDProvider *appleIDProvider &#x3D; [ASAuthorizationAppleIDProvider new];</span><br><span class=\"line\">        &#x2F;&#x2F; 注意 存储用户标识信息需要使用钥匙串来存储 这里笔者简单期间 使用NSUserDefaults 做的简单示例</span><br><span class=\"line\">        NSString *userIdentifier &#x3D; [[NSUserDefaults standardUserDefaults] valueForKey:QiShareCurrentIdentifier];</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (userIdentifier) &#123;</span><br><span class=\"line\">            NSString* __block errorMsg &#x3D; nil;</span><br><span class=\"line\">            &#x2F;&#x2F;Returns the credential state for the given user in a completion handler.</span><br><span class=\"line\">            &#x2F;&#x2F; 在回调中返回用户的授权状态</span><br><span class=\"line\">            [appleIDProvider getCredentialStateForUserID:userIdentifier completion:^(ASAuthorizationAppleIDProviderCredentialState credentialState, NSError * _Nullable error) &#123;</span><br><span class=\"line\">                switch (credentialState) &#123;</span><br><span class=\"line\">                        &#x2F;&#x2F; 苹果证书的授权状态</span><br><span class=\"line\">                    case ASAuthorizationAppleIDProviderCredentialRevoked:</span><br><span class=\"line\">                        &#x2F;&#x2F; 苹果授权凭证失效</span><br><span class=\"line\">                        errorMsg &#x3D; @&quot;苹果授权凭证失效&quot;;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case ASAuthorizationAppleIDProviderCredentialAuthorized:</span><br><span class=\"line\">                        &#x2F;&#x2F; 苹果授权凭证状态良好</span><br><span class=\"line\">                        errorMsg &#x3D; @&quot;苹果授权凭证状态良好&quot;;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case ASAuthorizationAppleIDProviderCredentialNotFound:</span><br><span class=\"line\">                        &#x2F;&#x2F; 未发现苹果授权凭证</span><br><span class=\"line\">                        errorMsg &#x3D; @&quot;未发现苹果授权凭证&quot;;</span><br><span class=\"line\">                        &#x2F;&#x2F; 可以引导用户重新登录</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">                    NSLog(@&quot;SignInWithApple授权状态变化情况&quot;);</span><br><span class=\"line\">                    NSLog(@&quot;%@&quot;, errorMsg);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;];</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用通知的方式检测是否授权应用支持Sign In With Apple变化情况。如下的代码可以根据自己的业务场景去考虑放置的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;! 添加苹果登录的状态通知</span><br><span class=\"line\">- (void)observeAppleSignInState &#123;</span><br><span class=\"line\">    if (@available(iOS 13.0, *)) &#123;</span><br><span class=\"line\">        NSNotificationCenter *center &#x3D; [NSNotificationCenter defaultCenter];</span><br><span class=\"line\">        [center addObserver:self selector:@selector(handleSignInWithAppleStateChanged:) name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F;! 观察SignInWithApple状态改变</span><br><span class=\"line\">- (void)handleSignInWithAppleStateChanged:(id)noti &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;, noti);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">- (void)dealloc &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (@available(iOS 13.0, *)) &#123;</span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] removeObserver:self name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重要（Important！）\"><a href=\"#重要（Important！）\" class=\"headerlink\" title=\"重要（Important！）\"></a>重要（Important！）</h2><ol>\n<li>最好使用苹果提供的按钮 <code>ASAuthorizationAppleIDButton</code> （只有黑白两种颜色）</li>\n<li>不用他的按钮的话建议使用显眼的颜色 </li>\n<li>尽量放在显眼位置（第一位）</li>\n<li><strong>不能比其他任何登录按钮要小</strong></li>\n<li>保证登录页面一屏就能看到苹果登录按钮，不能滚动后才能看到</li>\n<li>按钮的最小宽高有需求（看<a href=\"https://developer.apple.com/design/human-interface-guidelines/sign-in-with-apple/overview/\">苹果人机交互指南相关文档</a>）</li>\n<li>如果登录后要绑定手机的话，就在备注里面写好 依据来源 <a href=\"http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm\">http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm</a>  指明(截图)第二十四条（苹果一般不会打开网页，建议下载个pdf给他）</li>\n<li>如果不好好跟苹果爸爸的规矩来，那么可能会吃到2.1和4.0 (不要问我为什么知道)</li>\n</ol>\n<p>(更新至2019/11/01)</p>\n<table>\n<thead>\n<tr>\n<th>最小宽度</th>\n<th>最小高度</th>\n<th>最小间距</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>140pt (140px @1x, 280px @2x)</td>\n<td>30pt (30px @1x, 60px @2x)</td>\n<td>1/10 of the button’s height）</td>\n</tr>\n</tbody></table>\n<h2 id=\"参考其他教程\"><a href=\"#参考其他教程\" class=\"headerlink\" title=\"参考其他教程\"></a>参考其他教程</h2><p><a href=\"https://juejin.im/post/5d8c64d151882509606d6b17\">掘金</a></p>"},{"title":"Salesforce SDK Bug","author":"Arclin","abbrlink":"e88dc875","date":"2018-02-18T13:59:00.000Z","_content":"Salesforce SDK 有几个bug 不修复的话跑不起来 所以在这里记录一下\n\n<!-- more -->\n\n1. `SFOAuthCoordinator` 960行 \n\n```\n   if ([self isRedirectURL:requestUrl]) {\n        [self handleUserAgentResponse:url];\n        decisionHandler(WKNavigationActionPolicyCancel);\n        return;\n    }\n```\n\n2. `SFSDKLoginHostListViewController` `viewDidLoad`最下面的注册cell移动到`viewDidLoad`的第一行\n","source":"_posts/Salesforce-SDK-Bug.md","raw":"---\ntitle: Salesforce SDK Bug\nauthor: Arclin\ntags:\n  - Salesforce\ncategories:\n  - iOS\nabbrlink: e88dc875\ndate: 2018-02-18 21:59:00\n---\nSalesforce SDK 有几个bug 不修复的话跑不起来 所以在这里记录一下\n\n<!-- more -->\n\n1. `SFOAuthCoordinator` 960行 \n\n```\n   if ([self isRedirectURL:requestUrl]) {\n        [self handleUserAgentResponse:url];\n        decisionHandler(WKNavigationActionPolicyCancel);\n        return;\n    }\n```\n\n2. `SFSDKLoginHostListViewController` `viewDidLoad`最下面的注册cell移动到`viewDidLoad`的第一行\n","slug":"Salesforce-SDK-Bug","published":1,"updated":"2021-06-06T18:52:24.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoh70022tnn0cmyef2fa","content":"<p>Salesforce SDK 有几个bug 不修复的话跑不起来 所以在这里记录一下</p>\n<span id=\"more\"></span>\n\n<ol>\n<li><code>SFOAuthCoordinator</code> 960行 </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ([self isRedirectURL:requestUrl]) &#123;</span><br><span class=\"line\">     [self handleUserAgentResponse:url];</span><br><span class=\"line\">     decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class=\"line\">     return;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><code>SFSDKLoginHostListViewController</code> <code>viewDidLoad</code>最下面的注册cell移动到<code>viewDidLoad</code>的第一行</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Salesforce SDK 有几个bug 不修复的话跑不起来 所以在这里记录一下</p>","more":"<ol>\n<li><code>SFOAuthCoordinator</code> 960行 </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ([self isRedirectURL:requestUrl]) &#123;</span><br><span class=\"line\">     [self handleUserAgentResponse:url];</span><br><span class=\"line\">     decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class=\"line\">     return;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><code>SFSDKLoginHostListViewController</code> <code>viewDidLoad</code>最下面的注册cell移动到<code>viewDidLoad</code>的第一行</li>\n</ol>"},{"title":"SwiftUI指南","abbrlink":"f6762f39","date":"2019-12-14T02:20:13.000Z","_content":"\niOS 13 SwiftUI 指南\n\n<!--more-->\n\n### 布局方向\n\n#### VStack 垂直布局\n\n默认垂直方向居中布局\n\n```\nVStack {\n\tText(\"默认居中\")\n\tText(\"Hello, World!\")\n\tText(\"Hello, World Again!\")\n}\n```\n\n对齐方向参数可选(`.leading`,`.trailing`,`.center`)\n```\nVStack(alignment:.leading) {\n\tText(\"左对齐\")\n\tText(\"Hello, World!\")\n\tText(\"Hello, World Again!\")\n}\n```\n\t\n\n#### HStack 水平布局\n\n默认水平方向居中布局\n\n```\nHStack {\n\tText(\"默认居中\")\n\tText(\"Hello, World!\")\n\tText(\"Hello, World Again!\")\n}\n```\n\n对齐方向参数可选(`.top`,`.bottom`,`.center`)\n```\nHStack(alignment:.bottom) {\n\tText(\"左对齐\")\n\tText(\"Hello, World!\")\n\tText(\"Hello, World Again!\")\n}\n```\n\n### ZStack 前后布局\n\n代码下面内容的盖住上面的内容\n\n默认水平居中&垂直居中\n\n```\nZStack {\n\tText(\"默认居中\")\n\tText(\"Hello, World!\")\n}\n```\n\n对齐方向参数可选(`.leading`,`.trailing`,`.top`,`.bottom`,`.topLeading`,`.topTrailing`,`.bottomLeading`,`.bottomTrailing`)\n\n```\nZStack(alignment:.bottom) {\n\tText(\"底部对齐\")\n\tText(\"Hello, World!\")\n}\n```\n\n### Padding\n\n内边距，用来撑开你的布局\n\n默认撑开上下左右各16pt\n\n```\nZStack{\n\tText(\"默认居中\").padding()\n}\n```\n\n可以指定哪个位置撑开和数值大小\n\n```\nZStack{\n\tText(\"默认居中\").padding(20) // 上下左右均撑开20\n}\n```\n\n```\nZStack{\n\tText(\"默认居中\").padding(.leading: 20) // 左边撑开20，其他同理\n}\n```\n\n```\nZStack{\n\tText(\"默认居中\").padding([.leading,.trailing],50).fixedSize() // 左边和右边都撑开50，其他同理，fixedSize意思等同于UILabel的sizeToFit\n}\n```\n\n```\nZStack{\n\tText(\"默认居中\").padding(.leading, 10).padding(.top, 20) // 左边10，上边20，其他同理\n}\n```\n\n### Spacer\n\n用来填充空位。\n\n因为SwiftUI不像原来的UI开发，是先设置好frame,再往里面添加东西，相反，他是一种先紧紧包住控件，然后通过padding、spacer等元素去“撑开”视图的思想。所以，Spacer在这里有点类似于UIBarButtonItem里的那个`UIBarButtonSystemItemFlexibleSpace`,就是把东西给撑开。\n\n举个例子\n\n水平界面这时候布局紧紧包裹着Text控件\n```\nHStack {\n\tText(\"Hello, World!\")\n}\n```\n\n如果这时候加一个Spacer,那么Text控件就会靠左，右边部分会被Spacer把剩余空隙填满\n\n```\nHStack {\n\tText(\"Hello, World!\")\n\tSpacer()\n}\n```\n\n同理如果是`VStack`，写在下面的话，自然就会把Text控件往上顶，然后把剩余屏幕部分填满。\n\n### Image\n\n直接输入图片名就可以引用本地图片\n`Image(\"bg_nuanxin_mask\")`\n\n#### resizeable\n\n`Image(\"bg_nuanxin_mask\").resizable()`\n\n把图片撑开\n\n### 隐藏NavigationBar\n\n```\nNavigationView {\n\tZStack {\n\t\t//...\n\t}\n\t.navigationBarHidden(true)\n\t.navigationBarTitle(\"\")\n\t.navigationBarBackButtonHidden(true)\n}\n```\n\n#### 这个界面不显示，下个界面要显示导航栏\n\n当前页面声明一个属性\n```\n @State private var navBarHidden = true\n```\n\n目标页面加一个属性\n\n```\n@Binding var navBarHidden : Bool\n```\n\n传值过去\n```\nNavigationLink(destination:xxxx, navBarHidden: $navBarHidden)) {\n   xxxxx\n}\n```\n\n目标页面处理\n\n```\nvar body: some View {\n\tWebView(webUrl:\"https://www.baidu.com\",title: $title)\n\t.onAppear {\n\t\tself.navBarHidden = false\n\t}\n\t.onDisappear {\n\t\tself.navBarHidden = true\n\t}\n\t.navigationBarTitle(Text(title),displayMode: .inline)\n}\n```\n\n#### 导航栏标题样式\n\n普通\n```\n.navigationBarTitle(Text(title),displayMode: .inline)\n```\n\n特大\n```\n.navigationBarTitle(Text(title),displayMode: .large)\n```\n\n随滚动自动变化\n```\n.navigationBarTitle(Text(title),displayMode: .automatic)\n```\n\n### 需要用到的一些快捷键\n\ncmd + ctrl + 鼠标左键+控件/布局  =  调出菜单\nctrl + i = 代码缩进调整\t\n\n待续","source":"_posts/SwiftUI指南.md","raw":"---\ntitle: SwiftUI指南\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: f6762f39\ndate: 2019-12-14 10:20:13\n---\n\niOS 13 SwiftUI 指南\n\n<!--more-->\n\n### 布局方向\n\n#### VStack 垂直布局\n\n默认垂直方向居中布局\n\n```\nVStack {\n\tText(\"默认居中\")\n\tText(\"Hello, World!\")\n\tText(\"Hello, World Again!\")\n}\n```\n\n对齐方向参数可选(`.leading`,`.trailing`,`.center`)\n```\nVStack(alignment:.leading) {\n\tText(\"左对齐\")\n\tText(\"Hello, World!\")\n\tText(\"Hello, World Again!\")\n}\n```\n\t\n\n#### HStack 水平布局\n\n默认水平方向居中布局\n\n```\nHStack {\n\tText(\"默认居中\")\n\tText(\"Hello, World!\")\n\tText(\"Hello, World Again!\")\n}\n```\n\n对齐方向参数可选(`.top`,`.bottom`,`.center`)\n```\nHStack(alignment:.bottom) {\n\tText(\"左对齐\")\n\tText(\"Hello, World!\")\n\tText(\"Hello, World Again!\")\n}\n```\n\n### ZStack 前后布局\n\n代码下面内容的盖住上面的内容\n\n默认水平居中&垂直居中\n\n```\nZStack {\n\tText(\"默认居中\")\n\tText(\"Hello, World!\")\n}\n```\n\n对齐方向参数可选(`.leading`,`.trailing`,`.top`,`.bottom`,`.topLeading`,`.topTrailing`,`.bottomLeading`,`.bottomTrailing`)\n\n```\nZStack(alignment:.bottom) {\n\tText(\"底部对齐\")\n\tText(\"Hello, World!\")\n}\n```\n\n### Padding\n\n内边距，用来撑开你的布局\n\n默认撑开上下左右各16pt\n\n```\nZStack{\n\tText(\"默认居中\").padding()\n}\n```\n\n可以指定哪个位置撑开和数值大小\n\n```\nZStack{\n\tText(\"默认居中\").padding(20) // 上下左右均撑开20\n}\n```\n\n```\nZStack{\n\tText(\"默认居中\").padding(.leading: 20) // 左边撑开20，其他同理\n}\n```\n\n```\nZStack{\n\tText(\"默认居中\").padding([.leading,.trailing],50).fixedSize() // 左边和右边都撑开50，其他同理，fixedSize意思等同于UILabel的sizeToFit\n}\n```\n\n```\nZStack{\n\tText(\"默认居中\").padding(.leading, 10).padding(.top, 20) // 左边10，上边20，其他同理\n}\n```\n\n### Spacer\n\n用来填充空位。\n\n因为SwiftUI不像原来的UI开发，是先设置好frame,再往里面添加东西，相反，他是一种先紧紧包住控件，然后通过padding、spacer等元素去“撑开”视图的思想。所以，Spacer在这里有点类似于UIBarButtonItem里的那个`UIBarButtonSystemItemFlexibleSpace`,就是把东西给撑开。\n\n举个例子\n\n水平界面这时候布局紧紧包裹着Text控件\n```\nHStack {\n\tText(\"Hello, World!\")\n}\n```\n\n如果这时候加一个Spacer,那么Text控件就会靠左，右边部分会被Spacer把剩余空隙填满\n\n```\nHStack {\n\tText(\"Hello, World!\")\n\tSpacer()\n}\n```\n\n同理如果是`VStack`，写在下面的话，自然就会把Text控件往上顶，然后把剩余屏幕部分填满。\n\n### Image\n\n直接输入图片名就可以引用本地图片\n`Image(\"bg_nuanxin_mask\")`\n\n#### resizeable\n\n`Image(\"bg_nuanxin_mask\").resizable()`\n\n把图片撑开\n\n### 隐藏NavigationBar\n\n```\nNavigationView {\n\tZStack {\n\t\t//...\n\t}\n\t.navigationBarHidden(true)\n\t.navigationBarTitle(\"\")\n\t.navigationBarBackButtonHidden(true)\n}\n```\n\n#### 这个界面不显示，下个界面要显示导航栏\n\n当前页面声明一个属性\n```\n @State private var navBarHidden = true\n```\n\n目标页面加一个属性\n\n```\n@Binding var navBarHidden : Bool\n```\n\n传值过去\n```\nNavigationLink(destination:xxxx, navBarHidden: $navBarHidden)) {\n   xxxxx\n}\n```\n\n目标页面处理\n\n```\nvar body: some View {\n\tWebView(webUrl:\"https://www.baidu.com\",title: $title)\n\t.onAppear {\n\t\tself.navBarHidden = false\n\t}\n\t.onDisappear {\n\t\tself.navBarHidden = true\n\t}\n\t.navigationBarTitle(Text(title),displayMode: .inline)\n}\n```\n\n#### 导航栏标题样式\n\n普通\n```\n.navigationBarTitle(Text(title),displayMode: .inline)\n```\n\n特大\n```\n.navigationBarTitle(Text(title),displayMode: .large)\n```\n\n随滚动自动变化\n```\n.navigationBarTitle(Text(title),displayMode: .automatic)\n```\n\n### 需要用到的一些快捷键\n\ncmd + ctrl + 鼠标左键+控件/布局  =  调出菜单\nctrl + i = 代码缩进调整\t\n\n待续","slug":"SwiftUI指南","published":1,"updated":"2021-06-06T18:52:24.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoh90026tnn07ussagl8","content":"<p>iOS 13 SwiftUI 指南</p>\n<span id=\"more\"></span>\n\n<h3 id=\"布局方向\"><a href=\"#布局方向\" class=\"headerlink\" title=\"布局方向\"></a>布局方向</h3><h4 id=\"VStack-垂直布局\"><a href=\"#VStack-垂直布局\" class=\"headerlink\" title=\"VStack 垂直布局\"></a>VStack 垂直布局</h4><p>默认垂直方向居中布局</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VStack &#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World Again!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对齐方向参数可选(<code>.leading</code>,<code>.trailing</code>,<code>.center</code>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VStack(alignment:.leading) &#123;</span><br><span class=\"line\">\tText(&quot;左对齐&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World Again!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"HStack-水平布局\"><a href=\"#HStack-水平布局\" class=\"headerlink\" title=\"HStack 水平布局\"></a>HStack 水平布局</h4><p>默认水平方向居中布局</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HStack &#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World Again!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对齐方向参数可选(<code>.top</code>,<code>.bottom</code>,<code>.center</code>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HStack(alignment:.bottom) &#123;</span><br><span class=\"line\">\tText(&quot;左对齐&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World Again!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ZStack-前后布局\"><a href=\"#ZStack-前后布局\" class=\"headerlink\" title=\"ZStack 前后布局\"></a>ZStack 前后布局</h3><p>代码下面内容的盖住上面的内容</p>\n<p>默认水平居中&amp;垂直居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack &#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对齐方向参数可选(<code>.leading</code>,<code>.trailing</code>,<code>.top</code>,<code>.bottom</code>,<code>.topLeading</code>,<code>.topTrailing</code>,<code>.bottomLeading</code>,<code>.bottomTrailing</code>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack(alignment:.bottom) &#123;</span><br><span class=\"line\">\tText(&quot;底部对齐&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Padding\"><a href=\"#Padding\" class=\"headerlink\" title=\"Padding\"></a>Padding</h3><p>内边距，用来撑开你的布局</p>\n<p>默认撑开上下左右各16pt</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以指定哪个位置撑开和数值大小</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding(20) &#x2F;&#x2F; 上下左右均撑开20</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding(.leading: 20) &#x2F;&#x2F; 左边撑开20，其他同理</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding([.leading,.trailing],50).fixedSize() &#x2F;&#x2F; 左边和右边都撑开50，其他同理，fixedSize意思等同于UILabel的sizeToFit</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding(.leading, 10).padding(.top, 20) &#x2F;&#x2F; 左边10，上边20，其他同理</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Spacer\"><a href=\"#Spacer\" class=\"headerlink\" title=\"Spacer\"></a>Spacer</h3><p>用来填充空位。</p>\n<p>因为SwiftUI不像原来的UI开发，是先设置好frame,再往里面添加东西，相反，他是一种先紧紧包住控件，然后通过padding、spacer等元素去“撑开”视图的思想。所以，Spacer在这里有点类似于UIBarButtonItem里的那个<code>UIBarButtonSystemItemFlexibleSpace</code>,就是把东西给撑开。</p>\n<p>举个例子</p>\n<p>水平界面这时候布局紧紧包裹着Text控件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HStack &#123;</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果这时候加一个Spacer,那么Text控件就会靠左，右边部分会被Spacer把剩余空隙填满</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HStack &#123;</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tSpacer()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同理如果是<code>VStack</code>，写在下面的话，自然就会把Text控件往上顶，然后把剩余屏幕部分填满。</p>\n<h3 id=\"Image\"><a href=\"#Image\" class=\"headerlink\" title=\"Image\"></a>Image</h3><p>直接输入图片名就可以引用本地图片<br><code>Image(&quot;bg_nuanxin_mask&quot;)</code></p>\n<h4 id=\"resizeable\"><a href=\"#resizeable\" class=\"headerlink\" title=\"resizeable\"></a>resizeable</h4><p><code>Image(&quot;bg_nuanxin_mask&quot;).resizable()</code></p>\n<p>把图片撑开</p>\n<h3 id=\"隐藏NavigationBar\"><a href=\"#隐藏NavigationBar\" class=\"headerlink\" title=\"隐藏NavigationBar\"></a>隐藏NavigationBar</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NavigationView &#123;</span><br><span class=\"line\">\tZStack &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t.navigationBarHidden(true)</span><br><span class=\"line\">\t.navigationBarTitle(&quot;&quot;)</span><br><span class=\"line\">\t.navigationBarBackButtonHidden(true)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"这个界面不显示，下个界面要显示导航栏\"><a href=\"#这个界面不显示，下个界面要显示导航栏\" class=\"headerlink\" title=\"这个界面不显示，下个界面要显示导航栏\"></a>这个界面不显示，下个界面要显示导航栏</h4><p>当前页面声明一个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@State private var navBarHidden &#x3D; true</span><br></pre></td></tr></table></figure>\n\n<p>目标页面加一个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Binding var navBarHidden : Bool</span><br></pre></td></tr></table></figure>\n\n<p>传值过去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NavigationLink(destination:xxxx, navBarHidden: $navBarHidden)) &#123;</span><br><span class=\"line\">   xxxxx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>目标页面处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var body: some View &#123;</span><br><span class=\"line\">\tWebView(webUrl:&quot;https:&#x2F;&#x2F;www.baidu.com&quot;,title: $title)</span><br><span class=\"line\">\t.onAppear &#123;</span><br><span class=\"line\">\t\tself.navBarHidden &#x3D; false</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t.onDisappear &#123;</span><br><span class=\"line\">\t\tself.navBarHidden &#x3D; true</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t.navigationBarTitle(Text(title),displayMode: .inline)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"导航栏标题样式\"><a href=\"#导航栏标题样式\" class=\"headerlink\" title=\"导航栏标题样式\"></a>导航栏标题样式</h4><p>普通</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.navigationBarTitle(Text(title),displayMode: .inline)</span><br></pre></td></tr></table></figure>\n\n<p>特大</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.navigationBarTitle(Text(title),displayMode: .large)</span><br></pre></td></tr></table></figure>\n\n<p>随滚动自动变化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.navigationBarTitle(Text(title),displayMode: .automatic)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"需要用到的一些快捷键\"><a href=\"#需要用到的一些快捷键\" class=\"headerlink\" title=\"需要用到的一些快捷键\"></a>需要用到的一些快捷键</h3><p>cmd + ctrl + 鼠标左键+控件/布局  =  调出菜单<br>ctrl + i = 代码缩进调整    </p>\n<p>待续</p>\n","site":{"data":{}},"excerpt":"<p>iOS 13 SwiftUI 指南</p>","more":"<h3 id=\"布局方向\"><a href=\"#布局方向\" class=\"headerlink\" title=\"布局方向\"></a>布局方向</h3><h4 id=\"VStack-垂直布局\"><a href=\"#VStack-垂直布局\" class=\"headerlink\" title=\"VStack 垂直布局\"></a>VStack 垂直布局</h4><p>默认垂直方向居中布局</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VStack &#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World Again!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对齐方向参数可选(<code>.leading</code>,<code>.trailing</code>,<code>.center</code>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VStack(alignment:.leading) &#123;</span><br><span class=\"line\">\tText(&quot;左对齐&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World Again!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"HStack-水平布局\"><a href=\"#HStack-水平布局\" class=\"headerlink\" title=\"HStack 水平布局\"></a>HStack 水平布局</h4><p>默认水平方向居中布局</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HStack &#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World Again!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对齐方向参数可选(<code>.top</code>,<code>.bottom</code>,<code>.center</code>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HStack(alignment:.bottom) &#123;</span><br><span class=\"line\">\tText(&quot;左对齐&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World Again!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ZStack-前后布局\"><a href=\"#ZStack-前后布局\" class=\"headerlink\" title=\"ZStack 前后布局\"></a>ZStack 前后布局</h3><p>代码下面内容的盖住上面的内容</p>\n<p>默认水平居中&amp;垂直居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack &#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对齐方向参数可选(<code>.leading</code>,<code>.trailing</code>,<code>.top</code>,<code>.bottom</code>,<code>.topLeading</code>,<code>.topTrailing</code>,<code>.bottomLeading</code>,<code>.bottomTrailing</code>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack(alignment:.bottom) &#123;</span><br><span class=\"line\">\tText(&quot;底部对齐&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Padding\"><a href=\"#Padding\" class=\"headerlink\" title=\"Padding\"></a>Padding</h3><p>内边距，用来撑开你的布局</p>\n<p>默认撑开上下左右各16pt</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以指定哪个位置撑开和数值大小</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding(20) &#x2F;&#x2F; 上下左右均撑开20</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding(.leading: 20) &#x2F;&#x2F; 左边撑开20，其他同理</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding([.leading,.trailing],50).fixedSize() &#x2F;&#x2F; 左边和右边都撑开50，其他同理，fixedSize意思等同于UILabel的sizeToFit</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding(.leading, 10).padding(.top, 20) &#x2F;&#x2F; 左边10，上边20，其他同理</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Spacer\"><a href=\"#Spacer\" class=\"headerlink\" title=\"Spacer\"></a>Spacer</h3><p>用来填充空位。</p>\n<p>因为SwiftUI不像原来的UI开发，是先设置好frame,再往里面添加东西，相反，他是一种先紧紧包住控件，然后通过padding、spacer等元素去“撑开”视图的思想。所以，Spacer在这里有点类似于UIBarButtonItem里的那个<code>UIBarButtonSystemItemFlexibleSpace</code>,就是把东西给撑开。</p>\n<p>举个例子</p>\n<p>水平界面这时候布局紧紧包裹着Text控件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HStack &#123;</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果这时候加一个Spacer,那么Text控件就会靠左，右边部分会被Spacer把剩余空隙填满</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HStack &#123;</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tSpacer()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同理如果是<code>VStack</code>，写在下面的话，自然就会把Text控件往上顶，然后把剩余屏幕部分填满。</p>\n<h3 id=\"Image\"><a href=\"#Image\" class=\"headerlink\" title=\"Image\"></a>Image</h3><p>直接输入图片名就可以引用本地图片<br><code>Image(&quot;bg_nuanxin_mask&quot;)</code></p>\n<h4 id=\"resizeable\"><a href=\"#resizeable\" class=\"headerlink\" title=\"resizeable\"></a>resizeable</h4><p><code>Image(&quot;bg_nuanxin_mask&quot;).resizable()</code></p>\n<p>把图片撑开</p>\n<h3 id=\"隐藏NavigationBar\"><a href=\"#隐藏NavigationBar\" class=\"headerlink\" title=\"隐藏NavigationBar\"></a>隐藏NavigationBar</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NavigationView &#123;</span><br><span class=\"line\">\tZStack &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t.navigationBarHidden(true)</span><br><span class=\"line\">\t.navigationBarTitle(&quot;&quot;)</span><br><span class=\"line\">\t.navigationBarBackButtonHidden(true)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"这个界面不显示，下个界面要显示导航栏\"><a href=\"#这个界面不显示，下个界面要显示导航栏\" class=\"headerlink\" title=\"这个界面不显示，下个界面要显示导航栏\"></a>这个界面不显示，下个界面要显示导航栏</h4><p>当前页面声明一个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@State private var navBarHidden &#x3D; true</span><br></pre></td></tr></table></figure>\n\n<p>目标页面加一个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Binding var navBarHidden : Bool</span><br></pre></td></tr></table></figure>\n\n<p>传值过去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NavigationLink(destination:xxxx, navBarHidden: $navBarHidden)) &#123;</span><br><span class=\"line\">   xxxxx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>目标页面处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var body: some View &#123;</span><br><span class=\"line\">\tWebView(webUrl:&quot;https:&#x2F;&#x2F;www.baidu.com&quot;,title: $title)</span><br><span class=\"line\">\t.onAppear &#123;</span><br><span class=\"line\">\t\tself.navBarHidden &#x3D; false</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t.onDisappear &#123;</span><br><span class=\"line\">\t\tself.navBarHidden &#x3D; true</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t.navigationBarTitle(Text(title),displayMode: .inline)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"导航栏标题样式\"><a href=\"#导航栏标题样式\" class=\"headerlink\" title=\"导航栏标题样式\"></a>导航栏标题样式</h4><p>普通</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.navigationBarTitle(Text(title),displayMode: .inline)</span><br></pre></td></tr></table></figure>\n\n<p>特大</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.navigationBarTitle(Text(title),displayMode: .large)</span><br></pre></td></tr></table></figure>\n\n<p>随滚动自动变化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.navigationBarTitle(Text(title),displayMode: .automatic)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"需要用到的一些快捷键\"><a href=\"#需要用到的一些快捷键\" class=\"headerlink\" title=\"需要用到的一些快捷键\"></a>需要用到的一些快捷键</h3><p>cmd + ctrl + 鼠标左键+控件/布局  =  调出菜单<br>ctrl + i = 代码缩进调整    </p>\n<p>待续</p>"},{"title":"Shell 笔记","author":"Arclin","abbrlink":"cfe784af","date":"2018-05-17T08:10:25.000Z","_content":"Shell 笔记，有机会写就会继续补充\n<!--more-->\n\n1. if语句的中括号要留空格  `if空格[空格 判断语句 空格]; then xxx fi` \n2. 判断买某个路径是否是文件夹  `if [ -d “./xxx” ]; then xxx fi`\n3. 建立一个数组 `check=(\"Wechat\" \"Ali\" \"Union\" \"Pay\")`\n4. 声明一个函数, 并取得第一个参数\n\t```\n    function xxx() {\n    \tdir=$1\n    }\n    ```\n5. 获得某个后缀名的文件 `directory=./${d%.*}\".app\"`\n6. 执行某个命令但不输出到控制台 `unzip $xxx > /dev/null 2>&1`\n7. 声明某个变量为局部变量，使用`local`关键字 `local dir=$1`\n8. 大写转小写 `local file_name_lower=$(echo $file_name | tr 'A-Z' 'a-z')`\n9. 小写转大写 `local file_name_lower=$(echo $file_name | tr 'a-z' 'A-Z')`\n10. 遍历数组\n  ```\n  for item in ${check[@]}; do\n      echo $item\n  done\n  ```\n11. 字符串A是否包含字符串B `if[[ $A =~ $B ]]; then xxx fi`","source":"_posts/Shell-笔记.md","raw":"title: Shell 笔记\nauthor: Arclin\nabbrlink: cfe784af\ndate: 2018-05-17 16:10:25\ntags:\n---\nShell 笔记，有机会写就会继续补充\n<!--more-->\n\n1. if语句的中括号要留空格  `if空格[空格 判断语句 空格]; then xxx fi` \n2. 判断买某个路径是否是文件夹  `if [ -d “./xxx” ]; then xxx fi`\n3. 建立一个数组 `check=(\"Wechat\" \"Ali\" \"Union\" \"Pay\")`\n4. 声明一个函数, 并取得第一个参数\n\t```\n    function xxx() {\n    \tdir=$1\n    }\n    ```\n5. 获得某个后缀名的文件 `directory=./${d%.*}\".app\"`\n6. 执行某个命令但不输出到控制台 `unzip $xxx > /dev/null 2>&1`\n7. 声明某个变量为局部变量，使用`local`关键字 `local dir=$1`\n8. 大写转小写 `local file_name_lower=$(echo $file_name | tr 'A-Z' 'a-z')`\n9. 小写转大写 `local file_name_lower=$(echo $file_name | tr 'a-z' 'A-Z')`\n10. 遍历数组\n  ```\n  for item in ${check[@]}; do\n      echo $item\n  done\n  ```\n11. 字符串A是否包含字符串B `if[[ $A =~ $B ]]; then xxx fi`","slug":"Shell-笔记","published":1,"updated":"2021-06-06T18:52:24.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohb002atnn09uh6hy89","content":"<p>Shell 笔记，有机会写就会继续补充</p>\n<span id=\"more\"></span>\n\n<ol>\n<li>if语句的中括号要留空格  <code>if空格[空格 判断语句 空格]; then xxx fi</code> </li>\n<li>判断买某个路径是否是文件夹  <code>if [ -d “./xxx” ]; then xxx fi</code></li>\n<li>建立一个数组 <code>check=(&quot;Wechat&quot; &quot;Ali&quot; &quot;Union&quot; &quot;Pay&quot;)</code></li>\n<li>声明一个函数, 并取得第一个参数 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function xxx() &#123;</span><br><span class=\"line\">\tdir&#x3D;$1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>获得某个后缀名的文件 <code>directory=./$&#123;d%.*&#125;&quot;.app&quot;</code></li>\n<li>执行某个命令但不输出到控制台 <code>unzip $xxx &gt; /dev/null 2&gt;&amp;1</code></li>\n<li>声明某个变量为局部变量，使用<code>local</code>关键字 <code>local dir=$1</code></li>\n<li>大写转小写 <code>local file_name_lower=$(echo $file_name | tr &#39;A-Z&#39; &#39;a-z&#39;)</code></li>\n<li>小写转大写 <code>local file_name_lower=$(echo $file_name | tr &#39;a-z&#39; &#39;A-Z&#39;)</code></li>\n<li>遍历数组<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for item in $&#123;check[@]&#125;; do</span><br><span class=\"line\">    echo $item</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></li>\n<li>字符串A是否包含字符串B <code>if[[ $A =~ $B ]]; then xxx fi</code></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Shell 笔记，有机会写就会继续补充</p>","more":"<ol>\n<li>if语句的中括号要留空格  <code>if空格[空格 判断语句 空格]; then xxx fi</code> </li>\n<li>判断买某个路径是否是文件夹  <code>if [ -d “./xxx” ]; then xxx fi</code></li>\n<li>建立一个数组 <code>check=(&quot;Wechat&quot; &quot;Ali&quot; &quot;Union&quot; &quot;Pay&quot;)</code></li>\n<li>声明一个函数, 并取得第一个参数 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function xxx() &#123;</span><br><span class=\"line\">\tdir&#x3D;$1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>获得某个后缀名的文件 <code>directory=./$&#123;d%.*&#125;&quot;.app&quot;</code></li>\n<li>执行某个命令但不输出到控制台 <code>unzip $xxx &gt; /dev/null 2&gt;&amp;1</code></li>\n<li>声明某个变量为局部变量，使用<code>local</code>关键字 <code>local dir=$1</code></li>\n<li>大写转小写 <code>local file_name_lower=$(echo $file_name | tr &#39;A-Z&#39; &#39;a-z&#39;)</code></li>\n<li>小写转大写 <code>local file_name_lower=$(echo $file_name | tr &#39;a-z&#39; &#39;A-Z&#39;)</code></li>\n<li>遍历数组<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for item in $&#123;check[@]&#125;; do</span><br><span class=\"line\">    echo $item</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></li>\n<li>字符串A是否包含字符串B <code>if[[ $A =~ $B ]]; then xxx fi</code></li>\n</ol>"},{"title":" UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃的问题","author":"Arclin","abbrlink":"1787ee1c","date":"2016-11-08T16:00:00.000Z","_content":"UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃\n\n```\n-[UIPopoverController dealloc] reached while popover is still visible.\n```\n\n<!-- more -->\n\n错误的大体意思是：popover在仍旧可见的时候被销毁了（调用了dealloc）\n\n从错误可以得出的结论\n当popover仍旧可见的时候，不准销毁popover对象\n在销\n毁popover对象之前，一定先让popover消失（不可见）\n\n```\n@property (retain, nonatomic) UIPopoverController *popoverController;\n\n- (void)splitViewController:(UISplitViewController *)svc willHideViewController:(UIViewController *)aViewController withBarButtonItem:(UIBarButtonItem *)barButtonItem forPopoverController:(UIPopoverController *)pc\n{\n    self.popoverController = pc;\n}\n\n- (void)dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion\n{\n    [self.popoverController dismissPopoverAnimated:YES];\n    [super dismissViewControllerAnimated:YES completion:nil];\n}\n```","source":"_posts/UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃的问题.md","raw":"---\ntitle: ' UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃的问题'\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 1787ee1c\ndate: 2016-11-09 00:00:00\n---\nUISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃\n\n```\n-[UIPopoverController dealloc] reached while popover is still visible.\n```\n\n<!-- more -->\n\n错误的大体意思是：popover在仍旧可见的时候被销毁了（调用了dealloc）\n\n从错误可以得出的结论\n当popover仍旧可见的时候，不准销毁popover对象\n在销\n毁popover对象之前，一定先让popover消失（不可见）\n\n```\n@property (retain, nonatomic) UIPopoverController *popoverController;\n\n- (void)splitViewController:(UISplitViewController *)svc willHideViewController:(UIViewController *)aViewController withBarButtonItem:(UIBarButtonItem *)barButtonItem forPopoverController:(UIPopoverController *)pc\n{\n    self.popoverController = pc;\n}\n\n- (void)dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion\n{\n    [self.popoverController dismissPopoverAnimated:YES];\n    [super dismissViewControllerAnimated:YES completion:nil];\n}\n```","slug":"UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃的问题","published":1,"updated":"2021-06-06T18:52:24.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohc002dtnn0ay2v2fdh","content":"<p>UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-[UIPopoverController dealloc] reached while popover is still visible.</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<p>错误的大体意思是：popover在仍旧可见的时候被销毁了（调用了dealloc）</p>\n<p>从错误可以得出的结论<br>当popover仍旧可见的时候，不准销毁popover对象<br>在销<br>毁popover对象之前，一定先让popover消失（不可见）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property (retain, nonatomic) UIPopoverController *popoverController;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)splitViewController:(UISplitViewController *)svc willHideViewController:(UIViewController *)aViewController withBarButtonItem:(UIBarButtonItem *)barButtonItem forPopoverController:(UIPopoverController *)pc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self.popoverController &#x3D; pc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.popoverController dismissPopoverAnimated:YES];</span><br><span class=\"line\">    [super dismissViewControllerAnimated:YES completion:nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-[UIPopoverController dealloc] reached while popover is still visible.</span><br></pre></td></tr></table></figure>","more":"<p>错误的大体意思是：popover在仍旧可见的时候被销毁了（调用了dealloc）</p>\n<p>从错误可以得出的结论<br>当popover仍旧可见的时候，不准销毁popover对象<br>在销<br>毁popover对象之前，一定先让popover消失（不可见）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property (retain, nonatomic) UIPopoverController *popoverController;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)splitViewController:(UISplitViewController *)svc willHideViewController:(UIViewController *)aViewController withBarButtonItem:(UIBarButtonItem *)barButtonItem forPopoverController:(UIPopoverController *)pc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self.popoverController &#x3D; pc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.popoverController dismissPopoverAnimated:YES];</span><br><span class=\"line\">    [super dismissViewControllerAnimated:YES completion:nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"URLWithString返回空","author":"Arclin","abbrlink":"890a3088","date":"2016-10-16T16:00:00.000Z","_content":"`[NSURL URLWithString:@”…………”]` 返回空 nil\n但是貌似汉字或者空格等无法被识别，String不被认为是URLString，这个NSURL的值也就一直是nil\n要怎样才能够让它识别呢？\n解决方法如下 ：\n\n1. 转换编码\n\n  ```\n  str1 = [str1 stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n\n  NSURL *url = [NSURL URLWithString:[Tool returnFormatString:str1]];\n  ```\n\n2. 除去空格\n\n  ```\n  +(NSString *)returnFormatString:(NSString *)str\n  {\n      return [str stringByReplacingOccurrencesOfString:@\" \"withString:@\" \"];\n  }\n\n   NSLog(@\"URL==%@\",url);\n  ```","source":"_posts/URLWithString返回空.md","raw":"---\ntitle: URLWithString返回空\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 890a3088\ndate: 2016-10-17 00:00:00\n---\n`[NSURL URLWithString:@”…………”]` 返回空 nil\n但是貌似汉字或者空格等无法被识别，String不被认为是URLString，这个NSURL的值也就一直是nil\n要怎样才能够让它识别呢？\n解决方法如下 ：\n\n1. 转换编码\n\n  ```\n  str1 = [str1 stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n\n  NSURL *url = [NSURL URLWithString:[Tool returnFormatString:str1]];\n  ```\n\n2. 除去空格\n\n  ```\n  +(NSString *)returnFormatString:(NSString *)str\n  {\n      return [str stringByReplacingOccurrencesOfString:@\" \"withString:@\" \"];\n  }\n\n   NSLog(@\"URL==%@\",url);\n  ```","slug":"URLWithString返回空","published":1,"updated":"2021-06-06T18:52:24.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohd002htnn04dmh8pc7","content":"<p><code>[NSURL URLWithString:@”…………”]</code> 返回空 nil<br>但是貌似汉字或者空格等无法被识别，String不被认为是URLString，这个NSURL的值也就一直是nil<br>要怎样才能够让它识别呢？<br>解决方法如下 ：</p>\n<ol>\n<li>转换编码</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 &#x3D; [str1 stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class=\"line\"></span><br><span class=\"line\">NSURL *url &#x3D; [NSURL URLWithString:[Tool returnFormatString:str1]];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>除去空格</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+(NSString *)returnFormatString:(NSString *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return [str stringByReplacingOccurrencesOfString:@&quot; &quot;withString:@&quot; &quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> NSLog(@&quot;URL&#x3D;&#x3D;%@&quot;,url);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><code>[NSURL URLWithString:@”…………”]</code> 返回空 nil<br>但是貌似汉字或者空格等无法被识别，String不被认为是URLString，这个NSURL的值也就一直是nil<br>要怎样才能够让它识别呢？<br>解决方法如下 ：</p>\n<ol>\n<li>转换编码</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 &#x3D; [str1 stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class=\"line\"></span><br><span class=\"line\">NSURL *url &#x3D; [NSURL URLWithString:[Tool returnFormatString:str1]];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>除去空格</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+(NSString *)returnFormatString:(NSString *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return [str stringByReplacingOccurrencesOfString:@&quot; &quot;withString:@&quot; &quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> NSLog(@&quot;URL&#x3D;&#x3D;%@&quot;,url);</span><br></pre></td></tr></table></figure>"},{"title":"ReactiveCocoa解决异步串行任务执行中多层嵌套/递归的问题","author":"Arclin","abbrlink":"5f5664e4","date":"2017-03-19T16:00:00.000Z","_content":"\n因为在项目中遇到了一个异步的串行任务执行的问题,通过ReactiveCocoa解决了,所以在这里记录一下\n\n<!-- more -->\n\n首先是一个第三方的API,这个API会进行一个网络请求,并且使用block进行回调.批量执行并且是串行执行.\n如果不用RAC,我们可以通过递归,当任务一结束的时候递归执行任务二,以达到串行的效果,然后判断索引达到最后的时候跳出递归,但这种操作如果一多容易造成栈溢出,所以用RAC的优化如下.\n\n首先使用一个`RACSignal`包装API,如下\n\n```\n- (RACSignal *)deleteWithId:(NSString *)identifier\n{\n    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        GTLQueryDrive *query = [GTLQueryDrive queryForFilesDeleteWithFileId:identifier];\n        [self.service executeQuery:query completionHandler:^(GTLServiceTicket *ticket, id object, NSError *error) {\n            if(!error) {\n                [subscriber sendNext:nil];\n                [subscriber sendCompleted];\n            }else {\n                [subscriber sendError:error]; // 失败的时候抛出异常\n            }\n        }];\n        return nil;\n    }];\n    return signal;\n}\n```\n  \n接下来把多个任务组装成一个数组\n\n```\nNSMutableArray *signals = [NSMutableArray array];\nfor (NSString *identifier in identifiers) {\n    RACSignal * signal = [self deleteWithId:identifier];\n    [signals addObject:signal];\n}\n```\n然后使用`RACSignal`的`concat`方法\n\n`concat`会顺序执行数组中的信号内容,上一个signal的信号`sendComplete`之后下一个信号内容才会开始执行\n\n因为我们要在任务全部执行完成的时候发送一个回调和任务执行到一半的时候抛出异常停止任务和队列.\n所以我们顺便加一个`doCompleted`和`catch`\n\n```\nRACSignal *concatSignal = [[[RACSignal concat:signals] doCompleted:^{\n       completeBlock(nil); // 回调告诉前台说所有任务都完成了\n   }] catch:^RACSignal *(NSError *error) {\n       completeBlock(error); // 回调告诉前台说异常了\n       return [RACSignal empty]; // 停止当前和接下来的任务的执行\n   }];\n```\n\n如果你要订阅concatSignal信号的时候用到了UI刷新或者其他需要在主线程执行的任务,那么这里可以加多一个`deliverOn:[RACScheduler mainThreadScheduler]]`\n\n所以最后的信号可能是这样子\n\n```\nRACSignal *concatSignal = [[[[RACSignal concat:signals] doCompleted:^{\n    completeBlock(nil);\n}] catch:^RACSignal *(NSError *error) {\n    completeBlock(error);\n    return [RACSignal empty];\n}] deliverOn:[RACScheduler mainThreadScheduler]];\n```\n\n那订阅信号就简单了\n\n```\n[concatSignal subscribeNext:^(id x) {\n    DKLog(@\"%@\",x);\n}];\n```\n执行的时候他会根据数组的顺序一个个执行信号内的内容,这样子写起来也好看了很多.\n","source":"_posts/ReactiveCocoa解决异步串行任务执行中多层嵌套-递归的问题.md","raw":"---\ntitle: ReactiveCocoa解决异步串行任务执行中多层嵌套/递归的问题\nauthor: Arclin\ntags:\n  - iOS\n  - Reactive Cocoa\ncategories:\n  - iOS\nabbrlink: 5f5664e4\ndate: 2017-03-20 00:00:00\n---\n\n因为在项目中遇到了一个异步的串行任务执行的问题,通过ReactiveCocoa解决了,所以在这里记录一下\n\n<!-- more -->\n\n首先是一个第三方的API,这个API会进行一个网络请求,并且使用block进行回调.批量执行并且是串行执行.\n如果不用RAC,我们可以通过递归,当任务一结束的时候递归执行任务二,以达到串行的效果,然后判断索引达到最后的时候跳出递归,但这种操作如果一多容易造成栈溢出,所以用RAC的优化如下.\n\n首先使用一个`RACSignal`包装API,如下\n\n```\n- (RACSignal *)deleteWithId:(NSString *)identifier\n{\n    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        GTLQueryDrive *query = [GTLQueryDrive queryForFilesDeleteWithFileId:identifier];\n        [self.service executeQuery:query completionHandler:^(GTLServiceTicket *ticket, id object, NSError *error) {\n            if(!error) {\n                [subscriber sendNext:nil];\n                [subscriber sendCompleted];\n            }else {\n                [subscriber sendError:error]; // 失败的时候抛出异常\n            }\n        }];\n        return nil;\n    }];\n    return signal;\n}\n```\n  \n接下来把多个任务组装成一个数组\n\n```\nNSMutableArray *signals = [NSMutableArray array];\nfor (NSString *identifier in identifiers) {\n    RACSignal * signal = [self deleteWithId:identifier];\n    [signals addObject:signal];\n}\n```\n然后使用`RACSignal`的`concat`方法\n\n`concat`会顺序执行数组中的信号内容,上一个signal的信号`sendComplete`之后下一个信号内容才会开始执行\n\n因为我们要在任务全部执行完成的时候发送一个回调和任务执行到一半的时候抛出异常停止任务和队列.\n所以我们顺便加一个`doCompleted`和`catch`\n\n```\nRACSignal *concatSignal = [[[RACSignal concat:signals] doCompleted:^{\n       completeBlock(nil); // 回调告诉前台说所有任务都完成了\n   }] catch:^RACSignal *(NSError *error) {\n       completeBlock(error); // 回调告诉前台说异常了\n       return [RACSignal empty]; // 停止当前和接下来的任务的执行\n   }];\n```\n\n如果你要订阅concatSignal信号的时候用到了UI刷新或者其他需要在主线程执行的任务,那么这里可以加多一个`deliverOn:[RACScheduler mainThreadScheduler]]`\n\n所以最后的信号可能是这样子\n\n```\nRACSignal *concatSignal = [[[[RACSignal concat:signals] doCompleted:^{\n    completeBlock(nil);\n}] catch:^RACSignal *(NSError *error) {\n    completeBlock(error);\n    return [RACSignal empty];\n}] deliverOn:[RACScheduler mainThreadScheduler]];\n```\n\n那订阅信号就简单了\n\n```\n[concatSignal subscribeNext:^(id x) {\n    DKLog(@\"%@\",x);\n}];\n```\n执行的时候他会根据数组的顺序一个个执行信号内的内容,这样子写起来也好看了很多.\n","slug":"ReactiveCocoa解决异步串行任务执行中多层嵌套-递归的问题","published":1,"updated":"2021-06-06T18:52:24.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohg002ktnn0d2aueal2","content":"<p>因为在项目中遇到了一个异步的串行任务执行的问题,通过ReactiveCocoa解决了,所以在这里记录一下</p>\n<span id=\"more\"></span>\n\n<p>首先是一个第三方的API,这个API会进行一个网络请求,并且使用block进行回调.批量执行并且是串行执行.<br>如果不用RAC,我们可以通过递归,当任务一结束的时候递归执行任务二,以达到串行的效果,然后判断索引达到最后的时候跳出递归,但这种操作如果一多容易造成栈溢出,所以用RAC的优化如下.</p>\n<p>首先使用一个<code>RACSignal</code>包装API,如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (RACSignal *)deleteWithId:(NSString *)identifier</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RACSignal *signal &#x3D; [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class=\"line\">        GTLQueryDrive *query &#x3D; [GTLQueryDrive queryForFilesDeleteWithFileId:identifier];</span><br><span class=\"line\">        [self.service executeQuery:query completionHandler:^(GTLServiceTicket *ticket, id object, NSError *error) &#123;</span><br><span class=\"line\">            if(!error) &#123;</span><br><span class=\"line\">                [subscriber sendNext:nil];</span><br><span class=\"line\">                [subscriber sendCompleted];</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                [subscriber sendError:error]; &#x2F;&#x2F; 失败的时候抛出异常</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    return signal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来把多个任务组装成一个数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableArray *signals &#x3D; [NSMutableArray array];</span><br><span class=\"line\">for (NSString *identifier in identifiers) &#123;</span><br><span class=\"line\">    RACSignal * signal &#x3D; [self deleteWithId:identifier];</span><br><span class=\"line\">    [signals addObject:signal];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后使用<code>RACSignal</code>的<code>concat</code>方法</p>\n<p><code>concat</code>会顺序执行数组中的信号内容,上一个signal的信号<code>sendComplete</code>之后下一个信号内容才会开始执行</p>\n<p>因为我们要在任务全部执行完成的时候发送一个回调和任务执行到一半的时候抛出异常停止任务和队列.<br>所以我们顺便加一个<code>doCompleted</code>和<code>catch</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *concatSignal &#x3D; [[[RACSignal concat:signals] doCompleted:^&#123;</span><br><span class=\"line\">       completeBlock(nil); &#x2F;&#x2F; 回调告诉前台说所有任务都完成了</span><br><span class=\"line\">   &#125;] catch:^RACSignal *(NSError *error) &#123;</span><br><span class=\"line\">       completeBlock(error); &#x2F;&#x2F; 回调告诉前台说异常了</span><br><span class=\"line\">       return [RACSignal empty]; &#x2F;&#x2F; 停止当前和接下来的任务的执行</span><br><span class=\"line\">   &#125;];</span><br></pre></td></tr></table></figure>\n\n<p>如果你要订阅concatSignal信号的时候用到了UI刷新或者其他需要在主线程执行的任务,那么这里可以加多一个<code>deliverOn:[RACScheduler mainThreadScheduler]]</code></p>\n<p>所以最后的信号可能是这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *concatSignal &#x3D; [[[[RACSignal concat:signals] doCompleted:^&#123;</span><br><span class=\"line\">    completeBlock(nil);</span><br><span class=\"line\">&#125;] catch:^RACSignal *(NSError *error) &#123;</span><br><span class=\"line\">    completeBlock(error);</span><br><span class=\"line\">    return [RACSignal empty];</span><br><span class=\"line\">&#125;] deliverOn:[RACScheduler mainThreadScheduler]];</span><br></pre></td></tr></table></figure>\n\n<p>那订阅信号就简单了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[concatSignal subscribeNext:^(id x) &#123;</span><br><span class=\"line\">    DKLog(@&quot;%@&quot;,x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>执行的时候他会根据数组的顺序一个个执行信号内的内容,这样子写起来也好看了很多.</p>\n","site":{"data":{}},"excerpt":"<p>因为在项目中遇到了一个异步的串行任务执行的问题,通过ReactiveCocoa解决了,所以在这里记录一下</p>","more":"<p>首先是一个第三方的API,这个API会进行一个网络请求,并且使用block进行回调.批量执行并且是串行执行.<br>如果不用RAC,我们可以通过递归,当任务一结束的时候递归执行任务二,以达到串行的效果,然后判断索引达到最后的时候跳出递归,但这种操作如果一多容易造成栈溢出,所以用RAC的优化如下.</p>\n<p>首先使用一个<code>RACSignal</code>包装API,如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (RACSignal *)deleteWithId:(NSString *)identifier</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RACSignal *signal &#x3D; [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class=\"line\">        GTLQueryDrive *query &#x3D; [GTLQueryDrive queryForFilesDeleteWithFileId:identifier];</span><br><span class=\"line\">        [self.service executeQuery:query completionHandler:^(GTLServiceTicket *ticket, id object, NSError *error) &#123;</span><br><span class=\"line\">            if(!error) &#123;</span><br><span class=\"line\">                [subscriber sendNext:nil];</span><br><span class=\"line\">                [subscriber sendCompleted];</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                [subscriber sendError:error]; &#x2F;&#x2F; 失败的时候抛出异常</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    return signal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来把多个任务组装成一个数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableArray *signals &#x3D; [NSMutableArray array];</span><br><span class=\"line\">for (NSString *identifier in identifiers) &#123;</span><br><span class=\"line\">    RACSignal * signal &#x3D; [self deleteWithId:identifier];</span><br><span class=\"line\">    [signals addObject:signal];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后使用<code>RACSignal</code>的<code>concat</code>方法</p>\n<p><code>concat</code>会顺序执行数组中的信号内容,上一个signal的信号<code>sendComplete</code>之后下一个信号内容才会开始执行</p>\n<p>因为我们要在任务全部执行完成的时候发送一个回调和任务执行到一半的时候抛出异常停止任务和队列.<br>所以我们顺便加一个<code>doCompleted</code>和<code>catch</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *concatSignal &#x3D; [[[RACSignal concat:signals] doCompleted:^&#123;</span><br><span class=\"line\">       completeBlock(nil); &#x2F;&#x2F; 回调告诉前台说所有任务都完成了</span><br><span class=\"line\">   &#125;] catch:^RACSignal *(NSError *error) &#123;</span><br><span class=\"line\">       completeBlock(error); &#x2F;&#x2F; 回调告诉前台说异常了</span><br><span class=\"line\">       return [RACSignal empty]; &#x2F;&#x2F; 停止当前和接下来的任务的执行</span><br><span class=\"line\">   &#125;];</span><br></pre></td></tr></table></figure>\n\n<p>如果你要订阅concatSignal信号的时候用到了UI刷新或者其他需要在主线程执行的任务,那么这里可以加多一个<code>deliverOn:[RACScheduler mainThreadScheduler]]</code></p>\n<p>所以最后的信号可能是这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *concatSignal &#x3D; [[[[RACSignal concat:signals] doCompleted:^&#123;</span><br><span class=\"line\">    completeBlock(nil);</span><br><span class=\"line\">&#125;] catch:^RACSignal *(NSError *error) &#123;</span><br><span class=\"line\">    completeBlock(error);</span><br><span class=\"line\">    return [RACSignal empty];</span><br><span class=\"line\">&#125;] deliverOn:[RACScheduler mainThreadScheduler]];</span><br></pre></td></tr></table></figure>\n\n<p>那订阅信号就简单了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[concatSignal subscribeNext:^(id x) &#123;</span><br><span class=\"line\">    DKLog(@&quot;%@&quot;,x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>执行的时候他会根据数组的顺序一个个执行信号内的内容,这样子写起来也好看了很多.</p>"},{"title":"Apache强制https ","author":"Arclin","abbrlink":"f6ce3122","date":"2018-02-18T13:50:00.000Z","_content":"当用户访问http的地址的时候，Apache如何强制跳转到https地址\n\n<!-- more -->\n\n修改httpd.conf\n\n1. LoadModule rewrite_module modules/mod_rewrite.so 这个拓展貌似是已经被加载了；\n2. 修改Apache默认项目路径的这个\n\n```\n<Directory \"/var/www/html\">\n```\n\n其实是修改为项目发布的路径\n```\n<Directory \"/var/www/html/app/src/htdocs_www\">\n```\n改为All\n\n```\nAllowOverride All\n```\n\n\n```\n# \n# Possible values for the Options directive are \"None\", \"All\", \n# or any combination of: \n# Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews \n# \n# Note that \"MultiViews\" must be named *explicitly* --- \"Options All\" \n# doesn't give it to you. \n# \n# The Options directive is both complicated and important. Please see \n# http://httpd.apache.org/docs/2.2/mod/core.html\n# options \n# for more information. \n# Options Indexes FollowSymLinks \n# \n# AllowOverride controls what directives may be placed in .htaccess files. \n# It can be \"All\", \"None\", or any combination of the keywords: \n# Options FileInfo AuthConfig Limit \n# \n# \n# Controls who can get stuff from this server. \n# \nOrder allow,deny \nAllow from all\n```\n\n添加三行代码\n\n```\nRewriteEngine on\nRewriteCond %{SERVER_PORT} !^443$\nRewriteRule ^(.*)?$ https://%{SERVER_NAME}/$1 [L,R]\n```","source":"_posts/Untitled.md","raw":"---\ntitle: 'Apache强制https '\nauthor: Arclin\ntags:\n  - https\ncategories:\n  - Linux\nabbrlink: f6ce3122\ndate: 2018-02-18 21:50:00\n---\n当用户访问http的地址的时候，Apache如何强制跳转到https地址\n\n<!-- more -->\n\n修改httpd.conf\n\n1. LoadModule rewrite_module modules/mod_rewrite.so 这个拓展貌似是已经被加载了；\n2. 修改Apache默认项目路径的这个\n\n```\n<Directory \"/var/www/html\">\n```\n\n其实是修改为项目发布的路径\n```\n<Directory \"/var/www/html/app/src/htdocs_www\">\n```\n改为All\n\n```\nAllowOverride All\n```\n\n\n```\n# \n# Possible values for the Options directive are \"None\", \"All\", \n# or any combination of: \n# Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews \n# \n# Note that \"MultiViews\" must be named *explicitly* --- \"Options All\" \n# doesn't give it to you. \n# \n# The Options directive is both complicated and important. Please see \n# http://httpd.apache.org/docs/2.2/mod/core.html\n# options \n# for more information. \n# Options Indexes FollowSymLinks \n# \n# AllowOverride controls what directives may be placed in .htaccess files. \n# It can be \"All\", \"None\", or any combination of the keywords: \n# Options FileInfo AuthConfig Limit \n# \n# \n# Controls who can get stuff from this server. \n# \nOrder allow,deny \nAllow from all\n```\n\n添加三行代码\n\n```\nRewriteEngine on\nRewriteCond %{SERVER_PORT} !^443$\nRewriteRule ^(.*)?$ https://%{SERVER_NAME}/$1 [L,R]\n```","slug":"Untitled","published":1,"updated":"2021-06-06T18:52:24.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohh002otnn0hpaweqvy","content":"<p>当用户访问http的地址的时候，Apache如何强制跳转到https地址</p>\n<span id=\"more\"></span>\n\n<p>修改httpd.conf</p>\n<ol>\n<li>LoadModule rewrite_module modules/mod_rewrite.so 这个拓展貌似是已经被加载了；</li>\n<li>修改Apache默认项目路径的这个</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>其实是修改为项目发布的路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;app&#x2F;src&#x2F;htdocs_www&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>改为All</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AllowOverride All</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># </span><br><span class=\"line\"># Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, </span><br><span class=\"line\"># or any combination of: </span><br><span class=\"line\"># Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews </span><br><span class=\"line\"># </span><br><span class=\"line\"># Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; </span><br><span class=\"line\"># doesn&#39;t give it to you. </span><br><span class=\"line\"># </span><br><span class=\"line\"># The Options directive is both complicated and important. Please see </span><br><span class=\"line\"># http:&#x2F;&#x2F;httpd.apache.org&#x2F;docs&#x2F;2.2&#x2F;mod&#x2F;core.html</span><br><span class=\"line\"># options </span><br><span class=\"line\"># for more information. </span><br><span class=\"line\"># Options Indexes FollowSymLinks </span><br><span class=\"line\"># </span><br><span class=\"line\"># AllowOverride controls what directives may be placed in .htaccess files. </span><br><span class=\"line\"># It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: </span><br><span class=\"line\"># Options FileInfo AuthConfig Limit </span><br><span class=\"line\"># </span><br><span class=\"line\"># </span><br><span class=\"line\"># Controls who can get stuff from this server. </span><br><span class=\"line\"># </span><br><span class=\"line\">Order allow,deny </span><br><span class=\"line\">Allow from all</span><br></pre></td></tr></table></figure>\n\n<p>添加三行代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RewriteEngine on</span><br><span class=\"line\">RewriteCond %&#123;SERVER_PORT&#125; !^443$</span><br><span class=\"line\">RewriteRule ^(.*)?$ https:&#x2F;&#x2F;%&#123;SERVER_NAME&#125;&#x2F;$1 [L,R]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>当用户访问http的地址的时候，Apache如何强制跳转到https地址</p>","more":"<p>修改httpd.conf</p>\n<ol>\n<li>LoadModule rewrite_module modules/mod_rewrite.so 这个拓展貌似是已经被加载了；</li>\n<li>修改Apache默认项目路径的这个</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>其实是修改为项目发布的路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;app&#x2F;src&#x2F;htdocs_www&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>改为All</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AllowOverride All</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># </span><br><span class=\"line\"># Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, </span><br><span class=\"line\"># or any combination of: </span><br><span class=\"line\"># Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews </span><br><span class=\"line\"># </span><br><span class=\"line\"># Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; </span><br><span class=\"line\"># doesn&#39;t give it to you. </span><br><span class=\"line\"># </span><br><span class=\"line\"># The Options directive is both complicated and important. Please see </span><br><span class=\"line\"># http:&#x2F;&#x2F;httpd.apache.org&#x2F;docs&#x2F;2.2&#x2F;mod&#x2F;core.html</span><br><span class=\"line\"># options </span><br><span class=\"line\"># for more information. </span><br><span class=\"line\"># Options Indexes FollowSymLinks </span><br><span class=\"line\"># </span><br><span class=\"line\"># AllowOverride controls what directives may be placed in .htaccess files. </span><br><span class=\"line\"># It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: </span><br><span class=\"line\"># Options FileInfo AuthConfig Limit </span><br><span class=\"line\"># </span><br><span class=\"line\"># </span><br><span class=\"line\"># Controls who can get stuff from this server. </span><br><span class=\"line\"># </span><br><span class=\"line\">Order allow,deny </span><br><span class=\"line\">Allow from all</span><br></pre></td></tr></table></figure>\n\n<p>添加三行代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RewriteEngine on</span><br><span class=\"line\">RewriteCond %&#123;SERVER_PORT&#125; !^443$</span><br><span class=\"line\">RewriteRule ^(.*)?$ https:&#x2F;&#x2F;%&#123;SERVER_NAME&#125;&#x2F;$1 [L,R]</span><br></pre></td></tr></table></figure>"},{"title":"Vue学习笔记","author":"Arclin","abbrlink":"71513ccb","date":"2017-08-07T16:10:00.000Z","_content":"Vue.js 是一个用于构建用户界面的渐进式前端框架\n\n<!-- more -->\n\n## 安装 vue-cli 命令行工具\n\n 安装Vue\n`npm install -g vue-cli`\n\n## 初始化项目\nvue init webpack-simple 项目名\n\n项目模板有很多种,这里用了webpack-simple webpack-simple 没有包括Eslint检查功能等等功能，webpack有,但是普通项目用webpack-simple就足够了.\n\n构造Vue实例\n\n```\nvar vm = new Vue({\n  // 选项\n})\n```\n\n例子\n\n```\nwindow.onload=function(){\n //在这里面写Vue.js代码\n new Vue({\n  el: '#demo', // 需要渲染的DOM元素\n  data: {\t\t // 渲染的数据,key-value方式\n    message: 'Hello Vue.js!' \n  }\n})\n//----------------\n}\n```\n\n## HTML中数据绑定\n\n### 单次插值\n\n```\n<span>Message: {{ message }}</span>\n```\n\n如果想要单次插值,即今后的数据变化就不会再引起插值更新,加个 *\n\n```\n<span>This will never change: {{* message }}</span>\n```\n\n例子\n\n```\nJS\n\nvar data={message:'Hello Vue.js!'};\nnew Vue({\n  el: '#demo',\n  data: data\n })\ndata.message =\"Hello World!\";\ndata.message =\"Hello\"; // 再次改变时候,第二个元素内的值不会变化\n\nHTML\n\n<span>This will never change: {{ message }}</span><br>\n<span>This will never change: {{* message }}</span>\n```\n\n### 嵌入HTML\n\n三个大括号表示不是插入文本而是html标签\n\n```\nHTML\n\n<div>{{{ msg }}}</div>\n```\n\n```\nJS\n\nvar data={msg:'<p>Hello Vue.js!</p>'};\nnew Vue({\n    el: '#demo',\n    data: data\n})\n\n```\n\n### HTMl特性\n比如说修改某个元素的id属性\n\n```\nHTML\n\n<div id=\"{{ id }}\"></div>\n```\n\n```\nJS\n\nvar data={id:'demo'};\nnew Vue({\n  el: 'div',\n  data: data\n})\n```\n\n### JavaScript表达式\n\n绑定的数据支持JavaScript表达式\n\n```\nJS\n\nwindow.onload=function(){\n //在这里面写Vue.js代码\n var data={message:'Hello ',number:3,ok:true};\n new Vue({\n  el: '#demo',\n  data: data\n })\n //----------------\n}\n```\n\n```\n<div id='demo'>\n{{ number + 1 }}<br/>\n{{ ok ? 'YES' : 'NO' }}<br/>\n{{ message.split('').reverse().join('') }}\n</div>\n```\n\n输出\n\n```\nYES\nolleH\n```\n\n### 过滤器\n使用管道符 |\n\n将message内的全部转换为小写字母\n\n```\n{{ message | lowercase }}\n```\n\n转为小写字母后,首字母大写\n\n```\n{{msg | lowercase | capitalize}}\n```\n\n此外还有大写过滤器`uppercase`\n\n```\nJS\n var data={msg:'heLLO!'};\n new Vue({\n  el: '#demo',\n  data: data\n })\n```\n\n输出\n\n```\nHello\n```\n\n### 指令\n渲染数据的时候的逻辑表达式\nv-text v-html v-model v-on v-else\n\n```\nJS\n\nvar data={msg:0};\n new Vue({\n  el: '#demo',\n  data: data\n })\n```\n\n当msg的值为1的时候才打印Hello!\n\n```\nHTML\n<p v-if=\"msg\">Hello!</p>\n```\n\n### 计算属性\n\n在模板中表达式非常便利，但是它们实际上只用于简单的操作。模板是为了描述视图的结构。在模板中放入太多的逻辑会让模板过重且难以维护。这就是为什么 Vue.js 将绑定表达式限制为一个表达式。如果需要多于一个表达式的逻辑，应当使用计算属性。\n\n```\nJS\n\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    a: 1\n  },\n  computed: {\n    // 一个计算属性的 getter\n    b: function () {\n      // `this` 指向 vm 实例\n      return this.a + 1\n    }\n  }\n})\n```\n```\nHTML\n\n<div id=\"example\">\n  a={{ a }}, b={{ b }}\n</div>\n```\n输出\n\n```\n1\na=1, b=2\n```","source":"_posts/Vue学习笔记.md","raw":"---\ntitle: Vue学习笔记\nauthor: Arclin\ntags:\n  - Vue.js\ncategories:\n  - 前端\nabbrlink: 71513ccb\ndate: 2017-08-08 00:10:00\n---\nVue.js 是一个用于构建用户界面的渐进式前端框架\n\n<!-- more -->\n\n## 安装 vue-cli 命令行工具\n\n 安装Vue\n`npm install -g vue-cli`\n\n## 初始化项目\nvue init webpack-simple 项目名\n\n项目模板有很多种,这里用了webpack-simple webpack-simple 没有包括Eslint检查功能等等功能，webpack有,但是普通项目用webpack-simple就足够了.\n\n构造Vue实例\n\n```\nvar vm = new Vue({\n  // 选项\n})\n```\n\n例子\n\n```\nwindow.onload=function(){\n //在这里面写Vue.js代码\n new Vue({\n  el: '#demo', // 需要渲染的DOM元素\n  data: {\t\t // 渲染的数据,key-value方式\n    message: 'Hello Vue.js!' \n  }\n})\n//----------------\n}\n```\n\n## HTML中数据绑定\n\n### 单次插值\n\n```\n<span>Message: {{ message }}</span>\n```\n\n如果想要单次插值,即今后的数据变化就不会再引起插值更新,加个 *\n\n```\n<span>This will never change: {{* message }}</span>\n```\n\n例子\n\n```\nJS\n\nvar data={message:'Hello Vue.js!'};\nnew Vue({\n  el: '#demo',\n  data: data\n })\ndata.message =\"Hello World!\";\ndata.message =\"Hello\"; // 再次改变时候,第二个元素内的值不会变化\n\nHTML\n\n<span>This will never change: {{ message }}</span><br>\n<span>This will never change: {{* message }}</span>\n```\n\n### 嵌入HTML\n\n三个大括号表示不是插入文本而是html标签\n\n```\nHTML\n\n<div>{{{ msg }}}</div>\n```\n\n```\nJS\n\nvar data={msg:'<p>Hello Vue.js!</p>'};\nnew Vue({\n    el: '#demo',\n    data: data\n})\n\n```\n\n### HTMl特性\n比如说修改某个元素的id属性\n\n```\nHTML\n\n<div id=\"{{ id }}\"></div>\n```\n\n```\nJS\n\nvar data={id:'demo'};\nnew Vue({\n  el: 'div',\n  data: data\n})\n```\n\n### JavaScript表达式\n\n绑定的数据支持JavaScript表达式\n\n```\nJS\n\nwindow.onload=function(){\n //在这里面写Vue.js代码\n var data={message:'Hello ',number:3,ok:true};\n new Vue({\n  el: '#demo',\n  data: data\n })\n //----------------\n}\n```\n\n```\n<div id='demo'>\n{{ number + 1 }}<br/>\n{{ ok ? 'YES' : 'NO' }}<br/>\n{{ message.split('').reverse().join('') }}\n</div>\n```\n\n输出\n\n```\nYES\nolleH\n```\n\n### 过滤器\n使用管道符 |\n\n将message内的全部转换为小写字母\n\n```\n{{ message | lowercase }}\n```\n\n转为小写字母后,首字母大写\n\n```\n{{msg | lowercase | capitalize}}\n```\n\n此外还有大写过滤器`uppercase`\n\n```\nJS\n var data={msg:'heLLO!'};\n new Vue({\n  el: '#demo',\n  data: data\n })\n```\n\n输出\n\n```\nHello\n```\n\n### 指令\n渲染数据的时候的逻辑表达式\nv-text v-html v-model v-on v-else\n\n```\nJS\n\nvar data={msg:0};\n new Vue({\n  el: '#demo',\n  data: data\n })\n```\n\n当msg的值为1的时候才打印Hello!\n\n```\nHTML\n<p v-if=\"msg\">Hello!</p>\n```\n\n### 计算属性\n\n在模板中表达式非常便利，但是它们实际上只用于简单的操作。模板是为了描述视图的结构。在模板中放入太多的逻辑会让模板过重且难以维护。这就是为什么 Vue.js 将绑定表达式限制为一个表达式。如果需要多于一个表达式的逻辑，应当使用计算属性。\n\n```\nJS\n\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    a: 1\n  },\n  computed: {\n    // 一个计算属性的 getter\n    b: function () {\n      // `this` 指向 vm 实例\n      return this.a + 1\n    }\n  }\n})\n```\n```\nHTML\n\n<div id=\"example\">\n  a={{ a }}, b={{ b }}\n</div>\n```\n输出\n\n```\n1\na=1, b=2\n```","slug":"Vue学习笔记","published":1,"updated":"2021-06-06T18:52:24.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohi002qtnn039qp2io0","content":"<p>Vue.js 是一个用于构建用户界面的渐进式前端框架</p>\n<span id=\"more\"></span>\n\n<h2 id=\"安装-vue-cli-命令行工具\"><a href=\"#安装-vue-cli-命令行工具\" class=\"headerlink\" title=\"安装 vue-cli 命令行工具\"></a>安装 vue-cli 命令行工具</h2><p> 安装Vue<br><code>npm install -g vue-cli</code></p>\n<h2 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h2><p>vue init webpack-simple 项目名</p>\n<p>项目模板有很多种,这里用了webpack-simple webpack-simple 没有包括Eslint检查功能等等功能，webpack有,但是普通项目用webpack-simple就足够了.</p>\n<p>构造Vue实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 选项</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.onload&#x3D;function()&#123;</span><br><span class=\"line\"> &#x2F;&#x2F;在这里面写Vue.js代码</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;, &#x2F;&#x2F; 需要渲染的DOM元素</span><br><span class=\"line\">  data: &#123;\t\t &#x2F;&#x2F; 渲染的数据,key-value方式</span><br><span class=\"line\">    message: &#39;Hello Vue.js!&#39; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#x2F;&#x2F;----------------</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"HTML中数据绑定\"><a href=\"#HTML中数据绑定\" class=\"headerlink\" title=\"HTML中数据绑定\"></a>HTML中数据绑定</h2><h3 id=\"单次插值\"><a href=\"#单次插值\" class=\"headerlink\" title=\"单次插值\"></a>单次插值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span&gt;Message: &#123;&#123; message &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果想要单次插值,即今后的数据变化就不会再引起插值更新,加个 *</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123;* message &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>\n\n<p>例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data&#x3D;&#123;message:&#39;Hello Vue.js!&#39;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\">data.message &#x3D;&quot;Hello World!&quot;;</span><br><span class=\"line\">data.message &#x3D;&quot;Hello&quot;; &#x2F;&#x2F; 再次改变时候,第二个元素内的值不会变化</span><br><span class=\"line\"></span><br><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123; message &#125;&#125;&lt;&#x2F;span&gt;&lt;br&gt;</span><br><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123;* message &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"嵌入HTML\"><a href=\"#嵌入HTML\" class=\"headerlink\" title=\"嵌入HTML\"></a>嵌入HTML</h3><p>三个大括号表示不是插入文本而是html标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;&#123;&#123;&#123; msg &#125;&#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data&#x3D;&#123;msg:&#39;&lt;p&gt;Hello Vue.js!&lt;&#x2F;p&gt;&#39;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: &#39;#demo&#39;,</span><br><span class=\"line\">    data: data</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTMl特性\"><a href=\"#HTMl特性\" class=\"headerlink\" title=\"HTMl特性\"></a>HTMl特性</h3><p>比如说修改某个元素的id属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id&#x3D;&quot;&#123;&#123; id &#125;&#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data&#x3D;&#123;id:&#39;demo&#39;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#39;div&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JavaScript表达式\"><a href=\"#JavaScript表达式\" class=\"headerlink\" title=\"JavaScript表达式\"></a>JavaScript表达式</h3><p>绑定的数据支持JavaScript表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">window.onload&#x3D;function()&#123;</span><br><span class=\"line\"> &#x2F;&#x2F;在这里面写Vue.js代码</span><br><span class=\"line\"> var data&#x3D;&#123;message:&#39;Hello &#39;,number:3,ok:true&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> &#x2F;&#x2F;----------------</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&#39;demo&#39;&gt;</span><br><span class=\"line\">&#123;&#123; number + 1 &#125;&#125;&lt;br&#x2F;&gt;</span><br><span class=\"line\">&#123;&#123; ok ? &#39;YES&#39; : &#39;NO&#39; &#125;&#125;&lt;br&#x2F;&gt;</span><br><span class=\"line\">&#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YES</span><br><span class=\"line\">olleH</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h3><p>使用管道符 |</p>\n<p>将message内的全部转换为小写字母</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; message | lowercase &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>转为小写字母后,首字母大写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;msg | lowercase | capitalize&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此外还有大写过滤器<code>uppercase</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"> var data&#x3D;&#123;msg:&#39;heLLO!&#39;&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h3><p>渲染数据的时候的逻辑表达式<br>v-text v-html v-model v-on v-else</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data&#x3D;&#123;msg:0&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>当msg的值为1的时候才打印Hello!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\">&lt;p v-if&#x3D;&quot;msg&quot;&gt;Hello!&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h3><p>在模板中表达式非常便利，但是它们实际上只用于简单的操作。模板是为了描述视图的结构。在模板中放入太多的逻辑会让模板过重且难以维护。这就是为什么 Vue.js 将绑定表达式限制为一个表达式。如果需要多于一个表达式的逻辑，应当使用计算属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#example&#39;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    a: 1</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 一个计算属性的 getter</span><br><span class=\"line\">    b: function () &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; &#96;this&#96; 指向 vm 实例</span><br><span class=\"line\">      return this.a + 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class=\"line\">  a&#x3D;&#123;&#123; a &#125;&#125;, b&#x3D;&#123;&#123; b &#125;&#125;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">a&#x3D;1, b&#x3D;2</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>Vue.js 是一个用于构建用户界面的渐进式前端框架</p>","more":"<h2 id=\"安装-vue-cli-命令行工具\"><a href=\"#安装-vue-cli-命令行工具\" class=\"headerlink\" title=\"安装 vue-cli 命令行工具\"></a>安装 vue-cli 命令行工具</h2><p> 安装Vue<br><code>npm install -g vue-cli</code></p>\n<h2 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h2><p>vue init webpack-simple 项目名</p>\n<p>项目模板有很多种,这里用了webpack-simple webpack-simple 没有包括Eslint检查功能等等功能，webpack有,但是普通项目用webpack-simple就足够了.</p>\n<p>构造Vue实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 选项</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.onload&#x3D;function()&#123;</span><br><span class=\"line\"> &#x2F;&#x2F;在这里面写Vue.js代码</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;, &#x2F;&#x2F; 需要渲染的DOM元素</span><br><span class=\"line\">  data: &#123;\t\t &#x2F;&#x2F; 渲染的数据,key-value方式</span><br><span class=\"line\">    message: &#39;Hello Vue.js!&#39; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#x2F;&#x2F;----------------</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"HTML中数据绑定\"><a href=\"#HTML中数据绑定\" class=\"headerlink\" title=\"HTML中数据绑定\"></a>HTML中数据绑定</h2><h3 id=\"单次插值\"><a href=\"#单次插值\" class=\"headerlink\" title=\"单次插值\"></a>单次插值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span&gt;Message: &#123;&#123; message &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果想要单次插值,即今后的数据变化就不会再引起插值更新,加个 *</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123;* message &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>\n\n<p>例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data&#x3D;&#123;message:&#39;Hello Vue.js!&#39;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\">data.message &#x3D;&quot;Hello World!&quot;;</span><br><span class=\"line\">data.message &#x3D;&quot;Hello&quot;; &#x2F;&#x2F; 再次改变时候,第二个元素内的值不会变化</span><br><span class=\"line\"></span><br><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123; message &#125;&#125;&lt;&#x2F;span&gt;&lt;br&gt;</span><br><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123;* message &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"嵌入HTML\"><a href=\"#嵌入HTML\" class=\"headerlink\" title=\"嵌入HTML\"></a>嵌入HTML</h3><p>三个大括号表示不是插入文本而是html标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;&#123;&#123;&#123; msg &#125;&#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data&#x3D;&#123;msg:&#39;&lt;p&gt;Hello Vue.js!&lt;&#x2F;p&gt;&#39;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: &#39;#demo&#39;,</span><br><span class=\"line\">    data: data</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTMl特性\"><a href=\"#HTMl特性\" class=\"headerlink\" title=\"HTMl特性\"></a>HTMl特性</h3><p>比如说修改某个元素的id属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id&#x3D;&quot;&#123;&#123; id &#125;&#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data&#x3D;&#123;id:&#39;demo&#39;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#39;div&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JavaScript表达式\"><a href=\"#JavaScript表达式\" class=\"headerlink\" title=\"JavaScript表达式\"></a>JavaScript表达式</h3><p>绑定的数据支持JavaScript表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">window.onload&#x3D;function()&#123;</span><br><span class=\"line\"> &#x2F;&#x2F;在这里面写Vue.js代码</span><br><span class=\"line\"> var data&#x3D;&#123;message:&#39;Hello &#39;,number:3,ok:true&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> &#x2F;&#x2F;----------------</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&#39;demo&#39;&gt;</span><br><span class=\"line\">&#123;&#123; number + 1 &#125;&#125;&lt;br&#x2F;&gt;</span><br><span class=\"line\">&#123;&#123; ok ? &#39;YES&#39; : &#39;NO&#39; &#125;&#125;&lt;br&#x2F;&gt;</span><br><span class=\"line\">&#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YES</span><br><span class=\"line\">olleH</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h3><p>使用管道符 |</p>\n<p>将message内的全部转换为小写字母</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; message | lowercase &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>转为小写字母后,首字母大写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;msg | lowercase | capitalize&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此外还有大写过滤器<code>uppercase</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"> var data&#x3D;&#123;msg:&#39;heLLO!&#39;&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h3><p>渲染数据的时候的逻辑表达式<br>v-text v-html v-model v-on v-else</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data&#x3D;&#123;msg:0&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>当msg的值为1的时候才打印Hello!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\">&lt;p v-if&#x3D;&quot;msg&quot;&gt;Hello!&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h3><p>在模板中表达式非常便利，但是它们实际上只用于简单的操作。模板是为了描述视图的结构。在模板中放入太多的逻辑会让模板过重且难以维护。这就是为什么 Vue.js 将绑定表达式限制为一个表达式。如果需要多于一个表达式的逻辑，应当使用计算属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#example&#39;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    a: 1</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 一个计算属性的 getter</span><br><span class=\"line\">    b: function () &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; &#96;this&#96; 指向 vm 实例</span><br><span class=\"line\">      return this.a + 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class=\"line\">  a&#x3D;&#123;&#123; a &#125;&#125;, b&#x3D;&#123;&#123; b &#125;&#125;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">a&#x3D;1, b&#x3D;2</span><br></pre></td></tr></table></figure>"},{"title":"Xcode 添加Target","author":"Arclin","abbrlink":"8cafabb2","date":"2018-02-18T14:08:00.000Z","_content":"在区分开发环境和测试环境或生产环境的时候经常需要在XCode 添加Target, 所以在此记录一下\n\n<!-- more -->\n\n1. Duplicate target\n2. Change DisplayName & Bundle Identifier\n3. A copy-info.plist，默认生成在程序环境根目录，也就是`A.xcodeproj`的同级目录中，如果想放到里层（比如与`A-info.plist`放在同级目录），可以先在Xcode删除`A copy-info.plist`索引，然后拷贝文件到制定目录中，然后更名为`B-info.plist`，在add到project中。在`Project`的`Build Settings`中，修改`Info.plist` File选项为`B-info.plist`的目录（相对路径）,这样就可以看到Info页了（就是B-info.plist），接着修改`ProductName`和`Bundle identifier`，使之成为另一个app。`Prefix Header的路径`，视具体需求而定是否要修改，如果两个target可以公用同一个`Prefix Header`，那么就不需要修改这里的路径\n4. 修改scheme，在调试的Stop按钮边上，我们可以选择本工程中所有的target来做编译，如果不修改，在这里选择出来的名字就是A copy，为了与新建的target统一起来，同样也要修改这里的名字。点击scheme选择区，然后选Manager Scheme，找到A copy，然后改成你需要的名字，比如B\n5. 生成一个新的target，一定会与原target有区别，这里可以定义预编译宏，来区分两个版本的不同代码，预编译宏可以在Build Settings中Preprocessor Macros定义，比如在我们新建的target B中定义预编译宏MACRO，然后在代码中通过\n```\n\t#if defined (MACRO)\n\t//target  B需要执行的代码\n\t#else\n\t//target A需要执行的代码\n\t#endif\n```\n来区分\n6. 其他：Build Phases（各target编译所包含的内容，需要注意的是，如果创建了target B后，再往A里面添加资源或文件，target B中不会自动增加这些资源，需要手动添加）\n\t- Compile Sources\n\t需要编译的代码文件\n\t- Link Binary With Libraries\n\t编译所依赖的库\n\t- Copy Bundle Resources\n\t编译需要的资源\n\t每个target可以根据具体需要增减里面的内容\n","source":"_posts/XCode-添加Target.md","raw":"---\ntitle: Xcode 添加Target\nauthor: Arclin\ntags:\n  - iOS\n  - Xcode\ncategories:\n  - iOS\nabbrlink: 8cafabb2\ndate: 2018-02-18 22:08:00\n---\n在区分开发环境和测试环境或生产环境的时候经常需要在XCode 添加Target, 所以在此记录一下\n\n<!-- more -->\n\n1. Duplicate target\n2. Change DisplayName & Bundle Identifier\n3. A copy-info.plist，默认生成在程序环境根目录，也就是`A.xcodeproj`的同级目录中，如果想放到里层（比如与`A-info.plist`放在同级目录），可以先在Xcode删除`A copy-info.plist`索引，然后拷贝文件到制定目录中，然后更名为`B-info.plist`，在add到project中。在`Project`的`Build Settings`中，修改`Info.plist` File选项为`B-info.plist`的目录（相对路径）,这样就可以看到Info页了（就是B-info.plist），接着修改`ProductName`和`Bundle identifier`，使之成为另一个app。`Prefix Header的路径`，视具体需求而定是否要修改，如果两个target可以公用同一个`Prefix Header`，那么就不需要修改这里的路径\n4. 修改scheme，在调试的Stop按钮边上，我们可以选择本工程中所有的target来做编译，如果不修改，在这里选择出来的名字就是A copy，为了与新建的target统一起来，同样也要修改这里的名字。点击scheme选择区，然后选Manager Scheme，找到A copy，然后改成你需要的名字，比如B\n5. 生成一个新的target，一定会与原target有区别，这里可以定义预编译宏，来区分两个版本的不同代码，预编译宏可以在Build Settings中Preprocessor Macros定义，比如在我们新建的target B中定义预编译宏MACRO，然后在代码中通过\n```\n\t#if defined (MACRO)\n\t//target  B需要执行的代码\n\t#else\n\t//target A需要执行的代码\n\t#endif\n```\n来区分\n6. 其他：Build Phases（各target编译所包含的内容，需要注意的是，如果创建了target B后，再往A里面添加资源或文件，target B中不会自动增加这些资源，需要手动添加）\n\t- Compile Sources\n\t需要编译的代码文件\n\t- Link Binary With Libraries\n\t编译所依赖的库\n\t- Copy Bundle Resources\n\t编译需要的资源\n\t每个target可以根据具体需要增减里面的内容\n","slug":"XCode-添加Target","published":1,"updated":"2021-06-06T18:52:24.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohl002ttnn063cnbrsz","content":"<p>在区分开发环境和测试环境或生产环境的时候经常需要在XCode 添加Target, 所以在此记录一下</p>\n<span id=\"more\"></span>\n\n<ol>\n<li>Duplicate target</li>\n<li>Change DisplayName &amp; Bundle Identifier</li>\n<li>A copy-info.plist，默认生成在程序环境根目录，也就是<code>A.xcodeproj</code>的同级目录中，如果想放到里层（比如与<code>A-info.plist</code>放在同级目录），可以先在Xcode删除<code>A copy-info.plist</code>索引，然后拷贝文件到制定目录中，然后更名为<code>B-info.plist</code>，在add到project中。在<code>Project</code>的<code>Build Settings</code>中，修改<code>Info.plist</code> File选项为<code>B-info.plist</code>的目录（相对路径）,这样就可以看到Info页了（就是B-info.plist），接着修改<code>ProductName</code>和<code>Bundle identifier</code>，使之成为另一个app。<code>Prefix Header的路径</code>，视具体需求而定是否要修改，如果两个target可以公用同一个<code>Prefix Header</code>，那么就不需要修改这里的路径</li>\n<li>修改scheme，在调试的Stop按钮边上，我们可以选择本工程中所有的target来做编译，如果不修改，在这里选择出来的名字就是A copy，为了与新建的target统一起来，同样也要修改这里的名字。点击scheme选择区，然后选Manager Scheme，找到A copy，然后改成你需要的名字，比如B</li>\n<li>生成一个新的target，一定会与原target有区别，这里可以定义预编译宏，来区分两个版本的不同代码，预编译宏可以在Build Settings中Preprocessor Macros定义，比如在我们新建的target B中定义预编译宏MACRO，然后在代码中通过<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if defined (MACRO)</span><br><span class=\"line\">&#x2F;&#x2F;target  B需要执行的代码</span><br><span class=\"line\">#else</span><br><span class=\"line\">&#x2F;&#x2F;target A需要执行的代码</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n来区分</li>\n<li>其他：Build Phases（各target编译所包含的内容，需要注意的是，如果创建了target B后，再往A里面添加资源或文件，target B中不会自动增加这些资源，需要手动添加）<ul>\n<li>Compile Sources<br>需要编译的代码文件</li>\n<li>Link Binary With Libraries<br>编译所依赖的库</li>\n<li>Copy Bundle Resources<br>编译需要的资源<br>每个target可以根据具体需要增减里面的内容</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在区分开发环境和测试环境或生产环境的时候经常需要在XCode 添加Target, 所以在此记录一下</p>","more":"<ol>\n<li>Duplicate target</li>\n<li>Change DisplayName &amp; Bundle Identifier</li>\n<li>A copy-info.plist，默认生成在程序环境根目录，也就是<code>A.xcodeproj</code>的同级目录中，如果想放到里层（比如与<code>A-info.plist</code>放在同级目录），可以先在Xcode删除<code>A copy-info.plist</code>索引，然后拷贝文件到制定目录中，然后更名为<code>B-info.plist</code>，在add到project中。在<code>Project</code>的<code>Build Settings</code>中，修改<code>Info.plist</code> File选项为<code>B-info.plist</code>的目录（相对路径）,这样就可以看到Info页了（就是B-info.plist），接着修改<code>ProductName</code>和<code>Bundle identifier</code>，使之成为另一个app。<code>Prefix Header的路径</code>，视具体需求而定是否要修改，如果两个target可以公用同一个<code>Prefix Header</code>，那么就不需要修改这里的路径</li>\n<li>修改scheme，在调试的Stop按钮边上，我们可以选择本工程中所有的target来做编译，如果不修改，在这里选择出来的名字就是A copy，为了与新建的target统一起来，同样也要修改这里的名字。点击scheme选择区，然后选Manager Scheme，找到A copy，然后改成你需要的名字，比如B</li>\n<li>生成一个新的target，一定会与原target有区别，这里可以定义预编译宏，来区分两个版本的不同代码，预编译宏可以在Build Settings中Preprocessor Macros定义，比如在我们新建的target B中定义预编译宏MACRO，然后在代码中通过<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if defined (MACRO)</span><br><span class=\"line\">&#x2F;&#x2F;target  B需要执行的代码</span><br><span class=\"line\">#else</span><br><span class=\"line\">&#x2F;&#x2F;target A需要执行的代码</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n来区分</li>\n<li>其他：Build Phases（各target编译所包含的内容，需要注意的是，如果创建了target B后，再往A里面添加资源或文件，target B中不会自动增加这些资源，需要手动添加）<ul>\n<li>Compile Sources<br>需要编译的代码文件</li>\n<li>Link Binary With Libraries<br>编译所依赖的库</li>\n<li>Copy Bundle Resources<br>编译需要的资源<br>每个target可以根据具体需要增减里面的内容</li>\n</ul>\n</li>\n</ol>"},{"title":"frp 内网穿透","author":"Arclin","abbrlink":"b72542c2","date":"2018-02-18T14:05:00.000Z","_content":"frp 内网穿透\n\n<!-- more -->\n\n[文档](https://github.com/fatedier/frp/blob/master/README_zh.md)\n\n### 服务器CentOS下载安装\n\n```\nwget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_linux_amd64.tar.gz\ntar -zxvf frp_0.13.0_linux_amd64.tar.gz\ncd frp_0.13.0_linux_amd64.tar.gz\nrm -f frpc\nrm -f frpc.ini\nvi frps.ini\n```\n\n编辑frps.ini\n\n```\n[common]\nvhost_http_port = 8001 # http访问端口\nbind_port = 8009 # 远程响应的地址\ndashboard_port = 8002 #控制面板端口号\n# dashboard 用户名密码，默认都为 admin\ndashboard_user = admin\ndashboard_pwd = admin\n```\n\n### 启动服务端\n\n```\n./frps -c ./frps.ini\n```\n\n### Mac客户端下载\n\n```\nwget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_darwin_amd64.tar.gz\ntar -zxvf frp_0.13.0_darwin_amd64.tar.gz\ncd frp_0.13.0_darwin_amd64.tar.gz\nrm -f frps\nrm -f frps.ini\nvi frpc.ini\n```\n\n编辑frpc.ini\n\n```\n[common]\nserver_addr = 120.78.175.51 # 远程服务器地址\nserver_port = 8009 # 服务端填写的bind_port\n\n[web]\ntype = http \nlocal_port = 3000 # 本地要映射的端口\ncustom_domains = frp.arclin.me # 自定义的域名,需要在dnspod绑定远程主机地址\n```\n\n### 客户端运行\n\n```\n ./frpc -c ./frpc.ini\n```","source":"_posts/frp-内网穿透.md","raw":"---\ntitle: frp 内网穿透\nauthor: Arclin\ntags:\n  - frp\ncategories:\n  - Linux\nabbrlink: b72542c2\ndate: 2018-02-18 22:05:00\n---\nfrp 内网穿透\n\n<!-- more -->\n\n[文档](https://github.com/fatedier/frp/blob/master/README_zh.md)\n\n### 服务器CentOS下载安装\n\n```\nwget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_linux_amd64.tar.gz\ntar -zxvf frp_0.13.0_linux_amd64.tar.gz\ncd frp_0.13.0_linux_amd64.tar.gz\nrm -f frpc\nrm -f frpc.ini\nvi frps.ini\n```\n\n编辑frps.ini\n\n```\n[common]\nvhost_http_port = 8001 # http访问端口\nbind_port = 8009 # 远程响应的地址\ndashboard_port = 8002 #控制面板端口号\n# dashboard 用户名密码，默认都为 admin\ndashboard_user = admin\ndashboard_pwd = admin\n```\n\n### 启动服务端\n\n```\n./frps -c ./frps.ini\n```\n\n### Mac客户端下载\n\n```\nwget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_darwin_amd64.tar.gz\ntar -zxvf frp_0.13.0_darwin_amd64.tar.gz\ncd frp_0.13.0_darwin_amd64.tar.gz\nrm -f frps\nrm -f frps.ini\nvi frpc.ini\n```\n\n编辑frpc.ini\n\n```\n[common]\nserver_addr = 120.78.175.51 # 远程服务器地址\nserver_port = 8009 # 服务端填写的bind_port\n\n[web]\ntype = http \nlocal_port = 3000 # 本地要映射的端口\ncustom_domains = frp.arclin.me # 自定义的域名,需要在dnspod绑定远程主机地址\n```\n\n### 客户端运行\n\n```\n ./frpc -c ./frpc.ini\n```","slug":"frp-内网穿透","published":1,"updated":"2021-06-06T18:52:24.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohl002xtnn06z939abq","content":"<p>frp 内网穿透</p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://github.com/fatedier/frp/blob/master/README_zh.md\">文档</a></p>\n<h3 id=\"服务器CentOS下载安装\"><a href=\"#服务器CentOS下载安装\" class=\"headerlink\" title=\"服务器CentOS下载安装\"></a>服务器CentOS下载安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.13.0&#x2F;frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">tar -zxvf frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">cd frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">rm -f frpc</span><br><span class=\"line\">rm -f frpc.ini</span><br><span class=\"line\">vi frps.ini</span><br></pre></td></tr></table></figure>\n\n<p>编辑frps.ini</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">vhost_http_port &#x3D; 8001 # http访问端口</span><br><span class=\"line\">bind_port &#x3D; 8009 # 远程响应的地址</span><br><span class=\"line\">dashboard_port &#x3D; 8002 #控制面板端口号</span><br><span class=\"line\"># dashboard 用户名密码，默认都为 admin</span><br><span class=\"line\">dashboard_user &#x3D; admin</span><br><span class=\"line\">dashboard_pwd &#x3D; admin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动服务端\"><a href=\"#启动服务端\" class=\"headerlink\" title=\"启动服务端\"></a>启动服务端</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;frps -c .&#x2F;frps.ini</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Mac客户端下载\"><a href=\"#Mac客户端下载\" class=\"headerlink\" title=\"Mac客户端下载\"></a>Mac客户端下载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.13.0&#x2F;frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">tar -zxvf frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">cd frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">rm -f frps</span><br><span class=\"line\">rm -f frps.ini</span><br><span class=\"line\">vi frpc.ini</span><br></pre></td></tr></table></figure>\n\n<p>编辑frpc.ini</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">server_addr &#x3D; 120.78.175.51 # 远程服务器地址</span><br><span class=\"line\">server_port &#x3D; 8009 # 服务端填写的bind_port</span><br><span class=\"line\"></span><br><span class=\"line\">[web]</span><br><span class=\"line\">type &#x3D; http </span><br><span class=\"line\">local_port &#x3D; 3000 # 本地要映射的端口</span><br><span class=\"line\">custom_domains &#x3D; frp.arclin.me # 自定义的域名,需要在dnspod绑定远程主机地址</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"客户端运行\"><a href=\"#客户端运行\" class=\"headerlink\" title=\"客户端运行\"></a>客户端运行</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;frpc -c .&#x2F;frpc.ini</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>frp 内网穿透</p>","more":"<p><a href=\"https://github.com/fatedier/frp/blob/master/README_zh.md\">文档</a></p>\n<h3 id=\"服务器CentOS下载安装\"><a href=\"#服务器CentOS下载安装\" class=\"headerlink\" title=\"服务器CentOS下载安装\"></a>服务器CentOS下载安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.13.0&#x2F;frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">tar -zxvf frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">cd frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">rm -f frpc</span><br><span class=\"line\">rm -f frpc.ini</span><br><span class=\"line\">vi frps.ini</span><br></pre></td></tr></table></figure>\n\n<p>编辑frps.ini</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">vhost_http_port &#x3D; 8001 # http访问端口</span><br><span class=\"line\">bind_port &#x3D; 8009 # 远程响应的地址</span><br><span class=\"line\">dashboard_port &#x3D; 8002 #控制面板端口号</span><br><span class=\"line\"># dashboard 用户名密码，默认都为 admin</span><br><span class=\"line\">dashboard_user &#x3D; admin</span><br><span class=\"line\">dashboard_pwd &#x3D; admin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动服务端\"><a href=\"#启动服务端\" class=\"headerlink\" title=\"启动服务端\"></a>启动服务端</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;frps -c .&#x2F;frps.ini</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Mac客户端下载\"><a href=\"#Mac客户端下载\" class=\"headerlink\" title=\"Mac客户端下载\"></a>Mac客户端下载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.13.0&#x2F;frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">tar -zxvf frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">cd frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">rm -f frps</span><br><span class=\"line\">rm -f frps.ini</span><br><span class=\"line\">vi frpc.ini</span><br></pre></td></tr></table></figure>\n\n<p>编辑frpc.ini</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">server_addr &#x3D; 120.78.175.51 # 远程服务器地址</span><br><span class=\"line\">server_port &#x3D; 8009 # 服务端填写的bind_port</span><br><span class=\"line\"></span><br><span class=\"line\">[web]</span><br><span class=\"line\">type &#x3D; http </span><br><span class=\"line\">local_port &#x3D; 3000 # 本地要映射的端口</span><br><span class=\"line\">custom_domains &#x3D; frp.arclin.me # 自定义的域名,需要在dnspod绑定远程主机地址</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"客户端运行\"><a href=\"#客户端运行\" class=\"headerlink\" title=\"客户端运行\"></a>客户端运行</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;frpc -c .&#x2F;frpc.ini</span><br></pre></td></tr></table></figure>"},{"title":"docker笔记","author":"Arclin","abbrlink":"4417b09c","date":"2018-02-18T14:19:00.000Z","_content":"docker学习笔记\n\n<!-- more -->\n\ndocker是一种类似虚拟机的存在\n\n\n// 查看本机docker信息\n\n`docker info`\n\n// 运行hello world\n\n`docker run centos:6.7 /bin/echo \"Hello World\"`\n\n//  -t 进入伪终端\n//  -i 允许你对容器内的标准输入 (STDIN) 进行交互。 \n\n`docker run -i -t centos:6.7 /bin/bash`\n\n// -d 后台模式\n\n` docker run -d centos:6.7 /bin/sh -c \"while true;do echo hello world; sleep 1; done\"`\n\n//  查看当前运行的容器\n\n`docker ps`\n\n// -l 最近创建的容器\n\n`docker ps -l`\n\n// -a 所有容器\n\n`docker ps -a`\n\n// 查看运行log\n\n`docker logs 2b1b7a428627`\n\n//或\n\n`docker logs angry_austin`\n\n// 具体参数看ps的内容进行替换\n\n// 停止容器\n\n`docker stop angry_austin`\n\n\n// 删除容器\n\n`docker rm awesome_bardeen`\n\n// 进入容器终端 允许标准输入\n\n`docker exec -it practical_fermat /bin/bash`\n\n中间的参数是容器名\n\n// 拉取镜像 (如:httpd)\n\n`docker pull httpd`\n\n// 指定端口运行容器\n\n`docker run -d -p 5000:5001 httpd`\n\n// 提交新的镜像并添加tag v2 \n\n`docker commit -m \"has update\" -a=\"arclin\" 000c5746fa52 arclin/centos:v2`\n\n// 添加标签dev  中间那串是容器id\n\n`docker tag d 607e5fac1115 arclin/centos:dev`\n\n// 删除标签 6.7\n\n`docker rmi -f arclin/centos:6.7`\n\n\n// 指定端口运行  8080 是本地端口 80是容器端口 -d 是后台运行的意思\n\n`docker run -d -p 8080:80 httpd`\n\n// 随机端口运行 -P\n\n`docker run -d -P  httpd`\n\n// 查看容器practical_fermat的80端口被绑定到本机的哪个端口上了\n\n`docker port practical_fermat 80`\n\n// 运行的时候顺便给容器命名\n\n`docker run -d -P --name testName httpd`\n\n// 给容器重命名\n\n`docker rename practical_fermat test_httpd`\n\n// 运行nginx\n```\ndocker run -p 81:80 --name mynginx -v $PWD/www:/www -v \n\n$PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx  \n-p 81:80：将容器的80端口映射到主机的81端口\n--name mynginx：将容器命名为mynginx\n-v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www\n-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf\n-v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs\n```\n\n// 查看nginx的文件系统\n\n`docker inspect mynginx | grep Mounts -A 20`\n\n\n// 安装Apache\n\n`mkdir -p  ~/apache/www ~/apache/logs ~/apache/conf `\n\n// 运行Apache\n\n`docker run -p 80:80 -v $PWD/www/:/usr/local/apache2/htdocs/ -v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf -v $PWD/logs/:/usr/local/apache2/logs/ -d httpd`\n\n\n// 删除所有容器\n\n`sudo docker rm $(docker ps -a -q)`\n\n// 下载容器内的文件\n\n`docker cp ecef8319d2c8:/root/test.txt /root/`\n\n// 上传文件到容器中\n\n`docker cp /root/test.txt ecef8319d2c8:/root/`\n","source":"_posts/docker笔记.md","raw":"---\ntitle: docker笔记\nauthor: Arclin\ntags:\n  - docker\ncategories:\n  - Linux\nabbrlink: 4417b09c\ndate: 2018-02-18 22:19:00\n---\ndocker学习笔记\n\n<!-- more -->\n\ndocker是一种类似虚拟机的存在\n\n\n// 查看本机docker信息\n\n`docker info`\n\n// 运行hello world\n\n`docker run centos:6.7 /bin/echo \"Hello World\"`\n\n//  -t 进入伪终端\n//  -i 允许你对容器内的标准输入 (STDIN) 进行交互。 \n\n`docker run -i -t centos:6.7 /bin/bash`\n\n// -d 后台模式\n\n` docker run -d centos:6.7 /bin/sh -c \"while true;do echo hello world; sleep 1; done\"`\n\n//  查看当前运行的容器\n\n`docker ps`\n\n// -l 最近创建的容器\n\n`docker ps -l`\n\n// -a 所有容器\n\n`docker ps -a`\n\n// 查看运行log\n\n`docker logs 2b1b7a428627`\n\n//或\n\n`docker logs angry_austin`\n\n// 具体参数看ps的内容进行替换\n\n// 停止容器\n\n`docker stop angry_austin`\n\n\n// 删除容器\n\n`docker rm awesome_bardeen`\n\n// 进入容器终端 允许标准输入\n\n`docker exec -it practical_fermat /bin/bash`\n\n中间的参数是容器名\n\n// 拉取镜像 (如:httpd)\n\n`docker pull httpd`\n\n// 指定端口运行容器\n\n`docker run -d -p 5000:5001 httpd`\n\n// 提交新的镜像并添加tag v2 \n\n`docker commit -m \"has update\" -a=\"arclin\" 000c5746fa52 arclin/centos:v2`\n\n// 添加标签dev  中间那串是容器id\n\n`docker tag d 607e5fac1115 arclin/centos:dev`\n\n// 删除标签 6.7\n\n`docker rmi -f arclin/centos:6.7`\n\n\n// 指定端口运行  8080 是本地端口 80是容器端口 -d 是后台运行的意思\n\n`docker run -d -p 8080:80 httpd`\n\n// 随机端口运行 -P\n\n`docker run -d -P  httpd`\n\n// 查看容器practical_fermat的80端口被绑定到本机的哪个端口上了\n\n`docker port practical_fermat 80`\n\n// 运行的时候顺便给容器命名\n\n`docker run -d -P --name testName httpd`\n\n// 给容器重命名\n\n`docker rename practical_fermat test_httpd`\n\n// 运行nginx\n```\ndocker run -p 81:80 --name mynginx -v $PWD/www:/www -v \n\n$PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx  \n-p 81:80：将容器的80端口映射到主机的81端口\n--name mynginx：将容器命名为mynginx\n-v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www\n-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf\n-v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs\n```\n\n// 查看nginx的文件系统\n\n`docker inspect mynginx | grep Mounts -A 20`\n\n\n// 安装Apache\n\n`mkdir -p  ~/apache/www ~/apache/logs ~/apache/conf `\n\n// 运行Apache\n\n`docker run -p 80:80 -v $PWD/www/:/usr/local/apache2/htdocs/ -v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf -v $PWD/logs/:/usr/local/apache2/logs/ -d httpd`\n\n\n// 删除所有容器\n\n`sudo docker rm $(docker ps -a -q)`\n\n// 下载容器内的文件\n\n`docker cp ecef8319d2c8:/root/test.txt /root/`\n\n// 上传文件到容器中\n\n`docker cp /root/test.txt ecef8319d2c8:/root/`\n","slug":"docker笔记","published":1,"updated":"2021-06-06T18:52:24.961Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohm0031tnn02d03708i","content":"<p>docker学习笔记</p>\n<span id=\"more\"></span>\n\n<p>docker是一种类似虚拟机的存在</p>\n<p>// 查看本机docker信息</p>\n<p><code>docker info</code></p>\n<p>// 运行hello world</p>\n<p><code>docker run centos:6.7 /bin/echo &quot;Hello World&quot;</code></p>\n<p>//  -t 进入伪终端<br>//  -i 允许你对容器内的标准输入 (STDIN) 进行交互。 </p>\n<p><code>docker run -i -t centos:6.7 /bin/bash</code></p>\n<p>// -d 后台模式</p>\n<p><code> docker run -d centos:6.7 /bin/sh -c &quot;while true;do echo hello world; sleep 1; done&quot;</code></p>\n<p>//  查看当前运行的容器</p>\n<p><code>docker ps</code></p>\n<p>// -l 最近创建的容器</p>\n<p><code>docker ps -l</code></p>\n<p>// -a 所有容器</p>\n<p><code>docker ps -a</code></p>\n<p>// 查看运行log</p>\n<p><code>docker logs 2b1b7a428627</code></p>\n<p>//或</p>\n<p><code>docker logs angry_austin</code></p>\n<p>// 具体参数看ps的内容进行替换</p>\n<p>// 停止容器</p>\n<p><code>docker stop angry_austin</code></p>\n<p>// 删除容器</p>\n<p><code>docker rm awesome_bardeen</code></p>\n<p>// 进入容器终端 允许标准输入</p>\n<p><code>docker exec -it practical_fermat /bin/bash</code></p>\n<p>中间的参数是容器名</p>\n<p>// 拉取镜像 (如:httpd)</p>\n<p><code>docker pull httpd</code></p>\n<p>// 指定端口运行容器</p>\n<p><code>docker run -d -p 5000:5001 httpd</code></p>\n<p>// 提交新的镜像并添加tag v2 </p>\n<p><code>docker commit -m &quot;has update&quot; -a=&quot;arclin&quot; 000c5746fa52 arclin/centos:v2</code></p>\n<p>// 添加标签dev  中间那串是容器id</p>\n<p><code>docker tag d 607e5fac1115 arclin/centos:dev</code></p>\n<p>// 删除标签 6.7</p>\n<p><code>docker rmi -f arclin/centos:6.7</code></p>\n<p>// 指定端口运行  8080 是本地端口 80是容器端口 -d 是后台运行的意思</p>\n<p><code>docker run -d -p 8080:80 httpd</code></p>\n<p>// 随机端口运行 -P</p>\n<p><code>docker run -d -P  httpd</code></p>\n<p>// 查看容器practical_fermat的80端口被绑定到本机的哪个端口上了</p>\n<p><code>docker port practical_fermat 80</code></p>\n<p>// 运行的时候顺便给容器命名</p>\n<p><code>docker run -d -P --name testName httpd</code></p>\n<p>// 给容器重命名</p>\n<p><code>docker rename practical_fermat test_httpd</code></p>\n<p>// 运行nginx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p 81:80 --name mynginx -v $PWD&#x2F;www:&#x2F;www -v </span><br><span class=\"line\"></span><br><span class=\"line\">$PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf -v $PWD&#x2F;logs:&#x2F;wwwlogs  -d nginx  </span><br><span class=\"line\">-p 81:80：将容器的80端口映射到主机的81端口</span><br><span class=\"line\">--name mynginx：将容器命名为mynginx</span><br><span class=\"line\">-v $PWD&#x2F;www:&#x2F;www：将主机中当前目录下的www挂载到容器的&#x2F;www</span><br><span class=\"line\">-v $PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class=\"line\">-v $PWD&#x2F;logs:&#x2F;wwwlogs：将主机中当前目录下的logs挂载到容器的&#x2F;wwwlogs</span><br></pre></td></tr></table></figure>\n\n<p>// 查看nginx的文件系统</p>\n<p><code>docker inspect mynginx | grep Mounts -A 20</code></p>\n<p>// 安装Apache</p>\n<p><code>mkdir -p  ~/apache/www ~/apache/logs ~/apache/conf </code></p>\n<p>// 运行Apache</p>\n<p><code>docker run -p 80:80 -v $PWD/www/:/usr/local/apache2/htdocs/ -v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf -v $PWD/logs/:/usr/local/apache2/logs/ -d httpd</code></p>\n<p>// 删除所有容器</p>\n<p><code>sudo docker rm $(docker ps -a -q)</code></p>\n<p>// 下载容器内的文件</p>\n<p><code>docker cp ecef8319d2c8:/root/test.txt /root/</code></p>\n<p>// 上传文件到容器中</p>\n<p><code>docker cp /root/test.txt ecef8319d2c8:/root/</code></p>\n","site":{"data":{}},"excerpt":"<p>docker学习笔记</p>","more":"<p>docker是一种类似虚拟机的存在</p>\n<p>// 查看本机docker信息</p>\n<p><code>docker info</code></p>\n<p>// 运行hello world</p>\n<p><code>docker run centos:6.7 /bin/echo &quot;Hello World&quot;</code></p>\n<p>//  -t 进入伪终端<br>//  -i 允许你对容器内的标准输入 (STDIN) 进行交互。 </p>\n<p><code>docker run -i -t centos:6.7 /bin/bash</code></p>\n<p>// -d 后台模式</p>\n<p><code> docker run -d centos:6.7 /bin/sh -c &quot;while true;do echo hello world; sleep 1; done&quot;</code></p>\n<p>//  查看当前运行的容器</p>\n<p><code>docker ps</code></p>\n<p>// -l 最近创建的容器</p>\n<p><code>docker ps -l</code></p>\n<p>// -a 所有容器</p>\n<p><code>docker ps -a</code></p>\n<p>// 查看运行log</p>\n<p><code>docker logs 2b1b7a428627</code></p>\n<p>//或</p>\n<p><code>docker logs angry_austin</code></p>\n<p>// 具体参数看ps的内容进行替换</p>\n<p>// 停止容器</p>\n<p><code>docker stop angry_austin</code></p>\n<p>// 删除容器</p>\n<p><code>docker rm awesome_bardeen</code></p>\n<p>// 进入容器终端 允许标准输入</p>\n<p><code>docker exec -it practical_fermat /bin/bash</code></p>\n<p>中间的参数是容器名</p>\n<p>// 拉取镜像 (如:httpd)</p>\n<p><code>docker pull httpd</code></p>\n<p>// 指定端口运行容器</p>\n<p><code>docker run -d -p 5000:5001 httpd</code></p>\n<p>// 提交新的镜像并添加tag v2 </p>\n<p><code>docker commit -m &quot;has update&quot; -a=&quot;arclin&quot; 000c5746fa52 arclin/centos:v2</code></p>\n<p>// 添加标签dev  中间那串是容器id</p>\n<p><code>docker tag d 607e5fac1115 arclin/centos:dev</code></p>\n<p>// 删除标签 6.7</p>\n<p><code>docker rmi -f arclin/centos:6.7</code></p>\n<p>// 指定端口运行  8080 是本地端口 80是容器端口 -d 是后台运行的意思</p>\n<p><code>docker run -d -p 8080:80 httpd</code></p>\n<p>// 随机端口运行 -P</p>\n<p><code>docker run -d -P  httpd</code></p>\n<p>// 查看容器practical_fermat的80端口被绑定到本机的哪个端口上了</p>\n<p><code>docker port practical_fermat 80</code></p>\n<p>// 运行的时候顺便给容器命名</p>\n<p><code>docker run -d -P --name testName httpd</code></p>\n<p>// 给容器重命名</p>\n<p><code>docker rename practical_fermat test_httpd</code></p>\n<p>// 运行nginx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p 81:80 --name mynginx -v $PWD&#x2F;www:&#x2F;www -v </span><br><span class=\"line\"></span><br><span class=\"line\">$PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf -v $PWD&#x2F;logs:&#x2F;wwwlogs  -d nginx  </span><br><span class=\"line\">-p 81:80：将容器的80端口映射到主机的81端口</span><br><span class=\"line\">--name mynginx：将容器命名为mynginx</span><br><span class=\"line\">-v $PWD&#x2F;www:&#x2F;www：将主机中当前目录下的www挂载到容器的&#x2F;www</span><br><span class=\"line\">-v $PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class=\"line\">-v $PWD&#x2F;logs:&#x2F;wwwlogs：将主机中当前目录下的logs挂载到容器的&#x2F;wwwlogs</span><br></pre></td></tr></table></figure>\n\n<p>// 查看nginx的文件系统</p>\n<p><code>docker inspect mynginx | grep Mounts -A 20</code></p>\n<p>// 安装Apache</p>\n<p><code>mkdir -p  ~/apache/www ~/apache/logs ~/apache/conf </code></p>\n<p>// 运行Apache</p>\n<p><code>docker run -p 80:80 -v $PWD/www/:/usr/local/apache2/htdocs/ -v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf -v $PWD/logs/:/usr/local/apache2/logs/ -d httpd</code></p>\n<p>// 删除所有容器</p>\n<p><code>sudo docker rm $(docker ps -a -q)</code></p>\n<p>// 下载容器内的文件</p>\n<p><code>docker cp ecef8319d2c8:/root/test.txt /root/</code></p>\n<p>// 上传文件到容器中</p>\n<p><code>docker cp /root/test.txt ecef8319d2c8:/root/</code></p>"},{"title":"iOS 底层原理 --- Block、__block及其底层实现","author":"Arclin","abbrlink":"8275b854","date":"2021-06-07T15:50:00.000Z","_content":"本文主要简述Block、__block的本质是什么东西，文章涉及循环引用等开发常见问题，需要重点关注。\n\n<!--more-->\n\n\n## 先写一个最简单的block\n\n```\nvoid(^block)(void) = ^{\n    NSLog(@\"Block\");\n};\n\nblock();\n```\n\n使用命令行将`main.m`文件编译成C++文件<br/>\n`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m `\n\n编译完成后，上述代码会变成以下结构\n\n```\nvoid(*block)(void) = &__main_block_impl_0(__main_block_func_0, &__main_block_desc_0_DATA));\n\n((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n```\n\n可以看出是生成了一个`__main_block_impl_0`结构体类型的对象，参数1为`__main_block_func_0`，参数2为`&__main_block_desc_0_DATA`\n\n\n## block的底层结构\n\n接下来查看一下`__main_block_impl_0`是什么东西\n\n```\n/// block的结构体，引用了两个结构体和实现了一个构造方法\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n\n/// block的结构体引用的第一个结构体\nstruct __block_impl {\n  void *isa;\n  int Flags;\n  int Reserved;\n  void *FuncPtr;\n};\n\n/// block的结构体引用的第二个结构体，第一个参数赋值了0，第二个参数赋值了__main_block_impl_0的结构体大小\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n```\n\n所以拼接一下可以看出\n\n```\nstruct __main_block_impl_0 {\n  void *isa;\n  int Flags;\n  int Reserved;\n  void *FuncPtr;\n  size_t reserved;\n  size_t Block_size;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n}\n```\n\n- ***结论1：block本质上是一个OC对象，它内部也有个isa指针***\n\n接下来看看构造方法，第一个参数是`void *fp`意为`function pointer`函数指针，所以我们回去看看这里传了什么值进去\n```\nvoid(*block)(void) = &__main_block_impl_0(__main_block_func_0, &__main_block_desc_0_DATA));\n```\n\n是`__main_block_func_0`，那我们再看看`__main_block_func_0`是什么\n\n```\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n\tNSLog((NSString *)&__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_34b858_mi_0);\n}\n\n```\n\n可以看出我们在block内写的代码被封装成了一个函数\n\n- ***结论2：block是封装了函数调用以及函数调用环境的OC对象***\n\n最后，看一下block的调用，被编译成了下述结构（这里我们去掉强制转换）\n```\n(block)->FuncPtr(block);\n```\n\n可以看出，是取出了变量中的`FuncPtr`成员变量，得到函数指针后把自己传进去，这样子就完成了block的调用\n\n## block捕获外部变量\n\n从上面的分析我们可以得知，局部变量的定义和使用，是在两个函数中进行的，所以为了能够给让变量跨函数访问，block需要捕获该变量 \n\n### 局部auto类型的变量捕获\n\n**auto ： 自动变量，离开作用域自动销毁**\n\n平常我们定义的局部变量，默认都是`auto`修饰的\n\n先写一个简单的demo\n\n```\nint age = 10; // 等价于 auto int age = 10;\nvoid(^block)(void) = ^{\n    NSLog(@\"Block %d\",age);\n};\n```\n\n编译后变成如下结构(去掉强制转换)\n\n```\nint age = 10;\nvoid(*block)(void) = &__main_block_impl_0(__main_block_func_0, &__main_block_desc_0_DATA, age));\n```\n\n`__main_block_impl_0`也发生了变化，可以看到多了一个`age`成员变量，所以构造函数也多了一个参数\n\n```\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  int age;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n```\n\n`age(_age)`这个语法意为将构造方法传进来的`_age`赋值到自己的的成员变量`age`，这个过程我们称作变量的**捕获**\n\nblock内编译后的函数`__main_block_func_0`也发生了变化\n\n```\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  int age = __cself->age; // bound by copy\n   NSLog((NSString *)&__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_5fd8ec_mi_0,age);\n}\n```\n\n可以看出函数内取出了结构体内的`age`成员变量，然后交给`NSLog`使用\n\n\n由此可知，block在定义的时候就会把外部传进来的参数给存储一遍，然后调用的时候在从block对象中取出来，所以这就意味着**被block捕获的变量，在被捕获后如果修改了值，是不会应用到block中的**，举例如下\n\n```\nint age = 10;\nvoid(^block)(void) = ^{\n    NSLog(@\"age = %d\",age);\n};\nage = 20;\nblock(); // 调用这个方法只会输出age = 10，因为age被捕获时是10，所以后面就算改了值也没用\n```\n\n### 局部static类型的变量捕获\n\n把上面的`age`变量加一个`static`修饰符试试看\n\n```\nstatic int age = 10;\nvoid(^block)(void) = ^{\n    NSLog(@\"age = %d\",age);\n};\nage = 20;\nblock();\n```\n\n结果会输出`age = 20`，原因是静态变量会将`static`修饰的对象转为block的指针类型的成员属性，如下\n\n```\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  int *age;\n  ...\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  int *age = __cself->age; // bound by copy\n  NSLog((NSString *)&__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_bb86ee_mi_0,(*age));\n}\n```\n\n因为是指针传递，所以当指针指向的内容变化时，打印出来的值也就会变化了\n\n### 全局变量不捕获\n\n全局`static`变量不捕获，因为全局`static`变量大家都能访问，所以函数内可以直接读取值\n\n### block内的self会被捕获吗\n\n会，我们来举个例子\n\n```\n- (void)test {\n\tvoid(^block)(void) = ^{\n    \tNSLog(@\"%@\",self); \n    };\n    block();\n}\n```\n\n因为`test`方法会添加两个隐含的参数，编译后如下\n\n```\nstatic void _I_Person_Test(Person *self, SEL _cmd) {\n\t...\n}\n```\n\n所以这就是为什么我们能在方法内访问`self`和`_cmd`的原因，因为方法会传进来`self`参数，又因为参数是局部变量，又因为局部变量会被捕获，所以`self`参数会被捕获，捕获后大概长这样子\n\n```\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  Person *self;\n  ...\n};\n```\n\n## Block的类型\n\n\nBlock有三种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型\n\n|存储区域|类名|特点|调用copy后的效果|\n|---|---|---|---|\n|数据区域 .data区|`__NSGlobalBlock__`|没有访问auto变量|无效果|\n|栈区|`__NSStackBlock__`|访问了auto变量|从栈复制到堆|\n|堆区|`__NSMallocBlock__`|`__NSStackBlock__`调用了copy|引用计数增加|\n\n### `__NSGlobalBlock__`\n\n```\nvoid(^block)(void) = ^{\n    NSLog(@\"Hello world\");\n};\n```\n\n### `__NSStackBlock__`\n\n```\nint age = 20;\nvoid(^block)(void) = ^{\n   NSLog(@\"Block %d\",age);\n};\n```\n\n因为在ARC环境下，栈区block会自动copy，所以要测试这个类型的时候，需要使用MRC环境\n\n**栈区数据的特点是会自动销毁，离开了作用域，数据都会销毁**\n\n**栈区block存在的问题是，捕获的变量会存放在栈区，所以一旦离开了作用域，捕获的内容就销毁了，将来再去访问这个block内捕获的变量，访问到的可能就是一个未知的内容**\n\n以下情况编译器会自动将栈上的block复制到堆上：\n1. block作为函数返回值时，比如\n\t```\n    typedef void(^Block)(void);\n    Block myBlock() {\n    \tint age = 10\n        return ^{\n        \tNSLog(@\"---------%d\",age);\n        };\n    }\n    ```\n2. 将block赋值给__strong指针时\n\t- __strong是是id类型和对象类型默认的所有权修饰符，所以平时在ARC环境下写的引用外部auto局部变量的block都会自动copy到堆中，原因是block默认被__strong修饰了\n3. block作为Cocoa API中方法名含有usingBlock的方法参数时\n\t- 比如NSArray的`enumerateObjectsUsingBlock:`方法，block传进去之后就会被copy一下\n4. block作为GCD API的方法参数时\n\t- 比如GCD的`dispatch_after(dispatch_time_t when, dispatch_queue_t queue,\n\t\tdispatch_block_t block);`方法，block传进去之后就会被copy一下\n\n\n### `__NSMallocBlock__`\n\n将`__NSStackBlock__`进行一次copy，即可得到`__NSMallocBlock__`\n\n```\nint age = 20;\nvoid(^block)(void) = [^{\n   NSLog(@\"Block %d\",age);\n} copy];\n```\n\n\n## 捕获对象类型的auto变量\n\n当block内部访问了对象类型的auto变量时，如下\n\n```\nPerson *person = [[Person alloc] init];\nvoid(^block)(void) = ^{\n    NSLog(@\"Person %@\",person);\n};\nblock();\n```\n我们在ARC环境下编译，这时候block会在堆上（因为被自动copy了），执行命令行`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m`，会发现block结构体的person属性多了一个`__strong`的修饰符，证明他被block强持有了。\n\n```\nstruct __main_block_impl_0 {\n  ...\n  Person *__strong person;\n  ...\n}\n```\n\n但是我们如果编译的时候去掉`-fobjc-arc`，默认就是MRC环境了，这时候block会在栈上，查看编译后的c++文件发现不会有`__strong`修饰符，如果我们在block执行前加一行`[person release]`，那么这时候`person`就会直接释放，证明block没有持有`person变量`\n\n- 结论1：如果block是在栈上，将不会对auto变量产生强引用\n    \n如果我们给person添加`__weak`修饰符\n\n```\n__weak Person *person = [[Person alloc] init];\nvoid(^block)(void) = ^{\n    NSLog(@\"Person %@\",person);\n};\nblock();\n```\n\n则block将会对person对象进行弱引用，编译后如下：\n\n```\nstruct __main_block_impl_0 {\n  ...\n  Person *__weak person;\n  ...\n}\n```\n\n所以使用`__weak`修饰符可以避免block对外部变量的强引用操作\n\n我们来看看block的结构体内的`__main_block_desc_0`是个什么东西\n\n```\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n  void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};\n```\n\n可以发现，多了两个函数指针，`copy`和`dispose`，分别指向`__main_block_copy_0`和`__main_block_dispose_0`\n\n这两个函数的实现如下\n\n```\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {\n\t_Block_object_assign((void*)&dst->person, (void*)src->person, 3/*BLOCK_FIELD_IS_OBJECT*/);\n}\n\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {\n\t_Block_object_dispose((void*)src->person, 3/*BLOCK_FIELD_IS_OBJECT*/);\n}\n```\n\n`_Block_object_assign`函数内部会对person进行引用计数器的操作，如果`__main_block_impl_0`结构体内person指针是`__strong`类型，则为强引用，引用计数+1，如果`__main_block_impl_0`结构体内person指针是`__weak`类型，则为弱引用，引用计数不变。\n\n`_Block_object_dispose`会对person对象做释放操作，类似于release，也就是断开对person对象的引用，而person究竟是否被释放还是取决于person对象自己的引用计数\n\n\n- 结论2：如果block被拷贝到堆上\n\t- 会调用block内部的copy函数\n    - copy函数内部会调用_Block_object_assign函数\n    - _Block_object_assign函数会根据auto变量的修饰符（`__strong`，`__weak`，`__unsafe_unretained`）做出相应的操作，类似于retain(形成强引用、弱引用)\n    \n\t> __unsafe_unretained修饰的变量不会增加引用计数，当销毁时，该指针不会置空，会造成不安全的情况。\n    \n- 结论3：如果block从堆上移除\n\t- 会调用block内部的dispose函数\n    - dispose函数内部会调用_Block_object_assign函数\n    - _Block_object_dispose函数会自动释放引用的auto变量，类似于release\n    \n|函数|调用时机|\n|---|---|\n|copy函数|栈上的Block复制到堆时|\n|dispose函数|堆上的Block被废弃时|\n\n\n## __block\n\n一般情况下我们是无法改变block捕获的外部的值的\n\n```\nPerson *person = [[Person alloc] init];\nvoid(^block)(void) = ^{\n\tperson = nil;  /// 这种情况是会编译失败的\n};\nblock();\n```\n\n从上面的内容我们也可以知道原因。就是因为外部的person所在的内存空间和block内（单独开辟了一个函数）的内存空间不在同一个位置，所以block内是访问不到的外部的person的。\n\n但是我们如果添加了`__block`关键字的话，就可以访问了，所以我们编译一下看看添加`__block`之后的情况\n\n```\n__block Person *person = [[Person alloc] init];\nvoid(^block)(void) = ^{\n\tperson = nil;  // 编译成功\n};\nblock();\n```\n\n编译后长这样\n\n```\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __Block_byref_person_0 *person; // by ref\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_person_0 *_person, int flags=0) : person(_person->__forwarding) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n```\n\n可以看到person对象被封装成了一个`__Block_byref_person_0 *`类型的属性\n\n继续看看`__Block_byref_person_0`是什么\n\n```\nstruct __Block_byref_person_0 {\n  void *__isa;\n__Block_byref_person_0 *__forwarding;\n int __flags;\n int __size;\n void (*__Block_byref_id_object_copy)(void*, void*);\n void (*__Block_byref_id_object_dispose)(void*);\n Person *__strong person;\n};\n```\n\n`__Block_byref_person_0`有isa指针，是一个OC对象，里面有一个强引用的person对象（指向的内容等同于外面的person指针指向的内容），和我们熟悉的`__Block_byref_id_object_copy`和`__Block_byref_id_object_dispose`方法用于处理内存管理问题，还有指向自身的`forwarding`指针（这个指针指向对象自身），`flag`和`size`，分别表示标记位和这个结构体的占用内存空间大小。\n\nperson被封装成了结构体对象之后，原先的block函数就变成了\n\n```\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n\t__Block_byref_person_0 *person = __cself->person; // bound by ref\n\t(person->__forwarding->person) = __null;\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_250618_mi_0,(person->__forwarding->person));\n}\n```\n\n可以看出，但我们要改变person指针的值的时候，首先是取出person对象，即`__Block_byref_person_0 *person`，然后再通过`forwarding`指针拿到自己，再拿到最里面的person，最后就可以修改了。\n\n1. 通过内存打印，我们可以得知`__Block_byref_person_0`内的person对象和外部的person对象的地址是一致的，所以我们在block内修改外部的person就是相当于修改`__Block_byref_person_0`内的person对象\n2. 为什么要绕一个圈，不直接`person->person`而是要`person->__forwarding->person`？原因是防止block从栈复制到堆之后，栈上面的block访问person访问到的是栈上的person而不是堆上的person，所以栈上的forwarding指针要指向堆的block，这样子就能一直访问到堆上的person了\n\n3. 封装的`__Block_byref_person_0`结构体内的`__Block_byref_id_object_copy`函数会管理他自己的person对象的内存，实现代码如下:\n\t`_Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);`，这里的40是person对象的偏移值，可以看到结构体内person前面的4个指针加2个整型刚好40个字节。\n4. `__Block_byref_person_0`在`__main_block_impl_0`内必定是强引用，跟我们上面所说的不一样，就算在`__block`之前再添加`__weak`修饰，`__Block_byref_person_0`在`__main_block_impl_0`内依旧是强引用，加上`__weak`修饰受影响的只有`__Block_byref_person_0`内的person指针的引用方式\n\n> 注意：MRC环境下，__block 不会对变量造成强引用，即以下情况person会提前释放\n  \n  ```\n  __block Person *person = [Person new];\n  void(^block)(void) = ^{\n      NSLog(@\"%@\",person);\n  };\n  block(); /// 这时候person已经释放了\n  ```\n\n> 注意：__block只能用于修饰auto变量，不能修饰全局变量和静态（static）变量\n\n## 循环引用\n\n### 循环引用的发生原因与解决方式\n\n- 以下代码会产生循环引用\n\t\n    ```\n    @interface Person : NSObject\n\t    @property (nonatomic, copy) void(^block)(void);\n    @end\n    ```\n\t```\n\tPerson *person = [Person alloc] init];\n\tperson.age = 10;\n\tperson.block = ^{\n\t\tNSLog(@\"age is %d\",person.age);\n\t};\n\t```\n    \n    原因是person.block捕获了person，person又持有着block，也就是block内部对person存在一个强引用，person对block也存在一个强引用，所以均无法释放。\n    \n- 在定义person指针的时候添加`__weak`修饰符或者`__unsafe_unretain`修饰符，就可以让block在捕获person的时候弱引用person，这样子就不会造成循环引用了.\n\n\t<img src=\"https://z3.ax1x.com/2021/06/13/2I2lPU.png\" alt=\"2I2lPU.png\" border=\"0\" width=\"50%\" />\n    \n  > __weak: 不会产生强引用，指向的对象销毁时，会自动让指针至nil，不支持MRC\n   \n  > __unsafe_unretain: 不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变，变成野指针，支持MRC\n\n- 在定义person指针的时候添加`__block`修饰符也可以解决循环引用问题，但前提是需要调用block并手动将person指针置为nil，如下\n\t```\n\t__block Person *person = [Person alloc] init];\n\tperson.age = 10;\n\tperson.block = ^{\n\t\tNSLog(@\"age is %d\",person.age);\n        person = nil;\n\t};\n    person.block();\n    ```\n\t为什么这样子可以解决循环引用呢?首先先分析一下内存结构\n    \n    - peron持有block\n    - block持有__block对象\n    - __block持有着person\n    - peron又持有着block\n    - ...\n   \n    所以这里是三个对象相互持有形成一个三角形关系\n    <img src=\"https://z3.ax1x.com/2021/06/13/2IcLXn.png\" alt=\"2IcLXn.png\" border=\"0\" width=\"30%\"/>\n    \n    当block执行，person = nil，解除了`__block`变量对person的引用的时候，循环引用就不再存在了\n    \n    <img src=\"https://z3.ax1x.com/2021/06/13/2IgCp4.png\" alt=\"2IgCp4.png\" border=\"0\" width=\"30%\"/>\n\n\t- MRC环境下，由于**__block不会对变量造成强引用**，所以直接用__block修饰指针也可以达到以上效果\n\n### 为什么block做属性不常用weak而是用copy\n\n如果上述例子使用weak修饰block的话，那么block会在栈中，block里面的person也会在栈中，所以离开了作用域的话，里面的person就会销毁，从而无法使用。\n\n如果你希望block做完事情就释放，比如发送一个通知，修改某个单例类的属性，没有引用外部局部变量，那么用weak就可以节约内存空间","source":"_posts/iOS-底层原理-Block、-block及其底层实现.md","raw":"title: iOS 底层原理 --- Block、__block及其底层实现\nauthor: Arclin\nabbrlink: 8275b854\ntags:\n  - iOS\n  - 底层原理\ncategories:\n  - iOS\ndate: 2021-06-07 23:50:00\n---\n本文主要简述Block、__block的本质是什么东西，文章涉及循环引用等开发常见问题，需要重点关注。\n\n<!--more-->\n\n\n## 先写一个最简单的block\n\n```\nvoid(^block)(void) = ^{\n    NSLog(@\"Block\");\n};\n\nblock();\n```\n\n使用命令行将`main.m`文件编译成C++文件<br/>\n`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m `\n\n编译完成后，上述代码会变成以下结构\n\n```\nvoid(*block)(void) = &__main_block_impl_0(__main_block_func_0, &__main_block_desc_0_DATA));\n\n((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);\n```\n\n可以看出是生成了一个`__main_block_impl_0`结构体类型的对象，参数1为`__main_block_func_0`，参数2为`&__main_block_desc_0_DATA`\n\n\n## block的底层结构\n\n接下来查看一下`__main_block_impl_0`是什么东西\n\n```\n/// block的结构体，引用了两个结构体和实现了一个构造方法\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n\n/// block的结构体引用的第一个结构体\nstruct __block_impl {\n  void *isa;\n  int Flags;\n  int Reserved;\n  void *FuncPtr;\n};\n\n/// block的结构体引用的第二个结构体，第一个参数赋值了0，第二个参数赋值了__main_block_impl_0的结构体大小\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n```\n\n所以拼接一下可以看出\n\n```\nstruct __main_block_impl_0 {\n  void *isa;\n  int Flags;\n  int Reserved;\n  void *FuncPtr;\n  size_t reserved;\n  size_t Block_size;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n}\n```\n\n- ***结论1：block本质上是一个OC对象，它内部也有个isa指针***\n\n接下来看看构造方法，第一个参数是`void *fp`意为`function pointer`函数指针，所以我们回去看看这里传了什么值进去\n```\nvoid(*block)(void) = &__main_block_impl_0(__main_block_func_0, &__main_block_desc_0_DATA));\n```\n\n是`__main_block_func_0`，那我们再看看`__main_block_func_0`是什么\n\n```\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n\tNSLog((NSString *)&__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_34b858_mi_0);\n}\n\n```\n\n可以看出我们在block内写的代码被封装成了一个函数\n\n- ***结论2：block是封装了函数调用以及函数调用环境的OC对象***\n\n最后，看一下block的调用，被编译成了下述结构（这里我们去掉强制转换）\n```\n(block)->FuncPtr(block);\n```\n\n可以看出，是取出了变量中的`FuncPtr`成员变量，得到函数指针后把自己传进去，这样子就完成了block的调用\n\n## block捕获外部变量\n\n从上面的分析我们可以得知，局部变量的定义和使用，是在两个函数中进行的，所以为了能够给让变量跨函数访问，block需要捕获该变量 \n\n### 局部auto类型的变量捕获\n\n**auto ： 自动变量，离开作用域自动销毁**\n\n平常我们定义的局部变量，默认都是`auto`修饰的\n\n先写一个简单的demo\n\n```\nint age = 10; // 等价于 auto int age = 10;\nvoid(^block)(void) = ^{\n    NSLog(@\"Block %d\",age);\n};\n```\n\n编译后变成如下结构(去掉强制转换)\n\n```\nint age = 10;\nvoid(*block)(void) = &__main_block_impl_0(__main_block_func_0, &__main_block_desc_0_DATA, age));\n```\n\n`__main_block_impl_0`也发生了变化，可以看到多了一个`age`成员变量，所以构造函数也多了一个参数\n\n```\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  int age;\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n```\n\n`age(_age)`这个语法意为将构造方法传进来的`_age`赋值到自己的的成员变量`age`，这个过程我们称作变量的**捕获**\n\nblock内编译后的函数`__main_block_func_0`也发生了变化\n\n```\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  int age = __cself->age; // bound by copy\n   NSLog((NSString *)&__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_5fd8ec_mi_0,age);\n}\n```\n\n可以看出函数内取出了结构体内的`age`成员变量，然后交给`NSLog`使用\n\n\n由此可知，block在定义的时候就会把外部传进来的参数给存储一遍，然后调用的时候在从block对象中取出来，所以这就意味着**被block捕获的变量，在被捕获后如果修改了值，是不会应用到block中的**，举例如下\n\n```\nint age = 10;\nvoid(^block)(void) = ^{\n    NSLog(@\"age = %d\",age);\n};\nage = 20;\nblock(); // 调用这个方法只会输出age = 10，因为age被捕获时是10，所以后面就算改了值也没用\n```\n\n### 局部static类型的变量捕获\n\n把上面的`age`变量加一个`static`修饰符试试看\n\n```\nstatic int age = 10;\nvoid(^block)(void) = ^{\n    NSLog(@\"age = %d\",age);\n};\nage = 20;\nblock();\n```\n\n结果会输出`age = 20`，原因是静态变量会将`static`修饰的对象转为block的指针类型的成员属性，如下\n\n```\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  int *age;\n  ...\n};\n\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n  int *age = __cself->age; // bound by copy\n  NSLog((NSString *)&__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_bb86ee_mi_0,(*age));\n}\n```\n\n因为是指针传递，所以当指针指向的内容变化时，打印出来的值也就会变化了\n\n### 全局变量不捕获\n\n全局`static`变量不捕获，因为全局`static`变量大家都能访问，所以函数内可以直接读取值\n\n### block内的self会被捕获吗\n\n会，我们来举个例子\n\n```\n- (void)test {\n\tvoid(^block)(void) = ^{\n    \tNSLog(@\"%@\",self); \n    };\n    block();\n}\n```\n\n因为`test`方法会添加两个隐含的参数，编译后如下\n\n```\nstatic void _I_Person_Test(Person *self, SEL _cmd) {\n\t...\n}\n```\n\n所以这就是为什么我们能在方法内访问`self`和`_cmd`的原因，因为方法会传进来`self`参数，又因为参数是局部变量，又因为局部变量会被捕获，所以`self`参数会被捕获，捕获后大概长这样子\n\n```\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  Person *self;\n  ...\n};\n```\n\n## Block的类型\n\n\nBlock有三种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型\n\n|存储区域|类名|特点|调用copy后的效果|\n|---|---|---|---|\n|数据区域 .data区|`__NSGlobalBlock__`|没有访问auto变量|无效果|\n|栈区|`__NSStackBlock__`|访问了auto变量|从栈复制到堆|\n|堆区|`__NSMallocBlock__`|`__NSStackBlock__`调用了copy|引用计数增加|\n\n### `__NSGlobalBlock__`\n\n```\nvoid(^block)(void) = ^{\n    NSLog(@\"Hello world\");\n};\n```\n\n### `__NSStackBlock__`\n\n```\nint age = 20;\nvoid(^block)(void) = ^{\n   NSLog(@\"Block %d\",age);\n};\n```\n\n因为在ARC环境下，栈区block会自动copy，所以要测试这个类型的时候，需要使用MRC环境\n\n**栈区数据的特点是会自动销毁，离开了作用域，数据都会销毁**\n\n**栈区block存在的问题是，捕获的变量会存放在栈区，所以一旦离开了作用域，捕获的内容就销毁了，将来再去访问这个block内捕获的变量，访问到的可能就是一个未知的内容**\n\n以下情况编译器会自动将栈上的block复制到堆上：\n1. block作为函数返回值时，比如\n\t```\n    typedef void(^Block)(void);\n    Block myBlock() {\n    \tint age = 10\n        return ^{\n        \tNSLog(@\"---------%d\",age);\n        };\n    }\n    ```\n2. 将block赋值给__strong指针时\n\t- __strong是是id类型和对象类型默认的所有权修饰符，所以平时在ARC环境下写的引用外部auto局部变量的block都会自动copy到堆中，原因是block默认被__strong修饰了\n3. block作为Cocoa API中方法名含有usingBlock的方法参数时\n\t- 比如NSArray的`enumerateObjectsUsingBlock:`方法，block传进去之后就会被copy一下\n4. block作为GCD API的方法参数时\n\t- 比如GCD的`dispatch_after(dispatch_time_t when, dispatch_queue_t queue,\n\t\tdispatch_block_t block);`方法，block传进去之后就会被copy一下\n\n\n### `__NSMallocBlock__`\n\n将`__NSStackBlock__`进行一次copy，即可得到`__NSMallocBlock__`\n\n```\nint age = 20;\nvoid(^block)(void) = [^{\n   NSLog(@\"Block %d\",age);\n} copy];\n```\n\n\n## 捕获对象类型的auto变量\n\n当block内部访问了对象类型的auto变量时，如下\n\n```\nPerson *person = [[Person alloc] init];\nvoid(^block)(void) = ^{\n    NSLog(@\"Person %@\",person);\n};\nblock();\n```\n我们在ARC环境下编译，这时候block会在堆上（因为被自动copy了），执行命令行`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m`，会发现block结构体的person属性多了一个`__strong`的修饰符，证明他被block强持有了。\n\n```\nstruct __main_block_impl_0 {\n  ...\n  Person *__strong person;\n  ...\n}\n```\n\n但是我们如果编译的时候去掉`-fobjc-arc`，默认就是MRC环境了，这时候block会在栈上，查看编译后的c++文件发现不会有`__strong`修饰符，如果我们在block执行前加一行`[person release]`，那么这时候`person`就会直接释放，证明block没有持有`person变量`\n\n- 结论1：如果block是在栈上，将不会对auto变量产生强引用\n    \n如果我们给person添加`__weak`修饰符\n\n```\n__weak Person *person = [[Person alloc] init];\nvoid(^block)(void) = ^{\n    NSLog(@\"Person %@\",person);\n};\nblock();\n```\n\n则block将会对person对象进行弱引用，编译后如下：\n\n```\nstruct __main_block_impl_0 {\n  ...\n  Person *__weak person;\n  ...\n}\n```\n\n所以使用`__weak`修饰符可以避免block对外部变量的强引用操作\n\n我们来看看block的结构体内的`__main_block_desc_0`是个什么东西\n\n```\nstatic struct __main_block_desc_0 {\n  size_t reserved;\n  size_t Block_size;\n  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n  void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};\n```\n\n可以发现，多了两个函数指针，`copy`和`dispose`，分别指向`__main_block_copy_0`和`__main_block_dispose_0`\n\n这两个函数的实现如下\n\n```\nstatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {\n\t_Block_object_assign((void*)&dst->person, (void*)src->person, 3/*BLOCK_FIELD_IS_OBJECT*/);\n}\n\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {\n\t_Block_object_dispose((void*)src->person, 3/*BLOCK_FIELD_IS_OBJECT*/);\n}\n```\n\n`_Block_object_assign`函数内部会对person进行引用计数器的操作，如果`__main_block_impl_0`结构体内person指针是`__strong`类型，则为强引用，引用计数+1，如果`__main_block_impl_0`结构体内person指针是`__weak`类型，则为弱引用，引用计数不变。\n\n`_Block_object_dispose`会对person对象做释放操作，类似于release，也就是断开对person对象的引用，而person究竟是否被释放还是取决于person对象自己的引用计数\n\n\n- 结论2：如果block被拷贝到堆上\n\t- 会调用block内部的copy函数\n    - copy函数内部会调用_Block_object_assign函数\n    - _Block_object_assign函数会根据auto变量的修饰符（`__strong`，`__weak`，`__unsafe_unretained`）做出相应的操作，类似于retain(形成强引用、弱引用)\n    \n\t> __unsafe_unretained修饰的变量不会增加引用计数，当销毁时，该指针不会置空，会造成不安全的情况。\n    \n- 结论3：如果block从堆上移除\n\t- 会调用block内部的dispose函数\n    - dispose函数内部会调用_Block_object_assign函数\n    - _Block_object_dispose函数会自动释放引用的auto变量，类似于release\n    \n|函数|调用时机|\n|---|---|\n|copy函数|栈上的Block复制到堆时|\n|dispose函数|堆上的Block被废弃时|\n\n\n## __block\n\n一般情况下我们是无法改变block捕获的外部的值的\n\n```\nPerson *person = [[Person alloc] init];\nvoid(^block)(void) = ^{\n\tperson = nil;  /// 这种情况是会编译失败的\n};\nblock();\n```\n\n从上面的内容我们也可以知道原因。就是因为外部的person所在的内存空间和block内（单独开辟了一个函数）的内存空间不在同一个位置，所以block内是访问不到的外部的person的。\n\n但是我们如果添加了`__block`关键字的话，就可以访问了，所以我们编译一下看看添加`__block`之后的情况\n\n```\n__block Person *person = [[Person alloc] init];\nvoid(^block)(void) = ^{\n\tperson = nil;  // 编译成功\n};\nblock();\n```\n\n编译后长这样\n\n```\nstruct __main_block_impl_0 {\n  struct __block_impl impl;\n  struct __main_block_desc_0* Desc;\n  __Block_byref_person_0 *person; // by ref\n  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_person_0 *_person, int flags=0) : person(_person->__forwarding) {\n    impl.isa = &_NSConcreteStackBlock;\n    impl.Flags = flags;\n    impl.FuncPtr = fp;\n    Desc = desc;\n  }\n};\n```\n\n可以看到person对象被封装成了一个`__Block_byref_person_0 *`类型的属性\n\n继续看看`__Block_byref_person_0`是什么\n\n```\nstruct __Block_byref_person_0 {\n  void *__isa;\n__Block_byref_person_0 *__forwarding;\n int __flags;\n int __size;\n void (*__Block_byref_id_object_copy)(void*, void*);\n void (*__Block_byref_id_object_dispose)(void*);\n Person *__strong person;\n};\n```\n\n`__Block_byref_person_0`有isa指针，是一个OC对象，里面有一个强引用的person对象（指向的内容等同于外面的person指针指向的内容），和我们熟悉的`__Block_byref_id_object_copy`和`__Block_byref_id_object_dispose`方法用于处理内存管理问题，还有指向自身的`forwarding`指针（这个指针指向对象自身），`flag`和`size`，分别表示标记位和这个结构体的占用内存空间大小。\n\nperson被封装成了结构体对象之后，原先的block函数就变成了\n\n```\nstatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n\t__Block_byref_person_0 *person = __cself->person; // bound by ref\n\t(person->__forwarding->person) = __null;\n    NSLog((NSString *)&__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_250618_mi_0,(person->__forwarding->person));\n}\n```\n\n可以看出，但我们要改变person指针的值的时候，首先是取出person对象，即`__Block_byref_person_0 *person`，然后再通过`forwarding`指针拿到自己，再拿到最里面的person，最后就可以修改了。\n\n1. 通过内存打印，我们可以得知`__Block_byref_person_0`内的person对象和外部的person对象的地址是一致的，所以我们在block内修改外部的person就是相当于修改`__Block_byref_person_0`内的person对象\n2. 为什么要绕一个圈，不直接`person->person`而是要`person->__forwarding->person`？原因是防止block从栈复制到堆之后，栈上面的block访问person访问到的是栈上的person而不是堆上的person，所以栈上的forwarding指针要指向堆的block，这样子就能一直访问到堆上的person了\n\n3. 封装的`__Block_byref_person_0`结构体内的`__Block_byref_id_object_copy`函数会管理他自己的person对象的内存，实现代码如下:\n\t`_Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);`，这里的40是person对象的偏移值，可以看到结构体内person前面的4个指针加2个整型刚好40个字节。\n4. `__Block_byref_person_0`在`__main_block_impl_0`内必定是强引用，跟我们上面所说的不一样，就算在`__block`之前再添加`__weak`修饰，`__Block_byref_person_0`在`__main_block_impl_0`内依旧是强引用，加上`__weak`修饰受影响的只有`__Block_byref_person_0`内的person指针的引用方式\n\n> 注意：MRC环境下，__block 不会对变量造成强引用，即以下情况person会提前释放\n  \n  ```\n  __block Person *person = [Person new];\n  void(^block)(void) = ^{\n      NSLog(@\"%@\",person);\n  };\n  block(); /// 这时候person已经释放了\n  ```\n\n> 注意：__block只能用于修饰auto变量，不能修饰全局变量和静态（static）变量\n\n## 循环引用\n\n### 循环引用的发生原因与解决方式\n\n- 以下代码会产生循环引用\n\t\n    ```\n    @interface Person : NSObject\n\t    @property (nonatomic, copy) void(^block)(void);\n    @end\n    ```\n\t```\n\tPerson *person = [Person alloc] init];\n\tperson.age = 10;\n\tperson.block = ^{\n\t\tNSLog(@\"age is %d\",person.age);\n\t};\n\t```\n    \n    原因是person.block捕获了person，person又持有着block，也就是block内部对person存在一个强引用，person对block也存在一个强引用，所以均无法释放。\n    \n- 在定义person指针的时候添加`__weak`修饰符或者`__unsafe_unretain`修饰符，就可以让block在捕获person的时候弱引用person，这样子就不会造成循环引用了.\n\n\t<img src=\"https://z3.ax1x.com/2021/06/13/2I2lPU.png\" alt=\"2I2lPU.png\" border=\"0\" width=\"50%\" />\n    \n  > __weak: 不会产生强引用，指向的对象销毁时，会自动让指针至nil，不支持MRC\n   \n  > __unsafe_unretain: 不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变，变成野指针，支持MRC\n\n- 在定义person指针的时候添加`__block`修饰符也可以解决循环引用问题，但前提是需要调用block并手动将person指针置为nil，如下\n\t```\n\t__block Person *person = [Person alloc] init];\n\tperson.age = 10;\n\tperson.block = ^{\n\t\tNSLog(@\"age is %d\",person.age);\n        person = nil;\n\t};\n    person.block();\n    ```\n\t为什么这样子可以解决循环引用呢?首先先分析一下内存结构\n    \n    - peron持有block\n    - block持有__block对象\n    - __block持有着person\n    - peron又持有着block\n    - ...\n   \n    所以这里是三个对象相互持有形成一个三角形关系\n    <img src=\"https://z3.ax1x.com/2021/06/13/2IcLXn.png\" alt=\"2IcLXn.png\" border=\"0\" width=\"30%\"/>\n    \n    当block执行，person = nil，解除了`__block`变量对person的引用的时候，循环引用就不再存在了\n    \n    <img src=\"https://z3.ax1x.com/2021/06/13/2IgCp4.png\" alt=\"2IgCp4.png\" border=\"0\" width=\"30%\"/>\n\n\t- MRC环境下，由于**__block不会对变量造成强引用**，所以直接用__block修饰指针也可以达到以上效果\n\n### 为什么block做属性不常用weak而是用copy\n\n如果上述例子使用weak修饰block的话，那么block会在栈中，block里面的person也会在栈中，所以离开了作用域的话，里面的person就会销毁，从而无法使用。\n\n如果你希望block做完事情就释放，比如发送一个通知，修改某个单例类的属性，没有引用外部局部变量，那么用weak就可以节约内存空间","slug":"iOS-底层原理-Block、-block及其底层实现","published":1,"updated":"2021-06-14T07:24:54.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohn0034tnn014k5728x","content":"<p>本文主要简述Block、__block的本质是什么东西，文章涉及循环引用等开发常见问题，需要重点关注。</p>\n<span id=\"more\"></span>\n\n\n<h2 id=\"先写一个最简单的block\"><a href=\"#先写一个最简单的block\" class=\"headerlink\" title=\"先写一个最简单的block\"></a>先写一个最简单的block</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;Block&quot;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n\n<p>使用命令行将<code>main.m</code>文件编译成C++文件<br/><br><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m </code></p>\n<p>编译完成后，上述代码会变成以下结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void(*block)(void) &#x3D; &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class=\"line\"></span><br><span class=\"line\">((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br></pre></td></tr></table></figure>\n\n<p>可以看出是生成了一个<code>__main_block_impl_0</code>结构体类型的对象，参数1为<code>__main_block_func_0</code>，参数2为<code>&amp;__main_block_desc_0_DATA</code></p>\n<h2 id=\"block的底层结构\"><a href=\"#block的底层结构\" class=\"headerlink\" title=\"block的底层结构\"></a>block的底层结构</h2><p>接下来查看一下<code>__main_block_impl_0</code>是什么东西</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;&#x2F; block的结构体，引用了两个结构体和实现了一个构造方法</span><br><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  struct __block_impl impl;</span><br><span class=\"line\">  struct __main_block_desc_0* Desc;</span><br><span class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags&#x3D;0) &#123;</span><br><span class=\"line\">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">    impl.Flags &#x3D; flags;</span><br><span class=\"line\">    impl.FuncPtr &#x3D; fp;</span><br><span class=\"line\">    Desc &#x3D; desc;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;&#x2F; block的结构体引用的第一个结构体</span><br><span class=\"line\">struct __block_impl &#123;</span><br><span class=\"line\">  void *isa;</span><br><span class=\"line\">  int Flags;</span><br><span class=\"line\">  int Reserved;</span><br><span class=\"line\">  void *FuncPtr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;&#x2F; block的结构体引用的第二个结构体，第一个参数赋值了0，第二个参数赋值了__main_block_impl_0的结构体大小</span><br><span class=\"line\">static struct __main_block_desc_0 &#123;</span><br><span class=\"line\">  size_t reserved;</span><br><span class=\"line\">  size_t Block_size;</span><br><span class=\"line\">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>所以拼接一下可以看出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  void *isa;</span><br><span class=\"line\">  int Flags;</span><br><span class=\"line\">  int Reserved;</span><br><span class=\"line\">  void *FuncPtr;</span><br><span class=\"line\">  size_t reserved;</span><br><span class=\"line\">  size_t Block_size;</span><br><span class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags&#x3D;0) &#123;</span><br><span class=\"line\">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">    impl.Flags &#x3D; flags;</span><br><span class=\"line\">    impl.FuncPtr &#x3D; fp;</span><br><span class=\"line\">    Desc &#x3D; desc;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><em><strong>结论1：block本质上是一个OC对象，它内部也有个isa指针</strong></em></li>\n</ul>\n<p>接下来看看构造方法，第一个参数是<code>void *fp</code>意为<code>function pointer</code>函数指针，所以我们回去看看这里传了什么值进去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void(*block)(void) &#x3D; &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure>\n\n<p>是<code>__main_block_func_0</code>，那我们再看看<code>__main_block_func_0</code>是什么</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">\tNSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_34b858_mi_0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可以看出我们在block内写的代码被封装成了一个函数</p>\n<ul>\n<li><em><strong>结论2：block是封装了函数调用以及函数调用环境的OC对象</strong></em></li>\n</ul>\n<p>最后，看一下block的调用，被编译成了下述结构（这里我们去掉强制转换）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(block)-&gt;FuncPtr(block);</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，是取出了变量中的<code>FuncPtr</code>成员变量，得到函数指针后把自己传进去，这样子就完成了block的调用</p>\n<h2 id=\"block捕获外部变量\"><a href=\"#block捕获外部变量\" class=\"headerlink\" title=\"block捕获外部变量\"></a>block捕获外部变量</h2><p>从上面的分析我们可以得知，局部变量的定义和使用，是在两个函数中进行的，所以为了能够给让变量跨函数访问，block需要捕获该变量 </p>\n<h3 id=\"局部auto类型的变量捕获\"><a href=\"#局部auto类型的变量捕获\" class=\"headerlink\" title=\"局部auto类型的变量捕获\"></a>局部auto类型的变量捕获</h3><p><strong>auto ： 自动变量，离开作用域自动销毁</strong></p>\n<p>平常我们定义的局部变量，默认都是<code>auto</code>修饰的</p>\n<p>先写一个简单的demo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age &#x3D; 10; &#x2F;&#x2F; 等价于 auto int age &#x3D; 10;</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;Block %d&quot;,age);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>编译后变成如下结构(去掉强制转换)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age &#x3D; 10;</span><br><span class=\"line\">void(*block)(void) &#x3D; &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br></pre></td></tr></table></figure>\n\n<p><code>__main_block_impl_0</code>也发生了变化，可以看到多了一个<code>age</code>成员变量，所以构造函数也多了一个参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  struct __block_impl impl;</span><br><span class=\"line\">  struct __main_block_desc_0* Desc;</span><br><span class=\"line\">  int age;</span><br><span class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags&#x3D;0) : age(_age) &#123;</span><br><span class=\"line\">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">    impl.Flags &#x3D; flags;</span><br><span class=\"line\">    impl.FuncPtr &#x3D; fp;</span><br><span class=\"line\">    Desc &#x3D; desc;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>age(_age)</code>这个语法意为将构造方法传进来的<code>_age</code>赋值到自己的的成员变量<code>age</code>，这个过程我们称作变量的<strong>捕获</strong></p>\n<p>block内编译后的函数<code>__main_block_func_0</code>也发生了变化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">  int age &#x3D; __cself-&gt;age; &#x2F;&#x2F; bound by copy</span><br><span class=\"line\">   NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_5fd8ec_mi_0,age);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出函数内取出了结构体内的<code>age</code>成员变量，然后交给<code>NSLog</code>使用</p>\n<p>由此可知，block在定义的时候就会把外部传进来的参数给存储一遍，然后调用的时候在从block对象中取出来，所以这就意味着<strong>被block捕获的变量，在被捕获后如果修改了值，是不会应用到block中的</strong>，举例如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age &#x3D; 10;</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;age &#x3D; %d&quot;,age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">age &#x3D; 20;</span><br><span class=\"line\">block(); &#x2F;&#x2F; 调用这个方法只会输出age &#x3D; 10，因为age被捕获时是10，所以后面就算改了值也没用</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"局部static类型的变量捕获\"><a href=\"#局部static类型的变量捕获\" class=\"headerlink\" title=\"局部static类型的变量捕获\"></a>局部static类型的变量捕获</h3><p>把上面的<code>age</code>变量加一个<code>static</code>修饰符试试看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int age &#x3D; 10;</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;age &#x3D; %d&quot;,age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">age &#x3D; 20;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n\n<p>结果会输出<code>age = 20</code>，原因是静态变量会将<code>static</code>修饰的对象转为block的指针类型的成员属性，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  struct __block_impl impl;</span><br><span class=\"line\">  struct __main_block_desc_0* Desc;</span><br><span class=\"line\">  int *age;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">  int *age &#x3D; __cself-&gt;age; &#x2F;&#x2F; bound by copy</span><br><span class=\"line\">  NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_bb86ee_mi_0,(*age));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为是指针传递，所以当指针指向的内容变化时，打印出来的值也就会变化了</p>\n<h3 id=\"全局变量不捕获\"><a href=\"#全局变量不捕获\" class=\"headerlink\" title=\"全局变量不捕获\"></a>全局变量不捕获</h3><p>全局<code>static</code>变量不捕获，因为全局<code>static</code>变量大家都能访问，所以函数内可以直接读取值</p>\n<h3 id=\"block内的self会被捕获吗\"><a href=\"#block内的self会被捕获吗\" class=\"headerlink\" title=\"block内的self会被捕获吗\"></a>block内的self会被捕获吗</h3><p>会，我们来举个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)test &#123;</span><br><span class=\"line\">\tvoid(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    \tNSLog(@&quot;%@&quot;,self); </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    block();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>test</code>方法会添加两个隐含的参数，编译后如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void _I_Person_Test(Person *self, SEL _cmd) &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以这就是为什么我们能在方法内访问<code>self</code>和<code>_cmd</code>的原因，因为方法会传进来<code>self</code>参数，又因为参数是局部变量，又因为局部变量会被捕获，所以<code>self</code>参数会被捕获，捕获后大概长这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  struct __block_impl impl;</span><br><span class=\"line\">  struct __main_block_desc_0* Desc;</span><br><span class=\"line\">  Person *self;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Block的类型\"><a href=\"#Block的类型\" class=\"headerlink\" title=\"Block的类型\"></a>Block的类型</h2><p>Block有三种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型</p>\n<table>\n<thead>\n<tr>\n<th>存储区域</th>\n<th>类名</th>\n<th>特点</th>\n<th>调用copy后的效果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据区域 .data区</td>\n<td><code>__NSGlobalBlock__</code></td>\n<td>没有访问auto变量</td>\n<td>无效果</td>\n</tr>\n<tr>\n<td>栈区</td>\n<td><code>__NSStackBlock__</code></td>\n<td>访问了auto变量</td>\n<td>从栈复制到堆</td>\n</tr>\n<tr>\n<td>堆区</td>\n<td><code>__NSMallocBlock__</code></td>\n<td><code>__NSStackBlock__</code>调用了copy</td>\n<td>引用计数增加</td>\n</tr>\n</tbody></table>\n<h3 id=\"NSGlobalBlock\"><a href=\"#NSGlobalBlock\" class=\"headerlink\" title=\"__NSGlobalBlock__\"></a><code>__NSGlobalBlock__</code></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;Hello world&quot;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NSStackBlock\"><a href=\"#NSStackBlock\" class=\"headerlink\" title=\"__NSStackBlock__\"></a><code>__NSStackBlock__</code></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age &#x3D; 20;</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">   NSLog(@&quot;Block %d&quot;,age);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>因为在ARC环境下，栈区block会自动copy，所以要测试这个类型的时候，需要使用MRC环境</p>\n<p><strong>栈区数据的特点是会自动销毁，离开了作用域，数据都会销毁</strong></p>\n<p><strong>栈区block存在的问题是，捕获的变量会存放在栈区，所以一旦离开了作用域，捕获的内容就销毁了，将来再去访问这个block内捕获的变量，访问到的可能就是一个未知的内容</strong></p>\n<p>以下情况编译器会自动将栈上的block复制到堆上：</p>\n<ol>\n<li>block作为函数返回值时，比如 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef void(^Block)(void);</span><br><span class=\"line\">Block myBlock() &#123;</span><br><span class=\"line\">\tint age &#x3D; 10</span><br><span class=\"line\">    return ^&#123;</span><br><span class=\"line\">    \tNSLog(@&quot;---------%d&quot;,age);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>将block赋值给__strong指针时<ul>\n<li>__strong是是id类型和对象类型默认的所有权修饰符，所以平时在ARC环境下写的引用外部auto局部变量的block都会自动copy到堆中，原因是block默认被__strong修饰了</li>\n</ul>\n</li>\n<li>block作为Cocoa API中方法名含有usingBlock的方法参数时<ul>\n<li>比如NSArray的<code>enumerateObjectsUsingBlock:</code>方法，block传进去之后就会被copy一下</li>\n</ul>\n</li>\n<li>block作为GCD API的方法参数时<ul>\n<li>比如GCD的<code>dispatch_after(dispatch_time_t when, dispatch_queue_t queue,   dispatch_block_t block);</code>方法，block传进去之后就会被copy一下</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"NSMallocBlock\"><a href=\"#NSMallocBlock\" class=\"headerlink\" title=\"__NSMallocBlock__\"></a><code>__NSMallocBlock__</code></h3><p>将<code>__NSStackBlock__</code>进行一次copy，即可得到<code>__NSMallocBlock__</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age &#x3D; 20;</span><br><span class=\"line\">void(^block)(void) &#x3D; [^&#123;</span><br><span class=\"line\">   NSLog(@&quot;Block %d&quot;,age);</span><br><span class=\"line\">&#125; copy];</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"捕获对象类型的auto变量\"><a href=\"#捕获对象类型的auto变量\" class=\"headerlink\" title=\"捕获对象类型的auto变量\"></a>捕获对象类型的auto变量</h2><p>当block内部访问了对象类型的auto变量时，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *person &#x3D; [[Person alloc] init];</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;Person %@&quot;,person);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n<p>我们在ARC环境下编译，这时候block会在堆上（因为被自动copy了），执行命令行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</code>，会发现block结构体的person属性多了一个<code>__strong</code>的修饰符，证明他被block强持有了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  Person *__strong person;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是我们如果编译的时候去掉<code>-fobjc-arc</code>，默认就是MRC环境了，这时候block会在栈上，查看编译后的c++文件发现不会有<code>__strong</code>修饰符，如果我们在block执行前加一行<code>[person release]</code>，那么这时候<code>person</code>就会直接释放，证明block没有持有<code>person变量</code></p>\n<ul>\n<li>结论1：如果block是在栈上，将不会对auto变量产生强引用</li>\n</ul>\n<p>如果我们给person添加<code>__weak</code>修饰符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak Person *person &#x3D; [[Person alloc] init];</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;Person %@&quot;,person);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n\n<p>则block将会对person对象进行弱引用，编译后如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  Person *__weak person;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以使用<code>__weak</code>修饰符可以避免block对外部变量的强引用操作</p>\n<p>我们来看看block的结构体内的<code>__main_block_desc_0</code>是个什么东西</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static struct __main_block_desc_0 &#123;</span><br><span class=\"line\">  size_t reserved;</span><br><span class=\"line\">  size_t Block_size;</span><br><span class=\"line\">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class=\"line\">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class=\"line\">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现，多了两个函数指针，<code>copy</code>和<code>dispose</code>，分别指向<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code></p>\n<p>这两个函数的实现如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class=\"line\">\t_Block_object_assign((void*)&amp;dst-&gt;person, (void*)src-&gt;person, 3&#x2F;*BLOCK_FIELD_IS_OBJECT*&#x2F;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class=\"line\">\t_Block_object_dispose((void*)src-&gt;person, 3&#x2F;*BLOCK_FIELD_IS_OBJECT*&#x2F;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>_Block_object_assign</code>函数内部会对person进行引用计数器的操作，如果<code>__main_block_impl_0</code>结构体内person指针是<code>__strong</code>类型，则为强引用，引用计数+1，如果<code>__main_block_impl_0</code>结构体内person指针是<code>__weak</code>类型，则为弱引用，引用计数不变。</p>\n<p><code>_Block_object_dispose</code>会对person对象做释放操作，类似于release，也就是断开对person对象的引用，而person究竟是否被释放还是取决于person对象自己的引用计数</p>\n<ul>\n<li>结论2：如果block被拷贝到堆上<ul>\n<li>会调用block内部的copy函数</li>\n<li>copy函数内部会调用_Block_object_assign函数</li>\n<li>_Block_object_assign函数会根据auto变量的修饰符（<code>__strong</code>，<code>__weak</code>，<code>__unsafe_unretained</code>）做出相应的操作，类似于retain(形成强引用、弱引用)</li>\n</ul>\n<blockquote>\n<p>__unsafe_unretained修饰的变量不会增加引用计数，当销毁时，该指针不会置空，会造成不安全的情况。</p>\n</blockquote>\n</li>\n<li>结论3：如果block从堆上移除<ul>\n<li>会调用block内部的dispose函数</li>\n<li>dispose函数内部会调用_Block_object_assign函数</li>\n<li>_Block_object_dispose函数会自动释放引用的auto变量，类似于release</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>调用时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>copy函数</td>\n<td>栈上的Block复制到堆时</td>\n</tr>\n<tr>\n<td>dispose函数</td>\n<td>堆上的Block被废弃时</td>\n</tr>\n</tbody></table>\n<h2 id=\"block\"><a href=\"#block\" class=\"headerlink\" title=\"__block\"></a>__block</h2><p>一般情况下我们是无法改变block捕获的外部的值的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *person &#x3D; [[Person alloc] init];</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">\tperson &#x3D; nil;  &#x2F;&#x2F;&#x2F; 这种情况是会编译失败的</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n\n<p>从上面的内容我们也可以知道原因。就是因为外部的person所在的内存空间和block内（单独开辟了一个函数）的内存空间不在同一个位置，所以block内是访问不到的外部的person的。</p>\n<p>但是我们如果添加了<code>__block</code>关键字的话，就可以访问了，所以我们编译一下看看添加<code>__block</code>之后的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__block Person *person &#x3D; [[Person alloc] init];</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">\tperson &#x3D; nil;  &#x2F;&#x2F; 编译成功</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n\n<p>编译后长这样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  struct __block_impl impl;</span><br><span class=\"line\">  struct __main_block_desc_0* Desc;</span><br><span class=\"line\">  __Block_byref_person_0 *person; &#x2F;&#x2F; by ref</span><br><span class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_person_0 *_person, int flags&#x3D;0) : person(_person-&gt;__forwarding) &#123;</span><br><span class=\"line\">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">    impl.Flags &#x3D; flags;</span><br><span class=\"line\">    impl.FuncPtr &#x3D; fp;</span><br><span class=\"line\">    Desc &#x3D; desc;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到person对象被封装成了一个<code>__Block_byref_person_0 *</code>类型的属性</p>\n<p>继续看看<code>__Block_byref_person_0</code>是什么</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __Block_byref_person_0 &#123;</span><br><span class=\"line\">  void *__isa;</span><br><span class=\"line\">__Block_byref_person_0 *__forwarding;</span><br><span class=\"line\"> int __flags;</span><br><span class=\"line\"> int __size;</span><br><span class=\"line\"> void (*__Block_byref_id_object_copy)(void*, void*);</span><br><span class=\"line\"> void (*__Block_byref_id_object_dispose)(void*);</span><br><span class=\"line\"> Person *__strong person;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>__Block_byref_person_0</code>有isa指针，是一个OC对象，里面有一个强引用的person对象（指向的内容等同于外面的person指针指向的内容），和我们熟悉的<code>__Block_byref_id_object_copy</code>和<code>__Block_byref_id_object_dispose</code>方法用于处理内存管理问题，还有指向自身的<code>forwarding</code>指针（这个指针指向对象自身），<code>flag</code>和<code>size</code>，分别表示标记位和这个结构体的占用内存空间大小。</p>\n<p>person被封装成了结构体对象之后，原先的block函数就变成了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">\t__Block_byref_person_0 *person &#x3D; __cself-&gt;person; &#x2F;&#x2F; bound by ref</span><br><span class=\"line\">\t(person-&gt;__forwarding-&gt;person) &#x3D; __null;</span><br><span class=\"line\">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_250618_mi_0,(person-&gt;__forwarding-&gt;person));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，但我们要改变person指针的值的时候，首先是取出person对象，即<code>__Block_byref_person_0 *person</code>，然后再通过<code>forwarding</code>指针拿到自己，再拿到最里面的person，最后就可以修改了。</p>\n<ol>\n<li><p>通过内存打印，我们可以得知<code>__Block_byref_person_0</code>内的person对象和外部的person对象的地址是一致的，所以我们在block内修改外部的person就是相当于修改<code>__Block_byref_person_0</code>内的person对象</p>\n</li>\n<li><p>为什么要绕一个圈，不直接<code>person-&gt;person</code>而是要<code>person-&gt;__forwarding-&gt;person</code>？原因是防止block从栈复制到堆之后，栈上面的block访问person访问到的是栈上的person而不是堆上的person，所以栈上的forwarding指针要指向堆的block，这样子就能一直访问到堆上的person了</p>\n</li>\n<li><p>封装的<code>__Block_byref_person_0</code>结构体内的<code>__Block_byref_id_object_copy</code>函数会管理他自己的person对象的内存，实现代码如下:<br> <code>_Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);</code>，这里的40是person对象的偏移值，可以看到结构体内person前面的4个指针加2个整型刚好40个字节。</p>\n</li>\n<li><p><code>__Block_byref_person_0</code>在<code>__main_block_impl_0</code>内必定是强引用，跟我们上面所说的不一样，就算在<code>__block</code>之前再添加<code>__weak</code>修饰，<code>__Block_byref_person_0</code>在<code>__main_block_impl_0</code>内依旧是强引用，加上<code>__weak</code>修饰受影响的只有<code>__Block_byref_person_0</code>内的person指针的引用方式</p>\n</li>\n</ol>\n<blockquote>\n<p>注意：MRC环境下，__block 不会对变量造成强引用，即以下情况person会提前释放</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__block Person *person &#x3D; [Person new];</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,person);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block(); &#x2F;&#x2F;&#x2F; 这时候person已经释放了</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：__block只能用于修饰auto变量，不能修饰全局变量和静态（static）变量</p>\n</blockquote>\n<h2 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h2><h3 id=\"循环引用的发生原因与解决方式\"><a href=\"#循环引用的发生原因与解决方式\" class=\"headerlink\" title=\"循环引用的发生原因与解决方式\"></a>循环引用的发生原因与解决方式</h3><ul>\n<li><p>以下代码会产生循环引用</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Person : NSObject</span><br><span class=\"line\"> @property (nonatomic, copy) void(^block)(void);</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *person &#x3D; [Person alloc] init];</span><br><span class=\"line\">person.age &#x3D; 10;</span><br><span class=\"line\">person.block &#x3D; ^&#123;</span><br><span class=\"line\">\tNSLog(@&quot;age is %d&quot;,person.age);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>  原因是person.block捕获了person，person又持有着block，也就是block内部对person存在一个强引用，person对block也存在一个强引用，所以均无法释放。</p>\n</li>\n<li><p>在定义person指针的时候添加<code>__weak</code>修饰符或者<code>__unsafe_unretain</code>修饰符，就可以让block在捕获person的时候弱引用person，这样子就不会造成循环引用了.</p>\n  <img src=\"https://z3.ax1x.com/2021/06/13/2I2lPU.png\" alt=\"2I2lPU.png\" border=\"0\" width=\"50%\" />\n  \n> __weak: 不会产生强引用，指向的对象销毁时，会自动让指针至nil，不支持MRC\n \n> __unsafe_unretain: 不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变，变成野指针，支持MRC</li>\n<li><p>在定义person指针的时候添加<code>__block</code>修饰符也可以解决循环引用问题，但前提是需要调用block并手动将person指针置为nil，如下</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__block Person *person &#x3D; [Person alloc] init];</span><br><span class=\"line\">person.age &#x3D; 10;</span><br><span class=\"line\">person.block &#x3D; ^&#123;</span><br><span class=\"line\">\tNSLog(@&quot;age is %d&quot;,person.age);</span><br><span class=\"line\">       person &#x3D; nil;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">   person.block();</span><br></pre></td></tr></table></figure>\n<p>  为什么这样子可以解决循环引用呢?首先先分析一下内存结构</p>\n<ul>\n<li>peron持有block</li>\n<li>block持有__block对象</li>\n<li>__block持有着person</li>\n<li>peron又持有着block</li>\n<li>…</li>\n</ul>\n<p>  所以这里是三个对象相互持有形成一个三角形关系</p>\n  <img src=\"https://z3.ax1x.com/2021/06/13/2IcLXn.png\" alt=\"2IcLXn.png\" border=\"0\" width=\"30%\"/>\n  \n  当block执行，person = nil，解除了`__block`变量对person的引用的时候，循环引用就不再存在了\n  \n  <img src=\"https://z3.ax1x.com/2021/06/13/2IgCp4.png\" alt=\"2IgCp4.png\" border=\"0\" width=\"30%\"/>\n\n<ul>\n<li>MRC环境下，由于**__block不会对变量造成强引用**，所以直接用__block修饰指针也可以达到以上效果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为什么block做属性不常用weak而是用copy\"><a href=\"#为什么block做属性不常用weak而是用copy\" class=\"headerlink\" title=\"为什么block做属性不常用weak而是用copy\"></a>为什么block做属性不常用weak而是用copy</h3><p>如果上述例子使用weak修饰block的话，那么block会在栈中，block里面的person也会在栈中，所以离开了作用域的话，里面的person就会销毁，从而无法使用。</p>\n<p>如果你希望block做完事情就释放，比如发送一个通知，修改某个单例类的属性，没有引用外部局部变量，那么用weak就可以节约内存空间</p>\n","site":{"data":{}},"excerpt":"<p>本文主要简述Block、__block的本质是什么东西，文章涉及循环引用等开发常见问题，需要重点关注。</p>","more":"<h2 id=\"先写一个最简单的block\"><a href=\"#先写一个最简单的block\" class=\"headerlink\" title=\"先写一个最简单的block\"></a>先写一个最简单的block</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;Block&quot;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n\n<p>使用命令行将<code>main.m</code>文件编译成C++文件<br/><br><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m </code></p>\n<p>编译完成后，上述代码会变成以下结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void(*block)(void) &#x3D; &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class=\"line\"></span><br><span class=\"line\">((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br></pre></td></tr></table></figure>\n\n<p>可以看出是生成了一个<code>__main_block_impl_0</code>结构体类型的对象，参数1为<code>__main_block_func_0</code>，参数2为<code>&amp;__main_block_desc_0_DATA</code></p>\n<h2 id=\"block的底层结构\"><a href=\"#block的底层结构\" class=\"headerlink\" title=\"block的底层结构\"></a>block的底层结构</h2><p>接下来查看一下<code>__main_block_impl_0</code>是什么东西</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;&#x2F; block的结构体，引用了两个结构体和实现了一个构造方法</span><br><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  struct __block_impl impl;</span><br><span class=\"line\">  struct __main_block_desc_0* Desc;</span><br><span class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags&#x3D;0) &#123;</span><br><span class=\"line\">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">    impl.Flags &#x3D; flags;</span><br><span class=\"line\">    impl.FuncPtr &#x3D; fp;</span><br><span class=\"line\">    Desc &#x3D; desc;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;&#x2F; block的结构体引用的第一个结构体</span><br><span class=\"line\">struct __block_impl &#123;</span><br><span class=\"line\">  void *isa;</span><br><span class=\"line\">  int Flags;</span><br><span class=\"line\">  int Reserved;</span><br><span class=\"line\">  void *FuncPtr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;&#x2F; block的结构体引用的第二个结构体，第一个参数赋值了0，第二个参数赋值了__main_block_impl_0的结构体大小</span><br><span class=\"line\">static struct __main_block_desc_0 &#123;</span><br><span class=\"line\">  size_t reserved;</span><br><span class=\"line\">  size_t Block_size;</span><br><span class=\"line\">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>所以拼接一下可以看出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  void *isa;</span><br><span class=\"line\">  int Flags;</span><br><span class=\"line\">  int Reserved;</span><br><span class=\"line\">  void *FuncPtr;</span><br><span class=\"line\">  size_t reserved;</span><br><span class=\"line\">  size_t Block_size;</span><br><span class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags&#x3D;0) &#123;</span><br><span class=\"line\">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">    impl.Flags &#x3D; flags;</span><br><span class=\"line\">    impl.FuncPtr &#x3D; fp;</span><br><span class=\"line\">    Desc &#x3D; desc;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><em><strong>结论1：block本质上是一个OC对象，它内部也有个isa指针</strong></em></li>\n</ul>\n<p>接下来看看构造方法，第一个参数是<code>void *fp</code>意为<code>function pointer</code>函数指针，所以我们回去看看这里传了什么值进去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void(*block)(void) &#x3D; &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure>\n\n<p>是<code>__main_block_func_0</code>，那我们再看看<code>__main_block_func_0</code>是什么</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">\tNSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_34b858_mi_0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可以看出我们在block内写的代码被封装成了一个函数</p>\n<ul>\n<li><em><strong>结论2：block是封装了函数调用以及函数调用环境的OC对象</strong></em></li>\n</ul>\n<p>最后，看一下block的调用，被编译成了下述结构（这里我们去掉强制转换）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(block)-&gt;FuncPtr(block);</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，是取出了变量中的<code>FuncPtr</code>成员变量，得到函数指针后把自己传进去，这样子就完成了block的调用</p>\n<h2 id=\"block捕获外部变量\"><a href=\"#block捕获外部变量\" class=\"headerlink\" title=\"block捕获外部变量\"></a>block捕获外部变量</h2><p>从上面的分析我们可以得知，局部变量的定义和使用，是在两个函数中进行的，所以为了能够给让变量跨函数访问，block需要捕获该变量 </p>\n<h3 id=\"局部auto类型的变量捕获\"><a href=\"#局部auto类型的变量捕获\" class=\"headerlink\" title=\"局部auto类型的变量捕获\"></a>局部auto类型的变量捕获</h3><p><strong>auto ： 自动变量，离开作用域自动销毁</strong></p>\n<p>平常我们定义的局部变量，默认都是<code>auto</code>修饰的</p>\n<p>先写一个简单的demo</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age &#x3D; 10; &#x2F;&#x2F; 等价于 auto int age &#x3D; 10;</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;Block %d&quot;,age);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>编译后变成如下结构(去掉强制转换)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age &#x3D; 10;</span><br><span class=\"line\">void(*block)(void) &#x3D; &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br></pre></td></tr></table></figure>\n\n<p><code>__main_block_impl_0</code>也发生了变化，可以看到多了一个<code>age</code>成员变量，所以构造函数也多了一个参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  struct __block_impl impl;</span><br><span class=\"line\">  struct __main_block_desc_0* Desc;</span><br><span class=\"line\">  int age;</span><br><span class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags&#x3D;0) : age(_age) &#123;</span><br><span class=\"line\">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">    impl.Flags &#x3D; flags;</span><br><span class=\"line\">    impl.FuncPtr &#x3D; fp;</span><br><span class=\"line\">    Desc &#x3D; desc;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>age(_age)</code>这个语法意为将构造方法传进来的<code>_age</code>赋值到自己的的成员变量<code>age</code>，这个过程我们称作变量的<strong>捕获</strong></p>\n<p>block内编译后的函数<code>__main_block_func_0</code>也发生了变化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">  int age &#x3D; __cself-&gt;age; &#x2F;&#x2F; bound by copy</span><br><span class=\"line\">   NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_5fd8ec_mi_0,age);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出函数内取出了结构体内的<code>age</code>成员变量，然后交给<code>NSLog</code>使用</p>\n<p>由此可知，block在定义的时候就会把外部传进来的参数给存储一遍，然后调用的时候在从block对象中取出来，所以这就意味着<strong>被block捕获的变量，在被捕获后如果修改了值，是不会应用到block中的</strong>，举例如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age &#x3D; 10;</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;age &#x3D; %d&quot;,age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">age &#x3D; 20;</span><br><span class=\"line\">block(); &#x2F;&#x2F; 调用这个方法只会输出age &#x3D; 10，因为age被捕获时是10，所以后面就算改了值也没用</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"局部static类型的变量捕获\"><a href=\"#局部static类型的变量捕获\" class=\"headerlink\" title=\"局部static类型的变量捕获\"></a>局部static类型的变量捕获</h3><p>把上面的<code>age</code>变量加一个<code>static</code>修饰符试试看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int age &#x3D; 10;</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;age &#x3D; %d&quot;,age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">age &#x3D; 20;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n\n<p>结果会输出<code>age = 20</code>，原因是静态变量会将<code>static</code>修饰的对象转为block的指针类型的成员属性，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  struct __block_impl impl;</span><br><span class=\"line\">  struct __main_block_desc_0* Desc;</span><br><span class=\"line\">  int *age;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">  int *age &#x3D; __cself-&gt;age; &#x2F;&#x2F; bound by copy</span><br><span class=\"line\">  NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_bb86ee_mi_0,(*age));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为是指针传递，所以当指针指向的内容变化时，打印出来的值也就会变化了</p>\n<h3 id=\"全局变量不捕获\"><a href=\"#全局变量不捕获\" class=\"headerlink\" title=\"全局变量不捕获\"></a>全局变量不捕获</h3><p>全局<code>static</code>变量不捕获，因为全局<code>static</code>变量大家都能访问，所以函数内可以直接读取值</p>\n<h3 id=\"block内的self会被捕获吗\"><a href=\"#block内的self会被捕获吗\" class=\"headerlink\" title=\"block内的self会被捕获吗\"></a>block内的self会被捕获吗</h3><p>会，我们来举个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)test &#123;</span><br><span class=\"line\">\tvoid(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    \tNSLog(@&quot;%@&quot;,self); </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    block();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>test</code>方法会添加两个隐含的参数，编译后如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void _I_Person_Test(Person *self, SEL _cmd) &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以这就是为什么我们能在方法内访问<code>self</code>和<code>_cmd</code>的原因，因为方法会传进来<code>self</code>参数，又因为参数是局部变量，又因为局部变量会被捕获，所以<code>self</code>参数会被捕获，捕获后大概长这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  struct __block_impl impl;</span><br><span class=\"line\">  struct __main_block_desc_0* Desc;</span><br><span class=\"line\">  Person *self;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Block的类型\"><a href=\"#Block的类型\" class=\"headerlink\" title=\"Block的类型\"></a>Block的类型</h2><p>Block有三种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型</p>\n<table>\n<thead>\n<tr>\n<th>存储区域</th>\n<th>类名</th>\n<th>特点</th>\n<th>调用copy后的效果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据区域 .data区</td>\n<td><code>__NSGlobalBlock__</code></td>\n<td>没有访问auto变量</td>\n<td>无效果</td>\n</tr>\n<tr>\n<td>栈区</td>\n<td><code>__NSStackBlock__</code></td>\n<td>访问了auto变量</td>\n<td>从栈复制到堆</td>\n</tr>\n<tr>\n<td>堆区</td>\n<td><code>__NSMallocBlock__</code></td>\n<td><code>__NSStackBlock__</code>调用了copy</td>\n<td>引用计数增加</td>\n</tr>\n</tbody></table>\n<h3 id=\"NSGlobalBlock\"><a href=\"#NSGlobalBlock\" class=\"headerlink\" title=\"__NSGlobalBlock__\"></a><code>__NSGlobalBlock__</code></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;Hello world&quot;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NSStackBlock\"><a href=\"#NSStackBlock\" class=\"headerlink\" title=\"__NSStackBlock__\"></a><code>__NSStackBlock__</code></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age &#x3D; 20;</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">   NSLog(@&quot;Block %d&quot;,age);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>因为在ARC环境下，栈区block会自动copy，所以要测试这个类型的时候，需要使用MRC环境</p>\n<p><strong>栈区数据的特点是会自动销毁，离开了作用域，数据都会销毁</strong></p>\n<p><strong>栈区block存在的问题是，捕获的变量会存放在栈区，所以一旦离开了作用域，捕获的内容就销毁了，将来再去访问这个block内捕获的变量，访问到的可能就是一个未知的内容</strong></p>\n<p>以下情况编译器会自动将栈上的block复制到堆上：</p>\n<ol>\n<li>block作为函数返回值时，比如 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef void(^Block)(void);</span><br><span class=\"line\">Block myBlock() &#123;</span><br><span class=\"line\">\tint age &#x3D; 10</span><br><span class=\"line\">    return ^&#123;</span><br><span class=\"line\">    \tNSLog(@&quot;---------%d&quot;,age);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>将block赋值给__strong指针时<ul>\n<li>__strong是是id类型和对象类型默认的所有权修饰符，所以平时在ARC环境下写的引用外部auto局部变量的block都会自动copy到堆中，原因是block默认被__strong修饰了</li>\n</ul>\n</li>\n<li>block作为Cocoa API中方法名含有usingBlock的方法参数时<ul>\n<li>比如NSArray的<code>enumerateObjectsUsingBlock:</code>方法，block传进去之后就会被copy一下</li>\n</ul>\n</li>\n<li>block作为GCD API的方法参数时<ul>\n<li>比如GCD的<code>dispatch_after(dispatch_time_t when, dispatch_queue_t queue,   dispatch_block_t block);</code>方法，block传进去之后就会被copy一下</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"NSMallocBlock\"><a href=\"#NSMallocBlock\" class=\"headerlink\" title=\"__NSMallocBlock__\"></a><code>__NSMallocBlock__</code></h3><p>将<code>__NSStackBlock__</code>进行一次copy，即可得到<code>__NSMallocBlock__</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int age &#x3D; 20;</span><br><span class=\"line\">void(^block)(void) &#x3D; [^&#123;</span><br><span class=\"line\">   NSLog(@&quot;Block %d&quot;,age);</span><br><span class=\"line\">&#125; copy];</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"捕获对象类型的auto变量\"><a href=\"#捕获对象类型的auto变量\" class=\"headerlink\" title=\"捕获对象类型的auto变量\"></a>捕获对象类型的auto变量</h2><p>当block内部访问了对象类型的auto变量时，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *person &#x3D; [[Person alloc] init];</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;Person %@&quot;,person);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n<p>我们在ARC环境下编译，这时候block会在堆上（因为被自动copy了），执行命令行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</code>，会发现block结构体的person属性多了一个<code>__strong</code>的修饰符，证明他被block强持有了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  Person *__strong person;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是我们如果编译的时候去掉<code>-fobjc-arc</code>，默认就是MRC环境了，这时候block会在栈上，查看编译后的c++文件发现不会有<code>__strong</code>修饰符，如果我们在block执行前加一行<code>[person release]</code>，那么这时候<code>person</code>就会直接释放，证明block没有持有<code>person变量</code></p>\n<ul>\n<li>结论1：如果block是在栈上，将不会对auto变量产生强引用</li>\n</ul>\n<p>如果我们给person添加<code>__weak</code>修饰符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak Person *person &#x3D; [[Person alloc] init];</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;Person %@&quot;,person);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n\n<p>则block将会对person对象进行弱引用，编译后如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  Person *__weak person;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以使用<code>__weak</code>修饰符可以避免block对外部变量的强引用操作</p>\n<p>我们来看看block的结构体内的<code>__main_block_desc_0</code>是个什么东西</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static struct __main_block_desc_0 &#123;</span><br><span class=\"line\">  size_t reserved;</span><br><span class=\"line\">  size_t Block_size;</span><br><span class=\"line\">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class=\"line\">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class=\"line\">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现，多了两个函数指针，<code>copy</code>和<code>dispose</code>，分别指向<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code></p>\n<p>这两个函数的实现如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class=\"line\">\t_Block_object_assign((void*)&amp;dst-&gt;person, (void*)src-&gt;person, 3&#x2F;*BLOCK_FIELD_IS_OBJECT*&#x2F;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class=\"line\">\t_Block_object_dispose((void*)src-&gt;person, 3&#x2F;*BLOCK_FIELD_IS_OBJECT*&#x2F;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>_Block_object_assign</code>函数内部会对person进行引用计数器的操作，如果<code>__main_block_impl_0</code>结构体内person指针是<code>__strong</code>类型，则为强引用，引用计数+1，如果<code>__main_block_impl_0</code>结构体内person指针是<code>__weak</code>类型，则为弱引用，引用计数不变。</p>\n<p><code>_Block_object_dispose</code>会对person对象做释放操作，类似于release，也就是断开对person对象的引用，而person究竟是否被释放还是取决于person对象自己的引用计数</p>\n<ul>\n<li>结论2：如果block被拷贝到堆上<ul>\n<li>会调用block内部的copy函数</li>\n<li>copy函数内部会调用_Block_object_assign函数</li>\n<li>_Block_object_assign函数会根据auto变量的修饰符（<code>__strong</code>，<code>__weak</code>，<code>__unsafe_unretained</code>）做出相应的操作，类似于retain(形成强引用、弱引用)</li>\n</ul>\n<blockquote>\n<p>__unsafe_unretained修饰的变量不会增加引用计数，当销毁时，该指针不会置空，会造成不安全的情况。</p>\n</blockquote>\n</li>\n<li>结论3：如果block从堆上移除<ul>\n<li>会调用block内部的dispose函数</li>\n<li>dispose函数内部会调用_Block_object_assign函数</li>\n<li>_Block_object_dispose函数会自动释放引用的auto变量，类似于release</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>调用时机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>copy函数</td>\n<td>栈上的Block复制到堆时</td>\n</tr>\n<tr>\n<td>dispose函数</td>\n<td>堆上的Block被废弃时</td>\n</tr>\n</tbody></table>\n<h2 id=\"block\"><a href=\"#block\" class=\"headerlink\" title=\"__block\"></a>__block</h2><p>一般情况下我们是无法改变block捕获的外部的值的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *person &#x3D; [[Person alloc] init];</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">\tperson &#x3D; nil;  &#x2F;&#x2F;&#x2F; 这种情况是会编译失败的</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n\n<p>从上面的内容我们也可以知道原因。就是因为外部的person所在的内存空间和block内（单独开辟了一个函数）的内存空间不在同一个位置，所以block内是访问不到的外部的person的。</p>\n<p>但是我们如果添加了<code>__block</code>关键字的话，就可以访问了，所以我们编译一下看看添加<code>__block</code>之后的情况</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__block Person *person &#x3D; [[Person alloc] init];</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">\tperson &#x3D; nil;  &#x2F;&#x2F; 编译成功</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block();</span><br></pre></td></tr></table></figure>\n\n<p>编译后长这样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __main_block_impl_0 &#123;</span><br><span class=\"line\">  struct __block_impl impl;</span><br><span class=\"line\">  struct __main_block_desc_0* Desc;</span><br><span class=\"line\">  __Block_byref_person_0 *person; &#x2F;&#x2F; by ref</span><br><span class=\"line\">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_person_0 *_person, int flags&#x3D;0) : person(_person-&gt;__forwarding) &#123;</span><br><span class=\"line\">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class=\"line\">    impl.Flags &#x3D; flags;</span><br><span class=\"line\">    impl.FuncPtr &#x3D; fp;</span><br><span class=\"line\">    Desc &#x3D; desc;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到person对象被封装成了一个<code>__Block_byref_person_0 *</code>类型的属性</p>\n<p>继续看看<code>__Block_byref_person_0</code>是什么</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct __Block_byref_person_0 &#123;</span><br><span class=\"line\">  void *__isa;</span><br><span class=\"line\">__Block_byref_person_0 *__forwarding;</span><br><span class=\"line\"> int __flags;</span><br><span class=\"line\"> int __size;</span><br><span class=\"line\"> void (*__Block_byref_id_object_copy)(void*, void*);</span><br><span class=\"line\"> void (*__Block_byref_id_object_dispose)(void*);</span><br><span class=\"line\"> Person *__strong person;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>__Block_byref_person_0</code>有isa指针，是一个OC对象，里面有一个强引用的person对象（指向的内容等同于外面的person指针指向的内容），和我们熟悉的<code>__Block_byref_id_object_copy</code>和<code>__Block_byref_id_object_dispose</code>方法用于处理内存管理问题，还有指向自身的<code>forwarding</code>指针（这个指针指向对象自身），<code>flag</code>和<code>size</code>，分别表示标记位和这个结构体的占用内存空间大小。</p>\n<p>person被封装成了结构体对象之后，原先的block函数就变成了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class=\"line\">\t__Block_byref_person_0 *person &#x3D; __cself-&gt;person; &#x2F;&#x2F; bound by ref</span><br><span class=\"line\">\t(person-&gt;__forwarding-&gt;person) &#x3D; __null;</span><br><span class=\"line\">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_250618_mi_0,(person-&gt;__forwarding-&gt;person));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，但我们要改变person指针的值的时候，首先是取出person对象，即<code>__Block_byref_person_0 *person</code>，然后再通过<code>forwarding</code>指针拿到自己，再拿到最里面的person，最后就可以修改了。</p>\n<ol>\n<li><p>通过内存打印，我们可以得知<code>__Block_byref_person_0</code>内的person对象和外部的person对象的地址是一致的，所以我们在block内修改外部的person就是相当于修改<code>__Block_byref_person_0</code>内的person对象</p>\n</li>\n<li><p>为什么要绕一个圈，不直接<code>person-&gt;person</code>而是要<code>person-&gt;__forwarding-&gt;person</code>？原因是防止block从栈复制到堆之后，栈上面的block访问person访问到的是栈上的person而不是堆上的person，所以栈上的forwarding指针要指向堆的block，这样子就能一直访问到堆上的person了</p>\n</li>\n<li><p>封装的<code>__Block_byref_person_0</code>结构体内的<code>__Block_byref_id_object_copy</code>函数会管理他自己的person对象的内存，实现代码如下:<br> <code>_Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);</code>，这里的40是person对象的偏移值，可以看到结构体内person前面的4个指针加2个整型刚好40个字节。</p>\n</li>\n<li><p><code>__Block_byref_person_0</code>在<code>__main_block_impl_0</code>内必定是强引用，跟我们上面所说的不一样，就算在<code>__block</code>之前再添加<code>__weak</code>修饰，<code>__Block_byref_person_0</code>在<code>__main_block_impl_0</code>内依旧是强引用，加上<code>__weak</code>修饰受影响的只有<code>__Block_byref_person_0</code>内的person指针的引用方式</p>\n</li>\n</ol>\n<blockquote>\n<p>注意：MRC环境下，__block 不会对变量造成强引用，即以下情况person会提前释放</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__block Person *person &#x3D; [Person new];</span><br><span class=\"line\">void(^block)(void) &#x3D; ^&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,person);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">block(); &#x2F;&#x2F;&#x2F; 这时候person已经释放了</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：__block只能用于修饰auto变量，不能修饰全局变量和静态（static）变量</p>\n</blockquote>\n<h2 id=\"循环引用\"><a href=\"#循环引用\" class=\"headerlink\" title=\"循环引用\"></a>循环引用</h2><h3 id=\"循环引用的发生原因与解决方式\"><a href=\"#循环引用的发生原因与解决方式\" class=\"headerlink\" title=\"循环引用的发生原因与解决方式\"></a>循环引用的发生原因与解决方式</h3><ul>\n<li><p>以下代码会产生循环引用</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Person : NSObject</span><br><span class=\"line\"> @property (nonatomic, copy) void(^block)(void);</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *person &#x3D; [Person alloc] init];</span><br><span class=\"line\">person.age &#x3D; 10;</span><br><span class=\"line\">person.block &#x3D; ^&#123;</span><br><span class=\"line\">\tNSLog(@&quot;age is %d&quot;,person.age);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>  原因是person.block捕获了person，person又持有着block，也就是block内部对person存在一个强引用，person对block也存在一个强引用，所以均无法释放。</p>\n</li>\n<li><p>在定义person指针的时候添加<code>__weak</code>修饰符或者<code>__unsafe_unretain</code>修饰符，就可以让block在捕获person的时候弱引用person，这样子就不会造成循环引用了.</p>\n  <img src=\"https://z3.ax1x.com/2021/06/13/2I2lPU.png\" alt=\"2I2lPU.png\" border=\"0\" width=\"50%\" />\n  \n> __weak: 不会产生强引用，指向的对象销毁时，会自动让指针至nil，不支持MRC\n \n> __unsafe_unretain: 不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变，变成野指针，支持MRC</li>\n<li><p>在定义person指针的时候添加<code>__block</code>修饰符也可以解决循环引用问题，但前提是需要调用block并手动将person指针置为nil，如下</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__block Person *person &#x3D; [Person alloc] init];</span><br><span class=\"line\">person.age &#x3D; 10;</span><br><span class=\"line\">person.block &#x3D; ^&#123;</span><br><span class=\"line\">\tNSLog(@&quot;age is %d&quot;,person.age);</span><br><span class=\"line\">       person &#x3D; nil;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">   person.block();</span><br></pre></td></tr></table></figure>\n<p>  为什么这样子可以解决循环引用呢?首先先分析一下内存结构</p>\n<ul>\n<li>peron持有block</li>\n<li>block持有__block对象</li>\n<li>__block持有着person</li>\n<li>peron又持有着block</li>\n<li>…</li>\n</ul>\n<p>  所以这里是三个对象相互持有形成一个三角形关系</p>\n  <img src=\"https://z3.ax1x.com/2021/06/13/2IcLXn.png\" alt=\"2IcLXn.png\" border=\"0\" width=\"30%\"/>\n  \n  当block执行，person = nil，解除了`__block`变量对person的引用的时候，循环引用就不再存在了\n  \n  <img src=\"https://z3.ax1x.com/2021/06/13/2IgCp4.png\" alt=\"2IgCp4.png\" border=\"0\" width=\"30%\"/>\n\n<ul>\n<li>MRC环境下，由于**__block不会对变量造成强引用**，所以直接用__block修饰指针也可以达到以上效果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为什么block做属性不常用weak而是用copy\"><a href=\"#为什么block做属性不常用weak而是用copy\" class=\"headerlink\" title=\"为什么block做属性不常用weak而是用copy\"></a>为什么block做属性不常用weak而是用copy</h3><p>如果上述例子使用weak修饰block的话，那么block会在栈中，block里面的person也会在栈中，所以离开了作用域的话，里面的person就会销毁，从而无法使用。</p>\n<p>如果你希望block做完事情就释放，比如发送一个通知，修改某个单例类的属性，没有引用外部局部变量，那么用weak就可以节约内存空间</p>"},{"title":"iOS-定位总结","author":"Arclin","abbrlink":"2684222a","date":"2016-10-28T16:00:00.000Z","_content":"iOS-定位总结\n<!-- more -->\n\ninfo.plist 请求用户位置授权\n\n```\n<key>NSLocationWhenInUseUsageDescription</key>\n\t<string>需要使用位置</string>\n<key>NSLocationAlwaysUsageDescription</key>\n\t<string>需要使用位置</string>\n```\n\n代码\n\n\nlanguage: 要生成的位置信息的语言（’China‘还是’中国‘）\n\n - 中文 : @”zh-hans”\n - 英文 : @”en”\n - 日文 : @”jp”\n\n```\n- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location;\n```\n\n```\n@interface DKLocation()<CLLocationManagerDelegate>\n\n@property (nonatomic,strong) CLLocationManager *locationManager;\n\n@end\n@implementation DKLocation\n- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location\n{\n    \n    [[self rac_signalForSelector:@selector(locationManager:didUpdateToLocation:fromLocation:) fromProtocol:@protocol(CLLocationManagerDelegate)] subscribeNext:^(RACTuple *tuple) {\n        // 停止位置更新\n        CLLocationManager *manager = tuple.first;\n        CLLocation *newLocation = tuple.second;\n        \n        [manager stopUpdatingLocation];\n        [_locationManager stopUpdatingLocation];\n        _locationManager.delegate = nil;\n        // 保存 Device 的现语言\n        NSString *userDefaultLanguages = DKUserDefaults(kAppLanguage);\n        // 强制 成 英文\n        [[NSUserDefaults standardUserDefaults] setObject:[NSArray arrayWithObjects:language,nil] forKey:@\"AppleLanguages\"];\n        // 逆地理编码\n        CLGeocoder * geoCoder = [[CLGeocoder alloc] init];\n        [geoCoder reverseGeocodeLocation:newLocation completionHandler:^(NSArray *placemarks, NSError *error) {\n            if(!error){\n                for (CLPlacemark * placemark in placemarks) {\n                    NSString *provinceName = placemark.administrativeArea;\n                    NSString *country = placemark.country;\n                    location(country,provinceName);\n                    DKLog(@\"%@%@\",country,provinceName);\n                    break;\n                }\n            }\n            // 还原Device 的语言\n            [[NSUserDefaults standardUserDefaults] setObject:@[userDefaultLanguages] forKey:@\"AppleLanguages\"];\n        }];\n\n    }];\n    \n    // 初始化定位管理器\n    _locationManager = [[CLLocationManager alloc] init];\n    _locationManager.delegate = self;\n    // 设置定位精确度到米\n    _locationManager.desiredAccuracy = kCLLocationAccuracyBest;\n    // 设置过滤器为无\n    _locationManager.distanceFilter = kCLDistanceFilterNone;\n    if ([_locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) {\n        [_locationManager requestAlwaysAuthorization];\n    }\n    //开始定位，不断调用其代理方法\n    [_locationManager startUpdatingLocation];\n    \n}\n\n@end\n```","source":"_posts/iOS-定位总结.md","raw":"---\ntitle: iOS-定位总结\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 2684222a\ndate: 2016-10-29 00:00:00\n---\niOS-定位总结\n<!-- more -->\n\ninfo.plist 请求用户位置授权\n\n```\n<key>NSLocationWhenInUseUsageDescription</key>\n\t<string>需要使用位置</string>\n<key>NSLocationAlwaysUsageDescription</key>\n\t<string>需要使用位置</string>\n```\n\n代码\n\n\nlanguage: 要生成的位置信息的语言（’China‘还是’中国‘）\n\n - 中文 : @”zh-hans”\n - 英文 : @”en”\n - 日文 : @”jp”\n\n```\n- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location;\n```\n\n```\n@interface DKLocation()<CLLocationManagerDelegate>\n\n@property (nonatomic,strong) CLLocationManager *locationManager;\n\n@end\n@implementation DKLocation\n- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location\n{\n    \n    [[self rac_signalForSelector:@selector(locationManager:didUpdateToLocation:fromLocation:) fromProtocol:@protocol(CLLocationManagerDelegate)] subscribeNext:^(RACTuple *tuple) {\n        // 停止位置更新\n        CLLocationManager *manager = tuple.first;\n        CLLocation *newLocation = tuple.second;\n        \n        [manager stopUpdatingLocation];\n        [_locationManager stopUpdatingLocation];\n        _locationManager.delegate = nil;\n        // 保存 Device 的现语言\n        NSString *userDefaultLanguages = DKUserDefaults(kAppLanguage);\n        // 强制 成 英文\n        [[NSUserDefaults standardUserDefaults] setObject:[NSArray arrayWithObjects:language,nil] forKey:@\"AppleLanguages\"];\n        // 逆地理编码\n        CLGeocoder * geoCoder = [[CLGeocoder alloc] init];\n        [geoCoder reverseGeocodeLocation:newLocation completionHandler:^(NSArray *placemarks, NSError *error) {\n            if(!error){\n                for (CLPlacemark * placemark in placemarks) {\n                    NSString *provinceName = placemark.administrativeArea;\n                    NSString *country = placemark.country;\n                    location(country,provinceName);\n                    DKLog(@\"%@%@\",country,provinceName);\n                    break;\n                }\n            }\n            // 还原Device 的语言\n            [[NSUserDefaults standardUserDefaults] setObject:@[userDefaultLanguages] forKey:@\"AppleLanguages\"];\n        }];\n\n    }];\n    \n    // 初始化定位管理器\n    _locationManager = [[CLLocationManager alloc] init];\n    _locationManager.delegate = self;\n    // 设置定位精确度到米\n    _locationManager.desiredAccuracy = kCLLocationAccuracyBest;\n    // 设置过滤器为无\n    _locationManager.distanceFilter = kCLDistanceFilterNone;\n    if ([_locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) {\n        [_locationManager requestAlwaysAuthorization];\n    }\n    //开始定位，不断调用其代理方法\n    [_locationManager startUpdatingLocation];\n    \n}\n\n@end\n```","slug":"iOS-定位总结","published":1,"updated":"2021-06-06T18:52:24.963Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohn0037tnn03f6jbgkd","content":"<p>iOS-定位总结</p>\n<span id=\"more\"></span>\n\n<p>info.plist 请求用户位置授权</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;&#x2F;key&gt;</span><br><span class=\"line\">\t&lt;string&gt;需要使用位置&lt;&#x2F;string&gt;</span><br><span class=\"line\">&lt;key&gt;NSLocationAlwaysUsageDescription&lt;&#x2F;key&gt;</span><br><span class=\"line\">\t&lt;string&gt;需要使用位置&lt;&#x2F;string&gt;</span><br></pre></td></tr></table></figure>\n\n<p>代码</p>\n<p>language: 要生成的位置信息的语言（’China‘还是’中国‘）</p>\n<ul>\n<li>中文 : @”zh-hans”</li>\n<li>英文 : @”en”</li>\n<li>日文 : @”jp”</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface DKLocation()&lt;CLLocationManagerDelegate&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic,strong) CLLocationManager *locationManager;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\">@implementation DKLocation</span><br><span class=\"line\">- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [[self rac_signalForSelector:@selector(locationManager:didUpdateToLocation:fromLocation:) fromProtocol:@protocol(CLLocationManagerDelegate)] subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 停止位置更新</span><br><span class=\"line\">        CLLocationManager *manager &#x3D; tuple.first;</span><br><span class=\"line\">        CLLocation *newLocation &#x3D; tuple.second;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [manager stopUpdatingLocation];</span><br><span class=\"line\">        [_locationManager stopUpdatingLocation];</span><br><span class=\"line\">        _locationManager.delegate &#x3D; nil;</span><br><span class=\"line\">        &#x2F;&#x2F; 保存 Device 的现语言</span><br><span class=\"line\">        NSString *userDefaultLanguages &#x3D; DKUserDefaults(kAppLanguage);</span><br><span class=\"line\">        &#x2F;&#x2F; 强制 成 英文</span><br><span class=\"line\">        [[NSUserDefaults standardUserDefaults] setObject:[NSArray arrayWithObjects:language,nil] forKey:@&quot;AppleLanguages&quot;];</span><br><span class=\"line\">        &#x2F;&#x2F; 逆地理编码</span><br><span class=\"line\">        CLGeocoder * geoCoder &#x3D; [[CLGeocoder alloc] init];</span><br><span class=\"line\">        [geoCoder reverseGeocodeLocation:newLocation completionHandler:^(NSArray *placemarks, NSError *error) &#123;</span><br><span class=\"line\">            if(!error)&#123;</span><br><span class=\"line\">                for (CLPlacemark * placemark in placemarks) &#123;</span><br><span class=\"line\">                    NSString *provinceName &#x3D; placemark.administrativeArea;</span><br><span class=\"line\">                    NSString *country &#x3D; placemark.country;</span><br><span class=\"line\">                    location(country,provinceName);</span><br><span class=\"line\">                    DKLog(@&quot;%@%@&quot;,country,provinceName);</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#x2F;&#x2F; 还原Device 的语言</span><br><span class=\"line\">            [[NSUserDefaults standardUserDefaults] setObject:@[userDefaultLanguages] forKey:@&quot;AppleLanguages&quot;];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 初始化定位管理器</span><br><span class=\"line\">    _locationManager &#x3D; [[CLLocationManager alloc] init];</span><br><span class=\"line\">    _locationManager.delegate &#x3D; self;</span><br><span class=\"line\">    &#x2F;&#x2F; 设置定位精确度到米</span><br><span class=\"line\">    _locationManager.desiredAccuracy &#x3D; kCLLocationAccuracyBest;</span><br><span class=\"line\">    &#x2F;&#x2F; 设置过滤器为无</span><br><span class=\"line\">    _locationManager.distanceFilter &#x3D; kCLDistanceFilterNone;</span><br><span class=\"line\">    if ([_locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) &#123;</span><br><span class=\"line\">        [_locationManager requestAlwaysAuthorization];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;开始定位，不断调用其代理方法</span><br><span class=\"line\">    [_locationManager startUpdatingLocation];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>iOS-定位总结</p>","more":"<p>info.plist 请求用户位置授权</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;&#x2F;key&gt;</span><br><span class=\"line\">\t&lt;string&gt;需要使用位置&lt;&#x2F;string&gt;</span><br><span class=\"line\">&lt;key&gt;NSLocationAlwaysUsageDescription&lt;&#x2F;key&gt;</span><br><span class=\"line\">\t&lt;string&gt;需要使用位置&lt;&#x2F;string&gt;</span><br></pre></td></tr></table></figure>\n\n<p>代码</p>\n<p>language: 要生成的位置信息的语言（’China‘还是’中国‘）</p>\n<ul>\n<li>中文 : @”zh-hans”</li>\n<li>英文 : @”en”</li>\n<li>日文 : @”jp”</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface DKLocation()&lt;CLLocationManagerDelegate&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic,strong) CLLocationManager *locationManager;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\">@implementation DKLocation</span><br><span class=\"line\">- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [[self rac_signalForSelector:@selector(locationManager:didUpdateToLocation:fromLocation:) fromProtocol:@protocol(CLLocationManagerDelegate)] subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 停止位置更新</span><br><span class=\"line\">        CLLocationManager *manager &#x3D; tuple.first;</span><br><span class=\"line\">        CLLocation *newLocation &#x3D; tuple.second;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [manager stopUpdatingLocation];</span><br><span class=\"line\">        [_locationManager stopUpdatingLocation];</span><br><span class=\"line\">        _locationManager.delegate &#x3D; nil;</span><br><span class=\"line\">        &#x2F;&#x2F; 保存 Device 的现语言</span><br><span class=\"line\">        NSString *userDefaultLanguages &#x3D; DKUserDefaults(kAppLanguage);</span><br><span class=\"line\">        &#x2F;&#x2F; 强制 成 英文</span><br><span class=\"line\">        [[NSUserDefaults standardUserDefaults] setObject:[NSArray arrayWithObjects:language,nil] forKey:@&quot;AppleLanguages&quot;];</span><br><span class=\"line\">        &#x2F;&#x2F; 逆地理编码</span><br><span class=\"line\">        CLGeocoder * geoCoder &#x3D; [[CLGeocoder alloc] init];</span><br><span class=\"line\">        [geoCoder reverseGeocodeLocation:newLocation completionHandler:^(NSArray *placemarks, NSError *error) &#123;</span><br><span class=\"line\">            if(!error)&#123;</span><br><span class=\"line\">                for (CLPlacemark * placemark in placemarks) &#123;</span><br><span class=\"line\">                    NSString *provinceName &#x3D; placemark.administrativeArea;</span><br><span class=\"line\">                    NSString *country &#x3D; placemark.country;</span><br><span class=\"line\">                    location(country,provinceName);</span><br><span class=\"line\">                    DKLog(@&quot;%@%@&quot;,country,provinceName);</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#x2F;&#x2F; 还原Device 的语言</span><br><span class=\"line\">            [[NSUserDefaults standardUserDefaults] setObject:@[userDefaultLanguages] forKey:@&quot;AppleLanguages&quot;];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 初始化定位管理器</span><br><span class=\"line\">    _locationManager &#x3D; [[CLLocationManager alloc] init];</span><br><span class=\"line\">    _locationManager.delegate &#x3D; self;</span><br><span class=\"line\">    &#x2F;&#x2F; 设置定位精确度到米</span><br><span class=\"line\">    _locationManager.desiredAccuracy &#x3D; kCLLocationAccuracyBest;</span><br><span class=\"line\">    &#x2F;&#x2F; 设置过滤器为无</span><br><span class=\"line\">    _locationManager.distanceFilter &#x3D; kCLDistanceFilterNone;</span><br><span class=\"line\">    if ([_locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) &#123;</span><br><span class=\"line\">        [_locationManager requestAlwaysAuthorization];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;开始定位，不断调用其代理方法</span><br><span class=\"line\">    [_locationManager startUpdatingLocation];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>"},{"title":"iOS 底层原理 --- Category、+load、+initialize和关联对象","author":"Arclin","abbrlink":"2397c268","date":"2021-06-06T14:24:00.000Z","_content":"本文简述iOS中分类的底层实现和load方法、initialize方法在类和分类中的调用特性，还有如何通过关联对象的方式给分类添加属性，以及关联对象的底层实现原理\n\n<!--more-->\n\n\n## 分类（Category）\n\n### 先写一个Demo\n\n新建一个命令行工程，在main.m中写几个类\n\n\n父类：写一个run方法\n\n```\n@interface Person : NSObject\n\n- (void)run;\n\n@end\n```\n\n父类的分类：写一个eat方法\n\n```\n@interface Person(Test) \n\n- (void)eat;\n\n@end\n\n```\n\n根据经验可知道，现在Peron对象拥有了run方法和eat方法\n\n### 分类的底层结构\n\n输入命令行\n\n`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m`\n\n接下来同级目录下就会多出一个编译后的文件`main.cpp`，查看后发现`Person(Test) `分类被编译成了如下变量\n\n```\nstatic struct _category_t _OBJC_$_CATEGORY_Person_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = \n{\n\t\"Person\",\n\t0, // &OBJC_CLASS_$_Person,\n\t(const struct _method_list_t *)&_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Test,\n\t0,\n\t0,\n\t0,\n};\n```\n\n这个变量的类型是`static struct _category_t`，名字是`_OBJC_$_CATEGORY_Person_$_Test`，等于号后面是一个初始化结构体的过程，可以看到要实例化这个结构体需要6个参数，所以查看`_category_t`的结构如下\n\n```\nstruct _category_t {\n\tconst char *name; /// 原来的类的名字\n\tstruct _class_t *cls; /// 类对象\n\tconst struct _method_list_t *instance_methods; /// 实例方法数组\n\tconst struct _method_list_t *class_methods; /// 类方法数组\n\tconst struct _protocol_list_t *protocols; /// 遵循的协议数组\n\tconst struct _prop_list_t *properties; /// 属性数组\n};\n```\n\n由此可知，**分类可以定义实例方法，可以定义类方法，可以遵循协议，可以添加属性，但是不能添加成员变量！因为分类的结构里面没有存储成员变量的地方.**\n\n### 程序通过runtime动态将分类合并到类对象、元类对象中\n\n分类中的方法是在运行时才添加到类对象和元类对象中的，而不是编译的时候添加的，编译之后只是多了几个类型为`_category_t`的结构体变量。\n\n合并的过程可以在runtime源码（objc4-818.2）中`objc-runtime-new.mm`的`load_categories_nolock`函数中看到，这里不展开流程，直接说结论。\n\n合并过程是这样子的，首先我们知道原来的类（我们就叫他主类吧）对象是存放着成员方法的，主类的元类对象是放着类方法的，因为类对象和元类对象结构是一样的，所以我们就讨论成员方法就好了。\n\n其次呢，runtime先根据分类方法的数量在数组里面开辟空间，然后把分类方法塞到原来的成员方法数组的前端，这样子合并就完成了，其他类方法、协议、属性等数组，也是同样的过程。\n\n所以最后在**类对象的方法列表数组里面，排在前面的是分类方法，后面才是主类的方法。如果有多个分类的话，那么后编译的分类的成员方法会插在数组的前面（因为插入数组的时候是倒序插入）**。\n\n有了上述结论 我们就可以解释很多事情了。\n\n#### 如果分类实现了主类的方法会怎么样\n\n根据上述结论，系统在找对应的调用方法的时候，会先找到分类的方法，所以主类的方法没有机会被调用到。\n\n#### 如果多个分类都实现了同个主类的方法\n\n根据上述结论，后编译的分类的成员方法会插在方法列表的前面，所以谁后编译，就调用谁\n\n#### 如果子类或者子类的分类实现了父类的分类方法\n\n根据上述结论和结合我们以前所学知识，最后子类实例对象会去子类的类对象里面寻找方法并调用，使用`super`关键字调用方法的话，则会去到父类的类对象内找方法。\n\n### Category跟Class Extension的区别\n\n- Class Extension是编译的时候，它的数据就已经包含在类信息中\n- Category 是在运行时才会讲数据合并到类信息中\n\n\n## load方法\n\n\n### 先写一个Demo\n\n\n父类：实现load方法\n\n```\n@implementation Person\n\n+ (void)load {\n    NSLog(@\"Person load\");\n}\n\n@end\n```\n\n父类的分类：实现load方法\n\n```\n@implementation Person(Test)\n\n+ (void)load {\n    NSLog(@\"Person Text load\");\n}\n\n@end\n\n```\n\n子类：实现load方法\n\n```\n@implementation Student\n\n+ (void)load {\n    NSLog(@\"Student load\");\n}\n\n@end\n\n```\n\n子类的分类：实现load方法\n\n```\n@implementation Student(Test)\n\n+ (void)load {\n    NSLog(@\"Student Test load\");\n}\n\n@end\n```\n\n### load方法的调用时机\n\n通过runtime源码（objc4-818.2）`objc-runtime-new.mm`第3233行得知，load方法是在加载镜像(load_images)的时候调用的。\n\n```\nvoid load_images(const char *path __unused, const struct mach_header *mh)\n{\n    if (!didInitialAttachCategories && didCallDyldNotifyRegister) {\n        didInitialAttachCategories = true;\n        loadAllCategories();\n    }\n\n    // Return without taking locks if there are no +load methods here.\n    if (!hasLoadMethods((const headerType *)mh)) return;\n\n    recursive_mutex_locker_t lock(loadMethodLock);\n\n    // Discover load methods\n    {\n        mutex_locker_t lock2(runtimeLock);\n        prepare_load_methods((const headerType *)mh);\n    }\n\n    // Call +load methods (without runtimeLock - re-entrant)\n    call_load_methods();\n}\n\n```\n\n> 补充小细节：从`load_images`函数可以看到，加载分类`loadAllCategories()`早于调用load方法`call_load_methods()`，也就是元类对象中的类方法列表内，分类的load方法会在主类的load方法之前\n\n在调用load方法之前，首先要通过`prepare_load_methods`函数整理出一个数组，这个数组会决定主类的load方法的调用顺序\n\n从`prepare_load_methods`函数中调用的`schedule_class_load`函数的内部实现我们可以知道，父类会先被加入到数组中，其次才是主类。\n\n```\n/***********************************************************************\n* prepare_load_methods\n* Schedule +load for classes in this image, any un-+load-ed \n* superclasses in other images, and any categories in this image.\n**********************************************************************/\n// Recursively schedule +load for cls and any un-+load-ed superclasses.\n// cls must already be connected.\nstatic void schedule_class_load(Class cls)\n{\n    if (!cls) return;\n    ASSERT(cls->isRealized());  // _read_images should realize\n\n    if (cls->data()->flags & RW_LOADED) return;\n\n    // Ensure superclass-first ordering\n    schedule_class_load(cls->getSuperclass());\n\n    add_class_to_loadable_list(cls);\n    cls->setInfo(RW_LOADED); \n}\n```\n\n然后我们回到最开始的地方（load_images），通过`objc-loadmethod.mm`第337行`call_load_methods`得知，先调用主类的load方法(call_class_loads())，再调用分类的load方法`call_category_loads();`\n\n\n> 补充一个小细节：在整理数组的时候，这个数组里面存放的是一个个结构体，结构体长这样\n\n  ```\n  struct loadable_class {\n      Class cls;  // may be nil  这里放元类对象（load是类方法所以存在元类对象里面）\n      IMP method;  /// 这里放的是load方法的函数指针\n  };\n\n  struct loadable_category {\n      Category cat;  // may be nil 这个是上面讲到的category_t类型的对象\n      IMP method; /// 这里放的是load方法的函数指针\n  };\n  ```\n  \n注意：runtime代码内有记录类的load方法是否曾经被加入到load数组过（RW_LOADED），如果被调用过了，就会跳过，这就是load方法只会执行一次的原因（但是你要是非要手动调用load方法那还是会执行的）\n  \n**重要：系统调用load方法不通过消息发送机制**，可以查看`objc-loadmethod.mm`第177行如下\n\n```\n/***********************************************************************\n* call_class_loads\n* Call all pending class +load methods.\n* If new classes become loadable, +load is NOT called for them.\n*\n* Called only by call_load_methods().\n**********************************************************************/\nstatic void call_class_loads(void)\n{\n    int i;\n    \n    // Detach current loadable list.\n    struct loadable_class *classes = loadable_classes;\n    int used = loadable_classes_used;\n    loadable_classes = nil;\n    loadable_classes_allocated = 0;\n    loadable_classes_used = 0;\n    \n    // Call all +loads for the detached list.\n    for (i = 0; i < used; i++) {\n        Class cls = classes[i].cls;\n        load_method_t load_method = (load_method_t)classes[i].method;\n        if (!cls) continue; \n\n        if (PrintLoading) {\n            _objc_inform(\"LOAD: +[%s load]\\n\", cls->nameForLogging());\n        }\n        /// 意为直接通过函数指针调用函数\n        (*load_method)(cls, @selector(load));\n    }\n    \n    // Destroy the detached list.\n    if (classes) free(classes);\n}\n```\n\n\n\n### load方法的调用顺序\n\n综上所述，分类也有load方法。调用顺序是：先调用父类load方法，再调用子类load方法，最后调用分类的load方法，如果有多个分类，那么先编译的，先调用。\n\n\n所以上述Demo代码执行后输出结果为\n\n```\nPerson load\nStudent load\nPerson Test load\nStudent Test load\n```\n\n这里Person比Student先调用是因为他是父类，Person(Test)比Student(Test)先调用是因为它先编译\n\n### 综上所述\n\n于是我们可以解答下面的问题\n\n1. 类和分类都有+load方法\n2. 根据编译顺序，先调用父类+load，再调用子类+load，再调用分类+load(看编译顺序)\n3. 因为系统调用load方法时不通过消息发送机制，所以不存在子类load方法覆盖父类load方法的情况，但是，如果手动调用load方法（即通过消息发送机制调用方法），那么这时候就有继承的现象发生了，也就是子类会覆盖父类方法的实现。\n\n搞点复杂的事情\n\n1. 父类实现，父类分类实现，子类不实现，子类分类实现<br/>\n\t顺序：父类load，子类分类load、父类分类load<br/>\n    原因：本来应该调用子类load的，无奈子类load没实现，但是找到了子类分类，那么就调用子类分类的load，最后在调用父类分类load(因为分类要最晚调用，由于刚才子类分类被调用过了，所以这里没它事了)<br/>\n    **所以：不一定主类的load方法总比分类的load方法早调用，存在特殊情况**<br/><br/>\n2. 父类不实现，父类分类实现，子类实现，子类分类实现<br/>\n\t顺序：父类分类load，子类load，子类分类load<br/>\n    原因：跟上面的理由是一样的，父类没实现但是父类分类找到了那么就调用<br/>\n    **所以：父类的分类的load也可以比子类load方法早调用**\n    \n## initialize方法\n\n\n### 先写个Demo\n\n\n父类：实现initialize方法\n\n```\n@implementation Person\n\n+ (void)initialize {\n    NSLog(@\"Person initialize\");\n}\n\n@end\n```\n\n父类的分类：实现initialize方法\n\n```\n@implementation Person(Test)\n\n+ (void)initialize {\n    NSLog(@\"Person Text initialize\");\n}\n\n@end\n\n```\n\n子类：实现initialize方法\n\n```\n@implementation Student\n\n+ (void)initialize {\n    NSLog(@\"Student initialize\");\n}\n\n@end\n\n```\n\n子类的分类：实现initialize方法\n\n```\n@implementation Student(Test)\n\n+ (void)initialize {\n    NSLog(@\"Student Test initialize\");\n}\n\n@end\n```\n\n### initialize方法的调用时机\n\n- `+initialize`会在类第一次接受到消息的时候调用，即`objc_msgSend()`被触发的时候调用，这部分是汇编实现\n\n- runtime源码里面有一个`class_getInstanceMethod()`函数，用于查找方法，当找到要调用的方法之后，就会调用`initialize`方法，`class_getInstanceMethod()`内的主要实现为`lookUpImpOrForward()`函数的调用\n\n```\n/***********************************************************************\n* class_getInstanceMethod.  Return the instance method for the\n* specified class and selector.\n**********************************************************************/\nMethod class_getInstanceMethod(Class cls, SEL sel)\n{\n    if (!cls  ||  !sel) return nil;\n\n    // This deliberately avoids +initialize because it historically did so.\n\n    // This implementation is a bit weird because it's the only place that \n    // wants a Method instead of an IMP.\n\n    Method meth;\n    meth = _cache_getMethod(cls, sel, _objc_msgForward_impcache);\n    if (meth == (Method)1) {\n        // Cache contains forward:: . Stop searching.\n        return nil;\n    } else if (meth) {\n        return meth;\n    }\n        \n    // Search method lists, try method resolver, etc.\n    lookUpImpOrForward(nil, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER);\n\n    meth = _cache_getMethod(cls, sel, _objc_msgForward_impcache);\n    if (meth == (Method)1) {\n        // Cache contains forward:: . Stop searching.\n        return nil;\n    } else if (meth) {\n        return meth;\n    }\n\n    return _class_getMethod(cls, sel);\n}\n```\n\n- `lookUpImpOrForward()`函数实现内，有一判断条件为`if(slowpath(!cls->isInitialized())) { ... }` ，若该类已经调用过`+initialize`，那么就不会再调用，这就是`+initialize`只被系统调用一次的原因\n\n- 经过一层层点击方法实现（流程见补充），最终我们可以在`objc-initialize.mm`内发现函数`callInitialize(Class cls)`，内部实现是`objc_msgSend`，如下\n\n```\n  void callInitialize(Class cls)\n{\n    ((void(*)(Class, SEL))objc_msgSend)(cls, @selector(initialize));\n    asm(\"\");\n}\n```\n\n> 补充：函数调用路径为`lookUpImpOrForward`->`realizeAndInitializeIfNeeded_locked`->`initializeAndLeaveLocked`->`initializeAndMaybeRelock`->`initializeNonMetaClass`->`callInitialize`<br/>其中：`initializeNonMetaClass`函数实现内有一个递归，不断地传入`superclass`指针，去调用父类的`initialize`方法，直到`superclass`指针为空（或已经调用过`initialize`）为止，这就是先调用父类的`initialize`方法的原因\n  \n\n### initialize方法的调用顺序\n\n- 先调用父类的`initialize`方法，再调用子类的`initialize`\n\n\n### 综上所述\n\n1. `initialize`是通过`objc_msgSend`方式调用的，所以会受分类、继承等等因素影响调用\n2. 如果子类没有实现`+initialize`，会调用父类的`+initiailize`（所以父类的`+initialize`可能会被调用多次）\n3. 如果分类实现了`+initialize`，就会覆盖主类的`+initialize`调用\n\n\n## 关联对象\n\n\n假如我们要给一个类添加一个属性如下：<br>\n`@property (copy, nonatomic) NSString *test;`\n\n\n### 存值\n\n\n```\nOBJC_EXPORT void\nobjc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,\n                         id _Nullable value, objc_AssociationPolicy policy)\n``` \n\n|参数名|解释|\n|---|---|\n|object|要关联的对象，如果是在分类内给主类添加属性，那么这里就写`self`|\n|key|要用来标记这个属性的key，取值的时候也得靠这个key取|\n|value|存储的内容|\n|policy|存储策略（见下表）|\n\n#### objc_AssociationPolicy 存储策略\n\n|策略枚举|对应修饰符|\n|---|---|\n|OBJC_ASSOCIATION_ASSIGN|assign|\n|OBJC_ASSOCIATION_RETAIN_NONATOMIC|strong, nonatomic|\n|OBJC_ASSOCIATION_COPY_NONATOMIC|copy,nonatomic|\n|OBJC_ASSOCIATION_RETAIN|strong, atomic|\n|OBJC_ASSOCIATION_COPY|copy,atomic|\n\n> 如果要存weak类型的对象怎么办？<br/>创建一个类，用`OBJC_ASSOCIATION_RETAIN_NONATOMIC`标记存在主类中，然后在这个新建的类里面再存放一个weak引用的属性\n\n#### key有多少种填写形式\n\n  1. 声明全局变量`static const void *TestKey = &TestKey;`,将`TestKey`的地址作为key的内容，不能直接写`const void *TestKey`，因为这么写等共同于`const void *TestKey = NULL`，要是以后添加别的属性，就会冲突，使用例子：\n  \n  ```\n  objc_setAssociatedObject(self,TestKey,test,OBJC_ASSOCIATION_COPY_NONATOMIC)\n  ```\n  \n  2. 声明全局变量`static const char TestKey`，同样将`TestKey`的地址作为key，好处是`char`只占用一个字节的内存大小，使用例子：\n  \n  ```\n  objc_setAssociatedObject(self,&TestKey,test,OBJC_ASSOCIATION_COPY_NONATOMIC)\n  ```\n  \n  3. 因为OC内的字符串都存在常量区，所以通过字面量创建的相同字符串都是同个地址，所以我们也可以随便定义一个字符串去做key，使用例子：\n  \n  ```\n  objc_setAssociatedObject(self,@\"Test\",test,OBJC_ASSOCIATION_COPY_NONATOMIC)\n  ```\n  \n  4. 我们也可以通过使用getter方法的方法编号去做key，使用例子：\n  \n  ```\n  objc_setAssociatedObject(self,@selector(test),test,OBJC_ASSOCIATION_COPY_NONATOMIC)\n  ```\n  \n### 取值\n\n```\nOBJC_EXPORT id _Nullable\nobjc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key);\n``` \n\n\n- object同上，一般分类里面就填self\n- key属性需要和上面设值的key属性一致\n\n\n- 如果使用getter方法的方法编号去做key，有两种写法\n\t1. `objc_getAssociatedObject(self, @selector(test))`\n    2. `objc_getAssociatedObject(self, _cmd)`，`_cmd`表示当前方法的方法地址\n    \n    \n### 底层实现\n\n![图片来源自小码哥教程](https://www.hualigs.cn/image/60bd149eb55dc.jpg)\n\n- runtime维护着一个名为`AssociationsManager`的类\n- 类里面存放着一个字典，键是传入的对象（object参数），值是`ObjectAssociationMap`类的实例对象\n- `ObjectAssociationMap`是一个字典，键是传入的key参数，值是`ObjcAssociation`类的实例对象\n- `ObjcAssociation`有两个成员变量，`_policy`存放着传入的policy参数，`_value`存放着传入的value参数\n\n\n### 综上所述\n\n1. 关联对象并不是存储在被关联对象的内存中\n2. 关联对象存储在全局统一的`AssociationsManager`中\n3. 设置关联对象（object参数）为nil，就相当于是移除关联对象","source":"_posts/iOS-底层原理-Category、-load、-initialize和关联对象.md","raw":"title: iOS 底层原理 --- Category、+load、+initialize和关联对象\nauthor: Arclin\ntags:\n  - iOS\n  - 底层原理\ncategories:\n  - iOS\nabbrlink: 2397c268\ndate: 2021-06-06 22:24:00\n---\n本文简述iOS中分类的底层实现和load方法、initialize方法在类和分类中的调用特性，还有如何通过关联对象的方式给分类添加属性，以及关联对象的底层实现原理\n\n<!--more-->\n\n\n## 分类（Category）\n\n### 先写一个Demo\n\n新建一个命令行工程，在main.m中写几个类\n\n\n父类：写一个run方法\n\n```\n@interface Person : NSObject\n\n- (void)run;\n\n@end\n```\n\n父类的分类：写一个eat方法\n\n```\n@interface Person(Test) \n\n- (void)eat;\n\n@end\n\n```\n\n根据经验可知道，现在Peron对象拥有了run方法和eat方法\n\n### 分类的底层结构\n\n输入命令行\n\n`xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m`\n\n接下来同级目录下就会多出一个编译后的文件`main.cpp`，查看后发现`Person(Test) `分类被编译成了如下变量\n\n```\nstatic struct _category_t _OBJC_$_CATEGORY_Person_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = \n{\n\t\"Person\",\n\t0, // &OBJC_CLASS_$_Person,\n\t(const struct _method_list_t *)&_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Test,\n\t0,\n\t0,\n\t0,\n};\n```\n\n这个变量的类型是`static struct _category_t`，名字是`_OBJC_$_CATEGORY_Person_$_Test`，等于号后面是一个初始化结构体的过程，可以看到要实例化这个结构体需要6个参数，所以查看`_category_t`的结构如下\n\n```\nstruct _category_t {\n\tconst char *name; /// 原来的类的名字\n\tstruct _class_t *cls; /// 类对象\n\tconst struct _method_list_t *instance_methods; /// 实例方法数组\n\tconst struct _method_list_t *class_methods; /// 类方法数组\n\tconst struct _protocol_list_t *protocols; /// 遵循的协议数组\n\tconst struct _prop_list_t *properties; /// 属性数组\n};\n```\n\n由此可知，**分类可以定义实例方法，可以定义类方法，可以遵循协议，可以添加属性，但是不能添加成员变量！因为分类的结构里面没有存储成员变量的地方.**\n\n### 程序通过runtime动态将分类合并到类对象、元类对象中\n\n分类中的方法是在运行时才添加到类对象和元类对象中的，而不是编译的时候添加的，编译之后只是多了几个类型为`_category_t`的结构体变量。\n\n合并的过程可以在runtime源码（objc4-818.2）中`objc-runtime-new.mm`的`load_categories_nolock`函数中看到，这里不展开流程，直接说结论。\n\n合并过程是这样子的，首先我们知道原来的类（我们就叫他主类吧）对象是存放着成员方法的，主类的元类对象是放着类方法的，因为类对象和元类对象结构是一样的，所以我们就讨论成员方法就好了。\n\n其次呢，runtime先根据分类方法的数量在数组里面开辟空间，然后把分类方法塞到原来的成员方法数组的前端，这样子合并就完成了，其他类方法、协议、属性等数组，也是同样的过程。\n\n所以最后在**类对象的方法列表数组里面，排在前面的是分类方法，后面才是主类的方法。如果有多个分类的话，那么后编译的分类的成员方法会插在数组的前面（因为插入数组的时候是倒序插入）**。\n\n有了上述结论 我们就可以解释很多事情了。\n\n#### 如果分类实现了主类的方法会怎么样\n\n根据上述结论，系统在找对应的调用方法的时候，会先找到分类的方法，所以主类的方法没有机会被调用到。\n\n#### 如果多个分类都实现了同个主类的方法\n\n根据上述结论，后编译的分类的成员方法会插在方法列表的前面，所以谁后编译，就调用谁\n\n#### 如果子类或者子类的分类实现了父类的分类方法\n\n根据上述结论和结合我们以前所学知识，最后子类实例对象会去子类的类对象里面寻找方法并调用，使用`super`关键字调用方法的话，则会去到父类的类对象内找方法。\n\n### Category跟Class Extension的区别\n\n- Class Extension是编译的时候，它的数据就已经包含在类信息中\n- Category 是在运行时才会讲数据合并到类信息中\n\n\n## load方法\n\n\n### 先写一个Demo\n\n\n父类：实现load方法\n\n```\n@implementation Person\n\n+ (void)load {\n    NSLog(@\"Person load\");\n}\n\n@end\n```\n\n父类的分类：实现load方法\n\n```\n@implementation Person(Test)\n\n+ (void)load {\n    NSLog(@\"Person Text load\");\n}\n\n@end\n\n```\n\n子类：实现load方法\n\n```\n@implementation Student\n\n+ (void)load {\n    NSLog(@\"Student load\");\n}\n\n@end\n\n```\n\n子类的分类：实现load方法\n\n```\n@implementation Student(Test)\n\n+ (void)load {\n    NSLog(@\"Student Test load\");\n}\n\n@end\n```\n\n### load方法的调用时机\n\n通过runtime源码（objc4-818.2）`objc-runtime-new.mm`第3233行得知，load方法是在加载镜像(load_images)的时候调用的。\n\n```\nvoid load_images(const char *path __unused, const struct mach_header *mh)\n{\n    if (!didInitialAttachCategories && didCallDyldNotifyRegister) {\n        didInitialAttachCategories = true;\n        loadAllCategories();\n    }\n\n    // Return without taking locks if there are no +load methods here.\n    if (!hasLoadMethods((const headerType *)mh)) return;\n\n    recursive_mutex_locker_t lock(loadMethodLock);\n\n    // Discover load methods\n    {\n        mutex_locker_t lock2(runtimeLock);\n        prepare_load_methods((const headerType *)mh);\n    }\n\n    // Call +load methods (without runtimeLock - re-entrant)\n    call_load_methods();\n}\n\n```\n\n> 补充小细节：从`load_images`函数可以看到，加载分类`loadAllCategories()`早于调用load方法`call_load_methods()`，也就是元类对象中的类方法列表内，分类的load方法会在主类的load方法之前\n\n在调用load方法之前，首先要通过`prepare_load_methods`函数整理出一个数组，这个数组会决定主类的load方法的调用顺序\n\n从`prepare_load_methods`函数中调用的`schedule_class_load`函数的内部实现我们可以知道，父类会先被加入到数组中，其次才是主类。\n\n```\n/***********************************************************************\n* prepare_load_methods\n* Schedule +load for classes in this image, any un-+load-ed \n* superclasses in other images, and any categories in this image.\n**********************************************************************/\n// Recursively schedule +load for cls and any un-+load-ed superclasses.\n// cls must already be connected.\nstatic void schedule_class_load(Class cls)\n{\n    if (!cls) return;\n    ASSERT(cls->isRealized());  // _read_images should realize\n\n    if (cls->data()->flags & RW_LOADED) return;\n\n    // Ensure superclass-first ordering\n    schedule_class_load(cls->getSuperclass());\n\n    add_class_to_loadable_list(cls);\n    cls->setInfo(RW_LOADED); \n}\n```\n\n然后我们回到最开始的地方（load_images），通过`objc-loadmethod.mm`第337行`call_load_methods`得知，先调用主类的load方法(call_class_loads())，再调用分类的load方法`call_category_loads();`\n\n\n> 补充一个小细节：在整理数组的时候，这个数组里面存放的是一个个结构体，结构体长这样\n\n  ```\n  struct loadable_class {\n      Class cls;  // may be nil  这里放元类对象（load是类方法所以存在元类对象里面）\n      IMP method;  /// 这里放的是load方法的函数指针\n  };\n\n  struct loadable_category {\n      Category cat;  // may be nil 这个是上面讲到的category_t类型的对象\n      IMP method; /// 这里放的是load方法的函数指针\n  };\n  ```\n  \n注意：runtime代码内有记录类的load方法是否曾经被加入到load数组过（RW_LOADED），如果被调用过了，就会跳过，这就是load方法只会执行一次的原因（但是你要是非要手动调用load方法那还是会执行的）\n  \n**重要：系统调用load方法不通过消息发送机制**，可以查看`objc-loadmethod.mm`第177行如下\n\n```\n/***********************************************************************\n* call_class_loads\n* Call all pending class +load methods.\n* If new classes become loadable, +load is NOT called for them.\n*\n* Called only by call_load_methods().\n**********************************************************************/\nstatic void call_class_loads(void)\n{\n    int i;\n    \n    // Detach current loadable list.\n    struct loadable_class *classes = loadable_classes;\n    int used = loadable_classes_used;\n    loadable_classes = nil;\n    loadable_classes_allocated = 0;\n    loadable_classes_used = 0;\n    \n    // Call all +loads for the detached list.\n    for (i = 0; i < used; i++) {\n        Class cls = classes[i].cls;\n        load_method_t load_method = (load_method_t)classes[i].method;\n        if (!cls) continue; \n\n        if (PrintLoading) {\n            _objc_inform(\"LOAD: +[%s load]\\n\", cls->nameForLogging());\n        }\n        /// 意为直接通过函数指针调用函数\n        (*load_method)(cls, @selector(load));\n    }\n    \n    // Destroy the detached list.\n    if (classes) free(classes);\n}\n```\n\n\n\n### load方法的调用顺序\n\n综上所述，分类也有load方法。调用顺序是：先调用父类load方法，再调用子类load方法，最后调用分类的load方法，如果有多个分类，那么先编译的，先调用。\n\n\n所以上述Demo代码执行后输出结果为\n\n```\nPerson load\nStudent load\nPerson Test load\nStudent Test load\n```\n\n这里Person比Student先调用是因为他是父类，Person(Test)比Student(Test)先调用是因为它先编译\n\n### 综上所述\n\n于是我们可以解答下面的问题\n\n1. 类和分类都有+load方法\n2. 根据编译顺序，先调用父类+load，再调用子类+load，再调用分类+load(看编译顺序)\n3. 因为系统调用load方法时不通过消息发送机制，所以不存在子类load方法覆盖父类load方法的情况，但是，如果手动调用load方法（即通过消息发送机制调用方法），那么这时候就有继承的现象发生了，也就是子类会覆盖父类方法的实现。\n\n搞点复杂的事情\n\n1. 父类实现，父类分类实现，子类不实现，子类分类实现<br/>\n\t顺序：父类load，子类分类load、父类分类load<br/>\n    原因：本来应该调用子类load的，无奈子类load没实现，但是找到了子类分类，那么就调用子类分类的load，最后在调用父类分类load(因为分类要最晚调用，由于刚才子类分类被调用过了，所以这里没它事了)<br/>\n    **所以：不一定主类的load方法总比分类的load方法早调用，存在特殊情况**<br/><br/>\n2. 父类不实现，父类分类实现，子类实现，子类分类实现<br/>\n\t顺序：父类分类load，子类load，子类分类load<br/>\n    原因：跟上面的理由是一样的，父类没实现但是父类分类找到了那么就调用<br/>\n    **所以：父类的分类的load也可以比子类load方法早调用**\n    \n## initialize方法\n\n\n### 先写个Demo\n\n\n父类：实现initialize方法\n\n```\n@implementation Person\n\n+ (void)initialize {\n    NSLog(@\"Person initialize\");\n}\n\n@end\n```\n\n父类的分类：实现initialize方法\n\n```\n@implementation Person(Test)\n\n+ (void)initialize {\n    NSLog(@\"Person Text initialize\");\n}\n\n@end\n\n```\n\n子类：实现initialize方法\n\n```\n@implementation Student\n\n+ (void)initialize {\n    NSLog(@\"Student initialize\");\n}\n\n@end\n\n```\n\n子类的分类：实现initialize方法\n\n```\n@implementation Student(Test)\n\n+ (void)initialize {\n    NSLog(@\"Student Test initialize\");\n}\n\n@end\n```\n\n### initialize方法的调用时机\n\n- `+initialize`会在类第一次接受到消息的时候调用，即`objc_msgSend()`被触发的时候调用，这部分是汇编实现\n\n- runtime源码里面有一个`class_getInstanceMethod()`函数，用于查找方法，当找到要调用的方法之后，就会调用`initialize`方法，`class_getInstanceMethod()`内的主要实现为`lookUpImpOrForward()`函数的调用\n\n```\n/***********************************************************************\n* class_getInstanceMethod.  Return the instance method for the\n* specified class and selector.\n**********************************************************************/\nMethod class_getInstanceMethod(Class cls, SEL sel)\n{\n    if (!cls  ||  !sel) return nil;\n\n    // This deliberately avoids +initialize because it historically did so.\n\n    // This implementation is a bit weird because it's the only place that \n    // wants a Method instead of an IMP.\n\n    Method meth;\n    meth = _cache_getMethod(cls, sel, _objc_msgForward_impcache);\n    if (meth == (Method)1) {\n        // Cache contains forward:: . Stop searching.\n        return nil;\n    } else if (meth) {\n        return meth;\n    }\n        \n    // Search method lists, try method resolver, etc.\n    lookUpImpOrForward(nil, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER);\n\n    meth = _cache_getMethod(cls, sel, _objc_msgForward_impcache);\n    if (meth == (Method)1) {\n        // Cache contains forward:: . Stop searching.\n        return nil;\n    } else if (meth) {\n        return meth;\n    }\n\n    return _class_getMethod(cls, sel);\n}\n```\n\n- `lookUpImpOrForward()`函数实现内，有一判断条件为`if(slowpath(!cls->isInitialized())) { ... }` ，若该类已经调用过`+initialize`，那么就不会再调用，这就是`+initialize`只被系统调用一次的原因\n\n- 经过一层层点击方法实现（流程见补充），最终我们可以在`objc-initialize.mm`内发现函数`callInitialize(Class cls)`，内部实现是`objc_msgSend`，如下\n\n```\n  void callInitialize(Class cls)\n{\n    ((void(*)(Class, SEL))objc_msgSend)(cls, @selector(initialize));\n    asm(\"\");\n}\n```\n\n> 补充：函数调用路径为`lookUpImpOrForward`->`realizeAndInitializeIfNeeded_locked`->`initializeAndLeaveLocked`->`initializeAndMaybeRelock`->`initializeNonMetaClass`->`callInitialize`<br/>其中：`initializeNonMetaClass`函数实现内有一个递归，不断地传入`superclass`指针，去调用父类的`initialize`方法，直到`superclass`指针为空（或已经调用过`initialize`）为止，这就是先调用父类的`initialize`方法的原因\n  \n\n### initialize方法的调用顺序\n\n- 先调用父类的`initialize`方法，再调用子类的`initialize`\n\n\n### 综上所述\n\n1. `initialize`是通过`objc_msgSend`方式调用的，所以会受分类、继承等等因素影响调用\n2. 如果子类没有实现`+initialize`，会调用父类的`+initiailize`（所以父类的`+initialize`可能会被调用多次）\n3. 如果分类实现了`+initialize`，就会覆盖主类的`+initialize`调用\n\n\n## 关联对象\n\n\n假如我们要给一个类添加一个属性如下：<br>\n`@property (copy, nonatomic) NSString *test;`\n\n\n### 存值\n\n\n```\nOBJC_EXPORT void\nobjc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,\n                         id _Nullable value, objc_AssociationPolicy policy)\n``` \n\n|参数名|解释|\n|---|---|\n|object|要关联的对象，如果是在分类内给主类添加属性，那么这里就写`self`|\n|key|要用来标记这个属性的key，取值的时候也得靠这个key取|\n|value|存储的内容|\n|policy|存储策略（见下表）|\n\n#### objc_AssociationPolicy 存储策略\n\n|策略枚举|对应修饰符|\n|---|---|\n|OBJC_ASSOCIATION_ASSIGN|assign|\n|OBJC_ASSOCIATION_RETAIN_NONATOMIC|strong, nonatomic|\n|OBJC_ASSOCIATION_COPY_NONATOMIC|copy,nonatomic|\n|OBJC_ASSOCIATION_RETAIN|strong, atomic|\n|OBJC_ASSOCIATION_COPY|copy,atomic|\n\n> 如果要存weak类型的对象怎么办？<br/>创建一个类，用`OBJC_ASSOCIATION_RETAIN_NONATOMIC`标记存在主类中，然后在这个新建的类里面再存放一个weak引用的属性\n\n#### key有多少种填写形式\n\n  1. 声明全局变量`static const void *TestKey = &TestKey;`,将`TestKey`的地址作为key的内容，不能直接写`const void *TestKey`，因为这么写等共同于`const void *TestKey = NULL`，要是以后添加别的属性，就会冲突，使用例子：\n  \n  ```\n  objc_setAssociatedObject(self,TestKey,test,OBJC_ASSOCIATION_COPY_NONATOMIC)\n  ```\n  \n  2. 声明全局变量`static const char TestKey`，同样将`TestKey`的地址作为key，好处是`char`只占用一个字节的内存大小，使用例子：\n  \n  ```\n  objc_setAssociatedObject(self,&TestKey,test,OBJC_ASSOCIATION_COPY_NONATOMIC)\n  ```\n  \n  3. 因为OC内的字符串都存在常量区，所以通过字面量创建的相同字符串都是同个地址，所以我们也可以随便定义一个字符串去做key，使用例子：\n  \n  ```\n  objc_setAssociatedObject(self,@\"Test\",test,OBJC_ASSOCIATION_COPY_NONATOMIC)\n  ```\n  \n  4. 我们也可以通过使用getter方法的方法编号去做key，使用例子：\n  \n  ```\n  objc_setAssociatedObject(self,@selector(test),test,OBJC_ASSOCIATION_COPY_NONATOMIC)\n  ```\n  \n### 取值\n\n```\nOBJC_EXPORT id _Nullable\nobjc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key);\n``` \n\n\n- object同上，一般分类里面就填self\n- key属性需要和上面设值的key属性一致\n\n\n- 如果使用getter方法的方法编号去做key，有两种写法\n\t1. `objc_getAssociatedObject(self, @selector(test))`\n    2. `objc_getAssociatedObject(self, _cmd)`，`_cmd`表示当前方法的方法地址\n    \n    \n### 底层实现\n\n![图片来源自小码哥教程](https://www.hualigs.cn/image/60bd149eb55dc.jpg)\n\n- runtime维护着一个名为`AssociationsManager`的类\n- 类里面存放着一个字典，键是传入的对象（object参数），值是`ObjectAssociationMap`类的实例对象\n- `ObjectAssociationMap`是一个字典，键是传入的key参数，值是`ObjcAssociation`类的实例对象\n- `ObjcAssociation`有两个成员变量，`_policy`存放着传入的policy参数，`_value`存放着传入的value参数\n\n\n### 综上所述\n\n1. 关联对象并不是存储在被关联对象的内存中\n2. 关联对象存储在全局统一的`AssociationsManager`中\n3. 设置关联对象（object参数）为nil，就相当于是移除关联对象","slug":"iOS-底层原理-Category、-load、-initialize和关联对象","published":1,"updated":"2021-06-07T15:48:08.999Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoho003btnn0fboba6qb","content":"<p>本文简述iOS中分类的底层实现和load方法、initialize方法在类和分类中的调用特性，还有如何通过关联对象的方式给分类添加属性，以及关联对象的底层实现原理</p>\n<span id=\"more\"></span>\n\n\n<h2 id=\"分类（Category）\"><a href=\"#分类（Category）\" class=\"headerlink\" title=\"分类（Category）\"></a>分类（Category）</h2><h3 id=\"先写一个Demo\"><a href=\"#先写一个Demo\" class=\"headerlink\" title=\"先写一个Demo\"></a>先写一个Demo</h3><p>新建一个命令行工程，在main.m中写几个类</p>\n<p>父类：写一个run方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Person : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)run;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>父类的分类：写一个eat方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Person(Test) </span><br><span class=\"line\"></span><br><span class=\"line\">- (void)eat;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>根据经验可知道，现在Peron对象拥有了run方法和eat方法</p>\n<h3 id=\"分类的底层结构\"><a href=\"#分类的底层结构\" class=\"headerlink\" title=\"分类的底层结构\"></a>分类的底层结构</h3><p>输入命令行</p>\n<p><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code></p>\n<p>接下来同级目录下就会多出一个编译后的文件<code>main.cpp</code>，查看后发现<code>Person(Test) </code>分类被编译成了如下变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static struct _category_t _OBJC_$_CATEGORY_Person_$_Test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) &#x3D; </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;Person&quot;,</span><br><span class=\"line\">\t0, &#x2F;&#x2F; &amp;OBJC_CLASS_$_Person,</span><br><span class=\"line\">\t(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Test,</span><br><span class=\"line\">\t0,</span><br><span class=\"line\">\t0,</span><br><span class=\"line\">\t0,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这个变量的类型是<code>static struct _category_t</code>，名字是<code>_OBJC_$_CATEGORY_Person_$_Test</code>，等于号后面是一个初始化结构体的过程，可以看到要实例化这个结构体需要6个参数，所以查看<code>_category_t</code>的结构如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct _category_t &#123;</span><br><span class=\"line\">\tconst char *name; &#x2F;&#x2F;&#x2F; 原来的类的名字</span><br><span class=\"line\">\tstruct _class_t *cls; &#x2F;&#x2F;&#x2F; 类对象</span><br><span class=\"line\">\tconst struct _method_list_t *instance_methods; &#x2F;&#x2F;&#x2F; 实例方法数组</span><br><span class=\"line\">\tconst struct _method_list_t *class_methods; &#x2F;&#x2F;&#x2F; 类方法数组</span><br><span class=\"line\">\tconst struct _protocol_list_t *protocols; &#x2F;&#x2F;&#x2F; 遵循的协议数组</span><br><span class=\"line\">\tconst struct _prop_list_t *properties; &#x2F;&#x2F;&#x2F; 属性数组</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>由此可知，<strong>分类可以定义实例方法，可以定义类方法，可以遵循协议，可以添加属性，但是不能添加成员变量！因为分类的结构里面没有存储成员变量的地方.</strong></p>\n<h3 id=\"程序通过runtime动态将分类合并到类对象、元类对象中\"><a href=\"#程序通过runtime动态将分类合并到类对象、元类对象中\" class=\"headerlink\" title=\"程序通过runtime动态将分类合并到类对象、元类对象中\"></a>程序通过runtime动态将分类合并到类对象、元类对象中</h3><p>分类中的方法是在运行时才添加到类对象和元类对象中的，而不是编译的时候添加的，编译之后只是多了几个类型为<code>_category_t</code>的结构体变量。</p>\n<p>合并的过程可以在runtime源码（objc4-818.2）中<code>objc-runtime-new.mm</code>的<code>load_categories_nolock</code>函数中看到，这里不展开流程，直接说结论。</p>\n<p>合并过程是这样子的，首先我们知道原来的类（我们就叫他主类吧）对象是存放着成员方法的，主类的元类对象是放着类方法的，因为类对象和元类对象结构是一样的，所以我们就讨论成员方法就好了。</p>\n<p>其次呢，runtime先根据分类方法的数量在数组里面开辟空间，然后把分类方法塞到原来的成员方法数组的前端，这样子合并就完成了，其他类方法、协议、属性等数组，也是同样的过程。</p>\n<p>所以最后在<strong>类对象的方法列表数组里面，排在前面的是分类方法，后面才是主类的方法。如果有多个分类的话，那么后编译的分类的成员方法会插在数组的前面（因为插入数组的时候是倒序插入）</strong>。</p>\n<p>有了上述结论 我们就可以解释很多事情了。</p>\n<h4 id=\"如果分类实现了主类的方法会怎么样\"><a href=\"#如果分类实现了主类的方法会怎么样\" class=\"headerlink\" title=\"如果分类实现了主类的方法会怎么样\"></a>如果分类实现了主类的方法会怎么样</h4><p>根据上述结论，系统在找对应的调用方法的时候，会先找到分类的方法，所以主类的方法没有机会被调用到。</p>\n<h4 id=\"如果多个分类都实现了同个主类的方法\"><a href=\"#如果多个分类都实现了同个主类的方法\" class=\"headerlink\" title=\"如果多个分类都实现了同个主类的方法\"></a>如果多个分类都实现了同个主类的方法</h4><p>根据上述结论，后编译的分类的成员方法会插在方法列表的前面，所以谁后编译，就调用谁</p>\n<h4 id=\"如果子类或者子类的分类实现了父类的分类方法\"><a href=\"#如果子类或者子类的分类实现了父类的分类方法\" class=\"headerlink\" title=\"如果子类或者子类的分类实现了父类的分类方法\"></a>如果子类或者子类的分类实现了父类的分类方法</h4><p>根据上述结论和结合我们以前所学知识，最后子类实例对象会去子类的类对象里面寻找方法并调用，使用<code>super</code>关键字调用方法的话，则会去到父类的类对象内找方法。</p>\n<h3 id=\"Category跟Class-Extension的区别\"><a href=\"#Category跟Class-Extension的区别\" class=\"headerlink\" title=\"Category跟Class Extension的区别\"></a>Category跟Class Extension的区别</h3><ul>\n<li>Class Extension是编译的时候，它的数据就已经包含在类信息中</li>\n<li>Category 是在运行时才会讲数据合并到类信息中</li>\n</ul>\n<h2 id=\"load方法\"><a href=\"#load方法\" class=\"headerlink\" title=\"load方法\"></a>load方法</h2><h3 id=\"先写一个Demo-1\"><a href=\"#先写一个Demo-1\" class=\"headerlink\" title=\"先写一个Demo\"></a>先写一个Demo</h3><p>父类：实现load方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Person</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    NSLog(@&quot;Person load&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>父类的分类：实现load方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Person(Test)</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    NSLog(@&quot;Person Text load&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>子类：实现load方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Student</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    NSLog(@&quot;Student load&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>子类的分类：实现load方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Student(Test)</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    NSLog(@&quot;Student Test load&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"load方法的调用时机\"><a href=\"#load方法的调用时机\" class=\"headerlink\" title=\"load方法的调用时机\"></a>load方法的调用时机</h3><p>通过runtime源码（objc4-818.2）<code>objc-runtime-new.mm</code>第3233行得知，load方法是在加载镜像(load_images)的时候调用的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;</span><br><span class=\"line\">        didInitialAttachCategories &#x3D; true;</span><br><span class=\"line\">        loadAllCategories();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Return without taking locks if there are no +load methods here.</span><br><span class=\"line\">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class=\"line\"></span><br><span class=\"line\">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Discover load methods</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        mutex_locker_t lock2(runtimeLock);</span><br><span class=\"line\">        prepare_load_methods((const headerType *)mh);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Call +load methods (without runtimeLock - re-entrant)</span><br><span class=\"line\">    call_load_methods();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>补充小细节：从<code>load_images</code>函数可以看到，加载分类<code>loadAllCategories()</code>早于调用load方法<code>call_load_methods()</code>，也就是元类对象中的类方法列表内，分类的load方法会在主类的load方法之前</p>\n</blockquote>\n<p>在调用load方法之前，首先要通过<code>prepare_load_methods</code>函数整理出一个数组，这个数组会决定主类的load方法的调用顺序</p>\n<p>从<code>prepare_load_methods</code>函数中调用的<code>schedule_class_load</code>函数的内部实现我们可以知道，父类会先被加入到数组中，其次才是主类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;***********************************************************************</span><br><span class=\"line\">* prepare_load_methods</span><br><span class=\"line\">* Schedule +load for classes in this image, any un-+load-ed </span><br><span class=\"line\">* superclasses in other images, and any categories in this image.</span><br><span class=\"line\">**********************************************************************&#x2F;</span><br><span class=\"line\">&#x2F;&#x2F; Recursively schedule +load for cls and any un-+load-ed superclasses.</span><br><span class=\"line\">&#x2F;&#x2F; cls must already be connected.</span><br><span class=\"line\">static void schedule_class_load(Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!cls) return;</span><br><span class=\"line\">    ASSERT(cls-&gt;isRealized());  &#x2F;&#x2F; _read_images should realize</span><br><span class=\"line\"></span><br><span class=\"line\">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Ensure superclass-first ordering</span><br><span class=\"line\">    schedule_class_load(cls-&gt;getSuperclass());</span><br><span class=\"line\"></span><br><span class=\"line\">    add_class_to_loadable_list(cls);</span><br><span class=\"line\">    cls-&gt;setInfo(RW_LOADED); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们回到最开始的地方（load_images），通过<code>objc-loadmethod.mm</code>第337行<code>call_load_methods</code>得知，先调用主类的load方法(call_class_loads())，再调用分类的load方法<code>call_category_loads();</code></p>\n<blockquote>\n<p>补充一个小细节：在整理数组的时候，这个数组里面存放的是一个个结构体，结构体长这样</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct loadable_class &#123;</span><br><span class=\"line\">    Class cls;  &#x2F;&#x2F; may be nil  这里放元类对象（load是类方法所以存在元类对象里面）</span><br><span class=\"line\">    IMP method;  &#x2F;&#x2F;&#x2F; 这里放的是load方法的函数指针</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct loadable_category &#123;</span><br><span class=\"line\">    Category cat;  &#x2F;&#x2F; may be nil 这个是上面讲到的category_t类型的对象</span><br><span class=\"line\">    IMP method; &#x2F;&#x2F;&#x2F; 这里放的是load方法的函数指针</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意：runtime代码内有记录类的load方法是否曾经被加入到load数组过（RW_LOADED），如果被调用过了，就会跳过，这就是load方法只会执行一次的原因（但是你要是非要手动调用load方法那还是会执行的）</p>\n<p><strong>重要：系统调用load方法不通过消息发送机制</strong>，可以查看<code>objc-loadmethod.mm</code>第177行如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;***********************************************************************</span><br><span class=\"line\">* call_class_loads</span><br><span class=\"line\">* Call all pending class +load methods.</span><br><span class=\"line\">* If new classes become loadable, +load is NOT called for them.</span><br><span class=\"line\">*</span><br><span class=\"line\">* Called only by call_load_methods().</span><br><span class=\"line\">**********************************************************************&#x2F;</span><br><span class=\"line\">static void call_class_loads(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; Detach current loadable list.</span><br><span class=\"line\">    struct loadable_class *classes &#x3D; loadable_classes;</span><br><span class=\"line\">    int used &#x3D; loadable_classes_used;</span><br><span class=\"line\">    loadable_classes &#x3D; nil;</span><br><span class=\"line\">    loadable_classes_allocated &#x3D; 0;</span><br><span class=\"line\">    loadable_classes_used &#x3D; 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; Call all +loads for the detached list.</span><br><span class=\"line\">    for (i &#x3D; 0; i &lt; used; i++) &#123;</span><br><span class=\"line\">        Class cls &#x3D; classes[i].cls;</span><br><span class=\"line\">        load_method_t load_method &#x3D; (load_method_t)classes[i].method;</span><br><span class=\"line\">        if (!cls) continue; </span><br><span class=\"line\"></span><br><span class=\"line\">        if (PrintLoading) &#123;</span><br><span class=\"line\">            _objc_inform(&quot;LOAD: +[%s load]\\n&quot;, cls-&gt;nameForLogging());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;&#x2F; 意为直接通过函数指针调用函数</span><br><span class=\"line\">        (*load_method)(cls, @selector(load));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; Destroy the detached list.</span><br><span class=\"line\">    if (classes) free(classes);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"load方法的调用顺序\"><a href=\"#load方法的调用顺序\" class=\"headerlink\" title=\"load方法的调用顺序\"></a>load方法的调用顺序</h3><p>综上所述，分类也有load方法。调用顺序是：先调用父类load方法，再调用子类load方法，最后调用分类的load方法，如果有多个分类，那么先编译的，先调用。</p>\n<p>所以上述Demo代码执行后输出结果为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person load</span><br><span class=\"line\">Student load</span><br><span class=\"line\">Person Test load</span><br><span class=\"line\">Student Test load</span><br></pre></td></tr></table></figure>\n\n<p>这里Person比Student先调用是因为他是父类，Person(Test)比Student(Test)先调用是因为它先编译</p>\n<h3 id=\"综上所述\"><a href=\"#综上所述\" class=\"headerlink\" title=\"综上所述\"></a>综上所述</h3><p>于是我们可以解答下面的问题</p>\n<ol>\n<li>类和分类都有+load方法</li>\n<li>根据编译顺序，先调用父类+load，再调用子类+load，再调用分类+load(看编译顺序)</li>\n<li>因为系统调用load方法时不通过消息发送机制，所以不存在子类load方法覆盖父类load方法的情况，但是，如果手动调用load方法（即通过消息发送机制调用方法），那么这时候就有继承的现象发生了，也就是子类会覆盖父类方法的实现。</li>\n</ol>\n<p>搞点复杂的事情</p>\n<ol>\n<li>父类实现，父类分类实现，子类不实现，子类分类实现<br/><br> 顺序：父类load，子类分类load、父类分类load<br/><br> 原因：本来应该调用子类load的，无奈子类load没实现，但是找到了子类分类，那么就调用子类分类的load，最后在调用父类分类load(因为分类要最晚调用，由于刚才子类分类被调用过了，所以这里没它事了)<br/><br> <strong>所以：不一定主类的load方法总比分类的load方法早调用，存在特殊情况</strong><br/><br/></li>\n<li>父类不实现，父类分类实现，子类实现，子类分类实现<br/><br> 顺序：父类分类load，子类load，子类分类load<br/><br> 原因：跟上面的理由是一样的，父类没实现但是父类分类找到了那么就调用<br/><br> <strong>所以：父类的分类的load也可以比子类load方法早调用</strong></li>\n</ol>\n<h2 id=\"initialize方法\"><a href=\"#initialize方法\" class=\"headerlink\" title=\"initialize方法\"></a>initialize方法</h2><h3 id=\"先写个Demo\"><a href=\"#先写个Demo\" class=\"headerlink\" title=\"先写个Demo\"></a>先写个Demo</h3><p>父类：实现initialize方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Person</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)initialize &#123;</span><br><span class=\"line\">    NSLog(@&quot;Person initialize&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>父类的分类：实现initialize方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Person(Test)</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)initialize &#123;</span><br><span class=\"line\">    NSLog(@&quot;Person Text initialize&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>子类：实现initialize方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Student</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)initialize &#123;</span><br><span class=\"line\">    NSLog(@&quot;Student initialize&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>子类的分类：实现initialize方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Student(Test)</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)initialize &#123;</span><br><span class=\"line\">    NSLog(@&quot;Student Test initialize&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"initialize方法的调用时机\"><a href=\"#initialize方法的调用时机\" class=\"headerlink\" title=\"initialize方法的调用时机\"></a>initialize方法的调用时机</h3><ul>\n<li><p><code>+initialize</code>会在类第一次接受到消息的时候调用，即<code>objc_msgSend()</code>被触发的时候调用，这部分是汇编实现</p>\n</li>\n<li><p>runtime源码里面有一个<code>class_getInstanceMethod()</code>函数，用于查找方法，当找到要调用的方法之后，就会调用<code>initialize</code>方法，<code>class_getInstanceMethod()</code>内的主要实现为<code>lookUpImpOrForward()</code>函数的调用</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;***********************************************************************</span><br><span class=\"line\">* class_getInstanceMethod.  Return the instance method for the</span><br><span class=\"line\">* specified class and selector.</span><br><span class=\"line\">**********************************************************************&#x2F;</span><br><span class=\"line\">Method class_getInstanceMethod(Class cls, SEL sel)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!cls  ||  !sel) return nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; This deliberately avoids +initialize because it historically did so.</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; This implementation is a bit weird because it&#39;s the only place that </span><br><span class=\"line\">    &#x2F;&#x2F; wants a Method instead of an IMP.</span><br><span class=\"line\"></span><br><span class=\"line\">    Method meth;</span><br><span class=\"line\">    meth &#x3D; _cache_getMethod(cls, sel, _objc_msgForward_impcache);</span><br><span class=\"line\">    if (meth &#x3D;&#x3D; (Method)1) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; Cache contains forward:: . Stop searching.</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125; else if (meth) &#123;</span><br><span class=\"line\">        return meth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#x2F;&#x2F; Search method lists, try method resolver, etc.</span><br><span class=\"line\">    lookUpImpOrForward(nil, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER);</span><br><span class=\"line\"></span><br><span class=\"line\">    meth &#x3D; _cache_getMethod(cls, sel, _objc_msgForward_impcache);</span><br><span class=\"line\">    if (meth &#x3D;&#x3D; (Method)1) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; Cache contains forward:: . Stop searching.</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125; else if (meth) &#123;</span><br><span class=\"line\">        return meth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return _class_getMethod(cls, sel);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>lookUpImpOrForward()</code>函数实现内，有一判断条件为<code>if(slowpath(!cls-&gt;isInitialized())) &#123; ... &#125;</code> ，若该类已经调用过<code>+initialize</code>，那么就不会再调用，这就是<code>+initialize</code>只被系统调用一次的原因</p>\n</li>\n<li><p>经过一层层点击方法实现（流程见补充），最终我们可以在<code>objc-initialize.mm</code>内发现函数<code>callInitialize(Class cls)</code>，内部实现是<code>objc_msgSend</code>，如下</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  void callInitialize(Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ((void(*)(Class, SEL))objc_msgSend)(cls, @selector(initialize));</span><br><span class=\"line\">    asm(&quot;&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>补充：函数调用路径为<code>lookUpImpOrForward</code>-&gt;<code>realizeAndInitializeIfNeeded_locked</code>-&gt;<code>initializeAndLeaveLocked</code>-&gt;<code>initializeAndMaybeRelock</code>-&gt;<code>initializeNonMetaClass</code>-&gt;<code>callInitialize</code><br/>其中：<code>initializeNonMetaClass</code>函数实现内有一个递归，不断地传入<code>superclass</code>指针，去调用父类的<code>initialize</code>方法，直到<code>superclass</code>指针为空（或已经调用过<code>initialize</code>）为止，这就是先调用父类的<code>initialize</code>方法的原因</p>\n</blockquote>\n<h3 id=\"initialize方法的调用顺序\"><a href=\"#initialize方法的调用顺序\" class=\"headerlink\" title=\"initialize方法的调用顺序\"></a>initialize方法的调用顺序</h3><ul>\n<li>先调用父类的<code>initialize</code>方法，再调用子类的<code>initialize</code></li>\n</ul>\n<h3 id=\"综上所述-1\"><a href=\"#综上所述-1\" class=\"headerlink\" title=\"综上所述\"></a>综上所述</h3><ol>\n<li><code>initialize</code>是通过<code>objc_msgSend</code>方式调用的，所以会受分类、继承等等因素影响调用</li>\n<li>如果子类没有实现<code>+initialize</code>，会调用父类的<code>+initiailize</code>（所以父类的<code>+initialize</code>可能会被调用多次）</li>\n<li>如果分类实现了<code>+initialize</code>，就会覆盖主类的<code>+initialize</code>调用</li>\n</ol>\n<h2 id=\"关联对象\"><a href=\"#关联对象\" class=\"headerlink\" title=\"关联对象\"></a>关联对象</h2><p>假如我们要给一个类添加一个属性如下：<br><br><code>@property (copy, nonatomic) NSString *test;</code></p>\n<h3 id=\"存值\"><a href=\"#存值\" class=\"headerlink\" title=\"存值\"></a>存值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJC_EXPORT void</span><br><span class=\"line\">objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,</span><br><span class=\"line\">                         id _Nullable value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>object</td>\n<td>要关联的对象，如果是在分类内给主类添加属性，那么这里就写<code>self</code></td>\n</tr>\n<tr>\n<td>key</td>\n<td>要用来标记这个属性的key，取值的时候也得靠这个key取</td>\n</tr>\n<tr>\n<td>value</td>\n<td>存储的内容</td>\n</tr>\n<tr>\n<td>policy</td>\n<td>存储策略（见下表）</td>\n</tr>\n</tbody></table>\n<h4 id=\"objc-AssociationPolicy-存储策略\"><a href=\"#objc-AssociationPolicy-存储策略\" class=\"headerlink\" title=\"objc_AssociationPolicy 存储策略\"></a>objc_AssociationPolicy 存储策略</h4><table>\n<thead>\n<tr>\n<th>策略枚举</th>\n<th>对应修饰符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OBJC_ASSOCIATION_ASSIGN</td>\n<td>assign</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>\n<td>strong, nonatomic</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>\n<td>copy,nonatomic</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_RETAIN</td>\n<td>strong, atomic</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_COPY</td>\n<td>copy,atomic</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>如果要存weak类型的对象怎么办？<br/>创建一个类，用<code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code>标记存在主类中，然后在这个新建的类里面再存放一个weak引用的属性</p>\n</blockquote>\n<h4 id=\"key有多少种填写形式\"><a href=\"#key有多少种填写形式\" class=\"headerlink\" title=\"key有多少种填写形式\"></a>key有多少种填写形式</h4><ol>\n<li>声明全局变量<code>static const void *TestKey = &amp;TestKey;</code>,将<code>TestKey</code>的地址作为key的内容，不能直接写<code>const void *TestKey</code>，因为这么写等共同于<code>const void *TestKey = NULL</code>，要是以后添加别的属性，就会冲突，使用例子：</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_setAssociatedObject(self,TestKey,test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>声明全局变量<code>static const char TestKey</code>，同样将<code>TestKey</code>的地址作为key，好处是<code>char</code>只占用一个字节的内存大小，使用例子：</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_setAssociatedObject(self,&amp;TestKey,test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>因为OC内的字符串都存在常量区，所以通过字面量创建的相同字符串都是同个地址，所以我们也可以随便定义一个字符串去做key，使用例子：</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_setAssociatedObject(self,@&quot;Test&quot;,test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>我们也可以通过使用getter方法的方法编号去做key，使用例子：</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_setAssociatedObject(self,@selector(test),test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure>\n<h3 id=\"取值\"><a href=\"#取值\" class=\"headerlink\" title=\"取值\"></a>取值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJC_EXPORT id _Nullable</span><br><span class=\"line\">objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key);</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>object同上，一般分类里面就填self</li>\n<li>key属性需要和上面设值的key属性一致</li>\n</ul>\n<ul>\n<li>如果使用getter方法的方法编号去做key，有两种写法<ol>\n<li><code>objc_getAssociatedObject(self, @selector(test))</code></li>\n<li><code>objc_getAssociatedObject(self, _cmd)</code>，<code>_cmd</code>表示当前方法的方法地址</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"底层实现\"><a href=\"#底层实现\" class=\"headerlink\" title=\"底层实现\"></a>底层实现</h3><p><img src=\"https://www.hualigs.cn/image/60bd149eb55dc.jpg\" alt=\"图片来源自小码哥教程\"></p>\n<ul>\n<li>runtime维护着一个名为<code>AssociationsManager</code>的类</li>\n<li>类里面存放着一个字典，键是传入的对象（object参数），值是<code>ObjectAssociationMap</code>类的实例对象</li>\n<li><code>ObjectAssociationMap</code>是一个字典，键是传入的key参数，值是<code>ObjcAssociation</code>类的实例对象</li>\n<li><code>ObjcAssociation</code>有两个成员变量，<code>_policy</code>存放着传入的policy参数，<code>_value</code>存放着传入的value参数</li>\n</ul>\n<h3 id=\"综上所述-2\"><a href=\"#综上所述-2\" class=\"headerlink\" title=\"综上所述\"></a>综上所述</h3><ol>\n<li>关联对象并不是存储在被关联对象的内存中</li>\n<li>关联对象存储在全局统一的<code>AssociationsManager</code>中</li>\n<li>设置关联对象（object参数）为nil，就相当于是移除关联对象</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本文简述iOS中分类的底层实现和load方法、initialize方法在类和分类中的调用特性，还有如何通过关联对象的方式给分类添加属性，以及关联对象的底层实现原理</p>","more":"<h2 id=\"分类（Category）\"><a href=\"#分类（Category）\" class=\"headerlink\" title=\"分类（Category）\"></a>分类（Category）</h2><h3 id=\"先写一个Demo\"><a href=\"#先写一个Demo\" class=\"headerlink\" title=\"先写一个Demo\"></a>先写一个Demo</h3><p>新建一个命令行工程，在main.m中写几个类</p>\n<p>父类：写一个run方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Person : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)run;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>父类的分类：写一个eat方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Person(Test) </span><br><span class=\"line\"></span><br><span class=\"line\">- (void)eat;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>根据经验可知道，现在Peron对象拥有了run方法和eat方法</p>\n<h3 id=\"分类的底层结构\"><a href=\"#分类的底层结构\" class=\"headerlink\" title=\"分类的底层结构\"></a>分类的底层结构</h3><p>输入命令行</p>\n<p><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code></p>\n<p>接下来同级目录下就会多出一个编译后的文件<code>main.cpp</code>，查看后发现<code>Person(Test) </code>分类被编译成了如下变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static struct _category_t _OBJC_$_CATEGORY_Person_$_Test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) &#x3D; </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&quot;Person&quot;,</span><br><span class=\"line\">\t0, &#x2F;&#x2F; &amp;OBJC_CLASS_$_Person,</span><br><span class=\"line\">\t(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Test,</span><br><span class=\"line\">\t0,</span><br><span class=\"line\">\t0,</span><br><span class=\"line\">\t0,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这个变量的类型是<code>static struct _category_t</code>，名字是<code>_OBJC_$_CATEGORY_Person_$_Test</code>，等于号后面是一个初始化结构体的过程，可以看到要实例化这个结构体需要6个参数，所以查看<code>_category_t</code>的结构如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct _category_t &#123;</span><br><span class=\"line\">\tconst char *name; &#x2F;&#x2F;&#x2F; 原来的类的名字</span><br><span class=\"line\">\tstruct _class_t *cls; &#x2F;&#x2F;&#x2F; 类对象</span><br><span class=\"line\">\tconst struct _method_list_t *instance_methods; &#x2F;&#x2F;&#x2F; 实例方法数组</span><br><span class=\"line\">\tconst struct _method_list_t *class_methods; &#x2F;&#x2F;&#x2F; 类方法数组</span><br><span class=\"line\">\tconst struct _protocol_list_t *protocols; &#x2F;&#x2F;&#x2F; 遵循的协议数组</span><br><span class=\"line\">\tconst struct _prop_list_t *properties; &#x2F;&#x2F;&#x2F; 属性数组</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>由此可知，<strong>分类可以定义实例方法，可以定义类方法，可以遵循协议，可以添加属性，但是不能添加成员变量！因为分类的结构里面没有存储成员变量的地方.</strong></p>\n<h3 id=\"程序通过runtime动态将分类合并到类对象、元类对象中\"><a href=\"#程序通过runtime动态将分类合并到类对象、元类对象中\" class=\"headerlink\" title=\"程序通过runtime动态将分类合并到类对象、元类对象中\"></a>程序通过runtime动态将分类合并到类对象、元类对象中</h3><p>分类中的方法是在运行时才添加到类对象和元类对象中的，而不是编译的时候添加的，编译之后只是多了几个类型为<code>_category_t</code>的结构体变量。</p>\n<p>合并的过程可以在runtime源码（objc4-818.2）中<code>objc-runtime-new.mm</code>的<code>load_categories_nolock</code>函数中看到，这里不展开流程，直接说结论。</p>\n<p>合并过程是这样子的，首先我们知道原来的类（我们就叫他主类吧）对象是存放着成员方法的，主类的元类对象是放着类方法的，因为类对象和元类对象结构是一样的，所以我们就讨论成员方法就好了。</p>\n<p>其次呢，runtime先根据分类方法的数量在数组里面开辟空间，然后把分类方法塞到原来的成员方法数组的前端，这样子合并就完成了，其他类方法、协议、属性等数组，也是同样的过程。</p>\n<p>所以最后在<strong>类对象的方法列表数组里面，排在前面的是分类方法，后面才是主类的方法。如果有多个分类的话，那么后编译的分类的成员方法会插在数组的前面（因为插入数组的时候是倒序插入）</strong>。</p>\n<p>有了上述结论 我们就可以解释很多事情了。</p>\n<h4 id=\"如果分类实现了主类的方法会怎么样\"><a href=\"#如果分类实现了主类的方法会怎么样\" class=\"headerlink\" title=\"如果分类实现了主类的方法会怎么样\"></a>如果分类实现了主类的方法会怎么样</h4><p>根据上述结论，系统在找对应的调用方法的时候，会先找到分类的方法，所以主类的方法没有机会被调用到。</p>\n<h4 id=\"如果多个分类都实现了同个主类的方法\"><a href=\"#如果多个分类都实现了同个主类的方法\" class=\"headerlink\" title=\"如果多个分类都实现了同个主类的方法\"></a>如果多个分类都实现了同个主类的方法</h4><p>根据上述结论，后编译的分类的成员方法会插在方法列表的前面，所以谁后编译，就调用谁</p>\n<h4 id=\"如果子类或者子类的分类实现了父类的分类方法\"><a href=\"#如果子类或者子类的分类实现了父类的分类方法\" class=\"headerlink\" title=\"如果子类或者子类的分类实现了父类的分类方法\"></a>如果子类或者子类的分类实现了父类的分类方法</h4><p>根据上述结论和结合我们以前所学知识，最后子类实例对象会去子类的类对象里面寻找方法并调用，使用<code>super</code>关键字调用方法的话，则会去到父类的类对象内找方法。</p>\n<h3 id=\"Category跟Class-Extension的区别\"><a href=\"#Category跟Class-Extension的区别\" class=\"headerlink\" title=\"Category跟Class Extension的区别\"></a>Category跟Class Extension的区别</h3><ul>\n<li>Class Extension是编译的时候，它的数据就已经包含在类信息中</li>\n<li>Category 是在运行时才会讲数据合并到类信息中</li>\n</ul>\n<h2 id=\"load方法\"><a href=\"#load方法\" class=\"headerlink\" title=\"load方法\"></a>load方法</h2><h3 id=\"先写一个Demo-1\"><a href=\"#先写一个Demo-1\" class=\"headerlink\" title=\"先写一个Demo\"></a>先写一个Demo</h3><p>父类：实现load方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Person</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    NSLog(@&quot;Person load&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>父类的分类：实现load方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Person(Test)</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    NSLog(@&quot;Person Text load&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>子类：实现load方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Student</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    NSLog(@&quot;Student load&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>子类的分类：实现load方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Student(Test)</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    NSLog(@&quot;Student Test load&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"load方法的调用时机\"><a href=\"#load方法的调用时机\" class=\"headerlink\" title=\"load方法的调用时机\"></a>load方法的调用时机</h3><p>通过runtime源码（objc4-818.2）<code>objc-runtime-new.mm</code>第3233行得知，load方法是在加载镜像(load_images)的时候调用的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;</span><br><span class=\"line\">        didInitialAttachCategories &#x3D; true;</span><br><span class=\"line\">        loadAllCategories();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Return without taking locks if there are no +load methods here.</span><br><span class=\"line\">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class=\"line\"></span><br><span class=\"line\">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Discover load methods</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        mutex_locker_t lock2(runtimeLock);</span><br><span class=\"line\">        prepare_load_methods((const headerType *)mh);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Call +load methods (without runtimeLock - re-entrant)</span><br><span class=\"line\">    call_load_methods();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>补充小细节：从<code>load_images</code>函数可以看到，加载分类<code>loadAllCategories()</code>早于调用load方法<code>call_load_methods()</code>，也就是元类对象中的类方法列表内，分类的load方法会在主类的load方法之前</p>\n</blockquote>\n<p>在调用load方法之前，首先要通过<code>prepare_load_methods</code>函数整理出一个数组，这个数组会决定主类的load方法的调用顺序</p>\n<p>从<code>prepare_load_methods</code>函数中调用的<code>schedule_class_load</code>函数的内部实现我们可以知道，父类会先被加入到数组中，其次才是主类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;***********************************************************************</span><br><span class=\"line\">* prepare_load_methods</span><br><span class=\"line\">* Schedule +load for classes in this image, any un-+load-ed </span><br><span class=\"line\">* superclasses in other images, and any categories in this image.</span><br><span class=\"line\">**********************************************************************&#x2F;</span><br><span class=\"line\">&#x2F;&#x2F; Recursively schedule +load for cls and any un-+load-ed superclasses.</span><br><span class=\"line\">&#x2F;&#x2F; cls must already be connected.</span><br><span class=\"line\">static void schedule_class_load(Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!cls) return;</span><br><span class=\"line\">    ASSERT(cls-&gt;isRealized());  &#x2F;&#x2F; _read_images should realize</span><br><span class=\"line\"></span><br><span class=\"line\">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; Ensure superclass-first ordering</span><br><span class=\"line\">    schedule_class_load(cls-&gt;getSuperclass());</span><br><span class=\"line\"></span><br><span class=\"line\">    add_class_to_loadable_list(cls);</span><br><span class=\"line\">    cls-&gt;setInfo(RW_LOADED); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我们回到最开始的地方（load_images），通过<code>objc-loadmethod.mm</code>第337行<code>call_load_methods</code>得知，先调用主类的load方法(call_class_loads())，再调用分类的load方法<code>call_category_loads();</code></p>\n<blockquote>\n<p>补充一个小细节：在整理数组的时候，这个数组里面存放的是一个个结构体，结构体长这样</p>\n</blockquote>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct loadable_class &#123;</span><br><span class=\"line\">    Class cls;  &#x2F;&#x2F; may be nil  这里放元类对象（load是类方法所以存在元类对象里面）</span><br><span class=\"line\">    IMP method;  &#x2F;&#x2F;&#x2F; 这里放的是load方法的函数指针</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct loadable_category &#123;</span><br><span class=\"line\">    Category cat;  &#x2F;&#x2F; may be nil 这个是上面讲到的category_t类型的对象</span><br><span class=\"line\">    IMP method; &#x2F;&#x2F;&#x2F; 这里放的是load方法的函数指针</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意：runtime代码内有记录类的load方法是否曾经被加入到load数组过（RW_LOADED），如果被调用过了，就会跳过，这就是load方法只会执行一次的原因（但是你要是非要手动调用load方法那还是会执行的）</p>\n<p><strong>重要：系统调用load方法不通过消息发送机制</strong>，可以查看<code>objc-loadmethod.mm</code>第177行如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;***********************************************************************</span><br><span class=\"line\">* call_class_loads</span><br><span class=\"line\">* Call all pending class +load methods.</span><br><span class=\"line\">* If new classes become loadable, +load is NOT called for them.</span><br><span class=\"line\">*</span><br><span class=\"line\">* Called only by call_load_methods().</span><br><span class=\"line\">**********************************************************************&#x2F;</span><br><span class=\"line\">static void call_class_loads(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; Detach current loadable list.</span><br><span class=\"line\">    struct loadable_class *classes &#x3D; loadable_classes;</span><br><span class=\"line\">    int used &#x3D; loadable_classes_used;</span><br><span class=\"line\">    loadable_classes &#x3D; nil;</span><br><span class=\"line\">    loadable_classes_allocated &#x3D; 0;</span><br><span class=\"line\">    loadable_classes_used &#x3D; 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; Call all +loads for the detached list.</span><br><span class=\"line\">    for (i &#x3D; 0; i &lt; used; i++) &#123;</span><br><span class=\"line\">        Class cls &#x3D; classes[i].cls;</span><br><span class=\"line\">        load_method_t load_method &#x3D; (load_method_t)classes[i].method;</span><br><span class=\"line\">        if (!cls) continue; </span><br><span class=\"line\"></span><br><span class=\"line\">        if (PrintLoading) &#123;</span><br><span class=\"line\">            _objc_inform(&quot;LOAD: +[%s load]\\n&quot;, cls-&gt;nameForLogging());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;&#x2F; 意为直接通过函数指针调用函数</span><br><span class=\"line\">        (*load_method)(cls, @selector(load));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; Destroy the detached list.</span><br><span class=\"line\">    if (classes) free(classes);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"load方法的调用顺序\"><a href=\"#load方法的调用顺序\" class=\"headerlink\" title=\"load方法的调用顺序\"></a>load方法的调用顺序</h3><p>综上所述，分类也有load方法。调用顺序是：先调用父类load方法，再调用子类load方法，最后调用分类的load方法，如果有多个分类，那么先编译的，先调用。</p>\n<p>所以上述Demo代码执行后输出结果为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person load</span><br><span class=\"line\">Student load</span><br><span class=\"line\">Person Test load</span><br><span class=\"line\">Student Test load</span><br></pre></td></tr></table></figure>\n\n<p>这里Person比Student先调用是因为他是父类，Person(Test)比Student(Test)先调用是因为它先编译</p>\n<h3 id=\"综上所述\"><a href=\"#综上所述\" class=\"headerlink\" title=\"综上所述\"></a>综上所述</h3><p>于是我们可以解答下面的问题</p>\n<ol>\n<li>类和分类都有+load方法</li>\n<li>根据编译顺序，先调用父类+load，再调用子类+load，再调用分类+load(看编译顺序)</li>\n<li>因为系统调用load方法时不通过消息发送机制，所以不存在子类load方法覆盖父类load方法的情况，但是，如果手动调用load方法（即通过消息发送机制调用方法），那么这时候就有继承的现象发生了，也就是子类会覆盖父类方法的实现。</li>\n</ol>\n<p>搞点复杂的事情</p>\n<ol>\n<li>父类实现，父类分类实现，子类不实现，子类分类实现<br/><br> 顺序：父类load，子类分类load、父类分类load<br/><br> 原因：本来应该调用子类load的，无奈子类load没实现，但是找到了子类分类，那么就调用子类分类的load，最后在调用父类分类load(因为分类要最晚调用，由于刚才子类分类被调用过了，所以这里没它事了)<br/><br> <strong>所以：不一定主类的load方法总比分类的load方法早调用，存在特殊情况</strong><br/><br/></li>\n<li>父类不实现，父类分类实现，子类实现，子类分类实现<br/><br> 顺序：父类分类load，子类load，子类分类load<br/><br> 原因：跟上面的理由是一样的，父类没实现但是父类分类找到了那么就调用<br/><br> <strong>所以：父类的分类的load也可以比子类load方法早调用</strong></li>\n</ol>\n<h2 id=\"initialize方法\"><a href=\"#initialize方法\" class=\"headerlink\" title=\"initialize方法\"></a>initialize方法</h2><h3 id=\"先写个Demo\"><a href=\"#先写个Demo\" class=\"headerlink\" title=\"先写个Demo\"></a>先写个Demo</h3><p>父类：实现initialize方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Person</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)initialize &#123;</span><br><span class=\"line\">    NSLog(@&quot;Person initialize&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>父类的分类：实现initialize方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Person(Test)</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)initialize &#123;</span><br><span class=\"line\">    NSLog(@&quot;Person Text initialize&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>子类：实现initialize方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Student</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)initialize &#123;</span><br><span class=\"line\">    NSLog(@&quot;Student initialize&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>子类的分类：实现initialize方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Student(Test)</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)initialize &#123;</span><br><span class=\"line\">    NSLog(@&quot;Student Test initialize&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"initialize方法的调用时机\"><a href=\"#initialize方法的调用时机\" class=\"headerlink\" title=\"initialize方法的调用时机\"></a>initialize方法的调用时机</h3><ul>\n<li><p><code>+initialize</code>会在类第一次接受到消息的时候调用，即<code>objc_msgSend()</code>被触发的时候调用，这部分是汇编实现</p>\n</li>\n<li><p>runtime源码里面有一个<code>class_getInstanceMethod()</code>函数，用于查找方法，当找到要调用的方法之后，就会调用<code>initialize</code>方法，<code>class_getInstanceMethod()</code>内的主要实现为<code>lookUpImpOrForward()</code>函数的调用</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;***********************************************************************</span><br><span class=\"line\">* class_getInstanceMethod.  Return the instance method for the</span><br><span class=\"line\">* specified class and selector.</span><br><span class=\"line\">**********************************************************************&#x2F;</span><br><span class=\"line\">Method class_getInstanceMethod(Class cls, SEL sel)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!cls  ||  !sel) return nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; This deliberately avoids +initialize because it historically did so.</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; This implementation is a bit weird because it&#39;s the only place that </span><br><span class=\"line\">    &#x2F;&#x2F; wants a Method instead of an IMP.</span><br><span class=\"line\"></span><br><span class=\"line\">    Method meth;</span><br><span class=\"line\">    meth &#x3D; _cache_getMethod(cls, sel, _objc_msgForward_impcache);</span><br><span class=\"line\">    if (meth &#x3D;&#x3D; (Method)1) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; Cache contains forward:: . Stop searching.</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125; else if (meth) &#123;</span><br><span class=\"line\">        return meth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#x2F;&#x2F; Search method lists, try method resolver, etc.</span><br><span class=\"line\">    lookUpImpOrForward(nil, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER);</span><br><span class=\"line\"></span><br><span class=\"line\">    meth &#x3D; _cache_getMethod(cls, sel, _objc_msgForward_impcache);</span><br><span class=\"line\">    if (meth &#x3D;&#x3D; (Method)1) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; Cache contains forward:: . Stop searching.</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125; else if (meth) &#123;</span><br><span class=\"line\">        return meth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return _class_getMethod(cls, sel);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>lookUpImpOrForward()</code>函数实现内，有一判断条件为<code>if(slowpath(!cls-&gt;isInitialized())) &#123; ... &#125;</code> ，若该类已经调用过<code>+initialize</code>，那么就不会再调用，这就是<code>+initialize</code>只被系统调用一次的原因</p>\n</li>\n<li><p>经过一层层点击方法实现（流程见补充），最终我们可以在<code>objc-initialize.mm</code>内发现函数<code>callInitialize(Class cls)</code>，内部实现是<code>objc_msgSend</code>，如下</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  void callInitialize(Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ((void(*)(Class, SEL))objc_msgSend)(cls, @selector(initialize));</span><br><span class=\"line\">    asm(&quot;&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>补充：函数调用路径为<code>lookUpImpOrForward</code>-&gt;<code>realizeAndInitializeIfNeeded_locked</code>-&gt;<code>initializeAndLeaveLocked</code>-&gt;<code>initializeAndMaybeRelock</code>-&gt;<code>initializeNonMetaClass</code>-&gt;<code>callInitialize</code><br/>其中：<code>initializeNonMetaClass</code>函数实现内有一个递归，不断地传入<code>superclass</code>指针，去调用父类的<code>initialize</code>方法，直到<code>superclass</code>指针为空（或已经调用过<code>initialize</code>）为止，这就是先调用父类的<code>initialize</code>方法的原因</p>\n</blockquote>\n<h3 id=\"initialize方法的调用顺序\"><a href=\"#initialize方法的调用顺序\" class=\"headerlink\" title=\"initialize方法的调用顺序\"></a>initialize方法的调用顺序</h3><ul>\n<li>先调用父类的<code>initialize</code>方法，再调用子类的<code>initialize</code></li>\n</ul>\n<h3 id=\"综上所述-1\"><a href=\"#综上所述-1\" class=\"headerlink\" title=\"综上所述\"></a>综上所述</h3><ol>\n<li><code>initialize</code>是通过<code>objc_msgSend</code>方式调用的，所以会受分类、继承等等因素影响调用</li>\n<li>如果子类没有实现<code>+initialize</code>，会调用父类的<code>+initiailize</code>（所以父类的<code>+initialize</code>可能会被调用多次）</li>\n<li>如果分类实现了<code>+initialize</code>，就会覆盖主类的<code>+initialize</code>调用</li>\n</ol>\n<h2 id=\"关联对象\"><a href=\"#关联对象\" class=\"headerlink\" title=\"关联对象\"></a>关联对象</h2><p>假如我们要给一个类添加一个属性如下：<br><br><code>@property (copy, nonatomic) NSString *test;</code></p>\n<h3 id=\"存值\"><a href=\"#存值\" class=\"headerlink\" title=\"存值\"></a>存值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJC_EXPORT void</span><br><span class=\"line\">objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,</span><br><span class=\"line\">                         id _Nullable value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>object</td>\n<td>要关联的对象，如果是在分类内给主类添加属性，那么这里就写<code>self</code></td>\n</tr>\n<tr>\n<td>key</td>\n<td>要用来标记这个属性的key，取值的时候也得靠这个key取</td>\n</tr>\n<tr>\n<td>value</td>\n<td>存储的内容</td>\n</tr>\n<tr>\n<td>policy</td>\n<td>存储策略（见下表）</td>\n</tr>\n</tbody></table>\n<h4 id=\"objc-AssociationPolicy-存储策略\"><a href=\"#objc-AssociationPolicy-存储策略\" class=\"headerlink\" title=\"objc_AssociationPolicy 存储策略\"></a>objc_AssociationPolicy 存储策略</h4><table>\n<thead>\n<tr>\n<th>策略枚举</th>\n<th>对应修饰符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OBJC_ASSOCIATION_ASSIGN</td>\n<td>assign</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>\n<td>strong, nonatomic</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>\n<td>copy,nonatomic</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_RETAIN</td>\n<td>strong, atomic</td>\n</tr>\n<tr>\n<td>OBJC_ASSOCIATION_COPY</td>\n<td>copy,atomic</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>如果要存weak类型的对象怎么办？<br/>创建一个类，用<code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code>标记存在主类中，然后在这个新建的类里面再存放一个weak引用的属性</p>\n</blockquote>\n<h4 id=\"key有多少种填写形式\"><a href=\"#key有多少种填写形式\" class=\"headerlink\" title=\"key有多少种填写形式\"></a>key有多少种填写形式</h4><ol>\n<li>声明全局变量<code>static const void *TestKey = &amp;TestKey;</code>,将<code>TestKey</code>的地址作为key的内容，不能直接写<code>const void *TestKey</code>，因为这么写等共同于<code>const void *TestKey = NULL</code>，要是以后添加别的属性，就会冲突，使用例子：</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_setAssociatedObject(self,TestKey,test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>声明全局变量<code>static const char TestKey</code>，同样将<code>TestKey</code>的地址作为key，好处是<code>char</code>只占用一个字节的内存大小，使用例子：</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_setAssociatedObject(self,&amp;TestKey,test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>因为OC内的字符串都存在常量区，所以通过字面量创建的相同字符串都是同个地址，所以我们也可以随便定义一个字符串去做key，使用例子：</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_setAssociatedObject(self,@&quot;Test&quot;,test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>我们也可以通过使用getter方法的方法编号去做key，使用例子：</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_setAssociatedObject(self,@selector(test),test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure>\n<h3 id=\"取值\"><a href=\"#取值\" class=\"headerlink\" title=\"取值\"></a>取值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OBJC_EXPORT id _Nullable</span><br><span class=\"line\">objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key);</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>object同上，一般分类里面就填self</li>\n<li>key属性需要和上面设值的key属性一致</li>\n</ul>\n<ul>\n<li>如果使用getter方法的方法编号去做key，有两种写法<ol>\n<li><code>objc_getAssociatedObject(self, @selector(test))</code></li>\n<li><code>objc_getAssociatedObject(self, _cmd)</code>，<code>_cmd</code>表示当前方法的方法地址</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"底层实现\"><a href=\"#底层实现\" class=\"headerlink\" title=\"底层实现\"></a>底层实现</h3><p><img src=\"https://www.hualigs.cn/image/60bd149eb55dc.jpg\" alt=\"图片来源自小码哥教程\"></p>\n<ul>\n<li>runtime维护着一个名为<code>AssociationsManager</code>的类</li>\n<li>类里面存放着一个字典，键是传入的对象（object参数），值是<code>ObjectAssociationMap</code>类的实例对象</li>\n<li><code>ObjectAssociationMap</code>是一个字典，键是传入的key参数，值是<code>ObjcAssociation</code>类的实例对象</li>\n<li><code>ObjcAssociation</code>有两个成员变量，<code>_policy</code>存放着传入的policy参数，<code>_value</code>存放着传入的value参数</li>\n</ul>\n<h3 id=\"综上所述-2\"><a href=\"#综上所述-2\" class=\"headerlink\" title=\"综上所述\"></a>综上所述</h3><ol>\n<li>关联对象并不是存储在被关联对象的内存中</li>\n<li>关联对象存储在全局统一的<code>AssociationsManager</code>中</li>\n<li>设置关联对象（object参数）为nil，就相当于是移除关联对象</li>\n</ol>"},{"title":"WordPress常用函数","author":"Arclin","abbrlink":"3fd5c9ca","date":"2017-03-01T16:00:00.000Z","_content":"wordpress自定义主题的时候需要用到的函数\n\n<!-- more -->\n\n[参考文档](https://codex.wordpress.org/zh-cn:模板标签)\n\n\n|函数名|作用|\n|----|----|\n|bloginfo()|可以拿到博客的信息,name,description,version,特别注意bloginfo('stylesheet_url');会直接找到根目录下的style.css文件,这个页面的样式表|\n|wp_head()|\t一般放在header.php,会有很多东西引入进去|\n|wp_title()|网站标题|\n|get_header()|检查同目录下是否有header.php,有的话就会调用这个文件作为页面头部|\n|get_sidebar()|检查sidebar.php,调用作为侧边栏|\n|get_footer()|检查footer.php,调用作为底部栏|\n|have_posts()|判断是否有日志|\n|the_post()|调用一篇具体的日志,和主循环配合使用|\n|the_permalink()|每篇日志地址|\n|the_title()|日志标题|\n|the_content()|日志内容|\n|_e()|框架里面有语言文件,这里是调用语言文件内对应文字,使用类似这样子_e(\"Archives\"),中文页面下显示归档,英文页面下显示Archives|\n|the_category()|分类,这个函数里面有一个参数,可以表示用什么符号去分割多个分类名,例如the_category(',')|\n|the_author()|作者名|\n|the_excerpt()|日志摘要|\n|comments_popup_link(‘No Comments »’, ‘1 Comment »’, ‘% Comments »’);|当弹出留言的功能激活的话，comments_popup_link() 调用一个弹出的留言窗口，如果没有激活，comments_popup_link() 则只是简单的显示留言列表。No Comments » 是在没有留言的时候显示的。1 Comment » 是用于当刚好只有1条留言时候。% Comments &187; 是用于当有多于一条留言的时候。比如：8 Comments »。百分号 % 用来显示数字。» 是用来显示一个双层箭头 »。|\n|edit_post_link(‘Edit’, ‘&124’, ”);\t|这个只有当我们以管理员或者作者身份登录的的时候才可见。|\n|edit_post_link()|只是简单显示一个可以用来编辑当前日志的编辑链接，这样就可以让我们不必去管理界面搜寻该日志就能直接编辑。|\n|edit_post_link() |有三个参数。第一个是用来确定哪个词你将用在编辑链接的链接标题。如果你使用 Edit post，那么将显示 Edit post 而不是 Edit。第二个参数是用来显示在链接前面的字符，在这里是竖线，代码就是&124;。第三个参数是用于显示在编辑链接后面的字符，在这里没有使用。登录 WordPress 之后，再返回到首页就可以看到“Edit”的链接和一条竖线。|\n|posts_nav_link(‘中间页’, ‘<<上一页’, ‘下一页>>’)|调用后一页和前一页的链接,3个参数，分别给链接的中间，前面和后面的设置字符|\n|previous_post_link(‘%link’)|上一篇日志|\n|next_post_link(‘%link’)|下一篇日志|\n|wp_list_pages()|展示页面列表,如果参数里面填`title_li=<h2>Pages</h2>&depth=3`,可以设置title的样式,depth指的是页面的展示深度|\n|wp_list_cats()|展示分类列表,参数可填`sort_column=name&optioncount=1&hierarchical=0`,分别是设置排序根据,是否显示文章个数,以分层缩进的方式显示分类列表|\n|get_links_list();|友情链接列表,在后台装插件之后就可以用了|\n|wp_get_archives()|意思跟上面的差不多,也是有参数,获取的是文章归档列表,参数填type=daily的话就是按日期分,monthly按月分,yearly按年分,format=link以链接形式显示|\n|wp_loginout()|退出登录链接|\n|wp_register()|注册链接|\n|wp_meta()|显示管理员的相关控制信息|\n|get_calendar()|显示一个日历|\n|include(TEMPLATEPATH . ‘/searchform.php’)|导入某个自定义文件,像左边就是/searchform.php文件|\n\n### 判断是否有日志并循环输出日志\n```\n<?php if(have_posts()) : ?> <!--检查是否有日志-->\n\t<?php while(have_posts()) : the_post(); ?> <!--循环输出日志-->\n\t\t\t<div class=\"post\" id=\"post-<?php the_ID(); ?>\">\n\t\t\t\t<h2><a href=\"<?php the_permalink(); ?>\" title=\"<?php the_title(); ?>\"><?php the_title(); ?></a></h2><!--日志标题-->\n\t\t\t\t<div class='entry'>\n\t\t\t\t<?php the_content(); ?>\n\t\t\t</div>\n\t\t\t<p class=\"postmetadata\">\n\t\t\t<?php _e('Filed under&#58;'); ?> <?php the_category(', ') ?> <?php _e('by'); ?> <?php  the_author(); ?><br />\n\t\t\t<?php comments_popup_link('No Comments &#187;', '1 Comment &#187;', '% Comments &#187;'); ?> <?php edit_post_link('Edit', ' &#124; ', ''); ?>\n\t\t\t</p>\n\t\t\t</div>\n\t<?php endwhile; ?>\n\t<div class=\"navigation\">\n\t\t\t<?php posts_nav_link('index', '<<上一页', '下一页>>'); ?>\n\t</div>\n\t<?php else : ?> <!--如果没有日志-->\n\t<div class = \"post\">\n\t\t<h2><?php _e(\"Not Found\"); ?></h2>\n\t</div>\n<?php endif; ?>\n```\n\n### 搜索框\n\n```\n<form method=\"get\" id=\"searchform\" action=\"<?php bloginfo('home'); ?>/\">\n\n<div>\n\n\t<input type=\"text\" value=\"<?php echo wp_specialchars($s, 1); ?>\" name=\"s\" id=\"s\" size=\"15\" /><br />\n\n\t<input type=\"submit\" id=\"searchsubmit\" value=\"Search\" />\n\n</div>\n\n</form>\n```","source":"_posts/WordPress常用函数.md","raw":"---\ntitle: WordPress常用函数\nauthor: Arclin\ntags:\n  - PHP\n  - WordPress\ncategories:\n  - PHP\nabbrlink: 3fd5c9ca\ndate: 2017-03-02 00:00:00\n---\nwordpress自定义主题的时候需要用到的函数\n\n<!-- more -->\n\n[参考文档](https://codex.wordpress.org/zh-cn:模板标签)\n\n\n|函数名|作用|\n|----|----|\n|bloginfo()|可以拿到博客的信息,name,description,version,特别注意bloginfo('stylesheet_url');会直接找到根目录下的style.css文件,这个页面的样式表|\n|wp_head()|\t一般放在header.php,会有很多东西引入进去|\n|wp_title()|网站标题|\n|get_header()|检查同目录下是否有header.php,有的话就会调用这个文件作为页面头部|\n|get_sidebar()|检查sidebar.php,调用作为侧边栏|\n|get_footer()|检查footer.php,调用作为底部栏|\n|have_posts()|判断是否有日志|\n|the_post()|调用一篇具体的日志,和主循环配合使用|\n|the_permalink()|每篇日志地址|\n|the_title()|日志标题|\n|the_content()|日志内容|\n|_e()|框架里面有语言文件,这里是调用语言文件内对应文字,使用类似这样子_e(\"Archives\"),中文页面下显示归档,英文页面下显示Archives|\n|the_category()|分类,这个函数里面有一个参数,可以表示用什么符号去分割多个分类名,例如the_category(',')|\n|the_author()|作者名|\n|the_excerpt()|日志摘要|\n|comments_popup_link(‘No Comments »’, ‘1 Comment »’, ‘% Comments »’);|当弹出留言的功能激活的话，comments_popup_link() 调用一个弹出的留言窗口，如果没有激活，comments_popup_link() 则只是简单的显示留言列表。No Comments » 是在没有留言的时候显示的。1 Comment » 是用于当刚好只有1条留言时候。% Comments &187; 是用于当有多于一条留言的时候。比如：8 Comments »。百分号 % 用来显示数字。» 是用来显示一个双层箭头 »。|\n|edit_post_link(‘Edit’, ‘&124’, ”);\t|这个只有当我们以管理员或者作者身份登录的的时候才可见。|\n|edit_post_link()|只是简单显示一个可以用来编辑当前日志的编辑链接，这样就可以让我们不必去管理界面搜寻该日志就能直接编辑。|\n|edit_post_link() |有三个参数。第一个是用来确定哪个词你将用在编辑链接的链接标题。如果你使用 Edit post，那么将显示 Edit post 而不是 Edit。第二个参数是用来显示在链接前面的字符，在这里是竖线，代码就是&124;。第三个参数是用于显示在编辑链接后面的字符，在这里没有使用。登录 WordPress 之后，再返回到首页就可以看到“Edit”的链接和一条竖线。|\n|posts_nav_link(‘中间页’, ‘<<上一页’, ‘下一页>>’)|调用后一页和前一页的链接,3个参数，分别给链接的中间，前面和后面的设置字符|\n|previous_post_link(‘%link’)|上一篇日志|\n|next_post_link(‘%link’)|下一篇日志|\n|wp_list_pages()|展示页面列表,如果参数里面填`title_li=<h2>Pages</h2>&depth=3`,可以设置title的样式,depth指的是页面的展示深度|\n|wp_list_cats()|展示分类列表,参数可填`sort_column=name&optioncount=1&hierarchical=0`,分别是设置排序根据,是否显示文章个数,以分层缩进的方式显示分类列表|\n|get_links_list();|友情链接列表,在后台装插件之后就可以用了|\n|wp_get_archives()|意思跟上面的差不多,也是有参数,获取的是文章归档列表,参数填type=daily的话就是按日期分,monthly按月分,yearly按年分,format=link以链接形式显示|\n|wp_loginout()|退出登录链接|\n|wp_register()|注册链接|\n|wp_meta()|显示管理员的相关控制信息|\n|get_calendar()|显示一个日历|\n|include(TEMPLATEPATH . ‘/searchform.php’)|导入某个自定义文件,像左边就是/searchform.php文件|\n\n### 判断是否有日志并循环输出日志\n```\n<?php if(have_posts()) : ?> <!--检查是否有日志-->\n\t<?php while(have_posts()) : the_post(); ?> <!--循环输出日志-->\n\t\t\t<div class=\"post\" id=\"post-<?php the_ID(); ?>\">\n\t\t\t\t<h2><a href=\"<?php the_permalink(); ?>\" title=\"<?php the_title(); ?>\"><?php the_title(); ?></a></h2><!--日志标题-->\n\t\t\t\t<div class='entry'>\n\t\t\t\t<?php the_content(); ?>\n\t\t\t</div>\n\t\t\t<p class=\"postmetadata\">\n\t\t\t<?php _e('Filed under&#58;'); ?> <?php the_category(', ') ?> <?php _e('by'); ?> <?php  the_author(); ?><br />\n\t\t\t<?php comments_popup_link('No Comments &#187;', '1 Comment &#187;', '% Comments &#187;'); ?> <?php edit_post_link('Edit', ' &#124; ', ''); ?>\n\t\t\t</p>\n\t\t\t</div>\n\t<?php endwhile; ?>\n\t<div class=\"navigation\">\n\t\t\t<?php posts_nav_link('index', '<<上一页', '下一页>>'); ?>\n\t</div>\n\t<?php else : ?> <!--如果没有日志-->\n\t<div class = \"post\">\n\t\t<h2><?php _e(\"Not Found\"); ?></h2>\n\t</div>\n<?php endif; ?>\n```\n\n### 搜索框\n\n```\n<form method=\"get\" id=\"searchform\" action=\"<?php bloginfo('home'); ?>/\">\n\n<div>\n\n\t<input type=\"text\" value=\"<?php echo wp_specialchars($s, 1); ?>\" name=\"s\" id=\"s\" size=\"15\" /><br />\n\n\t<input type=\"submit\" id=\"searchsubmit\" value=\"Search\" />\n\n</div>\n\n</form>\n```","slug":"WordPress常用函数","published":1,"updated":"2021-06-06T18:52:24.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoho003etnn0hmtpd2k5","content":"<p>wordpress自定义主题的时候需要用到的函数</p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://codex.wordpress.org/zh-cn:%E6%A8%A1%E6%9D%BF%E6%A0%87%E7%AD%BE\">参考文档</a></p>\n<table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bloginfo()</td>\n<td>可以拿到博客的信息,name,description,version,特别注意bloginfo(‘stylesheet_url’);会直接找到根目录下的style.css文件,这个页面的样式表</td>\n</tr>\n<tr>\n<td>wp_head()</td>\n<td>一般放在header.php,会有很多东西引入进去</td>\n</tr>\n<tr>\n<td>wp_title()</td>\n<td>网站标题</td>\n</tr>\n<tr>\n<td>get_header()</td>\n<td>检查同目录下是否有header.php,有的话就会调用这个文件作为页面头部</td>\n</tr>\n<tr>\n<td>get_sidebar()</td>\n<td>检查sidebar.php,调用作为侧边栏</td>\n</tr>\n<tr>\n<td>get_footer()</td>\n<td>检查footer.php,调用作为底部栏</td>\n</tr>\n<tr>\n<td>have_posts()</td>\n<td>判断是否有日志</td>\n</tr>\n<tr>\n<td>the_post()</td>\n<td>调用一篇具体的日志,和主循环配合使用</td>\n</tr>\n<tr>\n<td>the_permalink()</td>\n<td>每篇日志地址</td>\n</tr>\n<tr>\n<td>the_title()</td>\n<td>日志标题</td>\n</tr>\n<tr>\n<td>the_content()</td>\n<td>日志内容</td>\n</tr>\n<tr>\n<td>_e()</td>\n<td>框架里面有语言文件,这里是调用语言文件内对应文字,使用类似这样子_e(“Archives”),中文页面下显示归档,英文页面下显示Archives</td>\n</tr>\n<tr>\n<td>the_category()</td>\n<td>分类,这个函数里面有一个参数,可以表示用什么符号去分割多个分类名,例如the_category(‘,’)</td>\n</tr>\n<tr>\n<td>the_author()</td>\n<td>作者名</td>\n</tr>\n<tr>\n<td>the_excerpt()</td>\n<td>日志摘要</td>\n</tr>\n<tr>\n<td>comments_popup_link(‘No Comments »’, ‘1 Comment »’, ‘% Comments »’);</td>\n<td>当弹出留言的功能激活的话，comments_popup_link() 调用一个弹出的留言窗口，如果没有激活，comments_popup_link() 则只是简单的显示留言列表。No Comments » 是在没有留言的时候显示的。1 Comment » 是用于当刚好只有1条留言时候。% Comments &187; 是用于当有多于一条留言的时候。比如：8 Comments »。百分号 % 用来显示数字。» 是用来显示一个双层箭头 »。</td>\n</tr>\n<tr>\n<td>edit_post_link(‘Edit’, ‘&amp;124’, ”);</td>\n<td>这个只有当我们以管理员或者作者身份登录的的时候才可见。</td>\n</tr>\n<tr>\n<td>edit_post_link()</td>\n<td>只是简单显示一个可以用来编辑当前日志的编辑链接，这样就可以让我们不必去管理界面搜寻该日志就能直接编辑。</td>\n</tr>\n<tr>\n<td>edit_post_link()</td>\n<td>有三个参数。第一个是用来确定哪个词你将用在编辑链接的链接标题。如果你使用 Edit post，那么将显示 Edit post 而不是 Edit。第二个参数是用来显示在链接前面的字符，在这里是竖线，代码就是&124;。第三个参数是用于显示在编辑链接后面的字符，在这里没有使用。登录 WordPress 之后，再返回到首页就可以看到“Edit”的链接和一条竖线。</td>\n</tr>\n<tr>\n<td>posts_nav_link(‘中间页’, ‘&lt;&lt;上一页’, ‘下一页&gt;&gt;’)</td>\n<td>调用后一页和前一页的链接,3个参数，分别给链接的中间，前面和后面的设置字符</td>\n</tr>\n<tr>\n<td>previous_post_link(‘%link’)</td>\n<td>上一篇日志</td>\n</tr>\n<tr>\n<td>next_post_link(‘%link’)</td>\n<td>下一篇日志</td>\n</tr>\n<tr>\n<td>wp_list_pages()</td>\n<td>展示页面列表,如果参数里面填<code>title_li=&lt;h2&gt;Pages&lt;/h2&gt;&amp;depth=3</code>,可以设置title的样式,depth指的是页面的展示深度</td>\n</tr>\n<tr>\n<td>wp_list_cats()</td>\n<td>展示分类列表,参数可填<code>sort_column=name&amp;optioncount=1&amp;hierarchical=0</code>,分别是设置排序根据,是否显示文章个数,以分层缩进的方式显示分类列表</td>\n</tr>\n<tr>\n<td>get_links_list();</td>\n<td>友情链接列表,在后台装插件之后就可以用了</td>\n</tr>\n<tr>\n<td>wp_get_archives()</td>\n<td>意思跟上面的差不多,也是有参数,获取的是文章归档列表,参数填type=daily的话就是按日期分,monthly按月分,yearly按年分,format=link以链接形式显示</td>\n</tr>\n<tr>\n<td>wp_loginout()</td>\n<td>退出登录链接</td>\n</tr>\n<tr>\n<td>wp_register()</td>\n<td>注册链接</td>\n</tr>\n<tr>\n<td>wp_meta()</td>\n<td>显示管理员的相关控制信息</td>\n</tr>\n<tr>\n<td>get_calendar()</td>\n<td>显示一个日历</td>\n</tr>\n<tr>\n<td>include(TEMPLATEPATH . ‘/searchform.php’)</td>\n<td>导入某个自定义文件,像左边就是/searchform.php文件</td>\n</tr>\n</tbody></table>\n<h3 id=\"判断是否有日志并循环输出日志\"><a href=\"#判断是否有日志并循环输出日志\" class=\"headerlink\" title=\"判断是否有日志并循环输出日志\"></a>判断是否有日志并循环输出日志</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php if(have_posts()) : ?&gt; &lt;!--检查是否有日志--&gt;</span><br><span class=\"line\">\t&lt;?php while(have_posts()) : the_post(); ?&gt; &lt;!--循环输出日志--&gt;</span><br><span class=\"line\">\t\t\t&lt;div class&#x3D;&quot;post&quot; id&#x3D;&quot;post-&lt;?php the_ID(); ?&gt;&quot;&gt;</span><br><span class=\"line\">\t\t\t\t&lt;h2&gt;&lt;a href&#x3D;&quot;&lt;?php the_permalink(); ?&gt;&quot; title&#x3D;&quot;&lt;?php the_title(); ?&gt;&quot;&gt;&lt;?php the_title(); ?&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;&lt;!--日志标题--&gt;</span><br><span class=\"line\">\t\t\t\t&lt;div class&#x3D;&#39;entry&#39;&gt;</span><br><span class=\"line\">\t\t\t\t&lt;?php the_content(); ?&gt;</span><br><span class=\"line\">\t\t\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">\t\t\t&lt;p class&#x3D;&quot;postmetadata&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;?php _e(&#39;Filed under&amp;#58;&#39;); ?&gt; &lt;?php the_category(&#39;, &#39;) ?&gt; &lt;?php _e(&#39;by&#39;); ?&gt; &lt;?php  the_author(); ?&gt;&lt;br &#x2F;&gt;</span><br><span class=\"line\">\t\t\t&lt;?php comments_popup_link(&#39;No Comments &amp;#187;&#39;, &#39;1 Comment &amp;#187;&#39;, &#39;% Comments &amp;#187;&#39;); ?&gt; &lt;?php edit_post_link(&#39;Edit&#39;, &#39; &amp;#124; &#39;, &#39;&#39;); ?&gt;</span><br><span class=\"line\">\t\t\t&lt;&#x2F;p&gt;</span><br><span class=\"line\">\t\t\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">\t&lt;?php endwhile; ?&gt;</span><br><span class=\"line\">\t&lt;div class&#x3D;&quot;navigation&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;?php posts_nav_link(&#39;index&#39;, &#39;&lt;&lt;上一页&#39;, &#39;下一页&gt;&gt;&#39;); ?&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">\t&lt;?php else : ?&gt; &lt;!--如果没有日志--&gt;</span><br><span class=\"line\">\t&lt;div class &#x3D; &quot;post&quot;&gt;</span><br><span class=\"line\">\t\t&lt;h2&gt;&lt;?php _e(&quot;Not Found&quot;); ?&gt;&lt;&#x2F;h2&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;?php endif; ?&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"搜索框\"><a href=\"#搜索框\" class=\"headerlink\" title=\"搜索框\"></a>搜索框</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form method&#x3D;&quot;get&quot; id&#x3D;&quot;searchform&quot; action&#x3D;&quot;&lt;?php bloginfo(&#39;home&#39;); ?&gt;&#x2F;&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;&lt;?php echo wp_specialchars($s, 1); ?&gt;&quot; name&#x3D;&quot;s&quot; id&#x3D;&quot;s&quot; size&#x3D;&quot;15&quot; &#x2F;&gt;&lt;br &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;input type&#x3D;&quot;submit&quot; id&#x3D;&quot;searchsubmit&quot; value&#x3D;&quot;Search&quot; &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>wordpress自定义主题的时候需要用到的函数</p>","more":"<p><a href=\"https://codex.wordpress.org/zh-cn:%E6%A8%A1%E6%9D%BF%E6%A0%87%E7%AD%BE\">参考文档</a></p>\n<table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bloginfo()</td>\n<td>可以拿到博客的信息,name,description,version,特别注意bloginfo(‘stylesheet_url’);会直接找到根目录下的style.css文件,这个页面的样式表</td>\n</tr>\n<tr>\n<td>wp_head()</td>\n<td>一般放在header.php,会有很多东西引入进去</td>\n</tr>\n<tr>\n<td>wp_title()</td>\n<td>网站标题</td>\n</tr>\n<tr>\n<td>get_header()</td>\n<td>检查同目录下是否有header.php,有的话就会调用这个文件作为页面头部</td>\n</tr>\n<tr>\n<td>get_sidebar()</td>\n<td>检查sidebar.php,调用作为侧边栏</td>\n</tr>\n<tr>\n<td>get_footer()</td>\n<td>检查footer.php,调用作为底部栏</td>\n</tr>\n<tr>\n<td>have_posts()</td>\n<td>判断是否有日志</td>\n</tr>\n<tr>\n<td>the_post()</td>\n<td>调用一篇具体的日志,和主循环配合使用</td>\n</tr>\n<tr>\n<td>the_permalink()</td>\n<td>每篇日志地址</td>\n</tr>\n<tr>\n<td>the_title()</td>\n<td>日志标题</td>\n</tr>\n<tr>\n<td>the_content()</td>\n<td>日志内容</td>\n</tr>\n<tr>\n<td>_e()</td>\n<td>框架里面有语言文件,这里是调用语言文件内对应文字,使用类似这样子_e(“Archives”),中文页面下显示归档,英文页面下显示Archives</td>\n</tr>\n<tr>\n<td>the_category()</td>\n<td>分类,这个函数里面有一个参数,可以表示用什么符号去分割多个分类名,例如the_category(‘,’)</td>\n</tr>\n<tr>\n<td>the_author()</td>\n<td>作者名</td>\n</tr>\n<tr>\n<td>the_excerpt()</td>\n<td>日志摘要</td>\n</tr>\n<tr>\n<td>comments_popup_link(‘No Comments »’, ‘1 Comment »’, ‘% Comments »’);</td>\n<td>当弹出留言的功能激活的话，comments_popup_link() 调用一个弹出的留言窗口，如果没有激活，comments_popup_link() 则只是简单的显示留言列表。No Comments » 是在没有留言的时候显示的。1 Comment » 是用于当刚好只有1条留言时候。% Comments &187; 是用于当有多于一条留言的时候。比如：8 Comments »。百分号 % 用来显示数字。» 是用来显示一个双层箭头 »。</td>\n</tr>\n<tr>\n<td>edit_post_link(‘Edit’, ‘&amp;124’, ”);</td>\n<td>这个只有当我们以管理员或者作者身份登录的的时候才可见。</td>\n</tr>\n<tr>\n<td>edit_post_link()</td>\n<td>只是简单显示一个可以用来编辑当前日志的编辑链接，这样就可以让我们不必去管理界面搜寻该日志就能直接编辑。</td>\n</tr>\n<tr>\n<td>edit_post_link()</td>\n<td>有三个参数。第一个是用来确定哪个词你将用在编辑链接的链接标题。如果你使用 Edit post，那么将显示 Edit post 而不是 Edit。第二个参数是用来显示在链接前面的字符，在这里是竖线，代码就是&124;。第三个参数是用于显示在编辑链接后面的字符，在这里没有使用。登录 WordPress 之后，再返回到首页就可以看到“Edit”的链接和一条竖线。</td>\n</tr>\n<tr>\n<td>posts_nav_link(‘中间页’, ‘&lt;&lt;上一页’, ‘下一页&gt;&gt;’)</td>\n<td>调用后一页和前一页的链接,3个参数，分别给链接的中间，前面和后面的设置字符</td>\n</tr>\n<tr>\n<td>previous_post_link(‘%link’)</td>\n<td>上一篇日志</td>\n</tr>\n<tr>\n<td>next_post_link(‘%link’)</td>\n<td>下一篇日志</td>\n</tr>\n<tr>\n<td>wp_list_pages()</td>\n<td>展示页面列表,如果参数里面填<code>title_li=&lt;h2&gt;Pages&lt;/h2&gt;&amp;depth=3</code>,可以设置title的样式,depth指的是页面的展示深度</td>\n</tr>\n<tr>\n<td>wp_list_cats()</td>\n<td>展示分类列表,参数可填<code>sort_column=name&amp;optioncount=1&amp;hierarchical=0</code>,分别是设置排序根据,是否显示文章个数,以分层缩进的方式显示分类列表</td>\n</tr>\n<tr>\n<td>get_links_list();</td>\n<td>友情链接列表,在后台装插件之后就可以用了</td>\n</tr>\n<tr>\n<td>wp_get_archives()</td>\n<td>意思跟上面的差不多,也是有参数,获取的是文章归档列表,参数填type=daily的话就是按日期分,monthly按月分,yearly按年分,format=link以链接形式显示</td>\n</tr>\n<tr>\n<td>wp_loginout()</td>\n<td>退出登录链接</td>\n</tr>\n<tr>\n<td>wp_register()</td>\n<td>注册链接</td>\n</tr>\n<tr>\n<td>wp_meta()</td>\n<td>显示管理员的相关控制信息</td>\n</tr>\n<tr>\n<td>get_calendar()</td>\n<td>显示一个日历</td>\n</tr>\n<tr>\n<td>include(TEMPLATEPATH . ‘/searchform.php’)</td>\n<td>导入某个自定义文件,像左边就是/searchform.php文件</td>\n</tr>\n</tbody></table>\n<h3 id=\"判断是否有日志并循环输出日志\"><a href=\"#判断是否有日志并循环输出日志\" class=\"headerlink\" title=\"判断是否有日志并循环输出日志\"></a>判断是否有日志并循环输出日志</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php if(have_posts()) : ?&gt; &lt;!--检查是否有日志--&gt;</span><br><span class=\"line\">\t&lt;?php while(have_posts()) : the_post(); ?&gt; &lt;!--循环输出日志--&gt;</span><br><span class=\"line\">\t\t\t&lt;div class&#x3D;&quot;post&quot; id&#x3D;&quot;post-&lt;?php the_ID(); ?&gt;&quot;&gt;</span><br><span class=\"line\">\t\t\t\t&lt;h2&gt;&lt;a href&#x3D;&quot;&lt;?php the_permalink(); ?&gt;&quot; title&#x3D;&quot;&lt;?php the_title(); ?&gt;&quot;&gt;&lt;?php the_title(); ?&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;&lt;!--日志标题--&gt;</span><br><span class=\"line\">\t\t\t\t&lt;div class&#x3D;&#39;entry&#39;&gt;</span><br><span class=\"line\">\t\t\t\t&lt;?php the_content(); ?&gt;</span><br><span class=\"line\">\t\t\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">\t\t\t&lt;p class&#x3D;&quot;postmetadata&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;?php _e(&#39;Filed under&amp;#58;&#39;); ?&gt; &lt;?php the_category(&#39;, &#39;) ?&gt; &lt;?php _e(&#39;by&#39;); ?&gt; &lt;?php  the_author(); ?&gt;&lt;br &#x2F;&gt;</span><br><span class=\"line\">\t\t\t&lt;?php comments_popup_link(&#39;No Comments &amp;#187;&#39;, &#39;1 Comment &amp;#187;&#39;, &#39;% Comments &amp;#187;&#39;); ?&gt; &lt;?php edit_post_link(&#39;Edit&#39;, &#39; &amp;#124; &#39;, &#39;&#39;); ?&gt;</span><br><span class=\"line\">\t\t\t&lt;&#x2F;p&gt;</span><br><span class=\"line\">\t\t\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">\t&lt;?php endwhile; ?&gt;</span><br><span class=\"line\">\t&lt;div class&#x3D;&quot;navigation&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;?php posts_nav_link(&#39;index&#39;, &#39;&lt;&lt;上一页&#39;, &#39;下一页&gt;&gt;&#39;); ?&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">\t&lt;?php else : ?&gt; &lt;!--如果没有日志--&gt;</span><br><span class=\"line\">\t&lt;div class &#x3D; &quot;post&quot;&gt;</span><br><span class=\"line\">\t\t&lt;h2&gt;&lt;?php _e(&quot;Not Found&quot;); ?&gt;&lt;&#x2F;h2&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;?php endif; ?&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"搜索框\"><a href=\"#搜索框\" class=\"headerlink\" title=\"搜索框\"></a>搜索框</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form method&#x3D;&quot;get&quot; id&#x3D;&quot;searchform&quot; action&#x3D;&quot;&lt;?php bloginfo(&#39;home&#39;); ?&gt;&#x2F;&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;&lt;?php echo wp_specialchars($s, 1); ?&gt;&quot; name&#x3D;&quot;s&quot; id&#x3D;&quot;s&quot; size&#x3D;&quot;15&quot; &#x2F;&gt;&lt;br &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;input type&#x3D;&quot;submit&quot; id&#x3D;&quot;searchsubmit&quot; value&#x3D;&quot;Search&quot; &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>"},{"title":"iOS 底层原理 --- KVC","abbrlink":"34b9a649","author":"Arclin","date":"2021-05-30T03:59:00.000Z","_content":"本文讲述KVC的底层实现和KVC是否能触发KVO呢？\n\n<!--more-->\n\n## KVC的使用\n\n\n```\n[self.person setValue:@10 forKey:@\"age\"]\n\n[self.person setValue:@10 forKeyPath:@\"age\"]\n```\n\nkeyPath和key的区别是，keyPath可以使用路径的方式进行赋值，比如person对象内有cat模型属性，cat对象里面有age属性，那么就可以使用`[self.person setValue:@10 forKeyPath:@\"cat.age\"]`的方式使用KVC，而key方式只支持直接访问的方式赋值\n\n## 赋值过程\n\n`setValue:forKey`首先会先寻找`setKey:`方法，如果找不到，那么就会寻找`_setKey:`方法，类似下面这样子\n\n```\n/// 优先找这个方法\n- （void）setAge:(int)age {\n\t_age = age;\n}\n\n/// 找不到上面那个方法的话，就找下面这儿方法\n- （void）_setAge:(int)age {\n\t_age = age;\n}\n```\n\n如果上述两个方法都找不到，那么就会去访问类方法`+ (BOOL)accessInstanceVariablesDirectly`，询问是否允许直接访问成员变量，默认返回YES\n\t\n  - 如果返回NO的话，那么程序会直接抛出异常`exception NSUnknownKeyException, reason:[XXX setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key age`\n\n  - 如果返回YES，那么程序会去直接访问成员变量，查找的顺序是`_key、_isKey、key、isKey`，类似下面这样子\n  \n```\n{\n    @public \n    int _age;\n    int _isAge;\n    int age;\n    int isAge;\n}\n```\n  \t\n  1. 如果找到了成员变量，那么就直接赋值\n  2. 如果找不到成员变量，那么就抛出上述异常\n    \n## KVC是否会触发KVO\n\n由于KVO是通过重写set方法的方式实现的，所以如果KVC找到了属性值并且通过set方法赋值的话，那么就自然会触发KVO\n\n如果KVC找不到set方法，如果`+ (BOOL)accessInstanceVariablesDirectly`返回YES的话，那么他去访问成员方法的时候，即便这时候成员方法是没有实现set方法的，KVC依旧会去执行`willChangeValueForKey:`和`didChangeValueForKey:`方法，在执行`didChangeValueForKey:`的时候，自然KVO就被触发了\n\n## valueForKey:的底层原理\n\n`valueForKey:`首先会根据`getKey、key、isKey、_key`顺序查找方法，找到了的话就调用，拿到返回值。\n\n如果没有找到方法，那么就会去访问类方法`+ (BOOL)accessInstanceVariablesDirectly`，询问是否允许直接访问成员变量，默认返回YES\n\n如果允许，那么按照`_key、_isKey、key、isKey`顺序查找成员变量，找到了的话就直接取值，找不到就抛出异常`NSUnknownKeyException`。\n\n如果不允许，就抛出异常`NSUnknownKeyException`","source":"_posts/iOS-底层原理-KVC.md","raw":"title: iOS 底层原理 --- KVC\nabbrlink: 34b9a649\ntags:\n  - iOS\n  - 底层原理\ncategories:\n  - iOS\nauthor: Arclin\ndate: 2021-05-30 11:59:00\n---\n本文讲述KVC的底层实现和KVC是否能触发KVO呢？\n\n<!--more-->\n\n## KVC的使用\n\n\n```\n[self.person setValue:@10 forKey:@\"age\"]\n\n[self.person setValue:@10 forKeyPath:@\"age\"]\n```\n\nkeyPath和key的区别是，keyPath可以使用路径的方式进行赋值，比如person对象内有cat模型属性，cat对象里面有age属性，那么就可以使用`[self.person setValue:@10 forKeyPath:@\"cat.age\"]`的方式使用KVC，而key方式只支持直接访问的方式赋值\n\n## 赋值过程\n\n`setValue:forKey`首先会先寻找`setKey:`方法，如果找不到，那么就会寻找`_setKey:`方法，类似下面这样子\n\n```\n/// 优先找这个方法\n- （void）setAge:(int)age {\n\t_age = age;\n}\n\n/// 找不到上面那个方法的话，就找下面这儿方法\n- （void）_setAge:(int)age {\n\t_age = age;\n}\n```\n\n如果上述两个方法都找不到，那么就会去访问类方法`+ (BOOL)accessInstanceVariablesDirectly`，询问是否允许直接访问成员变量，默认返回YES\n\t\n  - 如果返回NO的话，那么程序会直接抛出异常`exception NSUnknownKeyException, reason:[XXX setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key age`\n\n  - 如果返回YES，那么程序会去直接访问成员变量，查找的顺序是`_key、_isKey、key、isKey`，类似下面这样子\n  \n```\n{\n    @public \n    int _age;\n    int _isAge;\n    int age;\n    int isAge;\n}\n```\n  \t\n  1. 如果找到了成员变量，那么就直接赋值\n  2. 如果找不到成员变量，那么就抛出上述异常\n    \n## KVC是否会触发KVO\n\n由于KVO是通过重写set方法的方式实现的，所以如果KVC找到了属性值并且通过set方法赋值的话，那么就自然会触发KVO\n\n如果KVC找不到set方法，如果`+ (BOOL)accessInstanceVariablesDirectly`返回YES的话，那么他去访问成员方法的时候，即便这时候成员方法是没有实现set方法的，KVC依旧会去执行`willChangeValueForKey:`和`didChangeValueForKey:`方法，在执行`didChangeValueForKey:`的时候，自然KVO就被触发了\n\n## valueForKey:的底层原理\n\n`valueForKey:`首先会根据`getKey、key、isKey、_key`顺序查找方法，找到了的话就调用，拿到返回值。\n\n如果没有找到方法，那么就会去访问类方法`+ (BOOL)accessInstanceVariablesDirectly`，询问是否允许直接访问成员变量，默认返回YES\n\n如果允许，那么按照`_key、_isKey、key、isKey`顺序查找成员变量，找到了的话就直接取值，找不到就抛出异常`NSUnknownKeyException`。\n\n如果不允许，就抛出异常`NSUnknownKeyException`","slug":"iOS-底层原理-KVC","published":1,"updated":"2021-06-06T18:52:24.963Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohp003itnn043c0ggci","content":"<p>本文讲述KVC的底层实现和KVC是否能触发KVO呢？</p>\n<span id=\"more\"></span>\n\n<h2 id=\"KVC的使用\"><a href=\"#KVC的使用\" class=\"headerlink\" title=\"KVC的使用\"></a>KVC的使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self.person setValue:@10 forKey:@&quot;age&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">[self.person setValue:@10 forKeyPath:@&quot;age&quot;]</span><br></pre></td></tr></table></figure>\n\n<p>keyPath和key的区别是，keyPath可以使用路径的方式进行赋值，比如person对象内有cat模型属性，cat对象里面有age属性，那么就可以使用<code>[self.person setValue:@10 forKeyPath:@&quot;cat.age&quot;]</code>的方式使用KVC，而key方式只支持直接访问的方式赋值</p>\n<h2 id=\"赋值过程\"><a href=\"#赋值过程\" class=\"headerlink\" title=\"赋值过程\"></a>赋值过程</h2><p><code>setValue:forKey</code>首先会先寻找<code>setKey:</code>方法，如果找不到，那么就会寻找<code>_setKey:</code>方法，类似下面这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;&#x2F; 优先找这个方法</span><br><span class=\"line\">- （void）setAge:(int)age &#123;</span><br><span class=\"line\">\t_age &#x3D; age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;&#x2F; 找不到上面那个方法的话，就找下面这儿方法</span><br><span class=\"line\">- （void）_setAge:(int)age &#123;</span><br><span class=\"line\">\t_age &#x3D; age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果上述两个方法都找不到，那么就会去访问类方法<code>+ (BOOL)accessInstanceVariablesDirectly</code>，询问是否允许直接访问成员变量，默认返回YES</p>\n<ul>\n<li><p>如果返回NO的话，那么程序会直接抛出异常<code>exception NSUnknownKeyException, reason:[XXX setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key age</code></p>\n</li>\n<li><p>如果返回YES，那么程序会去直接访问成员变量，查找的顺序是<code>_key、_isKey、key、isKey</code>，类似下面这样子</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    @public </span><br><span class=\"line\">    int _age;</span><br><span class=\"line\">    int _isAge;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">    int isAge;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果找到了成员变量，那么就直接赋值</li>\n<li>如果找不到成员变量，那么就抛出上述异常</li>\n</ol>\n<h2 id=\"KVC是否会触发KVO\"><a href=\"#KVC是否会触发KVO\" class=\"headerlink\" title=\"KVC是否会触发KVO\"></a>KVC是否会触发KVO</h2><p>由于KVO是通过重写set方法的方式实现的，所以如果KVC找到了属性值并且通过set方法赋值的话，那么就自然会触发KVO</p>\n<p>如果KVC找不到set方法，如果<code>+ (BOOL)accessInstanceVariablesDirectly</code>返回YES的话，那么他去访问成员方法的时候，即便这时候成员方法是没有实现set方法的，KVC依旧会去执行<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>方法，在执行<code>didChangeValueForKey:</code>的时候，自然KVO就被触发了</p>\n<h2 id=\"valueForKey-的底层原理\"><a href=\"#valueForKey-的底层原理\" class=\"headerlink\" title=\"valueForKey:的底层原理\"></a>valueForKey:的底层原理</h2><p><code>valueForKey:</code>首先会根据<code>getKey、key、isKey、_key</code>顺序查找方法，找到了的话就调用，拿到返回值。</p>\n<p>如果没有找到方法，那么就会去访问类方法<code>+ (BOOL)accessInstanceVariablesDirectly</code>，询问是否允许直接访问成员变量，默认返回YES</p>\n<p>如果允许，那么按照<code>_key、_isKey、key、isKey</code>顺序查找成员变量，找到了的话就直接取值，找不到就抛出异常<code>NSUnknownKeyException</code>。</p>\n<p>如果不允许，就抛出异常<code>NSUnknownKeyException</code></p>\n","site":{"data":{}},"excerpt":"<p>本文讲述KVC的底层实现和KVC是否能触发KVO呢？</p>","more":"<h2 id=\"KVC的使用\"><a href=\"#KVC的使用\" class=\"headerlink\" title=\"KVC的使用\"></a>KVC的使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self.person setValue:@10 forKey:@&quot;age&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">[self.person setValue:@10 forKeyPath:@&quot;age&quot;]</span><br></pre></td></tr></table></figure>\n\n<p>keyPath和key的区别是，keyPath可以使用路径的方式进行赋值，比如person对象内有cat模型属性，cat对象里面有age属性，那么就可以使用<code>[self.person setValue:@10 forKeyPath:@&quot;cat.age&quot;]</code>的方式使用KVC，而key方式只支持直接访问的方式赋值</p>\n<h2 id=\"赋值过程\"><a href=\"#赋值过程\" class=\"headerlink\" title=\"赋值过程\"></a>赋值过程</h2><p><code>setValue:forKey</code>首先会先寻找<code>setKey:</code>方法，如果找不到，那么就会寻找<code>_setKey:</code>方法，类似下面这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;&#x2F; 优先找这个方法</span><br><span class=\"line\">- （void）setAge:(int)age &#123;</span><br><span class=\"line\">\t_age &#x3D; age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;&#x2F; 找不到上面那个方法的话，就找下面这儿方法</span><br><span class=\"line\">- （void）_setAge:(int)age &#123;</span><br><span class=\"line\">\t_age &#x3D; age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果上述两个方法都找不到，那么就会去访问类方法<code>+ (BOOL)accessInstanceVariablesDirectly</code>，询问是否允许直接访问成员变量，默认返回YES</p>\n<ul>\n<li><p>如果返回NO的话，那么程序会直接抛出异常<code>exception NSUnknownKeyException, reason:[XXX setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key age</code></p>\n</li>\n<li><p>如果返回YES，那么程序会去直接访问成员变量，查找的顺序是<code>_key、_isKey、key、isKey</code>，类似下面这样子</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    @public </span><br><span class=\"line\">    int _age;</span><br><span class=\"line\">    int _isAge;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\">    int isAge;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果找到了成员变量，那么就直接赋值</li>\n<li>如果找不到成员变量，那么就抛出上述异常</li>\n</ol>\n<h2 id=\"KVC是否会触发KVO\"><a href=\"#KVC是否会触发KVO\" class=\"headerlink\" title=\"KVC是否会触发KVO\"></a>KVC是否会触发KVO</h2><p>由于KVO是通过重写set方法的方式实现的，所以如果KVC找到了属性值并且通过set方法赋值的话，那么就自然会触发KVO</p>\n<p>如果KVC找不到set方法，如果<code>+ (BOOL)accessInstanceVariablesDirectly</code>返回YES的话，那么他去访问成员方法的时候，即便这时候成员方法是没有实现set方法的，KVC依旧会去执行<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>方法，在执行<code>didChangeValueForKey:</code>的时候，自然KVO就被触发了</p>\n<h2 id=\"valueForKey-的底层原理\"><a href=\"#valueForKey-的底层原理\" class=\"headerlink\" title=\"valueForKey:的底层原理\"></a>valueForKey:的底层原理</h2><p><code>valueForKey:</code>首先会根据<code>getKey、key、isKey、_key</code>顺序查找方法，找到了的话就调用，拿到返回值。</p>\n<p>如果没有找到方法，那么就会去访问类方法<code>+ (BOOL)accessInstanceVariablesDirectly</code>，询问是否允许直接访问成员变量，默认返回YES</p>\n<p>如果允许，那么按照<code>_key、_isKey、key、isKey</code>顺序查找成员变量，找到了的话就直接取值，找不到就抛出异常<code>NSUnknownKeyException</code>。</p>\n<p>如果不允许，就抛出异常<code>NSUnknownKeyException</code></p>"},{"title":"iOS 底层原理 --- KVO","abbrlink":"81c45883","date":"2021-05-26T17:06:23.000Z","_content":"\n本文简述KVO的底层实现是怎么一回事\n\n<!--more-->\n\n# 如何使用KVO\n\n举例\n\n```\nself.person = [[Person alloc] init];\nself.person.age = 1;\n\n/// 这个配置的值会直接影响监听方法的change字典里面带些什么值给你\nNSKeyValueObservingOptions options = NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld;\n\n[self.person addObserver:self keyPath:@\"age\" options:options context:@\"123\"];\n\n```\n\n\n```\n/// 当监听对象的属性值发生改变时，就会调用这个方法\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context {\n\t/// 这里的context就是注册监听的时候传入的@“123”\n}\n```\n\n# 内部发生了什么\n\n系统通过运行时机制，给`person`对象添加了一个父类，名为`NSKVONotifying_Person`(其他被监听的对象所生成的类也会遵循这个命名规则)，本质上是将`person`对象的isa指针指向了这个动态新建的类对象。\n\n另外，这个新建的类对象是继承自`Person`的，也就是`NSKVONotifying_Person`的superclass指针指向了`Persond`的类对象。\n\n# NSKVONotifying_*类内部结构\n\n- isa指针\n- superclass指针\n- setAge:方法  因为监听的是age属性，所以重写了setAge方法，若监听的属性没有set方法，或者值改变的时候没有调用set方法，那么KVO无法生效\n- class:方法，主要是为了防止对象调用class方法的时候得到了这个动态生成的类对象，所以重写class方法，返回真正`的Person`类对象\n- _isKVOA方法，返回一个bool，用来判断这是不是一个KVO类\n- dealloc 进行一些收尾工作\n\n## 重写的set方法的实现\n\n大概是这么实现的\n\n```\n- (void)setAge:(int)age {\n   _NSSetIntValueAnyNotify();\n}\n\nvoid _NSSetIntValueAnyNotify() \n{\n   [self willChangeValueForKey:@\"age\"];\n   [super setAge:age];\n   [self didChangeValueForKey:@\"age\"];\n}\n\n- (void)didChangeValueForKey:(NSString *)key {\n   [observer observeValueForKeyPath:key ofObject:self change:nil context:nil];\n}\n\n```\n\n这里的方法`_NSSetIntValueAnyNotify`，看具体监听的属性类型而定，如果监听的是`double`类型，那么方法就会变成`_NSSetDoubleValueAnyNotify`，所以系统内置了很多这种类似的方法，统称为`_NSSet*ValueAnyNotify`\n\n- 调用流程\n\n\t1. willChangeValueForKey:\n\t2. setAge:\n\t3. observeValueForKeyPath:ofObject:change:context:\n\t4. didChangeValueForKey:\n\n\n## 总结\n\n- 利用Runtime API动态生成一个之类，并且让instance对象的isa指针指向这个全新的子类\n- 当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAnyNotify函数\n\t- willChangeValueForKey:\n\t- 父类原来的setter\n\t- didChangeValueForKey:\n\t\t- 内部会触发监听器（Observer）的监听方法（observeValueForKeyPath:ofObject:change:context:）\n\n- 如何手动触发KVO\n\t注册监听后，手动调用`willChangeValueForKey:`和`didChangeValueForKey:`\n\t\n- 直接修改成员属性的值不会触发KVO，必须在前后分别补上`willChangeValueForKey:`和`didChangeValueForKey:`","source":"_posts/iOS-底层原理-KVO.md","raw":"---\ntitle: iOS 底层原理 --- KVO\ntags:\n  - iOS\n  - 底层原理\ncategories:\n  - iOS\nabbrlink: 81c45883\ndate: 2021-05-27 01:06:23\n---\n\n本文简述KVO的底层实现是怎么一回事\n\n<!--more-->\n\n# 如何使用KVO\n\n举例\n\n```\nself.person = [[Person alloc] init];\nself.person.age = 1;\n\n/// 这个配置的值会直接影响监听方法的change字典里面带些什么值给你\nNSKeyValueObservingOptions options = NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld;\n\n[self.person addObserver:self keyPath:@\"age\" options:options context:@\"123\"];\n\n```\n\n\n```\n/// 当监听对象的属性值发生改变时，就会调用这个方法\n- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context {\n\t/// 这里的context就是注册监听的时候传入的@“123”\n}\n```\n\n# 内部发生了什么\n\n系统通过运行时机制，给`person`对象添加了一个父类，名为`NSKVONotifying_Person`(其他被监听的对象所生成的类也会遵循这个命名规则)，本质上是将`person`对象的isa指针指向了这个动态新建的类对象。\n\n另外，这个新建的类对象是继承自`Person`的，也就是`NSKVONotifying_Person`的superclass指针指向了`Persond`的类对象。\n\n# NSKVONotifying_*类内部结构\n\n- isa指针\n- superclass指针\n- setAge:方法  因为监听的是age属性，所以重写了setAge方法，若监听的属性没有set方法，或者值改变的时候没有调用set方法，那么KVO无法生效\n- class:方法，主要是为了防止对象调用class方法的时候得到了这个动态生成的类对象，所以重写class方法，返回真正`的Person`类对象\n- _isKVOA方法，返回一个bool，用来判断这是不是一个KVO类\n- dealloc 进行一些收尾工作\n\n## 重写的set方法的实现\n\n大概是这么实现的\n\n```\n- (void)setAge:(int)age {\n   _NSSetIntValueAnyNotify();\n}\n\nvoid _NSSetIntValueAnyNotify() \n{\n   [self willChangeValueForKey:@\"age\"];\n   [super setAge:age];\n   [self didChangeValueForKey:@\"age\"];\n}\n\n- (void)didChangeValueForKey:(NSString *)key {\n   [observer observeValueForKeyPath:key ofObject:self change:nil context:nil];\n}\n\n```\n\n这里的方法`_NSSetIntValueAnyNotify`，看具体监听的属性类型而定，如果监听的是`double`类型，那么方法就会变成`_NSSetDoubleValueAnyNotify`，所以系统内置了很多这种类似的方法，统称为`_NSSet*ValueAnyNotify`\n\n- 调用流程\n\n\t1. willChangeValueForKey:\n\t2. setAge:\n\t3. observeValueForKeyPath:ofObject:change:context:\n\t4. didChangeValueForKey:\n\n\n## 总结\n\n- 利用Runtime API动态生成一个之类，并且让instance对象的isa指针指向这个全新的子类\n- 当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAnyNotify函数\n\t- willChangeValueForKey:\n\t- 父类原来的setter\n\t- didChangeValueForKey:\n\t\t- 内部会触发监听器（Observer）的监听方法（observeValueForKeyPath:ofObject:change:context:）\n\n- 如何手动触发KVO\n\t注册监听后，手动调用`willChangeValueForKey:`和`didChangeValueForKey:`\n\t\n- 直接修改成员属性的值不会触发KVO，必须在前后分别补上`willChangeValueForKey:`和`didChangeValueForKey:`","slug":"iOS-底层原理-KVO","published":1,"updated":"2021-06-06T18:52:24.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohp003mtnn049tf7vsv","content":"<p>本文简述KVO的底层实现是怎么一回事</p>\n<span id=\"more\"></span>\n\n<h1 id=\"如何使用KVO\"><a href=\"#如何使用KVO\" class=\"headerlink\" title=\"如何使用KVO\"></a>如何使用KVO</h1><p>举例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.person &#x3D; [[Person alloc] init];</span><br><span class=\"line\">self.person.age &#x3D; 1;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;&#x2F; 这个配置的值会直接影响监听方法的change字典里面带些什么值给你</span><br><span class=\"line\">NSKeyValueObservingOptions options &#x3D; NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld;</span><br><span class=\"line\"></span><br><span class=\"line\">[self.person addObserver:self keyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;&#x2F; 当监听对象的属性值发生改变时，就会调用这个方法</span><br><span class=\"line\">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;&#x2F; 这里的context就是注册监听的时候传入的@“123”</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"内部发生了什么\"><a href=\"#内部发生了什么\" class=\"headerlink\" title=\"内部发生了什么\"></a>内部发生了什么</h1><p>系统通过运行时机制，给<code>person</code>对象添加了一个父类，名为<code>NSKVONotifying_Person</code>(其他被监听的对象所生成的类也会遵循这个命名规则)，本质上是将<code>person</code>对象的isa指针指向了这个动态新建的类对象。</p>\n<p>另外，这个新建的类对象是继承自<code>Person</code>的，也就是<code>NSKVONotifying_Person</code>的superclass指针指向了<code>Persond</code>的类对象。</p>\n<h1 id=\"NSKVONotifying-类内部结构\"><a href=\"#NSKVONotifying-类内部结构\" class=\"headerlink\" title=\"NSKVONotifying_*类内部结构\"></a>NSKVONotifying_*类内部结构</h1><ul>\n<li>isa指针</li>\n<li>superclass指针</li>\n<li>setAge:方法  因为监听的是age属性，所以重写了setAge方法，若监听的属性没有set方法，或者值改变的时候没有调用set方法，那么KVO无法生效</li>\n<li>class:方法，主要是为了防止对象调用class方法的时候得到了这个动态生成的类对象，所以重写class方法，返回真正<code>的Person</code>类对象</li>\n<li>_isKVOA方法，返回一个bool，用来判断这是不是一个KVO类</li>\n<li>dealloc 进行一些收尾工作</li>\n</ul>\n<h2 id=\"重写的set方法的实现\"><a href=\"#重写的set方法的实现\" class=\"headerlink\" title=\"重写的set方法的实现\"></a>重写的set方法的实现</h2><p>大概是这么实现的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setAge:(int)age &#123;</span><br><span class=\"line\">   _NSSetIntValueAnyNotify();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void _NSSetIntValueAnyNotify() </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   [self willChangeValueForKey:@&quot;age&quot;];</span><br><span class=\"line\">   [super setAge:age];</span><br><span class=\"line\">   [self didChangeValueForKey:@&quot;age&quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)didChangeValueForKey:(NSString *)key &#123;</span><br><span class=\"line\">   [observer observeValueForKeyPath:key ofObject:self change:nil context:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里的方法<code>_NSSetIntValueAnyNotify</code>，看具体监听的属性类型而定，如果监听的是<code>double</code>类型，那么方法就会变成<code>_NSSetDoubleValueAnyNotify</code>，所以系统内置了很多这种类似的方法，统称为<code>_NSSet*ValueAnyNotify</code></p>\n<ul>\n<li><p>调用流程</p>\n<ol>\n<li>willChangeValueForKey:</li>\n<li>setAge:</li>\n<li>observeValueForKeyPath:ofObject:change:context:</li>\n<li>didChangeValueForKey:</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><p>利用Runtime API动态生成一个之类，并且让instance对象的isa指针指向这个全新的子类</p>\n</li>\n<li><p>当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAnyNotify函数</p>\n<ul>\n<li>willChangeValueForKey:</li>\n<li>父类原来的setter</li>\n<li>didChangeValueForKey:<ul>\n<li>内部会触发监听器（Observer）的监听方法（observeValueForKeyPath:ofObject:change:context:）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如何手动触发KVO<br>  注册监听后，手动调用<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p>\n</li>\n<li><p>直接修改成员属性的值不会触发KVO，必须在前后分别补上<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文简述KVO的底层实现是怎么一回事</p>","more":"<h1 id=\"如何使用KVO\"><a href=\"#如何使用KVO\" class=\"headerlink\" title=\"如何使用KVO\"></a>如何使用KVO</h1><p>举例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.person &#x3D; [[Person alloc] init];</span><br><span class=\"line\">self.person.age &#x3D; 1;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;&#x2F; 这个配置的值会直接影响监听方法的change字典里面带些什么值给你</span><br><span class=\"line\">NSKeyValueObservingOptions options &#x3D; NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld;</span><br><span class=\"line\"></span><br><span class=\"line\">[self.person addObserver:self keyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;&#x2F; 当监听对象的属性值发生改变时，就会调用这个方法</span><br><span class=\"line\">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F;&#x2F; 这里的context就是注册监听的时候传入的@“123”</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"内部发生了什么\"><a href=\"#内部发生了什么\" class=\"headerlink\" title=\"内部发生了什么\"></a>内部发生了什么</h1><p>系统通过运行时机制，给<code>person</code>对象添加了一个父类，名为<code>NSKVONotifying_Person</code>(其他被监听的对象所生成的类也会遵循这个命名规则)，本质上是将<code>person</code>对象的isa指针指向了这个动态新建的类对象。</p>\n<p>另外，这个新建的类对象是继承自<code>Person</code>的，也就是<code>NSKVONotifying_Person</code>的superclass指针指向了<code>Persond</code>的类对象。</p>\n<h1 id=\"NSKVONotifying-类内部结构\"><a href=\"#NSKVONotifying-类内部结构\" class=\"headerlink\" title=\"NSKVONotifying_*类内部结构\"></a>NSKVONotifying_*类内部结构</h1><ul>\n<li>isa指针</li>\n<li>superclass指针</li>\n<li>setAge:方法  因为监听的是age属性，所以重写了setAge方法，若监听的属性没有set方法，或者值改变的时候没有调用set方法，那么KVO无法生效</li>\n<li>class:方法，主要是为了防止对象调用class方法的时候得到了这个动态生成的类对象，所以重写class方法，返回真正<code>的Person</code>类对象</li>\n<li>_isKVOA方法，返回一个bool，用来判断这是不是一个KVO类</li>\n<li>dealloc 进行一些收尾工作</li>\n</ul>\n<h2 id=\"重写的set方法的实现\"><a href=\"#重写的set方法的实现\" class=\"headerlink\" title=\"重写的set方法的实现\"></a>重写的set方法的实现</h2><p>大概是这么实现的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setAge:(int)age &#123;</span><br><span class=\"line\">   _NSSetIntValueAnyNotify();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void _NSSetIntValueAnyNotify() </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   [self willChangeValueForKey:@&quot;age&quot;];</span><br><span class=\"line\">   [super setAge:age];</span><br><span class=\"line\">   [self didChangeValueForKey:@&quot;age&quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)didChangeValueForKey:(NSString *)key &#123;</span><br><span class=\"line\">   [observer observeValueForKeyPath:key ofObject:self change:nil context:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这里的方法<code>_NSSetIntValueAnyNotify</code>，看具体监听的属性类型而定，如果监听的是<code>double</code>类型，那么方法就会变成<code>_NSSetDoubleValueAnyNotify</code>，所以系统内置了很多这种类似的方法，统称为<code>_NSSet*ValueAnyNotify</code></p>\n<ul>\n<li><p>调用流程</p>\n<ol>\n<li>willChangeValueForKey:</li>\n<li>setAge:</li>\n<li>observeValueForKeyPath:ofObject:change:context:</li>\n<li>didChangeValueForKey:</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li><p>利用Runtime API动态生成一个之类，并且让instance对象的isa指针指向这个全新的子类</p>\n</li>\n<li><p>当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAnyNotify函数</p>\n<ul>\n<li>willChangeValueForKey:</li>\n<li>父类原来的setter</li>\n<li>didChangeValueForKey:<ul>\n<li>内部会触发监听器（Observer）的监听方法（observeValueForKeyPath:ofObject:change:context:）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如何手动触发KVO<br>  注册监听后，手动调用<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p>\n</li>\n<li><p>直接修改成员属性的值不会触发KVO，必须在前后分别补上<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p>\n</li>\n</ul>"},{"title":"iOS 底层原理 --- NSObject","author":"Arclin","abbrlink":"70f61b87","date":"2021-05-25T14:34:00.000Z","_content":"本文只是作为iOS底层原理课程的笔记用，所以均为结论性内容，如有疑问可在评论区进行探讨。\n\n<!--more-->\n\n##  NSObject的本质\n\n### 一个NSObject对象占用16个字节。\n\n验证方法\n\n1. 初始化一个`NSObject`对象\n\t`NSObject *obj = [[NSObject alloc] init];`\n\n2. 打印内存分配的量，得到16字节\n\t`malloc_size((__bridge const void *)obj)` \n\n3. 但是实际上只使用了8个字节，因为使用`class_getInstanceSize([NSObject class])`得到8\n\n`class_getInstanceSize`计算出了NSObject对象内的成员变量（即isa）的占用内存大小\n\n### NSObject实质上是一个结构体对象\n\n大概长这样\n\n```\nstruct NSObject_IMPL {\n\tClass isa;\n}\n```\n\n因为成员变量isa永远是对象（NSObject的子类对象）的第一个成员变量，所以对象的地址就是成员变量isa的地址\n\n### NSObject的子类\n\n比如有这么一个类\n\n```\n@interface Student : NSObject\n{\n    @public\n    int _no;\n    int _age;\n    int _height;\n}\n```\n\n实例化一下\n\n```\nStudent *stu = [[Student alloc] init];\n```\n\n`class_getInstanceSize([Student class])` 得到 24（意思为这个类至少需要的内存）\n`malloc_size((__bridge const void *)stu)` 得到32（意思为系统分配给这个类的内存）\n\n一般情况下我们更关心`malloc_size`得到的值\n\n因为继承自`NSObject`，所以`Student`有一个`Class isa`属性，占用8个字节，`_no`、`_age`、`_height` 各占用4个字节，一共占用20个字节，\n\n因为内存分配原则为**最大成员所占内存**（目前是isa 最大）的倍数，所以给够24个，这个叫做字节对齐\n\n因为 `isa`、`_no`、`_age` 刚好够 16个字节了，这时候突然又来多了个`_height`，这时候就需要20个字节了 , 那么为了适配各个厂商的内存读取规则，又给他分配了16个（凑16的倍数），这个叫做内存对齐，所以一共给类分配了 32个字节\n\n注：int 占用4个字节 double占用8个字节\n\n分配原则：如果内存一行(16个字节)放不下，那么就直接开新的一行\n比如\n\n```\n_no : Int \n_age : Double\n_height : Int\n```\n\n第一行：`isa` :8个，`_no` 4个，第一行剩下4个字节的位置，不够放`_age`,但是够放`_height`，那就直接放`_height`，如果这时候`_height`是`Double`的话，没别的东西来占用这4个位置，那么就直接放弃，开辟下一行\n第二行：前八个位置直接给`_age`\n\n```\n0x108b0bb00: d1 81 00 00 01 80 1d 01  <- isa   04 00 00 00 <- age   00 00 00 00  <- height ................\n0x108b0bb10: 00 00 00 00 00 00 00 00  <- age 00 00 00 00 00 00 00 00  ................\n```\n\n### sizeof()\n\n__sizeof()__方法是一个运算符，在编译期间就确定值，类似于宏替换，他的作用是计算传入的对象占用的内存的大小，如果传入的是类型（或者类名）的话，就计算类型占用的大小，比如传入一个对象的话，就是计算指向这个对象的指针的大小，指针占用的内存大小是8个字节，跟`class_getInstanceSize`的区别是`class_getInstanceSize`是计算类实例化后占用的大小。\n","source":"_posts/iOS-底层原理-NSObject.md","raw":"title: iOS 底层原理 --- NSObject\nauthor: Arclin\nabbrlink: 70f61b87\ntags:\n  - iOS \n  - 底层原理\ncategories:\n  - iOS\ndate: 2021-05-25 22:34:00\n---\n本文只是作为iOS底层原理课程的笔记用，所以均为结论性内容，如有疑问可在评论区进行探讨。\n\n<!--more-->\n\n##  NSObject的本质\n\n### 一个NSObject对象占用16个字节。\n\n验证方法\n\n1. 初始化一个`NSObject`对象\n\t`NSObject *obj = [[NSObject alloc] init];`\n\n2. 打印内存分配的量，得到16字节\n\t`malloc_size((__bridge const void *)obj)` \n\n3. 但是实际上只使用了8个字节，因为使用`class_getInstanceSize([NSObject class])`得到8\n\n`class_getInstanceSize`计算出了NSObject对象内的成员变量（即isa）的占用内存大小\n\n### NSObject实质上是一个结构体对象\n\n大概长这样\n\n```\nstruct NSObject_IMPL {\n\tClass isa;\n}\n```\n\n因为成员变量isa永远是对象（NSObject的子类对象）的第一个成员变量，所以对象的地址就是成员变量isa的地址\n\n### NSObject的子类\n\n比如有这么一个类\n\n```\n@interface Student : NSObject\n{\n    @public\n    int _no;\n    int _age;\n    int _height;\n}\n```\n\n实例化一下\n\n```\nStudent *stu = [[Student alloc] init];\n```\n\n`class_getInstanceSize([Student class])` 得到 24（意思为这个类至少需要的内存）\n`malloc_size((__bridge const void *)stu)` 得到32（意思为系统分配给这个类的内存）\n\n一般情况下我们更关心`malloc_size`得到的值\n\n因为继承自`NSObject`，所以`Student`有一个`Class isa`属性，占用8个字节，`_no`、`_age`、`_height` 各占用4个字节，一共占用20个字节，\n\n因为内存分配原则为**最大成员所占内存**（目前是isa 最大）的倍数，所以给够24个，这个叫做字节对齐\n\n因为 `isa`、`_no`、`_age` 刚好够 16个字节了，这时候突然又来多了个`_height`，这时候就需要20个字节了 , 那么为了适配各个厂商的内存读取规则，又给他分配了16个（凑16的倍数），这个叫做内存对齐，所以一共给类分配了 32个字节\n\n注：int 占用4个字节 double占用8个字节\n\n分配原则：如果内存一行(16个字节)放不下，那么就直接开新的一行\n比如\n\n```\n_no : Int \n_age : Double\n_height : Int\n```\n\n第一行：`isa` :8个，`_no` 4个，第一行剩下4个字节的位置，不够放`_age`,但是够放`_height`，那就直接放`_height`，如果这时候`_height`是`Double`的话，没别的东西来占用这4个位置，那么就直接放弃，开辟下一行\n第二行：前八个位置直接给`_age`\n\n```\n0x108b0bb00: d1 81 00 00 01 80 1d 01  <- isa   04 00 00 00 <- age   00 00 00 00  <- height ................\n0x108b0bb10: 00 00 00 00 00 00 00 00  <- age 00 00 00 00 00 00 00 00  ................\n```\n\n### sizeof()\n\n__sizeof()__方法是一个运算符，在编译期间就确定值，类似于宏替换，他的作用是计算传入的对象占用的内存的大小，如果传入的是类型（或者类名）的话，就计算类型占用的大小，比如传入一个对象的话，就是计算指向这个对象的指针的大小，指针占用的内存大小是8个字节，跟`class_getInstanceSize`的区别是`class_getInstanceSize`是计算类实例化后占用的大小。\n","slug":"iOS-底层原理-NSObject","published":1,"updated":"2021-06-06T18:52:24.963Z","_id":"ckqqxyohq003ptnn05aeb7vlm","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文只是作为iOS底层原理课程的笔记用，所以均为结论性内容，如有疑问可在评论区进行探讨。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"NSObject的本质\"><a href=\"#NSObject的本质\" class=\"headerlink\" title=\"NSObject的本质\"></a>NSObject的本质</h2><h3 id=\"一个NSObject对象占用16个字节。\"><a href=\"#一个NSObject对象占用16个字节。\" class=\"headerlink\" title=\"一个NSObject对象占用16个字节。\"></a>一个NSObject对象占用16个字节。</h3><p>验证方法</p>\n<ol>\n<li><p>初始化一个<code>NSObject</code>对象<br> <code>NSObject *obj = [[NSObject alloc] init];</code></p>\n</li>\n<li><p>打印内存分配的量，得到16字节<br> <code>malloc_size((__bridge const void *)obj)</code> </p>\n</li>\n<li><p>但是实际上只使用了8个字节，因为使用<code>class_getInstanceSize([NSObject class])</code>得到8</p>\n</li>\n</ol>\n<p><code>class_getInstanceSize</code>计算出了NSObject对象内的成员变量（即isa）的占用内存大小</p>\n<h3 id=\"NSObject实质上是一个结构体对象\"><a href=\"#NSObject实质上是一个结构体对象\" class=\"headerlink\" title=\"NSObject实质上是一个结构体对象\"></a>NSObject实质上是一个结构体对象</h3><p>大概长这样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct NSObject_IMPL &#123;</span><br><span class=\"line\">\tClass isa;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为成员变量isa永远是对象（NSObject的子类对象）的第一个成员变量，所以对象的地址就是成员变量isa的地址</p>\n<h3 id=\"NSObject的子类\"><a href=\"#NSObject的子类\" class=\"headerlink\" title=\"NSObject的子类\"></a>NSObject的子类</h3><p>比如有这么一个类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Student : NSObject</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    @public</span><br><span class=\"line\">    int _no;</span><br><span class=\"line\">    int _age;</span><br><span class=\"line\">    int _height;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例化一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student *stu &#x3D; [[Student alloc] init];</span><br></pre></td></tr></table></figure>\n\n<p><code>class_getInstanceSize([Student class])</code> 得到 24（意思为这个类至少需要的内存）<br><code>malloc_size((__bridge const void *)stu)</code> 得到32（意思为系统分配给这个类的内存）</p>\n<p>一般情况下我们更关心<code>malloc_size</code>得到的值</p>\n<p>因为继承自<code>NSObject</code>，所以<code>Student</code>有一个<code>Class isa</code>属性，占用8个字节，<code>_no</code>、<code>_age</code>、<code>_height</code> 各占用4个字节，一共占用20个字节，</p>\n<p>因为内存分配原则为<strong>最大成员所占内存</strong>（目前是isa 最大）的倍数，所以给够24个，这个叫做字节对齐</p>\n<p>因为 <code>isa</code>、<code>_no</code>、<code>_age</code> 刚好够 16个字节了，这时候突然又来多了个<code>_height</code>，这时候就需要20个字节了 , 那么为了适配各个厂商的内存读取规则，又给他分配了16个（凑16的倍数），这个叫做内存对齐，所以一共给类分配了 32个字节</p>\n<p>注：int 占用4个字节 double占用8个字节</p>\n<p>分配原则：如果内存一行(16个字节)放不下，那么就直接开新的一行<br>比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_no : Int </span><br><span class=\"line\">_age : Double</span><br><span class=\"line\">_height : Int</span><br></pre></td></tr></table></figure>\n\n<p>第一行：<code>isa</code> :8个，<code>_no</code> 4个，第一行剩下4个字节的位置，不够放<code>_age</code>,但是够放<code>_height</code>，那就直接放<code>_height</code>，如果这时候<code>_height</code>是<code>Double</code>的话，没别的东西来占用这4个位置，那么就直接放弃，开辟下一行<br>第二行：前八个位置直接给<code>_age</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x108b0bb00: d1 81 00 00 01 80 1d 01  &lt;- isa   04 00 00 00 &lt;- age   00 00 00 00  &lt;- height ................</span><br><span class=\"line\">0x108b0bb10: 00 00 00 00 00 00 00 00  &lt;- age 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sizeof\"><a href=\"#sizeof\" class=\"headerlink\" title=\"sizeof()\"></a>sizeof()</h3><p>__sizeof()__方法是一个运算符，在编译期间就确定值，类似于宏替换，他的作用是计算传入的对象占用的内存的大小，如果传入的是类型（或者类名）的话，就计算类型占用的大小，比如传入一个对象的话，就是计算指向这个对象的指针的大小，指针占用的内存大小是8个字节，跟<code>class_getInstanceSize</code>的区别是<code>class_getInstanceSize</code>是计算类实例化后占用的大小。</p>\n","site":{"data":{}},"excerpt":"<p>本文只是作为iOS底层原理课程的笔记用，所以均为结论性内容，如有疑问可在评论区进行探讨。</p>","more":"<h2 id=\"NSObject的本质\"><a href=\"#NSObject的本质\" class=\"headerlink\" title=\"NSObject的本质\"></a>NSObject的本质</h2><h3 id=\"一个NSObject对象占用16个字节。\"><a href=\"#一个NSObject对象占用16个字节。\" class=\"headerlink\" title=\"一个NSObject对象占用16个字节。\"></a>一个NSObject对象占用16个字节。</h3><p>验证方法</p>\n<ol>\n<li><p>初始化一个<code>NSObject</code>对象<br> <code>NSObject *obj = [[NSObject alloc] init];</code></p>\n</li>\n<li><p>打印内存分配的量，得到16字节<br> <code>malloc_size((__bridge const void *)obj)</code> </p>\n</li>\n<li><p>但是实际上只使用了8个字节，因为使用<code>class_getInstanceSize([NSObject class])</code>得到8</p>\n</li>\n</ol>\n<p><code>class_getInstanceSize</code>计算出了NSObject对象内的成员变量（即isa）的占用内存大小</p>\n<h3 id=\"NSObject实质上是一个结构体对象\"><a href=\"#NSObject实质上是一个结构体对象\" class=\"headerlink\" title=\"NSObject实质上是一个结构体对象\"></a>NSObject实质上是一个结构体对象</h3><p>大概长这样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct NSObject_IMPL &#123;</span><br><span class=\"line\">\tClass isa;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为成员变量isa永远是对象（NSObject的子类对象）的第一个成员变量，所以对象的地址就是成员变量isa的地址</p>\n<h3 id=\"NSObject的子类\"><a href=\"#NSObject的子类\" class=\"headerlink\" title=\"NSObject的子类\"></a>NSObject的子类</h3><p>比如有这么一个类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Student : NSObject</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    @public</span><br><span class=\"line\">    int _no;</span><br><span class=\"line\">    int _age;</span><br><span class=\"line\">    int _height;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例化一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Student *stu &#x3D; [[Student alloc] init];</span><br></pre></td></tr></table></figure>\n\n<p><code>class_getInstanceSize([Student class])</code> 得到 24（意思为这个类至少需要的内存）<br><code>malloc_size((__bridge const void *)stu)</code> 得到32（意思为系统分配给这个类的内存）</p>\n<p>一般情况下我们更关心<code>malloc_size</code>得到的值</p>\n<p>因为继承自<code>NSObject</code>，所以<code>Student</code>有一个<code>Class isa</code>属性，占用8个字节，<code>_no</code>、<code>_age</code>、<code>_height</code> 各占用4个字节，一共占用20个字节，</p>\n<p>因为内存分配原则为<strong>最大成员所占内存</strong>（目前是isa 最大）的倍数，所以给够24个，这个叫做字节对齐</p>\n<p>因为 <code>isa</code>、<code>_no</code>、<code>_age</code> 刚好够 16个字节了，这时候突然又来多了个<code>_height</code>，这时候就需要20个字节了 , 那么为了适配各个厂商的内存读取规则，又给他分配了16个（凑16的倍数），这个叫做内存对齐，所以一共给类分配了 32个字节</p>\n<p>注：int 占用4个字节 double占用8个字节</p>\n<p>分配原则：如果内存一行(16个字节)放不下，那么就直接开新的一行<br>比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_no : Int </span><br><span class=\"line\">_age : Double</span><br><span class=\"line\">_height : Int</span><br></pre></td></tr></table></figure>\n\n<p>第一行：<code>isa</code> :8个，<code>_no</code> 4个，第一行剩下4个字节的位置，不够放<code>_age</code>,但是够放<code>_height</code>，那就直接放<code>_height</code>，如果这时候<code>_height</code>是<code>Double</code>的话，没别的东西来占用这4个位置，那么就直接放弃，开辟下一行<br>第二行：前八个位置直接给<code>_age</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x108b0bb00: d1 81 00 00 01 80 1d 01  &lt;- isa   04 00 00 00 &lt;- age   00 00 00 00  &lt;- height ................</span><br><span class=\"line\">0x108b0bb10: 00 00 00 00 00 00 00 00  &lt;- age 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sizeof\"><a href=\"#sizeof\" class=\"headerlink\" title=\"sizeof()\"></a>sizeof()</h3><p>__sizeof()__方法是一个运算符，在编译期间就确定值，类似于宏替换，他的作用是计算传入的对象占用的内存的大小，如果传入的是类型（或者类名）的话，就计算类型占用的大小，比如传入一个对象的话，就是计算指向这个对象的指针的大小，指针占用的内存大小是8个字节，跟<code>class_getInstanceSize</code>的区别是<code>class_getInstanceSize</code>是计算类实例化后占用的大小。</p>"},{"title":"iOS 底层原理 --- instance、class和meta-class","abbrlink":"fdd98f42","date":"2021-05-25T16:22:27.000Z","_content":"\n本文讲的是实例对象(instance)，类对象(class)，元类对象（meta-class）的内容和他们之间的联系\n\n<!--more-->\n\n# 实例对象\n\n实例对象内存储着成员变量的值\n\n# class对象\n\n## class对象的基本内容\n\n每个类在内存中有且只有一个class对象\n\nclass对象在内存中，存储的信息主要包括\n\n- isa指针\n- superclass指针\n- 类的属性信息（@property）、 类的对象方法信息（instance method）\n- 类的协议信息（protocol）、类的成员变量信息（ivar）\n\n\n## class对象的结构\n\n```\nrw: readwrite\nro: readonly\nt:   table\n```\n\n```\nstruct objc_class {\n\tClass isa;\n\tClass superclass;\n\tcache_t cache; \t// 方法缓存\n\tcache_data_bits_t bits; // 用于获取具体类信息\n\t\n\tclass_rw_t *data() {\n\t   return bits.data();  //  实际方法实现为 bits & FAST_DATA_MASK  结果返回值为 class_rw_t类型的对象\n\t}\n}\n\nstruct class_rw_t {\n\tunit32 flags;\n\tunit32 version;\n\tconst class_ro_t *ro;\t\t\t// 方法列表\n\tproperty_list_t *properties;\t\t// 属性列表\n\tconst protocol_list_t *protocols;\t// 协议列表\n\tClass firstSubclass;\n\tClass nextSiblingClass;\n\tchat *demangledName;\n};\n\nstruct class_ro_t {\n\tuint32_t flags;\n\tunit32_t instanceStart;\n\tunit32_t instanceSize; \t\t\t// instance对象占用的内存空间\n\t\n\tconst uint8_t * ivarLayout;\n\tconst chat * name; \t\t\t// 类名\n\tmethod_list_t  * baseMethodList;\n\tprotoocl_list_t * baseProtocols;\n\tconst ivar_list_t *ivars;\t\t  // 成员变量列表\n\tconst uint8_t *weakIverLayout;\n\tproperty_list_t *baseProperties;\n}\n```\n\n## 相关的几个函数\n\n1. `Class objc_getClass(const chat *aClassName)`\n    1. 传入字符串类名\n    2. 返回对应的类对象\n    \n2. `Class object_getClass(id obj)`获取isa指向的对象\n    1. 传入的obj可能是instance对象、class对象、meta-class对象\n    2. 返回值\n        1. 如果是instance对象，返回class对象\n        2. 如果是class对象，返回meta-class对象\n        3. 如果是meta-class对象，返回NSObject（基类）的meta-class对象\n        \n3.  `- (Class)class`、`+ (Class)class` 返回的就是类对象\n\n# meta-class对象\n\n意思是用来描述类对象的对象，是一种特殊的类对象。\n\n每个类在内存中有且只有一个meta-class对象\n\nmeta-class对象和class对象的内存接口是一样的，但是用途不一样，在内存中存储的信息主要包括\n\n- isa指针\n- superclass指针\n- 类的类方法信息\n\n# isa指针和spuerclass指针\n\n<img src=\"https://i.loli.net/2021/05/26/pjxbn5vQ17hrmae.png\" width=\"50%\">\n\n\n## isa指针\n\ninstance的isa指向class\n\n> 当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用\n\nclass的isa指向meta-class\n\n> 当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用 \n\nmeta-class的isa指向基类（NSObject）的meta-class（NSObject的meta-class的isa指向自己的meta-class）\n\n## superclass指针\n\n举个例子，比如Student类继承自Person类，Person类继承自NSObject类：\n\nStudent的class的superclass指针指向父类的class对象，如果没有父类（NSObject），则superclass指针为空\n\nStudent的meta-class对象的superclass指针指向Person的meta-class\n\n基类（NSObject）的meta-class的superclass指针指向class对象\n\n### 调用成员方法\n\n因为Student要调用成员方法的时候，需要找到class对象，因为class对象才存放着成员方法，找不到的话就通过superclass指针找到父类class对象看看里面有没有想要的成员方法\n\n### 调用类方法\n\n当Student要调用Student的类方法的时候，就通过Student的class对象的isa找到Student的meta-class对象，然后找到类方法进行调用\n\n当Student要调用Person的类方法的时候，就得先通过Student的class对象的isa找到Student的meta-class对象，然后通过Student的mata-class对象里面的superclass指针找到Person的meta-class对象，然后在里面找到Person的类方法进行调用\n\n### 调用init方法\n\n比如现在Student对象要调用init方法，流程如下\n1. 先通过对象自己的isa指针，找到Student的类对象\n2. Student的类对象里面有superclass指针，那么就通过superclass指针拿到了Person的类对象\n3. Person的类对象里面也有superclass指针，那么就通过superclass指针拿到NSObject的类对象\n4. NSObject的类对象里面找到了init方法的相关信息，那么就可以进行调用了\n\n### 调用不存在的类方法\n\nStudent调用一个不存在的类方法流程\n1. 通过isa指针找到类对象\n2. 类对象的isa指针找到meta-class对象\n3. meta-class找不到该类方法，通过superclass指针找到父类的meta-class对象\n4. 一直找，直到找到基类的meta-class对象，基类的meta-class的superclass指向基类的class对象\n5. 基类的class对象里面有对象方法，如果对象方法刚好跟准备调用的类方法同名，那么则会调用该对象方法，如果找不到，则开始抛出异常\n\n## ISA_MASK\n\n```\n#if __arm64___\n#define ISA_MASK 0x000000ffffffff8ULL\n#elif __x86_64__\n#define  ISA_MASK 0x00007ffffffffff8ULL\n#endif\n```\n\n实例对象从64位系统开始，isa不直接指向类对象的地址，isa需要进行一次位运算，才能计算出真实地址\n\n```\ninstance的 isa & ISA_MASK -> class对象\nclass的isa & ISA_MASK -> meta_class 对象\n```\n\n\n\n","source":"_posts/iOS-底层原理-instance、Class和meta-Class.md","raw":"---\ntitle: iOS 底层原理 --- instance、class和meta-class\ntags:\n  - iOS\n  - 底层原理\ncategories:\n  - iOS\nabbrlink: fdd98f42\ndate: 2021-05-26 00:22:27\n---\n\n本文讲的是实例对象(instance)，类对象(class)，元类对象（meta-class）的内容和他们之间的联系\n\n<!--more-->\n\n# 实例对象\n\n实例对象内存储着成员变量的值\n\n# class对象\n\n## class对象的基本内容\n\n每个类在内存中有且只有一个class对象\n\nclass对象在内存中，存储的信息主要包括\n\n- isa指针\n- superclass指针\n- 类的属性信息（@property）、 类的对象方法信息（instance method）\n- 类的协议信息（protocol）、类的成员变量信息（ivar）\n\n\n## class对象的结构\n\n```\nrw: readwrite\nro: readonly\nt:   table\n```\n\n```\nstruct objc_class {\n\tClass isa;\n\tClass superclass;\n\tcache_t cache; \t// 方法缓存\n\tcache_data_bits_t bits; // 用于获取具体类信息\n\t\n\tclass_rw_t *data() {\n\t   return bits.data();  //  实际方法实现为 bits & FAST_DATA_MASK  结果返回值为 class_rw_t类型的对象\n\t}\n}\n\nstruct class_rw_t {\n\tunit32 flags;\n\tunit32 version;\n\tconst class_ro_t *ro;\t\t\t// 方法列表\n\tproperty_list_t *properties;\t\t// 属性列表\n\tconst protocol_list_t *protocols;\t// 协议列表\n\tClass firstSubclass;\n\tClass nextSiblingClass;\n\tchat *demangledName;\n};\n\nstruct class_ro_t {\n\tuint32_t flags;\n\tunit32_t instanceStart;\n\tunit32_t instanceSize; \t\t\t// instance对象占用的内存空间\n\t\n\tconst uint8_t * ivarLayout;\n\tconst chat * name; \t\t\t// 类名\n\tmethod_list_t  * baseMethodList;\n\tprotoocl_list_t * baseProtocols;\n\tconst ivar_list_t *ivars;\t\t  // 成员变量列表\n\tconst uint8_t *weakIverLayout;\n\tproperty_list_t *baseProperties;\n}\n```\n\n## 相关的几个函数\n\n1. `Class objc_getClass(const chat *aClassName)`\n    1. 传入字符串类名\n    2. 返回对应的类对象\n    \n2. `Class object_getClass(id obj)`获取isa指向的对象\n    1. 传入的obj可能是instance对象、class对象、meta-class对象\n    2. 返回值\n        1. 如果是instance对象，返回class对象\n        2. 如果是class对象，返回meta-class对象\n        3. 如果是meta-class对象，返回NSObject（基类）的meta-class对象\n        \n3.  `- (Class)class`、`+ (Class)class` 返回的就是类对象\n\n# meta-class对象\n\n意思是用来描述类对象的对象，是一种特殊的类对象。\n\n每个类在内存中有且只有一个meta-class对象\n\nmeta-class对象和class对象的内存接口是一样的，但是用途不一样，在内存中存储的信息主要包括\n\n- isa指针\n- superclass指针\n- 类的类方法信息\n\n# isa指针和spuerclass指针\n\n<img src=\"https://i.loli.net/2021/05/26/pjxbn5vQ17hrmae.png\" width=\"50%\">\n\n\n## isa指针\n\ninstance的isa指向class\n\n> 当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用\n\nclass的isa指向meta-class\n\n> 当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用 \n\nmeta-class的isa指向基类（NSObject）的meta-class（NSObject的meta-class的isa指向自己的meta-class）\n\n## superclass指针\n\n举个例子，比如Student类继承自Person类，Person类继承自NSObject类：\n\nStudent的class的superclass指针指向父类的class对象，如果没有父类（NSObject），则superclass指针为空\n\nStudent的meta-class对象的superclass指针指向Person的meta-class\n\n基类（NSObject）的meta-class的superclass指针指向class对象\n\n### 调用成员方法\n\n因为Student要调用成员方法的时候，需要找到class对象，因为class对象才存放着成员方法，找不到的话就通过superclass指针找到父类class对象看看里面有没有想要的成员方法\n\n### 调用类方法\n\n当Student要调用Student的类方法的时候，就通过Student的class对象的isa找到Student的meta-class对象，然后找到类方法进行调用\n\n当Student要调用Person的类方法的时候，就得先通过Student的class对象的isa找到Student的meta-class对象，然后通过Student的mata-class对象里面的superclass指针找到Person的meta-class对象，然后在里面找到Person的类方法进行调用\n\n### 调用init方法\n\n比如现在Student对象要调用init方法，流程如下\n1. 先通过对象自己的isa指针，找到Student的类对象\n2. Student的类对象里面有superclass指针，那么就通过superclass指针拿到了Person的类对象\n3. Person的类对象里面也有superclass指针，那么就通过superclass指针拿到NSObject的类对象\n4. NSObject的类对象里面找到了init方法的相关信息，那么就可以进行调用了\n\n### 调用不存在的类方法\n\nStudent调用一个不存在的类方法流程\n1. 通过isa指针找到类对象\n2. 类对象的isa指针找到meta-class对象\n3. meta-class找不到该类方法，通过superclass指针找到父类的meta-class对象\n4. 一直找，直到找到基类的meta-class对象，基类的meta-class的superclass指向基类的class对象\n5. 基类的class对象里面有对象方法，如果对象方法刚好跟准备调用的类方法同名，那么则会调用该对象方法，如果找不到，则开始抛出异常\n\n## ISA_MASK\n\n```\n#if __arm64___\n#define ISA_MASK 0x000000ffffffff8ULL\n#elif __x86_64__\n#define  ISA_MASK 0x00007ffffffffff8ULL\n#endif\n```\n\n实例对象从64位系统开始，isa不直接指向类对象的地址，isa需要进行一次位运算，才能计算出真实地址\n\n```\ninstance的 isa & ISA_MASK -> class对象\nclass的isa & ISA_MASK -> meta_class 对象\n```\n\n\n\n","slug":"iOS-底层原理-instance、Class和meta-Class","published":1,"updated":"2021-06-06T18:52:24.963Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohr003stnn0f6k97aek","content":"<p>本文讲的是实例对象(instance)，类对象(class)，元类对象（meta-class）的内容和他们之间的联系</p>\n<span id=\"more\"></span>\n\n<h1 id=\"实例对象\"><a href=\"#实例对象\" class=\"headerlink\" title=\"实例对象\"></a>实例对象</h1><p>实例对象内存储着成员变量的值</p>\n<h1 id=\"class对象\"><a href=\"#class对象\" class=\"headerlink\" title=\"class对象\"></a>class对象</h1><h2 id=\"class对象的基本内容\"><a href=\"#class对象的基本内容\" class=\"headerlink\" title=\"class对象的基本内容\"></a>class对象的基本内容</h2><p>每个类在内存中有且只有一个class对象</p>\n<p>class对象在内存中，存储的信息主要包括</p>\n<ul>\n<li>isa指针</li>\n<li>superclass指针</li>\n<li>类的属性信息（@property）、 类的对象方法信息（instance method）</li>\n<li>类的协议信息（protocol）、类的成员变量信息（ivar）</li>\n</ul>\n<h2 id=\"class对象的结构\"><a href=\"#class对象的结构\" class=\"headerlink\" title=\"class对象的结构\"></a>class对象的结构</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rw: readwrite</span><br><span class=\"line\">ro: readonly</span><br><span class=\"line\">t:   table</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct objc_class &#123;</span><br><span class=\"line\">\tClass isa;</span><br><span class=\"line\">\tClass superclass;</span><br><span class=\"line\">\tcache_t cache; \t&#x2F;&#x2F; 方法缓存</span><br><span class=\"line\">\tcache_data_bits_t bits; &#x2F;&#x2F; 用于获取具体类信息</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tclass_rw_t *data() &#123;</span><br><span class=\"line\">\t   return bits.data();  &#x2F;&#x2F;  实际方法实现为 bits &amp; FAST_DATA_MASK  结果返回值为 class_rw_t类型的对象</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">struct class_rw_t &#123;</span><br><span class=\"line\">\tunit32 flags;</span><br><span class=\"line\">\tunit32 version;</span><br><span class=\"line\">\tconst class_ro_t *ro;\t\t\t&#x2F;&#x2F; 方法列表</span><br><span class=\"line\">\tproperty_list_t *properties;\t\t&#x2F;&#x2F; 属性列表</span><br><span class=\"line\">\tconst protocol_list_t *protocols;\t&#x2F;&#x2F; 协议列表</span><br><span class=\"line\">\tClass firstSubclass;</span><br><span class=\"line\">\tClass nextSiblingClass;</span><br><span class=\"line\">\tchat *demangledName;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct class_ro_t &#123;</span><br><span class=\"line\">\tuint32_t flags;</span><br><span class=\"line\">\tunit32_t instanceStart;</span><br><span class=\"line\">\tunit32_t instanceSize; \t\t\t&#x2F;&#x2F; instance对象占用的内存空间</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tconst uint8_t * ivarLayout;</span><br><span class=\"line\">\tconst chat * name; \t\t\t&#x2F;&#x2F; 类名</span><br><span class=\"line\">\tmethod_list_t  * baseMethodList;</span><br><span class=\"line\">\tprotoocl_list_t * baseProtocols;</span><br><span class=\"line\">\tconst ivar_list_t *ivars;\t\t  &#x2F;&#x2F; 成员变量列表</span><br><span class=\"line\">\tconst uint8_t *weakIverLayout;</span><br><span class=\"line\">\tproperty_list_t *baseProperties;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"相关的几个函数\"><a href=\"#相关的几个函数\" class=\"headerlink\" title=\"相关的几个函数\"></a>相关的几个函数</h2><ol>\n<li><code>Class objc_getClass(const chat *aClassName)</code><ol>\n<li>传入字符串类名</li>\n<li>返回对应的类对象</li>\n</ol>\n</li>\n<li><code>Class object_getClass(id obj)</code>获取isa指向的对象<ol>\n<li>传入的obj可能是instance对象、class对象、meta-class对象</li>\n<li>返回值<ol>\n<li>如果是instance对象，返回class对象</li>\n<li>如果是class对象，返回meta-class对象</li>\n<li>如果是meta-class对象，返回NSObject（基类）的meta-class对象</li>\n</ol>\n</li>\n</ol>\n</li>\n<li> <code>- (Class)class</code>、<code>+ (Class)class</code> 返回的就是类对象</li>\n</ol>\n<h1 id=\"meta-class对象\"><a href=\"#meta-class对象\" class=\"headerlink\" title=\"meta-class对象\"></a>meta-class对象</h1><p>意思是用来描述类对象的对象，是一种特殊的类对象。</p>\n<p>每个类在内存中有且只有一个meta-class对象</p>\n<p>meta-class对象和class对象的内存接口是一样的，但是用途不一样，在内存中存储的信息主要包括</p>\n<ul>\n<li>isa指针</li>\n<li>superclass指针</li>\n<li>类的类方法信息</li>\n</ul>\n<h1 id=\"isa指针和spuerclass指针\"><a href=\"#isa指针和spuerclass指针\" class=\"headerlink\" title=\"isa指针和spuerclass指针\"></a>isa指针和spuerclass指针</h1><img src=\"https://i.loli.net/2021/05/26/pjxbn5vQ17hrmae.png\" width=\"50%\">\n\n\n<h2 id=\"isa指针\"><a href=\"#isa指针\" class=\"headerlink\" title=\"isa指针\"></a>isa指针</h2><p>instance的isa指向class</p>\n<blockquote>\n<p>当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用</p>\n</blockquote>\n<p>class的isa指向meta-class</p>\n<blockquote>\n<p>当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用 </p>\n</blockquote>\n<p>meta-class的isa指向基类（NSObject）的meta-class（NSObject的meta-class的isa指向自己的meta-class）</p>\n<h2 id=\"superclass指针\"><a href=\"#superclass指针\" class=\"headerlink\" title=\"superclass指针\"></a>superclass指针</h2><p>举个例子，比如Student类继承自Person类，Person类继承自NSObject类：</p>\n<p>Student的class的superclass指针指向父类的class对象，如果没有父类（NSObject），则superclass指针为空</p>\n<p>Student的meta-class对象的superclass指针指向Person的meta-class</p>\n<p>基类（NSObject）的meta-class的superclass指针指向class对象</p>\n<h3 id=\"调用成员方法\"><a href=\"#调用成员方法\" class=\"headerlink\" title=\"调用成员方法\"></a>调用成员方法</h3><p>因为Student要调用成员方法的时候，需要找到class对象，因为class对象才存放着成员方法，找不到的话就通过superclass指针找到父类class对象看看里面有没有想要的成员方法</p>\n<h3 id=\"调用类方法\"><a href=\"#调用类方法\" class=\"headerlink\" title=\"调用类方法\"></a>调用类方法</h3><p>当Student要调用Student的类方法的时候，就通过Student的class对象的isa找到Student的meta-class对象，然后找到类方法进行调用</p>\n<p>当Student要调用Person的类方法的时候，就得先通过Student的class对象的isa找到Student的meta-class对象，然后通过Student的mata-class对象里面的superclass指针找到Person的meta-class对象，然后在里面找到Person的类方法进行调用</p>\n<h3 id=\"调用init方法\"><a href=\"#调用init方法\" class=\"headerlink\" title=\"调用init方法\"></a>调用init方法</h3><p>比如现在Student对象要调用init方法，流程如下</p>\n<ol>\n<li>先通过对象自己的isa指针，找到Student的类对象</li>\n<li>Student的类对象里面有superclass指针，那么就通过superclass指针拿到了Person的类对象</li>\n<li>Person的类对象里面也有superclass指针，那么就通过superclass指针拿到NSObject的类对象</li>\n<li>NSObject的类对象里面找到了init方法的相关信息，那么就可以进行调用了</li>\n</ol>\n<h3 id=\"调用不存在的类方法\"><a href=\"#调用不存在的类方法\" class=\"headerlink\" title=\"调用不存在的类方法\"></a>调用不存在的类方法</h3><p>Student调用一个不存在的类方法流程</p>\n<ol>\n<li>通过isa指针找到类对象</li>\n<li>类对象的isa指针找到meta-class对象</li>\n<li>meta-class找不到该类方法，通过superclass指针找到父类的meta-class对象</li>\n<li>一直找，直到找到基类的meta-class对象，基类的meta-class的superclass指向基类的class对象</li>\n<li>基类的class对象里面有对象方法，如果对象方法刚好跟准备调用的类方法同名，那么则会调用该对象方法，如果找不到，则开始抛出异常</li>\n</ol>\n<h2 id=\"ISA-MASK\"><a href=\"#ISA-MASK\" class=\"headerlink\" title=\"ISA_MASK\"></a>ISA_MASK</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if __arm64___</span><br><span class=\"line\">#define ISA_MASK 0x000000ffffffff8ULL</span><br><span class=\"line\">#elif __x86_64__</span><br><span class=\"line\">#define  ISA_MASK 0x00007ffffffffff8ULL</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n\n<p>实例对象从64位系统开始，isa不直接指向类对象的地址，isa需要进行一次位运算，才能计算出真实地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">instance的 isa &amp; ISA_MASK -&gt; class对象</span><br><span class=\"line\">class的isa &amp; ISA_MASK -&gt; meta_class 对象</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"<p>本文讲的是实例对象(instance)，类对象(class)，元类对象（meta-class）的内容和他们之间的联系</p>","more":"<h1 id=\"实例对象\"><a href=\"#实例对象\" class=\"headerlink\" title=\"实例对象\"></a>实例对象</h1><p>实例对象内存储着成员变量的值</p>\n<h1 id=\"class对象\"><a href=\"#class对象\" class=\"headerlink\" title=\"class对象\"></a>class对象</h1><h2 id=\"class对象的基本内容\"><a href=\"#class对象的基本内容\" class=\"headerlink\" title=\"class对象的基本内容\"></a>class对象的基本内容</h2><p>每个类在内存中有且只有一个class对象</p>\n<p>class对象在内存中，存储的信息主要包括</p>\n<ul>\n<li>isa指针</li>\n<li>superclass指针</li>\n<li>类的属性信息（@property）、 类的对象方法信息（instance method）</li>\n<li>类的协议信息（protocol）、类的成员变量信息（ivar）</li>\n</ul>\n<h2 id=\"class对象的结构\"><a href=\"#class对象的结构\" class=\"headerlink\" title=\"class对象的结构\"></a>class对象的结构</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rw: readwrite</span><br><span class=\"line\">ro: readonly</span><br><span class=\"line\">t:   table</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct objc_class &#123;</span><br><span class=\"line\">\tClass isa;</span><br><span class=\"line\">\tClass superclass;</span><br><span class=\"line\">\tcache_t cache; \t&#x2F;&#x2F; 方法缓存</span><br><span class=\"line\">\tcache_data_bits_t bits; &#x2F;&#x2F; 用于获取具体类信息</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tclass_rw_t *data() &#123;</span><br><span class=\"line\">\t   return bits.data();  &#x2F;&#x2F;  实际方法实现为 bits &amp; FAST_DATA_MASK  结果返回值为 class_rw_t类型的对象</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">struct class_rw_t &#123;</span><br><span class=\"line\">\tunit32 flags;</span><br><span class=\"line\">\tunit32 version;</span><br><span class=\"line\">\tconst class_ro_t *ro;\t\t\t&#x2F;&#x2F; 方法列表</span><br><span class=\"line\">\tproperty_list_t *properties;\t\t&#x2F;&#x2F; 属性列表</span><br><span class=\"line\">\tconst protocol_list_t *protocols;\t&#x2F;&#x2F; 协议列表</span><br><span class=\"line\">\tClass firstSubclass;</span><br><span class=\"line\">\tClass nextSiblingClass;</span><br><span class=\"line\">\tchat *demangledName;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct class_ro_t &#123;</span><br><span class=\"line\">\tuint32_t flags;</span><br><span class=\"line\">\tunit32_t instanceStart;</span><br><span class=\"line\">\tunit32_t instanceSize; \t\t\t&#x2F;&#x2F; instance对象占用的内存空间</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tconst uint8_t * ivarLayout;</span><br><span class=\"line\">\tconst chat * name; \t\t\t&#x2F;&#x2F; 类名</span><br><span class=\"line\">\tmethod_list_t  * baseMethodList;</span><br><span class=\"line\">\tprotoocl_list_t * baseProtocols;</span><br><span class=\"line\">\tconst ivar_list_t *ivars;\t\t  &#x2F;&#x2F; 成员变量列表</span><br><span class=\"line\">\tconst uint8_t *weakIverLayout;</span><br><span class=\"line\">\tproperty_list_t *baseProperties;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"相关的几个函数\"><a href=\"#相关的几个函数\" class=\"headerlink\" title=\"相关的几个函数\"></a>相关的几个函数</h2><ol>\n<li><code>Class objc_getClass(const chat *aClassName)</code><ol>\n<li>传入字符串类名</li>\n<li>返回对应的类对象</li>\n</ol>\n</li>\n<li><code>Class object_getClass(id obj)</code>获取isa指向的对象<ol>\n<li>传入的obj可能是instance对象、class对象、meta-class对象</li>\n<li>返回值<ol>\n<li>如果是instance对象，返回class对象</li>\n<li>如果是class对象，返回meta-class对象</li>\n<li>如果是meta-class对象，返回NSObject（基类）的meta-class对象</li>\n</ol>\n</li>\n</ol>\n</li>\n<li> <code>- (Class)class</code>、<code>+ (Class)class</code> 返回的就是类对象</li>\n</ol>\n<h1 id=\"meta-class对象\"><a href=\"#meta-class对象\" class=\"headerlink\" title=\"meta-class对象\"></a>meta-class对象</h1><p>意思是用来描述类对象的对象，是一种特殊的类对象。</p>\n<p>每个类在内存中有且只有一个meta-class对象</p>\n<p>meta-class对象和class对象的内存接口是一样的，但是用途不一样，在内存中存储的信息主要包括</p>\n<ul>\n<li>isa指针</li>\n<li>superclass指针</li>\n<li>类的类方法信息</li>\n</ul>\n<h1 id=\"isa指针和spuerclass指针\"><a href=\"#isa指针和spuerclass指针\" class=\"headerlink\" title=\"isa指针和spuerclass指针\"></a>isa指针和spuerclass指针</h1><img src=\"https://i.loli.net/2021/05/26/pjxbn5vQ17hrmae.png\" width=\"50%\">\n\n\n<h2 id=\"isa指针\"><a href=\"#isa指针\" class=\"headerlink\" title=\"isa指针\"></a>isa指针</h2><p>instance的isa指向class</p>\n<blockquote>\n<p>当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用</p>\n</blockquote>\n<p>class的isa指向meta-class</p>\n<blockquote>\n<p>当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用 </p>\n</blockquote>\n<p>meta-class的isa指向基类（NSObject）的meta-class（NSObject的meta-class的isa指向自己的meta-class）</p>\n<h2 id=\"superclass指针\"><a href=\"#superclass指针\" class=\"headerlink\" title=\"superclass指针\"></a>superclass指针</h2><p>举个例子，比如Student类继承自Person类，Person类继承自NSObject类：</p>\n<p>Student的class的superclass指针指向父类的class对象，如果没有父类（NSObject），则superclass指针为空</p>\n<p>Student的meta-class对象的superclass指针指向Person的meta-class</p>\n<p>基类（NSObject）的meta-class的superclass指针指向class对象</p>\n<h3 id=\"调用成员方法\"><a href=\"#调用成员方法\" class=\"headerlink\" title=\"调用成员方法\"></a>调用成员方法</h3><p>因为Student要调用成员方法的时候，需要找到class对象，因为class对象才存放着成员方法，找不到的话就通过superclass指针找到父类class对象看看里面有没有想要的成员方法</p>\n<h3 id=\"调用类方法\"><a href=\"#调用类方法\" class=\"headerlink\" title=\"调用类方法\"></a>调用类方法</h3><p>当Student要调用Student的类方法的时候，就通过Student的class对象的isa找到Student的meta-class对象，然后找到类方法进行调用</p>\n<p>当Student要调用Person的类方法的时候，就得先通过Student的class对象的isa找到Student的meta-class对象，然后通过Student的mata-class对象里面的superclass指针找到Person的meta-class对象，然后在里面找到Person的类方法进行调用</p>\n<h3 id=\"调用init方法\"><a href=\"#调用init方法\" class=\"headerlink\" title=\"调用init方法\"></a>调用init方法</h3><p>比如现在Student对象要调用init方法，流程如下</p>\n<ol>\n<li>先通过对象自己的isa指针，找到Student的类对象</li>\n<li>Student的类对象里面有superclass指针，那么就通过superclass指针拿到了Person的类对象</li>\n<li>Person的类对象里面也有superclass指针，那么就通过superclass指针拿到NSObject的类对象</li>\n<li>NSObject的类对象里面找到了init方法的相关信息，那么就可以进行调用了</li>\n</ol>\n<h3 id=\"调用不存在的类方法\"><a href=\"#调用不存在的类方法\" class=\"headerlink\" title=\"调用不存在的类方法\"></a>调用不存在的类方法</h3><p>Student调用一个不存在的类方法流程</p>\n<ol>\n<li>通过isa指针找到类对象</li>\n<li>类对象的isa指针找到meta-class对象</li>\n<li>meta-class找不到该类方法，通过superclass指针找到父类的meta-class对象</li>\n<li>一直找，直到找到基类的meta-class对象，基类的meta-class的superclass指向基类的class对象</li>\n<li>基类的class对象里面有对象方法，如果对象方法刚好跟准备调用的类方法同名，那么则会调用该对象方法，如果找不到，则开始抛出异常</li>\n</ol>\n<h2 id=\"ISA-MASK\"><a href=\"#ISA-MASK\" class=\"headerlink\" title=\"ISA_MASK\"></a>ISA_MASK</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if __arm64___</span><br><span class=\"line\">#define ISA_MASK 0x000000ffffffff8ULL</span><br><span class=\"line\">#elif __x86_64__</span><br><span class=\"line\">#define  ISA_MASK 0x00007ffffffffff8ULL</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n\n<p>实例对象从64位系统开始，isa不直接指向类对象的地址，isa需要进行一次位运算，才能计算出真实地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">instance的 isa &amp; ISA_MASK -&gt; class对象</span><br><span class=\"line\">class的isa &amp; ISA_MASK -&gt; meta_class 对象</span><br></pre></td></tr></table></figure>"},{"title":"iOS 底层原理 --- isa指针","author":"Arclin","abbrlink":"78ececc4","date":"2021-06-14T07:26:00.000Z","_content":"本文讲述isa指针在runtime内部的底层实现和isa的优化方式\n\n<!-- more -->\n\n## isa指针的底层实现\n\n- 在arm64架构出现之前，isa就是一个普通的指针(`Class isa`)，存储着Class,Meta-Class对象的内存地址\n\n- 从arm64架构开始，对isa进行了优化，变成了一个共用体，还使用位域来存储更多的信息\n\n- isa指针的结构如下（objc4-818.2）\n\n```\nunion isa_t {\n    isa_t() { }\n    isa_t(uintptr_t value) : bits(value) { }\n    uintptr_t bits;\n\nprivate:\n    Class cls;\n\npublic:\n    struct {\n        uintptr_t nonpointer        : 1; \n        uintptr_t has_assoc         : 1;\n        uintptr_t has_cxx_dtor      : 1;\n        uintptr_t shiftcls          : 33;\n        uintptr_t magic             : 6;\n        uintptr_t weakly_referenced : 1;\n        uintptr_t unused            : 1;\n        uintptr_t has_sidetable_rc  : 1;\n        uintptr_t extra_rc          : 19\n    };\n\n    bool isDeallocating() {\n        return extra_rc == 0 && has_sidetable_rc == 0;\n    }\n    void setDeallocating() {\n        extra_rc = 0;\n        has_sidetable_rc = 0;\n    }\n\n    void setClass(Class cls, objc_object *obj);\n    Class getClass(bool authenticated);\n    Class getDecodedClass(bool authenticated);\n};\n\n```\n\n首先，共用体同结构体一样，是拥有成员变量的，但是不同的点在于所有成员变量共用一块内存，也就是说当一个成员变量有值时，其他成员变量都成了装饰。\n\n在runtime中，我们只需要用到`uintptr_t bits`，`uintptr_t`是`unsigned long`的别名，在64位系统下占用8个字节，共64位\n\n共用体内的`struct { ... }` 是为了增加可读性而添加的，它描述了`bits`里面存放了什么信息，我们一个个说明一下\n\n> 补充说明： 结构体内的冒号后面的数字表示这个成员所占的位数，举个例子，本来`char name`作为一个成员变量，是会占用一个字节，也就是8个二进制位，如果有3个这样子的成员变量，那么这个结构体就会占用3个字节，如果我们在这个成员变量的后面添加了一个数字，去限制这个成员变量所占的位数，比如`char name : 1`，那么三个这样子的成员变量就一共占用3个二进制位，也就是不到一个字节，因为系统分配内存的最小单位为1个字节，所以这个结构体就占用1个字节，这么做我们就可以节约2个字节了，这种技术叫做**位域**。\n\n- nonpointer\n\t- 0代表普通的指针，存储着Class、Meta-Class对象的内存地址\n    - 1代表优化过，使用位域存储着更多的信息\n    \n- has_assoc\n\t- 是否有设置过关联对象（注意是“设置过”，就算以后关联对象移除了，它还会是true），如果没有，会释放得更快\n    \n- has_cxx_dtor\n\t- 是否有C++的析构函数（.cxx_destruct），如果没有，会释放得更快\n   \n上面两个`会释放得更快`的原因是，在对象销毁的时候，会调用runtime里面的这个方法\n\n```\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        // Read all of the flags at once for performance.\n        bool cxx = obj->hasCxxDtor();\n        bool assoc = obj->hasAssociatedObjects();\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj, /*deallocating*/true);\n        obj->clearDeallocating();\n    }\n\n    return obj;\n}\n```\n\n可以看到如果`has_assoc`或者`has_cxx_dtor`的话，就不会进入判断为true的逻辑，函数会运行得更快\n\n- shiftcls\n\t- 存储着Class、Meta-Class对象的内存信息\n    \n- magic\n\t- 用于在调试时分辨对象是否未完成初始化\n    \n- weakly_referenced\n\t- 是否有被弱引用指向过（同样注意“指向过”，有过即为true），如果没有，释放时会更快\n    \n“会释放得更快”是因为对象销毁时调用了如下runtime源码\n\n```\nNEVER_INLINE void\nobjc_object::clearDeallocating_slow()\n{\n    ASSERT(isa.nonpointer  &&  (isa.weakly_referenced || isa.has_sidetable_rc));\n\n    SideTable& table = SideTables()[this];\n    table.lock();\n    if (isa.weakly_referenced) {\n        weak_clear_no_lock(&table.weak_table, (id)this);\n    }\n    if (isa.has_sidetable_rc) {\n        table.refcnts.erase(this);\n    }\n    table.unlock();\n}\n```\n\n- deallocating\n\t- 对象是否正在释放\n    \n- extra_rc \n\t- 里面存储的值是引用计数器减1后的值\n    \n- has_sitdtable_rc\n\t- 引用计数器是否过大无法存储在isa中\n    - 如果为1，那么引用计数器会存储在一个叫做SideTable的类的属性中\n    \n## 如何从isa指针中取出对应的信息\n\nisa是通过位运算来取出和存入信息的。\n\n- 我们以取出`shiftcls`内的类信息为例\n\n首先isa里面的bits存储着64个二进制位，然后其中`shiftcls`是使用了33个（从上面的共用体里面的位域看出），当系统需要取出对应信息的时候，就使用`ISA_MASK`（ISA掩码）跟bits做一次与运算，举个例子，bits的十六进制地址为`0x011d8001000083a5`\n\n>补充： ISA_MASK在arm64下的值为`0x0000000ffffffff8ULL`，下面我们把他转成二进制\n\n||8|16|24|32|40|48|56|64|\n|---|---|---|---|---|---|---|---|---|\n|bits<br>(0x011d8001000083a5)|1010 0101|1100 0001|0000 0000|0000 0000|1000 0000|0000 0001|1011 1000|1000 0000|\n|ISA_MASK<br>(0x0000000ffffffff8)|0001 1111|1111 1111|1111 1111|1111 1111|1111 0000|0000 0000|0000 0000|0000 0000|\n|与运算后的结果<br>(0x00000001000083a0)|0000 0101|1100 0001|0000 0000|0000 0000|1000 0000|0000 0000|0000 0000|0000 0000|\n\n我们可以来验证一下\n\n<img src=\"https://z3.ax1x.com/2021/06/15/2qoart.png\" width=\"80%\">\n\n\n可以看到 isa一开始的值跟`[person class]`的值是不相同的，跟`ISA_MASK`进行一次与运算之后就相同了，所以可以看出实例对象的isa不是直接指向类对象的，是需要进行一次运算取出来的。\n\n- 其他的信息如`nonpointer`等，取出的方式也类似这样，这么做的好处是充分利用了64个二进制位的内存，而不用像以前一样一个属性就占用了多个字节，造成二进制位的浪费。\n\n\n    ","source":"_posts/iOS-底层原理-isa指针.md","raw":"title: iOS 底层原理 --- isa指针\nauthor: Arclin\ntags:\n  - iOS\n  - 底层原理\ncategories:\n  - iOS\nabbrlink: 78ececc4\ndate: 2021-06-14 15:26:00\n---\n本文讲述isa指针在runtime内部的底层实现和isa的优化方式\n\n<!-- more -->\n\n## isa指针的底层实现\n\n- 在arm64架构出现之前，isa就是一个普通的指针(`Class isa`)，存储着Class,Meta-Class对象的内存地址\n\n- 从arm64架构开始，对isa进行了优化，变成了一个共用体，还使用位域来存储更多的信息\n\n- isa指针的结构如下（objc4-818.2）\n\n```\nunion isa_t {\n    isa_t() { }\n    isa_t(uintptr_t value) : bits(value) { }\n    uintptr_t bits;\n\nprivate:\n    Class cls;\n\npublic:\n    struct {\n        uintptr_t nonpointer        : 1; \n        uintptr_t has_assoc         : 1;\n        uintptr_t has_cxx_dtor      : 1;\n        uintptr_t shiftcls          : 33;\n        uintptr_t magic             : 6;\n        uintptr_t weakly_referenced : 1;\n        uintptr_t unused            : 1;\n        uintptr_t has_sidetable_rc  : 1;\n        uintptr_t extra_rc          : 19\n    };\n\n    bool isDeallocating() {\n        return extra_rc == 0 && has_sidetable_rc == 0;\n    }\n    void setDeallocating() {\n        extra_rc = 0;\n        has_sidetable_rc = 0;\n    }\n\n    void setClass(Class cls, objc_object *obj);\n    Class getClass(bool authenticated);\n    Class getDecodedClass(bool authenticated);\n};\n\n```\n\n首先，共用体同结构体一样，是拥有成员变量的，但是不同的点在于所有成员变量共用一块内存，也就是说当一个成员变量有值时，其他成员变量都成了装饰。\n\n在runtime中，我们只需要用到`uintptr_t bits`，`uintptr_t`是`unsigned long`的别名，在64位系统下占用8个字节，共64位\n\n共用体内的`struct { ... }` 是为了增加可读性而添加的，它描述了`bits`里面存放了什么信息，我们一个个说明一下\n\n> 补充说明： 结构体内的冒号后面的数字表示这个成员所占的位数，举个例子，本来`char name`作为一个成员变量，是会占用一个字节，也就是8个二进制位，如果有3个这样子的成员变量，那么这个结构体就会占用3个字节，如果我们在这个成员变量的后面添加了一个数字，去限制这个成员变量所占的位数，比如`char name : 1`，那么三个这样子的成员变量就一共占用3个二进制位，也就是不到一个字节，因为系统分配内存的最小单位为1个字节，所以这个结构体就占用1个字节，这么做我们就可以节约2个字节了，这种技术叫做**位域**。\n\n- nonpointer\n\t- 0代表普通的指针，存储着Class、Meta-Class对象的内存地址\n    - 1代表优化过，使用位域存储着更多的信息\n    \n- has_assoc\n\t- 是否有设置过关联对象（注意是“设置过”，就算以后关联对象移除了，它还会是true），如果没有，会释放得更快\n    \n- has_cxx_dtor\n\t- 是否有C++的析构函数（.cxx_destruct），如果没有，会释放得更快\n   \n上面两个`会释放得更快`的原因是，在对象销毁的时候，会调用runtime里面的这个方法\n\n```\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        // Read all of the flags at once for performance.\n        bool cxx = obj->hasCxxDtor();\n        bool assoc = obj->hasAssociatedObjects();\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj, /*deallocating*/true);\n        obj->clearDeallocating();\n    }\n\n    return obj;\n}\n```\n\n可以看到如果`has_assoc`或者`has_cxx_dtor`的话，就不会进入判断为true的逻辑，函数会运行得更快\n\n- shiftcls\n\t- 存储着Class、Meta-Class对象的内存信息\n    \n- magic\n\t- 用于在调试时分辨对象是否未完成初始化\n    \n- weakly_referenced\n\t- 是否有被弱引用指向过（同样注意“指向过”，有过即为true），如果没有，释放时会更快\n    \n“会释放得更快”是因为对象销毁时调用了如下runtime源码\n\n```\nNEVER_INLINE void\nobjc_object::clearDeallocating_slow()\n{\n    ASSERT(isa.nonpointer  &&  (isa.weakly_referenced || isa.has_sidetable_rc));\n\n    SideTable& table = SideTables()[this];\n    table.lock();\n    if (isa.weakly_referenced) {\n        weak_clear_no_lock(&table.weak_table, (id)this);\n    }\n    if (isa.has_sidetable_rc) {\n        table.refcnts.erase(this);\n    }\n    table.unlock();\n}\n```\n\n- deallocating\n\t- 对象是否正在释放\n    \n- extra_rc \n\t- 里面存储的值是引用计数器减1后的值\n    \n- has_sitdtable_rc\n\t- 引用计数器是否过大无法存储在isa中\n    - 如果为1，那么引用计数器会存储在一个叫做SideTable的类的属性中\n    \n## 如何从isa指针中取出对应的信息\n\nisa是通过位运算来取出和存入信息的。\n\n- 我们以取出`shiftcls`内的类信息为例\n\n首先isa里面的bits存储着64个二进制位，然后其中`shiftcls`是使用了33个（从上面的共用体里面的位域看出），当系统需要取出对应信息的时候，就使用`ISA_MASK`（ISA掩码）跟bits做一次与运算，举个例子，bits的十六进制地址为`0x011d8001000083a5`\n\n>补充： ISA_MASK在arm64下的值为`0x0000000ffffffff8ULL`，下面我们把他转成二进制\n\n||8|16|24|32|40|48|56|64|\n|---|---|---|---|---|---|---|---|---|\n|bits<br>(0x011d8001000083a5)|1010 0101|1100 0001|0000 0000|0000 0000|1000 0000|0000 0001|1011 1000|1000 0000|\n|ISA_MASK<br>(0x0000000ffffffff8)|0001 1111|1111 1111|1111 1111|1111 1111|1111 0000|0000 0000|0000 0000|0000 0000|\n|与运算后的结果<br>(0x00000001000083a0)|0000 0101|1100 0001|0000 0000|0000 0000|1000 0000|0000 0000|0000 0000|0000 0000|\n\n我们可以来验证一下\n\n<img src=\"https://z3.ax1x.com/2021/06/15/2qoart.png\" width=\"80%\">\n\n\n可以看到 isa一开始的值跟`[person class]`的值是不相同的，跟`ISA_MASK`进行一次与运算之后就相同了，所以可以看出实例对象的isa不是直接指向类对象的，是需要进行一次运算取出来的。\n\n- 其他的信息如`nonpointer`等，取出的方式也类似这样，这么做的好处是充分利用了64个二进制位的内存，而不用像以前一样一个属性就占用了多个字节，造成二进制位的浪费。\n\n\n    ","slug":"iOS-底层原理-isa指针","published":1,"updated":"2021-06-15T15:52:05.333Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohr003vtnn05kkt015b","content":"<p>本文讲述isa指针在runtime内部的底层实现和isa的优化方式</p>\n<span id=\"more\"></span>\n\n<h2 id=\"isa指针的底层实现\"><a href=\"#isa指针的底层实现\" class=\"headerlink\" title=\"isa指针的底层实现\"></a>isa指针的底层实现</h2><ul>\n<li><p>在arm64架构出现之前，isa就是一个普通的指针(<code>Class isa</code>)，存储着Class,Meta-Class对象的内存地址</p>\n</li>\n<li><p>从arm64架构开始，对isa进行了优化，变成了一个共用体，还使用位域来存储更多的信息</p>\n</li>\n<li><p>isa指针的结构如下（objc4-818.2）</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">union isa_t &#123;</span><br><span class=\"line\">    isa_t() &#123; &#125;</span><br><span class=\"line\">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class=\"line\">    uintptr_t bits;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    Class cls;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    struct &#123;</span><br><span class=\"line\">        uintptr_t nonpointer        : 1; </span><br><span class=\"line\">        uintptr_t has_assoc         : 1;</span><br><span class=\"line\">        uintptr_t has_cxx_dtor      : 1;</span><br><span class=\"line\">        uintptr_t shiftcls          : 33;</span><br><span class=\"line\">        uintptr_t magic             : 6;</span><br><span class=\"line\">        uintptr_t weakly_referenced : 1;</span><br><span class=\"line\">        uintptr_t unused            : 1;</span><br><span class=\"line\">        uintptr_t has_sidetable_rc  : 1;</span><br><span class=\"line\">        uintptr_t extra_rc          : 19</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    bool isDeallocating() &#123;</span><br><span class=\"line\">        return extra_rc &#x3D;&#x3D; 0 &amp;&amp; has_sidetable_rc &#x3D;&#x3D; 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void setDeallocating() &#123;</span><br><span class=\"line\">        extra_rc &#x3D; 0;</span><br><span class=\"line\">        has_sidetable_rc &#x3D; 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void setClass(Class cls, objc_object *obj);</span><br><span class=\"line\">    Class getClass(bool authenticated);</span><br><span class=\"line\">    Class getDecodedClass(bool authenticated);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>首先，共用体同结构体一样，是拥有成员变量的，但是不同的点在于所有成员变量共用一块内存，也就是说当一个成员变量有值时，其他成员变量都成了装饰。</p>\n<p>在runtime中，我们只需要用到<code>uintptr_t bits</code>，<code>uintptr_t</code>是<code>unsigned long</code>的别名，在64位系统下占用8个字节，共64位</p>\n<p>共用体内的<code>struct &#123; ... &#125;</code> 是为了增加可读性而添加的，它描述了<code>bits</code>里面存放了什么信息，我们一个个说明一下</p>\n<blockquote>\n<p>补充说明： 结构体内的冒号后面的数字表示这个成员所占的位数，举个例子，本来<code>char name</code>作为一个成员变量，是会占用一个字节，也就是8个二进制位，如果有3个这样子的成员变量，那么这个结构体就会占用3个字节，如果我们在这个成员变量的后面添加了一个数字，去限制这个成员变量所占的位数，比如<code>char name : 1</code>，那么三个这样子的成员变量就一共占用3个二进制位，也就是不到一个字节，因为系统分配内存的最小单位为1个字节，所以这个结构体就占用1个字节，这么做我们就可以节约2个字节了，这种技术叫做<strong>位域</strong>。</p>\n</blockquote>\n<ul>\n<li>nonpointer<ul>\n<li>0代表普通的指针，存储着Class、Meta-Class对象的内存地址</li>\n<li>1代表优化过，使用位域存储着更多的信息</li>\n</ul>\n</li>\n<li>has_assoc<ul>\n<li>是否有设置过关联对象（注意是“设置过”，就算以后关联对象移除了，它还会是true），如果没有，会释放得更快</li>\n</ul>\n</li>\n<li>has_cxx_dtor<ul>\n<li>是否有C++的析构函数（.cxx_destruct），如果没有，会释放得更快</li>\n</ul>\n</li>\n</ul>\n<p>上面两个<code>会释放得更快</code>的原因是，在对象销毁的时候，会调用runtime里面的这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *objc_destructInstance(id obj) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (obj) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; Read all of the flags at once for performance.</span><br><span class=\"line\">        bool cxx &#x3D; obj-&gt;hasCxxDtor();</span><br><span class=\"line\">        bool assoc &#x3D; obj-&gt;hasAssociatedObjects();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; This order is important.</span><br><span class=\"line\">        if (cxx) object_cxxDestruct(obj);</span><br><span class=\"line\">        if (assoc) _object_remove_assocations(obj, &#x2F;*deallocating*&#x2F;true);</span><br><span class=\"line\">        obj-&gt;clearDeallocating();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到如果<code>has_assoc</code>或者<code>has_cxx_dtor</code>的话，就不会进入判断为true的逻辑，函数会运行得更快</p>\n<ul>\n<li>shiftcls<ul>\n<li>存储着Class、Meta-Class对象的内存信息</li>\n</ul>\n</li>\n<li>magic<ul>\n<li>用于在调试时分辨对象是否未完成初始化</li>\n</ul>\n</li>\n<li>weakly_referenced<ul>\n<li>是否有被弱引用指向过（同样注意“指向过”，有过即为true），如果没有，释放时会更快</li>\n</ul>\n</li>\n</ul>\n<p>“会释放得更快”是因为对象销毁时调用了如下runtime源码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NEVER_INLINE void</span><br><span class=\"line\">objc_object::clearDeallocating_slow()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ASSERT(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class=\"line\"></span><br><span class=\"line\">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class=\"line\">    table.lock();</span><br><span class=\"line\">    if (isa.weakly_referenced) &#123;</span><br><span class=\"line\">        weak_clear_no_lock(&amp;table.weak_table, (id)this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (isa.has_sidetable_rc) &#123;</span><br><span class=\"line\">        table.refcnts.erase(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    table.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>deallocating<ul>\n<li>对象是否正在释放</li>\n</ul>\n</li>\n<li>extra_rc <ul>\n<li>里面存储的值是引用计数器减1后的值</li>\n</ul>\n</li>\n<li>has_sitdtable_rc<ul>\n<li>引用计数器是否过大无法存储在isa中</li>\n<li>如果为1，那么引用计数器会存储在一个叫做SideTable的类的属性中</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"如何从isa指针中取出对应的信息\"><a href=\"#如何从isa指针中取出对应的信息\" class=\"headerlink\" title=\"如何从isa指针中取出对应的信息\"></a>如何从isa指针中取出对应的信息</h2><p>isa是通过位运算来取出和存入信息的。</p>\n<ul>\n<li>我们以取出<code>shiftcls</code>内的类信息为例</li>\n</ul>\n<p>首先isa里面的bits存储着64个二进制位，然后其中<code>shiftcls</code>是使用了33个（从上面的共用体里面的位域看出），当系统需要取出对应信息的时候，就使用<code>ISA_MASK</code>（ISA掩码）跟bits做一次与运算，举个例子，bits的十六进制地址为<code>0x011d8001000083a5</code></p>\n<blockquote>\n<p>补充： ISA_MASK在arm64下的值为<code>0x0000000ffffffff8ULL</code>，下面我们把他转成二进制</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>8</th>\n<th>16</th>\n<th>24</th>\n<th>32</th>\n<th>40</th>\n<th>48</th>\n<th>56</th>\n<th>64</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bits<br>(0x011d8001000083a5)</td>\n<td>1010 0101</td>\n<td>1100 0001</td>\n<td>0000 0000</td>\n<td>0000 0000</td>\n<td>1000 0000</td>\n<td>0000 0001</td>\n<td>1011 1000</td>\n<td>1000 0000</td>\n</tr>\n<tr>\n<td>ISA_MASK<br>(0x0000000ffffffff8)</td>\n<td>0001 1111</td>\n<td>1111 1111</td>\n<td>1111 1111</td>\n<td>1111 1111</td>\n<td>1111 0000</td>\n<td>0000 0000</td>\n<td>0000 0000</td>\n<td>0000 0000</td>\n</tr>\n<tr>\n<td>与运算后的结果<br>(0x00000001000083a0)</td>\n<td>0000 0101</td>\n<td>1100 0001</td>\n<td>0000 0000</td>\n<td>0000 0000</td>\n<td>1000 0000</td>\n<td>0000 0000</td>\n<td>0000 0000</td>\n<td>0000 0000</td>\n</tr>\n</tbody></table>\n<p>我们可以来验证一下</p>\n<img src=\"https://z3.ax1x.com/2021/06/15/2qoart.png\" width=\"80%\">\n\n\n<p>可以看到 isa一开始的值跟<code>[person class]</code>的值是不相同的，跟<code>ISA_MASK</code>进行一次与运算之后就相同了，所以可以看出实例对象的isa不是直接指向类对象的，是需要进行一次运算取出来的。</p>\n<ul>\n<li>其他的信息如<code>nonpointer</code>等，取出的方式也类似这样，这么做的好处是充分利用了64个二进制位的内存，而不用像以前一样一个属性就占用了多个字节，造成二进制位的浪费。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文讲述isa指针在runtime内部的底层实现和isa的优化方式</p>","more":"<h2 id=\"isa指针的底层实现\"><a href=\"#isa指针的底层实现\" class=\"headerlink\" title=\"isa指针的底层实现\"></a>isa指针的底层实现</h2><ul>\n<li><p>在arm64架构出现之前，isa就是一个普通的指针(<code>Class isa</code>)，存储着Class,Meta-Class对象的内存地址</p>\n</li>\n<li><p>从arm64架构开始，对isa进行了优化，变成了一个共用体，还使用位域来存储更多的信息</p>\n</li>\n<li><p>isa指针的结构如下（objc4-818.2）</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">union isa_t &#123;</span><br><span class=\"line\">    isa_t() &#123; &#125;</span><br><span class=\"line\">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class=\"line\">    uintptr_t bits;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">    Class cls;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">    struct &#123;</span><br><span class=\"line\">        uintptr_t nonpointer        : 1; </span><br><span class=\"line\">        uintptr_t has_assoc         : 1;</span><br><span class=\"line\">        uintptr_t has_cxx_dtor      : 1;</span><br><span class=\"line\">        uintptr_t shiftcls          : 33;</span><br><span class=\"line\">        uintptr_t magic             : 6;</span><br><span class=\"line\">        uintptr_t weakly_referenced : 1;</span><br><span class=\"line\">        uintptr_t unused            : 1;</span><br><span class=\"line\">        uintptr_t has_sidetable_rc  : 1;</span><br><span class=\"line\">        uintptr_t extra_rc          : 19</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    bool isDeallocating() &#123;</span><br><span class=\"line\">        return extra_rc &#x3D;&#x3D; 0 &amp;&amp; has_sidetable_rc &#x3D;&#x3D; 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void setDeallocating() &#123;</span><br><span class=\"line\">        extra_rc &#x3D; 0;</span><br><span class=\"line\">        has_sidetable_rc &#x3D; 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void setClass(Class cls, objc_object *obj);</span><br><span class=\"line\">    Class getClass(bool authenticated);</span><br><span class=\"line\">    Class getDecodedClass(bool authenticated);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>首先，共用体同结构体一样，是拥有成员变量的，但是不同的点在于所有成员变量共用一块内存，也就是说当一个成员变量有值时，其他成员变量都成了装饰。</p>\n<p>在runtime中，我们只需要用到<code>uintptr_t bits</code>，<code>uintptr_t</code>是<code>unsigned long</code>的别名，在64位系统下占用8个字节，共64位</p>\n<p>共用体内的<code>struct &#123; ... &#125;</code> 是为了增加可读性而添加的，它描述了<code>bits</code>里面存放了什么信息，我们一个个说明一下</p>\n<blockquote>\n<p>补充说明： 结构体内的冒号后面的数字表示这个成员所占的位数，举个例子，本来<code>char name</code>作为一个成员变量，是会占用一个字节，也就是8个二进制位，如果有3个这样子的成员变量，那么这个结构体就会占用3个字节，如果我们在这个成员变量的后面添加了一个数字，去限制这个成员变量所占的位数，比如<code>char name : 1</code>，那么三个这样子的成员变量就一共占用3个二进制位，也就是不到一个字节，因为系统分配内存的最小单位为1个字节，所以这个结构体就占用1个字节，这么做我们就可以节约2个字节了，这种技术叫做<strong>位域</strong>。</p>\n</blockquote>\n<ul>\n<li>nonpointer<ul>\n<li>0代表普通的指针，存储着Class、Meta-Class对象的内存地址</li>\n<li>1代表优化过，使用位域存储着更多的信息</li>\n</ul>\n</li>\n<li>has_assoc<ul>\n<li>是否有设置过关联对象（注意是“设置过”，就算以后关联对象移除了，它还会是true），如果没有，会释放得更快</li>\n</ul>\n</li>\n<li>has_cxx_dtor<ul>\n<li>是否有C++的析构函数（.cxx_destruct），如果没有，会释放得更快</li>\n</ul>\n</li>\n</ul>\n<p>上面两个<code>会释放得更快</code>的原因是，在对象销毁的时候，会调用runtime里面的这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *objc_destructInstance(id obj) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (obj) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; Read all of the flags at once for performance.</span><br><span class=\"line\">        bool cxx &#x3D; obj-&gt;hasCxxDtor();</span><br><span class=\"line\">        bool assoc &#x3D; obj-&gt;hasAssociatedObjects();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F; This order is important.</span><br><span class=\"line\">        if (cxx) object_cxxDestruct(obj);</span><br><span class=\"line\">        if (assoc) _object_remove_assocations(obj, &#x2F;*deallocating*&#x2F;true);</span><br><span class=\"line\">        obj-&gt;clearDeallocating();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到如果<code>has_assoc</code>或者<code>has_cxx_dtor</code>的话，就不会进入判断为true的逻辑，函数会运行得更快</p>\n<ul>\n<li>shiftcls<ul>\n<li>存储着Class、Meta-Class对象的内存信息</li>\n</ul>\n</li>\n<li>magic<ul>\n<li>用于在调试时分辨对象是否未完成初始化</li>\n</ul>\n</li>\n<li>weakly_referenced<ul>\n<li>是否有被弱引用指向过（同样注意“指向过”，有过即为true），如果没有，释放时会更快</li>\n</ul>\n</li>\n</ul>\n<p>“会释放得更快”是因为对象销毁时调用了如下runtime源码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NEVER_INLINE void</span><br><span class=\"line\">objc_object::clearDeallocating_slow()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ASSERT(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class=\"line\"></span><br><span class=\"line\">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class=\"line\">    table.lock();</span><br><span class=\"line\">    if (isa.weakly_referenced) &#123;</span><br><span class=\"line\">        weak_clear_no_lock(&amp;table.weak_table, (id)this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (isa.has_sidetable_rc) &#123;</span><br><span class=\"line\">        table.refcnts.erase(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    table.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>deallocating<ul>\n<li>对象是否正在释放</li>\n</ul>\n</li>\n<li>extra_rc <ul>\n<li>里面存储的值是引用计数器减1后的值</li>\n</ul>\n</li>\n<li>has_sitdtable_rc<ul>\n<li>引用计数器是否过大无法存储在isa中</li>\n<li>如果为1，那么引用计数器会存储在一个叫做SideTable的类的属性中</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"如何从isa指针中取出对应的信息\"><a href=\"#如何从isa指针中取出对应的信息\" class=\"headerlink\" title=\"如何从isa指针中取出对应的信息\"></a>如何从isa指针中取出对应的信息</h2><p>isa是通过位运算来取出和存入信息的。</p>\n<ul>\n<li>我们以取出<code>shiftcls</code>内的类信息为例</li>\n</ul>\n<p>首先isa里面的bits存储着64个二进制位，然后其中<code>shiftcls</code>是使用了33个（从上面的共用体里面的位域看出），当系统需要取出对应信息的时候，就使用<code>ISA_MASK</code>（ISA掩码）跟bits做一次与运算，举个例子，bits的十六进制地址为<code>0x011d8001000083a5</code></p>\n<blockquote>\n<p>补充： ISA_MASK在arm64下的值为<code>0x0000000ffffffff8ULL</code>，下面我们把他转成二进制</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>8</th>\n<th>16</th>\n<th>24</th>\n<th>32</th>\n<th>40</th>\n<th>48</th>\n<th>56</th>\n<th>64</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bits<br>(0x011d8001000083a5)</td>\n<td>1010 0101</td>\n<td>1100 0001</td>\n<td>0000 0000</td>\n<td>0000 0000</td>\n<td>1000 0000</td>\n<td>0000 0001</td>\n<td>1011 1000</td>\n<td>1000 0000</td>\n</tr>\n<tr>\n<td>ISA_MASK<br>(0x0000000ffffffff8)</td>\n<td>0001 1111</td>\n<td>1111 1111</td>\n<td>1111 1111</td>\n<td>1111 1111</td>\n<td>1111 0000</td>\n<td>0000 0000</td>\n<td>0000 0000</td>\n<td>0000 0000</td>\n</tr>\n<tr>\n<td>与运算后的结果<br>(0x00000001000083a0)</td>\n<td>0000 0101</td>\n<td>1100 0001</td>\n<td>0000 0000</td>\n<td>0000 0000</td>\n<td>1000 0000</td>\n<td>0000 0000</td>\n<td>0000 0000</td>\n<td>0000 0000</td>\n</tr>\n</tbody></table>\n<p>我们可以来验证一下</p>\n<img src=\"https://z3.ax1x.com/2021/06/15/2qoart.png\" width=\"80%\">\n\n\n<p>可以看到 isa一开始的值跟<code>[person class]</code>的值是不相同的，跟<code>ISA_MASK</code>进行一次与运算之后就相同了，所以可以看出实例对象的isa不是直接指向类对象的，是需要进行一次运算取出来的。</p>\n<ul>\n<li>其他的信息如<code>nonpointer</code>等，取出的方式也类似这样，这么做的好处是充分利用了64个二进制位的内存，而不用像以前一样一个属性就占用了多个字节，造成二进制位的浪费。</li>\n</ul>"},{"title":"iOS 13新API","author":"Arclin","abbrlink":"f356f3c1","date":"2019-10-24T05:18:00.000Z","_content":"\n可能会用到的iOS13新Api\n\n<!-- more -->\n\n## 接口类\n\n### 截图转PDF\n\nsafari可以长截图了\n<img width=20% src=\"https://i.loli.net/2019/10/24/iHxWAqL63E2ZfMY.jpg\">\n\n然后我们可以把`UIScrollView`的截图转成PDF\n\n[文档](https://developer.apple.com/documentation/uikit/uiscreenshotservicedelegate)\n\n### 双指滑动手势\n\n![](https://i.loli.net/2019/10/24/FbSEV8WCXcQRrf9.gif)\n\n```\n/// 是否允许多指选中\noptional func tableView(_ tableView: UITableView, shouldBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) -> Bool\n\n///多指选中开始，这里可以做一些UI修改，比如修改导航栏上按钮的文本\noptional func tableView(_ tableView: UITableView, didBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) \n```\n\n### 深色模式\n\n见[文章](https://www.jianshu.com/p/176537b0d9dd)\n\n## Framework类\n\n### Multiple UI Instances\n\n可以支持一个界面同时展示多个控制器（不是父子控制器那种）\n在iPad上可以使用\n\n![](https://docs-assets.developer.apple.com/published/8ce996907a/fc0975ae-c186-438c-abdd-5280f650c377.png)\n\n主要类`UIScene`\n\n[文档](https://developer.apple.com/documentation/uikit/app_and_environment)\n\n\n### BackgroundTasks\n\n好消息~ 现在维持后台不被杀可以直接用这个API了，以前的会用后台获取定位和播放静音音乐的方式，但是现在只要注册后台就可以了，但是还是只有短期，长时间的话可能会要求充电状态或者持续的网络状态。\n\n[文档](https://developer.apple.com/documentation/backgroundtasks/)\n\n### Camera Capture\n\n现在可以同时使用前后摄像头，可以进行分割遮罩，可以识别出头发，皮肤，牙齿\n\n[文档1](https://developer.apple.com/documentation/avfoundation/avcapturemulticamsession/)\n\n[文档2](https://developer.apple.com/documentation/avfoundation/avsemanticsegmentationmatte/)\n\n### Combine\n\n官方版RxSwift，主要是配合SwiftUI使用\n\n[文档](https://developer.apple.com/documentation/combine/)\n\n### Core Haptics\n\n可以在UI交互的时候给点小触觉反馈，比如打开关闭UISwitch的时候小震动一下，或者播放点声音之类的\n\n[文档](https://developer.apple.com/documentation/corehaptics/)\n\n### Apple CryptoKit\n\n好消息，苹果自带HMAC、SHA、AES、NIST加密算法啦\n\n[文档](https://developer.apple.com/documentation/cryptokit/)\n\n### VisionKit\n\n好消息，苹果自带图片转文字功能啦\n\n[文档](https://developer.apple.com/documentation/visionkit/)\n\n### MetricKit\n\n用来收集用户设备信息的，主要是使用App的过程中的耗电，CPU等等性能指标，可以依据这些优化你的App\n\n[文档](https://developer.apple.com/documentation/metrickit/)\n\n### PencilKit\n\niPad上跟Apple Pencil交互的API\n\n[文档](https://developer.apple.com/documentation/pencilkit/)\n\n### Vision\n\n图像识别相关framework\niOS11的功能：面部和面部界标检测，条形码识别，图像配准以及一般特征跟踪。\n\niOS13的新功能：\n1. 对图像进行显著性分析。\n2. 在图像中检测人类和动物。\n3. 对图像进行分类和搜索。\n4. 分析图像与特征打印的相似性。\n5. 对文档执行文本识别。\n\n[文档](https://developer.apple.com/documentation/vision/)\n\n### Sign in with Apple\n\n苹果登录\n\n[文档](https://developer.apple.com/sign-in-with-apple/get-started/)\n\n### SF Symbols\n\n可以用来显示矢量图\n\n[文档](https://developer.apple.com/documentation/uikit/uiimage/configuring_and_displaying_symbol_images_in_your_ui/)\n\n### Bring Your iPad App to Mac\n\n直接把iPad App 迁移到 Mac，不过还是要做适配的，下面文档会有一些适配规则，以兼容两个端\n\n[参考](https://developer.apple.com/design/human-interface-guidelines/ios/overview/mac-catalyst/)\n\n[文档1](https://developer.apple.com/documentation/xcode/creating_a_mac_version_of_your_ipad_app)\n\n[文档2](https://developer.apple.com/documentation/uikit/mac_catalyst/optimizing_your_ipad_app_for_mac)\n\n### ARKit 3\n\n应该大家都知道ARKit，这次主要是多了些新特性，包括动态捕捉动作，同时捕捉多个面部，同时开启前后摄像头等。\n\n[文档](https://developer.apple.com/documentation/arkit/)\n\n### RealityKit\n\n3D模型搭建、展示用\n\n[文档](https://developer.apple.com/documentation/realitykit/)\n\n### Core ML 3\n\n升级版机器学习套件\n\n[文档](https://developer.apple.com/documentation/coreml/)\n\n","source":"_posts/iOS13新API.md","raw":"title: iOS 13新API\nauthor: Arclin\nabbrlink: f356f3c1\ntags:\n  - iOS\n  - feature\ncategories:\n  - iOS\ndate: 2019-10-24 13:18:00\n---\n\n可能会用到的iOS13新Api\n\n<!-- more -->\n\n## 接口类\n\n### 截图转PDF\n\nsafari可以长截图了\n<img width=20% src=\"https://i.loli.net/2019/10/24/iHxWAqL63E2ZfMY.jpg\">\n\n然后我们可以把`UIScrollView`的截图转成PDF\n\n[文档](https://developer.apple.com/documentation/uikit/uiscreenshotservicedelegate)\n\n### 双指滑动手势\n\n![](https://i.loli.net/2019/10/24/FbSEV8WCXcQRrf9.gif)\n\n```\n/// 是否允许多指选中\noptional func tableView(_ tableView: UITableView, shouldBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) -> Bool\n\n///多指选中开始，这里可以做一些UI修改，比如修改导航栏上按钮的文本\noptional func tableView(_ tableView: UITableView, didBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) \n```\n\n### 深色模式\n\n见[文章](https://www.jianshu.com/p/176537b0d9dd)\n\n## Framework类\n\n### Multiple UI Instances\n\n可以支持一个界面同时展示多个控制器（不是父子控制器那种）\n在iPad上可以使用\n\n![](https://docs-assets.developer.apple.com/published/8ce996907a/fc0975ae-c186-438c-abdd-5280f650c377.png)\n\n主要类`UIScene`\n\n[文档](https://developer.apple.com/documentation/uikit/app_and_environment)\n\n\n### BackgroundTasks\n\n好消息~ 现在维持后台不被杀可以直接用这个API了，以前的会用后台获取定位和播放静音音乐的方式，但是现在只要注册后台就可以了，但是还是只有短期，长时间的话可能会要求充电状态或者持续的网络状态。\n\n[文档](https://developer.apple.com/documentation/backgroundtasks/)\n\n### Camera Capture\n\n现在可以同时使用前后摄像头，可以进行分割遮罩，可以识别出头发，皮肤，牙齿\n\n[文档1](https://developer.apple.com/documentation/avfoundation/avcapturemulticamsession/)\n\n[文档2](https://developer.apple.com/documentation/avfoundation/avsemanticsegmentationmatte/)\n\n### Combine\n\n官方版RxSwift，主要是配合SwiftUI使用\n\n[文档](https://developer.apple.com/documentation/combine/)\n\n### Core Haptics\n\n可以在UI交互的时候给点小触觉反馈，比如打开关闭UISwitch的时候小震动一下，或者播放点声音之类的\n\n[文档](https://developer.apple.com/documentation/corehaptics/)\n\n### Apple CryptoKit\n\n好消息，苹果自带HMAC、SHA、AES、NIST加密算法啦\n\n[文档](https://developer.apple.com/documentation/cryptokit/)\n\n### VisionKit\n\n好消息，苹果自带图片转文字功能啦\n\n[文档](https://developer.apple.com/documentation/visionkit/)\n\n### MetricKit\n\n用来收集用户设备信息的，主要是使用App的过程中的耗电，CPU等等性能指标，可以依据这些优化你的App\n\n[文档](https://developer.apple.com/documentation/metrickit/)\n\n### PencilKit\n\niPad上跟Apple Pencil交互的API\n\n[文档](https://developer.apple.com/documentation/pencilkit/)\n\n### Vision\n\n图像识别相关framework\niOS11的功能：面部和面部界标检测，条形码识别，图像配准以及一般特征跟踪。\n\niOS13的新功能：\n1. 对图像进行显著性分析。\n2. 在图像中检测人类和动物。\n3. 对图像进行分类和搜索。\n4. 分析图像与特征打印的相似性。\n5. 对文档执行文本识别。\n\n[文档](https://developer.apple.com/documentation/vision/)\n\n### Sign in with Apple\n\n苹果登录\n\n[文档](https://developer.apple.com/sign-in-with-apple/get-started/)\n\n### SF Symbols\n\n可以用来显示矢量图\n\n[文档](https://developer.apple.com/documentation/uikit/uiimage/configuring_and_displaying_symbol_images_in_your_ui/)\n\n### Bring Your iPad App to Mac\n\n直接把iPad App 迁移到 Mac，不过还是要做适配的，下面文档会有一些适配规则，以兼容两个端\n\n[参考](https://developer.apple.com/design/human-interface-guidelines/ios/overview/mac-catalyst/)\n\n[文档1](https://developer.apple.com/documentation/xcode/creating_a_mac_version_of_your_ipad_app)\n\n[文档2](https://developer.apple.com/documentation/uikit/mac_catalyst/optimizing_your_ipad_app_for_mac)\n\n### ARKit 3\n\n应该大家都知道ARKit，这次主要是多了些新特性，包括动态捕捉动作，同时捕捉多个面部，同时开启前后摄像头等。\n\n[文档](https://developer.apple.com/documentation/arkit/)\n\n### RealityKit\n\n3D模型搭建、展示用\n\n[文档](https://developer.apple.com/documentation/realitykit/)\n\n### Core ML 3\n\n升级版机器学习套件\n\n[文档](https://developer.apple.com/documentation/coreml/)\n\n","slug":"iOS13新API","published":1,"updated":"2021-06-06T18:52:24.964Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohv003ytnn042xy5bof","content":"<p>可能会用到的iOS13新Api</p>\n<span id=\"more\"></span>\n\n<h2 id=\"接口类\"><a href=\"#接口类\" class=\"headerlink\" title=\"接口类\"></a>接口类</h2><h3 id=\"截图转PDF\"><a href=\"#截图转PDF\" class=\"headerlink\" title=\"截图转PDF\"></a>截图转PDF</h3><p>safari可以长截图了<br><img width=20% src=\"https://i.loli.net/2019/10/24/iHxWAqL63E2ZfMY.jpg\"></p>\n<p>然后我们可以把<code>UIScrollView</code>的截图转成PDF</p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiscreenshotservicedelegate\">文档</a></p>\n<h3 id=\"双指滑动手势\"><a href=\"#双指滑动手势\" class=\"headerlink\" title=\"双指滑动手势\"></a>双指滑动手势</h3><p><img src=\"https://i.loli.net/2019/10/24/FbSEV8WCXcQRrf9.gif\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;&#x2F; 是否允许多指选中</span><br><span class=\"line\">optional func tableView(_ tableView: UITableView, shouldBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) -&gt; Bool</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;&#x2F;多指选中开始，这里可以做一些UI修改，比如修改导航栏上按钮的文本</span><br><span class=\"line\">optional func tableView(_ tableView: UITableView, didBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"深色模式\"><a href=\"#深色模式\" class=\"headerlink\" title=\"深色模式\"></a>深色模式</h3><p>见<a href=\"https://www.jianshu.com/p/176537b0d9dd\">文章</a></p>\n<h2 id=\"Framework类\"><a href=\"#Framework类\" class=\"headerlink\" title=\"Framework类\"></a>Framework类</h2><h3 id=\"Multiple-UI-Instances\"><a href=\"#Multiple-UI-Instances\" class=\"headerlink\" title=\"Multiple UI Instances\"></a>Multiple UI Instances</h3><p>可以支持一个界面同时展示多个控制器（不是父子控制器那种）<br>在iPad上可以使用</p>\n<p><img src=\"https://docs-assets.developer.apple.com/published/8ce996907a/fc0975ae-c186-438c-abdd-5280f650c377.png\"></p>\n<p>主要类<code>UIScene</code></p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/app_and_environment\">文档</a></p>\n<h3 id=\"BackgroundTasks\"><a href=\"#BackgroundTasks\" class=\"headerlink\" title=\"BackgroundTasks\"></a>BackgroundTasks</h3><p>好消息~ 现在维持后台不被杀可以直接用这个API了，以前的会用后台获取定位和播放静音音乐的方式，但是现在只要注册后台就可以了，但是还是只有短期，长时间的话可能会要求充电状态或者持续的网络状态。</p>\n<p><a href=\"https://developer.apple.com/documentation/backgroundtasks/\">文档</a></p>\n<h3 id=\"Camera-Capture\"><a href=\"#Camera-Capture\" class=\"headerlink\" title=\"Camera Capture\"></a>Camera Capture</h3><p>现在可以同时使用前后摄像头，可以进行分割遮罩，可以识别出头发，皮肤，牙齿</p>\n<p><a href=\"https://developer.apple.com/documentation/avfoundation/avcapturemulticamsession/\">文档1</a></p>\n<p><a href=\"https://developer.apple.com/documentation/avfoundation/avsemanticsegmentationmatte/\">文档2</a></p>\n<h3 id=\"Combine\"><a href=\"#Combine\" class=\"headerlink\" title=\"Combine\"></a>Combine</h3><p>官方版RxSwift，主要是配合SwiftUI使用</p>\n<p><a href=\"https://developer.apple.com/documentation/combine/\">文档</a></p>\n<h3 id=\"Core-Haptics\"><a href=\"#Core-Haptics\" class=\"headerlink\" title=\"Core Haptics\"></a>Core Haptics</h3><p>可以在UI交互的时候给点小触觉反馈，比如打开关闭UISwitch的时候小震动一下，或者播放点声音之类的</p>\n<p><a href=\"https://developer.apple.com/documentation/corehaptics/\">文档</a></p>\n<h3 id=\"Apple-CryptoKit\"><a href=\"#Apple-CryptoKit\" class=\"headerlink\" title=\"Apple CryptoKit\"></a>Apple CryptoKit</h3><p>好消息，苹果自带HMAC、SHA、AES、NIST加密算法啦</p>\n<p><a href=\"https://developer.apple.com/documentation/cryptokit/\">文档</a></p>\n<h3 id=\"VisionKit\"><a href=\"#VisionKit\" class=\"headerlink\" title=\"VisionKit\"></a>VisionKit</h3><p>好消息，苹果自带图片转文字功能啦</p>\n<p><a href=\"https://developer.apple.com/documentation/visionkit/\">文档</a></p>\n<h3 id=\"MetricKit\"><a href=\"#MetricKit\" class=\"headerlink\" title=\"MetricKit\"></a>MetricKit</h3><p>用来收集用户设备信息的，主要是使用App的过程中的耗电，CPU等等性能指标，可以依据这些优化你的App</p>\n<p><a href=\"https://developer.apple.com/documentation/metrickit/\">文档</a></p>\n<h3 id=\"PencilKit\"><a href=\"#PencilKit\" class=\"headerlink\" title=\"PencilKit\"></a>PencilKit</h3><p>iPad上跟Apple Pencil交互的API</p>\n<p><a href=\"https://developer.apple.com/documentation/pencilkit/\">文档</a></p>\n<h3 id=\"Vision\"><a href=\"#Vision\" class=\"headerlink\" title=\"Vision\"></a>Vision</h3><p>图像识别相关framework<br>iOS11的功能：面部和面部界标检测，条形码识别，图像配准以及一般特征跟踪。</p>\n<p>iOS13的新功能：</p>\n<ol>\n<li>对图像进行显著性分析。</li>\n<li>在图像中检测人类和动物。</li>\n<li>对图像进行分类和搜索。</li>\n<li>分析图像与特征打印的相似性。</li>\n<li>对文档执行文本识别。</li>\n</ol>\n<p><a href=\"https://developer.apple.com/documentation/vision/\">文档</a></p>\n<h3 id=\"Sign-in-with-Apple\"><a href=\"#Sign-in-with-Apple\" class=\"headerlink\" title=\"Sign in with Apple\"></a>Sign in with Apple</h3><p>苹果登录</p>\n<p><a href=\"https://developer.apple.com/sign-in-with-apple/get-started/\">文档</a></p>\n<h3 id=\"SF-Symbols\"><a href=\"#SF-Symbols\" class=\"headerlink\" title=\"SF Symbols\"></a>SF Symbols</h3><p>可以用来显示矢量图</p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiimage/configuring_and_displaying_symbol_images_in_your_ui/\">文档</a></p>\n<h3 id=\"Bring-Your-iPad-App-to-Mac\"><a href=\"#Bring-Your-iPad-App-to-Mac\" class=\"headerlink\" title=\"Bring Your iPad App to Mac\"></a>Bring Your iPad App to Mac</h3><p>直接把iPad App 迁移到 Mac，不过还是要做适配的，下面文档会有一些适配规则，以兼容两个端</p>\n<p><a href=\"https://developer.apple.com/design/human-interface-guidelines/ios/overview/mac-catalyst/\">参考</a></p>\n<p><a href=\"https://developer.apple.com/documentation/xcode/creating_a_mac_version_of_your_ipad_app\">文档1</a></p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/mac_catalyst/optimizing_your_ipad_app_for_mac\">文档2</a></p>\n<h3 id=\"ARKit-3\"><a href=\"#ARKit-3\" class=\"headerlink\" title=\"ARKit 3\"></a>ARKit 3</h3><p>应该大家都知道ARKit，这次主要是多了些新特性，包括动态捕捉动作，同时捕捉多个面部，同时开启前后摄像头等。</p>\n<p><a href=\"https://developer.apple.com/documentation/arkit/\">文档</a></p>\n<h3 id=\"RealityKit\"><a href=\"#RealityKit\" class=\"headerlink\" title=\"RealityKit\"></a>RealityKit</h3><p>3D模型搭建、展示用</p>\n<p><a href=\"https://developer.apple.com/documentation/realitykit/\">文档</a></p>\n<h3 id=\"Core-ML-3\"><a href=\"#Core-ML-3\" class=\"headerlink\" title=\"Core ML 3\"></a>Core ML 3</h3><p>升级版机器学习套件</p>\n<p><a href=\"https://developer.apple.com/documentation/coreml/\">文档</a></p>\n","site":{"data":{}},"excerpt":"<p>可能会用到的iOS13新Api</p>","more":"<h2 id=\"接口类\"><a href=\"#接口类\" class=\"headerlink\" title=\"接口类\"></a>接口类</h2><h3 id=\"截图转PDF\"><a href=\"#截图转PDF\" class=\"headerlink\" title=\"截图转PDF\"></a>截图转PDF</h3><p>safari可以长截图了<br><img width=20% src=\"https://i.loli.net/2019/10/24/iHxWAqL63E2ZfMY.jpg\"></p>\n<p>然后我们可以把<code>UIScrollView</code>的截图转成PDF</p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiscreenshotservicedelegate\">文档</a></p>\n<h3 id=\"双指滑动手势\"><a href=\"#双指滑动手势\" class=\"headerlink\" title=\"双指滑动手势\"></a>双指滑动手势</h3><p><img src=\"https://i.loli.net/2019/10/24/FbSEV8WCXcQRrf9.gif\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;&#x2F; 是否允许多指选中</span><br><span class=\"line\">optional func tableView(_ tableView: UITableView, shouldBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) -&gt; Bool</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;&#x2F;多指选中开始，这里可以做一些UI修改，比如修改导航栏上按钮的文本</span><br><span class=\"line\">optional func tableView(_ tableView: UITableView, didBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"深色模式\"><a href=\"#深色模式\" class=\"headerlink\" title=\"深色模式\"></a>深色模式</h3><p>见<a href=\"https://www.jianshu.com/p/176537b0d9dd\">文章</a></p>\n<h2 id=\"Framework类\"><a href=\"#Framework类\" class=\"headerlink\" title=\"Framework类\"></a>Framework类</h2><h3 id=\"Multiple-UI-Instances\"><a href=\"#Multiple-UI-Instances\" class=\"headerlink\" title=\"Multiple UI Instances\"></a>Multiple UI Instances</h3><p>可以支持一个界面同时展示多个控制器（不是父子控制器那种）<br>在iPad上可以使用</p>\n<p><img src=\"https://docs-assets.developer.apple.com/published/8ce996907a/fc0975ae-c186-438c-abdd-5280f650c377.png\"></p>\n<p>主要类<code>UIScene</code></p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/app_and_environment\">文档</a></p>\n<h3 id=\"BackgroundTasks\"><a href=\"#BackgroundTasks\" class=\"headerlink\" title=\"BackgroundTasks\"></a>BackgroundTasks</h3><p>好消息~ 现在维持后台不被杀可以直接用这个API了，以前的会用后台获取定位和播放静音音乐的方式，但是现在只要注册后台就可以了，但是还是只有短期，长时间的话可能会要求充电状态或者持续的网络状态。</p>\n<p><a href=\"https://developer.apple.com/documentation/backgroundtasks/\">文档</a></p>\n<h3 id=\"Camera-Capture\"><a href=\"#Camera-Capture\" class=\"headerlink\" title=\"Camera Capture\"></a>Camera Capture</h3><p>现在可以同时使用前后摄像头，可以进行分割遮罩，可以识别出头发，皮肤，牙齿</p>\n<p><a href=\"https://developer.apple.com/documentation/avfoundation/avcapturemulticamsession/\">文档1</a></p>\n<p><a href=\"https://developer.apple.com/documentation/avfoundation/avsemanticsegmentationmatte/\">文档2</a></p>\n<h3 id=\"Combine\"><a href=\"#Combine\" class=\"headerlink\" title=\"Combine\"></a>Combine</h3><p>官方版RxSwift，主要是配合SwiftUI使用</p>\n<p><a href=\"https://developer.apple.com/documentation/combine/\">文档</a></p>\n<h3 id=\"Core-Haptics\"><a href=\"#Core-Haptics\" class=\"headerlink\" title=\"Core Haptics\"></a>Core Haptics</h3><p>可以在UI交互的时候给点小触觉反馈，比如打开关闭UISwitch的时候小震动一下，或者播放点声音之类的</p>\n<p><a href=\"https://developer.apple.com/documentation/corehaptics/\">文档</a></p>\n<h3 id=\"Apple-CryptoKit\"><a href=\"#Apple-CryptoKit\" class=\"headerlink\" title=\"Apple CryptoKit\"></a>Apple CryptoKit</h3><p>好消息，苹果自带HMAC、SHA、AES、NIST加密算法啦</p>\n<p><a href=\"https://developer.apple.com/documentation/cryptokit/\">文档</a></p>\n<h3 id=\"VisionKit\"><a href=\"#VisionKit\" class=\"headerlink\" title=\"VisionKit\"></a>VisionKit</h3><p>好消息，苹果自带图片转文字功能啦</p>\n<p><a href=\"https://developer.apple.com/documentation/visionkit/\">文档</a></p>\n<h3 id=\"MetricKit\"><a href=\"#MetricKit\" class=\"headerlink\" title=\"MetricKit\"></a>MetricKit</h3><p>用来收集用户设备信息的，主要是使用App的过程中的耗电，CPU等等性能指标，可以依据这些优化你的App</p>\n<p><a href=\"https://developer.apple.com/documentation/metrickit/\">文档</a></p>\n<h3 id=\"PencilKit\"><a href=\"#PencilKit\" class=\"headerlink\" title=\"PencilKit\"></a>PencilKit</h3><p>iPad上跟Apple Pencil交互的API</p>\n<p><a href=\"https://developer.apple.com/documentation/pencilkit/\">文档</a></p>\n<h3 id=\"Vision\"><a href=\"#Vision\" class=\"headerlink\" title=\"Vision\"></a>Vision</h3><p>图像识别相关framework<br>iOS11的功能：面部和面部界标检测，条形码识别，图像配准以及一般特征跟踪。</p>\n<p>iOS13的新功能：</p>\n<ol>\n<li>对图像进行显著性分析。</li>\n<li>在图像中检测人类和动物。</li>\n<li>对图像进行分类和搜索。</li>\n<li>分析图像与特征打印的相似性。</li>\n<li>对文档执行文本识别。</li>\n</ol>\n<p><a href=\"https://developer.apple.com/documentation/vision/\">文档</a></p>\n<h3 id=\"Sign-in-with-Apple\"><a href=\"#Sign-in-with-Apple\" class=\"headerlink\" title=\"Sign in with Apple\"></a>Sign in with Apple</h3><p>苹果登录</p>\n<p><a href=\"https://developer.apple.com/sign-in-with-apple/get-started/\">文档</a></p>\n<h3 id=\"SF-Symbols\"><a href=\"#SF-Symbols\" class=\"headerlink\" title=\"SF Symbols\"></a>SF Symbols</h3><p>可以用来显示矢量图</p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiimage/configuring_and_displaying_symbol_images_in_your_ui/\">文档</a></p>\n<h3 id=\"Bring-Your-iPad-App-to-Mac\"><a href=\"#Bring-Your-iPad-App-to-Mac\" class=\"headerlink\" title=\"Bring Your iPad App to Mac\"></a>Bring Your iPad App to Mac</h3><p>直接把iPad App 迁移到 Mac，不过还是要做适配的，下面文档会有一些适配规则，以兼容两个端</p>\n<p><a href=\"https://developer.apple.com/design/human-interface-guidelines/ios/overview/mac-catalyst/\">参考</a></p>\n<p><a href=\"https://developer.apple.com/documentation/xcode/creating_a_mac_version_of_your_ipad_app\">文档1</a></p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/mac_catalyst/optimizing_your_ipad_app_for_mac\">文档2</a></p>\n<h3 id=\"ARKit-3\"><a href=\"#ARKit-3\" class=\"headerlink\" title=\"ARKit 3\"></a>ARKit 3</h3><p>应该大家都知道ARKit，这次主要是多了些新特性，包括动态捕捉动作，同时捕捉多个面部，同时开启前后摄像头等。</p>\n<p><a href=\"https://developer.apple.com/documentation/arkit/\">文档</a></p>\n<h3 id=\"RealityKit\"><a href=\"#RealityKit\" class=\"headerlink\" title=\"RealityKit\"></a>RealityKit</h3><p>3D模型搭建、展示用</p>\n<p><a href=\"https://developer.apple.com/documentation/realitykit/\">文档</a></p>\n<h3 id=\"Core-ML-3\"><a href=\"#Core-ML-3\" class=\"headerlink\" title=\"Core ML 3\"></a>Core ML 3</h3><p>升级版机器学习套件</p>\n<p><a href=\"https://developer.apple.com/documentation/coreml/\">文档</a></p>"},{"title":"iOS 14 App Clips","author":"Arclin","abbrlink":"a44df9c3","date":"2020-11-25T02:08:18.000Z","_content":"\n本文将主要探讨App Clips开发流程 和 组件化、非组件化两种开发方式下如何复用代码的问题。\n\n<!-- more -->\n\nApp Clips是iOS14系统的新特性之一，类似于小程序，用户可以在不下载App的情况下体验到App的部分功能，如网易严选的商品详情功能（[https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw](https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw)），该功能适合做一些推广和引流的运营工作，另外苹果也提供的原生的浮窗样式，可以引导用户下载完整版App。\n\n苹果官方文档：[https://developer.apple.com/app-clips/](https://developer.apple.com/app-clips/)\n\n### 目前已知的触发方式\n\n- 二维码\n\t\n\t必须使用iOS 14系统相机或者使用控制中心的读取二维码组件来扫码才能触发App Clips。\n\n- NFC Tags\n\t\n\tNFC标签感应，比如星巴克桌面内嵌的NFC Tags。\n\n- Safari App Banner\n\t\n\t当用户用iOS的Safari浏览器浏览相应的网址后，页面顶部会出现一个横幅，提示用户有App Clips可以用。\n\n- 信息\n\t\n\tiOS系统自带的iMessage，当你在iMessage发送一个App Clips链接时，系统会自动把信息显示成一个App Clips的卡片。\n    \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a13d29c7a17d471dbc551c416ce2ed57~tplv-k3u1fbpfcp-watermark.image)\n\n### 开发前置工作\n\n#### 申请证书\n\n##### 创建App Clips ID\n\n1. 点击新增APP ID\n\t\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d62145df226549428f600ace6f1b44cb~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n2. 选择App Clip\n\t\n\t<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f93a07c34f7249b982f0cbca84bfcafe~tplv-k3u1fbpfcp-zoom-1.image\" >\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da0c96044db46bb897aab6f71543c8d~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n\n3. 输入一串英文名，用于拼接在主工程的bundle id的后面，生成该clip的bundle id\n\t<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2ae0fb422f149d98589f36c80123315~tplv-k3u1fbpfcp-zoom-1.image\" >\n\t\n4. 在Description内输入描述（不能使用特殊符号），并且在下方勾选App Clip能力，比如Apple Pay，Sign in with Apple，Push等等，**Associated Domains必须勾选**\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33e78440190242efaa8dac9b47004393~tplv-k3u1fbpfcp-zoom-1.image\" >\n\t\n5. 最后确认并点击右上方Register即可\n\n##### 创建Profiles\n\n流程跟创建App的Profiles一样，就是选择bundle id的时候改成Clip的bundle id 即可，同样有Development、AdHoc、Distribution三种类型\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68bfe6ee218047b7a3232058dcc2e006~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n##### 其他配置\n\n如果需要其他NFC、地点等等的一些方式触发App Clip配置的话，参考这个苹果的文档[https://help.apple.com/app-store-connect/#/dev5b665db74](https://help.apple.com/app-store-connect/#/dev5b665db74)\n\n#### Apple Store Connect 配置图片和标题，描述\n\n1. 需要一张1800 * 1200 的图片，用于显示在Clip的卡片上\n2. 副标题用于显示在卡片标题下的小字，如图所示<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b3e18f56f6d49219fc46f77dab1cef2~tplv-k3u1fbpfcp-zoom-1.image\" width=30%>\n3. 操作包括“打开”“查看”“开始游戏”，体现在卡片右边的蓝色按钮内的文案，根据你的产品类型进行选择就好\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c14c35967084886bc3f4fce6e985fcb~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n\n#### 配置apple-app-site-association.json\n\n假设你的开发者账号的Team Id是`A123`，Clips的bundle id是`com.abc.def.clips`，主工程的bundle id 是`com.abc.def`，则配置如下\n\n```\n{\n    \"appclips\":{\n        \"apps\":[\"A123.com.abc.def.clips\"]\n    },\n    \"applinks\":{\n        \"apps\":[\n        ],\n        \"details\":{\n            \"A123.com.abc.def\":{\n                \"paths\":[\n                    \"*\" // 这里的Path根据实际情况配置即可\n                ]\n            }\n        }\n    },\n    \"webcredentials\":{\n        \"apps\":[\n            \"A123.com.abc.def\",\n        ]\n    },\n    \"activitycontinuation\":{\n        \"apps\":[\n            \"A123.com.abc.def\",\n        ]\n    }\n}\n```\n\n配置完成后部署到你自己域名的根目录下，配置方法网上很多教程，这里贴上[苹果官方文档](https://developer.apple.com/documentation/safariservices/supporting_associated_domains?language=objc)\n\n如果配置错了，那么上传包到苹果后台之后，就会显示无效域名\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05ddb4d106a349d28c1504762697a9eb~tplv-k3u1fbpfcp-zoom-1.image)\n\n如果是json配置错误，那么配置正确后不用重新传包，等待苹果那边刷新缓存就好。\n\nApp Clip支持最多在三个域名的网页显示入口，到后面的工程配置那里会说明。\n\n#### 前端页面添加meta标签\n\n如果要在H5页面显示Clips入口，加上一段meta标签即可\n\n如果你的应用市场App id是 `123456`, Clips的bundle id 是 `com.abc.clips` 则应该配置\n\n```\n<meta name=\"apple-itunes-app\" content=\"app-id=123456,app-clip-bundle-id=com.abc.clips\">\n```\n\n### 开发工作\n\n#### 新建App Clip Target\n\n这里以OC工程为例\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9edc6108c0b64885b708ef5c9de8e1d0~tplv-k3u1fbpfcp-zoom-1.image\" >\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa5c9c1032174d77a4db0518029b78dd~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n#### 配置证书和Associated Domains\n\n用刚才生成的证书去配置一下即可\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fbccb4eee1445ca9b680200358535e0~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n添加Associated Domains，目的是打开对应域名网页后，页面上方能够出现Clip的入口。\n\n**这里可以添加多个域名，注意每个域名都需要配置apple-app-site-association！！！**\n\n**主工程的Target和Clip的Target都需要配置！！！**\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5125ca96f15433b8205294e48906e13~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n#### 编写代码\n\n创建完之后就会生成一个文件夹，里面就是我们熟悉的AppDelegate、SecneDelegate、Main.storyboard、Info.plist等文件，如果你不使用Storyboard进行界面搭建，那么也是跟之前的开发模式一样，删除info.plist内Application Scene Manifest，修改General-Deployment info - Main interface 为空，修改AppDelegate.m，在里面创建根控制器。\n\n之后的操作就跟普通开发一样了，调试的话可以直接在Xcode上左上角选择Clip的target，然后就可以跑起来了。\n\n另外，AppIcon是需要独立配置的，同样也是在Clip项目工程文件夹内Assets.xcassets。\n\n##### 非组件化开发模式\n\n一般情况下我们是需要复用代码的，将代码内某些模块功能进行复用，然后直接用在Clip，这时候我们只需要在右侧Target Membership勾选新建的Clip Target即可。\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2847eb910740229f410d0aa29f7bb5~tplv-k3u1fbpfcp-zoom-1.image\" width=30%>\n\n同样的 相关的依赖到的文件也需要勾选Clip Target\n\n##### 组件化开发模式 和 Podfile的配置\n\n如果是在组件化开发模式下，那么就需要配置Podfile\n\n在Podfile 底部新增代码\n\n```\nsource 'https://github.com/CocoaPods/Specs.git'\n# 你的私有pod仓库\nsource 'https://git.xxx.com/yourprivatepodspec/Podspec.git'\n\ntarget 'YourApp’ do\n    platform :ios, '10.3'\n    pod \"AFNetworking\"\n    pod \"SDWebImage\"\n    # 等等\nend\n\ntarget 'YourApp_Clips' do\n    platform :ios, '10.3'\n    pod 'ComponentA',           :path=> '../ComponentA'\n    pod \"ComponentB\",           :path=>\"../ComponentB\"\n    pod \"AFNetworking\"\n    pod \"SDWebImage\"\n    # 等等\nend\n\n```\n\n但是这样子相同的第三方pod会写两遍，所以我们可以优化成\n\n```\nsource 'https://github.com/CocoaPods/Specs.git'\n# 你的私有pod仓库\nsource 'https://git.xxx.com/yourprivatepodspec/Podspec.git'\n\ndef common_pods\n    pod \"AFNetworking\"\n    pod \"SDWebImage\"\nend\n\ntarget 'YourApp’ do\n    platform :ios, '10.3'\n    common_pods\nend\n\ntarget 'YourApp_Clips' do\n    platform :ios, '14.0'\n    pod 'ComponentA',           :path=> '../ComponentA'\n    pod \"ComponentB\",           :path=>\"../ComponentB\"\n    common_pods\nend\n\n```\n\n##### 抽离模块时不同环境的代码复用问题\n\n假如说A功能需要抽离出来放到Clip，但是A模块里面有需求是会跳转到B模块的，但是我并不希望Clip引入B模块，希望他能在这个地方提示用户下载完整App，那应该怎么做呢？\n\n首先第一个事情，苹果提供了一个Api可以引导弹窗引导用户下载APP\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fec69fde9e64618819b1b526034d23b~tplv-k3u1fbpfcp-zoom-1.image\" width=40%>\n\n```\nUIWindowScene *scene = (UIWindowScene *)[[UIApplication sharedApplication].connectedScenes.allObjects firstObject];\nSKOverlayAppConfiguration *config = [[SKOverlayAppConfiguration alloc] initWithAppIdentifier:@\"你的AppID\" position:SKOverlayPositionBottomRaised];\nSKOverlay *overlay = [[SKOverlay alloc] initWithConfiguration:config];\noverlay.delegate = self; // 添加代理后可以监听弹窗的弹出和消失，可以在代理内添加埋点。\n[overlay presentInScene:scene];\n\n// 主动让弹窗消失\n// [SKOverlay dismissOverlayInScene:scene];\n```\n\n第二. 如何在模块内划分环境，区分是主App还是Clip\n\n方法一：设计一个单例，添加一个枚举属性，分别在`主工程`的AppDelegate和`Clip`的AppDelegate内给单例的属性赋值，标记当前环境。然后在业务代码中获取单例的环境属性后进行判断。\n\n方法二：有时候我们在Clip复用的模块代码内不需要import某些头文件，因为我们不需要这个功能，这时候单例的方法就不管用了，我们需要通过宏去判断。\n\n如果代码不在pod组件内的话，只需要在Clip Target的`Build Settings` - `Preprocessor Macros`添加`APP_CLIPS`宏即可。\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7708c16f9c4247a9ab9ec393d01420b1~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n如果是组件化的开发模式，代码在pod内部，那么就稍微有点麻烦，需要在对应podspec新增一个subspec，专门提供给clip使用，然后配置上宏定义\n\n`ComponentA.podspec`\n\n```\n\ns.subspec \"App\" do |ss|\n    ss.source_files = \"xxxxxx\"\nend\n\ns.subspec \"AppClip\" do |ss|\n    ss.source_files = \"xxxxxx\"\n    ss.pod_target_xcconfig = { 'GCC_PREPROCESSOR_DEFINITIONS' => 'APP_CLIPS=1'}\nend\n```\n\n> 这里为什么要弄多一个App的subspec，因为如果主工程直接`pod ComponentA`的话，所有的subspec都会被引入，所以这里为了区分开，就加多了一个专门给主工程用的subspec\n\n`Podfile`\n\n```\ndef common_pods\n    pod \"AFNetworking\"\n    pod \"SDWebImage\"\nend\n\ntarget 'YourApp’ do\n    platform :ios, '10.3'\n    common_pods\n    pod 'ComponentA/App',           :path=> '../ComponentA'\nend\n\ntarget 'YourApp_Clips' do\n    platform :ios, '14.0'\n    pod 'ComponentA/AppClip',   :path=> '../ComponentA'\n    pod \"ComponentB\",           :path=>\"../ComponentB\"\n    common_pods\nend\n```\n\n通过以上方法，就可以用如下方式进行宏判断，区分当前环境\n\n```\n#ifdef APP_CLIPS\n\n#else\n\n#endif\n```\n\n### 测试工作\n\n#### 开发调试\n\n- 可以选择Clip Target直接使用Xcode编译运行\n\n- 可以使用真机扫描二维码，调起Clip卡片，但是前提是Clip要先在真机跑一遍。\n\t\n\t1. 手机点击`设置-开发者-Local Experiences-Register Local Experience`\n\t2. 输入域名、Clip的bundle id、标题、子标题，选择按钮标题、选择Clip弹出的卡片上的图片，然后点击存储即可。\n\t3. 将刚才输入的域名，去草料二维码等二维码生成网站生成一个二维码，然后手机相机扫描即可弹出卡片样式。\n\t4. 具体内容可以参考[官方文档](https://developer.apple.com/documentation/app_clips/testing_your_app_clip_s_launch_experience?language=objc)\n\t\n\n#### 外部测试\n\n1. 可以通过Archive打Release环境的包（Debug状态下没有选择导出Clip ipa的选项，不知道是哪里配置问题，如果有知道的小伙伴可以评论区分享一下），然后单独导出Clip的ipa，上传到蒲公英或者Fir等分发平台，测试同事就可以下载安装测试了。\n2. 如果已经传到了TestFlight，那么也可以在TestFlight上直接点击打开小程序进行测试。\n\n### 苹果官方提及的产品要求\n\n原文：[https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/](https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/)\n\n划重点：\n\n1. 请勿仅将App Clip用作营销用途，不能显示广告。\n \n2. 避免登录，避免不了的话尽可能使用Apple id登录\n\n3. Clips启动后只有在8小时内才能接收推送\n\n### Q&A\n\n1. 苹果文档说的App Clips 10M限制指的是哪个文件的10M\n\t\n\t经过测试后发现，应该是Release环境下Archive后，导出的Clips的ipa的大小，如果有误欢迎评论区指正。\n\t\n2. Clips可以有登录功能吗？\n\n\t可以，但是苹果希望用户能不登录就使用App，如果要登录也首选Sign in with Apple登录的方式(iOS13特性)，但是我们可以学网易严选那样子苹果ID登录之后再弹出手机验证码绑定功能。\n\t\n3. 可以有内购吗？\n\n\t可以。\n\t\n4. 用户使用完Clips后，如果想再次进入，入口在哪儿？\n\n\t假如是网页打开的Clips，那么离开网页后，在桌面的\"资源库\"里可以找到这个Clips并重新打开。如果找不到就搜索资源库，总能搜到的。","source":"_posts/iOS14-App-Clips.md","raw":"---\ntitle: iOS 14 App Clips\nauthor: Arclin\nabbrlink: a44df9c3\ndate: 2020-11-25 10:08:18\ntags:\n  - iOS\n  - feature\ncategories:\n  - iOS\n---\n\n本文将主要探讨App Clips开发流程 和 组件化、非组件化两种开发方式下如何复用代码的问题。\n\n<!-- more -->\n\nApp Clips是iOS14系统的新特性之一，类似于小程序，用户可以在不下载App的情况下体验到App的部分功能，如网易严选的商品详情功能（[https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw](https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw)），该功能适合做一些推广和引流的运营工作，另外苹果也提供的原生的浮窗样式，可以引导用户下载完整版App。\n\n苹果官方文档：[https://developer.apple.com/app-clips/](https://developer.apple.com/app-clips/)\n\n### 目前已知的触发方式\n\n- 二维码\n\t\n\t必须使用iOS 14系统相机或者使用控制中心的读取二维码组件来扫码才能触发App Clips。\n\n- NFC Tags\n\t\n\tNFC标签感应，比如星巴克桌面内嵌的NFC Tags。\n\n- Safari App Banner\n\t\n\t当用户用iOS的Safari浏览器浏览相应的网址后，页面顶部会出现一个横幅，提示用户有App Clips可以用。\n\n- 信息\n\t\n\tiOS系统自带的iMessage，当你在iMessage发送一个App Clips链接时，系统会自动把信息显示成一个App Clips的卡片。\n    \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a13d29c7a17d471dbc551c416ce2ed57~tplv-k3u1fbpfcp-watermark.image)\n\n### 开发前置工作\n\n#### 申请证书\n\n##### 创建App Clips ID\n\n1. 点击新增APP ID\n\t\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d62145df226549428f600ace6f1b44cb~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n2. 选择App Clip\n\t\n\t<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f93a07c34f7249b982f0cbca84bfcafe~tplv-k3u1fbpfcp-zoom-1.image\" >\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da0c96044db46bb897aab6f71543c8d~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n\n3. 输入一串英文名，用于拼接在主工程的bundle id的后面，生成该clip的bundle id\n\t<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2ae0fb422f149d98589f36c80123315~tplv-k3u1fbpfcp-zoom-1.image\" >\n\t\n4. 在Description内输入描述（不能使用特殊符号），并且在下方勾选App Clip能力，比如Apple Pay，Sign in with Apple，Push等等，**Associated Domains必须勾选**\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33e78440190242efaa8dac9b47004393~tplv-k3u1fbpfcp-zoom-1.image\" >\n\t\n5. 最后确认并点击右上方Register即可\n\n##### 创建Profiles\n\n流程跟创建App的Profiles一样，就是选择bundle id的时候改成Clip的bundle id 即可，同样有Development、AdHoc、Distribution三种类型\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68bfe6ee218047b7a3232058dcc2e006~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n##### 其他配置\n\n如果需要其他NFC、地点等等的一些方式触发App Clip配置的话，参考这个苹果的文档[https://help.apple.com/app-store-connect/#/dev5b665db74](https://help.apple.com/app-store-connect/#/dev5b665db74)\n\n#### Apple Store Connect 配置图片和标题，描述\n\n1. 需要一张1800 * 1200 的图片，用于显示在Clip的卡片上\n2. 副标题用于显示在卡片标题下的小字，如图所示<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b3e18f56f6d49219fc46f77dab1cef2~tplv-k3u1fbpfcp-zoom-1.image\" width=30%>\n3. 操作包括“打开”“查看”“开始游戏”，体现在卡片右边的蓝色按钮内的文案，根据你的产品类型进行选择就好\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c14c35967084886bc3f4fce6e985fcb~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n\n#### 配置apple-app-site-association.json\n\n假设你的开发者账号的Team Id是`A123`，Clips的bundle id是`com.abc.def.clips`，主工程的bundle id 是`com.abc.def`，则配置如下\n\n```\n{\n    \"appclips\":{\n        \"apps\":[\"A123.com.abc.def.clips\"]\n    },\n    \"applinks\":{\n        \"apps\":[\n        ],\n        \"details\":{\n            \"A123.com.abc.def\":{\n                \"paths\":[\n                    \"*\" // 这里的Path根据实际情况配置即可\n                ]\n            }\n        }\n    },\n    \"webcredentials\":{\n        \"apps\":[\n            \"A123.com.abc.def\",\n        ]\n    },\n    \"activitycontinuation\":{\n        \"apps\":[\n            \"A123.com.abc.def\",\n        ]\n    }\n}\n```\n\n配置完成后部署到你自己域名的根目录下，配置方法网上很多教程，这里贴上[苹果官方文档](https://developer.apple.com/documentation/safariservices/supporting_associated_domains?language=objc)\n\n如果配置错了，那么上传包到苹果后台之后，就会显示无效域名\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05ddb4d106a349d28c1504762697a9eb~tplv-k3u1fbpfcp-zoom-1.image)\n\n如果是json配置错误，那么配置正确后不用重新传包，等待苹果那边刷新缓存就好。\n\nApp Clip支持最多在三个域名的网页显示入口，到后面的工程配置那里会说明。\n\n#### 前端页面添加meta标签\n\n如果要在H5页面显示Clips入口，加上一段meta标签即可\n\n如果你的应用市场App id是 `123456`, Clips的bundle id 是 `com.abc.clips` 则应该配置\n\n```\n<meta name=\"apple-itunes-app\" content=\"app-id=123456,app-clip-bundle-id=com.abc.clips\">\n```\n\n### 开发工作\n\n#### 新建App Clip Target\n\n这里以OC工程为例\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9edc6108c0b64885b708ef5c9de8e1d0~tplv-k3u1fbpfcp-zoom-1.image\" >\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa5c9c1032174d77a4db0518029b78dd~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n#### 配置证书和Associated Domains\n\n用刚才生成的证书去配置一下即可\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fbccb4eee1445ca9b680200358535e0~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n添加Associated Domains，目的是打开对应域名网页后，页面上方能够出现Clip的入口。\n\n**这里可以添加多个域名，注意每个域名都需要配置apple-app-site-association！！！**\n\n**主工程的Target和Clip的Target都需要配置！！！**\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5125ca96f15433b8205294e48906e13~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n#### 编写代码\n\n创建完之后就会生成一个文件夹，里面就是我们熟悉的AppDelegate、SecneDelegate、Main.storyboard、Info.plist等文件，如果你不使用Storyboard进行界面搭建，那么也是跟之前的开发模式一样，删除info.plist内Application Scene Manifest，修改General-Deployment info - Main interface 为空，修改AppDelegate.m，在里面创建根控制器。\n\n之后的操作就跟普通开发一样了，调试的话可以直接在Xcode上左上角选择Clip的target，然后就可以跑起来了。\n\n另外，AppIcon是需要独立配置的，同样也是在Clip项目工程文件夹内Assets.xcassets。\n\n##### 非组件化开发模式\n\n一般情况下我们是需要复用代码的，将代码内某些模块功能进行复用，然后直接用在Clip，这时候我们只需要在右侧Target Membership勾选新建的Clip Target即可。\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2847eb910740229f410d0aa29f7bb5~tplv-k3u1fbpfcp-zoom-1.image\" width=30%>\n\n同样的 相关的依赖到的文件也需要勾选Clip Target\n\n##### 组件化开发模式 和 Podfile的配置\n\n如果是在组件化开发模式下，那么就需要配置Podfile\n\n在Podfile 底部新增代码\n\n```\nsource 'https://github.com/CocoaPods/Specs.git'\n# 你的私有pod仓库\nsource 'https://git.xxx.com/yourprivatepodspec/Podspec.git'\n\ntarget 'YourApp’ do\n    platform :ios, '10.3'\n    pod \"AFNetworking\"\n    pod \"SDWebImage\"\n    # 等等\nend\n\ntarget 'YourApp_Clips' do\n    platform :ios, '10.3'\n    pod 'ComponentA',           :path=> '../ComponentA'\n    pod \"ComponentB\",           :path=>\"../ComponentB\"\n    pod \"AFNetworking\"\n    pod \"SDWebImage\"\n    # 等等\nend\n\n```\n\n但是这样子相同的第三方pod会写两遍，所以我们可以优化成\n\n```\nsource 'https://github.com/CocoaPods/Specs.git'\n# 你的私有pod仓库\nsource 'https://git.xxx.com/yourprivatepodspec/Podspec.git'\n\ndef common_pods\n    pod \"AFNetworking\"\n    pod \"SDWebImage\"\nend\n\ntarget 'YourApp’ do\n    platform :ios, '10.3'\n    common_pods\nend\n\ntarget 'YourApp_Clips' do\n    platform :ios, '14.0'\n    pod 'ComponentA',           :path=> '../ComponentA'\n    pod \"ComponentB\",           :path=>\"../ComponentB\"\n    common_pods\nend\n\n```\n\n##### 抽离模块时不同环境的代码复用问题\n\n假如说A功能需要抽离出来放到Clip，但是A模块里面有需求是会跳转到B模块的，但是我并不希望Clip引入B模块，希望他能在这个地方提示用户下载完整App，那应该怎么做呢？\n\n首先第一个事情，苹果提供了一个Api可以引导弹窗引导用户下载APP\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fec69fde9e64618819b1b526034d23b~tplv-k3u1fbpfcp-zoom-1.image\" width=40%>\n\n```\nUIWindowScene *scene = (UIWindowScene *)[[UIApplication sharedApplication].connectedScenes.allObjects firstObject];\nSKOverlayAppConfiguration *config = [[SKOverlayAppConfiguration alloc] initWithAppIdentifier:@\"你的AppID\" position:SKOverlayPositionBottomRaised];\nSKOverlay *overlay = [[SKOverlay alloc] initWithConfiguration:config];\noverlay.delegate = self; // 添加代理后可以监听弹窗的弹出和消失，可以在代理内添加埋点。\n[overlay presentInScene:scene];\n\n// 主动让弹窗消失\n// [SKOverlay dismissOverlayInScene:scene];\n```\n\n第二. 如何在模块内划分环境，区分是主App还是Clip\n\n方法一：设计一个单例，添加一个枚举属性，分别在`主工程`的AppDelegate和`Clip`的AppDelegate内给单例的属性赋值，标记当前环境。然后在业务代码中获取单例的环境属性后进行判断。\n\n方法二：有时候我们在Clip复用的模块代码内不需要import某些头文件，因为我们不需要这个功能，这时候单例的方法就不管用了，我们需要通过宏去判断。\n\n如果代码不在pod组件内的话，只需要在Clip Target的`Build Settings` - `Preprocessor Macros`添加`APP_CLIPS`宏即可。\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7708c16f9c4247a9ab9ec393d01420b1~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n如果是组件化的开发模式，代码在pod内部，那么就稍微有点麻烦，需要在对应podspec新增一个subspec，专门提供给clip使用，然后配置上宏定义\n\n`ComponentA.podspec`\n\n```\n\ns.subspec \"App\" do |ss|\n    ss.source_files = \"xxxxxx\"\nend\n\ns.subspec \"AppClip\" do |ss|\n    ss.source_files = \"xxxxxx\"\n    ss.pod_target_xcconfig = { 'GCC_PREPROCESSOR_DEFINITIONS' => 'APP_CLIPS=1'}\nend\n```\n\n> 这里为什么要弄多一个App的subspec，因为如果主工程直接`pod ComponentA`的话，所有的subspec都会被引入，所以这里为了区分开，就加多了一个专门给主工程用的subspec\n\n`Podfile`\n\n```\ndef common_pods\n    pod \"AFNetworking\"\n    pod \"SDWebImage\"\nend\n\ntarget 'YourApp’ do\n    platform :ios, '10.3'\n    common_pods\n    pod 'ComponentA/App',           :path=> '../ComponentA'\nend\n\ntarget 'YourApp_Clips' do\n    platform :ios, '14.0'\n    pod 'ComponentA/AppClip',   :path=> '../ComponentA'\n    pod \"ComponentB\",           :path=>\"../ComponentB\"\n    common_pods\nend\n```\n\n通过以上方法，就可以用如下方式进行宏判断，区分当前环境\n\n```\n#ifdef APP_CLIPS\n\n#else\n\n#endif\n```\n\n### 测试工作\n\n#### 开发调试\n\n- 可以选择Clip Target直接使用Xcode编译运行\n\n- 可以使用真机扫描二维码，调起Clip卡片，但是前提是Clip要先在真机跑一遍。\n\t\n\t1. 手机点击`设置-开发者-Local Experiences-Register Local Experience`\n\t2. 输入域名、Clip的bundle id、标题、子标题，选择按钮标题、选择Clip弹出的卡片上的图片，然后点击存储即可。\n\t3. 将刚才输入的域名，去草料二维码等二维码生成网站生成一个二维码，然后手机相机扫描即可弹出卡片样式。\n\t4. 具体内容可以参考[官方文档](https://developer.apple.com/documentation/app_clips/testing_your_app_clip_s_launch_experience?language=objc)\n\t\n\n#### 外部测试\n\n1. 可以通过Archive打Release环境的包（Debug状态下没有选择导出Clip ipa的选项，不知道是哪里配置问题，如果有知道的小伙伴可以评论区分享一下），然后单独导出Clip的ipa，上传到蒲公英或者Fir等分发平台，测试同事就可以下载安装测试了。\n2. 如果已经传到了TestFlight，那么也可以在TestFlight上直接点击打开小程序进行测试。\n\n### 苹果官方提及的产品要求\n\n原文：[https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/](https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/)\n\n划重点：\n\n1. 请勿仅将App Clip用作营销用途，不能显示广告。\n \n2. 避免登录，避免不了的话尽可能使用Apple id登录\n\n3. Clips启动后只有在8小时内才能接收推送\n\n### Q&A\n\n1. 苹果文档说的App Clips 10M限制指的是哪个文件的10M\n\t\n\t经过测试后发现，应该是Release环境下Archive后，导出的Clips的ipa的大小，如果有误欢迎评论区指正。\n\t\n2. Clips可以有登录功能吗？\n\n\t可以，但是苹果希望用户能不登录就使用App，如果要登录也首选Sign in with Apple登录的方式(iOS13特性)，但是我们可以学网易严选那样子苹果ID登录之后再弹出手机验证码绑定功能。\n\t\n3. 可以有内购吗？\n\n\t可以。\n\t\n4. 用户使用完Clips后，如果想再次进入，入口在哪儿？\n\n\t假如是网页打开的Clips，那么离开网页后，在桌面的\"资源库\"里可以找到这个Clips并重新打开。如果找不到就搜索资源库，总能搜到的。","slug":"iOS14-App-Clips","published":1,"updated":"2021-06-06T18:52:24.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohv0041tnn0hdvo7pwg","content":"<p>本文将主要探讨App Clips开发流程 和 组件化、非组件化两种开发方式下如何复用代码的问题。</p>\n<span id=\"more\"></span>\n\n<p>App Clips是iOS14系统的新特性之一，类似于小程序，用户可以在不下载App的情况下体验到App的部分功能，如网易严选的商品详情功能（<a href=\"https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw\">https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw</a>），该功能适合做一些推广和引流的运营工作，另外苹果也提供的原生的浮窗样式，可以引导用户下载完整版App。</p>\n<p>苹果官方文档：<a href=\"https://developer.apple.com/app-clips/\">https://developer.apple.com/app-clips/</a></p>\n<h3 id=\"目前已知的触发方式\"><a href=\"#目前已知的触发方式\" class=\"headerlink\" title=\"目前已知的触发方式\"></a>目前已知的触发方式</h3><ul>\n<li><p>二维码</p>\n<p>  必须使用iOS 14系统相机或者使用控制中心的读取二维码组件来扫码才能触发App Clips。</p>\n</li>\n<li><p>NFC Tags</p>\n<p>  NFC标签感应，比如星巴克桌面内嵌的NFC Tags。</p>\n</li>\n<li><p>Safari App Banner</p>\n<p>  当用户用iOS的Safari浏览器浏览相应的网址后，页面顶部会出现一个横幅，提示用户有App Clips可以用。</p>\n</li>\n<li><p>信息</p>\n<p>  iOS系统自带的iMessage，当你在iMessage发送一个App Clips链接时，系统会自动把信息显示成一个App Clips的卡片。</p>\n</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a13d29c7a17d471dbc551c416ce2ed57~tplv-k3u1fbpfcp-watermark.image\"></p>\n<h3 id=\"开发前置工作\"><a href=\"#开发前置工作\" class=\"headerlink\" title=\"开发前置工作\"></a>开发前置工作</h3><h4 id=\"申请证书\"><a href=\"#申请证书\" class=\"headerlink\" title=\"申请证书\"></a>申请证书</h4><h5 id=\"创建App-Clips-ID\"><a href=\"#创建App-Clips-ID\" class=\"headerlink\" title=\"创建App Clips ID\"></a>创建App Clips ID</h5><ol>\n<li>点击新增APP ID</li>\n</ol>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d62145df226549428f600ace6f1b44cb~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<ol start=\"2\">\n<li>选择App Clip <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f93a07c34f7249b982f0cbca84bfcafe~tplv-k3u1fbpfcp-zoom-1.image\" >\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da0c96044db46bb897aab6f71543c8d~tplv-k3u1fbpfcp-zoom-1.image\" ></li>\n</ol>\n<ol start=\"3\">\n<li>输入一串英文名，用于拼接在主工程的bundle id的后面，生成该clip的bundle id <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2ae0fb422f149d98589f36c80123315~tplv-k3u1fbpfcp-zoom-1.image\" >\n </li>\n<li>在Description内输入描述（不能使用特殊符号），并且在下方勾选App Clip能力，比如Apple Pay，Sign in with Apple，Push等等，<strong>Associated Domains必须勾选</strong><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33e78440190242efaa8dac9b47004393~tplv-k3u1fbpfcp-zoom-1.image\" >\n </li>\n<li>最后确认并点击右上方Register即可</li>\n</ol>\n<h5 id=\"创建Profiles\"><a href=\"#创建Profiles\" class=\"headerlink\" title=\"创建Profiles\"></a>创建Profiles</h5><p>流程跟创建App的Profiles一样，就是选择bundle id的时候改成Clip的bundle id 即可，同样有Development、AdHoc、Distribution三种类型</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68bfe6ee218047b7a3232058dcc2e006~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<h5 id=\"其他配置\"><a href=\"#其他配置\" class=\"headerlink\" title=\"其他配置\"></a>其他配置</h5><p>如果需要其他NFC、地点等等的一些方式触发App Clip配置的话，参考这个苹果的文档<a href=\"https://help.apple.com/app-store-connect/#/dev5b665db74\">https://help.apple.com/app-store-connect/#/dev5b665db74</a></p>\n<h4 id=\"Apple-Store-Connect-配置图片和标题，描述\"><a href=\"#Apple-Store-Connect-配置图片和标题，描述\" class=\"headerlink\" title=\"Apple Store Connect 配置图片和标题，描述\"></a>Apple Store Connect 配置图片和标题，描述</h4><ol>\n<li>需要一张1800 * 1200 的图片，用于显示在Clip的卡片上</li>\n<li>副标题用于显示在卡片标题下的小字，如图所示<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b3e18f56f6d49219fc46f77dab1cef2~tplv-k3u1fbpfcp-zoom-1.image\" width=30%></li>\n<li>操作包括“打开”“查看”“开始游戏”，体现在卡片右边的蓝色按钮内的文案，根据你的产品类型进行选择就好</li>\n</ol>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c14c35967084886bc3f4fce6e985fcb~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n\n<h4 id=\"配置apple-app-site-association-json\"><a href=\"#配置apple-app-site-association-json\" class=\"headerlink\" title=\"配置apple-app-site-association.json\"></a>配置apple-app-site-association.json</h4><p>假设你的开发者账号的Team Id是<code>A123</code>，Clips的bundle id是<code>com.abc.def.clips</code>，主工程的bundle id 是<code>com.abc.def</code>，则配置如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;appclips&quot;:&#123;</span><br><span class=\"line\">        &quot;apps&quot;:[&quot;A123.com.abc.def.clips&quot;]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;applinks&quot;:&#123;</span><br><span class=\"line\">        &quot;apps&quot;:[</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        &quot;details&quot;:&#123;</span><br><span class=\"line\">            &quot;A123.com.abc.def&quot;:&#123;</span><br><span class=\"line\">                &quot;paths&quot;:[</span><br><span class=\"line\">                    &quot;*&quot; &#x2F;&#x2F; 这里的Path根据实际情况配置即可</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;webcredentials&quot;:&#123;</span><br><span class=\"line\">        &quot;apps&quot;:[</span><br><span class=\"line\">            &quot;A123.com.abc.def&quot;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;activitycontinuation&quot;:&#123;</span><br><span class=\"line\">        &quot;apps&quot;:[</span><br><span class=\"line\">            &quot;A123.com.abc.def&quot;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配置完成后部署到你自己域名的根目录下，配置方法网上很多教程，这里贴上<a href=\"https://developer.apple.com/documentation/safariservices/supporting_associated_domains?language=objc\">苹果官方文档</a></p>\n<p>如果配置错了，那么上传包到苹果后台之后，就会显示无效域名<br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05ddb4d106a349d28c1504762697a9eb~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>如果是json配置错误，那么配置正确后不用重新传包，等待苹果那边刷新缓存就好。</p>\n<p>App Clip支持最多在三个域名的网页显示入口，到后面的工程配置那里会说明。</p>\n<h4 id=\"前端页面添加meta标签\"><a href=\"#前端页面添加meta标签\" class=\"headerlink\" title=\"前端页面添加meta标签\"></a>前端页面添加meta标签</h4><p>如果要在H5页面显示Clips入口，加上一段meta标签即可</p>\n<p>如果你的应用市场App id是 <code>123456</code>, Clips的bundle id 是 <code>com.abc.clips</code> 则应该配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name&#x3D;&quot;apple-itunes-app&quot; content&#x3D;&quot;app-id&#x3D;123456,app-clip-bundle-id&#x3D;com.abc.clips&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"开发工作\"><a href=\"#开发工作\" class=\"headerlink\" title=\"开发工作\"></a>开发工作</h3><h4 id=\"新建App-Clip-Target\"><a href=\"#新建App-Clip-Target\" class=\"headerlink\" title=\"新建App Clip Target\"></a>新建App Clip Target</h4><p>这里以OC工程为例</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9edc6108c0b64885b708ef5c9de8e1d0~tplv-k3u1fbpfcp-zoom-1.image\" >\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa5c9c1032174d77a4db0518029b78dd~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<h4 id=\"配置证书和Associated-Domains\"><a href=\"#配置证书和Associated-Domains\" class=\"headerlink\" title=\"配置证书和Associated Domains\"></a>配置证书和Associated Domains</h4><p>用刚才生成的证书去配置一下即可</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fbccb4eee1445ca9b680200358535e0~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<p>添加Associated Domains，目的是打开对应域名网页后，页面上方能够出现Clip的入口。</p>\n<p><strong>这里可以添加多个域名，注意每个域名都需要配置apple-app-site-association！！！</strong></p>\n<p><strong>主工程的Target和Clip的Target都需要配置！！！</strong></p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5125ca96f15433b8205294e48906e13~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<h4 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h4><p>创建完之后就会生成一个文件夹，里面就是我们熟悉的AppDelegate、SecneDelegate、Main.storyboard、Info.plist等文件，如果你不使用Storyboard进行界面搭建，那么也是跟之前的开发模式一样，删除info.plist内Application Scene Manifest，修改General-Deployment info - Main interface 为空，修改AppDelegate.m，在里面创建根控制器。</p>\n<p>之后的操作就跟普通开发一样了，调试的话可以直接在Xcode上左上角选择Clip的target，然后就可以跑起来了。</p>\n<p>另外，AppIcon是需要独立配置的，同样也是在Clip项目工程文件夹内Assets.xcassets。</p>\n<h5 id=\"非组件化开发模式\"><a href=\"#非组件化开发模式\" class=\"headerlink\" title=\"非组件化开发模式\"></a>非组件化开发模式</h5><p>一般情况下我们是需要复用代码的，将代码内某些模块功能进行复用，然后直接用在Clip，这时候我们只需要在右侧Target Membership勾选新建的Clip Target即可。</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2847eb910740229f410d0aa29f7bb5~tplv-k3u1fbpfcp-zoom-1.image\" width=30%>\n\n<p>同样的 相关的依赖到的文件也需要勾选Clip Target</p>\n<h5 id=\"组件化开发模式-和-Podfile的配置\"><a href=\"#组件化开发模式-和-Podfile的配置\" class=\"headerlink\" title=\"组件化开发模式 和 Podfile的配置\"></a>组件化开发模式 和 Podfile的配置</h5><p>如果是在组件化开发模式下，那么就需要配置Podfile</p>\n<p>在Podfile 底部新增代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class=\"line\"># 你的私有pod仓库</span><br><span class=\"line\">source &#39;https:&#x2F;&#x2F;git.xxx.com&#x2F;yourprivatepodspec&#x2F;Podspec.git&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp’ do</span><br><span class=\"line\">    platform :ios, &#39;10.3&#39;</span><br><span class=\"line\">    pod &quot;AFNetworking&quot;</span><br><span class=\"line\">    pod &quot;SDWebImage&quot;</span><br><span class=\"line\">    # 等等</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp_Clips&#39; do</span><br><span class=\"line\">    platform :ios, &#39;10.3&#39;</span><br><span class=\"line\">    pod &#39;ComponentA&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class=\"line\">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class=\"line\">    pod &quot;AFNetworking&quot;</span><br><span class=\"line\">    pod &quot;SDWebImage&quot;</span><br><span class=\"line\">    # 等等</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>但是这样子相同的第三方pod会写两遍，所以我们可以优化成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class=\"line\"># 你的私有pod仓库</span><br><span class=\"line\">source &#39;https:&#x2F;&#x2F;git.xxx.com&#x2F;yourprivatepodspec&#x2F;Podspec.git&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">def common_pods</span><br><span class=\"line\">    pod &quot;AFNetworking&quot;</span><br><span class=\"line\">    pod &quot;SDWebImage&quot;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp’ do</span><br><span class=\"line\">    platform :ios, &#39;10.3&#39;</span><br><span class=\"line\">    common_pods</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp_Clips&#39; do</span><br><span class=\"line\">    platform :ios, &#39;14.0&#39;</span><br><span class=\"line\">    pod &#39;ComponentA&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class=\"line\">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class=\"line\">    common_pods</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"抽离模块时不同环境的代码复用问题\"><a href=\"#抽离模块时不同环境的代码复用问题\" class=\"headerlink\" title=\"抽离模块时不同环境的代码复用问题\"></a>抽离模块时不同环境的代码复用问题</h5><p>假如说A功能需要抽离出来放到Clip，但是A模块里面有需求是会跳转到B模块的，但是我并不希望Clip引入B模块，希望他能在这个地方提示用户下载完整App，那应该怎么做呢？</p>\n<p>首先第一个事情，苹果提供了一个Api可以引导弹窗引导用户下载APP</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fec69fde9e64618819b1b526034d23b~tplv-k3u1fbpfcp-zoom-1.image\" width=40%>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIWindowScene *scene &#x3D; (UIWindowScene *)[[UIApplication sharedApplication].connectedScenes.allObjects firstObject];</span><br><span class=\"line\">SKOverlayAppConfiguration *config &#x3D; [[SKOverlayAppConfiguration alloc] initWithAppIdentifier:@&quot;你的AppID&quot; position:SKOverlayPositionBottomRaised];</span><br><span class=\"line\">SKOverlay *overlay &#x3D; [[SKOverlay alloc] initWithConfiguration:config];</span><br><span class=\"line\">overlay.delegate &#x3D; self; &#x2F;&#x2F; 添加代理后可以监听弹窗的弹出和消失，可以在代理内添加埋点。</span><br><span class=\"line\">[overlay presentInScene:scene];</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 主动让弹窗消失</span><br><span class=\"line\">&#x2F;&#x2F; [SKOverlay dismissOverlayInScene:scene];</span><br></pre></td></tr></table></figure>\n\n<p>第二. 如何在模块内划分环境，区分是主App还是Clip</p>\n<p>方法一：设计一个单例，添加一个枚举属性，分别在<code>主工程</code>的AppDelegate和<code>Clip</code>的AppDelegate内给单例的属性赋值，标记当前环境。然后在业务代码中获取单例的环境属性后进行判断。</p>\n<p>方法二：有时候我们在Clip复用的模块代码内不需要import某些头文件，因为我们不需要这个功能，这时候单例的方法就不管用了，我们需要通过宏去判断。</p>\n<p>如果代码不在pod组件内的话，只需要在Clip Target的<code>Build Settings</code> - <code>Preprocessor Macros</code>添加<code>APP_CLIPS</code>宏即可。</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7708c16f9c4247a9ab9ec393d01420b1~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<p>如果是组件化的开发模式，代码在pod内部，那么就稍微有点麻烦，需要在对应podspec新增一个subspec，专门提供给clip使用，然后配置上宏定义</p>\n<p><code>ComponentA.podspec</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">s.subspec &quot;App&quot; do |ss|</span><br><span class=\"line\">    ss.source_files &#x3D; &quot;xxxxxx&quot;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec &quot;AppClip&quot; do |ss|</span><br><span class=\"line\">    ss.source_files &#x3D; &quot;xxxxxx&quot;</span><br><span class=\"line\">    ss.pod_target_xcconfig &#x3D; &#123; &#39;GCC_PREPROCESSOR_DEFINITIONS&#39; &#x3D;&gt; &#39;APP_CLIPS&#x3D;1&#39;&#125;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里为什么要弄多一个App的subspec，因为如果主工程直接<code>pod ComponentA</code>的话，所有的subspec都会被引入，所以这里为了区分开，就加多了一个专门给主工程用的subspec</p>\n</blockquote>\n<p><code>Podfile</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def common_pods</span><br><span class=\"line\">    pod &quot;AFNetworking&quot;</span><br><span class=\"line\">    pod &quot;SDWebImage&quot;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp’ do</span><br><span class=\"line\">    platform :ios, &#39;10.3&#39;</span><br><span class=\"line\">    common_pods</span><br><span class=\"line\">    pod &#39;ComponentA&#x2F;App&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp_Clips&#39; do</span><br><span class=\"line\">    platform :ios, &#39;14.0&#39;</span><br><span class=\"line\">    pod &#39;ComponentA&#x2F;AppClip&#39;,   :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class=\"line\">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class=\"line\">    common_pods</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>通过以上方法，就可以用如下方式进行宏判断，区分当前环境</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#ifdef APP_CLIPS</span><br><span class=\"line\"></span><br><span class=\"line\">#else</span><br><span class=\"line\"></span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试工作\"><a href=\"#测试工作\" class=\"headerlink\" title=\"测试工作\"></a>测试工作</h3><h4 id=\"开发调试\"><a href=\"#开发调试\" class=\"headerlink\" title=\"开发调试\"></a>开发调试</h4><ul>\n<li><p>可以选择Clip Target直接使用Xcode编译运行</p>\n</li>\n<li><p>可以使用真机扫描二维码，调起Clip卡片，但是前提是Clip要先在真机跑一遍。</p>\n<ol>\n<li>手机点击<code>设置-开发者-Local Experiences-Register Local Experience</code></li>\n<li>输入域名、Clip的bundle id、标题、子标题，选择按钮标题、选择Clip弹出的卡片上的图片，然后点击存储即可。</li>\n<li>将刚才输入的域名，去草料二维码等二维码生成网站生成一个二维码，然后手机相机扫描即可弹出卡片样式。</li>\n<li>具体内容可以参考<a href=\"https://developer.apple.com/documentation/app_clips/testing_your_app_clip_s_launch_experience?language=objc\">官方文档</a></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"外部测试\"><a href=\"#外部测试\" class=\"headerlink\" title=\"外部测试\"></a>外部测试</h4><ol>\n<li>可以通过Archive打Release环境的包（Debug状态下没有选择导出Clip ipa的选项，不知道是哪里配置问题，如果有知道的小伙伴可以评论区分享一下），然后单独导出Clip的ipa，上传到蒲公英或者Fir等分发平台，测试同事就可以下载安装测试了。</li>\n<li>如果已经传到了TestFlight，那么也可以在TestFlight上直接点击打开小程序进行测试。</li>\n</ol>\n<h3 id=\"苹果官方提及的产品要求\"><a href=\"#苹果官方提及的产品要求\" class=\"headerlink\" title=\"苹果官方提及的产品要求\"></a>苹果官方提及的产品要求</h3><p>原文：<a href=\"https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/\">https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/</a></p>\n<p>划重点：</p>\n<ol>\n<li><p>请勿仅将App Clip用作营销用途，不能显示广告。</p>\n</li>\n<li><p>避免登录，避免不了的话尽可能使用Apple id登录</p>\n</li>\n<li><p>Clips启动后只有在8小时内才能接收推送</p>\n</li>\n</ol>\n<h3 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h3><ol>\n<li><p>苹果文档说的App Clips 10M限制指的是哪个文件的10M</p>\n<p> 经过测试后发现，应该是Release环境下Archive后，导出的Clips的ipa的大小，如果有误欢迎评论区指正。</p>\n</li>\n<li><p>Clips可以有登录功能吗？</p>\n<p> 可以，但是苹果希望用户能不登录就使用App，如果要登录也首选Sign in with Apple登录的方式(iOS13特性)，但是我们可以学网易严选那样子苹果ID登录之后再弹出手机验证码绑定功能。</p>\n</li>\n<li><p>可以有内购吗？</p>\n<p> 可以。</p>\n</li>\n<li><p>用户使用完Clips后，如果想再次进入，入口在哪儿？</p>\n<p> 假如是网页打开的Clips，那么离开网页后，在桌面的”资源库”里可以找到这个Clips并重新打开。如果找不到就搜索资源库，总能搜到的。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本文将主要探讨App Clips开发流程 和 组件化、非组件化两种开发方式下如何复用代码的问题。</p>","more":"<p>App Clips是iOS14系统的新特性之一，类似于小程序，用户可以在不下载App的情况下体验到App的部分功能，如网易严选的商品详情功能（<a href=\"https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw\">https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw</a>），该功能适合做一些推广和引流的运营工作，另外苹果也提供的原生的浮窗样式，可以引导用户下载完整版App。</p>\n<p>苹果官方文档：<a href=\"https://developer.apple.com/app-clips/\">https://developer.apple.com/app-clips/</a></p>\n<h3 id=\"目前已知的触发方式\"><a href=\"#目前已知的触发方式\" class=\"headerlink\" title=\"目前已知的触发方式\"></a>目前已知的触发方式</h3><ul>\n<li><p>二维码</p>\n<p>  必须使用iOS 14系统相机或者使用控制中心的读取二维码组件来扫码才能触发App Clips。</p>\n</li>\n<li><p>NFC Tags</p>\n<p>  NFC标签感应，比如星巴克桌面内嵌的NFC Tags。</p>\n</li>\n<li><p>Safari App Banner</p>\n<p>  当用户用iOS的Safari浏览器浏览相应的网址后，页面顶部会出现一个横幅，提示用户有App Clips可以用。</p>\n</li>\n<li><p>信息</p>\n<p>  iOS系统自带的iMessage，当你在iMessage发送一个App Clips链接时，系统会自动把信息显示成一个App Clips的卡片。</p>\n</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a13d29c7a17d471dbc551c416ce2ed57~tplv-k3u1fbpfcp-watermark.image\"></p>\n<h3 id=\"开发前置工作\"><a href=\"#开发前置工作\" class=\"headerlink\" title=\"开发前置工作\"></a>开发前置工作</h3><h4 id=\"申请证书\"><a href=\"#申请证书\" class=\"headerlink\" title=\"申请证书\"></a>申请证书</h4><h5 id=\"创建App-Clips-ID\"><a href=\"#创建App-Clips-ID\" class=\"headerlink\" title=\"创建App Clips ID\"></a>创建App Clips ID</h5><ol>\n<li>点击新增APP ID</li>\n</ol>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d62145df226549428f600ace6f1b44cb~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<ol start=\"2\">\n<li>选择App Clip <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f93a07c34f7249b982f0cbca84bfcafe~tplv-k3u1fbpfcp-zoom-1.image\" >\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da0c96044db46bb897aab6f71543c8d~tplv-k3u1fbpfcp-zoom-1.image\" ></li>\n</ol>\n<ol start=\"3\">\n<li>输入一串英文名，用于拼接在主工程的bundle id的后面，生成该clip的bundle id <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2ae0fb422f149d98589f36c80123315~tplv-k3u1fbpfcp-zoom-1.image\" >\n </li>\n<li>在Description内输入描述（不能使用特殊符号），并且在下方勾选App Clip能力，比如Apple Pay，Sign in with Apple，Push等等，<strong>Associated Domains必须勾选</strong><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33e78440190242efaa8dac9b47004393~tplv-k3u1fbpfcp-zoom-1.image\" >\n </li>\n<li>最后确认并点击右上方Register即可</li>\n</ol>\n<h5 id=\"创建Profiles\"><a href=\"#创建Profiles\" class=\"headerlink\" title=\"创建Profiles\"></a>创建Profiles</h5><p>流程跟创建App的Profiles一样，就是选择bundle id的时候改成Clip的bundle id 即可，同样有Development、AdHoc、Distribution三种类型</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68bfe6ee218047b7a3232058dcc2e006~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<h5 id=\"其他配置\"><a href=\"#其他配置\" class=\"headerlink\" title=\"其他配置\"></a>其他配置</h5><p>如果需要其他NFC、地点等等的一些方式触发App Clip配置的话，参考这个苹果的文档<a href=\"https://help.apple.com/app-store-connect/#/dev5b665db74\">https://help.apple.com/app-store-connect/#/dev5b665db74</a></p>\n<h4 id=\"Apple-Store-Connect-配置图片和标题，描述\"><a href=\"#Apple-Store-Connect-配置图片和标题，描述\" class=\"headerlink\" title=\"Apple Store Connect 配置图片和标题，描述\"></a>Apple Store Connect 配置图片和标题，描述</h4><ol>\n<li>需要一张1800 * 1200 的图片，用于显示在Clip的卡片上</li>\n<li>副标题用于显示在卡片标题下的小字，如图所示<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b3e18f56f6d49219fc46f77dab1cef2~tplv-k3u1fbpfcp-zoom-1.image\" width=30%></li>\n<li>操作包括“打开”“查看”“开始游戏”，体现在卡片右边的蓝色按钮内的文案，根据你的产品类型进行选择就好</li>\n</ol>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c14c35967084886bc3f4fce6e985fcb~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n\n<h4 id=\"配置apple-app-site-association-json\"><a href=\"#配置apple-app-site-association-json\" class=\"headerlink\" title=\"配置apple-app-site-association.json\"></a>配置apple-app-site-association.json</h4><p>假设你的开发者账号的Team Id是<code>A123</code>，Clips的bundle id是<code>com.abc.def.clips</code>，主工程的bundle id 是<code>com.abc.def</code>，则配置如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;appclips&quot;:&#123;</span><br><span class=\"line\">        &quot;apps&quot;:[&quot;A123.com.abc.def.clips&quot;]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;applinks&quot;:&#123;</span><br><span class=\"line\">        &quot;apps&quot;:[</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        &quot;details&quot;:&#123;</span><br><span class=\"line\">            &quot;A123.com.abc.def&quot;:&#123;</span><br><span class=\"line\">                &quot;paths&quot;:[</span><br><span class=\"line\">                    &quot;*&quot; &#x2F;&#x2F; 这里的Path根据实际情况配置即可</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;webcredentials&quot;:&#123;</span><br><span class=\"line\">        &quot;apps&quot;:[</span><br><span class=\"line\">            &quot;A123.com.abc.def&quot;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;activitycontinuation&quot;:&#123;</span><br><span class=\"line\">        &quot;apps&quot;:[</span><br><span class=\"line\">            &quot;A123.com.abc.def&quot;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配置完成后部署到你自己域名的根目录下，配置方法网上很多教程，这里贴上<a href=\"https://developer.apple.com/documentation/safariservices/supporting_associated_domains?language=objc\">苹果官方文档</a></p>\n<p>如果配置错了，那么上传包到苹果后台之后，就会显示无效域名<br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05ddb4d106a349d28c1504762697a9eb~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>如果是json配置错误，那么配置正确后不用重新传包，等待苹果那边刷新缓存就好。</p>\n<p>App Clip支持最多在三个域名的网页显示入口，到后面的工程配置那里会说明。</p>\n<h4 id=\"前端页面添加meta标签\"><a href=\"#前端页面添加meta标签\" class=\"headerlink\" title=\"前端页面添加meta标签\"></a>前端页面添加meta标签</h4><p>如果要在H5页面显示Clips入口，加上一段meta标签即可</p>\n<p>如果你的应用市场App id是 <code>123456</code>, Clips的bundle id 是 <code>com.abc.clips</code> 则应该配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name&#x3D;&quot;apple-itunes-app&quot; content&#x3D;&quot;app-id&#x3D;123456,app-clip-bundle-id&#x3D;com.abc.clips&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"开发工作\"><a href=\"#开发工作\" class=\"headerlink\" title=\"开发工作\"></a>开发工作</h3><h4 id=\"新建App-Clip-Target\"><a href=\"#新建App-Clip-Target\" class=\"headerlink\" title=\"新建App Clip Target\"></a>新建App Clip Target</h4><p>这里以OC工程为例</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9edc6108c0b64885b708ef5c9de8e1d0~tplv-k3u1fbpfcp-zoom-1.image\" >\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa5c9c1032174d77a4db0518029b78dd~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<h4 id=\"配置证书和Associated-Domains\"><a href=\"#配置证书和Associated-Domains\" class=\"headerlink\" title=\"配置证书和Associated Domains\"></a>配置证书和Associated Domains</h4><p>用刚才生成的证书去配置一下即可</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fbccb4eee1445ca9b680200358535e0~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<p>添加Associated Domains，目的是打开对应域名网页后，页面上方能够出现Clip的入口。</p>\n<p><strong>这里可以添加多个域名，注意每个域名都需要配置apple-app-site-association！！！</strong></p>\n<p><strong>主工程的Target和Clip的Target都需要配置！！！</strong></p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5125ca96f15433b8205294e48906e13~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<h4 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h4><p>创建完之后就会生成一个文件夹，里面就是我们熟悉的AppDelegate、SecneDelegate、Main.storyboard、Info.plist等文件，如果你不使用Storyboard进行界面搭建，那么也是跟之前的开发模式一样，删除info.plist内Application Scene Manifest，修改General-Deployment info - Main interface 为空，修改AppDelegate.m，在里面创建根控制器。</p>\n<p>之后的操作就跟普通开发一样了，调试的话可以直接在Xcode上左上角选择Clip的target，然后就可以跑起来了。</p>\n<p>另外，AppIcon是需要独立配置的，同样也是在Clip项目工程文件夹内Assets.xcassets。</p>\n<h5 id=\"非组件化开发模式\"><a href=\"#非组件化开发模式\" class=\"headerlink\" title=\"非组件化开发模式\"></a>非组件化开发模式</h5><p>一般情况下我们是需要复用代码的，将代码内某些模块功能进行复用，然后直接用在Clip，这时候我们只需要在右侧Target Membership勾选新建的Clip Target即可。</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2847eb910740229f410d0aa29f7bb5~tplv-k3u1fbpfcp-zoom-1.image\" width=30%>\n\n<p>同样的 相关的依赖到的文件也需要勾选Clip Target</p>\n<h5 id=\"组件化开发模式-和-Podfile的配置\"><a href=\"#组件化开发模式-和-Podfile的配置\" class=\"headerlink\" title=\"组件化开发模式 和 Podfile的配置\"></a>组件化开发模式 和 Podfile的配置</h5><p>如果是在组件化开发模式下，那么就需要配置Podfile</p>\n<p>在Podfile 底部新增代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class=\"line\"># 你的私有pod仓库</span><br><span class=\"line\">source &#39;https:&#x2F;&#x2F;git.xxx.com&#x2F;yourprivatepodspec&#x2F;Podspec.git&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp’ do</span><br><span class=\"line\">    platform :ios, &#39;10.3&#39;</span><br><span class=\"line\">    pod &quot;AFNetworking&quot;</span><br><span class=\"line\">    pod &quot;SDWebImage&quot;</span><br><span class=\"line\">    # 等等</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp_Clips&#39; do</span><br><span class=\"line\">    platform :ios, &#39;10.3&#39;</span><br><span class=\"line\">    pod &#39;ComponentA&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class=\"line\">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class=\"line\">    pod &quot;AFNetworking&quot;</span><br><span class=\"line\">    pod &quot;SDWebImage&quot;</span><br><span class=\"line\">    # 等等</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>但是这样子相同的第三方pod会写两遍，所以我们可以优化成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class=\"line\"># 你的私有pod仓库</span><br><span class=\"line\">source &#39;https:&#x2F;&#x2F;git.xxx.com&#x2F;yourprivatepodspec&#x2F;Podspec.git&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">def common_pods</span><br><span class=\"line\">    pod &quot;AFNetworking&quot;</span><br><span class=\"line\">    pod &quot;SDWebImage&quot;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp’ do</span><br><span class=\"line\">    platform :ios, &#39;10.3&#39;</span><br><span class=\"line\">    common_pods</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp_Clips&#39; do</span><br><span class=\"line\">    platform :ios, &#39;14.0&#39;</span><br><span class=\"line\">    pod &#39;ComponentA&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class=\"line\">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class=\"line\">    common_pods</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"抽离模块时不同环境的代码复用问题\"><a href=\"#抽离模块时不同环境的代码复用问题\" class=\"headerlink\" title=\"抽离模块时不同环境的代码复用问题\"></a>抽离模块时不同环境的代码复用问题</h5><p>假如说A功能需要抽离出来放到Clip，但是A模块里面有需求是会跳转到B模块的，但是我并不希望Clip引入B模块，希望他能在这个地方提示用户下载完整App，那应该怎么做呢？</p>\n<p>首先第一个事情，苹果提供了一个Api可以引导弹窗引导用户下载APP</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fec69fde9e64618819b1b526034d23b~tplv-k3u1fbpfcp-zoom-1.image\" width=40%>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIWindowScene *scene &#x3D; (UIWindowScene *)[[UIApplication sharedApplication].connectedScenes.allObjects firstObject];</span><br><span class=\"line\">SKOverlayAppConfiguration *config &#x3D; [[SKOverlayAppConfiguration alloc] initWithAppIdentifier:@&quot;你的AppID&quot; position:SKOverlayPositionBottomRaised];</span><br><span class=\"line\">SKOverlay *overlay &#x3D; [[SKOverlay alloc] initWithConfiguration:config];</span><br><span class=\"line\">overlay.delegate &#x3D; self; &#x2F;&#x2F; 添加代理后可以监听弹窗的弹出和消失，可以在代理内添加埋点。</span><br><span class=\"line\">[overlay presentInScene:scene];</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 主动让弹窗消失</span><br><span class=\"line\">&#x2F;&#x2F; [SKOverlay dismissOverlayInScene:scene];</span><br></pre></td></tr></table></figure>\n\n<p>第二. 如何在模块内划分环境，区分是主App还是Clip</p>\n<p>方法一：设计一个单例，添加一个枚举属性，分别在<code>主工程</code>的AppDelegate和<code>Clip</code>的AppDelegate内给单例的属性赋值，标记当前环境。然后在业务代码中获取单例的环境属性后进行判断。</p>\n<p>方法二：有时候我们在Clip复用的模块代码内不需要import某些头文件，因为我们不需要这个功能，这时候单例的方法就不管用了，我们需要通过宏去判断。</p>\n<p>如果代码不在pod组件内的话，只需要在Clip Target的<code>Build Settings</code> - <code>Preprocessor Macros</code>添加<code>APP_CLIPS</code>宏即可。</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7708c16f9c4247a9ab9ec393d01420b1~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<p>如果是组件化的开发模式，代码在pod内部，那么就稍微有点麻烦，需要在对应podspec新增一个subspec，专门提供给clip使用，然后配置上宏定义</p>\n<p><code>ComponentA.podspec</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">s.subspec &quot;App&quot; do |ss|</span><br><span class=\"line\">    ss.source_files &#x3D; &quot;xxxxxx&quot;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec &quot;AppClip&quot; do |ss|</span><br><span class=\"line\">    ss.source_files &#x3D; &quot;xxxxxx&quot;</span><br><span class=\"line\">    ss.pod_target_xcconfig &#x3D; &#123; &#39;GCC_PREPROCESSOR_DEFINITIONS&#39; &#x3D;&gt; &#39;APP_CLIPS&#x3D;1&#39;&#125;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里为什么要弄多一个App的subspec，因为如果主工程直接<code>pod ComponentA</code>的话，所有的subspec都会被引入，所以这里为了区分开，就加多了一个专门给主工程用的subspec</p>\n</blockquote>\n<p><code>Podfile</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def common_pods</span><br><span class=\"line\">    pod &quot;AFNetworking&quot;</span><br><span class=\"line\">    pod &quot;SDWebImage&quot;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp’ do</span><br><span class=\"line\">    platform :ios, &#39;10.3&#39;</span><br><span class=\"line\">    common_pods</span><br><span class=\"line\">    pod &#39;ComponentA&#x2F;App&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp_Clips&#39; do</span><br><span class=\"line\">    platform :ios, &#39;14.0&#39;</span><br><span class=\"line\">    pod &#39;ComponentA&#x2F;AppClip&#39;,   :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class=\"line\">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class=\"line\">    common_pods</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>通过以上方法，就可以用如下方式进行宏判断，区分当前环境</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#ifdef APP_CLIPS</span><br><span class=\"line\"></span><br><span class=\"line\">#else</span><br><span class=\"line\"></span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试工作\"><a href=\"#测试工作\" class=\"headerlink\" title=\"测试工作\"></a>测试工作</h3><h4 id=\"开发调试\"><a href=\"#开发调试\" class=\"headerlink\" title=\"开发调试\"></a>开发调试</h4><ul>\n<li><p>可以选择Clip Target直接使用Xcode编译运行</p>\n</li>\n<li><p>可以使用真机扫描二维码，调起Clip卡片，但是前提是Clip要先在真机跑一遍。</p>\n<ol>\n<li>手机点击<code>设置-开发者-Local Experiences-Register Local Experience</code></li>\n<li>输入域名、Clip的bundle id、标题、子标题，选择按钮标题、选择Clip弹出的卡片上的图片，然后点击存储即可。</li>\n<li>将刚才输入的域名，去草料二维码等二维码生成网站生成一个二维码，然后手机相机扫描即可弹出卡片样式。</li>\n<li>具体内容可以参考<a href=\"https://developer.apple.com/documentation/app_clips/testing_your_app_clip_s_launch_experience?language=objc\">官方文档</a></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"外部测试\"><a href=\"#外部测试\" class=\"headerlink\" title=\"外部测试\"></a>外部测试</h4><ol>\n<li>可以通过Archive打Release环境的包（Debug状态下没有选择导出Clip ipa的选项，不知道是哪里配置问题，如果有知道的小伙伴可以评论区分享一下），然后单独导出Clip的ipa，上传到蒲公英或者Fir等分发平台，测试同事就可以下载安装测试了。</li>\n<li>如果已经传到了TestFlight，那么也可以在TestFlight上直接点击打开小程序进行测试。</li>\n</ol>\n<h3 id=\"苹果官方提及的产品要求\"><a href=\"#苹果官方提及的产品要求\" class=\"headerlink\" title=\"苹果官方提及的产品要求\"></a>苹果官方提及的产品要求</h3><p>原文：<a href=\"https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/\">https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/</a></p>\n<p>划重点：</p>\n<ol>\n<li><p>请勿仅将App Clip用作营销用途，不能显示广告。</p>\n</li>\n<li><p>避免登录，避免不了的话尽可能使用Apple id登录</p>\n</li>\n<li><p>Clips启动后只有在8小时内才能接收推送</p>\n</li>\n</ol>\n<h3 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h3><ol>\n<li><p>苹果文档说的App Clips 10M限制指的是哪个文件的10M</p>\n<p> 经过测试后发现，应该是Release环境下Archive后，导出的Clips的ipa的大小，如果有误欢迎评论区指正。</p>\n</li>\n<li><p>Clips可以有登录功能吗？</p>\n<p> 可以，但是苹果希望用户能不登录就使用App，如果要登录也首选Sign in with Apple登录的方式(iOS13特性)，但是我们可以学网易严选那样子苹果ID登录之后再弹出手机验证码绑定功能。</p>\n</li>\n<li><p>可以有内购吗？</p>\n<p> 可以。</p>\n</li>\n<li><p>用户使用完Clips后，如果想再次进入，入口在哪儿？</p>\n<p> 假如是网页打开的Clips，那么离开网页后，在桌面的”资源库”里可以找到这个Clips并重新打开。如果找不到就搜索资源库，总能搜到的。</p>\n</li>\n</ol>"},{"abbrlink":"0","author":"Arclin","title":"iOS12 新玩具ShortCut(捷径)使用","date":"2018-09-28T05:05:00.000Z","_content":"\n### 介绍\n\n升级iOS12之后可以在`设置-Siri`与搜索 中发现一个 `捷径` 功能, 所谓ShortCut就是其英文翻译\n其作用就是让用户自定义一个一句话或者短语, 然后可以触发app做一系列动作\n\n<!-- more -->\n\n### 接入\n\nShortCut分为两种, 一种是在手机的`Spotlight`上搜索某个关键字的时候可以搜索到你的app, 这个关键字就是ShortCut的一种(文字输入), 你需要使用`NSUserActivity`去实现这个功能\n> 依赖 `CoreSpotlight` `CoreServices`\n\n另外一种叫做 `Intent`(语音输入), 需要添加一个IntentExtension和IntentExtensionUI, 然后在主Target添加一个intentdefinition文件, 详细的配置大家可以参考\n[文章1](https://juejin.im/post/5b2077d8f265da6e45549c68)\n[文章2](http://www.cnblogs.com/czjie2010/p/czjie.html)\n\n> 依赖`Intents` `IntentsUI`\n\n\n### 最简单的配置操作步骤\n\n1. 项目的`Capabilities`打开`Siri`\n2. 授权\n\t```\n\tif (@available(iOS 10.0, *)) {\n\t\t[INPreferences requestSiriAuthorization:^(INSiriAuthorizationStatus status) {\n\t\t\tswitch (status) {\n\t\t\t\tcase INSiriAuthorizationStatusNotDetermined:\n\t\t\t\t\tNSLog(@\"用户尚未对该应用程序作出选择。\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase INSiriAuthorizationStatusRestricted:\n\t\t\t\t\tNSLog(@\"此应用程序无权使用Siri服务\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase INSiriAuthorizationStatusDenied:\n\t\t\t\t\tNSLog(@\"用户已明确拒绝此应用程序的授权\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase INSiriAuthorizationStatusAuthorized:\n\t\t\t\t\tNSLog(@\"用户可以使用此应用程序的授权\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}];\n\t}\n\t```\n\t- 新建一个`intentdefinition`，比如`A.intentdefinition`\n\t- 新建一个`Target`,`Intent Extension`有需要的话把`Intent UI Extension`也加上，`General`中配置相关证书\n\t- 进入`A.intentdefinition`，界面左下角`+`号点一下，点击`new intent`\n\t- 界面右边`Target Membership`，把`步骤2`中新增的`Target`给勾上\n\t-  界面中间`Title`填写需要展示的标题，`Descripion` 写描述\n\t- Build一下，系统自动生成头文件，头文件名字在界面右测的导航页的第三个按钮的`Custom Class`里\n\t- 找个控制器，导入`步骤8`生成的头文件，添加个按钮，比如\n\n\t```\n\tself.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@\"捷径\" style:UIBarButtonItemStylePlain target:self action:@selector(siri:)];\n\t```\n\n3. 点击按钮召唤添加Shortcut的控制器\n\n\t```\n\t- (void)siri:(UIBarButtonItem *)item {\n\t    if (@available(iOS 12.0, *)) {\n\t    \t // 这个类名具体看你生成了叫什么名字的头文件\n\t        ZeRiIntent *intent = [[ZeRiIntent alloc] init];\n\t        intent.suggestedInvocationPhrase = @\"打开xxx\"; // 引导用户说的语句\n\t        INShortcut *shortCur = [[INShortcut alloc] initWithIntent:intent];\n\t        INUIAddVoiceShortcutViewController *vc = [[INUIAddVoiceShortcutViewController alloc] initWithShortcut:shortCur];\n\t        vc.delegate = self;\n\t        [self presentViewController:vc animated:YES completion:nil];\n\t    } else {\n\t        // Fallback on earlier versions\n\t    }\n\t}\n\t```\n\n4. 同个地方实现代理方法\n\n\t```\n\t#pragma mark - INUIAddVoiceShortcutViewControllerDelegate\n\t- (void)addVoiceShortcutViewControllerDidCancel:(INUIAddVoiceShortcutViewController *)controller  API_AVAILABLE(ios(12.0)){\n\t\t[controller dismissViewControllerAnimated:YES completion:nil];\n\t}\n\t- (void)addVoiceShortcutViewController:(INUIAddVoiceShortcutViewController *)controller didFinishWithVoiceShortcut:(INVoiceShortcut *)voiceShortcut error:(NSError *)error  API_AVAILABLE(ios(12.0)){\n\t\t[controller dismissViewControllerAnimated:YES completion:nil];\n\t}\n\t```\n\n5. 进入`Intent` target中的`IntentHandler`类，导入`步骤8`生成的头文件，要是头文件找不到，在这个target的`info.plist`中`NSExtension`下的`IntentsSupported`下添加一个名为那个头文件的值，主target的`info.plist`的`NSUserActivityTypes`下也加一个一样的\n\n6. `IntentHandler.m`遵循协议`XXXIntentHandling`（具体协议名看你的类名），实现两个方法\n\n\t```\n\t\t// 用户说了那句话之后要Siri做什么事情\n\t- (void)handleZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion {\n\t\tcompletion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);\n\t}\n\t  // 用户确认了之后要Siri做什么事情\n\t- (void)confirmZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion {\n\t\tcompletion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);\n\t}\n\t```\n\n\t  `ZeRiIntentResponseCodeContinueInApp`只是枚举中其中一个值，使用不同的值会有不同     效果，自己探索一下，这里的值指的是打开app(具体方法名看协议)\n\n7. 进入`AppDelegate`，实现方法如下，根据`Intent`类名判断用户想要的操作\n\n\t```\n\t- (BOOL)application:(UIApplication *)application continueUserActivity:(nonnull NSUserActivity *)userActivity restorationHandler:(nonnull void (^)(NSArray<id<UIUserActivityRestoring>> * _Nullable))restorationHandler {\n\tif ([userActivity.activityType isEqualToString:@\"XXXIntent\"]) {\n\t}\n    return YES;\n}\n```\n8. 结束","source":"_posts/iOS12-新玩具ShortCut-捷径-使用.md","raw":"abbrlink: '0'\ntags:\n  - iOS\ncategories:\n  - iOS\nauthor: Arclin\ntitle: iOS12 新玩具ShortCut(捷径)使用\ndate: 2018-09-28 13:05:00\n---\n\n### 介绍\n\n升级iOS12之后可以在`设置-Siri`与搜索 中发现一个 `捷径` 功能, 所谓ShortCut就是其英文翻译\n其作用就是让用户自定义一个一句话或者短语, 然后可以触发app做一系列动作\n\n<!-- more -->\n\n### 接入\n\nShortCut分为两种, 一种是在手机的`Spotlight`上搜索某个关键字的时候可以搜索到你的app, 这个关键字就是ShortCut的一种(文字输入), 你需要使用`NSUserActivity`去实现这个功能\n> 依赖 `CoreSpotlight` `CoreServices`\n\n另外一种叫做 `Intent`(语音输入), 需要添加一个IntentExtension和IntentExtensionUI, 然后在主Target添加一个intentdefinition文件, 详细的配置大家可以参考\n[文章1](https://juejin.im/post/5b2077d8f265da6e45549c68)\n[文章2](http://www.cnblogs.com/czjie2010/p/czjie.html)\n\n> 依赖`Intents` `IntentsUI`\n\n\n### 最简单的配置操作步骤\n\n1. 项目的`Capabilities`打开`Siri`\n2. 授权\n\t```\n\tif (@available(iOS 10.0, *)) {\n\t\t[INPreferences requestSiriAuthorization:^(INSiriAuthorizationStatus status) {\n\t\t\tswitch (status) {\n\t\t\t\tcase INSiriAuthorizationStatusNotDetermined:\n\t\t\t\t\tNSLog(@\"用户尚未对该应用程序作出选择。\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase INSiriAuthorizationStatusRestricted:\n\t\t\t\t\tNSLog(@\"此应用程序无权使用Siri服务\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase INSiriAuthorizationStatusDenied:\n\t\t\t\t\tNSLog(@\"用户已明确拒绝此应用程序的授权\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase INSiriAuthorizationStatusAuthorized:\n\t\t\t\t\tNSLog(@\"用户可以使用此应用程序的授权\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}];\n\t}\n\t```\n\t- 新建一个`intentdefinition`，比如`A.intentdefinition`\n\t- 新建一个`Target`,`Intent Extension`有需要的话把`Intent UI Extension`也加上，`General`中配置相关证书\n\t- 进入`A.intentdefinition`，界面左下角`+`号点一下，点击`new intent`\n\t- 界面右边`Target Membership`，把`步骤2`中新增的`Target`给勾上\n\t-  界面中间`Title`填写需要展示的标题，`Descripion` 写描述\n\t- Build一下，系统自动生成头文件，头文件名字在界面右测的导航页的第三个按钮的`Custom Class`里\n\t- 找个控制器，导入`步骤8`生成的头文件，添加个按钮，比如\n\n\t```\n\tself.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@\"捷径\" style:UIBarButtonItemStylePlain target:self action:@selector(siri:)];\n\t```\n\n3. 点击按钮召唤添加Shortcut的控制器\n\n\t```\n\t- (void)siri:(UIBarButtonItem *)item {\n\t    if (@available(iOS 12.0, *)) {\n\t    \t // 这个类名具体看你生成了叫什么名字的头文件\n\t        ZeRiIntent *intent = [[ZeRiIntent alloc] init];\n\t        intent.suggestedInvocationPhrase = @\"打开xxx\"; // 引导用户说的语句\n\t        INShortcut *shortCur = [[INShortcut alloc] initWithIntent:intent];\n\t        INUIAddVoiceShortcutViewController *vc = [[INUIAddVoiceShortcutViewController alloc] initWithShortcut:shortCur];\n\t        vc.delegate = self;\n\t        [self presentViewController:vc animated:YES completion:nil];\n\t    } else {\n\t        // Fallback on earlier versions\n\t    }\n\t}\n\t```\n\n4. 同个地方实现代理方法\n\n\t```\n\t#pragma mark - INUIAddVoiceShortcutViewControllerDelegate\n\t- (void)addVoiceShortcutViewControllerDidCancel:(INUIAddVoiceShortcutViewController *)controller  API_AVAILABLE(ios(12.0)){\n\t\t[controller dismissViewControllerAnimated:YES completion:nil];\n\t}\n\t- (void)addVoiceShortcutViewController:(INUIAddVoiceShortcutViewController *)controller didFinishWithVoiceShortcut:(INVoiceShortcut *)voiceShortcut error:(NSError *)error  API_AVAILABLE(ios(12.0)){\n\t\t[controller dismissViewControllerAnimated:YES completion:nil];\n\t}\n\t```\n\n5. 进入`Intent` target中的`IntentHandler`类，导入`步骤8`生成的头文件，要是头文件找不到，在这个target的`info.plist`中`NSExtension`下的`IntentsSupported`下添加一个名为那个头文件的值，主target的`info.plist`的`NSUserActivityTypes`下也加一个一样的\n\n6. `IntentHandler.m`遵循协议`XXXIntentHandling`（具体协议名看你的类名），实现两个方法\n\n\t```\n\t\t// 用户说了那句话之后要Siri做什么事情\n\t- (void)handleZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion {\n\t\tcompletion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);\n\t}\n\t  // 用户确认了之后要Siri做什么事情\n\t- (void)confirmZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion {\n\t\tcompletion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);\n\t}\n\t```\n\n\t  `ZeRiIntentResponseCodeContinueInApp`只是枚举中其中一个值，使用不同的值会有不同     效果，自己探索一下，这里的值指的是打开app(具体方法名看协议)\n\n7. 进入`AppDelegate`，实现方法如下，根据`Intent`类名判断用户想要的操作\n\n\t```\n\t- (BOOL)application:(UIApplication *)application continueUserActivity:(nonnull NSUserActivity *)userActivity restorationHandler:(nonnull void (^)(NSArray<id<UIUserActivityRestoring>> * _Nullable))restorationHandler {\n\tif ([userActivity.activityType isEqualToString:@\"XXXIntent\"]) {\n\t}\n    return YES;\n}\n```\n8. 结束","slug":"iOS12-新玩具ShortCut-捷径-使用","published":1,"updated":"2021-06-06T18:52:24.963Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohw0044tnn00bv39b3e","content":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>升级iOS12之后可以在<code>设置-Siri</code>与搜索 中发现一个 <code>捷径</code> 功能, 所谓ShortCut就是其英文翻译<br>其作用就是让用户自定义一个一句话或者短语, 然后可以触发app做一系列动作</p>\n<span id=\"more\"></span>\n\n<h3 id=\"接入\"><a href=\"#接入\" class=\"headerlink\" title=\"接入\"></a>接入</h3><p>ShortCut分为两种, 一种是在手机的<code>Spotlight</code>上搜索某个关键字的时候可以搜索到你的app, 这个关键字就是ShortCut的一种(文字输入), 你需要使用<code>NSUserActivity</code>去实现这个功能</p>\n<blockquote>\n<p>依赖 <code>CoreSpotlight</code> <code>CoreServices</code></p>\n</blockquote>\n<p>另外一种叫做 <code>Intent</code>(语音输入), 需要添加一个IntentExtension和IntentExtensionUI, 然后在主Target添加一个intentdefinition文件, 详细的配置大家可以参考<br><a href=\"https://juejin.im/post/5b2077d8f265da6e45549c68\">文章1</a><br><a href=\"http://www.cnblogs.com/czjie2010/p/czjie.html\">文章2</a></p>\n<blockquote>\n<p>依赖<code>Intents</code> <code>IntentsUI</code></p>\n</blockquote>\n<h3 id=\"最简单的配置操作步骤\"><a href=\"#最简单的配置操作步骤\" class=\"headerlink\" title=\"最简单的配置操作步骤\"></a>最简单的配置操作步骤</h3><ol>\n<li><p>项目的<code>Capabilities</code>打开<code>Siri</code></p>\n</li>\n<li><p>授权</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (@available(iOS 10.0, *)) &#123;</span><br><span class=\"line\">\t[INPreferences requestSiriAuthorization:^(INSiriAuthorizationStatus status) &#123;</span><br><span class=\"line\">\t\tswitch (status) &#123;</span><br><span class=\"line\">\t\t\tcase INSiriAuthorizationStatusNotDetermined:</span><br><span class=\"line\">\t\t\t\tNSLog(@&quot;用户尚未对该应用程序作出选择。&quot;);</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tcase INSiriAuthorizationStatusRestricted:</span><br><span class=\"line\">\t\t\t\tNSLog(@&quot;此应用程序无权使用Siri服务&quot;);</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tcase INSiriAuthorizationStatusDenied:</span><br><span class=\"line\">\t\t\t\tNSLog(@&quot;用户已明确拒绝此应用程序的授权&quot;);</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tcase INSiriAuthorizationStatusAuthorized:</span><br><span class=\"line\">\t\t\t\tNSLog(@&quot;用户可以使用此应用程序的授权&quot;);</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tdefault:</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>新建一个<code>intentdefinition</code>，比如<code>A.intentdefinition</code></li>\n<li>新建一个<code>Target</code>,<code>Intent Extension</code>有需要的话把<code>Intent UI Extension</code>也加上，<code>General</code>中配置相关证书</li>\n<li>进入<code>A.intentdefinition</code>，界面左下角<code>+</code>号点一下，点击<code>new intent</code></li>\n<li>界面右边<code>Target Membership</code>，把<code>步骤2</code>中新增的<code>Target</code>给勾上</li>\n<li> 界面中间<code>Title</code>填写需要展示的标题，<code>Descripion</code> 写描述</li>\n<li>Build一下，系统自动生成头文件，头文件名字在界面右测的导航页的第三个按钮的<code>Custom Class</code>里</li>\n<li>找个控制器，导入<code>步骤8</code>生成的头文件，添加个按钮，比如</li>\n</ul>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.navigationItem.rightBarButtonItem &#x3D; [[UIBarButtonItem alloc] initWithTitle:@&quot;捷径&quot; style:UIBarButtonItemStylePlain target:self action:@selector(siri:)];</span><br></pre></td></tr></table></figure></li>\n<li><p>点击按钮召唤添加Shortcut的控制器</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)siri:(UIBarButtonItem *)item &#123;</span><br><span class=\"line\">    if (@available(iOS 12.0, *)) &#123;</span><br><span class=\"line\">    \t &#x2F;&#x2F; 这个类名具体看你生成了叫什么名字的头文件</span><br><span class=\"line\">        ZeRiIntent *intent &#x3D; [[ZeRiIntent alloc] init];</span><br><span class=\"line\">        intent.suggestedInvocationPhrase &#x3D; @&quot;打开xxx&quot;; &#x2F;&#x2F; 引导用户说的语句</span><br><span class=\"line\">        INShortcut *shortCur &#x3D; [[INShortcut alloc] initWithIntent:intent];</span><br><span class=\"line\">        INUIAddVoiceShortcutViewController *vc &#x3D; [[INUIAddVoiceShortcutViewController alloc] initWithShortcut:shortCur];</span><br><span class=\"line\">        vc.delegate &#x3D; self;</span><br><span class=\"line\">        [self presentViewController:vc animated:YES completion:nil];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; Fallback on earlier versions</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>同个地方实现代理方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - INUIAddVoiceShortcutViewControllerDelegate</span><br><span class=\"line\">- (void)addVoiceShortcutViewControllerDidCancel:(INUIAddVoiceShortcutViewController *)controller  API_AVAILABLE(ios(12.0))&#123;</span><br><span class=\"line\">\t[controller dismissViewControllerAnimated:YES completion:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)addVoiceShortcutViewController:(INUIAddVoiceShortcutViewController *)controller didFinishWithVoiceShortcut:(INVoiceShortcut *)voiceShortcut error:(NSError *)error  API_AVAILABLE(ios(12.0))&#123;</span><br><span class=\"line\">\t[controller dismissViewControllerAnimated:YES completion:nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>进入<code>Intent</code> target中的<code>IntentHandler</code>类，导入<code>步骤8</code>生成的头文件，要是头文件找不到，在这个target的<code>info.plist</code>中<code>NSExtension</code>下的<code>IntentsSupported</code>下添加一个名为那个头文件的值，主target的<code>info.plist</code>的<code>NSUserActivityTypes</code>下也加一个一样的</p>\n</li>\n<li><p><code>IntentHandler.m</code>遵循协议<code>XXXIntentHandling</code>（具体协议名看你的类名），实现两个方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#x2F;&#x2F; 用户说了那句话之后要Siri做什么事情</span><br><span class=\"line\">- (void)handleZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion &#123;</span><br><span class=\"line\">\tcompletion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  &#x2F;&#x2F; 用户确认了之后要Siri做什么事情</span><br><span class=\"line\">- (void)confirmZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion &#123;</span><br><span class=\"line\">\tcompletion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>   <code>ZeRiIntentResponseCodeContinueInApp</code>只是枚举中其中一个值，使用不同的值会有不同     效果，自己探索一下，这里的值指的是打开app(具体方法名看协议)</p>\n</li>\n<li><p>进入<code>AppDelegate</code>，实现方法如下，根据<code>Intent</code>类名判断用户想要的操作</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t- (BOOL)application:(UIApplication *)application continueUserActivity:(nonnull NSUserActivity *)userActivity restorationHandler:(nonnull void (^)(NSArray&lt;id&lt;UIUserActivityRestoring&gt;&gt; * _Nullable))restorationHandler &#123;</span><br><span class=\"line\">\tif ([userActivity.activityType isEqualToString:@&quot;XXXIntent&quot;]) &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>结束</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>升级iOS12之后可以在<code>设置-Siri</code>与搜索 中发现一个 <code>捷径</code> 功能, 所谓ShortCut就是其英文翻译<br>其作用就是让用户自定义一个一句话或者短语, 然后可以触发app做一系列动作</p>","more":"<h3 id=\"接入\"><a href=\"#接入\" class=\"headerlink\" title=\"接入\"></a>接入</h3><p>ShortCut分为两种, 一种是在手机的<code>Spotlight</code>上搜索某个关键字的时候可以搜索到你的app, 这个关键字就是ShortCut的一种(文字输入), 你需要使用<code>NSUserActivity</code>去实现这个功能</p>\n<blockquote>\n<p>依赖 <code>CoreSpotlight</code> <code>CoreServices</code></p>\n</blockquote>\n<p>另外一种叫做 <code>Intent</code>(语音输入), 需要添加一个IntentExtension和IntentExtensionUI, 然后在主Target添加一个intentdefinition文件, 详细的配置大家可以参考<br><a href=\"https://juejin.im/post/5b2077d8f265da6e45549c68\">文章1</a><br><a href=\"http://www.cnblogs.com/czjie2010/p/czjie.html\">文章2</a></p>\n<blockquote>\n<p>依赖<code>Intents</code> <code>IntentsUI</code></p>\n</blockquote>\n<h3 id=\"最简单的配置操作步骤\"><a href=\"#最简单的配置操作步骤\" class=\"headerlink\" title=\"最简单的配置操作步骤\"></a>最简单的配置操作步骤</h3><ol>\n<li><p>项目的<code>Capabilities</code>打开<code>Siri</code></p>\n</li>\n<li><p>授权</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (@available(iOS 10.0, *)) &#123;</span><br><span class=\"line\">\t[INPreferences requestSiriAuthorization:^(INSiriAuthorizationStatus status) &#123;</span><br><span class=\"line\">\t\tswitch (status) &#123;</span><br><span class=\"line\">\t\t\tcase INSiriAuthorizationStatusNotDetermined:</span><br><span class=\"line\">\t\t\t\tNSLog(@&quot;用户尚未对该应用程序作出选择。&quot;);</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tcase INSiriAuthorizationStatusRestricted:</span><br><span class=\"line\">\t\t\t\tNSLog(@&quot;此应用程序无权使用Siri服务&quot;);</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tcase INSiriAuthorizationStatusDenied:</span><br><span class=\"line\">\t\t\t\tNSLog(@&quot;用户已明确拒绝此应用程序的授权&quot;);</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tcase INSiriAuthorizationStatusAuthorized:</span><br><span class=\"line\">\t\t\t\tNSLog(@&quot;用户可以使用此应用程序的授权&quot;);</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tdefault:</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>新建一个<code>intentdefinition</code>，比如<code>A.intentdefinition</code></li>\n<li>新建一个<code>Target</code>,<code>Intent Extension</code>有需要的话把<code>Intent UI Extension</code>也加上，<code>General</code>中配置相关证书</li>\n<li>进入<code>A.intentdefinition</code>，界面左下角<code>+</code>号点一下，点击<code>new intent</code></li>\n<li>界面右边<code>Target Membership</code>，把<code>步骤2</code>中新增的<code>Target</code>给勾上</li>\n<li> 界面中间<code>Title</code>填写需要展示的标题，<code>Descripion</code> 写描述</li>\n<li>Build一下，系统自动生成头文件，头文件名字在界面右测的导航页的第三个按钮的<code>Custom Class</code>里</li>\n<li>找个控制器，导入<code>步骤8</code>生成的头文件，添加个按钮，比如</li>\n</ul>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.navigationItem.rightBarButtonItem &#x3D; [[UIBarButtonItem alloc] initWithTitle:@&quot;捷径&quot; style:UIBarButtonItemStylePlain target:self action:@selector(siri:)];</span><br></pre></td></tr></table></figure></li>\n<li><p>点击按钮召唤添加Shortcut的控制器</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)siri:(UIBarButtonItem *)item &#123;</span><br><span class=\"line\">    if (@available(iOS 12.0, *)) &#123;</span><br><span class=\"line\">    \t &#x2F;&#x2F; 这个类名具体看你生成了叫什么名字的头文件</span><br><span class=\"line\">        ZeRiIntent *intent &#x3D; [[ZeRiIntent alloc] init];</span><br><span class=\"line\">        intent.suggestedInvocationPhrase &#x3D; @&quot;打开xxx&quot;; &#x2F;&#x2F; 引导用户说的语句</span><br><span class=\"line\">        INShortcut *shortCur &#x3D; [[INShortcut alloc] initWithIntent:intent];</span><br><span class=\"line\">        INUIAddVoiceShortcutViewController *vc &#x3D; [[INUIAddVoiceShortcutViewController alloc] initWithShortcut:shortCur];</span><br><span class=\"line\">        vc.delegate &#x3D; self;</span><br><span class=\"line\">        [self presentViewController:vc animated:YES completion:nil];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; Fallback on earlier versions</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>同个地方实现代理方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - INUIAddVoiceShortcutViewControllerDelegate</span><br><span class=\"line\">- (void)addVoiceShortcutViewControllerDidCancel:(INUIAddVoiceShortcutViewController *)controller  API_AVAILABLE(ios(12.0))&#123;</span><br><span class=\"line\">\t[controller dismissViewControllerAnimated:YES completion:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)addVoiceShortcutViewController:(INUIAddVoiceShortcutViewController *)controller didFinishWithVoiceShortcut:(INVoiceShortcut *)voiceShortcut error:(NSError *)error  API_AVAILABLE(ios(12.0))&#123;</span><br><span class=\"line\">\t[controller dismissViewControllerAnimated:YES completion:nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>进入<code>Intent</code> target中的<code>IntentHandler</code>类，导入<code>步骤8</code>生成的头文件，要是头文件找不到，在这个target的<code>info.plist</code>中<code>NSExtension</code>下的<code>IntentsSupported</code>下添加一个名为那个头文件的值，主target的<code>info.plist</code>的<code>NSUserActivityTypes</code>下也加一个一样的</p>\n</li>\n<li><p><code>IntentHandler.m</code>遵循协议<code>XXXIntentHandling</code>（具体协议名看你的类名），实现两个方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#x2F;&#x2F; 用户说了那句话之后要Siri做什么事情</span><br><span class=\"line\">- (void)handleZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion &#123;</span><br><span class=\"line\">\tcompletion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  &#x2F;&#x2F; 用户确认了之后要Siri做什么事情</span><br><span class=\"line\">- (void)confirmZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion &#123;</span><br><span class=\"line\">\tcompletion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>   <code>ZeRiIntentResponseCodeContinueInApp</code>只是枚举中其中一个值，使用不同的值会有不同     效果，自己探索一下，这里的值指的是打开app(具体方法名看协议)</p>\n</li>\n<li><p>进入<code>AppDelegate</code>，实现方法如下，根据<code>Intent</code>类名判断用户想要的操作</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t- (BOOL)application:(UIApplication *)application continueUserActivity:(nonnull NSUserActivity *)userActivity restorationHandler:(nonnull void (^)(NSArray&lt;id&lt;UIUserActivityRestoring&gt;&gt; * _Nullable))restorationHandler &#123;</span><br><span class=\"line\">\tif ([userActivity.activityType isEqualToString:@&quot;XXXIntent&quot;]) &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>结束</p>\n</li>\n</ol>"},{"title":"iOS动态加载字体","abbrlink":"f82939c6","date":"2021-03-17T02:42:42.000Z","_content":"当你某个在开发某个SDK时需要使用到特殊字体，因为无法修改应用的info.plist，所以这时候我们需要采用动态注册字体的方式加载字体，方法如下\n\n<!--more-->\n\n- OC\n\n\t方法调用\n\t\n\t```oc\n\t[UIFont fontWithName:<#(nonnull NSString *)#> size:<#(CGFloat)#>]\n\t```\n\n\t如果上述方法返回nil,则你需要注册你的字体\n\t```oc\n    NSBundle *bundle = [NSBundle bundleForClass:[self class]];\n    NSURL *fontURL = [bundle URLForResource:<#fontName#> withExtension:@\"otf\"/*or TTF*/];\n    NSData *inData = [NSData dataWithContentsOfURL:fontURL];\n    CFErrorRef error;\n    CGDataProviderRef provider = CGDataProviderCreateWithCFData((CFDataRef)inData);\n    CGFontRef font = CGFontCreateWithDataProvider(provider);\n    if (!CTFontManagerRegisterGraphicsFont(font, &error)) {\n    CFStringRef errorDescription = CFErrorCopyDescription(error);\n    NSLog(@\"Failed to load font: %@\", errorDescription);\n    CFRelease(errorDescription);\n    }\n    CFSafeRelease(font);\n    CFSafeRelease(provider);\n\t```\n\n\t```objective-c\n    void CFSafeRelease(CFTypeRef cf) {\n        if (cf != NULL) {\n            CFRelease(cf);\n        }\n    }\n\t```\n\t\n- Swift\n\n\t方法调用\n\t```swift\n\tUIFont.customFont(name:\"xxx\" size: 12)\n\t```\n\n\t```swift\n    extension UIFont {\n\t    static func customFont(fontName:String, size: CGFloat) -> UIFont {\n        if let font = UIFont(name: fontName, size: size) {\n            return font\n        } else {\n            _ = self.registerFont(bundle: Bundle.init(for: XXXX.self), fontName: fontName, fontExtension: \"otf\") // 也可以写ttf,看具体格式\n            if let newFont = UIFont(name: fontName, size: size) {\n                return newFont\n            }\n            return UIFont.customFont(ofSize: size)\n        }\n    }\n    \n    static func registerFont(bundle: Bundle, fontName: String, fontExtension: String) -> Bool {\n        guard let fontURL = bundle.url(forResource: fontName, withExtension: fontExtension) else {\n            fatalError(\"Couldn't find font \\(fontName)\")\n        }\n        \n        guard let fontDataProvider = CGDataProvider(url: fontURL as CFURL) else {\n            fatalError(\"Couldn't load data from the font \\(fontName)\")\n        }\n        \n        guard let font = CGFont(fontDataProvider) else {\n            fatalError(\"Couldn't create font from data\")\n        }\n        \n        var error: Unmanaged<CFError>?\n        let success = CTFontManagerRegisterGraphicsFont(font, &error)\n        guard success else {\n            print(\"Error registering font: maybe it was already registered.\")\n            return false\n        }\n        \n        return true\n    }\n\n\t```\n\t\n参考资料：\n\t[https://stackoverflow.com/questions/12919513/how-do-i-add-a-custom-font-to-a-cocoapod](https://stackoverflow.com/questions/12919513/how-do-i-add-a-custom-font-to-a-cocoapod)","source":"_posts/iOS动态加载字体.md","raw":"title: iOS动态加载字体\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: f82939c6\ndate: 2021-03-17 10:42:42\n---\n当你某个在开发某个SDK时需要使用到特殊字体，因为无法修改应用的info.plist，所以这时候我们需要采用动态注册字体的方式加载字体，方法如下\n\n<!--more-->\n\n- OC\n\n\t方法调用\n\t\n\t```oc\n\t[UIFont fontWithName:<#(nonnull NSString *)#> size:<#(CGFloat)#>]\n\t```\n\n\t如果上述方法返回nil,则你需要注册你的字体\n\t```oc\n    NSBundle *bundle = [NSBundle bundleForClass:[self class]];\n    NSURL *fontURL = [bundle URLForResource:<#fontName#> withExtension:@\"otf\"/*or TTF*/];\n    NSData *inData = [NSData dataWithContentsOfURL:fontURL];\n    CFErrorRef error;\n    CGDataProviderRef provider = CGDataProviderCreateWithCFData((CFDataRef)inData);\n    CGFontRef font = CGFontCreateWithDataProvider(provider);\n    if (!CTFontManagerRegisterGraphicsFont(font, &error)) {\n    CFStringRef errorDescription = CFErrorCopyDescription(error);\n    NSLog(@\"Failed to load font: %@\", errorDescription);\n    CFRelease(errorDescription);\n    }\n    CFSafeRelease(font);\n    CFSafeRelease(provider);\n\t```\n\n\t```objective-c\n    void CFSafeRelease(CFTypeRef cf) {\n        if (cf != NULL) {\n            CFRelease(cf);\n        }\n    }\n\t```\n\t\n- Swift\n\n\t方法调用\n\t```swift\n\tUIFont.customFont(name:\"xxx\" size: 12)\n\t```\n\n\t```swift\n    extension UIFont {\n\t    static func customFont(fontName:String, size: CGFloat) -> UIFont {\n        if let font = UIFont(name: fontName, size: size) {\n            return font\n        } else {\n            _ = self.registerFont(bundle: Bundle.init(for: XXXX.self), fontName: fontName, fontExtension: \"otf\") // 也可以写ttf,看具体格式\n            if let newFont = UIFont(name: fontName, size: size) {\n                return newFont\n            }\n            return UIFont.customFont(ofSize: size)\n        }\n    }\n    \n    static func registerFont(bundle: Bundle, fontName: String, fontExtension: String) -> Bool {\n        guard let fontURL = bundle.url(forResource: fontName, withExtension: fontExtension) else {\n            fatalError(\"Couldn't find font \\(fontName)\")\n        }\n        \n        guard let fontDataProvider = CGDataProvider(url: fontURL as CFURL) else {\n            fatalError(\"Couldn't load data from the font \\(fontName)\")\n        }\n        \n        guard let font = CGFont(fontDataProvider) else {\n            fatalError(\"Couldn't create font from data\")\n        }\n        \n        var error: Unmanaged<CFError>?\n        let success = CTFontManagerRegisterGraphicsFont(font, &error)\n        guard success else {\n            print(\"Error registering font: maybe it was already registered.\")\n            return false\n        }\n        \n        return true\n    }\n\n\t```\n\t\n参考资料：\n\t[https://stackoverflow.com/questions/12919513/how-do-i-add-a-custom-font-to-a-cocoapod](https://stackoverflow.com/questions/12919513/how-do-i-add-a-custom-font-to-a-cocoapod)","slug":"iOS动态加载字体","published":1,"updated":"2021-08-21T09:03:39.407Z","_id":"ckqqxyohw0047tnn0gakldndt","comments":1,"layout":"post","photos":[],"link":"","content":"<p>当你某个在开发某个SDK时需要使用到特殊字体，因为无法修改应用的info.plist，所以这时候我们需要采用动态注册字体的方式加载字体，方法如下</p>\n<span id=\"more\"></span>\n\n<ul>\n<li><p>OC</p>\n<p>  方法调用</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[UIFont fontWithName:&lt;#(nonnull NSString *)#&gt; size:&lt;#(CGFloat)#&gt;]</span><br></pre></td></tr></table></figure>\n\n<p>  如果上述方法返回nil,则你需要注册你的字体</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSBundle *bundle &#x3D; [NSBundle bundleForClass:[self class]];</span><br><span class=\"line\">NSURL *fontURL &#x3D; [bundle URLForResource:&lt;#fontName#&gt; withExtension:@&quot;otf&quot;&#x2F;*or TTF*&#x2F;];</span><br><span class=\"line\">NSData *inData &#x3D; [NSData dataWithContentsOfURL:fontURL];</span><br><span class=\"line\">CFErrorRef error;</span><br><span class=\"line\">CGDataProviderRef provider &#x3D; CGDataProviderCreateWithCFData((CFDataRef)inData);</span><br><span class=\"line\">CGFontRef font &#x3D; CGFontCreateWithDataProvider(provider);</span><br><span class=\"line\">if (!CTFontManagerRegisterGraphicsFont(font, &amp;error)) &#123;</span><br><span class=\"line\">CFStringRef errorDescription &#x3D; CFErrorCopyDescription(error);</span><br><span class=\"line\">NSLog(@&quot;Failed to load font: %@&quot;, errorDescription);</span><br><span class=\"line\">CFRelease(errorDescription);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">CFSafeRelease(font);</span><br><span class=\"line\">CFSafeRelease(provider);</span><br></pre></td></tr></table></figure>\n\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void CFSafeRelease(CFTypeRef cf) &#123;</span><br><span class=\"line\">    if (cf !&#x3D; NULL) &#123;</span><br><span class=\"line\">        CFRelease(cf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Swift</p>\n<p>  方法调用</p>\n  <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIFont</span>.customFont(name:<span class=\"string\">&quot;xxx&quot;</span> size: <span class=\"number\">12</span>)</span><br></pre></td></tr></table></figure>\n\n  <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIFont</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">customFont</span>(<span class=\"params\">fontName</span>:<span class=\"type\">String</span>, <span class=\"params\">size</span>: <span class=\"type\">CGFloat</span>)</span> -&gt; <span class=\"type\">UIFont</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> font <span class=\"operator\">=</span> <span class=\"type\">UIFont</span>(name: fontName, size: size) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> font</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">_</span> <span class=\"operator\">=</span> <span class=\"keyword\">self</span>.registerFont(bundle: <span class=\"type\">Bundle</span>.<span class=\"keyword\">init</span>(for: <span class=\"type\">XXXX</span>.<span class=\"keyword\">self</span>), fontName: fontName, fontExtension: <span class=\"string\">&quot;otf&quot;</span>) <span class=\"comment\">// 也可以写ttf,看具体格式</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> newFont <span class=\"operator\">=</span> <span class=\"type\">UIFont</span>(name: fontName, size: size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> newFont</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">UIFont</span>.customFont(ofSize: size)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">registerFont</span>(<span class=\"params\">bundle</span>: <span class=\"type\">Bundle</span>, <span class=\"params\">fontName</span>: <span class=\"type\">String</span>, <span class=\"params\">fontExtension</span>: <span class=\"type\">String</span>)</span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> fontURL <span class=\"operator\">=</span> bundle.url(forResource: fontName, withExtension: fontExtension) <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fatalError</span>(<span class=\"string\">&quot;Couldn&#x27;t find font <span class=\"subst\">\\(fontName)</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> fontDataProvider <span class=\"operator\">=</span> <span class=\"type\">CGDataProvider</span>(url: fontURL <span class=\"keyword\">as</span> <span class=\"type\">CFURL</span>) <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fatalError</span>(<span class=\"string\">&quot;Couldn&#x27;t load data from the font <span class=\"subst\">\\(fontName)</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> font <span class=\"operator\">=</span> <span class=\"type\">CGFont</span>(fontDataProvider) <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fatalError</span>(<span class=\"string\">&quot;Couldn&#x27;t create font from data&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> error: <span class=\"type\">Unmanaged</span>&lt;<span class=\"type\">CFError</span>&gt;?</span><br><span class=\"line\">    <span class=\"keyword\">let</span> success <span class=\"operator\">=</span> <span class=\"type\">CTFontManagerRegisterGraphicsFont</span>(font, <span class=\"operator\">&amp;</span>error)</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> success <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Error registering font: maybe it was already registered.&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>参考资料：<br>    <a href=\"https://stackoverflow.com/questions/12919513/how-do-i-add-a-custom-font-to-a-cocoapod\">https://stackoverflow.com/questions/12919513/how-do-i-add-a-custom-font-to-a-cocoapod</a></p>\n","site":{"data":{}},"excerpt":"<p>当你某个在开发某个SDK时需要使用到特殊字体，因为无法修改应用的info.plist，所以这时候我们需要采用动态注册字体的方式加载字体，方法如下</p>","more":"<ul>\n<li><p>OC</p>\n<p>  方法调用</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[UIFont fontWithName:&lt;#(nonnull NSString *)#&gt; size:&lt;#(CGFloat)#&gt;]</span><br></pre></td></tr></table></figure>\n\n<p>  如果上述方法返回nil,则你需要注册你的字体</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSBundle *bundle &#x3D; [NSBundle bundleForClass:[self class]];</span><br><span class=\"line\">NSURL *fontURL &#x3D; [bundle URLForResource:&lt;#fontName#&gt; withExtension:@&quot;otf&quot;&#x2F;*or TTF*&#x2F;];</span><br><span class=\"line\">NSData *inData &#x3D; [NSData dataWithContentsOfURL:fontURL];</span><br><span class=\"line\">CFErrorRef error;</span><br><span class=\"line\">CGDataProviderRef provider &#x3D; CGDataProviderCreateWithCFData((CFDataRef)inData);</span><br><span class=\"line\">CGFontRef font &#x3D; CGFontCreateWithDataProvider(provider);</span><br><span class=\"line\">if (!CTFontManagerRegisterGraphicsFont(font, &amp;error)) &#123;</span><br><span class=\"line\">CFStringRef errorDescription &#x3D; CFErrorCopyDescription(error);</span><br><span class=\"line\">NSLog(@&quot;Failed to load font: %@&quot;, errorDescription);</span><br><span class=\"line\">CFRelease(errorDescription);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">CFSafeRelease(font);</span><br><span class=\"line\">CFSafeRelease(provider);</span><br></pre></td></tr></table></figure>\n\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void CFSafeRelease(CFTypeRef cf) &#123;</span><br><span class=\"line\">    if (cf !&#x3D; NULL) &#123;</span><br><span class=\"line\">        CFRelease(cf);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Swift</p>\n<p>  方法调用</p>\n  <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">UIFont</span>.customFont(name:<span class=\"string\">&quot;xxx&quot;</span> size: <span class=\"number\">12</span>)</span><br></pre></td></tr></table></figure>\n\n  <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIFont</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">customFont</span>(<span class=\"params\">fontName</span>:<span class=\"type\">String</span>, <span class=\"params\">size</span>: <span class=\"type\">CGFloat</span>)</span> -&gt; <span class=\"type\">UIFont</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> font <span class=\"operator\">=</span> <span class=\"type\">UIFont</span>(name: fontName, size: size) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> font</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">_</span> <span class=\"operator\">=</span> <span class=\"keyword\">self</span>.registerFont(bundle: <span class=\"type\">Bundle</span>.<span class=\"keyword\">init</span>(for: <span class=\"type\">XXXX</span>.<span class=\"keyword\">self</span>), fontName: fontName, fontExtension: <span class=\"string\">&quot;otf&quot;</span>) <span class=\"comment\">// 也可以写ttf,看具体格式</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> newFont <span class=\"operator\">=</span> <span class=\"type\">UIFont</span>(name: fontName, size: size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> newFont</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">UIFont</span>.customFont(ofSize: size)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">registerFont</span>(<span class=\"params\">bundle</span>: <span class=\"type\">Bundle</span>, <span class=\"params\">fontName</span>: <span class=\"type\">String</span>, <span class=\"params\">fontExtension</span>: <span class=\"type\">String</span>)</span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> fontURL <span class=\"operator\">=</span> bundle.url(forResource: fontName, withExtension: fontExtension) <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fatalError</span>(<span class=\"string\">&quot;Couldn&#x27;t find font <span class=\"subst\">\\(fontName)</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> fontDataProvider <span class=\"operator\">=</span> <span class=\"type\">CGDataProvider</span>(url: fontURL <span class=\"keyword\">as</span> <span class=\"type\">CFURL</span>) <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fatalError</span>(<span class=\"string\">&quot;Couldn&#x27;t load data from the font <span class=\"subst\">\\(fontName)</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> font <span class=\"operator\">=</span> <span class=\"type\">CGFont</span>(fontDataProvider) <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fatalError</span>(<span class=\"string\">&quot;Couldn&#x27;t create font from data&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> error: <span class=\"type\">Unmanaged</span>&lt;<span class=\"type\">CFError</span>&gt;?</span><br><span class=\"line\">    <span class=\"keyword\">let</span> success <span class=\"operator\">=</span> <span class=\"type\">CTFontManagerRegisterGraphicsFont</span>(font, <span class=\"operator\">&amp;</span>error)</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> success <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Error registering font: maybe it was already registered.&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>参考资料：<br>    <a href=\"https://stackoverflow.com/questions/12919513/how-do-i-add-a-custom-font-to-a-cocoapod\">https://stackoverflow.com/questions/12919513/how-do-i-add-a-custom-font-to-a-cocoapod</a></p>"},{"title":"iOS 14新API","abbrlink":"36f1cd4f","date":"2020-06-29T03:08:18.000Z","_content":"\niOS 14 新API\n\n<!-- more -->\n\n### Control Appearance update\n\n控件外观更新，比如UISlider、 UIProgressView、UIActivityIndicatorView，长得稍微有点不一样，不影响适配。\n\n![](https://s1.ax1x.com/2020/06/29/NfJ6zt.png)\n\nUIPageControl样式改变并且可以自定义icon\n\n![](https://s1.ax1x.com/2020/06/29/NfYs7F.png)\n\n自定义小心心icon和书签icon\n\n![](https://s1.ax1x.com/2020/06/29/NfYO1I.png)\n\n\n### Color Picker\n\n新增颜色选择器`UIColorPickerViewController`\n\n支持取色器 收藏常用颜色等等\n\n可以配置是否支持调整透明度等等，具体配置项目参考api文档\n\n建议Present弹出\n\n<a href=\"https://sm.ms/image/iz1WnGFImlUvkty\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/iz1WnGFImlUvkty.png\" width=50% ></a>\n\n### Date Picker\n\nUIDatePicker更新UI\n\n两种样式\n\n支持农历\n\n<a href=\"https://sm.ms/image/wMmTIykghRNqWQn\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/wMmTIykghRNqWQn.png\" width=50% ></a>\n\n<a href=\"https://sm.ms/image/uF3WonxPAsDyXaO\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/uF3WonxPAsDyXaO.png\" width=50% ></a>\n\n### Menus \n\n貌似可以替代我们常有的角标弹窗列表按钮需求\n\n基于`UIButton`和`UIBarButtonItem`的新增的`menu`属性，可以配置长按或者单击(配置 `button.showsMenuAsPrimaryAction = true`)弹出菜单列表\n\n<a href=\"https://sm.ms/image/L1XmoD2d7EKj49Y\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/L1XmoD2d7EKj49Y.png\" width=50% ></a>\n\n<a href=\"https://sm.ms/image/ZflMaksQFDuKp3T\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/ZflMaksQFDuKp3T.png\" width=50% ></a>\n\n\nUINavigationBar 的原生返回按钮长按会弹出菜单，可以跳回导航栏栈中的任意一个页面，按钮标题为前面控制器的标题\n\n\n<a href=\"https://sm.ms/image/FVdgXvpGeTBfYKZ\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/FVdgXvpGeTBfYKZ.png\" width=50% ></a>\n\n\n更新弹出菜单内容，将会实时更新并自带系统动画：\n\n`updateVisibleMenu(_ block: (UIMenu) -> UIMenu)`\n\n### UIActions\n\nUIBarButtonItem 新增 fixedSpace(width:) 和 flexibleSpace方法 去调节item之间的间隔，不用像之前那样子创建一个fixedSpace类型的UIBarButtonItem去占位\n\nUIButton新增了一个初始化方法init(type:primaryAction:) type默认为.system 标题为primaryAction.title ，图片为 primaryAction.image\n\n\n### WidgetKit \n\niOS14 重大新特性之一 支持三种宽度的widget，具体内容另外开篇再讲\n<a href=\"https://sm.ms/image/eiXyvjhfgAqQURr\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/eiXyvjhfgAqQURr.png\" width=50% ></a>\n\n\n### 让你的app支持物理键盘\n\n[具体内容查看文档](https://developer.apple.com/documentation/uikit/keyboards_and_input/adding_hardware_keyboard_support_to_your_app)\n\n### Asynchronously Loading Images into Table and Collection Views\n\n[文档](https://developer.apple.com/documentation/uikit/uiimage/asynchronously_loading_images_into_table_and_collection_views)\n\ntableView和CollectionView异步加载网络图片的API\n\n### PHPicker 图片选择器\n\n新的图片选择器，支持多选，不需要用户允许相册访问权限，可以选择图片（包括livePhoto）和视频\n\n<a href=\"https://sm.ms/image/R9fc3SZIlpLhuwB\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/R9fc3SZIlpLhuwB.png\" width=50% ></a>\n\n### 定位权限更新\n\n旧的定位权限弹窗如下：\n\n<a href=\"https://sm.ms/image/kSgBdY3hjRWG21E\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/kSgBdY3hjRWG21E.png\" width=50% ></a>\n\n新的定位权限弹窗如下：\n\n<a href=\"https://sm.ms/image/svo9OnAS1BZdLDP\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/svo9OnAS1BZdLDP.png\" width=50% ></a>\n\n多了个小地图，并且小地图的左上角多了个按钮，点击选择是否允许准确定位。\n\n若不允许的话，开发者获取的定位会变成一个±5公里的范围，并且只能持续定位最多20分钟\n\n通过一个枚举值得知是否用户选择了模糊定位：\n\n<a href=\"https://sm.ms/image/9gh6mbKL7VWe3uH\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/9gh6mbKL7VWe3uH.png\" ></a>\n\n用户可以改变设置，是否允许app获取准确定位\n\n<a href=\"https://sm.ms/image/jsQr4xoevXNa2Ju\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/jsQr4xoevXNa2Ju.png\" ></a>\n\n开发者可以通过在`info.plist`里面配置信息解释为何需要用户选择准确定位\n\n<a href=\"https://sm.ms/image/X5CRUopcnOHG3I2\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/X5CRUopcnOHG3I2.png\" ></a>\n\n让隐私弹窗默认选择模糊定位\n\n<a href=\"https://sm.ms/image/UeLtJhGXOvbKmns\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/UeLtJhGXOvbKmns.png\" width=50%></a>\n\n### UICollectionView重大更新\n\nUICollection从数据源协议到Cell都有了新的API，开发者可以为cell添加各种“附件”，已适配复杂的列表样式，如下第二张图，另外可以在collectionView上使用类似tableView的样式，如下图\n\n<a href=\"https://sm.ms/image/Iaho8TuHE1P4iRx\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/Iaho8TuHE1P4iRx.png\" ></a>\n\n<a href=\"https://sm.ms/image/taEDOVHfAk2LnQe\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/taEDOVHfAk2LnQe.png\"  width=50% ></a>\n\n通过新的配置类，可以做成如下效果\n\n<a href=\"https://sm.ms/image/nlrR8VBkzqy2SdP\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/nlrR8VBkzqy2SdP.png\"  width=50% ></a>\n\n<a href=\"https://sm.ms/image/PhtUgJrCR2OTQwY\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/PhtUgJrCR2OTQwY.png\"  width=50% ></a>\n\n新增一个UICollectionListViewCell，可以做出如下样式的cell\n\n<a href=\"https://sm.ms/image/jlZKFpCybNJPoET\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/jlZKFpCybNJPoET.png\" width=50%  ></a>\n\nCell的注册方式也有所改变，可以看出苹果从API层面已经进入MVVM架构模式了，注册cell需要带上对应的CellViewModel\n\n<a href=\"https://sm.ms/image/2awdL6yOmUzIGrZ\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/2awdL6yOmUzIGrZ.jpg\" width=50% ></a>\n\n另外也支持像UITableViewCell的侧滑操作等等，详细内容将会另外开篇讲述。\n\n具体查看[视频](https://developer.apple.com/videos/play/wwdc2020/10097/)","source":"_posts/iOS14新API.md","raw":"---\ntitle: iOS 14新API\nabbrlink: 36f1cd4f\ndate: 2020-06-29 11:08:18\ntags:\n  - iOS\n  - feature\ncategories:\n  - iOS\n---\n\niOS 14 新API\n\n<!-- more -->\n\n### Control Appearance update\n\n控件外观更新，比如UISlider、 UIProgressView、UIActivityIndicatorView，长得稍微有点不一样，不影响适配。\n\n![](https://s1.ax1x.com/2020/06/29/NfJ6zt.png)\n\nUIPageControl样式改变并且可以自定义icon\n\n![](https://s1.ax1x.com/2020/06/29/NfYs7F.png)\n\n自定义小心心icon和书签icon\n\n![](https://s1.ax1x.com/2020/06/29/NfYO1I.png)\n\n\n### Color Picker\n\n新增颜色选择器`UIColorPickerViewController`\n\n支持取色器 收藏常用颜色等等\n\n可以配置是否支持调整透明度等等，具体配置项目参考api文档\n\n建议Present弹出\n\n<a href=\"https://sm.ms/image/iz1WnGFImlUvkty\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/iz1WnGFImlUvkty.png\" width=50% ></a>\n\n### Date Picker\n\nUIDatePicker更新UI\n\n两种样式\n\n支持农历\n\n<a href=\"https://sm.ms/image/wMmTIykghRNqWQn\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/wMmTIykghRNqWQn.png\" width=50% ></a>\n\n<a href=\"https://sm.ms/image/uF3WonxPAsDyXaO\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/uF3WonxPAsDyXaO.png\" width=50% ></a>\n\n### Menus \n\n貌似可以替代我们常有的角标弹窗列表按钮需求\n\n基于`UIButton`和`UIBarButtonItem`的新增的`menu`属性，可以配置长按或者单击(配置 `button.showsMenuAsPrimaryAction = true`)弹出菜单列表\n\n<a href=\"https://sm.ms/image/L1XmoD2d7EKj49Y\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/L1XmoD2d7EKj49Y.png\" width=50% ></a>\n\n<a href=\"https://sm.ms/image/ZflMaksQFDuKp3T\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/ZflMaksQFDuKp3T.png\" width=50% ></a>\n\n\nUINavigationBar 的原生返回按钮长按会弹出菜单，可以跳回导航栏栈中的任意一个页面，按钮标题为前面控制器的标题\n\n\n<a href=\"https://sm.ms/image/FVdgXvpGeTBfYKZ\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/FVdgXvpGeTBfYKZ.png\" width=50% ></a>\n\n\n更新弹出菜单内容，将会实时更新并自带系统动画：\n\n`updateVisibleMenu(_ block: (UIMenu) -> UIMenu)`\n\n### UIActions\n\nUIBarButtonItem 新增 fixedSpace(width:) 和 flexibleSpace方法 去调节item之间的间隔，不用像之前那样子创建一个fixedSpace类型的UIBarButtonItem去占位\n\nUIButton新增了一个初始化方法init(type:primaryAction:) type默认为.system 标题为primaryAction.title ，图片为 primaryAction.image\n\n\n### WidgetKit \n\niOS14 重大新特性之一 支持三种宽度的widget，具体内容另外开篇再讲\n<a href=\"https://sm.ms/image/eiXyvjhfgAqQURr\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/eiXyvjhfgAqQURr.png\" width=50% ></a>\n\n\n### 让你的app支持物理键盘\n\n[具体内容查看文档](https://developer.apple.com/documentation/uikit/keyboards_and_input/adding_hardware_keyboard_support_to_your_app)\n\n### Asynchronously Loading Images into Table and Collection Views\n\n[文档](https://developer.apple.com/documentation/uikit/uiimage/asynchronously_loading_images_into_table_and_collection_views)\n\ntableView和CollectionView异步加载网络图片的API\n\n### PHPicker 图片选择器\n\n新的图片选择器，支持多选，不需要用户允许相册访问权限，可以选择图片（包括livePhoto）和视频\n\n<a href=\"https://sm.ms/image/R9fc3SZIlpLhuwB\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/R9fc3SZIlpLhuwB.png\" width=50% ></a>\n\n### 定位权限更新\n\n旧的定位权限弹窗如下：\n\n<a href=\"https://sm.ms/image/kSgBdY3hjRWG21E\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/kSgBdY3hjRWG21E.png\" width=50% ></a>\n\n新的定位权限弹窗如下：\n\n<a href=\"https://sm.ms/image/svo9OnAS1BZdLDP\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/svo9OnAS1BZdLDP.png\" width=50% ></a>\n\n多了个小地图，并且小地图的左上角多了个按钮，点击选择是否允许准确定位。\n\n若不允许的话，开发者获取的定位会变成一个±5公里的范围，并且只能持续定位最多20分钟\n\n通过一个枚举值得知是否用户选择了模糊定位：\n\n<a href=\"https://sm.ms/image/9gh6mbKL7VWe3uH\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/9gh6mbKL7VWe3uH.png\" ></a>\n\n用户可以改变设置，是否允许app获取准确定位\n\n<a href=\"https://sm.ms/image/jsQr4xoevXNa2Ju\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/jsQr4xoevXNa2Ju.png\" ></a>\n\n开发者可以通过在`info.plist`里面配置信息解释为何需要用户选择准确定位\n\n<a href=\"https://sm.ms/image/X5CRUopcnOHG3I2\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/X5CRUopcnOHG3I2.png\" ></a>\n\n让隐私弹窗默认选择模糊定位\n\n<a href=\"https://sm.ms/image/UeLtJhGXOvbKmns\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/UeLtJhGXOvbKmns.png\" width=50%></a>\n\n### UICollectionView重大更新\n\nUICollection从数据源协议到Cell都有了新的API，开发者可以为cell添加各种“附件”，已适配复杂的列表样式，如下第二张图，另外可以在collectionView上使用类似tableView的样式，如下图\n\n<a href=\"https://sm.ms/image/Iaho8TuHE1P4iRx\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/Iaho8TuHE1P4iRx.png\" ></a>\n\n<a href=\"https://sm.ms/image/taEDOVHfAk2LnQe\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/taEDOVHfAk2LnQe.png\"  width=50% ></a>\n\n通过新的配置类，可以做成如下效果\n\n<a href=\"https://sm.ms/image/nlrR8VBkzqy2SdP\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/nlrR8VBkzqy2SdP.png\"  width=50% ></a>\n\n<a href=\"https://sm.ms/image/PhtUgJrCR2OTQwY\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/PhtUgJrCR2OTQwY.png\"  width=50% ></a>\n\n新增一个UICollectionListViewCell，可以做出如下样式的cell\n\n<a href=\"https://sm.ms/image/jlZKFpCybNJPoET\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/jlZKFpCybNJPoET.png\" width=50%  ></a>\n\nCell的注册方式也有所改变，可以看出苹果从API层面已经进入MVVM架构模式了，注册cell需要带上对应的CellViewModel\n\n<a href=\"https://sm.ms/image/2awdL6yOmUzIGrZ\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/2awdL6yOmUzIGrZ.jpg\" width=50% ></a>\n\n另外也支持像UITableViewCell的侧滑操作等等，详细内容将会另外开篇讲述。\n\n具体查看[视频](https://developer.apple.com/videos/play/wwdc2020/10097/)","slug":"iOS14新API","published":1,"updated":"2021-06-06T18:52:24.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohx004atnn038dg54nn","content":"<p>iOS 14 新API</p>\n<span id=\"more\"></span>\n\n<h3 id=\"Control-Appearance-update\"><a href=\"#Control-Appearance-update\" class=\"headerlink\" title=\"Control Appearance update\"></a>Control Appearance update</h3><p>控件外观更新，比如UISlider、 UIProgressView、UIActivityIndicatorView，长得稍微有点不一样，不影响适配。</p>\n<p><img src=\"https://s1.ax1x.com/2020/06/29/NfJ6zt.png\"></p>\n<p>UIPageControl样式改变并且可以自定义icon</p>\n<p><img src=\"https://s1.ax1x.com/2020/06/29/NfYs7F.png\"></p>\n<p>自定义小心心icon和书签icon</p>\n<p><img src=\"https://s1.ax1x.com/2020/06/29/NfYO1I.png\"></p>\n<h3 id=\"Color-Picker\"><a href=\"#Color-Picker\" class=\"headerlink\" title=\"Color Picker\"></a>Color Picker</h3><p>新增颜色选择器<code>UIColorPickerViewController</code></p>\n<p>支持取色器 收藏常用颜色等等</p>\n<p>可以配置是否支持调整透明度等等，具体配置项目参考api文档</p>\n<p>建议Present弹出</p>\n<p><a href=\"https://sm.ms/image/iz1WnGFImlUvkty\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/iz1WnGFImlUvkty.png\" width=50% ></a></p>\n<h3 id=\"Date-Picker\"><a href=\"#Date-Picker\" class=\"headerlink\" title=\"Date Picker\"></a>Date Picker</h3><p>UIDatePicker更新UI</p>\n<p>两种样式</p>\n<p>支持农历</p>\n<p><a href=\"https://sm.ms/image/wMmTIykghRNqWQn\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/wMmTIykghRNqWQn.png\" width=50% ></a></p>\n<p><a href=\"https://sm.ms/image/uF3WonxPAsDyXaO\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/uF3WonxPAsDyXaO.png\" width=50% ></a></p>\n<h3 id=\"Menus\"><a href=\"#Menus\" class=\"headerlink\" title=\"Menus\"></a>Menus</h3><p>貌似可以替代我们常有的角标弹窗列表按钮需求</p>\n<p>基于<code>UIButton</code>和<code>UIBarButtonItem</code>的新增的<code>menu</code>属性，可以配置长按或者单击(配置 <code>button.showsMenuAsPrimaryAction = true</code>)弹出菜单列表</p>\n<p><a href=\"https://sm.ms/image/L1XmoD2d7EKj49Y\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/L1XmoD2d7EKj49Y.png\" width=50% ></a></p>\n<p><a href=\"https://sm.ms/image/ZflMaksQFDuKp3T\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/ZflMaksQFDuKp3T.png\" width=50% ></a></p>\n<p>UINavigationBar 的原生返回按钮长按会弹出菜单，可以跳回导航栏栈中的任意一个页面，按钮标题为前面控制器的标题</p>\n<p><a href=\"https://sm.ms/image/FVdgXvpGeTBfYKZ\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/FVdgXvpGeTBfYKZ.png\" width=50% ></a></p>\n<p>更新弹出菜单内容，将会实时更新并自带系统动画：</p>\n<p><code>updateVisibleMenu(_ block: (UIMenu) -&gt; UIMenu)</code></p>\n<h3 id=\"UIActions\"><a href=\"#UIActions\" class=\"headerlink\" title=\"UIActions\"></a>UIActions</h3><p>UIBarButtonItem 新增 fixedSpace(width:) 和 flexibleSpace方法 去调节item之间的间隔，不用像之前那样子创建一个fixedSpace类型的UIBarButtonItem去占位</p>\n<p>UIButton新增了一个初始化方法init(type:primaryAction:) type默认为.system 标题为primaryAction.title ，图片为 primaryAction.image</p>\n<h3 id=\"WidgetKit\"><a href=\"#WidgetKit\" class=\"headerlink\" title=\"WidgetKit\"></a>WidgetKit</h3><p>iOS14 重大新特性之一 支持三种宽度的widget，具体内容另外开篇再讲<br><a href=\"https://sm.ms/image/eiXyvjhfgAqQURr\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/eiXyvjhfgAqQURr.png\" width=50% ></a></p>\n<h3 id=\"让你的app支持物理键盘\"><a href=\"#让你的app支持物理键盘\" class=\"headerlink\" title=\"让你的app支持物理键盘\"></a>让你的app支持物理键盘</h3><p><a href=\"https://developer.apple.com/documentation/uikit/keyboards_and_input/adding_hardware_keyboard_support_to_your_app\">具体内容查看文档</a></p>\n<h3 id=\"Asynchronously-Loading-Images-into-Table-and-Collection-Views\"><a href=\"#Asynchronously-Loading-Images-into-Table-and-Collection-Views\" class=\"headerlink\" title=\"Asynchronously Loading Images into Table and Collection Views\"></a>Asynchronously Loading Images into Table and Collection Views</h3><p><a href=\"https://developer.apple.com/documentation/uikit/uiimage/asynchronously_loading_images_into_table_and_collection_views\">文档</a></p>\n<p>tableView和CollectionView异步加载网络图片的API</p>\n<h3 id=\"PHPicker-图片选择器\"><a href=\"#PHPicker-图片选择器\" class=\"headerlink\" title=\"PHPicker 图片选择器\"></a>PHPicker 图片选择器</h3><p>新的图片选择器，支持多选，不需要用户允许相册访问权限，可以选择图片（包括livePhoto）和视频</p>\n<p><a href=\"https://sm.ms/image/R9fc3SZIlpLhuwB\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/R9fc3SZIlpLhuwB.png\" width=50% ></a></p>\n<h3 id=\"定位权限更新\"><a href=\"#定位权限更新\" class=\"headerlink\" title=\"定位权限更新\"></a>定位权限更新</h3><p>旧的定位权限弹窗如下：</p>\n<p><a href=\"https://sm.ms/image/kSgBdY3hjRWG21E\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/kSgBdY3hjRWG21E.png\" width=50% ></a></p>\n<p>新的定位权限弹窗如下：</p>\n<p><a href=\"https://sm.ms/image/svo9OnAS1BZdLDP\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/svo9OnAS1BZdLDP.png\" width=50% ></a></p>\n<p>多了个小地图，并且小地图的左上角多了个按钮，点击选择是否允许准确定位。</p>\n<p>若不允许的话，开发者获取的定位会变成一个±5公里的范围，并且只能持续定位最多20分钟</p>\n<p>通过一个枚举值得知是否用户选择了模糊定位：</p>\n<p><a href=\"https://sm.ms/image/9gh6mbKL7VWe3uH\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/9gh6mbKL7VWe3uH.png\" ></a></p>\n<p>用户可以改变设置，是否允许app获取准确定位</p>\n<p><a href=\"https://sm.ms/image/jsQr4xoevXNa2Ju\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/jsQr4xoevXNa2Ju.png\" ></a></p>\n<p>开发者可以通过在<code>info.plist</code>里面配置信息解释为何需要用户选择准确定位</p>\n<p><a href=\"https://sm.ms/image/X5CRUopcnOHG3I2\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/X5CRUopcnOHG3I2.png\" ></a></p>\n<p>让隐私弹窗默认选择模糊定位</p>\n<p><a href=\"https://sm.ms/image/UeLtJhGXOvbKmns\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/UeLtJhGXOvbKmns.png\" width=50%></a></p>\n<h3 id=\"UICollectionView重大更新\"><a href=\"#UICollectionView重大更新\" class=\"headerlink\" title=\"UICollectionView重大更新\"></a>UICollectionView重大更新</h3><p>UICollection从数据源协议到Cell都有了新的API，开发者可以为cell添加各种“附件”，已适配复杂的列表样式，如下第二张图，另外可以在collectionView上使用类似tableView的样式，如下图</p>\n<p><a href=\"https://sm.ms/image/Iaho8TuHE1P4iRx\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/Iaho8TuHE1P4iRx.png\" ></a></p>\n<p><a href=\"https://sm.ms/image/taEDOVHfAk2LnQe\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/taEDOVHfAk2LnQe.png\"  width=50% ></a></p>\n<p>通过新的配置类，可以做成如下效果</p>\n<p><a href=\"https://sm.ms/image/nlrR8VBkzqy2SdP\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/nlrR8VBkzqy2SdP.png\"  width=50% ></a></p>\n<p><a href=\"https://sm.ms/image/PhtUgJrCR2OTQwY\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/PhtUgJrCR2OTQwY.png\"  width=50% ></a></p>\n<p>新增一个UICollectionListViewCell，可以做出如下样式的cell</p>\n<p><a href=\"https://sm.ms/image/jlZKFpCybNJPoET\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/jlZKFpCybNJPoET.png\" width=50%  ></a></p>\n<p>Cell的注册方式也有所改变，可以看出苹果从API层面已经进入MVVM架构模式了，注册cell需要带上对应的CellViewModel</p>\n<p><a href=\"https://sm.ms/image/2awdL6yOmUzIGrZ\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/2awdL6yOmUzIGrZ.jpg\" width=50% ></a></p>\n<p>另外也支持像UITableViewCell的侧滑操作等等，详细内容将会另外开篇讲述。</p>\n<p>具体查看<a href=\"https://developer.apple.com/videos/play/wwdc2020/10097/\">视频</a></p>\n","site":{"data":{}},"excerpt":"<p>iOS 14 新API</p>","more":"<h3 id=\"Control-Appearance-update\"><a href=\"#Control-Appearance-update\" class=\"headerlink\" title=\"Control Appearance update\"></a>Control Appearance update</h3><p>控件外观更新，比如UISlider、 UIProgressView、UIActivityIndicatorView，长得稍微有点不一样，不影响适配。</p>\n<p><img src=\"https://s1.ax1x.com/2020/06/29/NfJ6zt.png\"></p>\n<p>UIPageControl样式改变并且可以自定义icon</p>\n<p><img src=\"https://s1.ax1x.com/2020/06/29/NfYs7F.png\"></p>\n<p>自定义小心心icon和书签icon</p>\n<p><img src=\"https://s1.ax1x.com/2020/06/29/NfYO1I.png\"></p>\n<h3 id=\"Color-Picker\"><a href=\"#Color-Picker\" class=\"headerlink\" title=\"Color Picker\"></a>Color Picker</h3><p>新增颜色选择器<code>UIColorPickerViewController</code></p>\n<p>支持取色器 收藏常用颜色等等</p>\n<p>可以配置是否支持调整透明度等等，具体配置项目参考api文档</p>\n<p>建议Present弹出</p>\n<p><a href=\"https://sm.ms/image/iz1WnGFImlUvkty\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/iz1WnGFImlUvkty.png\" width=50% ></a></p>\n<h3 id=\"Date-Picker\"><a href=\"#Date-Picker\" class=\"headerlink\" title=\"Date Picker\"></a>Date Picker</h3><p>UIDatePicker更新UI</p>\n<p>两种样式</p>\n<p>支持农历</p>\n<p><a href=\"https://sm.ms/image/wMmTIykghRNqWQn\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/wMmTIykghRNqWQn.png\" width=50% ></a></p>\n<p><a href=\"https://sm.ms/image/uF3WonxPAsDyXaO\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/uF3WonxPAsDyXaO.png\" width=50% ></a></p>\n<h3 id=\"Menus\"><a href=\"#Menus\" class=\"headerlink\" title=\"Menus\"></a>Menus</h3><p>貌似可以替代我们常有的角标弹窗列表按钮需求</p>\n<p>基于<code>UIButton</code>和<code>UIBarButtonItem</code>的新增的<code>menu</code>属性，可以配置长按或者单击(配置 <code>button.showsMenuAsPrimaryAction = true</code>)弹出菜单列表</p>\n<p><a href=\"https://sm.ms/image/L1XmoD2d7EKj49Y\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/L1XmoD2d7EKj49Y.png\" width=50% ></a></p>\n<p><a href=\"https://sm.ms/image/ZflMaksQFDuKp3T\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/ZflMaksQFDuKp3T.png\" width=50% ></a></p>\n<p>UINavigationBar 的原生返回按钮长按会弹出菜单，可以跳回导航栏栈中的任意一个页面，按钮标题为前面控制器的标题</p>\n<p><a href=\"https://sm.ms/image/FVdgXvpGeTBfYKZ\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/FVdgXvpGeTBfYKZ.png\" width=50% ></a></p>\n<p>更新弹出菜单内容，将会实时更新并自带系统动画：</p>\n<p><code>updateVisibleMenu(_ block: (UIMenu) -&gt; UIMenu)</code></p>\n<h3 id=\"UIActions\"><a href=\"#UIActions\" class=\"headerlink\" title=\"UIActions\"></a>UIActions</h3><p>UIBarButtonItem 新增 fixedSpace(width:) 和 flexibleSpace方法 去调节item之间的间隔，不用像之前那样子创建一个fixedSpace类型的UIBarButtonItem去占位</p>\n<p>UIButton新增了一个初始化方法init(type:primaryAction:) type默认为.system 标题为primaryAction.title ，图片为 primaryAction.image</p>\n<h3 id=\"WidgetKit\"><a href=\"#WidgetKit\" class=\"headerlink\" title=\"WidgetKit\"></a>WidgetKit</h3><p>iOS14 重大新特性之一 支持三种宽度的widget，具体内容另外开篇再讲<br><a href=\"https://sm.ms/image/eiXyvjhfgAqQURr\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/eiXyvjhfgAqQURr.png\" width=50% ></a></p>\n<h3 id=\"让你的app支持物理键盘\"><a href=\"#让你的app支持物理键盘\" class=\"headerlink\" title=\"让你的app支持物理键盘\"></a>让你的app支持物理键盘</h3><p><a href=\"https://developer.apple.com/documentation/uikit/keyboards_and_input/adding_hardware_keyboard_support_to_your_app\">具体内容查看文档</a></p>\n<h3 id=\"Asynchronously-Loading-Images-into-Table-and-Collection-Views\"><a href=\"#Asynchronously-Loading-Images-into-Table-and-Collection-Views\" class=\"headerlink\" title=\"Asynchronously Loading Images into Table and Collection Views\"></a>Asynchronously Loading Images into Table and Collection Views</h3><p><a href=\"https://developer.apple.com/documentation/uikit/uiimage/asynchronously_loading_images_into_table_and_collection_views\">文档</a></p>\n<p>tableView和CollectionView异步加载网络图片的API</p>\n<h3 id=\"PHPicker-图片选择器\"><a href=\"#PHPicker-图片选择器\" class=\"headerlink\" title=\"PHPicker 图片选择器\"></a>PHPicker 图片选择器</h3><p>新的图片选择器，支持多选，不需要用户允许相册访问权限，可以选择图片（包括livePhoto）和视频</p>\n<p><a href=\"https://sm.ms/image/R9fc3SZIlpLhuwB\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/R9fc3SZIlpLhuwB.png\" width=50% ></a></p>\n<h3 id=\"定位权限更新\"><a href=\"#定位权限更新\" class=\"headerlink\" title=\"定位权限更新\"></a>定位权限更新</h3><p>旧的定位权限弹窗如下：</p>\n<p><a href=\"https://sm.ms/image/kSgBdY3hjRWG21E\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/kSgBdY3hjRWG21E.png\" width=50% ></a></p>\n<p>新的定位权限弹窗如下：</p>\n<p><a href=\"https://sm.ms/image/svo9OnAS1BZdLDP\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/svo9OnAS1BZdLDP.png\" width=50% ></a></p>\n<p>多了个小地图，并且小地图的左上角多了个按钮，点击选择是否允许准确定位。</p>\n<p>若不允许的话，开发者获取的定位会变成一个±5公里的范围，并且只能持续定位最多20分钟</p>\n<p>通过一个枚举值得知是否用户选择了模糊定位：</p>\n<p><a href=\"https://sm.ms/image/9gh6mbKL7VWe3uH\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/9gh6mbKL7VWe3uH.png\" ></a></p>\n<p>用户可以改变设置，是否允许app获取准确定位</p>\n<p><a href=\"https://sm.ms/image/jsQr4xoevXNa2Ju\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/jsQr4xoevXNa2Ju.png\" ></a></p>\n<p>开发者可以通过在<code>info.plist</code>里面配置信息解释为何需要用户选择准确定位</p>\n<p><a href=\"https://sm.ms/image/X5CRUopcnOHG3I2\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/X5CRUopcnOHG3I2.png\" ></a></p>\n<p>让隐私弹窗默认选择模糊定位</p>\n<p><a href=\"https://sm.ms/image/UeLtJhGXOvbKmns\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/UeLtJhGXOvbKmns.png\" width=50%></a></p>\n<h3 id=\"UICollectionView重大更新\"><a href=\"#UICollectionView重大更新\" class=\"headerlink\" title=\"UICollectionView重大更新\"></a>UICollectionView重大更新</h3><p>UICollection从数据源协议到Cell都有了新的API，开发者可以为cell添加各种“附件”，已适配复杂的列表样式，如下第二张图，另外可以在collectionView上使用类似tableView的样式，如下图</p>\n<p><a href=\"https://sm.ms/image/Iaho8TuHE1P4iRx\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/Iaho8TuHE1P4iRx.png\" ></a></p>\n<p><a href=\"https://sm.ms/image/taEDOVHfAk2LnQe\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/taEDOVHfAk2LnQe.png\"  width=50% ></a></p>\n<p>通过新的配置类，可以做成如下效果</p>\n<p><a href=\"https://sm.ms/image/nlrR8VBkzqy2SdP\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/nlrR8VBkzqy2SdP.png\"  width=50% ></a></p>\n<p><a href=\"https://sm.ms/image/PhtUgJrCR2OTQwY\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/PhtUgJrCR2OTQwY.png\"  width=50% ></a></p>\n<p>新增一个UICollectionListViewCell，可以做出如下样式的cell</p>\n<p><a href=\"https://sm.ms/image/jlZKFpCybNJPoET\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/jlZKFpCybNJPoET.png\" width=50%  ></a></p>\n<p>Cell的注册方式也有所改变，可以看出苹果从API层面已经进入MVVM架构模式了，注册cell需要带上对应的CellViewModel</p>\n<p><a href=\"https://sm.ms/image/2awdL6yOmUzIGrZ\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/2awdL6yOmUzIGrZ.jpg\" width=50% ></a></p>\n<p>另外也支持像UITableViewCell的侧滑操作等等，详细内容将会另外开篇讲述。</p>\n<p>具体查看<a href=\"https://developer.apple.com/videos/play/wwdc2020/10097/\">视频</a></p>"},{"title":"iOS从服务器下载DAE文件并动态加载到SCNScene","author":"Arclin","abbrlink":"8c9c88ab","date":"2017-02-22T16:00:00.000Z","_content":"ViewController 已有 SCNScene,怎么从服务器下载3D模型文件(DAE)然后加载到这个 SCNScene呢？\n\n<!-- more -->\n\n1. 由于 `SCNScene` 不支持动态加载 DAE 文件，或者说不支持动态加载 `COLLADA` 方案下的所有3d 类型，但是测试发现直接把 DAE 文件放进 `arc.scnassets` 文件夹下的时候是可以加载的，可见系统编译的时候应该是做了某些手脚，查询资料后发现系统是执行了两个脚本，两个脚本的路径分别是`/Applications/Xcode.app/Contents/Developer/usr/bin/copySceneKitAssets`和\n`/Applications/Xcode.app/Contents/Developer/usr/bin/scntool` 所以先把这两个文件拷出来\n\n2. 新建一个文件夹，命名是 自定义名字.scnassets,例如abc.scnassets\n\n3. 把模型文件放在里面,然后在这个文件夹外面放上copySceneKitAssets和scntool\n4. 终端执行./copySceneKitAssets abc.scnassets -o abc-o.scnassets 如果没问题的话就会生成一个 abc-o.scnassets 文件夹\n5. 打包 zip 上传服务器\n6. 代码下载 zip包,解压,然后载入文件\n\n```\ndocumentsDirectoryURL = [documentsDirectoryURL URLByAppendingPathComponent:@\"abc-o.scnassets/test.dae\"];\nSCNSceneSource *sceneSource = [SCNSceneSource sceneSourceWithURL:documentsDirectoryURL options:nil];\nSCNNode *theCube = [sceneSource entryWithIdentifier:@\"Cube\" withClass:[SCNNode class]];\n```\n或者使用SCNScene这个方法\n\n```\n+ (nullable instancetype)sceneWithURL:(NSURL *)url options:(nullable NSDictionary<SCNSceneSourceLoadingOption, id> *)options error:(NSError **)error;\n```\n也是可以的\n\n","source":"_posts/iOS从服务器下载DAE文件并动态加载到SCNScene.md","raw":"---\ntitle: iOS从服务器下载DAE文件并动态加载到SCNScene\nauthor: Arclin\ntags:\n  - iOS\n  - Scene Kit\n  - ''\ncategories:\n  - iOS\nabbrlink: 8c9c88ab\ndate: 2017-02-23 00:00:00\n---\nViewController 已有 SCNScene,怎么从服务器下载3D模型文件(DAE)然后加载到这个 SCNScene呢？\n\n<!-- more -->\n\n1. 由于 `SCNScene` 不支持动态加载 DAE 文件，或者说不支持动态加载 `COLLADA` 方案下的所有3d 类型，但是测试发现直接把 DAE 文件放进 `arc.scnassets` 文件夹下的时候是可以加载的，可见系统编译的时候应该是做了某些手脚，查询资料后发现系统是执行了两个脚本，两个脚本的路径分别是`/Applications/Xcode.app/Contents/Developer/usr/bin/copySceneKitAssets`和\n`/Applications/Xcode.app/Contents/Developer/usr/bin/scntool` 所以先把这两个文件拷出来\n\n2. 新建一个文件夹，命名是 自定义名字.scnassets,例如abc.scnassets\n\n3. 把模型文件放在里面,然后在这个文件夹外面放上copySceneKitAssets和scntool\n4. 终端执行./copySceneKitAssets abc.scnassets -o abc-o.scnassets 如果没问题的话就会生成一个 abc-o.scnassets 文件夹\n5. 打包 zip 上传服务器\n6. 代码下载 zip包,解压,然后载入文件\n\n```\ndocumentsDirectoryURL = [documentsDirectoryURL URLByAppendingPathComponent:@\"abc-o.scnassets/test.dae\"];\nSCNSceneSource *sceneSource = [SCNSceneSource sceneSourceWithURL:documentsDirectoryURL options:nil];\nSCNNode *theCube = [sceneSource entryWithIdentifier:@\"Cube\" withClass:[SCNNode class]];\n```\n或者使用SCNScene这个方法\n\n```\n+ (nullable instancetype)sceneWithURL:(NSURL *)url options:(nullable NSDictionary<SCNSceneSourceLoadingOption, id> *)options error:(NSError **)error;\n```\n也是可以的\n\n","slug":"iOS从服务器下载DAE文件并动态加载到SCNScene","published":1,"updated":"2021-06-06T18:52:24.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohx004dtnn02b52h5x3","content":"<p>ViewController 已有 SCNScene,怎么从服务器下载3D模型文件(DAE)然后加载到这个 SCNScene呢？</p>\n<span id=\"more\"></span>\n\n<ol>\n<li><p>由于 <code>SCNScene</code> 不支持动态加载 DAE 文件，或者说不支持动态加载 <code>COLLADA</code> 方案下的所有3d 类型，但是测试发现直接把 DAE 文件放进 <code>arc.scnassets</code> 文件夹下的时候是可以加载的，可见系统编译的时候应该是做了某些手脚，查询资料后发现系统是执行了两个脚本，两个脚本的路径分别是<code>/Applications/Xcode.app/Contents/Developer/usr/bin/copySceneKitAssets</code>和<br><code>/Applications/Xcode.app/Contents/Developer/usr/bin/scntool</code> 所以先把这两个文件拷出来</p>\n</li>\n<li><p>新建一个文件夹，命名是 自定义名字.scnassets,例如abc.scnassets</p>\n</li>\n<li><p>把模型文件放在里面,然后在这个文件夹外面放上copySceneKitAssets和scntool</p>\n</li>\n<li><p>终端执行./copySceneKitAssets abc.scnassets -o abc-o.scnassets 如果没问题的话就会生成一个 abc-o.scnassets 文件夹</p>\n</li>\n<li><p>打包 zip 上传服务器</p>\n</li>\n<li><p>代码下载 zip包,解压,然后载入文件</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">documentsDirectoryURL &#x3D; [documentsDirectoryURL URLByAppendingPathComponent:@&quot;abc-o.scnassets&#x2F;test.dae&quot;];</span><br><span class=\"line\">SCNSceneSource *sceneSource &#x3D; [SCNSceneSource sceneSourceWithURL:documentsDirectoryURL options:nil];</span><br><span class=\"line\">SCNNode *theCube &#x3D; [sceneSource entryWithIdentifier:@&quot;Cube&quot; withClass:[SCNNode class]];</span><br></pre></td></tr></table></figure>\n<p>或者使用SCNScene这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (nullable instancetype)sceneWithURL:(NSURL *)url options:(nullable NSDictionary&lt;SCNSceneSourceLoadingOption, id&gt; *)options error:(NSError **)error;</span><br></pre></td></tr></table></figure>\n<p>也是可以的</p>\n","site":{"data":{}},"excerpt":"<p>ViewController 已有 SCNScene,怎么从服务器下载3D模型文件(DAE)然后加载到这个 SCNScene呢？</p>","more":"<ol>\n<li><p>由于 <code>SCNScene</code> 不支持动态加载 DAE 文件，或者说不支持动态加载 <code>COLLADA</code> 方案下的所有3d 类型，但是测试发现直接把 DAE 文件放进 <code>arc.scnassets</code> 文件夹下的时候是可以加载的，可见系统编译的时候应该是做了某些手脚，查询资料后发现系统是执行了两个脚本，两个脚本的路径分别是<code>/Applications/Xcode.app/Contents/Developer/usr/bin/copySceneKitAssets</code>和<br><code>/Applications/Xcode.app/Contents/Developer/usr/bin/scntool</code> 所以先把这两个文件拷出来</p>\n</li>\n<li><p>新建一个文件夹，命名是 自定义名字.scnassets,例如abc.scnassets</p>\n</li>\n<li><p>把模型文件放在里面,然后在这个文件夹外面放上copySceneKitAssets和scntool</p>\n</li>\n<li><p>终端执行./copySceneKitAssets abc.scnassets -o abc-o.scnassets 如果没问题的话就会生成一个 abc-o.scnassets 文件夹</p>\n</li>\n<li><p>打包 zip 上传服务器</p>\n</li>\n<li><p>代码下载 zip包,解压,然后载入文件</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">documentsDirectoryURL &#x3D; [documentsDirectoryURL URLByAppendingPathComponent:@&quot;abc-o.scnassets&#x2F;test.dae&quot;];</span><br><span class=\"line\">SCNSceneSource *sceneSource &#x3D; [SCNSceneSource sceneSourceWithURL:documentsDirectoryURL options:nil];</span><br><span class=\"line\">SCNNode *theCube &#x3D; [sceneSource entryWithIdentifier:@&quot;Cube&quot; withClass:[SCNNode class]];</span><br></pre></td></tr></table></figure>\n<p>或者使用SCNScene这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (nullable instancetype)sceneWithURL:(NSURL *)url options:(nullable NSDictionary&lt;SCNSceneSourceLoadingOption, id&gt; *)options error:(NSError **)error;</span><br></pre></td></tr></table></figure>\n<p>也是可以的</p>"},{"title":"iOS基于Navigation-Base-on-ViewModel的路由搭建——HOOK方式实现","author":"Arclin","abbrlink":"b111382b","date":"2017-01-04T16:00:00.000Z","_content":"本文主要讲述的是在 iOS 中使用 MVVM 架构开发的情况下，将 ViewModel 作为行为驱动主体，通过 Hook 的方式，设计一个 App 的路由层\n\n<!-- more -->\n\n- 什么是路由\n\n\t- 路由在服务端指的是url请求的分层解析，将一个请求分发到对应的应用处理程序。\n在移动端指的是将 App 内页面访问、H5与App之间和访问请求和 App之间的访问请求 进行分发的逻辑层。\n\n- 在移动端中路由需要做什么事情\n\n\t- 针对网络上的各种说法，这里做一下简要说明：\n\t\t- 提供接口供外部访问，这里的”外部”指的可能是App内的一个ViewController，也有可能是其他应用（包括系统应用），也有可能是 H5页面。\n分发资源。路由不需要依赖外部的资源的定义，就可以将资源传递给目的地。（‘资源’在这里指的是原生页面、模块、组件等等）\n\t\t- 统一的标识符（或者统一格式的标识符）去标识资源，并且可以通过这些标示符去统一访问请求的过程。\n\t\t- 解决安全访问的问题，如果是外部的H5、App去访问你的 App,那么就得特别注意这个问题。（本文暂不提及这个问题）\n\n- 在移动端中路由的使用场景\n\n\t- 原生界面之间，模块之间与组件之间的交互（例如页面的跳转之类）\n\t- H5页面与原生界面之间的交互\n\t- 解除业务依赖\n\t- 组件化开发\n\n- iOS自带的系统访问方式、统一的连接协议\n\n\t- 苹果开发了[URLScheme](https://developer.apple.com/library/content/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899)这种东西，使得 App 能够在沙盒机制的前提下互相调用，定义URL-Scheme的方式如下\n> - 协议部分来标示App应用\n> - 主机Host部分用于标示业务线或者是应用提供的划分好的服务实体，比方说index、discover是业务条线，api-asycn是对外提供的api，pushService是App内部的推送服务等。\n> - 路径部分则可以是细分的页面、组件或者服务的标示\n> - 参数定义有一些是必要的，比如说action来标示动作，比方说可以使用get标示获取、insert增加，userToken表示安全的用户令牌，source表示来源，当然像是userToken与source这些都是路由层需要进行解析和验证的，而action则是业务相关的参数，这一点在路由曾设计的时候需要进行详细区分\n\n- 讲完了路由的概念，接下来谈谈 路由设计\n\t- 我们先抽取最常见的页面跳转来讲，因为我们使用的是 MVVM,那么从理论上来讲，我们就应该让App以 ViewModel为驱动进行运作，而不是用 ViewController,之前说 ViewController 在跳转的时候只需要关心跳转过去的界面是否是一个 UIViewController 的子类，而不需要关心这个 viewController的具体细节,所以考虑用 ViewModel把 目的 ViewController 传递到当前 ViewController，但是ViewModel 严格来讲不能引入任何 UIKit 的任何内容，不然ViewModel级就会失去其可测试性，所以我们通过引入服务总线的概念，维护一个NavigationController 的堆栈（这个思想来自于雷纯锋的博客中的一篇文章[MVVM With ReactiveCocoa](http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/)）具体实现如下\n\n```\n//这个是协议声明部分\n@protocol MRCNavigationProtocol <NSObject>\n- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated;\n- (void)popViewModelAnimated:(BOOL)animated;\n- (void)popToRootViewModelAnimated:(BOOL)animated;\n- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion;\n- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion;\n- (void)resetRootViewModel:(MRCViewModel *)viewModel;\n@end\n```\n  \n以下是方法的实现部分，没有写任何方法的实现过程，只是进行了空操作，目的是使用 Hook 思想去捕获操作\n  \n```\n- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated {}\n- (void)popViewModelAnimated:(BOOL)animated {}\n- (void)popToRootViewModelAnimated:(BOOL)animated {}\n- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion {}\n- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion {}\n- (void)resetRootViewModel:(MRCViewModel *)viewModel {}\n```\n\n栈顶的 NavigationController 进行 Hook 并执行真正的跳转操作(使用到了 ReactiveCocoa， 因为要捕获的方法太多，这里只列举两条)\n\n```\n- (void)registerNavigationHooks {\n  \t @weakify(self)\n    [[(NSObject *)self.services\n        rac_signalForSelector:@selector(pushViewModel:animated:)]\n        subscribeNext:^(RACTuple *tuple) {\n            @strongify(self)\n            UIViewController *viewController = (UIViewController *)[MRCRouter.sharedInstance viewControllerForViewModel:tuple.first];\n            [self.navigationControllers.lastObject pushViewController:viewController animated:[tuple.second boolValue]];\n        }];\n    [[(NSObject *)self.services\n        rac_signalForSelector:@selector(popViewModelAnimated:)]\n        subscribeNext:^(RACTuple *tuple) {\n          @strongify(self)\n            [self.navigationControllers.lastObject popViewControllerAnimated:[tuple.first boolValue]];\n    }];\n}\n```\n\n实际在 ViewController 里面调用起来就会是这种感觉\n\n```\n- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {\n    [tableView deselectRowAtIndexPath:indexPath animated:YES];\n    if (indexPath.section == 0) {\n        MRCTrendingViewModel *trendingViewModel = [[MRCTrendingViewModel alloc] initWithServices:self.viewModel.services params:nil];\n        [self.viewModel.services pushViewModel:trendingViewModel animated:YES];\n    }\n}\n```\n\n然后看下将ViewModel与 ViewController 关联起来的 路由内的映射(截取部分)\n\n```\n- (NSDictionary *)viewModelViewMappings {\n   return @{\n   \t   @\"MRCLoginViewModel\": @\"MRCLoginViewController\",\n      @\"MRCHomepageViewModel\": @\"MRCHomepageViewController\",\n      @\"MRCRepoDetailViewModel\": @\"MRCRepoDetailViewController\",\n      @\"MRCWebViewModel\": @\"MRCWebViewController\",\n   };\n}\n```\n\n当然这上面的只是路由的实现方案1，纯粹地将 ViewController 与 ViewModel 关联起来，方案2是 建立一个路由层通过URL 的方式进行路由交互参考[一步步构建iOS路由](http://www.jianshu.com/p/3a902f274a3d)这部分我后面会讲讲我的思考。\n\n","source":"_posts/iOS基于Navigation-Base-on-ViewModel的路由搭建——HOOK方式实现.md","raw":"---\ntitle: iOS基于Navigation-Base-on-ViewModel的路由搭建——HOOK方式实现\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: b111382b\ndate: 2017-01-05 00:00:00\n---\n本文主要讲述的是在 iOS 中使用 MVVM 架构开发的情况下，将 ViewModel 作为行为驱动主体，通过 Hook 的方式，设计一个 App 的路由层\n\n<!-- more -->\n\n- 什么是路由\n\n\t- 路由在服务端指的是url请求的分层解析，将一个请求分发到对应的应用处理程序。\n在移动端指的是将 App 内页面访问、H5与App之间和访问请求和 App之间的访问请求 进行分发的逻辑层。\n\n- 在移动端中路由需要做什么事情\n\n\t- 针对网络上的各种说法，这里做一下简要说明：\n\t\t- 提供接口供外部访问，这里的”外部”指的可能是App内的一个ViewController，也有可能是其他应用（包括系统应用），也有可能是 H5页面。\n分发资源。路由不需要依赖外部的资源的定义，就可以将资源传递给目的地。（‘资源’在这里指的是原生页面、模块、组件等等）\n\t\t- 统一的标识符（或者统一格式的标识符）去标识资源，并且可以通过这些标示符去统一访问请求的过程。\n\t\t- 解决安全访问的问题，如果是外部的H5、App去访问你的 App,那么就得特别注意这个问题。（本文暂不提及这个问题）\n\n- 在移动端中路由的使用场景\n\n\t- 原生界面之间，模块之间与组件之间的交互（例如页面的跳转之类）\n\t- H5页面与原生界面之间的交互\n\t- 解除业务依赖\n\t- 组件化开发\n\n- iOS自带的系统访问方式、统一的连接协议\n\n\t- 苹果开发了[URLScheme](https://developer.apple.com/library/content/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899)这种东西，使得 App 能够在沙盒机制的前提下互相调用，定义URL-Scheme的方式如下\n> - 协议部分来标示App应用\n> - 主机Host部分用于标示业务线或者是应用提供的划分好的服务实体，比方说index、discover是业务条线，api-asycn是对外提供的api，pushService是App内部的推送服务等。\n> - 路径部分则可以是细分的页面、组件或者服务的标示\n> - 参数定义有一些是必要的，比如说action来标示动作，比方说可以使用get标示获取、insert增加，userToken表示安全的用户令牌，source表示来源，当然像是userToken与source这些都是路由层需要进行解析和验证的，而action则是业务相关的参数，这一点在路由曾设计的时候需要进行详细区分\n\n- 讲完了路由的概念，接下来谈谈 路由设计\n\t- 我们先抽取最常见的页面跳转来讲，因为我们使用的是 MVVM,那么从理论上来讲，我们就应该让App以 ViewModel为驱动进行运作，而不是用 ViewController,之前说 ViewController 在跳转的时候只需要关心跳转过去的界面是否是一个 UIViewController 的子类，而不需要关心这个 viewController的具体细节,所以考虑用 ViewModel把 目的 ViewController 传递到当前 ViewController，但是ViewModel 严格来讲不能引入任何 UIKit 的任何内容，不然ViewModel级就会失去其可测试性，所以我们通过引入服务总线的概念，维护一个NavigationController 的堆栈（这个思想来自于雷纯锋的博客中的一篇文章[MVVM With ReactiveCocoa](http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/)）具体实现如下\n\n```\n//这个是协议声明部分\n@protocol MRCNavigationProtocol <NSObject>\n- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated;\n- (void)popViewModelAnimated:(BOOL)animated;\n- (void)popToRootViewModelAnimated:(BOOL)animated;\n- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion;\n- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion;\n- (void)resetRootViewModel:(MRCViewModel *)viewModel;\n@end\n```\n  \n以下是方法的实现部分，没有写任何方法的实现过程，只是进行了空操作，目的是使用 Hook 思想去捕获操作\n  \n```\n- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated {}\n- (void)popViewModelAnimated:(BOOL)animated {}\n- (void)popToRootViewModelAnimated:(BOOL)animated {}\n- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion {}\n- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion {}\n- (void)resetRootViewModel:(MRCViewModel *)viewModel {}\n```\n\n栈顶的 NavigationController 进行 Hook 并执行真正的跳转操作(使用到了 ReactiveCocoa， 因为要捕获的方法太多，这里只列举两条)\n\n```\n- (void)registerNavigationHooks {\n  \t @weakify(self)\n    [[(NSObject *)self.services\n        rac_signalForSelector:@selector(pushViewModel:animated:)]\n        subscribeNext:^(RACTuple *tuple) {\n            @strongify(self)\n            UIViewController *viewController = (UIViewController *)[MRCRouter.sharedInstance viewControllerForViewModel:tuple.first];\n            [self.navigationControllers.lastObject pushViewController:viewController animated:[tuple.second boolValue]];\n        }];\n    [[(NSObject *)self.services\n        rac_signalForSelector:@selector(popViewModelAnimated:)]\n        subscribeNext:^(RACTuple *tuple) {\n          @strongify(self)\n            [self.navigationControllers.lastObject popViewControllerAnimated:[tuple.first boolValue]];\n    }];\n}\n```\n\n实际在 ViewController 里面调用起来就会是这种感觉\n\n```\n- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {\n    [tableView deselectRowAtIndexPath:indexPath animated:YES];\n    if (indexPath.section == 0) {\n        MRCTrendingViewModel *trendingViewModel = [[MRCTrendingViewModel alloc] initWithServices:self.viewModel.services params:nil];\n        [self.viewModel.services pushViewModel:trendingViewModel animated:YES];\n    }\n}\n```\n\n然后看下将ViewModel与 ViewController 关联起来的 路由内的映射(截取部分)\n\n```\n- (NSDictionary *)viewModelViewMappings {\n   return @{\n   \t   @\"MRCLoginViewModel\": @\"MRCLoginViewController\",\n      @\"MRCHomepageViewModel\": @\"MRCHomepageViewController\",\n      @\"MRCRepoDetailViewModel\": @\"MRCRepoDetailViewController\",\n      @\"MRCWebViewModel\": @\"MRCWebViewController\",\n   };\n}\n```\n\n当然这上面的只是路由的实现方案1，纯粹地将 ViewController 与 ViewModel 关联起来，方案2是 建立一个路由层通过URL 的方式进行路由交互参考[一步步构建iOS路由](http://www.jianshu.com/p/3a902f274a3d)这部分我后面会讲讲我的思考。\n\n","slug":"iOS基于Navigation-Base-on-ViewModel的路由搭建——HOOK方式实现","published":1,"updated":"2021-06-06T18:52:24.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohy004htnn0b7ai38ue","content":"<p>本文主要讲述的是在 iOS 中使用 MVVM 架构开发的情况下，将 ViewModel 作为行为驱动主体，通过 Hook 的方式，设计一个 App 的路由层</p>\n<span id=\"more\"></span>\n\n<ul>\n<li><p>什么是路由</p>\n<ul>\n<li>路由在服务端指的是url请求的分层解析，将一个请求分发到对应的应用处理程序。<br>在移动端指的是将 App 内页面访问、H5与App之间和访问请求和 App之间的访问请求 进行分发的逻辑层。</li>\n</ul>\n</li>\n<li><p>在移动端中路由需要做什么事情</p>\n<ul>\n<li>针对网络上的各种说法，这里做一下简要说明：<ul>\n<li>提供接口供外部访问，这里的”外部”指的可能是App内的一个ViewController，也有可能是其他应用（包括系统应用），也有可能是 H5页面。<br>分发资源。路由不需要依赖外部的资源的定义，就可以将资源传递给目的地。（‘资源’在这里指的是原生页面、模块、组件等等）</li>\n<li>统一的标识符（或者统一格式的标识符）去标识资源，并且可以通过这些标示符去统一访问请求的过程。</li>\n<li>解决安全访问的问题，如果是外部的H5、App去访问你的 App,那么就得特别注意这个问题。（本文暂不提及这个问题）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>在移动端中路由的使用场景</p>\n<ul>\n<li>原生界面之间，模块之间与组件之间的交互（例如页面的跳转之类）</li>\n<li>H5页面与原生界面之间的交互</li>\n<li>解除业务依赖</li>\n<li>组件化开发</li>\n</ul>\n</li>\n<li><p>iOS自带的系统访问方式、统一的连接协议</p>\n<ul>\n<li>苹果开发了<a href=\"https://developer.apple.com/library/content/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899\">URLScheme</a>这种东西，使得 App 能够在沙盒机制的前提下互相调用，定义URL-Scheme的方式如下<blockquote>\n<ul>\n<li>协议部分来标示App应用</li>\n<li>主机Host部分用于标示业务线或者是应用提供的划分好的服务实体，比方说index、discover是业务条线，api-asycn是对外提供的api，pushService是App内部的推送服务等。</li>\n<li>路径部分则可以是细分的页面、组件或者服务的标示</li>\n<li>参数定义有一些是必要的，比如说action来标示动作，比方说可以使用get标示获取、insert增加，userToken表示安全的用户令牌，source表示来源，当然像是userToken与source这些都是路由层需要进行解析和验证的，而action则是业务相关的参数，这一点在路由曾设计的时候需要进行详细区分</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>讲完了路由的概念，接下来谈谈 路由设计</p>\n<ul>\n<li>我们先抽取最常见的页面跳转来讲，因为我们使用的是 MVVM,那么从理论上来讲，我们就应该让App以 ViewModel为驱动进行运作，而不是用 ViewController,之前说 ViewController 在跳转的时候只需要关心跳转过去的界面是否是一个 UIViewController 的子类，而不需要关心这个 viewController的具体细节,所以考虑用 ViewModel把 目的 ViewController 传递到当前 ViewController，但是ViewModel 严格来讲不能引入任何 UIKit 的任何内容，不然ViewModel级就会失去其可测试性，所以我们通过引入服务总线的概念，维护一个NavigationController 的堆栈（这个思想来自于雷纯锋的博客中的一篇文章<a href=\"http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/\">MVVM With ReactiveCocoa</a>）具体实现如下</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;这个是协议声明部分</span><br><span class=\"line\">@protocol MRCNavigationProtocol &lt;NSObject&gt;</span><br><span class=\"line\">- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated;</span><br><span class=\"line\">- (void)popViewModelAnimated:(BOOL)animated;</span><br><span class=\"line\">- (void)popToRootViewModelAnimated:(BOOL)animated;</span><br><span class=\"line\">- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion;</span><br><span class=\"line\">- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion;</span><br><span class=\"line\">- (void)resetRootViewModel:(MRCViewModel *)viewModel;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>以下是方法的实现部分，没有写任何方法的实现过程，只是进行了空操作，目的是使用 Hook 思想去捕获操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)popViewModelAnimated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)popToRootViewModelAnimated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion &#123;&#125;</span><br><span class=\"line\">- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion &#123;&#125;</span><br><span class=\"line\">- (void)resetRootViewModel:(MRCViewModel *)viewModel &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>栈顶的 NavigationController 进行 Hook 并执行真正的跳转操作(使用到了 ReactiveCocoa， 因为要捕获的方法太多，这里只列举两条)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)registerNavigationHooks &#123;</span><br><span class=\"line\">  \t @weakify(self)</span><br><span class=\"line\">    [[(NSObject *)self.services</span><br><span class=\"line\">        rac_signalForSelector:@selector(pushViewModel:animated:)]</span><br><span class=\"line\">        subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">            @strongify(self)</span><br><span class=\"line\">            UIViewController *viewController &#x3D; (UIViewController *)[MRCRouter.sharedInstance viewControllerForViewModel:tuple.first];</span><br><span class=\"line\">            [self.navigationControllers.lastObject pushViewController:viewController animated:[tuple.second boolValue]];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    [[(NSObject *)self.services</span><br><span class=\"line\">        rac_signalForSelector:@selector(popViewModelAnimated:)]</span><br><span class=\"line\">        subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">          @strongify(self)</span><br><span class=\"line\">            [self.navigationControllers.lastObject popViewControllerAnimated:[tuple.first boolValue]];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际在 ViewController 里面调用起来就会是这种感觉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class=\"line\">    [tableView deselectRowAtIndexPath:indexPath animated:YES];</span><br><span class=\"line\">    if (indexPath.section &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">        MRCTrendingViewModel *trendingViewModel &#x3D; [[MRCTrendingViewModel alloc] initWithServices:self.viewModel.services params:nil];</span><br><span class=\"line\">        [self.viewModel.services pushViewModel:trendingViewModel animated:YES];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后看下将ViewModel与 ViewController 关联起来的 路由内的映射(截取部分)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSDictionary *)viewModelViewMappings &#123;</span><br><span class=\"line\">   return @&#123;</span><br><span class=\"line\">   \t   @&quot;MRCLoginViewModel&quot;: @&quot;MRCLoginViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCHomepageViewModel&quot;: @&quot;MRCHomepageViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCRepoDetailViewModel&quot;: @&quot;MRCRepoDetailViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCWebViewModel&quot;: @&quot;MRCWebViewController&quot;,</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然这上面的只是路由的实现方案1，纯粹地将 ViewController 与 ViewModel 关联起来，方案2是 建立一个路由层通过URL 的方式进行路由交互参考<a href=\"http://www.jianshu.com/p/3a902f274a3d\">一步步构建iOS路由</a>这部分我后面会讲讲我的思考。</p>\n","site":{"data":{}},"excerpt":"<p>本文主要讲述的是在 iOS 中使用 MVVM 架构开发的情况下，将 ViewModel 作为行为驱动主体，通过 Hook 的方式，设计一个 App 的路由层</p>","more":"<ul>\n<li><p>什么是路由</p>\n<ul>\n<li>路由在服务端指的是url请求的分层解析，将一个请求分发到对应的应用处理程序。<br>在移动端指的是将 App 内页面访问、H5与App之间和访问请求和 App之间的访问请求 进行分发的逻辑层。</li>\n</ul>\n</li>\n<li><p>在移动端中路由需要做什么事情</p>\n<ul>\n<li>针对网络上的各种说法，这里做一下简要说明：<ul>\n<li>提供接口供外部访问，这里的”外部”指的可能是App内的一个ViewController，也有可能是其他应用（包括系统应用），也有可能是 H5页面。<br>分发资源。路由不需要依赖外部的资源的定义，就可以将资源传递给目的地。（‘资源’在这里指的是原生页面、模块、组件等等）</li>\n<li>统一的标识符（或者统一格式的标识符）去标识资源，并且可以通过这些标示符去统一访问请求的过程。</li>\n<li>解决安全访问的问题，如果是外部的H5、App去访问你的 App,那么就得特别注意这个问题。（本文暂不提及这个问题）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>在移动端中路由的使用场景</p>\n<ul>\n<li>原生界面之间，模块之间与组件之间的交互（例如页面的跳转之类）</li>\n<li>H5页面与原生界面之间的交互</li>\n<li>解除业务依赖</li>\n<li>组件化开发</li>\n</ul>\n</li>\n<li><p>iOS自带的系统访问方式、统一的连接协议</p>\n<ul>\n<li>苹果开发了<a href=\"https://developer.apple.com/library/content/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899\">URLScheme</a>这种东西，使得 App 能够在沙盒机制的前提下互相调用，定义URL-Scheme的方式如下<blockquote>\n<ul>\n<li>协议部分来标示App应用</li>\n<li>主机Host部分用于标示业务线或者是应用提供的划分好的服务实体，比方说index、discover是业务条线，api-asycn是对外提供的api，pushService是App内部的推送服务等。</li>\n<li>路径部分则可以是细分的页面、组件或者服务的标示</li>\n<li>参数定义有一些是必要的，比如说action来标示动作，比方说可以使用get标示获取、insert增加，userToken表示安全的用户令牌，source表示来源，当然像是userToken与source这些都是路由层需要进行解析和验证的，而action则是业务相关的参数，这一点在路由曾设计的时候需要进行详细区分</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>讲完了路由的概念，接下来谈谈 路由设计</p>\n<ul>\n<li>我们先抽取最常见的页面跳转来讲，因为我们使用的是 MVVM,那么从理论上来讲，我们就应该让App以 ViewModel为驱动进行运作，而不是用 ViewController,之前说 ViewController 在跳转的时候只需要关心跳转过去的界面是否是一个 UIViewController 的子类，而不需要关心这个 viewController的具体细节,所以考虑用 ViewModel把 目的 ViewController 传递到当前 ViewController，但是ViewModel 严格来讲不能引入任何 UIKit 的任何内容，不然ViewModel级就会失去其可测试性，所以我们通过引入服务总线的概念，维护一个NavigationController 的堆栈（这个思想来自于雷纯锋的博客中的一篇文章<a href=\"http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/\">MVVM With ReactiveCocoa</a>）具体实现如下</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;这个是协议声明部分</span><br><span class=\"line\">@protocol MRCNavigationProtocol &lt;NSObject&gt;</span><br><span class=\"line\">- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated;</span><br><span class=\"line\">- (void)popViewModelAnimated:(BOOL)animated;</span><br><span class=\"line\">- (void)popToRootViewModelAnimated:(BOOL)animated;</span><br><span class=\"line\">- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion;</span><br><span class=\"line\">- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion;</span><br><span class=\"line\">- (void)resetRootViewModel:(MRCViewModel *)viewModel;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>以下是方法的实现部分，没有写任何方法的实现过程，只是进行了空操作，目的是使用 Hook 思想去捕获操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)popViewModelAnimated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)popToRootViewModelAnimated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion &#123;&#125;</span><br><span class=\"line\">- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion &#123;&#125;</span><br><span class=\"line\">- (void)resetRootViewModel:(MRCViewModel *)viewModel &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>栈顶的 NavigationController 进行 Hook 并执行真正的跳转操作(使用到了 ReactiveCocoa， 因为要捕获的方法太多，这里只列举两条)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)registerNavigationHooks &#123;</span><br><span class=\"line\">  \t @weakify(self)</span><br><span class=\"line\">    [[(NSObject *)self.services</span><br><span class=\"line\">        rac_signalForSelector:@selector(pushViewModel:animated:)]</span><br><span class=\"line\">        subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">            @strongify(self)</span><br><span class=\"line\">            UIViewController *viewController &#x3D; (UIViewController *)[MRCRouter.sharedInstance viewControllerForViewModel:tuple.first];</span><br><span class=\"line\">            [self.navigationControllers.lastObject pushViewController:viewController animated:[tuple.second boolValue]];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    [[(NSObject *)self.services</span><br><span class=\"line\">        rac_signalForSelector:@selector(popViewModelAnimated:)]</span><br><span class=\"line\">        subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">          @strongify(self)</span><br><span class=\"line\">            [self.navigationControllers.lastObject popViewControllerAnimated:[tuple.first boolValue]];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际在 ViewController 里面调用起来就会是这种感觉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class=\"line\">    [tableView deselectRowAtIndexPath:indexPath animated:YES];</span><br><span class=\"line\">    if (indexPath.section &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">        MRCTrendingViewModel *trendingViewModel &#x3D; [[MRCTrendingViewModel alloc] initWithServices:self.viewModel.services params:nil];</span><br><span class=\"line\">        [self.viewModel.services pushViewModel:trendingViewModel animated:YES];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后看下将ViewModel与 ViewController 关联起来的 路由内的映射(截取部分)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSDictionary *)viewModelViewMappings &#123;</span><br><span class=\"line\">   return @&#123;</span><br><span class=\"line\">   \t   @&quot;MRCLoginViewModel&quot;: @&quot;MRCLoginViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCHomepageViewModel&quot;: @&quot;MRCHomepageViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCRepoDetailViewModel&quot;: @&quot;MRCRepoDetailViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCWebViewModel&quot;: @&quot;MRCWebViewController&quot;,</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然这上面的只是路由的实现方案1，纯粹地将 ViewController 与 ViewModel 关联起来，方案2是 建立一个路由层通过URL 的方式进行路由交互参考<a href=\"http://www.jianshu.com/p/3a902f274a3d\">一步步构建iOS路由</a>这部分我后面会讲讲我的思考。</p>"},{"title":"ipad和iphone使用UIAlertViewController","author":"Arclin","abbrlink":"f0080c3e","date":"2016-10-16T16:00:00.000Z","_content":"ipad和iphone使用UIAlertViewController\n\n```\nid aController;\n    if(DKDeviceiPad){\n    alertC.modalPresentationStyle = UIModalPresentationPopover;\n    UIPopoverPresentationController *popPc = alertC.popoverPresentationController;\n    popPc.barButtonItem = self.downloadItem;\n    popPc.permittedArrowDirections = UIPopoverArrowDirectionAny;\n    aController = alertC;\n}else{\n    aController = alertC;\n}\n[window.rootViewController presentViewController:aController animated:YES completion:nil];\n```","source":"_posts/ipad和iphone使用UIAlertViewController.md","raw":"---\ntitle: ipad和iphone使用UIAlertViewController\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: f0080c3e\ndate: 2016-10-17 00:00:00\n---\nipad和iphone使用UIAlertViewController\n\n```\nid aController;\n    if(DKDeviceiPad){\n    alertC.modalPresentationStyle = UIModalPresentationPopover;\n    UIPopoverPresentationController *popPc = alertC.popoverPresentationController;\n    popPc.barButtonItem = self.downloadItem;\n    popPc.permittedArrowDirections = UIPopoverArrowDirectionAny;\n    aController = alertC;\n}else{\n    aController = alertC;\n}\n[window.rootViewController presentViewController:aController animated:YES completion:nil];\n```","slug":"ipad和iphone使用UIAlertViewController","published":1,"updated":"2021-06-06T18:52:24.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyohz004ktnn0ajxq3ctq","content":"<p>ipad和iphone使用UIAlertViewController</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id aController;</span><br><span class=\"line\">    if(DKDeviceiPad)&#123;</span><br><span class=\"line\">    alertC.modalPresentationStyle &#x3D; UIModalPresentationPopover;</span><br><span class=\"line\">    UIPopoverPresentationController *popPc &#x3D; alertC.popoverPresentationController;</span><br><span class=\"line\">    popPc.barButtonItem &#x3D; self.downloadItem;</span><br><span class=\"line\">    popPc.permittedArrowDirections &#x3D; UIPopoverArrowDirectionAny;</span><br><span class=\"line\">    aController &#x3D; alertC;</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">    aController &#x3D; alertC;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[window.rootViewController presentViewController:aController animated:YES completion:nil];</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>ipad和iphone使用UIAlertViewController</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id aController;</span><br><span class=\"line\">    if(DKDeviceiPad)&#123;</span><br><span class=\"line\">    alertC.modalPresentationStyle &#x3D; UIModalPresentationPopover;</span><br><span class=\"line\">    UIPopoverPresentationController *popPc &#x3D; alertC.popoverPresentationController;</span><br><span class=\"line\">    popPc.barButtonItem &#x3D; self.downloadItem;</span><br><span class=\"line\">    popPc.permittedArrowDirections &#x3D; UIPopoverArrowDirectionAny;</span><br><span class=\"line\">    aController &#x3D; alertC;</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">    aController &#x3D; alertC;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[window.rootViewController presentViewController:aController animated:YES completion:nil];</span><br></pre></td></tr></table></figure>"},{"title":"iOS 底层原理 --- 方法、消息发送与super关键字","author":"Arclin","abbrlink":"5ed61a9","date":"2021-06-28T17:11:00.000Z","_content":"本文主要简述类（元类）对象里面的方法缓存、消息发送（包括消息发送，动态方法解析与消息转发）与super关键字的底层原理\n\n<!--more-->\n\n## 方法\n\n### Class对象的结构\n\n```objectivec\nstruct objc_class {\n    Class isa;\n    Class superclass;\n    cache_t cache; // 方法缓存\n    class_data_bits_t bits; // 用于获取具体的类信息\n}\n```\n\n其中`bits`成员变量与`FAST_DATA_MASK`进行一次与运算之后，会获得一个其属性可读可写的对象的地址，这个对象长这样\n\n```objectivec\nstruct class_rw_t {\n    uint32_t flags;\n    uint32_t version;\n    const clsss_ro_t *ro;\n    method_array_t * methods; // 方法列表\n    property_array_t *properties; // 属性列表\n    protocol_array_t protocols; // 协议列表\n    Class firstSubclass;\n    Class nextSiblingClass;\n    char *demangledName;\n}\n```\n\n其中 `class_ro_t`里面存放的是类的原始信息(不包括分类里面的东西)，是仅可读的，结构如下\n\n```objectivec\nstruct class_ro_t {\n    uint32_t flags;\n    unit32_t instanceStart;\n    uint32_t instanceSize; // instance对象占用的内存空间\n#ifdef __LP__64__\n    uint32_t reserved;\n#endif\n    const uint8_t *ivarLayout;\n    const char * name; // 类名\n    method_list_t * baseMethodList;\n    protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars; // 成员变量列表\n    const uint8_t * weakIverLayout;\n    property_list_t * baseProperties;\n}\n```\n\n\n### class_rw_t\n\n`class_rw_t`里面的methods、properties、protocols是二维数组，是可读可写的，比如方法列表随时可以新增`method_list_t`类型的数据进去。`class_rw_t`包含了类的初始内容和分类的内容，其中方法列表类似如下结构\n\n```objectivec\nmethod_array_t: [\n    method_list_t : [\n      method_t,\n      method_t,\n      method_t\n    ],\n    method_list_t : [\n      method_t,\n      method_t,\n      method_t\n    ],\n]\n```\n\n`objc_class`内有一个`data()`函数，其返回值一开始是指向`class_ro_t`类型的对象的。在合并分类内的内容时，才会产生`class_rw_t`类型的对象，并指向这个对象。可以参考runtime源码，`objc-runtime-new.mm`中`realizeClassWithoutSwift`函数的实现，这里贴出关键部分\n\n```objectivec\nstatic Class realizeClassWithoutSwift(Class cls, Class previously)\n{\n    ...\n    auto ro = (const class_ro_t *)cls->data();\n    auto isMeta = ro->flags & RO_META;\n    if (ro->flags & RO_FUTURE) {\n        // This was a future class. rw data is already allocated.\n        rw = cls->data();\n        ro = cls->data()->ro();\n        ASSERT(!isMeta);\n        cls->changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);\n    } else {\n        // Normal class. Allocate writeable class data.\n        rw = objc::zalloc<class_rw_t>();\n        rw->set_ro(ro);\n        rw->flags = RW_REALIZED|RW_REALIZING|isMeta;\n        cls->setData(rw);\n    }\n    ...\n}\n```\n\n### class_ro_t\n\n`class_ro_t`里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，所以不能新增内容，包含了类的初始内容，其中方法列表类似如下结构\n\n```\nmethod_list_t : [\n  method_t,\n  method_t,\n  method_t\n]\n```\n\n> 在runtime源码，`objc-runtime-new.mm`中的`attachCategories`方法中我们可以看到分类合并到`class_rw_t`对象的过程，比如方法的合并如下\n\n```\nmethod_list_t *mlist = entry.cat->methodsForMeta(isMeta);\nif (mlist) {\n    if (mcount == 64) {\n        prepareMethodLists(cls, mlists, mcount, NO, fromBundle, __func__);\n        rwe->methods.attachLists(mlists, mcount);\n        mcount = 0;\n    }\n    mlists[ATTACH_BUFSIZ - ++mcount] = mlist;\n    fromBundle |= entry.hi->isBundle();\n}\n```\n\n### method_t\n\n- `method_t`是对方法/函数的封装（下面是缩减版定义）\n\n```\nstruct method_t {\n    ...\n    SEL name(); // 函数名\n    const char *types(); // 编码（返回值类型、参数类型）\n    IMP imp(bool needsLock); // 指向函数的指针（函数地址）\n    ...\n}\n```\n\n- `IMP`代表具体函数的实现\n\n\t`typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);`\n\n- `SEL`可以代表方法\\函数名，一般叫做选择器，底层结构跟`char *`类似\n\t\n    `typedef struct objc_selector *SEL`;\n    - 可以通过`@selector()`和`sel_registerName()`获得\n\t- 可以通过`sel_getName()`和`NSStringFromSelector()`转成字符串\n\t- 不同类中相同名字的方法，所对应的方法选择器是相同的\n\n- `types`包含了函数返回值、参数编码的字符串，称作`Type Encodings`（类型编码），具体可以参考[苹果官方文档](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100)\n\n\t- 比如`-（void）test:(int)a;`的方法编码为`v@:i`，v = void,@表示指针变量(因为编译后第一个参数是self)，：表示选择器(因为编译后第二个参数是_cmd)，\n    - 有时类型编码会带上数字，比如`v16@0:8`，第一个数字表示这个函数的参数一共占用16个字节，第二个数字开始往后的数字都代表偏移值，0代表第一个参数的字节偏移值为0，第三个数字8代表偏移8个字节，也就是第一个参数已经占用了8个字节了，所以第二个参数就从第8个字节开始\n    \n### cache_t\n\n- Class内部结构中有个方法缓存（cache_t），用散列表来缓存曾经调用过的方法，可以提高方法的查找速度\n\n```objectivec\nstruct cache_t {\n    explicit_atomic<uintptr_t> _bucketsAndMaybeMask;\n    union {\n        struct {\n            explicit_atomic<mask_t>    _maybeMask; // 散列表的长度 - 1\n            uint16_t                   _flags;\n            uint16_t                   _occupied; // 已经缓存的方法数量\n        };\n        explicit_atomic<preopt_cache_t *> _originalPreoptCache;\n    };   \n    struct bucket_t *buckets() const;\n    mask_t mask() const;\n    mask_t occupied() const;\n};\n```\n\n其中，通过`buckets()`函数我们可以得知`_bucketsAndMaybeMask`是一个存放`bucket_t`数组的指针（即`_bucketsAndMaybeMask`指针指向的是数组的第一个元素），是通过位运算取出来的\n\n```objectivec\nstruct bucket_t *cache_t::buckets() const\n{\n    uintptr_t addr = _bucketsAndMaybeMask.load(memory_order_relaxed);\n    return (bucket_t *)(addr & bucketsMask);\n}\n```\n\n而`bucket_t`的结构如下\n\n```\nstruct bucket_t {\n    explicit_atomic<uintptr_t> _imp; \t// 函数的内存地址\n    explicit_atomic<SEL> _sel; // SEL作为key\n};\n```\n\n通过IMP和SEL，我们就可以调用方法了，所以综上所述，一个实例对象调用方法，其类对象从方法缓存里面找方法的大概流程就是\n\n```\n获取sel : class - isa - 偏移16个字节 - cache_t - buckets() - [bucket_t] - 计算出下标index - bucket_t - sel()\n获取imp : class - isa - 偏移16个字节 - cache_t - buckets() - [bucket_t] - 计算出下标index - bucket_t - imp(nil,cls)\n```\n\n另外`_bucketsAndMaybeMask`之所以叫这个名字是因为它不仅存放着`buckets`还存放着`maybeMask`，在arm64位真机环境下，取高16位，如下:\n\n```objectivec\nmask_t cache_t::mask() const\n{\n    uintptr_t maskAndBuckets = _bucketsAndMaybeMask.load(memory_order_relaxed);\n    //maskShift 为48,\n    return maskAndBuckets >> maskShift;\n}\n```\n\n#### 方法缓存的流程\n\n先看看runtime源码中，将方法插入缓存的函数（摘抄核心流程）\n\n```objectivec\nvoid cache_t::insert(SEL sel, IMP imp, id receiver)\n{\n    ...\n    //对_occupied赋值 + 1。首次 newOccupied = 1。\n    mask_t newOccupied = occupied() + 1;\n    //旧容量，（mask + 1） 或者 0\n    unsigned oldCapacity = capacity(), capacity = oldCapacity;\n    //是否为空，首次进入这里\n    if (slowpath(isConstantEmptyCache())) {\n        // Cache is read-only. Replace it.\n        //默认容量给4\n        if (!capacity) capacity = INIT_CACHE_SIZE;//1 << 2 = 4\n        //0 4 false 开辟新的容器空间。由于旧容器为空这里不需要释放传false。\n        reallocate(oldCapacity, capacity, /* freeOld */false);\n    }\n    //newOccupied + 1 (相当于 _occupied + 2) <= capacity * 3 / 4 容量够的时候什么都不做，直接插入。<=75%的容积正常插入，否则扩容。\n    //## ⚠️在arm64位的情况下，CACHE_END_MARKER 0 扩容条件为：7 / 8 87.5% 这个时候CACHE_ALLOW_FULL_UTILIZATION 为 1\n    else if (fastpath(newOccupied + CACHE_END_MARKER <= cache_fill_ratio(capacity))) {\n        // Cache is less than 3/4 or 7/8 full. Use it as-is.\n    }\n#if CACHE_ALLOW_FULL_UTILIZATION\n    //capacity <= 1<<3 (8), _occupied + 1（CACHE_END_MARKER为0） <= 容量。少于8个元素的时候允许100%占满。\n    else if (capacity <= FULL_UTILIZATION_CACHE_SIZE && newOccupied + CACHE_END_MARKER <= capacity) {\n        // Allow 100% cache utilization for small buckets. Use it as-is.\n    }\n#endif\n    //扩容\n    else {\n        //容量不为空返回 2倍的容量，否则返回4\n        capacity = capacity ? capacity * 2 : INIT_CACHE_SIZE;\n        //MAX_CACHE_SIZE 1<<16 = 2^16。最大缓存65536\n        if (capacity > MAX_CACHE_SIZE) {\n            capacity = MAX_CACHE_SIZE;\n        }\n        //开辟新的容器控件，释放旧的空间。\n        reallocate(oldCapacity, capacity, true);\n    }\n    //从_bucketsAndMaybeMask获取buckets\n    bucket_t *b = buckets();\n    mask_t m = capacity - 1;//首次是4-1\n    //计算插入的index\n    mask_t begin = cache_hash(sel, m);\n    mask_t i = begin;\n\n    // Scan for the first unused slot and insert there.\n    // There is guaranteed to be an empty slot.\n    //循环判断插入数据。\n    do {\n        //能走到这里大概率是cache不存在，所以这里走fastpath\n        if (fastpath(b[i].sel() == 0)) {\n            //Occupied + 1\n            incrementOccupied();\n            //buckets中插入bucket\n            b[i].set<Atomic, Encoded>(b, sel, imp, cls());\n            return;\n        }\n        //已经存在了，不进行任何处理。有可能是其它线程插入的。\n        if (b[i].sel() == sel) {\n            // The entry was added to the cache by some other thread\n            // before we grabbed the cacheUpdateLock.\n            return;\n        }\n        //cache_next为了防止hash冲突。再hash了一次（下文会讲到）。\n    } while (fastpath((i = cache_next(i, m)) != begin));\n    //异常处理\n    bad_cache(receiver, (SEL)sel);\n}\n```\n\n - 首次进入isConstantEmptyCache分支。会创建一个容量为4的空buckets。这个时候由于旧buckets不存在不需要释放所以参数传递false。\n - 当容量大于等于3/4或7/8的情况下扩容。arm64的条件下为7 / 8。\n - arm64条件下容量小于等于8的时候会占用100%才扩容。\n - 扩容是直接翻倍，默认值4。最大值MAX_CACHE_SIZE为216(65536)。在扩容的时候直接释放了旧值。\n - mask值为capacity - 1\n - 通过cache_hash（下文会提及的散列表算法）计算插入的index，后面会通过cache_next再进行计算hash解决冲突问题。\n - 循环判断通过b[i].set插入bucket数据。\n - **reallocate函数在开辟控件的同时，把缓存给直接清空了**，清空之后再把现在要缓存的方法放进去，所以扩容后occupied会为1。\n \n\n#### 散列表（哈希表）缓存\n\n- 方法缓存的容器，不是简单的数组，而是用散列表的方式进行存储。\n\n  假如现在散列表长度为10，那么mask（即cache_t里面的_maybeMask）就是10-1 = 9，当selector传进来的时候，会跟mask进行一次与运算，如下：\n\n  `@selector(personTest) & mask = 4`\n\n  假如得到的结果是4的话，那么就会插在列表的下标为4的位置，其他位置因为已经开辟好空间了，所以有值就放值，没值就NULL\n\n  这种列表的好处是，当想取到特定的bucket_t的时候，只需要把selector跟mask进行一次与运算，就可以直接得到下标，然后直接从列表取出，这样子就不用遍历查找了，大大节约了性能。\n\n  另外，由于与运算的特性，跟mask进行与运算之后的值，都不可能比mask更大，这样子就保证不会插入越界的位置。\n\n- 如果通过计算后的下标值，插入列表的时候发现已经有东西了那怎么办？\n\n\t这也就是所谓的Hash冲突。为了处理这种问题，系统会调用`cache_next`函数\n\t    \n\t```\n    static inline mask_t cache_next(mask_t i, mask_t mask) {\n        return i ? i-1 : mask;\n    }\n\t```\n\n\t也就是说如果`@selector(personTest) & mask = 4`的4已经有东西了，那么就取 4 - 1 = 3，如果3还有东西，就放在2的位置，如果2还有，就放在1，以此类推，如果直到0都还没有可以插入的位置，那么就从mask的位置开始找，也就是9，然后再找9看看是否可以插入，插不进去再找8，以此类推，找到为止。\n    \n    由于列表在存放数量达到容量的87.5%的时候就会两倍的扩容（arm64），扩容后又会清空缓存，所以一定能找到合适的位置插入的。\n    \n    \n## 消息发送机制\n\n调用一个不存在的方法的时候，他会经历这么一个流程\n\n消息发送 - （找不到方法的话） -> 动态方法解析 - （没有实现的话） -> 消息转发 -> （没有实现的话） -> 抛出异常\n\n### 消息发送\n\n假如我们这么调用一个方法\n\n```\n[person personTest];\n```\n\n底层会转换为\n\n```objectivec\nobjc_msgSend(person,sel_registerName(\"personTest\"));\n```\n\n- 这里的person我们称作消息接受者（receiver），就是调用方法的对象，如果这里还是调用类方法的话，那么这里就会传入一个类对象\n- `sel_registerName()`函数等价于`@selector`\n- 为了性能，`objc_msgSend`方法底层是使用汇编和C++实现的\n\n消息发送的流程如下：\n\n1. receiver 是否为空，如果是退出，否则继续\n2. 从receiver的类对象（如果传入的是类则找的是元类对象，下文统称为receiverClass）的cache中查找方法，如果找到则调用方法，如果找不到则继续\n3. 从receiverClass中的`class_rw_t`中查找方法，如果找到则调用方法，并将方法插入缓存，如果找不到则继续\n4. 从`superClass`的cache中查找方法，有则调用并缓存到当前receiverClass的cache中(不是superClass的cache),否则继续\n5. 从`superClass`的`class_rw_t`中找，有则调用并缓存到receiverClass的cache中，否则继续\n6. 继续通过`superClass`的`superClass`找方法，流程回到4，直到再也没有父类了，并且也找不到方法，那么将会进入动态方法解析阶段。\n\n其中：\n- 如果是从`class_rw_t`中查找方法，若方法列表已经排序好，那么就使用二分查找法查找\n- 如果是还没排序的方法，那么就使用遍历的方法查找\n- 在缓存中查找方法的过程也称作快速查找（使用汇编实现），在`class_rw_t`中查找方法的过程也称作慢速查找(使用汇编和C++实现)，C++部分方法源码在`lookUpImpOrForward`函数中，如下：\n\n```objectivec\nIMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)\n{\n    const IMP forward_imp = (IMP)_objc_msgForward_impcache;\n    IMP imp = nil;\n    Class curClass;\n    runtimeLock.assertUnlocked();\n    // Optimistic cache lookup\n    if (fastpath(behavior & LOOKUP_CACHE)) {\n        imp = cache_getImp(cls, sel);\n        if (imp) goto done_nolock;\n    }\n    runtimeLock.lock();\n    checkIsKnownClass(cls);\n    if (slowpath(!cls->isRealized())) {\n        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);\n    }\n    if (slowpath((behavior & LOOKUP_INITIALIZE) && !cls->isInitialized())) {\n        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);\n    }\n    runtimeLock.assertLocked();\n    curClass = cls;\n    for (unsigned attempts = unreasonableClassCount();;) {\n        // curClass method list.\n        Method meth = getMethodNoSuper_nolock(curClass, sel);\n        if (meth) {\n            imp = meth->imp;\n            goto done;\n        }\n        if (slowpath((curClass = curClass->superclass) == nil)) {\n            imp = forward_imp;\n            break;\n        }\n        if (slowpath(--attempts == 0)) {\n            _objc_fatal(\"Memory corruption in class list.\");\n        }\n\n        // Superclass cache.\n        imp = cache_getImp(curClass, sel);\n        if (slowpath(imp == forward_imp)) {\n            break;\n        }\n        if (fastpath(imp)) {\n            // Found the method in a superclass. Cache it in this class.\n            goto done;\n        }\n    }\n    if (slowpath(behavior & LOOKUP_RESOLVER)) {\n        behavior ^= LOOKUP_RESOLVER;\n        return resolveMethod_locked(inst, sel, cls, behavior);\n    }\n done:\n    log_and_fill_cache(cls, imp, sel, inst, curClass);\n    runtimeLock.unlock();\n done_nolock:\n    if (slowpath((behavior & LOOKUP_NIL) && imp == forward_imp)) {\n        return nil;\n    }\n    return imp;\n}\n```\n\n慢速查找流程图：\n\n<img src=\"https://p5-tt.byteimg.com/origin/pgc-image/47b512631098428e8bc60162e1df4ab7.png\" >\n\n消息发送流程图：\n\n<img src=\"https://p9-tt.byteimg.com/origin/pgc-image/70dfbbc7f61a4a9fac15e5ff1af809b4.png\">\n\n\n\n### 动态方法解析（也称：动态方法决议）\n\n当消息发送流程找不到方法后就会进入动态方法解析流程。\n\n动态方法解析是当消息发送阶段找不到方法的时候，开发者可以通过重写特定方法（如果是类方法就重写`+ (BOOL)resolveClassMethod:(SEL)sel`，如果是对象方法就重写`+ (BOOL)resolveInstanceMethod:(SEL)sel`），给原先不存在的方法添加方法实现。主要是用到runtime里面的`class_addMethod`函数，并且动态解析后，会重新走”消息发送“的流程\n\n#### 使用\n\n假如这里的person没有实现print方法\n\n```objectivec\nPerson *person = [Person new];\n[person print];\n```\n\n那我们可以在`Person.m`添加一个方法实现用来替换丢失的`print`，这里我们用`truePrint`来替代\n```objectivec\n- (void)truePrint {\n    NSLog(@\"true print\");\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    if (sel == @selector(print)) {\n        \n        // 获取truePrint方法的Method对象\n        Method truePrint = class_getInstanceMethod(self, @selector(truePrint));\n        \n        // 动态添加print方法的实现，通过method_getImplementation获取到方法的函数指针，通过method_getTypeEncoding拿到方法的函数编码即 v@: 或 v16@0:8\n        class_addMethod(self, sel, method_getImplementation(truePrint), method_getTypeEncoding(truePrint));\n        \n        // 返回YES代表有动态添加方法\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n```\n\n\n#### Method的结构\n\n\n点击Method我们可以看到结构如下\n```\ntypedef struct objc_method *Method;\n```\n\n而`ojbc_method`的定义如下\n\n```\nstruct objc_method {\n    SEL _Nonnull method_name;\t\n    char * _Nullable method_types;\n    IMP _Nonnull method_imp;\n}  \n```\n\n可以看到跟上面所说的`method_t`是类似的东西\n\n以下是一些拿到`Method`对象后可以使用的一些函数\n\n```objectivec\n// 函数调用，但是不接收返回值类型为结构体\nmethod_invoke\n// 函数调用，但是接收返回值类型为结构体\nmethod_invoke_stret\n// 获取函数名\nmethod_getName\n// 获取函数实现IMP\nmethod_getImplementation\n// 获取函数type encoding\nmethod_getTypeEncoding\n// 复制返回值类型\nmethod_copyReturnType\n// 复制参数类型\nmethod_copyArgumentType\n// 获取返回值类型\nmethod_getReturnType\n// 获取参数个数\nmethod_getNumberOfArguments\n// 获取函数参数类型\nmethod_getArgumentType\n// 获取函数描述\nmethod_getDescription\n// 设置函数实现IMP\nmethod_setImplementation\n// 交换函数的实现IMP\nmethod_exchangeImplementations\n```\n\n\n#### Runtime中的原理\n\n在上面的消息发送的流程函数`lookUpImpOrForward`中，有一段代码如下\n\n```\nif (slowpath(behavior & LOOKUP_RESOLVER)) {\n    behavior ^= LOOKUP_RESOLVER;\n    return resolveMethod_locked(inst, sel, cls, behavior);\n}\n```\n\n当找不到消息的时候就会进入动态方法解析的流程即`resolveMethod_locked`，如下\n\n```objectivec\nstatic NEVER_INLINE IMP resolveMethod_locked(id inst, SEL sel, Class cls, int behavior) {\n    runtimeLock.assertLocked();\n    ASSERT(cls->isRealized());\n\n    runtimeLock.unlock();\n\n    if (! cls->isMetaClass()) {\n        // try [cls resolveInstanceMethod:sel]\n        resolveInstanceMethod(inst, sel, cls);\n    } else {\n        // try [nonMetaClass resolveClassMethod:sel]\n        // and [cls resolveInstanceMethod:sel]\n        resolveClassMethod(inst, sel, cls);\n        if (!lookUpImpOrNilTryCache(inst, sel, cls)) {\n            resolveInstanceMethod(inst, sel, cls);\n        }\n    }\n\n    return lookUpImpOrForwardTryCache(inst, sel, cls, behavior);\n}\n```\n\n这里面我们可以发现`resolveInstanceMethod`和`resolveClassMethod`两个函数，分别是实现实例方法的动态消息解析和类方法的动态消息解析，这两个长得差不多，所以我们拿实例对象的函数查看一下\n\n```\nstatic void resolveInstanceMethod(id inst, SEL sel, Class cls)\n{\n    runtimeLock.assertUnlocked();\n    ASSERT(cls->isRealized());\n    SEL resolve_sel = @selector(resolveInstanceMethod:);\n\n    if (!lookUpImpOrNilTryCache(cls, resolve_sel, cls->ISA(/*authenticated*/true))) {\n        // Resolver not implemented.\n        return;\n    }\n\n    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;\n    bool resolved = msg(cls, resolve_sel, sel);\n\n    // Cache the result (good or bad) so the resolver doesn't fire next time.\n    // +resolveInstanceMethod adds to self a.k.a. cls\n    IMP imp = lookUpImpOrNilTryCache(inst, sel, cls);\n\n    if (resolved  &&  PrintResolving) {\n        if (imp) {\n            _objc_inform(\"RESOLVE: method %c[%s %s] \"\n                         \"dynamically resolved to %p\", \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel), imp);\n        }\n        else {\n            // Method resolver didn't add anything?\n            _objc_inform(\"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES\"\n                         \", but no new implementation of %c[%s %s] was found\",\n                         cls->nameForLogging(), sel_getName(sel), \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel));\n        }\n    }\n}\n```\n\n在这里我们可以看到对`resolveInstanceMethod`方法进行了一次`objc_msgSend`调用，调用之后又执行了`lookUpImpOrNilTryCache`函数进行了缓存，如果缓存成功，那么下次调用这个方法就不会在进入动态方法解析阶段，直接通过消息发送阶段就调用成功了。\n\n#### 优化\n\n根据我们以前所学的知识可以知道，方法查找的流程为\n\n实例方法：类 -- 父类 -- 父类 -- ... -- 根类 -- nil\n\n类方法：元类 -- 父元类 -- 父元类 -- ... -- 根元类 -- 根类 -- nil\n\n也就是说丢失的方法最后都会回到根类去找方法，一般情况下是`NSObject`\n\n通过这个特性，我们可以直接在`NSObject`上添加分类，然后实现动态解析方法，根据方法名前缀进行判断，然后统一处理未被找到的方法添加默认实现。通过这种方式我们可以减少一些找不到方法导致的崩溃问题，提升用户体验。\n\n\n### 消息转发\n\n如果没有实现动态方法解析，那么将进入消息转发阶段。消息转发即把消息交给别人发送的意思。\n\n从上面的`lookUpImpOrForward`函数的源码我们可以看到，最后是调用了`_objc_msgForward_impcache`这个函数，这个函数是通过汇编实现的\n\n要实现消息转发，我们有两种方式，一种是实现一个方法`-forwardingTargetForSelector`，一种是实现`-methodSignatureForSelector`和`-forwardInvocation`，比如\n\n```objectivec\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    if (aSelector == @selector(print)) {\n        return [[Student alloc] init];\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n```\n\n实现了这个方法之后，最后系统会去我们提供的`Student`对象去寻找`print`方法，找到了的话就会进行调用。注意这个方法每次都会进来，每次都会生成新的`Student`对象对其`print`方法进行调用。\n\n如果`forwardingTargetForSelector`没实现或者返回空的话\n\n```objectivec\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    if (aSelector == @selector(print)) {\n        return nil;\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n```\n\n那么就会寻找`-methodSignatureForSelector`和`-forwardInvocation`\n\n```objectivec\n/// 方法签名： 返回值类型、参数类型\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if (aSelector == @selector(print)) {\n        return [NSMethodSignature signatureWithObjCTypes:\"v16@0:8\"];\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n\n/// NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数\n/// anInvocation.target 方法调用者\n/// anInvocation.selector 方法名\n//// [anInvocation getArgument:NULL atIndex:0] 方法参数\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    [anInvocation invokeWithTarget:[[Student alloc] init]];\n}\n```\n\n首先我们在方法签名中指定方法类型，然后在`forwardInvocation`方法中，修改target，然后直接调用，这样子就会直接调用Student的print方法了\n\n<img src=\"https://p3-tt.byteimg.com/origin/pgc-image/ba2d1d5ff71a49c8913690d6f69fb7d7.png\" width=80%>\n\n#### NSInvocation\n\n当系统执行到`forwardInvocation`的时候，无论在方法内有任何实现，都不会执行到`doseNotRecognizeSelector`（抛出异常），所以实现了就不会崩，即便什么都不做。\n\n在`forwardInvocation`内我们可以拿到方法调用的很多信息，比如方法调用者`anInvocation.target`、方法名`anInvocation.selector`和方法参数\n\n比如调用方法为`[person print:1]`，进入到`forwardInvocation`后我们可以通过以下方法拿到`1`这个参数\n\n```objectivec\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    int a;\n    [anInvocation getArgument:&a atIndex:2]; // 第一个参数是self，第二个是_cmd，所以从下标2开始取\n}\n```\n\n如果要拿返回值的话，就可以这么做\n\n```objectivec\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    [anInvocation invokeWithTarget:[[Student alloc] init]]; // 要先调用一下Student的print方法，这里假设返回值是整型\n    int result;\n    [anInvocation getReturnValue:&result];\n    NSLog(@\"%d\",result); /// 这里可以拿到返回值\n}\n```\n\n#### NSMethodSignature\n\n`[NSMethodSignature signatureWithObjCTypes:\"v16@0:8\"]`，注意这里的方法编码要跟下面`forwardInvocation`要调用的方法的方法编码一致 \n\n我们除了可以通过方法编码拿到`NSMethodSignature`对象之外，还可以这么做\n\n```objectivec\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if (aSelector == @selector(print)) {\n        return [[Student new] methodSignatureForSelector:@selector(print)];\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n```\n\n#### 类方法的消息转发\n\n`+ (id)forwardingTargetForSelector:(SEL)aSelector`\n\n`+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector`\n\n`+ (void)forwardInvocation:(NSInvocation *)anInvocation`\n\n这几个方法也有类方法版本，但是代码补全没出来，但是实际使用是可行的\n\n`+ (id)forwardingTargetForSelector:(SEL)aSelector`在这个方法里面返回的消息接受者既可以是类对象也可以是实例对象。\n\n\n#### @synthesize 和 @dynamic\n\n`@synthesize`用来自动给成员变量名生成`setter`和`getter`的声明和实现\n\n`@dynamic`用来告诉编译器不要自动生成`setter`和`getter`的实现（声明还是会声明的），待到运行时开发者自己实现，并且不会为属性实现带下划线的成员变量\n\n\n## super\n\n假如我们调用`Student`实例的一个父类方法\n\n`[super run:xx]`\n\n那么编译后会变成如下代码\n\n`objc_msgSendSuper(self,class_getSuperclass(objc_getClass(\"Student\")),sel_registerName(\"run\"),xx);`\n\n所以`super`发送消息的本质是调用`objc_msgSendSuper2`函数，最终的消息接受者依旧是`self`，只是实例方法寻找从父类的类对象开始寻找，类方法从父类的元类对象开始寻找。\n\n所以当我们调用方法`[super class]`的时候，跟`[self class]`没区别，返回结果是一致的","source":"_posts/iOS-底层原理-方法缓存与消息发送机制.md","raw":"title: iOS 底层原理 --- 方法、消息发送与super关键字\nauthor: Arclin\ntags:\n  - iOS\n  - 底层原理\ncategories:\n  - iOS\nabbrlink: 5ed61a9\ndate: 2021-06-29 01:11:00\n---\n本文主要简述类（元类）对象里面的方法缓存、消息发送（包括消息发送，动态方法解析与消息转发）与super关键字的底层原理\n\n<!--more-->\n\n## 方法\n\n### Class对象的结构\n\n```objectivec\nstruct objc_class {\n    Class isa;\n    Class superclass;\n    cache_t cache; // 方法缓存\n    class_data_bits_t bits; // 用于获取具体的类信息\n}\n```\n\n其中`bits`成员变量与`FAST_DATA_MASK`进行一次与运算之后，会获得一个其属性可读可写的对象的地址，这个对象长这样\n\n```objectivec\nstruct class_rw_t {\n    uint32_t flags;\n    uint32_t version;\n    const clsss_ro_t *ro;\n    method_array_t * methods; // 方法列表\n    property_array_t *properties; // 属性列表\n    protocol_array_t protocols; // 协议列表\n    Class firstSubclass;\n    Class nextSiblingClass;\n    char *demangledName;\n}\n```\n\n其中 `class_ro_t`里面存放的是类的原始信息(不包括分类里面的东西)，是仅可读的，结构如下\n\n```objectivec\nstruct class_ro_t {\n    uint32_t flags;\n    unit32_t instanceStart;\n    uint32_t instanceSize; // instance对象占用的内存空间\n#ifdef __LP__64__\n    uint32_t reserved;\n#endif\n    const uint8_t *ivarLayout;\n    const char * name; // 类名\n    method_list_t * baseMethodList;\n    protocol_list_t * baseProtocols;\n    const ivar_list_t * ivars; // 成员变量列表\n    const uint8_t * weakIverLayout;\n    property_list_t * baseProperties;\n}\n```\n\n\n### class_rw_t\n\n`class_rw_t`里面的methods、properties、protocols是二维数组，是可读可写的，比如方法列表随时可以新增`method_list_t`类型的数据进去。`class_rw_t`包含了类的初始内容和分类的内容，其中方法列表类似如下结构\n\n```objectivec\nmethod_array_t: [\n    method_list_t : [\n      method_t,\n      method_t,\n      method_t\n    ],\n    method_list_t : [\n      method_t,\n      method_t,\n      method_t\n    ],\n]\n```\n\n`objc_class`内有一个`data()`函数，其返回值一开始是指向`class_ro_t`类型的对象的。在合并分类内的内容时，才会产生`class_rw_t`类型的对象，并指向这个对象。可以参考runtime源码，`objc-runtime-new.mm`中`realizeClassWithoutSwift`函数的实现，这里贴出关键部分\n\n```objectivec\nstatic Class realizeClassWithoutSwift(Class cls, Class previously)\n{\n    ...\n    auto ro = (const class_ro_t *)cls->data();\n    auto isMeta = ro->flags & RO_META;\n    if (ro->flags & RO_FUTURE) {\n        // This was a future class. rw data is already allocated.\n        rw = cls->data();\n        ro = cls->data()->ro();\n        ASSERT(!isMeta);\n        cls->changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);\n    } else {\n        // Normal class. Allocate writeable class data.\n        rw = objc::zalloc<class_rw_t>();\n        rw->set_ro(ro);\n        rw->flags = RW_REALIZED|RW_REALIZING|isMeta;\n        cls->setData(rw);\n    }\n    ...\n}\n```\n\n### class_ro_t\n\n`class_ro_t`里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，所以不能新增内容，包含了类的初始内容，其中方法列表类似如下结构\n\n```\nmethod_list_t : [\n  method_t,\n  method_t,\n  method_t\n]\n```\n\n> 在runtime源码，`objc-runtime-new.mm`中的`attachCategories`方法中我们可以看到分类合并到`class_rw_t`对象的过程，比如方法的合并如下\n\n```\nmethod_list_t *mlist = entry.cat->methodsForMeta(isMeta);\nif (mlist) {\n    if (mcount == 64) {\n        prepareMethodLists(cls, mlists, mcount, NO, fromBundle, __func__);\n        rwe->methods.attachLists(mlists, mcount);\n        mcount = 0;\n    }\n    mlists[ATTACH_BUFSIZ - ++mcount] = mlist;\n    fromBundle |= entry.hi->isBundle();\n}\n```\n\n### method_t\n\n- `method_t`是对方法/函数的封装（下面是缩减版定义）\n\n```\nstruct method_t {\n    ...\n    SEL name(); // 函数名\n    const char *types(); // 编码（返回值类型、参数类型）\n    IMP imp(bool needsLock); // 指向函数的指针（函数地址）\n    ...\n}\n```\n\n- `IMP`代表具体函数的实现\n\n\t`typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);`\n\n- `SEL`可以代表方法\\函数名，一般叫做选择器，底层结构跟`char *`类似\n\t\n    `typedef struct objc_selector *SEL`;\n    - 可以通过`@selector()`和`sel_registerName()`获得\n\t- 可以通过`sel_getName()`和`NSStringFromSelector()`转成字符串\n\t- 不同类中相同名字的方法，所对应的方法选择器是相同的\n\n- `types`包含了函数返回值、参数编码的字符串，称作`Type Encodings`（类型编码），具体可以参考[苹果官方文档](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100)\n\n\t- 比如`-（void）test:(int)a;`的方法编码为`v@:i`，v = void,@表示指针变量(因为编译后第一个参数是self)，：表示选择器(因为编译后第二个参数是_cmd)，\n    - 有时类型编码会带上数字，比如`v16@0:8`，第一个数字表示这个函数的参数一共占用16个字节，第二个数字开始往后的数字都代表偏移值，0代表第一个参数的字节偏移值为0，第三个数字8代表偏移8个字节，也就是第一个参数已经占用了8个字节了，所以第二个参数就从第8个字节开始\n    \n### cache_t\n\n- Class内部结构中有个方法缓存（cache_t），用散列表来缓存曾经调用过的方法，可以提高方法的查找速度\n\n```objectivec\nstruct cache_t {\n    explicit_atomic<uintptr_t> _bucketsAndMaybeMask;\n    union {\n        struct {\n            explicit_atomic<mask_t>    _maybeMask; // 散列表的长度 - 1\n            uint16_t                   _flags;\n            uint16_t                   _occupied; // 已经缓存的方法数量\n        };\n        explicit_atomic<preopt_cache_t *> _originalPreoptCache;\n    };   \n    struct bucket_t *buckets() const;\n    mask_t mask() const;\n    mask_t occupied() const;\n};\n```\n\n其中，通过`buckets()`函数我们可以得知`_bucketsAndMaybeMask`是一个存放`bucket_t`数组的指针（即`_bucketsAndMaybeMask`指针指向的是数组的第一个元素），是通过位运算取出来的\n\n```objectivec\nstruct bucket_t *cache_t::buckets() const\n{\n    uintptr_t addr = _bucketsAndMaybeMask.load(memory_order_relaxed);\n    return (bucket_t *)(addr & bucketsMask);\n}\n```\n\n而`bucket_t`的结构如下\n\n```\nstruct bucket_t {\n    explicit_atomic<uintptr_t> _imp; \t// 函数的内存地址\n    explicit_atomic<SEL> _sel; // SEL作为key\n};\n```\n\n通过IMP和SEL，我们就可以调用方法了，所以综上所述，一个实例对象调用方法，其类对象从方法缓存里面找方法的大概流程就是\n\n```\n获取sel : class - isa - 偏移16个字节 - cache_t - buckets() - [bucket_t] - 计算出下标index - bucket_t - sel()\n获取imp : class - isa - 偏移16个字节 - cache_t - buckets() - [bucket_t] - 计算出下标index - bucket_t - imp(nil,cls)\n```\n\n另外`_bucketsAndMaybeMask`之所以叫这个名字是因为它不仅存放着`buckets`还存放着`maybeMask`，在arm64位真机环境下，取高16位，如下:\n\n```objectivec\nmask_t cache_t::mask() const\n{\n    uintptr_t maskAndBuckets = _bucketsAndMaybeMask.load(memory_order_relaxed);\n    //maskShift 为48,\n    return maskAndBuckets >> maskShift;\n}\n```\n\n#### 方法缓存的流程\n\n先看看runtime源码中，将方法插入缓存的函数（摘抄核心流程）\n\n```objectivec\nvoid cache_t::insert(SEL sel, IMP imp, id receiver)\n{\n    ...\n    //对_occupied赋值 + 1。首次 newOccupied = 1。\n    mask_t newOccupied = occupied() + 1;\n    //旧容量，（mask + 1） 或者 0\n    unsigned oldCapacity = capacity(), capacity = oldCapacity;\n    //是否为空，首次进入这里\n    if (slowpath(isConstantEmptyCache())) {\n        // Cache is read-only. Replace it.\n        //默认容量给4\n        if (!capacity) capacity = INIT_CACHE_SIZE;//1 << 2 = 4\n        //0 4 false 开辟新的容器空间。由于旧容器为空这里不需要释放传false。\n        reallocate(oldCapacity, capacity, /* freeOld */false);\n    }\n    //newOccupied + 1 (相当于 _occupied + 2) <= capacity * 3 / 4 容量够的时候什么都不做，直接插入。<=75%的容积正常插入，否则扩容。\n    //## ⚠️在arm64位的情况下，CACHE_END_MARKER 0 扩容条件为：7 / 8 87.5% 这个时候CACHE_ALLOW_FULL_UTILIZATION 为 1\n    else if (fastpath(newOccupied + CACHE_END_MARKER <= cache_fill_ratio(capacity))) {\n        // Cache is less than 3/4 or 7/8 full. Use it as-is.\n    }\n#if CACHE_ALLOW_FULL_UTILIZATION\n    //capacity <= 1<<3 (8), _occupied + 1（CACHE_END_MARKER为0） <= 容量。少于8个元素的时候允许100%占满。\n    else if (capacity <= FULL_UTILIZATION_CACHE_SIZE && newOccupied + CACHE_END_MARKER <= capacity) {\n        // Allow 100% cache utilization for small buckets. Use it as-is.\n    }\n#endif\n    //扩容\n    else {\n        //容量不为空返回 2倍的容量，否则返回4\n        capacity = capacity ? capacity * 2 : INIT_CACHE_SIZE;\n        //MAX_CACHE_SIZE 1<<16 = 2^16。最大缓存65536\n        if (capacity > MAX_CACHE_SIZE) {\n            capacity = MAX_CACHE_SIZE;\n        }\n        //开辟新的容器控件，释放旧的空间。\n        reallocate(oldCapacity, capacity, true);\n    }\n    //从_bucketsAndMaybeMask获取buckets\n    bucket_t *b = buckets();\n    mask_t m = capacity - 1;//首次是4-1\n    //计算插入的index\n    mask_t begin = cache_hash(sel, m);\n    mask_t i = begin;\n\n    // Scan for the first unused slot and insert there.\n    // There is guaranteed to be an empty slot.\n    //循环判断插入数据。\n    do {\n        //能走到这里大概率是cache不存在，所以这里走fastpath\n        if (fastpath(b[i].sel() == 0)) {\n            //Occupied + 1\n            incrementOccupied();\n            //buckets中插入bucket\n            b[i].set<Atomic, Encoded>(b, sel, imp, cls());\n            return;\n        }\n        //已经存在了，不进行任何处理。有可能是其它线程插入的。\n        if (b[i].sel() == sel) {\n            // The entry was added to the cache by some other thread\n            // before we grabbed the cacheUpdateLock.\n            return;\n        }\n        //cache_next为了防止hash冲突。再hash了一次（下文会讲到）。\n    } while (fastpath((i = cache_next(i, m)) != begin));\n    //异常处理\n    bad_cache(receiver, (SEL)sel);\n}\n```\n\n - 首次进入isConstantEmptyCache分支。会创建一个容量为4的空buckets。这个时候由于旧buckets不存在不需要释放所以参数传递false。\n - 当容量大于等于3/4或7/8的情况下扩容。arm64的条件下为7 / 8。\n - arm64条件下容量小于等于8的时候会占用100%才扩容。\n - 扩容是直接翻倍，默认值4。最大值MAX_CACHE_SIZE为216(65536)。在扩容的时候直接释放了旧值。\n - mask值为capacity - 1\n - 通过cache_hash（下文会提及的散列表算法）计算插入的index，后面会通过cache_next再进行计算hash解决冲突问题。\n - 循环判断通过b[i].set插入bucket数据。\n - **reallocate函数在开辟控件的同时，把缓存给直接清空了**，清空之后再把现在要缓存的方法放进去，所以扩容后occupied会为1。\n \n\n#### 散列表（哈希表）缓存\n\n- 方法缓存的容器，不是简单的数组，而是用散列表的方式进行存储。\n\n  假如现在散列表长度为10，那么mask（即cache_t里面的_maybeMask）就是10-1 = 9，当selector传进来的时候，会跟mask进行一次与运算，如下：\n\n  `@selector(personTest) & mask = 4`\n\n  假如得到的结果是4的话，那么就会插在列表的下标为4的位置，其他位置因为已经开辟好空间了，所以有值就放值，没值就NULL\n\n  这种列表的好处是，当想取到特定的bucket_t的时候，只需要把selector跟mask进行一次与运算，就可以直接得到下标，然后直接从列表取出，这样子就不用遍历查找了，大大节约了性能。\n\n  另外，由于与运算的特性，跟mask进行与运算之后的值，都不可能比mask更大，这样子就保证不会插入越界的位置。\n\n- 如果通过计算后的下标值，插入列表的时候发现已经有东西了那怎么办？\n\n\t这也就是所谓的Hash冲突。为了处理这种问题，系统会调用`cache_next`函数\n\t    \n\t```\n    static inline mask_t cache_next(mask_t i, mask_t mask) {\n        return i ? i-1 : mask;\n    }\n\t```\n\n\t也就是说如果`@selector(personTest) & mask = 4`的4已经有东西了，那么就取 4 - 1 = 3，如果3还有东西，就放在2的位置，如果2还有，就放在1，以此类推，如果直到0都还没有可以插入的位置，那么就从mask的位置开始找，也就是9，然后再找9看看是否可以插入，插不进去再找8，以此类推，找到为止。\n    \n    由于列表在存放数量达到容量的87.5%的时候就会两倍的扩容（arm64），扩容后又会清空缓存，所以一定能找到合适的位置插入的。\n    \n    \n## 消息发送机制\n\n调用一个不存在的方法的时候，他会经历这么一个流程\n\n消息发送 - （找不到方法的话） -> 动态方法解析 - （没有实现的话） -> 消息转发 -> （没有实现的话） -> 抛出异常\n\n### 消息发送\n\n假如我们这么调用一个方法\n\n```\n[person personTest];\n```\n\n底层会转换为\n\n```objectivec\nobjc_msgSend(person,sel_registerName(\"personTest\"));\n```\n\n- 这里的person我们称作消息接受者（receiver），就是调用方法的对象，如果这里还是调用类方法的话，那么这里就会传入一个类对象\n- `sel_registerName()`函数等价于`@selector`\n- 为了性能，`objc_msgSend`方法底层是使用汇编和C++实现的\n\n消息发送的流程如下：\n\n1. receiver 是否为空，如果是退出，否则继续\n2. 从receiver的类对象（如果传入的是类则找的是元类对象，下文统称为receiverClass）的cache中查找方法，如果找到则调用方法，如果找不到则继续\n3. 从receiverClass中的`class_rw_t`中查找方法，如果找到则调用方法，并将方法插入缓存，如果找不到则继续\n4. 从`superClass`的cache中查找方法，有则调用并缓存到当前receiverClass的cache中(不是superClass的cache),否则继续\n5. 从`superClass`的`class_rw_t`中找，有则调用并缓存到receiverClass的cache中，否则继续\n6. 继续通过`superClass`的`superClass`找方法，流程回到4，直到再也没有父类了，并且也找不到方法，那么将会进入动态方法解析阶段。\n\n其中：\n- 如果是从`class_rw_t`中查找方法，若方法列表已经排序好，那么就使用二分查找法查找\n- 如果是还没排序的方法，那么就使用遍历的方法查找\n- 在缓存中查找方法的过程也称作快速查找（使用汇编实现），在`class_rw_t`中查找方法的过程也称作慢速查找(使用汇编和C++实现)，C++部分方法源码在`lookUpImpOrForward`函数中，如下：\n\n```objectivec\nIMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)\n{\n    const IMP forward_imp = (IMP)_objc_msgForward_impcache;\n    IMP imp = nil;\n    Class curClass;\n    runtimeLock.assertUnlocked();\n    // Optimistic cache lookup\n    if (fastpath(behavior & LOOKUP_CACHE)) {\n        imp = cache_getImp(cls, sel);\n        if (imp) goto done_nolock;\n    }\n    runtimeLock.lock();\n    checkIsKnownClass(cls);\n    if (slowpath(!cls->isRealized())) {\n        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);\n    }\n    if (slowpath((behavior & LOOKUP_INITIALIZE) && !cls->isInitialized())) {\n        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);\n    }\n    runtimeLock.assertLocked();\n    curClass = cls;\n    for (unsigned attempts = unreasonableClassCount();;) {\n        // curClass method list.\n        Method meth = getMethodNoSuper_nolock(curClass, sel);\n        if (meth) {\n            imp = meth->imp;\n            goto done;\n        }\n        if (slowpath((curClass = curClass->superclass) == nil)) {\n            imp = forward_imp;\n            break;\n        }\n        if (slowpath(--attempts == 0)) {\n            _objc_fatal(\"Memory corruption in class list.\");\n        }\n\n        // Superclass cache.\n        imp = cache_getImp(curClass, sel);\n        if (slowpath(imp == forward_imp)) {\n            break;\n        }\n        if (fastpath(imp)) {\n            // Found the method in a superclass. Cache it in this class.\n            goto done;\n        }\n    }\n    if (slowpath(behavior & LOOKUP_RESOLVER)) {\n        behavior ^= LOOKUP_RESOLVER;\n        return resolveMethod_locked(inst, sel, cls, behavior);\n    }\n done:\n    log_and_fill_cache(cls, imp, sel, inst, curClass);\n    runtimeLock.unlock();\n done_nolock:\n    if (slowpath((behavior & LOOKUP_NIL) && imp == forward_imp)) {\n        return nil;\n    }\n    return imp;\n}\n```\n\n慢速查找流程图：\n\n<img src=\"https://p5-tt.byteimg.com/origin/pgc-image/47b512631098428e8bc60162e1df4ab7.png\" >\n\n消息发送流程图：\n\n<img src=\"https://p9-tt.byteimg.com/origin/pgc-image/70dfbbc7f61a4a9fac15e5ff1af809b4.png\">\n\n\n\n### 动态方法解析（也称：动态方法决议）\n\n当消息发送流程找不到方法后就会进入动态方法解析流程。\n\n动态方法解析是当消息发送阶段找不到方法的时候，开发者可以通过重写特定方法（如果是类方法就重写`+ (BOOL)resolveClassMethod:(SEL)sel`，如果是对象方法就重写`+ (BOOL)resolveInstanceMethod:(SEL)sel`），给原先不存在的方法添加方法实现。主要是用到runtime里面的`class_addMethod`函数，并且动态解析后，会重新走”消息发送“的流程\n\n#### 使用\n\n假如这里的person没有实现print方法\n\n```objectivec\nPerson *person = [Person new];\n[person print];\n```\n\n那我们可以在`Person.m`添加一个方法实现用来替换丢失的`print`，这里我们用`truePrint`来替代\n```objectivec\n- (void)truePrint {\n    NSLog(@\"true print\");\n}\n\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n    if (sel == @selector(print)) {\n        \n        // 获取truePrint方法的Method对象\n        Method truePrint = class_getInstanceMethod(self, @selector(truePrint));\n        \n        // 动态添加print方法的实现，通过method_getImplementation获取到方法的函数指针，通过method_getTypeEncoding拿到方法的函数编码即 v@: 或 v16@0:8\n        class_addMethod(self, sel, method_getImplementation(truePrint), method_getTypeEncoding(truePrint));\n        \n        // 返回YES代表有动态添加方法\n        return YES;\n    }\n    return [super resolveInstanceMethod:sel];\n}\n```\n\n\n#### Method的结构\n\n\n点击Method我们可以看到结构如下\n```\ntypedef struct objc_method *Method;\n```\n\n而`ojbc_method`的定义如下\n\n```\nstruct objc_method {\n    SEL _Nonnull method_name;\t\n    char * _Nullable method_types;\n    IMP _Nonnull method_imp;\n}  \n```\n\n可以看到跟上面所说的`method_t`是类似的东西\n\n以下是一些拿到`Method`对象后可以使用的一些函数\n\n```objectivec\n// 函数调用，但是不接收返回值类型为结构体\nmethod_invoke\n// 函数调用，但是接收返回值类型为结构体\nmethod_invoke_stret\n// 获取函数名\nmethod_getName\n// 获取函数实现IMP\nmethod_getImplementation\n// 获取函数type encoding\nmethod_getTypeEncoding\n// 复制返回值类型\nmethod_copyReturnType\n// 复制参数类型\nmethod_copyArgumentType\n// 获取返回值类型\nmethod_getReturnType\n// 获取参数个数\nmethod_getNumberOfArguments\n// 获取函数参数类型\nmethod_getArgumentType\n// 获取函数描述\nmethod_getDescription\n// 设置函数实现IMP\nmethod_setImplementation\n// 交换函数的实现IMP\nmethod_exchangeImplementations\n```\n\n\n#### Runtime中的原理\n\n在上面的消息发送的流程函数`lookUpImpOrForward`中，有一段代码如下\n\n```\nif (slowpath(behavior & LOOKUP_RESOLVER)) {\n    behavior ^= LOOKUP_RESOLVER;\n    return resolveMethod_locked(inst, sel, cls, behavior);\n}\n```\n\n当找不到消息的时候就会进入动态方法解析的流程即`resolveMethod_locked`，如下\n\n```objectivec\nstatic NEVER_INLINE IMP resolveMethod_locked(id inst, SEL sel, Class cls, int behavior) {\n    runtimeLock.assertLocked();\n    ASSERT(cls->isRealized());\n\n    runtimeLock.unlock();\n\n    if (! cls->isMetaClass()) {\n        // try [cls resolveInstanceMethod:sel]\n        resolveInstanceMethod(inst, sel, cls);\n    } else {\n        // try [nonMetaClass resolveClassMethod:sel]\n        // and [cls resolveInstanceMethod:sel]\n        resolveClassMethod(inst, sel, cls);\n        if (!lookUpImpOrNilTryCache(inst, sel, cls)) {\n            resolveInstanceMethod(inst, sel, cls);\n        }\n    }\n\n    return lookUpImpOrForwardTryCache(inst, sel, cls, behavior);\n}\n```\n\n这里面我们可以发现`resolveInstanceMethod`和`resolveClassMethod`两个函数，分别是实现实例方法的动态消息解析和类方法的动态消息解析，这两个长得差不多，所以我们拿实例对象的函数查看一下\n\n```\nstatic void resolveInstanceMethod(id inst, SEL sel, Class cls)\n{\n    runtimeLock.assertUnlocked();\n    ASSERT(cls->isRealized());\n    SEL resolve_sel = @selector(resolveInstanceMethod:);\n\n    if (!lookUpImpOrNilTryCache(cls, resolve_sel, cls->ISA(/*authenticated*/true))) {\n        // Resolver not implemented.\n        return;\n    }\n\n    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;\n    bool resolved = msg(cls, resolve_sel, sel);\n\n    // Cache the result (good or bad) so the resolver doesn't fire next time.\n    // +resolveInstanceMethod adds to self a.k.a. cls\n    IMP imp = lookUpImpOrNilTryCache(inst, sel, cls);\n\n    if (resolved  &&  PrintResolving) {\n        if (imp) {\n            _objc_inform(\"RESOLVE: method %c[%s %s] \"\n                         \"dynamically resolved to %p\", \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel), imp);\n        }\n        else {\n            // Method resolver didn't add anything?\n            _objc_inform(\"RESOLVE: +[%s resolveInstanceMethod:%s] returned YES\"\n                         \", but no new implementation of %c[%s %s] was found\",\n                         cls->nameForLogging(), sel_getName(sel), \n                         cls->isMetaClass() ? '+' : '-', \n                         cls->nameForLogging(), sel_getName(sel));\n        }\n    }\n}\n```\n\n在这里我们可以看到对`resolveInstanceMethod`方法进行了一次`objc_msgSend`调用，调用之后又执行了`lookUpImpOrNilTryCache`函数进行了缓存，如果缓存成功，那么下次调用这个方法就不会在进入动态方法解析阶段，直接通过消息发送阶段就调用成功了。\n\n#### 优化\n\n根据我们以前所学的知识可以知道，方法查找的流程为\n\n实例方法：类 -- 父类 -- 父类 -- ... -- 根类 -- nil\n\n类方法：元类 -- 父元类 -- 父元类 -- ... -- 根元类 -- 根类 -- nil\n\n也就是说丢失的方法最后都会回到根类去找方法，一般情况下是`NSObject`\n\n通过这个特性，我们可以直接在`NSObject`上添加分类，然后实现动态解析方法，根据方法名前缀进行判断，然后统一处理未被找到的方法添加默认实现。通过这种方式我们可以减少一些找不到方法导致的崩溃问题，提升用户体验。\n\n\n### 消息转发\n\n如果没有实现动态方法解析，那么将进入消息转发阶段。消息转发即把消息交给别人发送的意思。\n\n从上面的`lookUpImpOrForward`函数的源码我们可以看到，最后是调用了`_objc_msgForward_impcache`这个函数，这个函数是通过汇编实现的\n\n要实现消息转发，我们有两种方式，一种是实现一个方法`-forwardingTargetForSelector`，一种是实现`-methodSignatureForSelector`和`-forwardInvocation`，比如\n\n```objectivec\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    if (aSelector == @selector(print)) {\n        return [[Student alloc] init];\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n```\n\n实现了这个方法之后，最后系统会去我们提供的`Student`对象去寻找`print`方法，找到了的话就会进行调用。注意这个方法每次都会进来，每次都会生成新的`Student`对象对其`print`方法进行调用。\n\n如果`forwardingTargetForSelector`没实现或者返回空的话\n\n```objectivec\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    if (aSelector == @selector(print)) {\n        return nil;\n    }\n    return [super forwardingTargetForSelector:aSelector];\n}\n```\n\n那么就会寻找`-methodSignatureForSelector`和`-forwardInvocation`\n\n```objectivec\n/// 方法签名： 返回值类型、参数类型\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if (aSelector == @selector(print)) {\n        return [NSMethodSignature signatureWithObjCTypes:\"v16@0:8\"];\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n\n/// NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数\n/// anInvocation.target 方法调用者\n/// anInvocation.selector 方法名\n//// [anInvocation getArgument:NULL atIndex:0] 方法参数\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    [anInvocation invokeWithTarget:[[Student alloc] init]];\n}\n```\n\n首先我们在方法签名中指定方法类型，然后在`forwardInvocation`方法中，修改target，然后直接调用，这样子就会直接调用Student的print方法了\n\n<img src=\"https://p3-tt.byteimg.com/origin/pgc-image/ba2d1d5ff71a49c8913690d6f69fb7d7.png\" width=80%>\n\n#### NSInvocation\n\n当系统执行到`forwardInvocation`的时候，无论在方法内有任何实现，都不会执行到`doseNotRecognizeSelector`（抛出异常），所以实现了就不会崩，即便什么都不做。\n\n在`forwardInvocation`内我们可以拿到方法调用的很多信息，比如方法调用者`anInvocation.target`、方法名`anInvocation.selector`和方法参数\n\n比如调用方法为`[person print:1]`，进入到`forwardInvocation`后我们可以通过以下方法拿到`1`这个参数\n\n```objectivec\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    int a;\n    [anInvocation getArgument:&a atIndex:2]; // 第一个参数是self，第二个是_cmd，所以从下标2开始取\n}\n```\n\n如果要拿返回值的话，就可以这么做\n\n```objectivec\n- (void)forwardInvocation:(NSInvocation *)anInvocation {\n    [anInvocation invokeWithTarget:[[Student alloc] init]]; // 要先调用一下Student的print方法，这里假设返回值是整型\n    int result;\n    [anInvocation getReturnValue:&result];\n    NSLog(@\"%d\",result); /// 这里可以拿到返回值\n}\n```\n\n#### NSMethodSignature\n\n`[NSMethodSignature signatureWithObjCTypes:\"v16@0:8\"]`，注意这里的方法编码要跟下面`forwardInvocation`要调用的方法的方法编码一致 \n\n我们除了可以通过方法编码拿到`NSMethodSignature`对象之外，还可以这么做\n\n```objectivec\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {\n    if (aSelector == @selector(print)) {\n        return [[Student new] methodSignatureForSelector:@selector(print)];\n    }\n    return [super methodSignatureForSelector:aSelector];\n}\n```\n\n#### 类方法的消息转发\n\n`+ (id)forwardingTargetForSelector:(SEL)aSelector`\n\n`+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector`\n\n`+ (void)forwardInvocation:(NSInvocation *)anInvocation`\n\n这几个方法也有类方法版本，但是代码补全没出来，但是实际使用是可行的\n\n`+ (id)forwardingTargetForSelector:(SEL)aSelector`在这个方法里面返回的消息接受者既可以是类对象也可以是实例对象。\n\n\n#### @synthesize 和 @dynamic\n\n`@synthesize`用来自动给成员变量名生成`setter`和`getter`的声明和实现\n\n`@dynamic`用来告诉编译器不要自动生成`setter`和`getter`的实现（声明还是会声明的），待到运行时开发者自己实现，并且不会为属性实现带下划线的成员变量\n\n\n## super\n\n假如我们调用`Student`实例的一个父类方法\n\n`[super run:xx]`\n\n那么编译后会变成如下代码\n\n`objc_msgSendSuper(self,class_getSuperclass(objc_getClass(\"Student\")),sel_registerName(\"run\"),xx);`\n\n所以`super`发送消息的本质是调用`objc_msgSendSuper2`函数，最终的消息接受者依旧是`self`，只是实例方法寻找从父类的类对象开始寻找，类方法从父类的元类对象开始寻找。\n\n所以当我们调用方法`[super class]`的时候，跟`[self class]`没区别，返回结果是一致的","slug":"iOS-底层原理-方法缓存与消息发送机制","published":1,"updated":"2021-08-25T16:05:35.774Z","_id":"ckqqxyohz004otnn07dej3062","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文主要简述类（元类）对象里面的方法缓存、消息发送（包括消息发送，动态方法解析与消息转发）与super关键字的底层原理</p>\n<span id=\"more\"></span>\n\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"Class对象的结构\"><a href=\"#Class对象的结构\" class=\"headerlink\" title=\"Class对象的结构\"></a>Class对象的结构</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_class &#123;</span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">    Class superclass;</span><br><span class=\"line\">    cache_t cache; <span class=\"comment\">// 方法缓存</span></span><br><span class=\"line\">    class_data_bits_t bits; <span class=\"comment\">// 用于获取具体的类信息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>bits</code>成员变量与<code>FAST_DATA_MASK</code>进行一次与运算之后，会获得一个其属性可读可写的对象的地址，这个对象长这样</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> class_rw_t &#123;</span><br><span class=\"line\">    uint32_t flags;</span><br><span class=\"line\">    uint32_t version;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> clsss_ro_t *ro;</span><br><span class=\"line\">    method_array_t * methods; <span class=\"comment\">// 方法列表</span></span><br><span class=\"line\">    property_array_t *properties; <span class=\"comment\">// 属性列表</span></span><br><span class=\"line\">    protocol_array_t protocols; <span class=\"comment\">// 协议列表</span></span><br><span class=\"line\">    Class firstSubclass;</span><br><span class=\"line\">    Class nextSiblingClass;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *demangledName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>class_ro_t</code>里面存放的是类的原始信息(不包括分类里面的东西)，是仅可读的，结构如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> class_ro_t &#123;</span><br><span class=\"line\">    uint32_t flags;</span><br><span class=\"line\">    unit32_t instanceStart;</span><br><span class=\"line\">    uint32_t instanceSize; <span class=\"comment\">// instance对象占用的内存空间</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __LP__64__</span></span><br><span class=\"line\">    uint32_t reserved;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> uint8_t *ivarLayout;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * name; <span class=\"comment\">// 类名</span></span><br><span class=\"line\">    method_list_t * baseMethodList;</span><br><span class=\"line\">    protocol_list_t * baseProtocols;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ivar_list_t * ivars; <span class=\"comment\">// 成员变量列表</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> uint8_t * weakIverLayout;</span><br><span class=\"line\">    property_list_t * baseProperties;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"class-rw-t\"><a href=\"#class-rw-t\" class=\"headerlink\" title=\"class_rw_t\"></a>class_rw_t</h3><p><code>class_rw_t</code>里面的methods、properties、protocols是二维数组，是可读可写的，比如方法列表随时可以新增<code>method_list_t</code>类型的数据进去。<code>class_rw_t</code>包含了类的初始内容和分类的内容，其中方法列表类似如下结构</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">method_array_t: [</span><br><span class=\"line\">    method_list_t : [</span><br><span class=\"line\">      method_t,</span><br><span class=\"line\">      method_t,</span><br><span class=\"line\">      method_t</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    method_list_t : [</span><br><span class=\"line\">      method_t,</span><br><span class=\"line\">      method_t,</span><br><span class=\"line\">      method_t</span><br><span class=\"line\">    ],</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p><code>objc_class</code>内有一个<code>data()</code>函数，其返回值一开始是指向<code>class_ro_t</code>类型的对象的。在合并分类内的内容时，才会产生<code>class_rw_t</code>类型的对象，并指向这个对象。可以参考runtime源码，<code>objc-runtime-new.mm</code>中<code>realizeClassWithoutSwift</code>函数的实现，这里贴出关键部分</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Class realizeClassWithoutSwift(Class cls, Class previously)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    auto ro = (<span class=\"keyword\">const</span> class_ro_t *)cls-&gt;data();</span><br><span class=\"line\">    auto isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// This was a future class. rw data is already allocated.</span></span><br><span class=\"line\">        rw = cls-&gt;data();</span><br><span class=\"line\">        ro = cls-&gt;data()-&gt;ro();</span><br><span class=\"line\">        ASSERT(!isMeta);</span><br><span class=\"line\">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Normal class. Allocate writeable class data.</span></span><br><span class=\"line\">        rw = objc::zalloc&lt;class_rw_t&gt;();</span><br><span class=\"line\">        rw-&gt;set_ro(ro);</span><br><span class=\"line\">        rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class=\"line\">        cls-&gt;setData(rw);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"class-ro-t\"><a href=\"#class-ro-t\" class=\"headerlink\" title=\"class_ro_t\"></a>class_ro_t</h3><p><code>class_ro_t</code>里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，所以不能新增内容，包含了类的初始内容，其中方法列表类似如下结构</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">method_list_t</span> : [</span><br><span class=\"line\">  <span class=\"keyword\">method_t</span>,</span><br><span class=\"line\">  <span class=\"keyword\">method_t</span>,</span><br><span class=\"line\">  <span class=\"keyword\">method_t</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在runtime源码，<code>objc-runtime-new.mm</code>中的<code>attachCategories</code>方法中我们可以看到分类合并到<code>class_rw_t</code>对象的过程，比如方法的合并如下</p>\n</blockquote>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">method_list_t *mlist = entry.cat-&gt;methods<span class=\"constructor\">ForMeta(<span class=\"params\">isMeta</span>)</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mlist) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mcount<span class=\"operator\"> == </span><span class=\"number\">64</span>) &#123;</span><br><span class=\"line\">        prepare<span class=\"constructor\">MethodLists(<span class=\"params\">cls</span>, <span class=\"params\">mlists</span>, <span class=\"params\">mcount</span>, NO, <span class=\"params\">fromBundle</span>, <span class=\"params\">__func__</span>)</span>;</span><br><span class=\"line\">        rwe-&gt;methods.attach<span class=\"constructor\">Lists(<span class=\"params\">mlists</span>, <span class=\"params\">mcount</span>)</span>;</span><br><span class=\"line\">        mcount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mlists<span class=\"literal\">[ATTACH<span class=\"identifier\">_BUFSIZ</span> - <span class=\"operator\">++</span><span class=\"identifier\">mcount</span>]</span> = mlist;</span><br><span class=\"line\">    fromBundle <span class=\"pattern-match\">|= entry.hi-&gt;is<span class=\"constructor\">Bundle()</span>;</span></span><br><span class=\"line\"><span class=\"pattern-match\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"method-t\"><a href=\"#method-t\" class=\"headerlink\" title=\"method_t\"></a>method_t</h3><ul>\n<li><code>method_t</code>是对方法/函数的封装（下面是缩减版定义）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_t</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\">SEL <span class=\"title\">name</span><span class=\"params\">()</span></span>; <span class=\"comment\">// 函数名</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *<span class=\"title\">types</span><span class=\"params\">()</span></span>; <span class=\"comment\">// 编码（返回值类型、参数类型）</span></span><br><span class=\"line\">    <span class=\"function\">IMP <span class=\"title\">imp</span><span class=\"params\">(<span class=\"keyword\">bool</span> needsLock)</span></span>; <span class=\"comment\">// 指向函数的指针（函数地址）</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>IMP</code>代表具体函数的实现</p>\n<p>  <code>typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</code></p>\n</li>\n<li><p><code>SEL</code>可以代表方法\\函数名，一般叫做选择器，底层结构跟<code>char *</code>类似</p>\n<p>  <code>typedef struct objc_selector *SEL</code>;</p>\n<ul>\n<li>可以通过<code>@selector()</code>和<code>sel_registerName()</code>获得</li>\n<li>可以通过<code>sel_getName()</code>和<code>NSStringFromSelector()</code>转成字符串</li>\n<li>不同类中相同名字的方法，所对应的方法选择器是相同的</li>\n</ul>\n</li>\n<li><p><code>types</code>包含了函数返回值、参数编码的字符串，称作<code>Type Encodings</code>（类型编码），具体可以参考<a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100\">苹果官方文档</a></p>\n<ul>\n<li>比如<code>-（void）test:(int)a;</code>的方法编码为<code>v@:i</code>，v = void,@表示指针变量(因为编译后第一个参数是self)，：表示选择器(因为编译后第二个参数是_cmd)，</li>\n<li>有时类型编码会带上数字，比如<code>v16@0:8</code>，第一个数字表示这个函数的参数一共占用16个字节，第二个数字开始往后的数字都代表偏移值，0代表第一个参数的字节偏移值为0，第三个数字8代表偏移8个字节，也就是第一个参数已经占用了8个字节了，所以第二个参数就从第8个字节开始</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"cache-t\"><a href=\"#cache-t\" class=\"headerlink\" title=\"cache_t\"></a>cache_t</h3><ul>\n<li>Class内部结构中有个方法缓存（cache_t），用散列表来缓存曾经调用过的方法，可以提高方法的查找速度</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> cache_t &#123;</span><br><span class=\"line\">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;</span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">            explicit_atomic&lt;mask_t&gt;    _maybeMask; <span class=\"comment\">// 散列表的长度 - 1</span></span><br><span class=\"line\">            uint16_t                   _flags;</span><br><span class=\"line\">            uint16_t                   _occupied; <span class=\"comment\">// 已经缓存的方法数量</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;</span><br><span class=\"line\">    &#125;;   </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> bucket_t *buckets() <span class=\"keyword\">const</span>;</span><br><span class=\"line\">    mask_t mask() <span class=\"keyword\">const</span>;</span><br><span class=\"line\">    mask_t occupied() <span class=\"keyword\">const</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其中，通过<code>buckets()</code>函数我们可以得知<code>_bucketsAndMaybeMask</code>是一个存放<code>bucket_t</code>数组的指针（即<code>_bucketsAndMaybeMask</code>指针指向的是数组的第一个元素），是通过位运算取出来的</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> bucket_t *cache_t::buckets() <span class=\"keyword\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    uintptr_t addr = _bucketsAndMaybeMask.load(memory_order_relaxed);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (bucket_t *)(addr &amp; bucketsMask);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而<code>bucket_t</code>的结构如下</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct <span class=\"class\">bucket_t </span>&#123;</span><br><span class=\"line\">    explicit_atomic<span class=\"params\">&lt;uintptr_t&gt;</span> _imp; \t<span class=\"comment\">// 函数的内存地址</span></span><br><span class=\"line\">    explicit_atomic<span class=\"params\">&lt;SEL&gt;</span> _sel; <span class=\"comment\">// SEL作为key</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>通过IMP和SEL，我们就可以调用方法了，所以综上所述，一个实例对象调用方法，其类对象从方法缓存里面找方法的大概流程就是</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">获取sel : class - isa - 偏移<span class=\"number\">16</span>个字节 - <span class=\"keyword\">cache_t </span>- <span class=\"keyword\">buckets() </span>- [<span class=\"keyword\">bucket_t] </span>- 计算出下标index - <span class=\"keyword\">bucket_t </span>- sel()</span><br><span class=\"line\">获取imp : class - isa - 偏移<span class=\"number\">16</span>个字节 - <span class=\"keyword\">cache_t </span>- <span class=\"keyword\">buckets() </span>- [<span class=\"keyword\">bucket_t] </span>- 计算出下标index - <span class=\"keyword\">bucket_t </span>- imp(nil,cls)</span><br></pre></td></tr></table></figure>\n\n<p>另外<code>_bucketsAndMaybeMask</code>之所以叫这个名字是因为它不仅存放着<code>buckets</code>还存放着<code>maybeMask</code>，在arm64位真机环境下，取高16位，如下:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mask_t cache_t::mask() <span class=\"keyword\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    uintptr_t maskAndBuckets = _bucketsAndMaybeMask.load(memory_order_relaxed);</span><br><span class=\"line\">    <span class=\"comment\">//maskShift 为48,</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maskAndBuckets &gt;&gt; maskShift;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法缓存的流程\"><a href=\"#方法缓存的流程\" class=\"headerlink\" title=\"方法缓存的流程\"></a>方法缓存的流程</h4><p>先看看runtime源码中，将方法插入缓存的函数（摘抄核心流程）</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> cache_t::insert(SEL sel, IMP imp, <span class=\"keyword\">id</span> receiver)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//对_occupied赋值 + 1。首次 newOccupied = 1。</span></span><br><span class=\"line\">    mask_t newOccupied = occupied() + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//旧容量，（mask + 1） 或者 0</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> oldCapacity = capacity(), capacity = oldCapacity;</span><br><span class=\"line\">    <span class=\"comment\">//是否为空，首次进入这里</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(isConstantEmptyCache())) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Cache is read-only. Replace it.</span></span><br><span class=\"line\">        <span class=\"comment\">//默认容量给4</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!capacity) capacity = INIT_CACHE_SIZE;<span class=\"comment\">//1 &lt;&lt; 2 = 4</span></span><br><span class=\"line\">        <span class=\"comment\">//0 4 false 开辟新的容器空间。由于旧容器为空这里不需要释放传false。</span></span><br><span class=\"line\">        reallocate(oldCapacity, capacity, <span class=\"comment\">/* freeOld */</span><span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//newOccupied + 1 (相当于 _occupied + 2) &lt;= capacity * 3 / 4 容量够的时候什么都不做，直接插入。&lt;=75%的容积正常插入，否则扩容。</span></span><br><span class=\"line\">    <span class=\"comment\">//## ⚠️在arm64位的情况下，CACHE_END_MARKER 0 扩容条件为：7 / 8 87.5% 这个时候CACHE_ALLOW_FULL_UTILIZATION 为 1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fastpath(newOccupied + <span class=\"built_in\">CACHE_END_MARKER</span> &lt;= cache_fill_ratio(capacity))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Cache is less than 3/4 or 7/8 full. Use it as-is.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> CACHE_ALLOW_FULL_UTILIZATION</span></span><br><span class=\"line\">    <span class=\"comment\">//capacity &lt;= 1&lt;&lt;3 (8), _occupied + 1（CACHE_END_MARKER为0） &lt;= 容量。少于8个元素的时候允许100%占满。</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (capacity &lt;= FULL_UTILIZATION_CACHE_SIZE &amp;&amp; newOccupied + <span class=\"built_in\">CACHE_END_MARKER</span> &lt;= capacity) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Allow 100% cache utilization for small buckets. Use it as-is.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">//扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//容量不为空返回 2倍的容量，否则返回4</span></span><br><span class=\"line\">        capacity = capacity ? capacity * <span class=\"number\">2</span> : INIT_CACHE_SIZE;</span><br><span class=\"line\">        <span class=\"comment\">//MAX_CACHE_SIZE 1&lt;&lt;16 = 2^16。最大缓存65536</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class=\"line\">            capacity = MAX_CACHE_SIZE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//开辟新的容器控件，释放旧的空间。</span></span><br><span class=\"line\">        reallocate(oldCapacity, capacity, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//从_bucketsAndMaybeMask获取buckets</span></span><br><span class=\"line\">    bucket_t *b = buckets();</span><br><span class=\"line\">    mask_t m = capacity - <span class=\"number\">1</span>;<span class=\"comment\">//首次是4-1</span></span><br><span class=\"line\">    <span class=\"comment\">//计算插入的index</span></span><br><span class=\"line\">    mask_t begin = cache_hash(sel, m);</span><br><span class=\"line\">    mask_t i = begin;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Scan for the first unused slot and insert there.</span></span><br><span class=\"line\">    <span class=\"comment\">// There is guaranteed to be an empty slot.</span></span><br><span class=\"line\">    <span class=\"comment\">//循环判断插入数据。</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//能走到这里大概率是cache不存在，所以这里走fastpath</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fastpath(b[i].sel() == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//Occupied + 1</span></span><br><span class=\"line\">            incrementOccupied();</span><br><span class=\"line\">            <span class=\"comment\">//buckets中插入bucket</span></span><br><span class=\"line\">            b[i].set&lt;Atomic, Encoded&gt;(b, sel, imp, cls());</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//已经存在了，不进行任何处理。有可能是其它线程插入的。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[i].sel() == sel) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The entry was added to the cache by some other thread</span></span><br><span class=\"line\">            <span class=\"comment\">// before we grabbed the cacheUpdateLock.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//cache_next为了防止hash冲突。再hash了一次（下文会讲到）。</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (fastpath((i = cache_next(i, m)) != begin));</span><br><span class=\"line\">    <span class=\"comment\">//异常处理</span></span><br><span class=\"line\">    bad_cache(receiver, (SEL)sel);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>首次进入isConstantEmptyCache分支。会创建一个容量为4的空buckets。这个时候由于旧buckets不存在不需要释放所以参数传递false。</li>\n<li>当容量大于等于3/4或7/8的情况下扩容。arm64的条件下为7 / 8。</li>\n<li>arm64条件下容量小于等于8的时候会占用100%才扩容。</li>\n<li>扩容是直接翻倍，默认值4。最大值MAX_CACHE_SIZE为216(65536)。在扩容的时候直接释放了旧值。</li>\n<li>mask值为capacity - 1</li>\n<li>通过cache_hash（下文会提及的散列表算法）计算插入的index，后面会通过cache_next再进行计算hash解决冲突问题。</li>\n<li>循环判断通过b[i].set插入bucket数据。</li>\n<li><strong>reallocate函数在开辟控件的同时，把缓存给直接清空了</strong>，清空之后再把现在要缓存的方法放进去，所以扩容后occupied会为1。</li>\n</ul>\n<h4 id=\"散列表（哈希表）缓存\"><a href=\"#散列表（哈希表）缓存\" class=\"headerlink\" title=\"散列表（哈希表）缓存\"></a>散列表（哈希表）缓存</h4><ul>\n<li><p>方法缓存的容器，不是简单的数组，而是用散列表的方式进行存储。</p>\n<p>假如现在散列表长度为10，那么mask（即cache_t里面的_maybeMask）就是10-1 = 9，当selector传进来的时候，会跟mask进行一次与运算，如下：</p>\n<p><code>@selector(personTest) &amp; mask = 4</code></p>\n<p>假如得到的结果是4的话，那么就会插在列表的下标为4的位置，其他位置因为已经开辟好空间了，所以有值就放值，没值就NULL</p>\n<p>这种列表的好处是，当想取到特定的bucket_t的时候，只需要把selector跟mask进行一次与运算，就可以直接得到下标，然后直接从列表取出，这样子就不用遍历查找了，大大节约了性能。</p>\n<p>另外，由于与运算的特性，跟mask进行与运算之后的值，都不可能比mask更大，这样子就保证不会插入越界的位置。</p>\n</li>\n<li><p>如果通过计算后的下标值，插入列表的时候发现已经有东西了那怎么办？</p>\n<p>  这也就是所谓的Hash冲突。为了处理这种问题，系统会调用<code>cache_next</code>函数</p>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">mask_t</span> <span class=\"title\">cache_next</span><span class=\"params\">(<span class=\"keyword\">mask_t</span> i, <span class=\"keyword\">mask_t</span> mask)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i ? i<span class=\"number\">-1</span> : mask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  也就是说如果<code>@selector(personTest) &amp; mask = 4</code>的4已经有东西了，那么就取 4 - 1 = 3，如果3还有东西，就放在2的位置，如果2还有，就放在1，以此类推，如果直到0都还没有可以插入的位置，那么就从mask的位置开始找，也就是9，然后再找9看看是否可以插入，插不进去再找8，以此类推，找到为止。</p>\n<p>  由于列表在存放数量达到容量的87.5%的时候就会两倍的扩容（arm64），扩容后又会清空缓存，所以一定能找到合适的位置插入的。</p>\n</li>\n</ul>\n<h2 id=\"消息发送机制\"><a href=\"#消息发送机制\" class=\"headerlink\" title=\"消息发送机制\"></a>消息发送机制</h2><p>调用一个不存在的方法的时候，他会经历这么一个流程</p>\n<p>消息发送 - （找不到方法的话） -&gt; 动态方法解析 - （没有实现的话） -&gt; 消息转发 -&gt; （没有实现的话） -&gt; 抛出异常</p>\n<h3 id=\"消息发送\"><a href=\"#消息发送\" class=\"headerlink\" title=\"消息发送\"></a>消息发送</h3><p>假如我们这么调用一个方法</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[person personTest]</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>底层会转换为</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_msgSend(person,sel_registerName(<span class=\"string\">&quot;personTest&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这里的person我们称作消息接受者（receiver），就是调用方法的对象，如果这里还是调用类方法的话，那么这里就会传入一个类对象</li>\n<li><code>sel_registerName()</code>函数等价于<code>@selector</code></li>\n<li>为了性能，<code>objc_msgSend</code>方法底层是使用汇编和C++实现的</li>\n</ul>\n<p>消息发送的流程如下：</p>\n<ol>\n<li>receiver 是否为空，如果是退出，否则继续</li>\n<li>从receiver的类对象（如果传入的是类则找的是元类对象，下文统称为receiverClass）的cache中查找方法，如果找到则调用方法，如果找不到则继续</li>\n<li>从receiverClass中的<code>class_rw_t</code>中查找方法，如果找到则调用方法，并将方法插入缓存，如果找不到则继续</li>\n<li>从<code>superClass</code>的cache中查找方法，有则调用并缓存到当前receiverClass的cache中(不是superClass的cache),否则继续</li>\n<li>从<code>superClass</code>的<code>class_rw_t</code>中找，有则调用并缓存到receiverClass的cache中，否则继续</li>\n<li>继续通过<code>superClass</code>的<code>superClass</code>找方法，流程回到4，直到再也没有父类了，并且也找不到方法，那么将会进入动态方法解析阶段。</li>\n</ol>\n<p>其中：</p>\n<ul>\n<li>如果是从<code>class_rw_t</code>中查找方法，若方法列表已经排序好，那么就使用二分查找法查找</li>\n<li>如果是还没排序的方法，那么就使用遍历的方法查找</li>\n<li>在缓存中查找方法的过程也称作快速查找（使用汇编实现），在<code>class_rw_t</code>中查找方法的过程也称作慢速查找(使用汇编和C++实现)，C++部分方法源码在<code>lookUpImpOrForward</code>函数中，如下：</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IMP lookUpImpOrForward(<span class=\"keyword\">id</span> inst, SEL sel, Class cls, <span class=\"keyword\">int</span> behavior)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> IMP forward_imp = (IMP)_objc_msgForward_impcache;</span><br><span class=\"line\">    IMP imp = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    Class curClass;</span><br><span class=\"line\">    runtimeLock.assertUnlocked();</span><br><span class=\"line\">    <span class=\"comment\">// Optimistic cache lookup</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fastpath(behavior &amp; LOOKUP_CACHE)) &#123;</span><br><span class=\"line\">        imp = cache_getImp(cls, sel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (imp) <span class=\"keyword\">goto</span> done_nolock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    runtimeLock.lock();</span><br><span class=\"line\">    checkIsKnownClass(cls);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(!cls-&gt;isRealized())) &#123;</span><br><span class=\"line\">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</span><br><span class=\"line\">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    runtimeLock.assertLocked();</span><br><span class=\"line\">    curClass = cls;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> attempts = unreasonableClassCount();;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// curClass method list.</span></span><br><span class=\"line\">        Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (meth) &#123;</span><br><span class=\"line\">            imp = meth-&gt;imp;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowpath((curClass = curClass-&gt;superclass) == <span class=\"literal\">nil</span>)) &#123;</span><br><span class=\"line\">            imp = forward_imp;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowpath(--attempts == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            _objc_fatal(<span class=\"string\">&quot;Memory corruption in class list.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Superclass cache.</span></span><br><span class=\"line\">        imp = cache_getImp(curClass, sel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowpath(imp == forward_imp)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fastpath(imp)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Found the method in a superclass. Cache it in this class.</span></span><br><span class=\"line\">            <span class=\"keyword\">goto</span> done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class=\"line\">        behavior ^= LOOKUP_RESOLVER;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> done:</span><br><span class=\"line\">    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class=\"line\">    runtimeLock.unlock();</span><br><span class=\"line\"> done_nolock:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> imp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>慢速查找流程图：</p>\n<img src=\"https://p5-tt.byteimg.com/origin/pgc-image/47b512631098428e8bc60162e1df4ab7.png\" >\n\n<p>消息发送流程图：</p>\n<img src=\"https://p9-tt.byteimg.com/origin/pgc-image/70dfbbc7f61a4a9fac15e5ff1af809b4.png\">\n\n\n\n<h3 id=\"动态方法解析（也称：动态方法决议）\"><a href=\"#动态方法解析（也称：动态方法决议）\" class=\"headerlink\" title=\"动态方法解析（也称：动态方法决议）\"></a>动态方法解析（也称：动态方法决议）</h3><p>当消息发送流程找不到方法后就会进入动态方法解析流程。</p>\n<p>动态方法解析是当消息发送阶段找不到方法的时候，开发者可以通过重写特定方法（如果是类方法就重写<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>，如果是对象方法就重写<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>），给原先不存在的方法添加方法实现。主要是用到runtime里面的<code>class_addMethod</code>函数，并且动态解析后，会重新走”消息发送“的流程</p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>假如这里的person没有实现print方法</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *person = [Person new];</span><br><span class=\"line\">[person print];</span><br></pre></td></tr></table></figure>\n\n<p>那我们可以在<code>Person.m</code>添加一个方法实现用来替换丢失的<code>print</code>，这里我们用<code>truePrint</code>来替代</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)truePrint &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;true print&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sel == <span class=\"keyword\">@selector</span>(print)) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取truePrint方法的Method对象</span></span><br><span class=\"line\">        Method truePrint = class_getInstanceMethod(<span class=\"keyword\">self</span>, <span class=\"keyword\">@selector</span>(truePrint));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 动态添加print方法的实现，通过method_getImplementation获取到方法的函数指针，通过method_getTypeEncoding拿到方法的函数编码即 v@: 或 v16@0:8</span></span><br><span class=\"line\">        class_addMethod(<span class=\"keyword\">self</span>, sel, method_getImplementation(truePrint), method_getTypeEncoding(truePrint));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 返回YES代表有动态添加方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveInstanceMethod:sel];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"Method的结构\"><a href=\"#Method的结构\" class=\"headerlink\" title=\"Method的结构\"></a>Method的结构</h4><p>点击Method我们可以看到结构如下</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct objc_method *<span class=\"function\"><span class=\"keyword\">Method</span>;</span></span><br></pre></td></tr></table></figure>\n\n<p>而<code>ojbc_method</code>的定义如下</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">struct</span> objc_method &#123;</span><br><span class=\"line\">    <span class=\"attribute\">SEL</span> _Nonnull method_name;\t</span><br><span class=\"line\">    <span class=\"attribute\">char</span> * _Nullable method_types;</span><br><span class=\"line\">    <span class=\"attribute\">IMP</span> _Nonnull method_imp;</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>可以看到跟上面所说的<code>method_t</code>是类似的东西</p>\n<p>以下是一些拿到<code>Method</code>对象后可以使用的一些函数</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数调用，但是不接收返回值类型为结构体</span></span><br><span class=\"line\">method_invoke</span><br><span class=\"line\"><span class=\"comment\">// 函数调用，但是接收返回值类型为结构体</span></span><br><span class=\"line\">method_invoke_stret</span><br><span class=\"line\"><span class=\"comment\">// 获取函数名</span></span><br><span class=\"line\">method_getName</span><br><span class=\"line\"><span class=\"comment\">// 获取函数实现IMP</span></span><br><span class=\"line\">method_getImplementation</span><br><span class=\"line\"><span class=\"comment\">// 获取函数type encoding</span></span><br><span class=\"line\">method_getTypeEncoding</span><br><span class=\"line\"><span class=\"comment\">// 复制返回值类型</span></span><br><span class=\"line\">method_copyReturnType</span><br><span class=\"line\"><span class=\"comment\">// 复制参数类型</span></span><br><span class=\"line\">method_copyArgumentType</span><br><span class=\"line\"><span class=\"comment\">// 获取返回值类型</span></span><br><span class=\"line\">method_getReturnType</span><br><span class=\"line\"><span class=\"comment\">// 获取参数个数</span></span><br><span class=\"line\">method_getNumberOfArguments</span><br><span class=\"line\"><span class=\"comment\">// 获取函数参数类型</span></span><br><span class=\"line\">method_getArgumentType</span><br><span class=\"line\"><span class=\"comment\">// 获取函数描述</span></span><br><span class=\"line\">method_getDescription</span><br><span class=\"line\"><span class=\"comment\">// 设置函数实现IMP</span></span><br><span class=\"line\">method_setImplementation</span><br><span class=\"line\"><span class=\"comment\">// 交换函数的实现IMP</span></span><br><span class=\"line\">method_exchangeImplementations</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"Runtime中的原理\"><a href=\"#Runtime中的原理\" class=\"headerlink\" title=\"Runtime中的原理\"></a>Runtime中的原理</h4><p>在上面的消息发送的流程函数<code>lookUpImpOrForward</code>中，有一段代码如下</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class=\"line\">    behavior ^= LOOKUP_RESOLVER;</span><br><span class=\"line\">    return resolve<span class=\"constructor\">Method_locked(<span class=\"params\">inst</span>, <span class=\"params\">sel</span>, <span class=\"params\">cls</span>, <span class=\"params\">behavior</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当找不到消息的时候就会进入动态方法解析的流程即<code>resolveMethod_locked</code>，如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> NEVER_INLINE IMP resolveMethod_locked(<span class=\"keyword\">id</span> inst, SEL sel, Class cls, <span class=\"keyword\">int</span> behavior) &#123;</span><br><span class=\"line\">    runtimeLock.assertLocked();</span><br><span class=\"line\">    ASSERT(cls-&gt;isRealized());</span><br><span class=\"line\"></span><br><span class=\"line\">    runtimeLock.unlock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// try [cls resolveInstanceMethod:sel]</span></span><br><span class=\"line\">        resolveInstanceMethod(inst, sel, cls);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class=\"line\">        <span class=\"comment\">// and [cls resolveInstanceMethod:sel]</span></span><br><span class=\"line\">        resolveClassMethod(inst, sel, cls);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!lookUpImpOrNilTryCache(inst, sel, cls)) &#123;</span><br><span class=\"line\">            resolveInstanceMethod(inst, sel, cls);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lookUpImpOrForwardTryCache(inst, sel, cls, behavior);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里面我们可以发现<code>resolveInstanceMethod</code>和<code>resolveClassMethod</code>两个函数，分别是实现实例方法的动态消息解析和类方法的动态消息解析，这两个长得差不多，所以我们拿实例对象的函数查看一下</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void resolveInstanceMethod(id inst, SEL sel, Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    runtimeLock.assertUnlocked();</span><br><span class=\"line\">    ASSERT(<span class=\"function\"><span class=\"title\">cls</span>-&gt;</span>isRealized());</span><br><span class=\"line\">    SEL resolve_sel = @selector(resolveInstanceMethod:);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">if</span> (!lookUpImpOrNilTryCache(cls, resolve_sel, cls-&gt;</span>ISA(<span class=\"comment\">/*authenticated*/</span><span class=\"literal\">true</span>))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Resolver not implemented.</span></span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class=\"line\">    bool resolved = msg(cls, resolve_sel, sel);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span></span><br><span class=\"line\">    <span class=\"comment\">// +resolveInstanceMethod adds to self a.k.a. cls</span></span><br><span class=\"line\">    IMP imp = lookUpImpOrNilTryCache(inst, sel, cls);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (imp) &#123;</span><br><span class=\"line\">            _objc_inform(<span class=\"string\">&quot;RESOLVE: method %c[%s %s] &quot;</span></span><br><span class=\"line\">                         <span class=\"string\">&quot;dynamically resolved to %p&quot;</span>, </span><br><span class=\"line\">                         <span class=\"function\"><span class=\"title\">cls</span>-&gt;</span>isMetaClass() ? <span class=\"string\">&#x27;+&#x27;</span> : <span class=\"string\">&#x27;-&#x27;</span>, </span><br><span class=\"line\">                         <span class=\"function\"><span class=\"title\">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel), imp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Method resolver didn&#x27;t add anything?</span></span><br><span class=\"line\">            _objc_inform(<span class=\"string\">&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</span></span><br><span class=\"line\">                         <span class=\"string\">&quot;, but no new implementation of %c[%s %s] was found&quot;</span>,</span><br><span class=\"line\">                         <span class=\"function\"><span class=\"title\">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel), </span><br><span class=\"line\">                         <span class=\"function\"><span class=\"title\">cls</span>-&gt;</span>isMetaClass() ? <span class=\"string\">&#x27;+&#x27;</span> : <span class=\"string\">&#x27;-&#x27;</span>, </span><br><span class=\"line\">                         <span class=\"function\"><span class=\"title\">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里我们可以看到对<code>resolveInstanceMethod</code>方法进行了一次<code>objc_msgSend</code>调用，调用之后又执行了<code>lookUpImpOrNilTryCache</code>函数进行了缓存，如果缓存成功，那么下次调用这个方法就不会在进入动态方法解析阶段，直接通过消息发送阶段就调用成功了。</p>\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><p>根据我们以前所学的知识可以知道，方法查找的流程为</p>\n<p>实例方法：类 – 父类 – 父类 – … – 根类 – nil</p>\n<p>类方法：元类 – 父元类 – 父元类 – … – 根元类 – 根类 – nil</p>\n<p>也就是说丢失的方法最后都会回到根类去找方法，一般情况下是<code>NSObject</code></p>\n<p>通过这个特性，我们可以直接在<code>NSObject</code>上添加分类，然后实现动态解析方法，根据方法名前缀进行判断，然后统一处理未被找到的方法添加默认实现。通过这种方式我们可以减少一些找不到方法导致的崩溃问题，提升用户体验。</p>\n<h3 id=\"消息转发\"><a href=\"#消息转发\" class=\"headerlink\" title=\"消息转发\"></a>消息转发</h3><p>如果没有实现动态方法解析，那么将进入消息转发阶段。消息转发即把消息交给别人发送的意思。</p>\n<p>从上面的<code>lookUpImpOrForward</code>函数的源码我们可以看到，最后是调用了<code>_objc_msgForward_impcache</code>这个函数，这个函数是通过汇编实现的</p>\n<p>要实现消息转发，我们有两种方式，一种是实现一个方法<code>-forwardingTargetForSelector</code>，一种是实现<code>-methodSignatureForSelector</code>和<code>-forwardInvocation</code>，比如</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aSelector == <span class=\"keyword\">@selector</span>(print)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [[Student alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> forwardingTargetForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现了这个方法之后，最后系统会去我们提供的<code>Student</code>对象去寻找<code>print</code>方法，找到了的话就会进行调用。注意这个方法每次都会进来，每次都会生成新的<code>Student</code>对象对其<code>print</code>方法进行调用。</p>\n<p>如果<code>forwardingTargetForSelector</code>没实现或者返回空的话</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aSelector == <span class=\"keyword\">@selector</span>(print)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> forwardingTargetForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么就会寻找<code>-methodSignatureForSelector</code>和<code>-forwardInvocation</code></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 方法签名： 返回值类型、参数类型</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aSelector == <span class=\"keyword\">@selector</span>(print)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"built_in\">NSMethodSignature</span> signatureWithObjCTypes:<span class=\"string\">&quot;v16@0:8&quot;</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> methodSignatureForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数</span></span><br><span class=\"line\"><span class=\"comment\">/// anInvocation.target 方法调用者</span></span><br><span class=\"line\"><span class=\"comment\">/// anInvocation.selector 方法名</span></span><br><span class=\"line\"><span class=\"comment\">//// [anInvocation getArgument:NULL atIndex:0] 方法参数</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation &#123;</span><br><span class=\"line\">    [anInvocation invokeWithTarget:[[Student alloc] init]];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先我们在方法签名中指定方法类型，然后在<code>forwardInvocation</code>方法中，修改target，然后直接调用，这样子就会直接调用Student的print方法了</p>\n<img src=\"https://p3-tt.byteimg.com/origin/pgc-image/ba2d1d5ff71a49c8913690d6f69fb7d7.png\" width=80%>\n\n<h4 id=\"NSInvocation\"><a href=\"#NSInvocation\" class=\"headerlink\" title=\"NSInvocation\"></a>NSInvocation</h4><p>当系统执行到<code>forwardInvocation</code>的时候，无论在方法内有任何实现，都不会执行到<code>doseNotRecognizeSelector</code>（抛出异常），所以实现了就不会崩，即便什么都不做。</p>\n<p>在<code>forwardInvocation</code>内我们可以拿到方法调用的很多信息，比如方法调用者<code>anInvocation.target</code>、方法名<code>anInvocation.selector</code>和方法参数</p>\n<p>比如调用方法为<code>[person print:1]</code>，进入到<code>forwardInvocation</code>后我们可以通过以下方法拿到<code>1</code>这个参数</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    [anInvocation getArgument:&amp;a atIndex:<span class=\"number\">2</span>]; <span class=\"comment\">// 第一个参数是self，第二个是_cmd，所以从下标2开始取</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要拿返回值的话，就可以这么做</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation &#123;</span><br><span class=\"line\">    [anInvocation invokeWithTarget:[[Student alloc] init]]; <span class=\"comment\">// 要先调用一下Student的print方法，这里假设返回值是整型</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> result;</span><br><span class=\"line\">    [anInvocation getReturnValue:&amp;result];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>,result); <span class=\"comment\">/// 这里可以拿到返回值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"NSMethodSignature\"><a href=\"#NSMethodSignature\" class=\"headerlink\" title=\"NSMethodSignature\"></a>NSMethodSignature</h4><p><code>[NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;]</code>，注意这里的方法编码要跟下面<code>forwardInvocation</code>要调用的方法的方法编码一致 </p>\n<p>我们除了可以通过方法编码拿到<code>NSMethodSignature</code>对象之外，还可以这么做</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aSelector == <span class=\"keyword\">@selector</span>(print)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [[Student new] methodSignatureForSelector:<span class=\"keyword\">@selector</span>(print)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> methodSignatureForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"类方法的消息转发\"><a href=\"#类方法的消息转发\" class=\"headerlink\" title=\"类方法的消息转发\"></a>类方法的消息转发</h4><p><code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code></p>\n<p><code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code></p>\n<p><code>+ (void)forwardInvocation:(NSInvocation *)anInvocation</code></p>\n<p>这几个方法也有类方法版本，但是代码补全没出来，但是实际使用是可行的</p>\n<p><code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>在这个方法里面返回的消息接受者既可以是类对象也可以是实例对象。</p>\n<h4 id=\"synthesize-和-dynamic\"><a href=\"#synthesize-和-dynamic\" class=\"headerlink\" title=\"@synthesize 和 @dynamic\"></a>@synthesize 和 @dynamic</h4><p><code>@synthesize</code>用来自动给成员变量名生成<code>setter</code>和<code>getter</code>的声明和实现</p>\n<p><code>@dynamic</code>用来告诉编译器不要自动生成<code>setter</code>和<code>getter</code>的实现（声明还是会声明的），待到运行时开发者自己实现，并且不会为属性实现带下划线的成员变量</p>\n<h2 id=\"super\"><a href=\"#super\" class=\"headerlink\" title=\"super\"></a>super</h2><p>假如我们调用<code>Student</code>实例的一个父类方法</p>\n<p><code>[super run:xx]</code></p>\n<p>那么编译后会变成如下代码</p>\n<p><code>objc_msgSendSuper(self,class_getSuperclass(objc_getClass(&quot;Student&quot;)),sel_registerName(&quot;run&quot;),xx);</code></p>\n<p>所以<code>super</code>发送消息的本质是调用<code>objc_msgSendSuper2</code>函数，最终的消息接受者依旧是<code>self</code>，只是实例方法寻找从父类的类对象开始寻找，类方法从父类的元类对象开始寻找。</p>\n<p>所以当我们调用方法<code>[super class]</code>的时候，跟<code>[self class]</code>没区别，返回结果是一致的</p>\n","site":{"data":{}},"excerpt":"<p>本文主要简述类（元类）对象里面的方法缓存、消息发送（包括消息发送，动态方法解析与消息转发）与super关键字的底层原理</p>","more":"<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"Class对象的结构\"><a href=\"#Class对象的结构\" class=\"headerlink\" title=\"Class对象的结构\"></a>Class对象的结构</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_class &#123;</span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">    Class superclass;</span><br><span class=\"line\">    cache_t cache; <span class=\"comment\">// 方法缓存</span></span><br><span class=\"line\">    class_data_bits_t bits; <span class=\"comment\">// 用于获取具体的类信息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>bits</code>成员变量与<code>FAST_DATA_MASK</code>进行一次与运算之后，会获得一个其属性可读可写的对象的地址，这个对象长这样</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> class_rw_t &#123;</span><br><span class=\"line\">    uint32_t flags;</span><br><span class=\"line\">    uint32_t version;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> clsss_ro_t *ro;</span><br><span class=\"line\">    method_array_t * methods; <span class=\"comment\">// 方法列表</span></span><br><span class=\"line\">    property_array_t *properties; <span class=\"comment\">// 属性列表</span></span><br><span class=\"line\">    protocol_array_t protocols; <span class=\"comment\">// 协议列表</span></span><br><span class=\"line\">    Class firstSubclass;</span><br><span class=\"line\">    Class nextSiblingClass;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *demangledName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>class_ro_t</code>里面存放的是类的原始信息(不包括分类里面的东西)，是仅可读的，结构如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> class_ro_t &#123;</span><br><span class=\"line\">    uint32_t flags;</span><br><span class=\"line\">    unit32_t instanceStart;</span><br><span class=\"line\">    uint32_t instanceSize; <span class=\"comment\">// instance对象占用的内存空间</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __LP__64__</span></span><br><span class=\"line\">    uint32_t reserved;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> uint8_t *ivarLayout;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * name; <span class=\"comment\">// 类名</span></span><br><span class=\"line\">    method_list_t * baseMethodList;</span><br><span class=\"line\">    protocol_list_t * baseProtocols;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> ivar_list_t * ivars; <span class=\"comment\">// 成员变量列表</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> uint8_t * weakIverLayout;</span><br><span class=\"line\">    property_list_t * baseProperties;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"class-rw-t\"><a href=\"#class-rw-t\" class=\"headerlink\" title=\"class_rw_t\"></a>class_rw_t</h3><p><code>class_rw_t</code>里面的methods、properties、protocols是二维数组，是可读可写的，比如方法列表随时可以新增<code>method_list_t</code>类型的数据进去。<code>class_rw_t</code>包含了类的初始内容和分类的内容，其中方法列表类似如下结构</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">method_array_t: [</span><br><span class=\"line\">    method_list_t : [</span><br><span class=\"line\">      method_t,</span><br><span class=\"line\">      method_t,</span><br><span class=\"line\">      method_t</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    method_list_t : [</span><br><span class=\"line\">      method_t,</span><br><span class=\"line\">      method_t,</span><br><span class=\"line\">      method_t</span><br><span class=\"line\">    ],</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p><code>objc_class</code>内有一个<code>data()</code>函数，其返回值一开始是指向<code>class_ro_t</code>类型的对象的。在合并分类内的内容时，才会产生<code>class_rw_t</code>类型的对象，并指向这个对象。可以参考runtime源码，<code>objc-runtime-new.mm</code>中<code>realizeClassWithoutSwift</code>函数的实现，这里贴出关键部分</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Class realizeClassWithoutSwift(Class cls, Class previously)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    auto ro = (<span class=\"keyword\">const</span> class_ro_t *)cls-&gt;data();</span><br><span class=\"line\">    auto isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// This was a future class. rw data is already allocated.</span></span><br><span class=\"line\">        rw = cls-&gt;data();</span><br><span class=\"line\">        ro = cls-&gt;data()-&gt;ro();</span><br><span class=\"line\">        ASSERT(!isMeta);</span><br><span class=\"line\">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Normal class. Allocate writeable class data.</span></span><br><span class=\"line\">        rw = objc::zalloc&lt;class_rw_t&gt;();</span><br><span class=\"line\">        rw-&gt;set_ro(ro);</span><br><span class=\"line\">        rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class=\"line\">        cls-&gt;setData(rw);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"class-ro-t\"><a href=\"#class-ro-t\" class=\"headerlink\" title=\"class_ro_t\"></a>class_ro_t</h3><p><code>class_ro_t</code>里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，所以不能新增内容，包含了类的初始内容，其中方法列表类似如下结构</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">method_list_t</span> : [</span><br><span class=\"line\">  <span class=\"keyword\">method_t</span>,</span><br><span class=\"line\">  <span class=\"keyword\">method_t</span>,</span><br><span class=\"line\">  <span class=\"keyword\">method_t</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在runtime源码，<code>objc-runtime-new.mm</code>中的<code>attachCategories</code>方法中我们可以看到分类合并到<code>class_rw_t</code>对象的过程，比如方法的合并如下</p>\n</blockquote>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">method_list_t *mlist = entry.cat-&gt;methods<span class=\"constructor\">ForMeta(<span class=\"params\">isMeta</span>)</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (mlist) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mcount<span class=\"operator\"> == </span><span class=\"number\">64</span>) &#123;</span><br><span class=\"line\">        prepare<span class=\"constructor\">MethodLists(<span class=\"params\">cls</span>, <span class=\"params\">mlists</span>, <span class=\"params\">mcount</span>, NO, <span class=\"params\">fromBundle</span>, <span class=\"params\">__func__</span>)</span>;</span><br><span class=\"line\">        rwe-&gt;methods.attach<span class=\"constructor\">Lists(<span class=\"params\">mlists</span>, <span class=\"params\">mcount</span>)</span>;</span><br><span class=\"line\">        mcount = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mlists<span class=\"literal\">[ATTACH<span class=\"identifier\">_BUFSIZ</span> - <span class=\"operator\">++</span><span class=\"identifier\">mcount</span>]</span> = mlist;</span><br><span class=\"line\">    fromBundle <span class=\"pattern-match\">|= entry.hi-&gt;is<span class=\"constructor\">Bundle()</span>;</span></span><br><span class=\"line\"><span class=\"pattern-match\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"method-t\"><a href=\"#method-t\" class=\"headerlink\" title=\"method_t\"></a>method_t</h3><ul>\n<li><code>method_t</code>是对方法/函数的封装（下面是缩减版定义）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">method_t</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\">SEL <span class=\"title\">name</span><span class=\"params\">()</span></span>; <span class=\"comment\">// 函数名</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *<span class=\"title\">types</span><span class=\"params\">()</span></span>; <span class=\"comment\">// 编码（返回值类型、参数类型）</span></span><br><span class=\"line\">    <span class=\"function\">IMP <span class=\"title\">imp</span><span class=\"params\">(<span class=\"keyword\">bool</span> needsLock)</span></span>; <span class=\"comment\">// 指向函数的指针（函数地址）</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>IMP</code>代表具体函数的实现</p>\n<p>  <code>typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</code></p>\n</li>\n<li><p><code>SEL</code>可以代表方法\\函数名，一般叫做选择器，底层结构跟<code>char *</code>类似</p>\n<p>  <code>typedef struct objc_selector *SEL</code>;</p>\n<ul>\n<li>可以通过<code>@selector()</code>和<code>sel_registerName()</code>获得</li>\n<li>可以通过<code>sel_getName()</code>和<code>NSStringFromSelector()</code>转成字符串</li>\n<li>不同类中相同名字的方法，所对应的方法选择器是相同的</li>\n</ul>\n</li>\n<li><p><code>types</code>包含了函数返回值、参数编码的字符串，称作<code>Type Encodings</code>（类型编码），具体可以参考<a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100\">苹果官方文档</a></p>\n<ul>\n<li>比如<code>-（void）test:(int)a;</code>的方法编码为<code>v@:i</code>，v = void,@表示指针变量(因为编译后第一个参数是self)，：表示选择器(因为编译后第二个参数是_cmd)，</li>\n<li>有时类型编码会带上数字，比如<code>v16@0:8</code>，第一个数字表示这个函数的参数一共占用16个字节，第二个数字开始往后的数字都代表偏移值，0代表第一个参数的字节偏移值为0，第三个数字8代表偏移8个字节，也就是第一个参数已经占用了8个字节了，所以第二个参数就从第8个字节开始</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"cache-t\"><a href=\"#cache-t\" class=\"headerlink\" title=\"cache_t\"></a>cache_t</h3><ul>\n<li>Class内部结构中有个方法缓存（cache_t），用散列表来缓存曾经调用过的方法，可以提高方法的查找速度</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> cache_t &#123;</span><br><span class=\"line\">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;</span><br><span class=\"line\">    <span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">            explicit_atomic&lt;mask_t&gt;    _maybeMask; <span class=\"comment\">// 散列表的长度 - 1</span></span><br><span class=\"line\">            uint16_t                   _flags;</span><br><span class=\"line\">            uint16_t                   _occupied; <span class=\"comment\">// 已经缓存的方法数量</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;</span><br><span class=\"line\">    &#125;;   </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> bucket_t *buckets() <span class=\"keyword\">const</span>;</span><br><span class=\"line\">    mask_t mask() <span class=\"keyword\">const</span>;</span><br><span class=\"line\">    mask_t occupied() <span class=\"keyword\">const</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其中，通过<code>buckets()</code>函数我们可以得知<code>_bucketsAndMaybeMask</code>是一个存放<code>bucket_t</code>数组的指针（即<code>_bucketsAndMaybeMask</code>指针指向的是数组的第一个元素），是通过位运算取出来的</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> bucket_t *cache_t::buckets() <span class=\"keyword\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    uintptr_t addr = _bucketsAndMaybeMask.load(memory_order_relaxed);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (bucket_t *)(addr &amp; bucketsMask);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而<code>bucket_t</code>的结构如下</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct <span class=\"class\">bucket_t </span>&#123;</span><br><span class=\"line\">    explicit_atomic<span class=\"params\">&lt;uintptr_t&gt;</span> _imp; \t<span class=\"comment\">// 函数的内存地址</span></span><br><span class=\"line\">    explicit_atomic<span class=\"params\">&lt;SEL&gt;</span> _sel; <span class=\"comment\">// SEL作为key</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>通过IMP和SEL，我们就可以调用方法了，所以综上所述，一个实例对象调用方法，其类对象从方法缓存里面找方法的大概流程就是</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">获取sel : class - isa - 偏移<span class=\"number\">16</span>个字节 - <span class=\"keyword\">cache_t </span>- <span class=\"keyword\">buckets() </span>- [<span class=\"keyword\">bucket_t] </span>- 计算出下标index - <span class=\"keyword\">bucket_t </span>- sel()</span><br><span class=\"line\">获取imp : class - isa - 偏移<span class=\"number\">16</span>个字节 - <span class=\"keyword\">cache_t </span>- <span class=\"keyword\">buckets() </span>- [<span class=\"keyword\">bucket_t] </span>- 计算出下标index - <span class=\"keyword\">bucket_t </span>- imp(nil,cls)</span><br></pre></td></tr></table></figure>\n\n<p>另外<code>_bucketsAndMaybeMask</code>之所以叫这个名字是因为它不仅存放着<code>buckets</code>还存放着<code>maybeMask</code>，在arm64位真机环境下，取高16位，如下:</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mask_t cache_t::mask() <span class=\"keyword\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    uintptr_t maskAndBuckets = _bucketsAndMaybeMask.load(memory_order_relaxed);</span><br><span class=\"line\">    <span class=\"comment\">//maskShift 为48,</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maskAndBuckets &gt;&gt; maskShift;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法缓存的流程\"><a href=\"#方法缓存的流程\" class=\"headerlink\" title=\"方法缓存的流程\"></a>方法缓存的流程</h4><p>先看看runtime源码中，将方法插入缓存的函数（摘抄核心流程）</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> cache_t::insert(SEL sel, IMP imp, <span class=\"keyword\">id</span> receiver)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//对_occupied赋值 + 1。首次 newOccupied = 1。</span></span><br><span class=\"line\">    mask_t newOccupied = occupied() + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//旧容量，（mask + 1） 或者 0</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> oldCapacity = capacity(), capacity = oldCapacity;</span><br><span class=\"line\">    <span class=\"comment\">//是否为空，首次进入这里</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(isConstantEmptyCache())) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Cache is read-only. Replace it.</span></span><br><span class=\"line\">        <span class=\"comment\">//默认容量给4</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!capacity) capacity = INIT_CACHE_SIZE;<span class=\"comment\">//1 &lt;&lt; 2 = 4</span></span><br><span class=\"line\">        <span class=\"comment\">//0 4 false 开辟新的容器空间。由于旧容器为空这里不需要释放传false。</span></span><br><span class=\"line\">        reallocate(oldCapacity, capacity, <span class=\"comment\">/* freeOld */</span><span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//newOccupied + 1 (相当于 _occupied + 2) &lt;= capacity * 3 / 4 容量够的时候什么都不做，直接插入。&lt;=75%的容积正常插入，否则扩容。</span></span><br><span class=\"line\">    <span class=\"comment\">//## ⚠️在arm64位的情况下，CACHE_END_MARKER 0 扩容条件为：7 / 8 87.5% 这个时候CACHE_ALLOW_FULL_UTILIZATION 为 1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fastpath(newOccupied + <span class=\"built_in\">CACHE_END_MARKER</span> &lt;= cache_fill_ratio(capacity))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Cache is less than 3/4 or 7/8 full. Use it as-is.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> CACHE_ALLOW_FULL_UTILIZATION</span></span><br><span class=\"line\">    <span class=\"comment\">//capacity &lt;= 1&lt;&lt;3 (8), _occupied + 1（CACHE_END_MARKER为0） &lt;= 容量。少于8个元素的时候允许100%占满。</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (capacity &lt;= FULL_UTILIZATION_CACHE_SIZE &amp;&amp; newOccupied + <span class=\"built_in\">CACHE_END_MARKER</span> &lt;= capacity) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Allow 100% cache utilization for small buckets. Use it as-is.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">//扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//容量不为空返回 2倍的容量，否则返回4</span></span><br><span class=\"line\">        capacity = capacity ? capacity * <span class=\"number\">2</span> : INIT_CACHE_SIZE;</span><br><span class=\"line\">        <span class=\"comment\">//MAX_CACHE_SIZE 1&lt;&lt;16 = 2^16。最大缓存65536</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class=\"line\">            capacity = MAX_CACHE_SIZE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//开辟新的容器控件，释放旧的空间。</span></span><br><span class=\"line\">        reallocate(oldCapacity, capacity, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//从_bucketsAndMaybeMask获取buckets</span></span><br><span class=\"line\">    bucket_t *b = buckets();</span><br><span class=\"line\">    mask_t m = capacity - <span class=\"number\">1</span>;<span class=\"comment\">//首次是4-1</span></span><br><span class=\"line\">    <span class=\"comment\">//计算插入的index</span></span><br><span class=\"line\">    mask_t begin = cache_hash(sel, m);</span><br><span class=\"line\">    mask_t i = begin;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Scan for the first unused slot and insert there.</span></span><br><span class=\"line\">    <span class=\"comment\">// There is guaranteed to be an empty slot.</span></span><br><span class=\"line\">    <span class=\"comment\">//循环判断插入数据。</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//能走到这里大概率是cache不存在，所以这里走fastpath</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fastpath(b[i].sel() == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//Occupied + 1</span></span><br><span class=\"line\">            incrementOccupied();</span><br><span class=\"line\">            <span class=\"comment\">//buckets中插入bucket</span></span><br><span class=\"line\">            b[i].set&lt;Atomic, Encoded&gt;(b, sel, imp, cls());</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//已经存在了，不进行任何处理。有可能是其它线程插入的。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b[i].sel() == sel) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// The entry was added to the cache by some other thread</span></span><br><span class=\"line\">            <span class=\"comment\">// before we grabbed the cacheUpdateLock.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//cache_next为了防止hash冲突。再hash了一次（下文会讲到）。</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (fastpath((i = cache_next(i, m)) != begin));</span><br><span class=\"line\">    <span class=\"comment\">//异常处理</span></span><br><span class=\"line\">    bad_cache(receiver, (SEL)sel);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>首次进入isConstantEmptyCache分支。会创建一个容量为4的空buckets。这个时候由于旧buckets不存在不需要释放所以参数传递false。</li>\n<li>当容量大于等于3/4或7/8的情况下扩容。arm64的条件下为7 / 8。</li>\n<li>arm64条件下容量小于等于8的时候会占用100%才扩容。</li>\n<li>扩容是直接翻倍，默认值4。最大值MAX_CACHE_SIZE为216(65536)。在扩容的时候直接释放了旧值。</li>\n<li>mask值为capacity - 1</li>\n<li>通过cache_hash（下文会提及的散列表算法）计算插入的index，后面会通过cache_next再进行计算hash解决冲突问题。</li>\n<li>循环判断通过b[i].set插入bucket数据。</li>\n<li><strong>reallocate函数在开辟控件的同时，把缓存给直接清空了</strong>，清空之后再把现在要缓存的方法放进去，所以扩容后occupied会为1。</li>\n</ul>\n<h4 id=\"散列表（哈希表）缓存\"><a href=\"#散列表（哈希表）缓存\" class=\"headerlink\" title=\"散列表（哈希表）缓存\"></a>散列表（哈希表）缓存</h4><ul>\n<li><p>方法缓存的容器，不是简单的数组，而是用散列表的方式进行存储。</p>\n<p>假如现在散列表长度为10，那么mask（即cache_t里面的_maybeMask）就是10-1 = 9，当selector传进来的时候，会跟mask进行一次与运算，如下：</p>\n<p><code>@selector(personTest) &amp; mask = 4</code></p>\n<p>假如得到的结果是4的话，那么就会插在列表的下标为4的位置，其他位置因为已经开辟好空间了，所以有值就放值，没值就NULL</p>\n<p>这种列表的好处是，当想取到特定的bucket_t的时候，只需要把selector跟mask进行一次与运算，就可以直接得到下标，然后直接从列表取出，这样子就不用遍历查找了，大大节约了性能。</p>\n<p>另外，由于与运算的特性，跟mask进行与运算之后的值，都不可能比mask更大，这样子就保证不会插入越界的位置。</p>\n</li>\n<li><p>如果通过计算后的下标值，插入列表的时候发现已经有东西了那怎么办？</p>\n<p>  这也就是所谓的Hash冲突。为了处理这种问题，系统会调用<code>cache_next</code>函数</p>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">mask_t</span> <span class=\"title\">cache_next</span><span class=\"params\">(<span class=\"keyword\">mask_t</span> i, <span class=\"keyword\">mask_t</span> mask)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i ? i<span class=\"number\">-1</span> : mask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>  也就是说如果<code>@selector(personTest) &amp; mask = 4</code>的4已经有东西了，那么就取 4 - 1 = 3，如果3还有东西，就放在2的位置，如果2还有，就放在1，以此类推，如果直到0都还没有可以插入的位置，那么就从mask的位置开始找，也就是9，然后再找9看看是否可以插入，插不进去再找8，以此类推，找到为止。</p>\n<p>  由于列表在存放数量达到容量的87.5%的时候就会两倍的扩容（arm64），扩容后又会清空缓存，所以一定能找到合适的位置插入的。</p>\n</li>\n</ul>\n<h2 id=\"消息发送机制\"><a href=\"#消息发送机制\" class=\"headerlink\" title=\"消息发送机制\"></a>消息发送机制</h2><p>调用一个不存在的方法的时候，他会经历这么一个流程</p>\n<p>消息发送 - （找不到方法的话） -&gt; 动态方法解析 - （没有实现的话） -&gt; 消息转发 -&gt; （没有实现的话） -&gt; 抛出异常</p>\n<h3 id=\"消息发送\"><a href=\"#消息发送\" class=\"headerlink\" title=\"消息发送\"></a>消息发送</h3><p>假如我们这么调用一个方法</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[person personTest]</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>底层会转换为</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objc_msgSend(person,sel_registerName(<span class=\"string\">&quot;personTest&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这里的person我们称作消息接受者（receiver），就是调用方法的对象，如果这里还是调用类方法的话，那么这里就会传入一个类对象</li>\n<li><code>sel_registerName()</code>函数等价于<code>@selector</code></li>\n<li>为了性能，<code>objc_msgSend</code>方法底层是使用汇编和C++实现的</li>\n</ul>\n<p>消息发送的流程如下：</p>\n<ol>\n<li>receiver 是否为空，如果是退出，否则继续</li>\n<li>从receiver的类对象（如果传入的是类则找的是元类对象，下文统称为receiverClass）的cache中查找方法，如果找到则调用方法，如果找不到则继续</li>\n<li>从receiverClass中的<code>class_rw_t</code>中查找方法，如果找到则调用方法，并将方法插入缓存，如果找不到则继续</li>\n<li>从<code>superClass</code>的cache中查找方法，有则调用并缓存到当前receiverClass的cache中(不是superClass的cache),否则继续</li>\n<li>从<code>superClass</code>的<code>class_rw_t</code>中找，有则调用并缓存到receiverClass的cache中，否则继续</li>\n<li>继续通过<code>superClass</code>的<code>superClass</code>找方法，流程回到4，直到再也没有父类了，并且也找不到方法，那么将会进入动态方法解析阶段。</li>\n</ol>\n<p>其中：</p>\n<ul>\n<li>如果是从<code>class_rw_t</code>中查找方法，若方法列表已经排序好，那么就使用二分查找法查找</li>\n<li>如果是还没排序的方法，那么就使用遍历的方法查找</li>\n<li>在缓存中查找方法的过程也称作快速查找（使用汇编实现），在<code>class_rw_t</code>中查找方法的过程也称作慢速查找(使用汇编和C++实现)，C++部分方法源码在<code>lookUpImpOrForward</code>函数中，如下：</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IMP lookUpImpOrForward(<span class=\"keyword\">id</span> inst, SEL sel, Class cls, <span class=\"keyword\">int</span> behavior)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> IMP forward_imp = (IMP)_objc_msgForward_impcache;</span><br><span class=\"line\">    IMP imp = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    Class curClass;</span><br><span class=\"line\">    runtimeLock.assertUnlocked();</span><br><span class=\"line\">    <span class=\"comment\">// Optimistic cache lookup</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fastpath(behavior &amp; LOOKUP_CACHE)) &#123;</span><br><span class=\"line\">        imp = cache_getImp(cls, sel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (imp) <span class=\"keyword\">goto</span> done_nolock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    runtimeLock.lock();</span><br><span class=\"line\">    checkIsKnownClass(cls);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(!cls-&gt;isRealized())) &#123;</span><br><span class=\"line\">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</span><br><span class=\"line\">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    runtimeLock.assertLocked();</span><br><span class=\"line\">    curClass = cls;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">unsigned</span> attempts = unreasonableClassCount();;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// curClass method list.</span></span><br><span class=\"line\">        Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (meth) &#123;</span><br><span class=\"line\">            imp = meth-&gt;imp;</span><br><span class=\"line\">            <span class=\"keyword\">goto</span> done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowpath((curClass = curClass-&gt;superclass) == <span class=\"literal\">nil</span>)) &#123;</span><br><span class=\"line\">            imp = forward_imp;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowpath(--attempts == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            _objc_fatal(<span class=\"string\">&quot;Memory corruption in class list.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Superclass cache.</span></span><br><span class=\"line\">        imp = cache_getImp(curClass, sel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (slowpath(imp == forward_imp)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fastpath(imp)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Found the method in a superclass. Cache it in this class.</span></span><br><span class=\"line\">            <span class=\"keyword\">goto</span> done;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class=\"line\">        behavior ^= LOOKUP_RESOLVER;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> done:</span><br><span class=\"line\">    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class=\"line\">    runtimeLock.unlock();</span><br><span class=\"line\"> done_nolock:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> imp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>慢速查找流程图：</p>\n<img src=\"https://p5-tt.byteimg.com/origin/pgc-image/47b512631098428e8bc60162e1df4ab7.png\" >\n\n<p>消息发送流程图：</p>\n<img src=\"https://p9-tt.byteimg.com/origin/pgc-image/70dfbbc7f61a4a9fac15e5ff1af809b4.png\">\n\n\n\n<h3 id=\"动态方法解析（也称：动态方法决议）\"><a href=\"#动态方法解析（也称：动态方法决议）\" class=\"headerlink\" title=\"动态方法解析（也称：动态方法决议）\"></a>动态方法解析（也称：动态方法决议）</h3><p>当消息发送流程找不到方法后就会进入动态方法解析流程。</p>\n<p>动态方法解析是当消息发送阶段找不到方法的时候，开发者可以通过重写特定方法（如果是类方法就重写<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>，如果是对象方法就重写<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>），给原先不存在的方法添加方法实现。主要是用到runtime里面的<code>class_addMethod</code>函数，并且动态解析后，会重新走”消息发送“的流程</p>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><p>假如这里的person没有实现print方法</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *person = [Person new];</span><br><span class=\"line\">[person print];</span><br></pre></td></tr></table></figure>\n\n<p>那我们可以在<code>Person.m</code>添加一个方法实现用来替换丢失的<code>print</code>，这里我们用<code>truePrint</code>来替代</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)truePrint &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;true print&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sel == <span class=\"keyword\">@selector</span>(print)) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取truePrint方法的Method对象</span></span><br><span class=\"line\">        Method truePrint = class_getInstanceMethod(<span class=\"keyword\">self</span>, <span class=\"keyword\">@selector</span>(truePrint));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 动态添加print方法的实现，通过method_getImplementation获取到方法的函数指针，通过method_getTypeEncoding拿到方法的函数编码即 v@: 或 v16@0:8</span></span><br><span class=\"line\">        class_addMethod(<span class=\"keyword\">self</span>, sel, method_getImplementation(truePrint), method_getTypeEncoding(truePrint));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 返回YES代表有动态添加方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> resolveInstanceMethod:sel];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"Method的结构\"><a href=\"#Method的结构\" class=\"headerlink\" title=\"Method的结构\"></a>Method的结构</h4><p>点击Method我们可以看到结构如下</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct objc_method *<span class=\"function\"><span class=\"keyword\">Method</span>;</span></span><br></pre></td></tr></table></figure>\n\n<p>而<code>ojbc_method</code>的定义如下</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">struct</span> objc_method &#123;</span><br><span class=\"line\">    <span class=\"attribute\">SEL</span> _Nonnull method_name;\t</span><br><span class=\"line\">    <span class=\"attribute\">char</span> * _Nullable method_types;</span><br><span class=\"line\">    <span class=\"attribute\">IMP</span> _Nonnull method_imp;</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n<p>可以看到跟上面所说的<code>method_t</code>是类似的东西</p>\n<p>以下是一些拿到<code>Method</code>对象后可以使用的一些函数</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数调用，但是不接收返回值类型为结构体</span></span><br><span class=\"line\">method_invoke</span><br><span class=\"line\"><span class=\"comment\">// 函数调用，但是接收返回值类型为结构体</span></span><br><span class=\"line\">method_invoke_stret</span><br><span class=\"line\"><span class=\"comment\">// 获取函数名</span></span><br><span class=\"line\">method_getName</span><br><span class=\"line\"><span class=\"comment\">// 获取函数实现IMP</span></span><br><span class=\"line\">method_getImplementation</span><br><span class=\"line\"><span class=\"comment\">// 获取函数type encoding</span></span><br><span class=\"line\">method_getTypeEncoding</span><br><span class=\"line\"><span class=\"comment\">// 复制返回值类型</span></span><br><span class=\"line\">method_copyReturnType</span><br><span class=\"line\"><span class=\"comment\">// 复制参数类型</span></span><br><span class=\"line\">method_copyArgumentType</span><br><span class=\"line\"><span class=\"comment\">// 获取返回值类型</span></span><br><span class=\"line\">method_getReturnType</span><br><span class=\"line\"><span class=\"comment\">// 获取参数个数</span></span><br><span class=\"line\">method_getNumberOfArguments</span><br><span class=\"line\"><span class=\"comment\">// 获取函数参数类型</span></span><br><span class=\"line\">method_getArgumentType</span><br><span class=\"line\"><span class=\"comment\">// 获取函数描述</span></span><br><span class=\"line\">method_getDescription</span><br><span class=\"line\"><span class=\"comment\">// 设置函数实现IMP</span></span><br><span class=\"line\">method_setImplementation</span><br><span class=\"line\"><span class=\"comment\">// 交换函数的实现IMP</span></span><br><span class=\"line\">method_exchangeImplementations</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"Runtime中的原理\"><a href=\"#Runtime中的原理\" class=\"headerlink\" title=\"Runtime中的原理\"></a>Runtime中的原理</h4><p>在上面的消息发送的流程函数<code>lookUpImpOrForward</code>中，有一段代码如下</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class=\"line\">    behavior ^= LOOKUP_RESOLVER;</span><br><span class=\"line\">    return resolve<span class=\"constructor\">Method_locked(<span class=\"params\">inst</span>, <span class=\"params\">sel</span>, <span class=\"params\">cls</span>, <span class=\"params\">behavior</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当找不到消息的时候就会进入动态方法解析的流程即<code>resolveMethod_locked</code>，如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> NEVER_INLINE IMP resolveMethod_locked(<span class=\"keyword\">id</span> inst, SEL sel, Class cls, <span class=\"keyword\">int</span> behavior) &#123;</span><br><span class=\"line\">    runtimeLock.assertLocked();</span><br><span class=\"line\">    ASSERT(cls-&gt;isRealized());</span><br><span class=\"line\"></span><br><span class=\"line\">    runtimeLock.unlock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// try [cls resolveInstanceMethod:sel]</span></span><br><span class=\"line\">        resolveInstanceMethod(inst, sel, cls);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class=\"line\">        <span class=\"comment\">// and [cls resolveInstanceMethod:sel]</span></span><br><span class=\"line\">        resolveClassMethod(inst, sel, cls);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!lookUpImpOrNilTryCache(inst, sel, cls)) &#123;</span><br><span class=\"line\">            resolveInstanceMethod(inst, sel, cls);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> lookUpImpOrForwardTryCache(inst, sel, cls, behavior);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里面我们可以发现<code>resolveInstanceMethod</code>和<code>resolveClassMethod</code>两个函数，分别是实现实例方法的动态消息解析和类方法的动态消息解析，这两个长得差不多，所以我们拿实例对象的函数查看一下</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void resolveInstanceMethod(id inst, SEL sel, Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    runtimeLock.assertUnlocked();</span><br><span class=\"line\">    ASSERT(<span class=\"function\"><span class=\"title\">cls</span>-&gt;</span>isRealized());</span><br><span class=\"line\">    SEL resolve_sel = @selector(resolveInstanceMethod:);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">if</span> (!lookUpImpOrNilTryCache(cls, resolve_sel, cls-&gt;</span>ISA(<span class=\"comment\">/*authenticated*/</span><span class=\"literal\">true</span>))) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Resolver not implemented.</span></span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class=\"line\">    bool resolved = msg(cls, resolve_sel, sel);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span></span><br><span class=\"line\">    <span class=\"comment\">// +resolveInstanceMethod adds to self a.k.a. cls</span></span><br><span class=\"line\">    IMP imp = lookUpImpOrNilTryCache(inst, sel, cls);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (imp) &#123;</span><br><span class=\"line\">            _objc_inform(<span class=\"string\">&quot;RESOLVE: method %c[%s %s] &quot;</span></span><br><span class=\"line\">                         <span class=\"string\">&quot;dynamically resolved to %p&quot;</span>, </span><br><span class=\"line\">                         <span class=\"function\"><span class=\"title\">cls</span>-&gt;</span>isMetaClass() ? <span class=\"string\">&#x27;+&#x27;</span> : <span class=\"string\">&#x27;-&#x27;</span>, </span><br><span class=\"line\">                         <span class=\"function\"><span class=\"title\">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel), imp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Method resolver didn&#x27;t add anything?</span></span><br><span class=\"line\">            _objc_inform(<span class=\"string\">&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</span></span><br><span class=\"line\">                         <span class=\"string\">&quot;, but no new implementation of %c[%s %s] was found&quot;</span>,</span><br><span class=\"line\">                         <span class=\"function\"><span class=\"title\">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel), </span><br><span class=\"line\">                         <span class=\"function\"><span class=\"title\">cls</span>-&gt;</span>isMetaClass() ? <span class=\"string\">&#x27;+&#x27;</span> : <span class=\"string\">&#x27;-&#x27;</span>, </span><br><span class=\"line\">                         <span class=\"function\"><span class=\"title\">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这里我们可以看到对<code>resolveInstanceMethod</code>方法进行了一次<code>objc_msgSend</code>调用，调用之后又执行了<code>lookUpImpOrNilTryCache</code>函数进行了缓存，如果缓存成功，那么下次调用这个方法就不会在进入动态方法解析阶段，直接通过消息发送阶段就调用成功了。</p>\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><p>根据我们以前所学的知识可以知道，方法查找的流程为</p>\n<p>实例方法：类 – 父类 – 父类 – … – 根类 – nil</p>\n<p>类方法：元类 – 父元类 – 父元类 – … – 根元类 – 根类 – nil</p>\n<p>也就是说丢失的方法最后都会回到根类去找方法，一般情况下是<code>NSObject</code></p>\n<p>通过这个特性，我们可以直接在<code>NSObject</code>上添加分类，然后实现动态解析方法，根据方法名前缀进行判断，然后统一处理未被找到的方法添加默认实现。通过这种方式我们可以减少一些找不到方法导致的崩溃问题，提升用户体验。</p>\n<h3 id=\"消息转发\"><a href=\"#消息转发\" class=\"headerlink\" title=\"消息转发\"></a>消息转发</h3><p>如果没有实现动态方法解析，那么将进入消息转发阶段。消息转发即把消息交给别人发送的意思。</p>\n<p>从上面的<code>lookUpImpOrForward</code>函数的源码我们可以看到，最后是调用了<code>_objc_msgForward_impcache</code>这个函数，这个函数是通过汇编实现的</p>\n<p>要实现消息转发，我们有两种方式，一种是实现一个方法<code>-forwardingTargetForSelector</code>，一种是实现<code>-methodSignatureForSelector</code>和<code>-forwardInvocation</code>，比如</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aSelector == <span class=\"keyword\">@selector</span>(print)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [[Student alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> forwardingTargetForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现了这个方法之后，最后系统会去我们提供的<code>Student</code>对象去寻找<code>print</code>方法，找到了的话就会进行调用。注意这个方法每次都会进来，每次都会生成新的<code>Student</code>对象对其<code>print</code>方法进行调用。</p>\n<p>如果<code>forwardingTargetForSelector</code>没实现或者返回空的话</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aSelector == <span class=\"keyword\">@selector</span>(print)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> forwardingTargetForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么就会寻找<code>-methodSignatureForSelector</code>和<code>-forwardInvocation</code></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 方法签名： 返回值类型、参数类型</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aSelector == <span class=\"keyword\">@selector</span>(print)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [<span class=\"built_in\">NSMethodSignature</span> signatureWithObjCTypes:<span class=\"string\">&quot;v16@0:8&quot;</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> methodSignatureForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数</span></span><br><span class=\"line\"><span class=\"comment\">/// anInvocation.target 方法调用者</span></span><br><span class=\"line\"><span class=\"comment\">/// anInvocation.selector 方法名</span></span><br><span class=\"line\"><span class=\"comment\">//// [anInvocation getArgument:NULL atIndex:0] 方法参数</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation &#123;</span><br><span class=\"line\">    [anInvocation invokeWithTarget:[[Student alloc] init]];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先我们在方法签名中指定方法类型，然后在<code>forwardInvocation</code>方法中，修改target，然后直接调用，这样子就会直接调用Student的print方法了</p>\n<img src=\"https://p3-tt.byteimg.com/origin/pgc-image/ba2d1d5ff71a49c8913690d6f69fb7d7.png\" width=80%>\n\n<h4 id=\"NSInvocation\"><a href=\"#NSInvocation\" class=\"headerlink\" title=\"NSInvocation\"></a>NSInvocation</h4><p>当系统执行到<code>forwardInvocation</code>的时候，无论在方法内有任何实现，都不会执行到<code>doseNotRecognizeSelector</code>（抛出异常），所以实现了就不会崩，即便什么都不做。</p>\n<p>在<code>forwardInvocation</code>内我们可以拿到方法调用的很多信息，比如方法调用者<code>anInvocation.target</code>、方法名<code>anInvocation.selector</code>和方法参数</p>\n<p>比如调用方法为<code>[person print:1]</code>，进入到<code>forwardInvocation</code>后我们可以通过以下方法拿到<code>1</code>这个参数</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    [anInvocation getArgument:&amp;a atIndex:<span class=\"number\">2</span>]; <span class=\"comment\">// 第一个参数是self，第二个是_cmd，所以从下标2开始取</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要拿返回值的话，就可以这么做</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)anInvocation &#123;</span><br><span class=\"line\">    [anInvocation invokeWithTarget:[[Student alloc] init]]; <span class=\"comment\">// 要先调用一下Student的print方法，这里假设返回值是整型</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> result;</span><br><span class=\"line\">    [anInvocation getReturnValue:&amp;result];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>,result); <span class=\"comment\">/// 这里可以拿到返回值</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"NSMethodSignature\"><a href=\"#NSMethodSignature\" class=\"headerlink\" title=\"NSMethodSignature\"></a>NSMethodSignature</h4><p><code>[NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;]</code>，注意这里的方法编码要跟下面<code>forwardInvocation</code>要调用的方法的方法编码一致 </p>\n<p>我们除了可以通过方法编码拿到<code>NSMethodSignature</code>对象之外，还可以这么做</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (aSelector == <span class=\"keyword\">@selector</span>(print)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [[Student new] methodSignatureForSelector:<span class=\"keyword\">@selector</span>(print)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">super</span> methodSignatureForSelector:aSelector];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"类方法的消息转发\"><a href=\"#类方法的消息转发\" class=\"headerlink\" title=\"类方法的消息转发\"></a>类方法的消息转发</h4><p><code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code></p>\n<p><code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code></p>\n<p><code>+ (void)forwardInvocation:(NSInvocation *)anInvocation</code></p>\n<p>这几个方法也有类方法版本，但是代码补全没出来，但是实际使用是可行的</p>\n<p><code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>在这个方法里面返回的消息接受者既可以是类对象也可以是实例对象。</p>\n<h4 id=\"synthesize-和-dynamic\"><a href=\"#synthesize-和-dynamic\" class=\"headerlink\" title=\"@synthesize 和 @dynamic\"></a>@synthesize 和 @dynamic</h4><p><code>@synthesize</code>用来自动给成员变量名生成<code>setter</code>和<code>getter</code>的声明和实现</p>\n<p><code>@dynamic</code>用来告诉编译器不要自动生成<code>setter</code>和<code>getter</code>的实现（声明还是会声明的），待到运行时开发者自己实现，并且不会为属性实现带下划线的成员变量</p>\n<h2 id=\"super\"><a href=\"#super\" class=\"headerlink\" title=\"super\"></a>super</h2><p>假如我们调用<code>Student</code>实例的一个父类方法</p>\n<p><code>[super run:xx]</code></p>\n<p>那么编译后会变成如下代码</p>\n<p><code>objc_msgSendSuper(self,class_getSuperclass(objc_getClass(&quot;Student&quot;)),sel_registerName(&quot;run&quot;),xx);</code></p>\n<p>所以<code>super</code>发送消息的本质是调用<code>objc_msgSendSuper2</code>函数，最终的消息接受者依旧是<code>self</code>，只是实例方法寻找从父类的类对象开始寻找，类方法从父类的元类对象开始寻找。</p>\n<p>所以当我们调用方法<code>[super class]</code>的时候，跟<code>[self class]</code>没区别，返回结果是一致的</p>"},{"title":"nginx 镜像谷歌","author":"Arclin","abbrlink":"a6a89073","date":"2018-02-18T14:12:00.000Z","_content":"nginx 镜像谷歌\n\n<!-- more -->\n\n安装nginx第三方模块\n\n下载->解压->编译\n\n```\nwget http://artfiles.org/openssl.org/source/old/1.1.0/openssl-1.1.0g.tar.gz\nwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz\nwget http://zlib.net/zlib-1.2.11.tar.gz\n\ngit clone https://github.com/nginx/nginx.git\ngit clone https://github.com/cuber/ngx_http_google_filter_module\ngit clone https://github.com/yaoweibin/ngx_http_substitutions_filter_module\n\ncd ngx_http_google_filter_module\ngit checkout 77532b9\ncd ..\n\ntar -zxvf openssl-1.1.0g.tar.gz \ntar -zxvf pcre-8.39.tar.gz \ntar -zxvf zlib-1.2.11.tar.gz\n\ncd nginx\n\n./auto/configure --prefix=/usr/local/nginx --conf-path=/usr/local/nginx/conf/nginx.conf --with-http_v2_module --with-pcre=../pcre-8.39 --with-openssl=../openssl-1.1.0g --with-zlib=../zlib-1.2.11 --with-http_ssl_module --add-module=../ngx_http_google_filter_module --add-module=../ngx_http_substitutions_filter_module\n\nmake -j 4\n\nsudo make install\n```\n\n修改配置文件\n\n`vi /usr/local/nginx/conf/nginx.conf`\n\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    resolver 8.8.8.8;\n    location / {\n        google on;\n    }\n}\n```\n\n重启nginx\n\n```\nnginx -s reload\nservice nginx restart\n```\n\nreload 时发生错误\n\n```\nnginx: [error] open() \"/var/run/nginx.pid\" failed (2: No such file or directory)\n```\n\n解决\n\n```\nnginx -c /usr/local/nginx/conf/nginx.conf\n```\n","source":"_posts/nginx-镜像谷歌.md","raw":"---\ntitle: nginx 镜像谷歌\nauthor: Arclin\ntags:\n  - nginx\ncategories:\n  - Linux\nabbrlink: a6a89073\ndate: 2018-02-18 22:12:00\n---\nnginx 镜像谷歌\n\n<!-- more -->\n\n安装nginx第三方模块\n\n下载->解压->编译\n\n```\nwget http://artfiles.org/openssl.org/source/old/1.1.0/openssl-1.1.0g.tar.gz\nwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz\nwget http://zlib.net/zlib-1.2.11.tar.gz\n\ngit clone https://github.com/nginx/nginx.git\ngit clone https://github.com/cuber/ngx_http_google_filter_module\ngit clone https://github.com/yaoweibin/ngx_http_substitutions_filter_module\n\ncd ngx_http_google_filter_module\ngit checkout 77532b9\ncd ..\n\ntar -zxvf openssl-1.1.0g.tar.gz \ntar -zxvf pcre-8.39.tar.gz \ntar -zxvf zlib-1.2.11.tar.gz\n\ncd nginx\n\n./auto/configure --prefix=/usr/local/nginx --conf-path=/usr/local/nginx/conf/nginx.conf --with-http_v2_module --with-pcre=../pcre-8.39 --with-openssl=../openssl-1.1.0g --with-zlib=../zlib-1.2.11 --with-http_ssl_module --add-module=../ngx_http_google_filter_module --add-module=../ngx_http_substitutions_filter_module\n\nmake -j 4\n\nsudo make install\n```\n\n修改配置文件\n\n`vi /usr/local/nginx/conf/nginx.conf`\n\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    resolver 8.8.8.8;\n    location / {\n        google on;\n    }\n}\n```\n\n重启nginx\n\n```\nnginx -s reload\nservice nginx restart\n```\n\nreload 时发生错误\n\n```\nnginx: [error] open() \"/var/run/nginx.pid\" failed (2: No such file or directory)\n```\n\n解决\n\n```\nnginx -c /usr/local/nginx/conf/nginx.conf\n```\n","slug":"nginx-镜像谷歌","published":1,"updated":"2021-06-06T18:52:24.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoi0004rtnn0blie7dp2","content":"<p>nginx 镜像谷歌</p>\n<span id=\"more\"></span>\n\n<p>安装nginx第三方模块</p>\n<p>下载-&gt;解压-&gt;编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http:&#x2F;&#x2F;artfiles.org&#x2F;openssl.org&#x2F;source&#x2F;old&#x2F;1.1.0&#x2F;openssl-1.1.0g.tar.gz</span><br><span class=\"line\">wget ftp:&#x2F;&#x2F;ftp.csx.cam.ac.uk&#x2F;pub&#x2F;software&#x2F;programming&#x2F;pcre&#x2F;pcre-8.39.tar.gz</span><br><span class=\"line\">wget http:&#x2F;&#x2F;zlib.net&#x2F;zlib-1.2.11.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;nginx&#x2F;nginx.git</span><br><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;cuber&#x2F;ngx_http_google_filter_module</span><br><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;yaoweibin&#x2F;ngx_http_substitutions_filter_module</span><br><span class=\"line\"></span><br><span class=\"line\">cd ngx_http_google_filter_module</span><br><span class=\"line\">git checkout 77532b9</span><br><span class=\"line\">cd ..</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf openssl-1.1.0g.tar.gz </span><br><span class=\"line\">tar -zxvf pcre-8.39.tar.gz </span><br><span class=\"line\">tar -zxvf zlib-1.2.11.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">cd nginx</span><br><span class=\"line\"></span><br><span class=\"line\">.&#x2F;auto&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --conf-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf --with-http_v2_module --with-pcre&#x3D;..&#x2F;pcre-8.39 --with-openssl&#x3D;..&#x2F;openssl-1.1.0g --with-zlib&#x3D;..&#x2F;zlib-1.2.11 --with-http_ssl_module --add-module&#x3D;..&#x2F;ngx_http_google_filter_module --add-module&#x3D;..&#x2F;ngx_http_substitutions_filter_module</span><br><span class=\"line\"></span><br><span class=\"line\">make -j 4</span><br><span class=\"line\"></span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件</p>\n<p><code>vi /usr/local/nginx/conf/nginx.conf</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location &#x2F; &#123;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重启nginx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br><span class=\"line\">service nginx restart</span><br></pre></td></tr></table></figure>\n\n<p>reload 时发生错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx: [error] open() &quot;&#x2F;var&#x2F;run&#x2F;nginx.pid&quot; failed (2: No such file or directory)</span><br></pre></td></tr></table></figure>\n\n<p>解决</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>nginx 镜像谷歌</p>","more":"<p>安装nginx第三方模块</p>\n<p>下载-&gt;解压-&gt;编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http:&#x2F;&#x2F;artfiles.org&#x2F;openssl.org&#x2F;source&#x2F;old&#x2F;1.1.0&#x2F;openssl-1.1.0g.tar.gz</span><br><span class=\"line\">wget ftp:&#x2F;&#x2F;ftp.csx.cam.ac.uk&#x2F;pub&#x2F;software&#x2F;programming&#x2F;pcre&#x2F;pcre-8.39.tar.gz</span><br><span class=\"line\">wget http:&#x2F;&#x2F;zlib.net&#x2F;zlib-1.2.11.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;nginx&#x2F;nginx.git</span><br><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;cuber&#x2F;ngx_http_google_filter_module</span><br><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;yaoweibin&#x2F;ngx_http_substitutions_filter_module</span><br><span class=\"line\"></span><br><span class=\"line\">cd ngx_http_google_filter_module</span><br><span class=\"line\">git checkout 77532b9</span><br><span class=\"line\">cd ..</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf openssl-1.1.0g.tar.gz </span><br><span class=\"line\">tar -zxvf pcre-8.39.tar.gz </span><br><span class=\"line\">tar -zxvf zlib-1.2.11.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">cd nginx</span><br><span class=\"line\"></span><br><span class=\"line\">.&#x2F;auto&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --conf-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf --with-http_v2_module --with-pcre&#x3D;..&#x2F;pcre-8.39 --with-openssl&#x3D;..&#x2F;openssl-1.1.0g --with-zlib&#x3D;..&#x2F;zlib-1.2.11 --with-http_ssl_module --add-module&#x3D;..&#x2F;ngx_http_google_filter_module --add-module&#x3D;..&#x2F;ngx_http_substitutions_filter_module</span><br><span class=\"line\"></span><br><span class=\"line\">make -j 4</span><br><span class=\"line\"></span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件</p>\n<p><code>vi /usr/local/nginx/conf/nginx.conf</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location &#x2F; &#123;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重启nginx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br><span class=\"line\">service nginx restart</span><br></pre></td></tr></table></figure>\n\n<p>reload 时发生错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx: [error] open() &quot;&#x2F;var&#x2F;run&#x2F;nginx.pid&quot; failed (2: No such file or directory)</span><br></pre></td></tr></table></figure>\n\n<p>解决</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>"},{"title":"pan手势判断方向","author":"Arclin","abbrlink":"34db2dbc","date":"2016-10-16T16:00:00.000Z","_content":"pan手势判断方向\n\n```\nUIPanGestureRecognizer *pan = (UIPanGestureRecognizer *)gestureRecognizer;\nCGPoint point = [pan translationInView:gestureRecognizer.view]; // point.x < 0 左滑\n```","source":"_posts/pan手势判断方向.md","raw":"---\ntitle: pan手势判断方向\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 34db2dbc\ndate: 2016-10-17 00:00:00\n---\npan手势判断方向\n\n```\nUIPanGestureRecognizer *pan = (UIPanGestureRecognizer *)gestureRecognizer;\nCGPoint point = [pan translationInView:gestureRecognizer.view]; // point.x < 0 左滑\n```","slug":"pan手势判断方向","published":1,"updated":"2021-06-06T18:52:24.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoi1004vtnn02m1w5tla","content":"<p>pan手势判断方向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIPanGestureRecognizer *pan &#x3D; (UIPanGestureRecognizer *)gestureRecognizer;</span><br><span class=\"line\">CGPoint point &#x3D; [pan translationInView:gestureRecognizer.view]; &#x2F;&#x2F; point.x &lt; 0 左滑</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>pan手势判断方向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIPanGestureRecognizer *pan &#x3D; (UIPanGestureRecognizer *)gestureRecognizer;</span><br><span class=\"line\">CGPoint point &#x3D; [pan translationInView:gestureRecognizer.view]; &#x2F;&#x2F; point.x &lt; 0 左滑</span><br></pre></td></tr></table></figure>"},{"title":"ngrok 内网穿透使用","author":"Arclin","abbrlink":"dda122f4","date":"2018-02-18T14:02:00.000Z","_content":"ngrok 内网穿透使用\n\n<!-- more -->\n\n### 安装golang\n\n```\nsudo yum install build-essential golang mercurial git\n```\n\n### 运行脚本\n\n```\ncd ~\ngit clone https://github.com/tutumcloud/ngrok.git ngrok\nexport NGROK_DOMAIN=\"ngrok.arclin.me\"\ncd ngrok\nopenssl genrsa -out rootCA.key 2048\nopenssl req -x509 -new -nodes -key rootCA.key -subj \"/CN=$NGROK_DOMAIN” -days 5000 -out rootCA.pem\nopenssl genrsa -out device.key 2048\nopenssl req -new -key device.key -subj \"/CN=$NGROK_DOMAIN” -out device.csr\nopenssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000\ncp rootCA.pem assets/client/tls/ngrokroot.crt\ncp device.crt assets/server/tls/snakeoil.crt\ncp device.key assets/server/tls/snakeoil.key\nGOOS=linux GOARCH=amd64\nmake release-server\ncd /usr/lib/golang/src/\nGOOS=darwin GOARCH=amd64 ./make.bash\ncd ~/ngrok\nGOOS=darwin GOARCH=amd64 make release-client\n```\n\n### 服务端运行脚本\n\n```\nnohup  bin/ngrokd -domain=\"ngrok.arclin.me\" -httpAddr=\":8081\" -httpsAddr=\":8082\" &\n```\n> nohub 后台运行\n\n### 客户端\n\n新建 `./ngrok.cfg` 文件写入信息\n\n```\nserver_addr:arclin.me:4443\ntrust_host_root_certs: false\n```\n\n客户端运行\n```\n./ngrok -config=./ngrok.cfg -subdomain=test 3000\n```","source":"_posts/ngrok-内网穿透使用.md","raw":"---\ntitle: ngrok 内网穿透使用\nauthor: Arclin\ntags:\n  - ngrok\ncategories:\n  - Linux\nabbrlink: dda122f4\ndate: 2018-02-18 22:02:00\n---\nngrok 内网穿透使用\n\n<!-- more -->\n\n### 安装golang\n\n```\nsudo yum install build-essential golang mercurial git\n```\n\n### 运行脚本\n\n```\ncd ~\ngit clone https://github.com/tutumcloud/ngrok.git ngrok\nexport NGROK_DOMAIN=\"ngrok.arclin.me\"\ncd ngrok\nopenssl genrsa -out rootCA.key 2048\nopenssl req -x509 -new -nodes -key rootCA.key -subj \"/CN=$NGROK_DOMAIN” -days 5000 -out rootCA.pem\nopenssl genrsa -out device.key 2048\nopenssl req -new -key device.key -subj \"/CN=$NGROK_DOMAIN” -out device.csr\nopenssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000\ncp rootCA.pem assets/client/tls/ngrokroot.crt\ncp device.crt assets/server/tls/snakeoil.crt\ncp device.key assets/server/tls/snakeoil.key\nGOOS=linux GOARCH=amd64\nmake release-server\ncd /usr/lib/golang/src/\nGOOS=darwin GOARCH=amd64 ./make.bash\ncd ~/ngrok\nGOOS=darwin GOARCH=amd64 make release-client\n```\n\n### 服务端运行脚本\n\n```\nnohup  bin/ngrokd -domain=\"ngrok.arclin.me\" -httpAddr=\":8081\" -httpsAddr=\":8082\" &\n```\n> nohub 后台运行\n\n### 客户端\n\n新建 `./ngrok.cfg` 文件写入信息\n\n```\nserver_addr:arclin.me:4443\ntrust_host_root_certs: false\n```\n\n客户端运行\n```\n./ngrok -config=./ngrok.cfg -subdomain=test 3000\n```","slug":"ngrok-内网穿透使用","published":1,"updated":"2021-06-06T18:52:24.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoi1004ytnn0eb5sbe7a","content":"<p>ngrok 内网穿透使用</p>\n<span id=\"more\"></span>\n\n<h3 id=\"安装golang\"><a href=\"#安装golang\" class=\"headerlink\" title=\"安装golang\"></a>安装golang</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install build-essential golang mercurial git</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行脚本\"><a href=\"#运行脚本\" class=\"headerlink\" title=\"运行脚本\"></a>运行脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;tutumcloud&#x2F;ngrok.git ngrok</span><br><span class=\"line\">export NGROK_DOMAIN&#x3D;&quot;ngrok.arclin.me&quot;</span><br><span class=\"line\">cd ngrok</span><br><span class=\"line\">openssl genrsa -out rootCA.key 2048</span><br><span class=\"line\">openssl req -x509 -new -nodes -key rootCA.key -subj &quot;&#x2F;CN&#x3D;$NGROK_DOMAIN” -days 5000 -out rootCA.pem</span><br><span class=\"line\">openssl genrsa -out device.key 2048</span><br><span class=\"line\">openssl req -new -key device.key -subj &quot;&#x2F;CN&#x3D;$NGROK_DOMAIN” -out device.csr</span><br><span class=\"line\">openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br><span class=\"line\">cp rootCA.pem assets&#x2F;client&#x2F;tls&#x2F;ngrokroot.crt</span><br><span class=\"line\">cp device.crt assets&#x2F;server&#x2F;tls&#x2F;snakeoil.crt</span><br><span class=\"line\">cp device.key assets&#x2F;server&#x2F;tls&#x2F;snakeoil.key</span><br><span class=\"line\">GOOS&#x3D;linux GOARCH&#x3D;amd64</span><br><span class=\"line\">make release-server</span><br><span class=\"line\">cd &#x2F;usr&#x2F;lib&#x2F;golang&#x2F;src&#x2F;</span><br><span class=\"line\">GOOS&#x3D;darwin GOARCH&#x3D;amd64 .&#x2F;make.bash</span><br><span class=\"line\">cd ~&#x2F;ngrok</span><br><span class=\"line\">GOOS&#x3D;darwin GOARCH&#x3D;amd64 make release-client</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务端运行脚本\"><a href=\"#服务端运行脚本\" class=\"headerlink\" title=\"服务端运行脚本\"></a>服务端运行脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup  bin&#x2F;ngrokd -domain&#x3D;&quot;ngrok.arclin.me&quot; -httpAddr&#x3D;&quot;:8081&quot; -httpsAddr&#x3D;&quot;:8082&quot; &amp;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>nohub 后台运行</p>\n</blockquote>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><p>新建 <code>./ngrok.cfg</code> 文件写入信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server_addr:arclin.me:4443</span><br><span class=\"line\">trust_host_root_certs: false</span><br></pre></td></tr></table></figure>\n\n<p>客户端运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;ngrok -config&#x3D;.&#x2F;ngrok.cfg -subdomain&#x3D;test 3000</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>ngrok 内网穿透使用</p>","more":"<h3 id=\"安装golang\"><a href=\"#安装golang\" class=\"headerlink\" title=\"安装golang\"></a>安装golang</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install build-essential golang mercurial git</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行脚本\"><a href=\"#运行脚本\" class=\"headerlink\" title=\"运行脚本\"></a>运行脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;tutumcloud&#x2F;ngrok.git ngrok</span><br><span class=\"line\">export NGROK_DOMAIN&#x3D;&quot;ngrok.arclin.me&quot;</span><br><span class=\"line\">cd ngrok</span><br><span class=\"line\">openssl genrsa -out rootCA.key 2048</span><br><span class=\"line\">openssl req -x509 -new -nodes -key rootCA.key -subj &quot;&#x2F;CN&#x3D;$NGROK_DOMAIN” -days 5000 -out rootCA.pem</span><br><span class=\"line\">openssl genrsa -out device.key 2048</span><br><span class=\"line\">openssl req -new -key device.key -subj &quot;&#x2F;CN&#x3D;$NGROK_DOMAIN” -out device.csr</span><br><span class=\"line\">openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br><span class=\"line\">cp rootCA.pem assets&#x2F;client&#x2F;tls&#x2F;ngrokroot.crt</span><br><span class=\"line\">cp device.crt assets&#x2F;server&#x2F;tls&#x2F;snakeoil.crt</span><br><span class=\"line\">cp device.key assets&#x2F;server&#x2F;tls&#x2F;snakeoil.key</span><br><span class=\"line\">GOOS&#x3D;linux GOARCH&#x3D;amd64</span><br><span class=\"line\">make release-server</span><br><span class=\"line\">cd &#x2F;usr&#x2F;lib&#x2F;golang&#x2F;src&#x2F;</span><br><span class=\"line\">GOOS&#x3D;darwin GOARCH&#x3D;amd64 .&#x2F;make.bash</span><br><span class=\"line\">cd ~&#x2F;ngrok</span><br><span class=\"line\">GOOS&#x3D;darwin GOARCH&#x3D;amd64 make release-client</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务端运行脚本\"><a href=\"#服务端运行脚本\" class=\"headerlink\" title=\"服务端运行脚本\"></a>服务端运行脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup  bin&#x2F;ngrokd -domain&#x3D;&quot;ngrok.arclin.me&quot; -httpAddr&#x3D;&quot;:8081&quot; -httpsAddr&#x3D;&quot;:8082&quot; &amp;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>nohub 后台运行</p>\n</blockquote>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><p>新建 <code>./ngrok.cfg</code> 文件写入信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server_addr:arclin.me:4443</span><br><span class=\"line\">trust_host_root_certs: false</span><br></pre></td></tr></table></figure>\n\n<p>客户端运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;ngrok -config&#x3D;.&#x2F;ngrok.cfg -subdomain&#x3D;test 3000</span><br></pre></td></tr></table></figure>"},{"title":"pod install速度慢的终极解决方案","abbrlink":"826fbbdd","date":"2020-04-01T02:13:48.000Z","_content":"\n相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。\n\n<!-- more -->\n\n[原博文](https://blog.csdn.net/iotjin/article/details/81604034)已经被删掉了，所以我自己copy并整理了一份\n\n相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。\n\n使用国内镜像的Specs\n在pod install时使用命令\n`pod install --no-repo-update`\n\n使用proxychains使终端命令走代理\n下面就来说明一下这几种方法为何没有完全解决问题\n\n使用国内镜像的Specs\n这个只是加快了Specs下载更新速度，而且如果使用国内镜像Specs，那么Podfile中就必须指明使用这个Specs。\n\n在pod install时使用命令\n`pod install --no-repo-update`\n\ninstall时不更新本地库，但如果第一次install还是要去github clone代码\n\n使用proxychains使终端命令走代理\n\n这个只是使pod命令走代理，git download的时候不会走代理\n其实真正慢的原因并不在pod命令，而是在于github上的代码库访问速度慢，那么就知道真正的解决方案就是要加快git命令的速度。\n\n我使用Shadowsocks代理，默认代理端口为1080，配置好代理之后去终端输入git配置命令，命令如下\n\n`git config --global http.proxy socks5://127.0.0.1:1080`\n\n> 注意这里的 socks5:// 协议 如果你用的是http/https协议 这里要改成 http:// 或https://\n\n> 这里的http.proxy 一般不用改\n\n> 查看端口号的方式可以在小飞机那里或者其他翻墙软件点击配置信息查看，看本地端口号一项\n\n上面的命令是给git设置全局代理，但是我们并不希望国内git库也走代理，而是只需要github上的代码库走代理，命令如下\n\n`git config --global http.https://github.com.proxy socks5://127.0.0.1:1080`\n\n> 这里的socks5:// 协议 跟上面说的同理\n\n（ps：如果要恢复/移除上面设置的git代理，使用如下命令\n`git config --global --unset http.proxy`\n`git config --global --unset http.https://github.com.proxy`)\n\n（如果不恢复的话，你一旦关掉代理（小飞机），那么之后git命令都跑不了网络了）\n\n> 注意这里的 http.proxy 其实就是上面的`git config --global http.proxy socks5://127.0.0.1:1080`中的 http.proxy, 如果你写的是https.proxy，那么这里unset的时候应该也写https.proxy","source":"_posts/pod-install速度慢的终极解决方案.md","raw":"---\ntitle: pod install速度慢的终极解决方案\ntags:\n  - iOS\n  - Cocoapods\n  - 技巧\ncategories:\n  - iOS\nabbrlink: 826fbbdd\ndate: 2020-04-01 10:13:48\n---\n\n相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。\n\n<!-- more -->\n\n[原博文](https://blog.csdn.net/iotjin/article/details/81604034)已经被删掉了，所以我自己copy并整理了一份\n\n相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。\n\n使用国内镜像的Specs\n在pod install时使用命令\n`pod install --no-repo-update`\n\n使用proxychains使终端命令走代理\n下面就来说明一下这几种方法为何没有完全解决问题\n\n使用国内镜像的Specs\n这个只是加快了Specs下载更新速度，而且如果使用国内镜像Specs，那么Podfile中就必须指明使用这个Specs。\n\n在pod install时使用命令\n`pod install --no-repo-update`\n\ninstall时不更新本地库，但如果第一次install还是要去github clone代码\n\n使用proxychains使终端命令走代理\n\n这个只是使pod命令走代理，git download的时候不会走代理\n其实真正慢的原因并不在pod命令，而是在于github上的代码库访问速度慢，那么就知道真正的解决方案就是要加快git命令的速度。\n\n我使用Shadowsocks代理，默认代理端口为1080，配置好代理之后去终端输入git配置命令，命令如下\n\n`git config --global http.proxy socks5://127.0.0.1:1080`\n\n> 注意这里的 socks5:// 协议 如果你用的是http/https协议 这里要改成 http:// 或https://\n\n> 这里的http.proxy 一般不用改\n\n> 查看端口号的方式可以在小飞机那里或者其他翻墙软件点击配置信息查看，看本地端口号一项\n\n上面的命令是给git设置全局代理，但是我们并不希望国内git库也走代理，而是只需要github上的代码库走代理，命令如下\n\n`git config --global http.https://github.com.proxy socks5://127.0.0.1:1080`\n\n> 这里的socks5:// 协议 跟上面说的同理\n\n（ps：如果要恢复/移除上面设置的git代理，使用如下命令\n`git config --global --unset http.proxy`\n`git config --global --unset http.https://github.com.proxy`)\n\n（如果不恢复的话，你一旦关掉代理（小飞机），那么之后git命令都跑不了网络了）\n\n> 注意这里的 http.proxy 其实就是上面的`git config --global http.proxy socks5://127.0.0.1:1080`中的 http.proxy, 如果你写的是https.proxy，那么这里unset的时候应该也写https.proxy","slug":"pod-install速度慢的终极解决方案","published":1,"updated":"2021-06-06T18:52:24.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoi40052tnn019fwcgbn","content":"<p>相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。</p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://blog.csdn.net/iotjin/article/details/81604034\">原博文</a>已经被删掉了，所以我自己copy并整理了一份</p>\n<p>相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。</p>\n<p>使用国内镜像的Specs<br>在pod install时使用命令<br><code>pod install --no-repo-update</code></p>\n<p>使用proxychains使终端命令走代理<br>下面就来说明一下这几种方法为何没有完全解决问题</p>\n<p>使用国内镜像的Specs<br>这个只是加快了Specs下载更新速度，而且如果使用国内镜像Specs，那么Podfile中就必须指明使用这个Specs。</p>\n<p>在pod install时使用命令<br><code>pod install --no-repo-update</code></p>\n<p>install时不更新本地库，但如果第一次install还是要去github clone代码</p>\n<p>使用proxychains使终端命令走代理</p>\n<p>这个只是使pod命令走代理，git download的时候不会走代理<br>其实真正慢的原因并不在pod命令，而是在于github上的代码库访问速度慢，那么就知道真正的解决方案就是要加快git命令的速度。</p>\n<p>我使用Shadowsocks代理，默认代理端口为1080，配置好代理之后去终端输入git配置命令，命令如下</p>\n<p><code>git config --global http.proxy socks5://127.0.0.1:1080</code></p>\n<blockquote>\n<p>注意这里的 socks5:// 协议 如果你用的是http/https协议 这里要改成 http:// 或https://</p>\n</blockquote>\n<blockquote>\n<p>这里的http.proxy 一般不用改</p>\n</blockquote>\n<blockquote>\n<p>查看端口号的方式可以在小飞机那里或者其他翻墙软件点击配置信息查看，看本地端口号一项</p>\n</blockquote>\n<p>上面的命令是给git设置全局代理，但是我们并不希望国内git库也走代理，而是只需要github上的代码库走代理，命令如下</p>\n<p><code>git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</code></p>\n<blockquote>\n<p>这里的socks5:// 协议 跟上面说的同理</p>\n</blockquote>\n<p>（ps：如果要恢复/移除上面设置的git代理，使用如下命令<br><code>git config --global --unset http.proxy</code><br><code>git config --global --unset http.https://github.com.proxy</code>)</p>\n<p>（如果不恢复的话，你一旦关掉代理（小飞机），那么之后git命令都跑不了网络了）</p>\n<blockquote>\n<p>注意这里的 http.proxy 其实就是上面的<code>git config --global http.proxy socks5://127.0.0.1:1080</code>中的 http.proxy, 如果你写的是https.proxy，那么这里unset的时候应该也写https.proxy</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。</p>","more":"<p><a href=\"https://blog.csdn.net/iotjin/article/details/81604034\">原博文</a>已经被删掉了，所以我自己copy并整理了一份</p>\n<p>相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。</p>\n<p>使用国内镜像的Specs<br>在pod install时使用命令<br><code>pod install --no-repo-update</code></p>\n<p>使用proxychains使终端命令走代理<br>下面就来说明一下这几种方法为何没有完全解决问题</p>\n<p>使用国内镜像的Specs<br>这个只是加快了Specs下载更新速度，而且如果使用国内镜像Specs，那么Podfile中就必须指明使用这个Specs。</p>\n<p>在pod install时使用命令<br><code>pod install --no-repo-update</code></p>\n<p>install时不更新本地库，但如果第一次install还是要去github clone代码</p>\n<p>使用proxychains使终端命令走代理</p>\n<p>这个只是使pod命令走代理，git download的时候不会走代理<br>其实真正慢的原因并不在pod命令，而是在于github上的代码库访问速度慢，那么就知道真正的解决方案就是要加快git命令的速度。</p>\n<p>我使用Shadowsocks代理，默认代理端口为1080，配置好代理之后去终端输入git配置命令，命令如下</p>\n<p><code>git config --global http.proxy socks5://127.0.0.1:1080</code></p>\n<blockquote>\n<p>注意这里的 socks5:// 协议 如果你用的是http/https协议 这里要改成 http:// 或https://</p>\n</blockquote>\n<blockquote>\n<p>这里的http.proxy 一般不用改</p>\n</blockquote>\n<blockquote>\n<p>查看端口号的方式可以在小飞机那里或者其他翻墙软件点击配置信息查看，看本地端口号一项</p>\n</blockquote>\n<p>上面的命令是给git设置全局代理，但是我们并不希望国内git库也走代理，而是只需要github上的代码库走代理，命令如下</p>\n<p><code>git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</code></p>\n<blockquote>\n<p>这里的socks5:// 协议 跟上面说的同理</p>\n</blockquote>\n<p>（ps：如果要恢复/移除上面设置的git代理，使用如下命令<br><code>git config --global --unset http.proxy</code><br><code>git config --global --unset http.https://github.com.proxy</code>)</p>\n<p>（如果不恢复的话，你一旦关掉代理（小飞机），那么之后git命令都跑不了网络了）</p>\n<blockquote>\n<p>注意这里的 http.proxy 其实就是上面的<code>git config --global http.proxy socks5://127.0.0.1:1080</code>中的 http.proxy, 如果你写的是https.proxy，那么这里unset的时候应该也写https.proxy</p>\n</blockquote>"},{"title":"pop后强制竖屏","author":"Arclin","abbrlink":"50c5f6e6","date":"2016-10-16T16:00:00.000Z","_content":"pop之后强制竖屏\n\n<!-- more -->\n\n`AppDeleagte.h`\n\n```\n// 控制全部不支持横屏，当allowRotation为YES的时候可以横/竖屏切换\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    if (self.allowRotation) {\n        return  UIInterfaceOrientationMaskAllButUpsideDown;\n    }\n    return UIInterfaceOrientationMaskPortrait;\n}\n```\n\npop之后强制竖屏\n\n```\n- (void)viewDidAppear:(BOOL)animated\n{\n     [super viewDidAppear:animated];\n    \n    // 强制竖屏\n    [[UIDevice currentDevice] setValue:@(UIDeviceOrientationPortrait) forKey:@\"orientation\"];\n}\n```","source":"_posts/pop后强制竖屏.md","raw":"---\ntitle: pop后强制竖屏\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 50c5f6e6\ndate: 2016-10-17 00:00:00\n---\npop之后强制竖屏\n\n<!-- more -->\n\n`AppDeleagte.h`\n\n```\n// 控制全部不支持横屏，当allowRotation为YES的时候可以横/竖屏切换\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    if (self.allowRotation) {\n        return  UIInterfaceOrientationMaskAllButUpsideDown;\n    }\n    return UIInterfaceOrientationMaskPortrait;\n}\n```\n\npop之后强制竖屏\n\n```\n- (void)viewDidAppear:(BOOL)animated\n{\n     [super viewDidAppear:animated];\n    \n    // 强制竖屏\n    [[UIDevice currentDevice] setValue:@(UIDeviceOrientationPortrait) forKey:@\"orientation\"];\n}\n```","slug":"pop后强制竖屏","published":1,"updated":"2021-06-06T18:52:24.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoi60055tnn0a8khelqm","content":"<p>pop之后强制竖屏</p>\n<span id=\"more\"></span>\n\n<p><code>AppDeleagte.h</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 控制全部不支持横屏，当allowRotation为YES的时候可以横&#x2F;竖屏切换</span><br><span class=\"line\">- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;</span><br><span class=\"line\">    if (self.allowRotation) &#123;</span><br><span class=\"line\">        return  UIInterfaceOrientationMaskAllButUpsideDown;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return UIInterfaceOrientationMaskPortrait;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>pop之后强制竖屏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     [super viewDidAppear:animated];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 强制竖屏</span><br><span class=\"line\">    [[UIDevice currentDevice] setValue:@(UIDeviceOrientationPortrait) forKey:@&quot;orientation&quot;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>pop之后强制竖屏</p>","more":"<p><code>AppDeleagte.h</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 控制全部不支持横屏，当allowRotation为YES的时候可以横&#x2F;竖屏切换</span><br><span class=\"line\">- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;</span><br><span class=\"line\">    if (self.allowRotation) &#123;</span><br><span class=\"line\">        return  UIInterfaceOrientationMaskAllButUpsideDown;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return UIInterfaceOrientationMaskPortrait;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>pop之后强制竖屏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     [super viewDidAppear:animated];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 强制竖屏</span><br><span class=\"line\">    [[UIDevice currentDevice] setValue:@(UIDeviceOrientationPortrait) forKey:@&quot;orientation&quot;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"一句ipack命令解决iOS编译打包上传fir流程","author":"Arclin","abbrlink":"4edc914d","date":"2017-02-13T16:00:00.000Z","_content":"一行命令即可将包含 cocoapods 的iOS 项目编译打包并上传到 fir\n<!-- more -->\n\n### 准备工具\n - fir-cli\n - Cocopods\n \n### 功能\n\n进入任意一个有.xcodeworksapce文件的目录下，输入ipack（可以自定义）即可完成编译打包上传，加上-c 更新说明\n参数就可以填写本次打包的更新说明，这个说明会在 fir 上面显示出来\n\n### 编写shell脚本\n\nsh代码说明\n\n变量定义\n\n`basepath=$(pwd)`  命令行代码执行位置\n`bName=$(basename ${basepath})`  拿到项目文件夹名字\n`description=$(basename ${basepath})` 要写在 fir 的更新说明\n`achivepath=${basepath}'/build/'${bName}'.xcarchive'` 构建文件的储存位置\n\n`ipaPath=${basepath}'/'${bName}'.ipa'` ipa 的储存位置\n\n拿到参数\n\n```\nwhile getopts \":c:\" opt; do` # 遍历参数 虽然现在只有一个，不过为了拓展还是可以加上去\ncase $opt in\n    c ) description=\"$OPTARG\";;   # 如果参数是c 的话就把内容赋值给description\n    ? ) echo \"参数选项不正确，应该是 -c <发布内容>\"\n        exit 1;;\n    esca\ndone\n```\n\n判断命令是不是执行在有`.xcodeworksapce`文件的目录下\n\n`$(ls *.xcwork* >/dev/null 2>&1)`\n\n清除缓存\n\n```\n/usr/bin/xcodebuild -target　${bName} clean\n```\n\n编译\n\n```\n/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}\n```\n\n判断编译成功了吗\n\n`if [ ! -d ${achivepath} ];`\n\n打包\n\n/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}\n\n判断打包成功了吗\n\n`if [ ! -f ${ipaPath} ];`\n\n上传到 fir\n\n```\nfir publish ${bName}.ipa --token <你的 Fir Token> -c ${description}\n```\n\nfirToken 的位置\n\n![](/images/pasted-0.png)\n\n清理编译打包的文件\n\n```\nrm -rf ${ipaPath} ${achivepath}\n```\n\n完事\n\n执行\n如果你把 sh文件放在桌面的话，一般来说现在去到有.xcodeworksapce文件的目录下，执行\n\n```\n~/Desktop/iosPackage.sh\n```\n\n就可以了，加个参数就是\n\n```\n~/Desktop/iosPackage.sh -c \"测试测试\"`\n```\n\n但是`~/Desktop/iosPackage.sh`太长了，所以得给他加个别名\n\n所以执行\n\n```\ncd ~\ntouch .bash_profile\n```\n\n创建一个`.bash_profile`文件\n\n然后在里面填写 `alias ipack='~/Desktop/iosPackage.sh'`\n这个`ipack`你想写啥就啥\n\n然后保存之后执行\n\n`source ./bash_profile`\n\n之后就可以直接用 ipack 代替 `~/Desktop/iosPackage.sh`\n\n`ipack ipack -c \"测试测试\"`\n\nEND","source":"_posts/一句ipack命令解决iOS编译打包上传fir流程.md","raw":"---\ntitle: 一句ipack命令解决iOS编译打包上传fir流程\nauthor: Arclin\ntags:\n  - Fir\n  - shell\ncategories:\n  - iOS\nabbrlink: 4edc914d\ndate: 2017-02-14 00:00:00\n---\n一行命令即可将包含 cocoapods 的iOS 项目编译打包并上传到 fir\n<!-- more -->\n\n### 准备工具\n - fir-cli\n - Cocopods\n \n### 功能\n\n进入任意一个有.xcodeworksapce文件的目录下，输入ipack（可以自定义）即可完成编译打包上传，加上-c 更新说明\n参数就可以填写本次打包的更新说明，这个说明会在 fir 上面显示出来\n\n### 编写shell脚本\n\nsh代码说明\n\n变量定义\n\n`basepath=$(pwd)`  命令行代码执行位置\n`bName=$(basename ${basepath})`  拿到项目文件夹名字\n`description=$(basename ${basepath})` 要写在 fir 的更新说明\n`achivepath=${basepath}'/build/'${bName}'.xcarchive'` 构建文件的储存位置\n\n`ipaPath=${basepath}'/'${bName}'.ipa'` ipa 的储存位置\n\n拿到参数\n\n```\nwhile getopts \":c:\" opt; do` # 遍历参数 虽然现在只有一个，不过为了拓展还是可以加上去\ncase $opt in\n    c ) description=\"$OPTARG\";;   # 如果参数是c 的话就把内容赋值给description\n    ? ) echo \"参数选项不正确，应该是 -c <发布内容>\"\n        exit 1;;\n    esca\ndone\n```\n\n判断命令是不是执行在有`.xcodeworksapce`文件的目录下\n\n`$(ls *.xcwork* >/dev/null 2>&1)`\n\n清除缓存\n\n```\n/usr/bin/xcodebuild -target　${bName} clean\n```\n\n编译\n\n```\n/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}\n```\n\n判断编译成功了吗\n\n`if [ ! -d ${achivepath} ];`\n\n打包\n\n/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}\n\n判断打包成功了吗\n\n`if [ ! -f ${ipaPath} ];`\n\n上传到 fir\n\n```\nfir publish ${bName}.ipa --token <你的 Fir Token> -c ${description}\n```\n\nfirToken 的位置\n\n![](/images/pasted-0.png)\n\n清理编译打包的文件\n\n```\nrm -rf ${ipaPath} ${achivepath}\n```\n\n完事\n\n执行\n如果你把 sh文件放在桌面的话，一般来说现在去到有.xcodeworksapce文件的目录下，执行\n\n```\n~/Desktop/iosPackage.sh\n```\n\n就可以了，加个参数就是\n\n```\n~/Desktop/iosPackage.sh -c \"测试测试\"`\n```\n\n但是`~/Desktop/iosPackage.sh`太长了，所以得给他加个别名\n\n所以执行\n\n```\ncd ~\ntouch .bash_profile\n```\n\n创建一个`.bash_profile`文件\n\n然后在里面填写 `alias ipack='~/Desktop/iosPackage.sh'`\n这个`ipack`你想写啥就啥\n\n然后保存之后执行\n\n`source ./bash_profile`\n\n之后就可以直接用 ipack 代替 `~/Desktop/iosPackage.sh`\n\n`ipack ipack -c \"测试测试\"`\n\nEND","slug":"一句ipack命令解决iOS编译打包上传fir流程","published":1,"updated":"2021-06-06T18:52:24.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoi60059tnn0ds11glbj","content":"<p>一行命令即可将包含 cocoapods 的iOS 项目编译打包并上传到 fir</p>\n<span id=\"more\"></span>\n\n<h3 id=\"准备工具\"><a href=\"#准备工具\" class=\"headerlink\" title=\"准备工具\"></a>准备工具</h3><ul>\n<li>fir-cli</li>\n<li>Cocopods</li>\n</ul>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>进入任意一个有.xcodeworksapce文件的目录下，输入ipack（可以自定义）即可完成编译打包上传，加上-c 更新说明<br>参数就可以填写本次打包的更新说明，这个说明会在 fir 上面显示出来</p>\n<h3 id=\"编写shell脚本\"><a href=\"#编写shell脚本\" class=\"headerlink\" title=\"编写shell脚本\"></a>编写shell脚本</h3><p>sh代码说明</p>\n<p>变量定义</p>\n<p><code>basepath=$(pwd)</code>  命令行代码执行位置<br><code>bName=$(basename $&#123;basepath&#125;)</code>  拿到项目文件夹名字<br><code>description=$(basename $&#123;basepath&#125;)</code> 要写在 fir 的更新说明<br><code>achivepath=$&#123;basepath&#125;&#39;/build/&#39;$&#123;bName&#125;&#39;.xcarchive&#39;</code> 构建文件的储存位置</p>\n<p><code>ipaPath=$&#123;basepath&#125;&#39;/&#39;$&#123;bName&#125;&#39;.ipa&#39;</code> ipa 的储存位置</p>\n<p>拿到参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while getopts &quot;:c:&quot; opt; do&#96; # 遍历参数 虽然现在只有一个，不过为了拓展还是可以加上去</span><br><span class=\"line\">case $opt in</span><br><span class=\"line\">    c ) description&#x3D;&quot;$OPTARG&quot;;;   # 如果参数是c 的话就把内容赋值给description</span><br><span class=\"line\">    ? ) echo &quot;参数选项不正确，应该是 -c &lt;发布内容&gt;&quot;</span><br><span class=\"line\">        exit 1;;</span><br><span class=\"line\">    esca</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n\n<p>判断命令是不是执行在有<code>.xcodeworksapce</code>文件的目录下</p>\n<p><code>$(ls *.xcwork* &gt;/dev/null 2&gt;&amp;1)</code></p>\n<p>清除缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;xcodebuild -target　$&#123;bName&#125; clean</span><br></pre></td></tr></table></figure>\n\n<p>编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;xcodebuild -exportArchive -exportFormat ipa -archivePath $&#123;achivepath&#125; -exportPath $&#123;ipaPath&#125;</span><br></pre></td></tr></table></figure>\n\n<p>判断编译成功了吗</p>\n<p><code>if [ ! -d $&#123;achivepath&#125; ];</code></p>\n<p>打包</p>\n<p>/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}</p>\n<p>判断打包成功了吗</p>\n<p><code>if [ ! -f $&#123;ipaPath&#125; ];</code></p>\n<p>上传到 fir</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fir publish $&#123;bName&#125;.ipa --token &lt;你的 Fir Token&gt; -c $&#123;description&#125;</span><br></pre></td></tr></table></figure>\n\n<p>firToken 的位置</p>\n<p><img src=\"/images/pasted-0.png\"></p>\n<p>清理编译打包的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf $&#123;ipaPath&#125; $&#123;achivepath&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完事</p>\n<p>执行<br>如果你把 sh文件放在桌面的话，一般来说现在去到有.xcodeworksapce文件的目录下，执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~&#x2F;Desktop&#x2F;iosPackage.sh</span><br></pre></td></tr></table></figure>\n\n<p>就可以了，加个参数就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~&#x2F;Desktop&#x2F;iosPackage.sh -c &quot;测试测试&quot;&#96;</span><br></pre></td></tr></table></figure>\n\n<p>但是<code>~/Desktop/iosPackage.sh</code>太长了，所以得给他加个别名</p>\n<p>所以执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">touch .bash_profile</span><br></pre></td></tr></table></figure>\n\n<p>创建一个<code>.bash_profile</code>文件</p>\n<p>然后在里面填写 <code>alias ipack=&#39;~/Desktop/iosPackage.sh&#39;</code><br>这个<code>ipack</code>你想写啥就啥</p>\n<p>然后保存之后执行</p>\n<p><code>source ./bash_profile</code></p>\n<p>之后就可以直接用 ipack 代替 <code>~/Desktop/iosPackage.sh</code></p>\n<p><code>ipack ipack -c &quot;测试测试&quot;</code></p>\n<p>END</p>\n","site":{"data":{}},"excerpt":"<p>一行命令即可将包含 cocoapods 的iOS 项目编译打包并上传到 fir</p>","more":"<h3 id=\"准备工具\"><a href=\"#准备工具\" class=\"headerlink\" title=\"准备工具\"></a>准备工具</h3><ul>\n<li>fir-cli</li>\n<li>Cocopods</li>\n</ul>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>进入任意一个有.xcodeworksapce文件的目录下，输入ipack（可以自定义）即可完成编译打包上传，加上-c 更新说明<br>参数就可以填写本次打包的更新说明，这个说明会在 fir 上面显示出来</p>\n<h3 id=\"编写shell脚本\"><a href=\"#编写shell脚本\" class=\"headerlink\" title=\"编写shell脚本\"></a>编写shell脚本</h3><p>sh代码说明</p>\n<p>变量定义</p>\n<p><code>basepath=$(pwd)</code>  命令行代码执行位置<br><code>bName=$(basename $&#123;basepath&#125;)</code>  拿到项目文件夹名字<br><code>description=$(basename $&#123;basepath&#125;)</code> 要写在 fir 的更新说明<br><code>achivepath=$&#123;basepath&#125;&#39;/build/&#39;$&#123;bName&#125;&#39;.xcarchive&#39;</code> 构建文件的储存位置</p>\n<p><code>ipaPath=$&#123;basepath&#125;&#39;/&#39;$&#123;bName&#125;&#39;.ipa&#39;</code> ipa 的储存位置</p>\n<p>拿到参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while getopts &quot;:c:&quot; opt; do&#96; # 遍历参数 虽然现在只有一个，不过为了拓展还是可以加上去</span><br><span class=\"line\">case $opt in</span><br><span class=\"line\">    c ) description&#x3D;&quot;$OPTARG&quot;;;   # 如果参数是c 的话就把内容赋值给description</span><br><span class=\"line\">    ? ) echo &quot;参数选项不正确，应该是 -c &lt;发布内容&gt;&quot;</span><br><span class=\"line\">        exit 1;;</span><br><span class=\"line\">    esca</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n\n<p>判断命令是不是执行在有<code>.xcodeworksapce</code>文件的目录下</p>\n<p><code>$(ls *.xcwork* &gt;/dev/null 2&gt;&amp;1)</code></p>\n<p>清除缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;xcodebuild -target　$&#123;bName&#125; clean</span><br></pre></td></tr></table></figure>\n\n<p>编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;xcodebuild -exportArchive -exportFormat ipa -archivePath $&#123;achivepath&#125; -exportPath $&#123;ipaPath&#125;</span><br></pre></td></tr></table></figure>\n\n<p>判断编译成功了吗</p>\n<p><code>if [ ! -d $&#123;achivepath&#125; ];</code></p>\n<p>打包</p>\n<p>/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}</p>\n<p>判断打包成功了吗</p>\n<p><code>if [ ! -f $&#123;ipaPath&#125; ];</code></p>\n<p>上传到 fir</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fir publish $&#123;bName&#125;.ipa --token &lt;你的 Fir Token&gt; -c $&#123;description&#125;</span><br></pre></td></tr></table></figure>\n\n<p>firToken 的位置</p>\n<p><img src=\"/images/pasted-0.png\"></p>\n<p>清理编译打包的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf $&#123;ipaPath&#125; $&#123;achivepath&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完事</p>\n<p>执行<br>如果你把 sh文件放在桌面的话，一般来说现在去到有.xcodeworksapce文件的目录下，执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~&#x2F;Desktop&#x2F;iosPackage.sh</span><br></pre></td></tr></table></figure>\n\n<p>就可以了，加个参数就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~&#x2F;Desktop&#x2F;iosPackage.sh -c &quot;测试测试&quot;&#96;</span><br></pre></td></tr></table></figure>\n\n<p>但是<code>~/Desktop/iosPackage.sh</code>太长了，所以得给他加个别名</p>\n<p>所以执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">touch .bash_profile</span><br></pre></td></tr></table></figure>\n\n<p>创建一个<code>.bash_profile</code>文件</p>\n<p>然后在里面填写 <code>alias ipack=&#39;~/Desktop/iosPackage.sh&#39;</code><br>这个<code>ipack</code>你想写啥就啥</p>\n<p>然后保存之后执行</p>\n<p><code>source ./bash_profile</code></p>\n<p>之后就可以直接用 ipack 代替 <code>~/Desktop/iosPackage.sh</code></p>\n<p><code>ipack ipack -c &quot;测试测试&quot;</code></p>\n<p>END</p>"},{"title":"使用DKHTTPTool时的异常处理","author":"Arclin","abbrlink":"7daccd39","date":"2017-01-04T16:00:00.000Z","_content":"本文主要讲述的是在使用 DKHTTPTool 时，返回异常数据时的处理\n\n<!-- more -->\n\n如果是普通调用情况的话,也即是调用这个方法\n```\n- (NSInteger)requestForMethod:(NSString *)method\n                cacheStragety:(DKCacheStrategy)strategy\n                          url:(NSString *)URLString\n                       header:(NSDictionary *)header\n                       params:(NSDictionary *)params\n                       filter:(DKHTTPRequestFilterBlock)filterBlock\n                 verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock\n                responseBlock:(DKHTTPResponseBlock)block;\n```\n\n那么捕获异常只需要拿到回调中的DKResponse中的error属性即可\n\n如果是用链式调用的方法`RACSignal`回调的话，那么就得看情况了，如果你是用 `RACCommand` 去启用网络请求的话，那么记得 `RACCommand` 是用 `errors` 属性去存储错误信号的，如果你有多个 `RACCommand` 对象建议你在 `ViewModel` 里创建一个 `RACSubject` 去统一处理错误信号，然后你可以这么写`[[RACSignal merge:@[_addParamCommand.errors,_removeParamCommand.errors,_sendCommand.errors]] subscribe:self.errors];`\n\n如果你直接取得网络请求回调中的`RACSignal`对象的话 ，直接`subscribeError:`就可以得到`NSError`对象\n关于提示错误信息，从交互的角度上来讲，我觉得友好程度\n\n`TopBarMessage(TWMessageBarManager) > HUD > ALERT`\n\n当然实际运用的时候还是得看情况，不同情况使用不同的提示方式","source":"_posts/使用DKHTTPTool时的异常处理.md","raw":"---\ntitle: 使用DKHTTPTool时的异常处理\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 7daccd39\ndate: 2017-01-05 00:00:00\n---\n本文主要讲述的是在使用 DKHTTPTool 时，返回异常数据时的处理\n\n<!-- more -->\n\n如果是普通调用情况的话,也即是调用这个方法\n```\n- (NSInteger)requestForMethod:(NSString *)method\n                cacheStragety:(DKCacheStrategy)strategy\n                          url:(NSString *)URLString\n                       header:(NSDictionary *)header\n                       params:(NSDictionary *)params\n                       filter:(DKHTTPRequestFilterBlock)filterBlock\n                 verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock\n                responseBlock:(DKHTTPResponseBlock)block;\n```\n\n那么捕获异常只需要拿到回调中的DKResponse中的error属性即可\n\n如果是用链式调用的方法`RACSignal`回调的话，那么就得看情况了，如果你是用 `RACCommand` 去启用网络请求的话，那么记得 `RACCommand` 是用 `errors` 属性去存储错误信号的，如果你有多个 `RACCommand` 对象建议你在 `ViewModel` 里创建一个 `RACSubject` 去统一处理错误信号，然后你可以这么写`[[RACSignal merge:@[_addParamCommand.errors,_removeParamCommand.errors,_sendCommand.errors]] subscribe:self.errors];`\n\n如果你直接取得网络请求回调中的`RACSignal`对象的话 ，直接`subscribeError:`就可以得到`NSError`对象\n关于提示错误信息，从交互的角度上来讲，我觉得友好程度\n\n`TopBarMessage(TWMessageBarManager) > HUD > ALERT`\n\n当然实际运用的时候还是得看情况，不同情况使用不同的提示方式","slug":"使用DKHTTPTool时的异常处理","published":1,"updated":"2021-06-06T18:52:24.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoi7005ctnn07sg47uee","content":"<p>本文主要讲述的是在使用 DKHTTPTool 时，返回异常数据时的处理</p>\n<span id=\"more\"></span>\n\n<p>如果是普通调用情况的话,也即是调用这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method</span><br><span class=\"line\">                cacheStragety:(DKCacheStrategy)strategy</span><br><span class=\"line\">                          url:(NSString *)URLString</span><br><span class=\"line\">                       header:(NSDictionary *)header</span><br><span class=\"line\">                       params:(NSDictionary *)params</span><br><span class=\"line\">                       filter:(DKHTTPRequestFilterBlock)filterBlock</span><br><span class=\"line\">                 verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock</span><br><span class=\"line\">                responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n\n<p>那么捕获异常只需要拿到回调中的DKResponse中的error属性即可</p>\n<p>如果是用链式调用的方法<code>RACSignal</code>回调的话，那么就得看情况了，如果你是用 <code>RACCommand</code> 去启用网络请求的话，那么记得 <code>RACCommand</code> 是用 <code>errors</code> 属性去存储错误信号的，如果你有多个 <code>RACCommand</code> 对象建议你在 <code>ViewModel</code> 里创建一个 <code>RACSubject</code> 去统一处理错误信号，然后你可以这么写<code>[[RACSignal merge:@[_addParamCommand.errors,_removeParamCommand.errors,_sendCommand.errors]] subscribe:self.errors];</code></p>\n<p>如果你直接取得网络请求回调中的<code>RACSignal</code>对象的话 ，直接<code>subscribeError:</code>就可以得到<code>NSError</code>对象<br>关于提示错误信息，从交互的角度上来讲，我觉得友好程度</p>\n<p><code>TopBarMessage(TWMessageBarManager) &gt; HUD &gt; ALERT</code></p>\n<p>当然实际运用的时候还是得看情况，不同情况使用不同的提示方式</p>\n","site":{"data":{}},"excerpt":"<p>本文主要讲述的是在使用 DKHTTPTool 时，返回异常数据时的处理</p>","more":"<p>如果是普通调用情况的话,也即是调用这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method</span><br><span class=\"line\">                cacheStragety:(DKCacheStrategy)strategy</span><br><span class=\"line\">                          url:(NSString *)URLString</span><br><span class=\"line\">                       header:(NSDictionary *)header</span><br><span class=\"line\">                       params:(NSDictionary *)params</span><br><span class=\"line\">                       filter:(DKHTTPRequestFilterBlock)filterBlock</span><br><span class=\"line\">                 verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock</span><br><span class=\"line\">                responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n\n<p>那么捕获异常只需要拿到回调中的DKResponse中的error属性即可</p>\n<p>如果是用链式调用的方法<code>RACSignal</code>回调的话，那么就得看情况了，如果你是用 <code>RACCommand</code> 去启用网络请求的话，那么记得 <code>RACCommand</code> 是用 <code>errors</code> 属性去存储错误信号的，如果你有多个 <code>RACCommand</code> 对象建议你在 <code>ViewModel</code> 里创建一个 <code>RACSubject</code> 去统一处理错误信号，然后你可以这么写<code>[[RACSignal merge:@[_addParamCommand.errors,_removeParamCommand.errors,_sendCommand.errors]] subscribe:self.errors];</code></p>\n<p>如果你直接取得网络请求回调中的<code>RACSignal</code>对象的话 ，直接<code>subscribeError:</code>就可以得到<code>NSError</code>对象<br>关于提示错误信息，从交互的角度上来讲，我觉得友好程度</p>\n<p><code>TopBarMessage(TWMessageBarManager) &gt; HUD &gt; ALERT</code></p>\n<p>当然实际运用的时候还是得看情况，不同情况使用不同的提示方式</p>"},{"title":"使用PHP进行webhook的注意点","author":"Arclin","abbrlink":"f8291fcc","date":"2018-02-18T13:55:00.000Z","_content":"有时会编写PHP脚本进行webhook, 这里有些地方需要注意一下, 否则会导致脚本执行失败\n\n<!-- more -->\n\n允许某些敏感方法的执行\n编辑`php.ini`\n\n```\ndisable_functions = scandir,passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,\nini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,\nstream_socket_server,fsocket,fsockopen\n```\n\n把`exec`去掉\n\n检查`apache`用户的目录权限\n\napache用户公钥要配置在项目里面\n也就是项目里会有两个公钥\n一个是root的一个是apache的","source":"_posts/使用php的exec方法进行webhook的注意点.md","raw":"---\ntitle: 使用PHP进行webhook的注意点\nauthor: Arclin\ntags:\n  - php\n  - webhook\ncategories:\n  - PHP\nabbrlink: f8291fcc\ndate: 2018-02-18 21:55:00\n---\n有时会编写PHP脚本进行webhook, 这里有些地方需要注意一下, 否则会导致脚本执行失败\n\n<!-- more -->\n\n允许某些敏感方法的执行\n编辑`php.ini`\n\n```\ndisable_functions = scandir,passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,\nini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,\nstream_socket_server,fsocket,fsockopen\n```\n\n把`exec`去掉\n\n检查`apache`用户的目录权限\n\napache用户公钥要配置在项目里面\n也就是项目里会有两个公钥\n一个是root的一个是apache的","slug":"使用php的exec方法进行webhook的注意点","published":1,"updated":"2021-06-06T18:52:24.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoi8005gtnn021fhfiy8","content":"<p>有时会编写PHP脚本进行webhook, 这里有些地方需要注意一下, 否则会导致脚本执行失败</p>\n<span id=\"more\"></span>\n\n<p>允许某些敏感方法的执行<br>编辑<code>php.ini</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">disable_functions &#x3D; scandir,passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,</span><br><span class=\"line\">ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,</span><br><span class=\"line\">stream_socket_server,fsocket,fsockopen</span><br></pre></td></tr></table></figure>\n\n<p>把<code>exec</code>去掉</p>\n<p>检查<code>apache</code>用户的目录权限</p>\n<p>apache用户公钥要配置在项目里面<br>也就是项目里会有两个公钥<br>一个是root的一个是apache的</p>\n","site":{"data":{}},"excerpt":"<p>有时会编写PHP脚本进行webhook, 这里有些地方需要注意一下, 否则会导致脚本执行失败</p>","more":"<p>允许某些敏感方法的执行<br>编辑<code>php.ini</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">disable_functions &#x3D; scandir,passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,</span><br><span class=\"line\">ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,</span><br><span class=\"line\">stream_socket_server,fsocket,fsockopen</span><br></pre></td></tr></table></figure>\n\n<p>把<code>exec</code>去掉</p>\n<p>检查<code>apache</code>用户的目录权限</p>\n<p>apache用户公钥要配置在项目里面<br>也就是项目里会有两个公钥<br>一个是root的一个是apache的</p>"},{"title":"什么时候用weakSelf什么时候用strongSelf","author":"Arclin","abbrlink":"f9b1d95c","date":"2016-10-16T16:00:00.000Z","_content":"#### 什么时候用weakSelf 什么时候用 strongSelf\n\n - Objective C 的 Block 是一个很实用的语法，特别是与GCD结合使用，可以很方便地实现并发、异步任务。但是，如果使用不当，Block 也会引起一些循环引用问题(retain cycle)—— Block 会 retain ‘self’，而 ‘self‘ 又 retain 了 Block。因为在 ObjC 中，直接调用一个实例变量，会被编译器处理成 ‘self->theVar’，’self’ 是一个 strong 类型的变量，引用计数会加 1，于是，self retains queue， queue retains block，block retains self。\n\n - 解决 retain circle\n\n \t- Apple 官方的建议是，传进 Block 之前，把 ‘self’ 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。\n示例代码：\n\n```\n__weak typeof(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ \n\t[weakSelf doSomething]; \n});\n```\n\n - clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：\n\n```\n__weak typeof(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n \t[weakSelf doSomething]; \n \t[weakSelf doOtherThing]; \n});\n```\n\n - 在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，于是，strongSelf 就派上用场了：\n\n```\n__weak __typeof__(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n \t__strong typeof(self) strongSelf = weakSelf;\n   [strongSelf doSomething];\n   [strongSelf doOtherThing];\n });\n```\n\n - __strong 确保在 Block 内，strongSelf 不会被释放。\n\n- 总结\n\n\t- 在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。\n\n\t- 如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。","source":"_posts/什么时候用weakSelf什么时候用strongSelf.md","raw":"---\ntitle: 什么时候用weakSelf什么时候用strongSelf\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: f9b1d95c\ndate: 2016-10-17 00:00:00\n---\n#### 什么时候用weakSelf 什么时候用 strongSelf\n\n - Objective C 的 Block 是一个很实用的语法，特别是与GCD结合使用，可以很方便地实现并发、异步任务。但是，如果使用不当，Block 也会引起一些循环引用问题(retain cycle)—— Block 会 retain ‘self’，而 ‘self‘ 又 retain 了 Block。因为在 ObjC 中，直接调用一个实例变量，会被编译器处理成 ‘self->theVar’，’self’ 是一个 strong 类型的变量，引用计数会加 1，于是，self retains queue， queue retains block，block retains self。\n\n - 解决 retain circle\n\n \t- Apple 官方的建议是，传进 Block 之前，把 ‘self’ 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。\n示例代码：\n\n```\n__weak typeof(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ \n\t[weakSelf doSomething]; \n});\n```\n\n - clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：\n\n```\n__weak typeof(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n \t[weakSelf doSomething]; \n \t[weakSelf doOtherThing]; \n});\n```\n\n - 在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，于是，strongSelf 就派上用场了：\n\n```\n__weak __typeof__(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n \t__strong typeof(self) strongSelf = weakSelf;\n   [strongSelf doSomething];\n   [strongSelf doOtherThing];\n });\n```\n\n - __strong 确保在 Block 内，strongSelf 不会被释放。\n\n- 总结\n\n\t- 在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。\n\n\t- 如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。","slug":"什么时候用weakSelf什么时候用strongSelf","published":1,"updated":"2021-06-06T18:52:24.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoia005jtnn0bypy3hkb","content":"<h4 id=\"什么时候用weakSelf-什么时候用-strongSelf\"><a href=\"#什么时候用weakSelf-什么时候用-strongSelf\" class=\"headerlink\" title=\"什么时候用weakSelf 什么时候用 strongSelf\"></a>什么时候用weakSelf 什么时候用 strongSelf</h4><ul>\n<li><p>Objective C 的 Block 是一个很实用的语法，特别是与GCD结合使用，可以很方便地实现并发、异步任务。但是，如果使用不当，Block 也会引起一些循环引用问题(retain cycle)—— Block 会 retain ‘self’，而 ‘self‘ 又 retain 了 Block。因为在 ObjC 中，直接调用一个实例变量，会被编译器处理成 ‘self-&gt;theVar’，’self’ 是一个 strong 类型的变量，引用计数会加 1，于是，self retains queue， queue retains block，block retains self。</p>\n</li>\n<li><p>解决 retain circle</p>\n<ul>\n<li>Apple 官方的建议是，传进 Block 之前，把 ‘self’ 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。<br>示例代码：</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; </span><br><span class=\"line\">\t[weakSelf doSomething]; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\"> \t[weakSelf doSomething]; </span><br><span class=\"line\"> \t[weakSelf doOtherThing]; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，于是，strongSelf 就派上用场了：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak __typeof__(self) weakSelf &#x3D; self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\"> \t__strong typeof(self) strongSelf &#x3D; weakSelf;</span><br><span class=\"line\">   [strongSelf doSomething];</span><br><span class=\"line\">   [strongSelf doOtherThing];</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>__strong 确保在 Block 内，strongSelf 不会被释放。</p>\n</li>\n<li><p>总结</p>\n<ul>\n<li><p>在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。</p>\n</li>\n<li><p>如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么时候用weakSelf-什么时候用-strongSelf\"><a href=\"#什么时候用weakSelf-什么时候用-strongSelf\" class=\"headerlink\" title=\"什么时候用weakSelf 什么时候用 strongSelf\"></a>什么时候用weakSelf 什么时候用 strongSelf</h4><ul>\n<li><p>Objective C 的 Block 是一个很实用的语法，特别是与GCD结合使用，可以很方便地实现并发、异步任务。但是，如果使用不当，Block 也会引起一些循环引用问题(retain cycle)—— Block 会 retain ‘self’，而 ‘self‘ 又 retain 了 Block。因为在 ObjC 中，直接调用一个实例变量，会被编译器处理成 ‘self-&gt;theVar’，’self’ 是一个 strong 类型的变量，引用计数会加 1，于是，self retains queue， queue retains block，block retains self。</p>\n</li>\n<li><p>解决 retain circle</p>\n<ul>\n<li>Apple 官方的建议是，传进 Block 之前，把 ‘self’ 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。<br>示例代码：</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; </span><br><span class=\"line\">\t[weakSelf doSomething]; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\"> \t[weakSelf doSomething]; </span><br><span class=\"line\"> \t[weakSelf doOtherThing]; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，于是，strongSelf 就派上用场了：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak __typeof__(self) weakSelf &#x3D; self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\"> \t__strong typeof(self) strongSelf &#x3D; weakSelf;</span><br><span class=\"line\">   [strongSelf doSomething];</span><br><span class=\"line\">   [strongSelf doOtherThing];</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>__strong 确保在 Block 内，strongSelf 不会被释放。</p>\n</li>\n<li><p>总结</p>\n<ul>\n<li><p>在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。</p>\n</li>\n<li><p>如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"使用RAC+DKHTTPTool实践","author":"Arclin","abbrlink":"8d52056b","date":"2016-12-25T16:00:00.000Z","_content":"使用RAC+DKHTTP套件实践\n- 这次通过一个简单的例子来解说DKHTTP套件与 RAC 结合的使用\n\n<!-- more -->\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/444.png?raw=true)\n\n- 首先简析下这个界面\n\t- 顶部搜索框部分的背景：广告栏位+图书推荐的图片，这里是一个获取图片的接口（接口 A）\n\t- 图书推荐： 这里也是一个接口，需要显示图书的封面（接口 B）\n\t- 笔记推荐： 这里也是一个接口，需要显示图书笔记的一些简介 （接口 C）\n- 页面渲染\n\n\t- 同页面多接口的渲染方式有多种： \n    \t-\t一是接口的串联，也就是一个接口返回的数据交作为参数给下一个接口去发送请求 ；\n    \t- 二是同时发送请求，根据接口返回的顺序渲染页面；\n    \t- 三是同时请求，等所有的接口返回之后再一次性进行渲染。\n\t- 上面的三种渲染方式，RACSignal都有相应的解决方案，假设这里页面渲染的方式选择的是依次渲染，那么我们使用 DKHTTPChainTool 的executeSignal()来写个例子\n\n```\n RACSignal *signalA = DKHTTPChainInstance.method(@\"POST\")\n                                         .url(@\"\")\n                                         .params(@{@\"did\":@\"1\",@\"page\":@\"1\",@\"num\":@\"100\"})\n                                         .executeSignal();\n\nRACSignal *signalB = DKHTTPChainInstance.method(@\"POST\")\n                                        .url(@\"\")\n                                        .params(@{@\"dis_id\":@\"9\"})\n                                        .executeSignal();\n\nRACSignal *signalC = DKHTTPChainInstance.method(@\"POST\")\n                                        .url(@\"\")\n                                        .params(@{@\"dis_id\":@\"9\"})\n                                        .executeSignal();\n\nRACSignal *mergeSignal = [RACSignal merge:@[signalA,signalB,signalC]];\n[mergeSignal subscribeNext:^(DKResponse *x){\n      DKLog(@\"%zd  %@\",x.taskIdentifier,x.rawData);\n}];\n```\n\n上面这个例子的结果会依次执行三个接口，并且按照接口返回的顺序执行mergeSignal 的 subscribeNext 的 block\n\n### 同时请求接口，等所有接口返回数据之后再进行渲染\n\n> 上面的三个 Signal就不重复写了\n\n```\nRACSignal *mergeSignal  = [RACSignal zip:@[signalA,signalB,signalC]];\n[mergeSignal subscribeNext:^(RACTuple *x){\n     [x.rac_sequence.signal subscribeNext:^(DKResponse *x) {\n         DKLog(@\"%@\",x.rawData);\n     }];\n}];\n```\n\n上面的 `mergeSignal` 里面会发送一个 `RACTuple` ,里面依次包装着三个请求 Signal的 `DKResponse`回调对象\n\n### 接口串联，上一个接口响应的数据作为下一个接口的参数\n\n```\n RACSignal *flattenSignal = [signalA flattenMap:^RACStream *(DKResponse *value) {\n        NSString *did = value.result[@\"content\"][0][@\"d_id\"];\n        return DKHTTPChainInstance.method(@\"GET\")\n                                 .url(@\"\")\n                                 .params(@{@\"did\":did,@\"page\":@\"1\",@\"num\":@\"20\"})\n                                 .executeSignal();\n}];\n[flattenSignal subscribeNext:^(DKResponse *x) {\n    DKLog(@\"%@\",x.rawData);\n}];\n```\n\n平时常用的大概就这么几个，待补充吧，之后我会继续讲讲关于异常处理的问题。","source":"_posts/使用RAC-DKHTTPTool实践.md","raw":"---\ntitle: 使用RAC+DKHTTPTool实践\nauthor: Arclin\ntags:\n  - iOS\n  - Reactive Cocoa\ncategories:\n  - iOS\nabbrlink: 8d52056b\ndate: 2016-12-26 00:00:00\n---\n使用RAC+DKHTTP套件实践\n- 这次通过一个简单的例子来解说DKHTTP套件与 RAC 结合的使用\n\n<!-- more -->\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/444.png?raw=true)\n\n- 首先简析下这个界面\n\t- 顶部搜索框部分的背景：广告栏位+图书推荐的图片，这里是一个获取图片的接口（接口 A）\n\t- 图书推荐： 这里也是一个接口，需要显示图书的封面（接口 B）\n\t- 笔记推荐： 这里也是一个接口，需要显示图书笔记的一些简介 （接口 C）\n- 页面渲染\n\n\t- 同页面多接口的渲染方式有多种： \n    \t-\t一是接口的串联，也就是一个接口返回的数据交作为参数给下一个接口去发送请求 ；\n    \t- 二是同时发送请求，根据接口返回的顺序渲染页面；\n    \t- 三是同时请求，等所有的接口返回之后再一次性进行渲染。\n\t- 上面的三种渲染方式，RACSignal都有相应的解决方案，假设这里页面渲染的方式选择的是依次渲染，那么我们使用 DKHTTPChainTool 的executeSignal()来写个例子\n\n```\n RACSignal *signalA = DKHTTPChainInstance.method(@\"POST\")\n                                         .url(@\"\")\n                                         .params(@{@\"did\":@\"1\",@\"page\":@\"1\",@\"num\":@\"100\"})\n                                         .executeSignal();\n\nRACSignal *signalB = DKHTTPChainInstance.method(@\"POST\")\n                                        .url(@\"\")\n                                        .params(@{@\"dis_id\":@\"9\"})\n                                        .executeSignal();\n\nRACSignal *signalC = DKHTTPChainInstance.method(@\"POST\")\n                                        .url(@\"\")\n                                        .params(@{@\"dis_id\":@\"9\"})\n                                        .executeSignal();\n\nRACSignal *mergeSignal = [RACSignal merge:@[signalA,signalB,signalC]];\n[mergeSignal subscribeNext:^(DKResponse *x){\n      DKLog(@\"%zd  %@\",x.taskIdentifier,x.rawData);\n}];\n```\n\n上面这个例子的结果会依次执行三个接口，并且按照接口返回的顺序执行mergeSignal 的 subscribeNext 的 block\n\n### 同时请求接口，等所有接口返回数据之后再进行渲染\n\n> 上面的三个 Signal就不重复写了\n\n```\nRACSignal *mergeSignal  = [RACSignal zip:@[signalA,signalB,signalC]];\n[mergeSignal subscribeNext:^(RACTuple *x){\n     [x.rac_sequence.signal subscribeNext:^(DKResponse *x) {\n         DKLog(@\"%@\",x.rawData);\n     }];\n}];\n```\n\n上面的 `mergeSignal` 里面会发送一个 `RACTuple` ,里面依次包装着三个请求 Signal的 `DKResponse`回调对象\n\n### 接口串联，上一个接口响应的数据作为下一个接口的参数\n\n```\n RACSignal *flattenSignal = [signalA flattenMap:^RACStream *(DKResponse *value) {\n        NSString *did = value.result[@\"content\"][0][@\"d_id\"];\n        return DKHTTPChainInstance.method(@\"GET\")\n                                 .url(@\"\")\n                                 .params(@{@\"did\":did,@\"page\":@\"1\",@\"num\":@\"20\"})\n                                 .executeSignal();\n}];\n[flattenSignal subscribeNext:^(DKResponse *x) {\n    DKLog(@\"%@\",x.rawData);\n}];\n```\n\n平时常用的大概就这么几个，待补充吧，之后我会继续讲讲关于异常处理的问题。","slug":"使用RAC-DKHTTPTool实践","published":1,"updated":"2021-06-06T18:52:24.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoif005ntnn0fldog9fi","content":"<p>使用RAC+DKHTTP套件实践</p>\n<ul>\n<li>这次通过一个简单的例子来解说DKHTTP套件与 RAC 结合的使用</li>\n</ul>\n<span id=\"more\"></span>\n\n<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/444.png?raw=true\"></p>\n<ul>\n<li><p>首先简析下这个界面</p>\n<ul>\n<li>顶部搜索框部分的背景：广告栏位+图书推荐的图片，这里是一个获取图片的接口（接口 A）</li>\n<li>图书推荐： 这里也是一个接口，需要显示图书的封面（接口 B）</li>\n<li>笔记推荐： 这里也是一个接口，需要显示图书笔记的一些简介 （接口 C）</li>\n</ul>\n</li>\n<li><p>页面渲染</p>\n<ul>\n<li>同页面多接口的渲染方式有多种： <ul>\n<li>   一是接口的串联，也就是一个接口返回的数据交作为参数给下一个接口去发送请求 ；</li>\n<li>二是同时发送请求，根据接口返回的顺序渲染页面；</li>\n<li>三是同时请求，等所有的接口返回之后再一次性进行渲染。</li>\n</ul>\n</li>\n<li>上面的三种渲染方式，RACSignal都有相应的解决方案，假设这里页面渲染的方式选择的是依次渲染，那么我们使用 DKHTTPChainTool 的executeSignal()来写个例子</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> RACSignal *signalA &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                         .url(@&quot;&quot;)</span><br><span class=\"line\">                                         .params(@&#123;@&quot;did&quot;:@&quot;1&quot;,@&quot;page&quot;:@&quot;1&quot;,@&quot;num&quot;:@&quot;100&quot;&#125;)</span><br><span class=\"line\">                                         .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *signalB &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url(@&quot;&quot;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;dis_id&quot;:@&quot;9&quot;&#125;)</span><br><span class=\"line\">                                        .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *signalC &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url(@&quot;&quot;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;dis_id&quot;:@&quot;9&quot;&#125;)</span><br><span class=\"line\">                                        .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *mergeSignal &#x3D; [RACSignal merge:@[signalA,signalB,signalC]];</span><br><span class=\"line\">[mergeSignal subscribeNext:^(DKResponse *x)&#123;</span><br><span class=\"line\">      DKLog(@&quot;%zd  %@&quot;,x.taskIdentifier,x.rawData);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>上面这个例子的结果会依次执行三个接口，并且按照接口返回的顺序执行mergeSignal 的 subscribeNext 的 block</p>\n<h3 id=\"同时请求接口，等所有接口返回数据之后再进行渲染\"><a href=\"#同时请求接口，等所有接口返回数据之后再进行渲染\" class=\"headerlink\" title=\"同时请求接口，等所有接口返回数据之后再进行渲染\"></a>同时请求接口，等所有接口返回数据之后再进行渲染</h3><blockquote>\n<p>上面的三个 Signal就不重复写了</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *mergeSignal  &#x3D; [RACSignal zip:@[signalA,signalB,signalC]];</span><br><span class=\"line\">[mergeSignal subscribeNext:^(RACTuple *x)&#123;</span><br><span class=\"line\">     [x.rac_sequence.signal subscribeNext:^(DKResponse *x) &#123;</span><br><span class=\"line\">         DKLog(@&quot;%@&quot;,x.rawData);</span><br><span class=\"line\">     &#125;];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>上面的 <code>mergeSignal</code> 里面会发送一个 <code>RACTuple</code> ,里面依次包装着三个请求 Signal的 <code>DKResponse</code>回调对象</p>\n<h3 id=\"接口串联，上一个接口响应的数据作为下一个接口的参数\"><a href=\"#接口串联，上一个接口响应的数据作为下一个接口的参数\" class=\"headerlink\" title=\"接口串联，上一个接口响应的数据作为下一个接口的参数\"></a>接口串联，上一个接口响应的数据作为下一个接口的参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> RACSignal *flattenSignal &#x3D; [signalA flattenMap:^RACStream *(DKResponse *value) &#123;</span><br><span class=\"line\">        NSString *did &#x3D; value.result[@&quot;content&quot;][0][@&quot;d_id&quot;];</span><br><span class=\"line\">        return DKHTTPChainInstance.method(@&quot;GET&quot;)</span><br><span class=\"line\">                                 .url(@&quot;&quot;)</span><br><span class=\"line\">                                 .params(@&#123;@&quot;did&quot;:did,@&quot;page&quot;:@&quot;1&quot;,@&quot;num&quot;:@&quot;20&quot;&#125;)</span><br><span class=\"line\">                                 .executeSignal();</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">[flattenSignal subscribeNext:^(DKResponse *x) &#123;</span><br><span class=\"line\">    DKLog(@&quot;%@&quot;,x.rawData);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>平时常用的大概就这么几个，待补充吧，之后我会继续讲讲关于异常处理的问题。</p>\n","site":{"data":{}},"excerpt":"<p>使用RAC+DKHTTP套件实践</p>\n<ul>\n<li>这次通过一个简单的例子来解说DKHTTP套件与 RAC 结合的使用</li>\n</ul>","more":"<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/444.png?raw=true\"></p>\n<ul>\n<li><p>首先简析下这个界面</p>\n<ul>\n<li>顶部搜索框部分的背景：广告栏位+图书推荐的图片，这里是一个获取图片的接口（接口 A）</li>\n<li>图书推荐： 这里也是一个接口，需要显示图书的封面（接口 B）</li>\n<li>笔记推荐： 这里也是一个接口，需要显示图书笔记的一些简介 （接口 C）</li>\n</ul>\n</li>\n<li><p>页面渲染</p>\n<ul>\n<li>同页面多接口的渲染方式有多种： <ul>\n<li>   一是接口的串联，也就是一个接口返回的数据交作为参数给下一个接口去发送请求 ；</li>\n<li>二是同时发送请求，根据接口返回的顺序渲染页面；</li>\n<li>三是同时请求，等所有的接口返回之后再一次性进行渲染。</li>\n</ul>\n</li>\n<li>上面的三种渲染方式，RACSignal都有相应的解决方案，假设这里页面渲染的方式选择的是依次渲染，那么我们使用 DKHTTPChainTool 的executeSignal()来写个例子</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> RACSignal *signalA &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                         .url(@&quot;&quot;)</span><br><span class=\"line\">                                         .params(@&#123;@&quot;did&quot;:@&quot;1&quot;,@&quot;page&quot;:@&quot;1&quot;,@&quot;num&quot;:@&quot;100&quot;&#125;)</span><br><span class=\"line\">                                         .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *signalB &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url(@&quot;&quot;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;dis_id&quot;:@&quot;9&quot;&#125;)</span><br><span class=\"line\">                                        .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *signalC &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url(@&quot;&quot;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;dis_id&quot;:@&quot;9&quot;&#125;)</span><br><span class=\"line\">                                        .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *mergeSignal &#x3D; [RACSignal merge:@[signalA,signalB,signalC]];</span><br><span class=\"line\">[mergeSignal subscribeNext:^(DKResponse *x)&#123;</span><br><span class=\"line\">      DKLog(@&quot;%zd  %@&quot;,x.taskIdentifier,x.rawData);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>上面这个例子的结果会依次执行三个接口，并且按照接口返回的顺序执行mergeSignal 的 subscribeNext 的 block</p>\n<h3 id=\"同时请求接口，等所有接口返回数据之后再进行渲染\"><a href=\"#同时请求接口，等所有接口返回数据之后再进行渲染\" class=\"headerlink\" title=\"同时请求接口，等所有接口返回数据之后再进行渲染\"></a>同时请求接口，等所有接口返回数据之后再进行渲染</h3><blockquote>\n<p>上面的三个 Signal就不重复写了</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *mergeSignal  &#x3D; [RACSignal zip:@[signalA,signalB,signalC]];</span><br><span class=\"line\">[mergeSignal subscribeNext:^(RACTuple *x)&#123;</span><br><span class=\"line\">     [x.rac_sequence.signal subscribeNext:^(DKResponse *x) &#123;</span><br><span class=\"line\">         DKLog(@&quot;%@&quot;,x.rawData);</span><br><span class=\"line\">     &#125;];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>上面的 <code>mergeSignal</code> 里面会发送一个 <code>RACTuple</code> ,里面依次包装着三个请求 Signal的 <code>DKResponse</code>回调对象</p>\n<h3 id=\"接口串联，上一个接口响应的数据作为下一个接口的参数\"><a href=\"#接口串联，上一个接口响应的数据作为下一个接口的参数\" class=\"headerlink\" title=\"接口串联，上一个接口响应的数据作为下一个接口的参数\"></a>接口串联，上一个接口响应的数据作为下一个接口的参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> RACSignal *flattenSignal &#x3D; [signalA flattenMap:^RACStream *(DKResponse *value) &#123;</span><br><span class=\"line\">        NSString *did &#x3D; value.result[@&quot;content&quot;][0][@&quot;d_id&quot;];</span><br><span class=\"line\">        return DKHTTPChainInstance.method(@&quot;GET&quot;)</span><br><span class=\"line\">                                 .url(@&quot;&quot;)</span><br><span class=\"line\">                                 .params(@&#123;@&quot;did&quot;:did,@&quot;page&quot;:@&quot;1&quot;,@&quot;num&quot;:@&quot;20&quot;&#125;)</span><br><span class=\"line\">                                 .executeSignal();</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">[flattenSignal subscribeNext:^(DKResponse *x) &#123;</span><br><span class=\"line\">    DKLog(@&quot;%@&quot;,x.rawData);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>平时常用的大概就这么几个，待补充吧，之后我会继续讲讲关于异常处理的问题。</p>"},{"title":"依赖注入与Objection","abbrlink":"6ae5f77f","date":"2020-05-01T02:44:01.000Z","_content":"\n本文会说明iOS内依赖注入的概念和依赖注入框架Objection的一般使用\n\n<!--more-->\n\n#### 依赖注入\n\n首先先说明什么叫做依赖注入\n\n比如AController跳转到BController,那么这时候BController就需要在AController内部进行实例化，如下\n\n```\n@implementation AController : UIViewController\n\n...\n\n- (void)jump \n{\n\tBController *bController = [[BController alloc] init];\n    [self.navigationController pushViewController:bController animated:YES];\n}\n\n@end\n\n```\n\n这么做的话，当AController被封装成组件之后，BController的配置将会被限制，外部无法改变BController任何细节，所以我们 ** 稍 加 改 进 **\n\n```\n@implementation AController : UIViewController\n\n...\n\n- (instancetype)initWithCreateBlock:(UIViewController *(^)(void))createBViewControllerBlock {\n\t....\n\tself.createBViewControllerBlock = createBViewControllerBlock;\n\t...\n}\n\n- (void)jump \n{\n\tUIViewController *bController = self.createBViewControllerBlock();\n    [self.navigationController pushViewController:bController animated:YES];\n}\n\n@end\n\n```\n\n```\n[[AController alloc] initWithCreateBlock:UIViewController* ^{\n\tBController *bController = [[BController alloc] initWithTitle:@\"xxx\"];\n\treturn bController;\n}];\n```\n\n将BController的创建通过Block暴露出来，AController内部不关心BController是如何被创建的，那么AController对BController的依赖将通过外部的Block进行注入。\n\n这，就是依赖注入。\n\n\n当然这是最简单的依赖注入，无法满足我们复杂的需求，所以有时候我们需要使用第三方框架，如`Objection`和`Typhoon`\n\n#### Objection\n\n接下来说明一下Objection的使用\n\nObjection 是一个依赖注入框架，能够在你获取一个类的实例的时候，这个类内部的属性也同时会被实例化。举个例子：\n\n```\n//Car.h\n\n@class Engine,Break;\n\n@interface Car : NSObject\n\n@property (nonatomic, strong) Engine *engine;\n\n@property (nonatomic, strong) Break *breaks;\n\n@end\n\n```\n\n```\n//Car.m\n\n#import <Objection/Objection.h>\n\n@implementation Car\nobjection_requires(@\"engine\", @\"breaks\")\n\n@end\n\n```\n\n创建一个默认注射器\n\n```\nJSObjectionInjector *injector = [JSObjection createInjector];\n[JSObjection setDefaultInjector:injector];\n```\n\n实例化Car对象\n```\nCar *car = [[JSObjection defaultInjector] getObject:[Car class]];\n```\n\n这时候所依赖的`engine`对象和`breaks`对象都会通过`init`方法实例化\n\n最后打印属性\n\n```\ncar <Car: 0x6000006d8480> engine <Engine: 0x6000004841b0> breaks <Break: 0x6000004841e0>\n```\n\n假如说Car对象不能通过`init`或者`initWithXXX`等自定义构造方法去实例化，那么我们需要指定方法，让注射器在指定的方法构建依赖\n\n```\n@implementation Car\nobjection_requires(@\"engine\", @\"breaks\")\n- (void)awakeFromNib {\n  [[JSObjection defaultInjector] injectDependencies:self];\n}\n@end\n```\n\n当Car被注射器初始化完成之后，会调用`- awakeFromObjection`方法，这里可以额外赋一些值\n\n```\n- (void)awakeFromObjection \n{\n\tself.test = @\"111\";\n}\n```\n\n上面的说的都是直接init出来的对象，但是更多情况下我们需要指定构造方法\n\n```\n@implementation Car\nobjection_initializer_sel(@selector(initWithObject:)) // 该宏只需且只能出现一次\n\n- (instancetype)initWithObject:(id)object\n{\n    if (self = [super init]) {\n        self.test = object;\n    }\n    return self;\n}\n@end\n```\n\n取出的时候加上`argumentList:`参数即可\n```\n Car *car = [[JSObjection defaultInjector] getObject:[Car class] argumentList:@[@\"aaaa\"]];\n```\n\n或者不想写`objection_initializer_sel()`宏的话\n可以直接在取的方法那里改动一下变成\n\n```\nCar *car = [[JSObjection defaultInjector] getObject:[Car class] initializer:@selector(initWithObject:) argumentList:@[@\"aaaa\"]];\n```\n\n效果也是一样的\n\n##### 对象工厂\n\n在Car中添加一个对象工厂属性\n\n```\n@property(nonatomic, strong) JSObjectFactory *objectFactory;\n```\n\n然后标记注入里面加多一个`objectFactory`\n\n```\nobjection_requires(@\"engine\", @\"breaks\",@\"objectFactory\")\n```\n\n然后你就可以通过\n\n```\nid obj = [self.objectFactory getObject:[Engine class]];\n```\n\n获取到对应的对象\n\n##### 模块\n\n你可以创建一个继承自`JSObjectionModule`的模块，在里面绑定相对应的`事物`，便可直接取到对应的值\n\n例如  一个协议和一个模块类，对象绑定了类名和这个类所遵循的协议\n\n```\n\n@protocol APIService <NSObject>\n\n- (void)api:(NSString *)params;\n\n@end\n\n\n@interface ModuleA : JSObjectionModule\n\n@end\n\n@implementation ModuleA\n\n- (void)configure\n{\n    [self bindClass:[MyAPIService class] toProtocol:@protocol(APIService)];\n}\n\n@end\n\n```\n\n这时候注射器初始化方式改为\n\n```\nJSObjectionInjector *injectorA = [JSObjection createInjector:ModuleA.new]; [JSObjection setDefaultInjector:injectorA];\n```\n\n你就可以直接拿到对应遵循了这个协议的对象而不用通过ModuleA的实例对象\n\n```\nMyAPIService *delegate = [injectorA getObject:@protocol(APIService)];\n```\n\n**注意由于绑定的时候是用了bindClass:方法，所以每次取出都是不同的对象**\n\n除了绑定对象类名和协议外，还可以绑定一个对象和绑定一个类名\n\n```\n@implementation ModuleA\n\n- (void)configure\n{\n    [self bind:对象实例 toClass:[UIApplication class]];\n    [self bind:对象实例 toProtocol:@protocol(UIApplicationDelegate)];\n}\n\n@end\n\n```\n\n**注意由于绑定的时候是用了bind:方法，所以每次取出都是相同的对象 **\n\n当对象被创建的时候，可以通过bindBlock:方法进行干涉\n\n```\n@implementation ModuleA\n\n- (void)configure\n{\n    [self bindClass:[MyAPIService class] toProtocol:@protocol(APIService)];\n    [self bindBlock:^id(JSObjectionInjector *context) {\n        MyAPIService *service = [[MyAPIService alloc] init];\n        service.buildByMySelf = YES;\n        return service;\n    } toClass:[MyAPIService class]];\n}\n\n@end\n```\n\n上面这个例子表示MyAPIService被实例化后都会带上`buildByMySelf = YES`\n\n但是用这种方法的话，假如用注射器取出对象的时候带上了参数，那我们就没办法拿到参数了，所以我们需要用到`ObjectionProvider`协议\n\n```\n@interface ProviderA : JSObjectionModule<JSObjectionProvider>\n\n@end\n\n@implementation ProviderA\n- (id)provide:(JSObjectionInjector *)context arguments:(NSArray *)arguments\n{\n    MyAPIService *service = [[MyAPIService alloc] init];\n    service.buildByProvider = YES;\n    service.arguments = arguments;\n    return service;\n}\n\n- (void)configure\n{\n\t[self bindProvider:[ModuleA new] toClass:MyAPIService.class];\n}\n\n@end\n```\n\n这样子就能手动构建对象并且得到参数了\n\n##### 作用域\n\n上面提及的`bindClass:`、`bindBlock:`、`bindProvider:`这些方法，都有一个拓展参数`inScope:(JSObjectionScope)scope;`\n\n比如：\n\n```\n[self bindClass:[MyAPIService class] toProtocol:@protocol(APIService) inScope:JSObjectionScopeSingleton named:@\"\"];\n\n[self bindBlock:^id(JSObjectionInjector *context) {\n\tMyAPIService *service = [[MyAPIService alloc] init];\n\tservice.buildByMySelf = YES;\n\treturn service;\n} toClass:[MyAPIService class] inScope:JSObjectionScopeSingleton named:@\"\"];\n\n[self bindProvider:[ModuleA new] toClass:MyAPIService.class inScope:JSObjectionScopeSingleton];\n```\n\n`JSObjectionScopeSingleton`意味着注射器取出来的都是同个对象，\n`JSObjectionScopeNormal`意味着注射器取出来的是不同对象。\n\n##### 总结\n\nObjection 帮助你实现** 依赖注入 **，你只需要完成两件事情，配置依赖关系和获取依赖对象。配置依赖关系时，你可以使用几个常用的宏来快速的完成依赖关系的配置，另外你还可以使用模块的概念来完成更多的绑定操作，它允许你将某些类或某些协议接口绑定到某个或某一类的对象上，在配置完成后，你就可以使用关键的 injector 注入器获取到你所需要的对象。\n\nObjection 像是一种字典容器，通过多种形式将 value 和 key 关联起来，在完成配置之后，你只需要关注你通过何种 key 获取到需要的 value 即可。Objection 最主要的功能之一就是面向接口编程的实现，在上面的示例中也进行了演示，面向接口编程是一种非常重要的编程思想。\n","source":"_posts/依赖注入与Objection.md","raw":"---\ntitle: 依赖注入与Objection\ntags:\n  - iOS\n  - 架构\ncategories:\n  - iOS\nabbrlink: 6ae5f77f\ndate: 2020-05-01 10:44:01\n---\n\n本文会说明iOS内依赖注入的概念和依赖注入框架Objection的一般使用\n\n<!--more-->\n\n#### 依赖注入\n\n首先先说明什么叫做依赖注入\n\n比如AController跳转到BController,那么这时候BController就需要在AController内部进行实例化，如下\n\n```\n@implementation AController : UIViewController\n\n...\n\n- (void)jump \n{\n\tBController *bController = [[BController alloc] init];\n    [self.navigationController pushViewController:bController animated:YES];\n}\n\n@end\n\n```\n\n这么做的话，当AController被封装成组件之后，BController的配置将会被限制，外部无法改变BController任何细节，所以我们 ** 稍 加 改 进 **\n\n```\n@implementation AController : UIViewController\n\n...\n\n- (instancetype)initWithCreateBlock:(UIViewController *(^)(void))createBViewControllerBlock {\n\t....\n\tself.createBViewControllerBlock = createBViewControllerBlock;\n\t...\n}\n\n- (void)jump \n{\n\tUIViewController *bController = self.createBViewControllerBlock();\n    [self.navigationController pushViewController:bController animated:YES];\n}\n\n@end\n\n```\n\n```\n[[AController alloc] initWithCreateBlock:UIViewController* ^{\n\tBController *bController = [[BController alloc] initWithTitle:@\"xxx\"];\n\treturn bController;\n}];\n```\n\n将BController的创建通过Block暴露出来，AController内部不关心BController是如何被创建的，那么AController对BController的依赖将通过外部的Block进行注入。\n\n这，就是依赖注入。\n\n\n当然这是最简单的依赖注入，无法满足我们复杂的需求，所以有时候我们需要使用第三方框架，如`Objection`和`Typhoon`\n\n#### Objection\n\n接下来说明一下Objection的使用\n\nObjection 是一个依赖注入框架，能够在你获取一个类的实例的时候，这个类内部的属性也同时会被实例化。举个例子：\n\n```\n//Car.h\n\n@class Engine,Break;\n\n@interface Car : NSObject\n\n@property (nonatomic, strong) Engine *engine;\n\n@property (nonatomic, strong) Break *breaks;\n\n@end\n\n```\n\n```\n//Car.m\n\n#import <Objection/Objection.h>\n\n@implementation Car\nobjection_requires(@\"engine\", @\"breaks\")\n\n@end\n\n```\n\n创建一个默认注射器\n\n```\nJSObjectionInjector *injector = [JSObjection createInjector];\n[JSObjection setDefaultInjector:injector];\n```\n\n实例化Car对象\n```\nCar *car = [[JSObjection defaultInjector] getObject:[Car class]];\n```\n\n这时候所依赖的`engine`对象和`breaks`对象都会通过`init`方法实例化\n\n最后打印属性\n\n```\ncar <Car: 0x6000006d8480> engine <Engine: 0x6000004841b0> breaks <Break: 0x6000004841e0>\n```\n\n假如说Car对象不能通过`init`或者`initWithXXX`等自定义构造方法去实例化，那么我们需要指定方法，让注射器在指定的方法构建依赖\n\n```\n@implementation Car\nobjection_requires(@\"engine\", @\"breaks\")\n- (void)awakeFromNib {\n  [[JSObjection defaultInjector] injectDependencies:self];\n}\n@end\n```\n\n当Car被注射器初始化完成之后，会调用`- awakeFromObjection`方法，这里可以额外赋一些值\n\n```\n- (void)awakeFromObjection \n{\n\tself.test = @\"111\";\n}\n```\n\n上面的说的都是直接init出来的对象，但是更多情况下我们需要指定构造方法\n\n```\n@implementation Car\nobjection_initializer_sel(@selector(initWithObject:)) // 该宏只需且只能出现一次\n\n- (instancetype)initWithObject:(id)object\n{\n    if (self = [super init]) {\n        self.test = object;\n    }\n    return self;\n}\n@end\n```\n\n取出的时候加上`argumentList:`参数即可\n```\n Car *car = [[JSObjection defaultInjector] getObject:[Car class] argumentList:@[@\"aaaa\"]];\n```\n\n或者不想写`objection_initializer_sel()`宏的话\n可以直接在取的方法那里改动一下变成\n\n```\nCar *car = [[JSObjection defaultInjector] getObject:[Car class] initializer:@selector(initWithObject:) argumentList:@[@\"aaaa\"]];\n```\n\n效果也是一样的\n\n##### 对象工厂\n\n在Car中添加一个对象工厂属性\n\n```\n@property(nonatomic, strong) JSObjectFactory *objectFactory;\n```\n\n然后标记注入里面加多一个`objectFactory`\n\n```\nobjection_requires(@\"engine\", @\"breaks\",@\"objectFactory\")\n```\n\n然后你就可以通过\n\n```\nid obj = [self.objectFactory getObject:[Engine class]];\n```\n\n获取到对应的对象\n\n##### 模块\n\n你可以创建一个继承自`JSObjectionModule`的模块，在里面绑定相对应的`事物`，便可直接取到对应的值\n\n例如  一个协议和一个模块类，对象绑定了类名和这个类所遵循的协议\n\n```\n\n@protocol APIService <NSObject>\n\n- (void)api:(NSString *)params;\n\n@end\n\n\n@interface ModuleA : JSObjectionModule\n\n@end\n\n@implementation ModuleA\n\n- (void)configure\n{\n    [self bindClass:[MyAPIService class] toProtocol:@protocol(APIService)];\n}\n\n@end\n\n```\n\n这时候注射器初始化方式改为\n\n```\nJSObjectionInjector *injectorA = [JSObjection createInjector:ModuleA.new]; [JSObjection setDefaultInjector:injectorA];\n```\n\n你就可以直接拿到对应遵循了这个协议的对象而不用通过ModuleA的实例对象\n\n```\nMyAPIService *delegate = [injectorA getObject:@protocol(APIService)];\n```\n\n**注意由于绑定的时候是用了bindClass:方法，所以每次取出都是不同的对象**\n\n除了绑定对象类名和协议外，还可以绑定一个对象和绑定一个类名\n\n```\n@implementation ModuleA\n\n- (void)configure\n{\n    [self bind:对象实例 toClass:[UIApplication class]];\n    [self bind:对象实例 toProtocol:@protocol(UIApplicationDelegate)];\n}\n\n@end\n\n```\n\n**注意由于绑定的时候是用了bind:方法，所以每次取出都是相同的对象 **\n\n当对象被创建的时候，可以通过bindBlock:方法进行干涉\n\n```\n@implementation ModuleA\n\n- (void)configure\n{\n    [self bindClass:[MyAPIService class] toProtocol:@protocol(APIService)];\n    [self bindBlock:^id(JSObjectionInjector *context) {\n        MyAPIService *service = [[MyAPIService alloc] init];\n        service.buildByMySelf = YES;\n        return service;\n    } toClass:[MyAPIService class]];\n}\n\n@end\n```\n\n上面这个例子表示MyAPIService被实例化后都会带上`buildByMySelf = YES`\n\n但是用这种方法的话，假如用注射器取出对象的时候带上了参数，那我们就没办法拿到参数了，所以我们需要用到`ObjectionProvider`协议\n\n```\n@interface ProviderA : JSObjectionModule<JSObjectionProvider>\n\n@end\n\n@implementation ProviderA\n- (id)provide:(JSObjectionInjector *)context arguments:(NSArray *)arguments\n{\n    MyAPIService *service = [[MyAPIService alloc] init];\n    service.buildByProvider = YES;\n    service.arguments = arguments;\n    return service;\n}\n\n- (void)configure\n{\n\t[self bindProvider:[ModuleA new] toClass:MyAPIService.class];\n}\n\n@end\n```\n\n这样子就能手动构建对象并且得到参数了\n\n##### 作用域\n\n上面提及的`bindClass:`、`bindBlock:`、`bindProvider:`这些方法，都有一个拓展参数`inScope:(JSObjectionScope)scope;`\n\n比如：\n\n```\n[self bindClass:[MyAPIService class] toProtocol:@protocol(APIService) inScope:JSObjectionScopeSingleton named:@\"\"];\n\n[self bindBlock:^id(JSObjectionInjector *context) {\n\tMyAPIService *service = [[MyAPIService alloc] init];\n\tservice.buildByMySelf = YES;\n\treturn service;\n} toClass:[MyAPIService class] inScope:JSObjectionScopeSingleton named:@\"\"];\n\n[self bindProvider:[ModuleA new] toClass:MyAPIService.class inScope:JSObjectionScopeSingleton];\n```\n\n`JSObjectionScopeSingleton`意味着注射器取出来的都是同个对象，\n`JSObjectionScopeNormal`意味着注射器取出来的是不同对象。\n\n##### 总结\n\nObjection 帮助你实现** 依赖注入 **，你只需要完成两件事情，配置依赖关系和获取依赖对象。配置依赖关系时，你可以使用几个常用的宏来快速的完成依赖关系的配置，另外你还可以使用模块的概念来完成更多的绑定操作，它允许你将某些类或某些协议接口绑定到某个或某一类的对象上，在配置完成后，你就可以使用关键的 injector 注入器获取到你所需要的对象。\n\nObjection 像是一种字典容器，通过多种形式将 value 和 key 关联起来，在完成配置之后，你只需要关注你通过何种 key 获取到需要的 value 即可。Objection 最主要的功能之一就是面向接口编程的实现，在上面的示例中也进行了演示，面向接口编程是一种非常重要的编程思想。\n","slug":"依赖注入与Objection","published":1,"updated":"2021-06-06T18:52:24.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoig005qtnn08hrfcqjl","content":"<p>本文会说明iOS内依赖注入的概念和依赖注入框架Objection的一般使用</p>\n<span id=\"more\"></span>\n\n<h4 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h4><p>首先先说明什么叫做依赖注入</p>\n<p>比如AController跳转到BController,那么这时候BController就需要在AController内部进行实例化，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation AController : UIViewController</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)jump </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBController *bController &#x3D; [[BController alloc] init];</span><br><span class=\"line\">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这么做的话，当AController被封装成组件之后，BController的配置将会被限制，外部无法改变BController任何细节，所以我们 ** 稍 加 改 进 **</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation AController : UIViewController</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithCreateBlock:(UIViewController *(^)(void))createBViewControllerBlock &#123;</span><br><span class=\"line\">\t....</span><br><span class=\"line\">\tself.createBViewControllerBlock &#x3D; createBViewControllerBlock;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)jump </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tUIViewController *bController &#x3D; self.createBViewControllerBlock();</span><br><span class=\"line\">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[AController alloc] initWithCreateBlock:UIViewController* ^&#123;</span><br><span class=\"line\">\tBController *bController &#x3D; [[BController alloc] initWithTitle:@&quot;xxx&quot;];</span><br><span class=\"line\">\treturn bController;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>将BController的创建通过Block暴露出来，AController内部不关心BController是如何被创建的，那么AController对BController的依赖将通过外部的Block进行注入。</p>\n<p>这，就是依赖注入。</p>\n<p>当然这是最简单的依赖注入，无法满足我们复杂的需求，所以有时候我们需要使用第三方框架，如<code>Objection</code>和<code>Typhoon</code></p>\n<h4 id=\"Objection\"><a href=\"#Objection\" class=\"headerlink\" title=\"Objection\"></a>Objection</h4><p>接下来说明一下Objection的使用</p>\n<p>Objection 是一个依赖注入框架，能够在你获取一个类的实例的时候，这个类内部的属性也同时会被实例化。举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Car.h</span><br><span class=\"line\"></span><br><span class=\"line\">@class Engine,Break;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface Car : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, strong) Engine *engine;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, strong) Break *breaks;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Car.m</span><br><span class=\"line\"></span><br><span class=\"line\">#import &lt;Objection&#x2F;Objection.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Car</span><br><span class=\"line\">objection_requires(@&quot;engine&quot;, @&quot;breaks&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>创建一个默认注射器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSObjectionInjector *injector &#x3D; [JSObjection createInjector];</span><br><span class=\"line\">[JSObjection setDefaultInjector:injector];</span><br></pre></td></tr></table></figure>\n\n<p>实例化Car对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Car *car &#x3D; [[JSObjection defaultInjector] getObject:[Car class]];</span><br></pre></td></tr></table></figure>\n\n<p>这时候所依赖的<code>engine</code>对象和<code>breaks</code>对象都会通过<code>init</code>方法实例化</p>\n<p>最后打印属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">car &lt;Car: 0x6000006d8480&gt; engine &lt;Engine: 0x6000004841b0&gt; breaks &lt;Break: 0x6000004841e0&gt;</span><br></pre></td></tr></table></figure>\n\n<p>假如说Car对象不能通过<code>init</code>或者<code>initWithXXX</code>等自定义构造方法去实例化，那么我们需要指定方法，让注射器在指定的方法构建依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Car</span><br><span class=\"line\">objection_requires(@&quot;engine&quot;, @&quot;breaks&quot;)</span><br><span class=\"line\">- (void)awakeFromNib &#123;</span><br><span class=\"line\">  [[JSObjection defaultInjector] injectDependencies:self];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>当Car被注射器初始化完成之后，会调用<code>- awakeFromObjection</code>方法，这里可以额外赋一些值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)awakeFromObjection </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tself.test &#x3D; @&quot;111&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的说的都是直接init出来的对象，但是更多情况下我们需要指定构造方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Car</span><br><span class=\"line\">objection_initializer_sel(@selector(initWithObject:)) &#x2F;&#x2F; 该宏只需且只能出现一次</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithObject:(id)object</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (self &#x3D; [super init]) &#123;</span><br><span class=\"line\">        self.test &#x3D; object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>取出的时候加上<code>argumentList:</code>参数即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Car *car &#x3D; [[JSObjection defaultInjector] getObject:[Car class] argumentList:@[@&quot;aaaa&quot;]];</span><br></pre></td></tr></table></figure>\n\n<p>或者不想写<code>objection_initializer_sel()</code>宏的话<br>可以直接在取的方法那里改动一下变成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Car *car &#x3D; [[JSObjection defaultInjector] getObject:[Car class] initializer:@selector(initWithObject:) argumentList:@[@&quot;aaaa&quot;]];</span><br></pre></td></tr></table></figure>\n\n<p>效果也是一样的</p>\n<h5 id=\"对象工厂\"><a href=\"#对象工厂\" class=\"headerlink\" title=\"对象工厂\"></a>对象工厂</h5><p>在Car中添加一个对象工厂属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property(nonatomic, strong) JSObjectFactory *objectFactory;</span><br></pre></td></tr></table></figure>\n\n<p>然后标记注入里面加多一个<code>objectFactory</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objection_requires(@&quot;engine&quot;, @&quot;breaks&quot;,@&quot;objectFactory&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>然后你就可以通过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj &#x3D; [self.objectFactory getObject:[Engine class]];</span><br></pre></td></tr></table></figure>\n\n<p>获取到对应的对象</p>\n<h5 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h5><p>你可以创建一个继承自<code>JSObjectionModule</code>的模块，在里面绑定相对应的<code>事物</code>，便可直接取到对应的值</p>\n<p>例如  一个协议和一个模块类，对象绑定了类名和这个类所遵循的协议</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">@protocol APIService &lt;NSObject&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)api:(NSString *)params;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@interface ModuleA : JSObjectionModule</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ModuleA</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)configure</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self bindClass:[MyAPIService class] toProtocol:@protocol(APIService)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这时候注射器初始化方式改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSObjectionInjector *injectorA &#x3D; [JSObjection createInjector:ModuleA.new]; [JSObjection setDefaultInjector:injectorA];</span><br></pre></td></tr></table></figure>\n\n<p>你就可以直接拿到对应遵循了这个协议的对象而不用通过ModuleA的实例对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyAPIService *delegate &#x3D; [injectorA getObject:@protocol(APIService)];</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意由于绑定的时候是用了bindClass:方法，所以每次取出都是不同的对象</strong></p>\n<p>除了绑定对象类名和协议外，还可以绑定一个对象和绑定一个类名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation ModuleA</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)configure</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self bind:对象实例 toClass:[UIApplication class]];</span><br><span class=\"line\">    [self bind:对象实例 toProtocol:@protocol(UIApplicationDelegate)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>**注意由于绑定的时候是用了bind:方法，所以每次取出都是相同的对象 **</p>\n<p>当对象被创建的时候，可以通过bindBlock:方法进行干涉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation ModuleA</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)configure</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self bindClass:[MyAPIService class] toProtocol:@protocol(APIService)];</span><br><span class=\"line\">    [self bindBlock:^id(JSObjectionInjector *context) &#123;</span><br><span class=\"line\">        MyAPIService *service &#x3D; [[MyAPIService alloc] init];</span><br><span class=\"line\">        service.buildByMySelf &#x3D; YES;</span><br><span class=\"line\">        return service;</span><br><span class=\"line\">    &#125; toClass:[MyAPIService class]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>上面这个例子表示MyAPIService被实例化后都会带上<code>buildByMySelf = YES</code></p>\n<p>但是用这种方法的话，假如用注射器取出对象的时候带上了参数，那我们就没办法拿到参数了，所以我们需要用到<code>ObjectionProvider</code>协议</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface ProviderA : JSObjectionModule&lt;JSObjectionProvider&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ProviderA</span><br><span class=\"line\">- (id)provide:(JSObjectionInjector *)context arguments:(NSArray *)arguments</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    MyAPIService *service &#x3D; [[MyAPIService alloc] init];</span><br><span class=\"line\">    service.buildByProvider &#x3D; YES;</span><br><span class=\"line\">    service.arguments &#x3D; arguments;</span><br><span class=\"line\">    return service;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)configure</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[self bindProvider:[ModuleA new] toClass:MyAPIService.class];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>这样子就能手动构建对象并且得到参数了</p>\n<h5 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h5><p>上面提及的<code>bindClass:</code>、<code>bindBlock:</code>、<code>bindProvider:</code>这些方法，都有一个拓展参数<code>inScope:(JSObjectionScope)scope;</code></p>\n<p>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self bindClass:[MyAPIService class] toProtocol:@protocol(APIService) inScope:JSObjectionScopeSingleton named:@&quot;&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self bindBlock:^id(JSObjectionInjector *context) &#123;</span><br><span class=\"line\">\tMyAPIService *service &#x3D; [[MyAPIService alloc] init];</span><br><span class=\"line\">\tservice.buildByMySelf &#x3D; YES;</span><br><span class=\"line\">\treturn service;</span><br><span class=\"line\">&#125; toClass:[MyAPIService class] inScope:JSObjectionScopeSingleton named:@&quot;&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self bindProvider:[ModuleA new] toClass:MyAPIService.class inScope:JSObjectionScopeSingleton];</span><br></pre></td></tr></table></figure>\n\n<p><code>JSObjectionScopeSingleton</code>意味着注射器取出来的都是同个对象，<br><code>JSObjectionScopeNormal</code>意味着注射器取出来的是不同对象。</p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>Objection 帮助你实现** 依赖注入 **，你只需要完成两件事情，配置依赖关系和获取依赖对象。配置依赖关系时，你可以使用几个常用的宏来快速的完成依赖关系的配置，另外你还可以使用模块的概念来完成更多的绑定操作，它允许你将某些类或某些协议接口绑定到某个或某一类的对象上，在配置完成后，你就可以使用关键的 injector 注入器获取到你所需要的对象。</p>\n<p>Objection 像是一种字典容器，通过多种形式将 value 和 key 关联起来，在完成配置之后，你只需要关注你通过何种 key 获取到需要的 value 即可。Objection 最主要的功能之一就是面向接口编程的实现，在上面的示例中也进行了演示，面向接口编程是一种非常重要的编程思想。</p>\n","site":{"data":{}},"excerpt":"<p>本文会说明iOS内依赖注入的概念和依赖注入框架Objection的一般使用</p>","more":"<h4 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h4><p>首先先说明什么叫做依赖注入</p>\n<p>比如AController跳转到BController,那么这时候BController就需要在AController内部进行实例化，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation AController : UIViewController</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)jump </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBController *bController &#x3D; [[BController alloc] init];</span><br><span class=\"line\">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这么做的话，当AController被封装成组件之后，BController的配置将会被限制，外部无法改变BController任何细节，所以我们 ** 稍 加 改 进 **</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation AController : UIViewController</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithCreateBlock:(UIViewController *(^)(void))createBViewControllerBlock &#123;</span><br><span class=\"line\">\t....</span><br><span class=\"line\">\tself.createBViewControllerBlock &#x3D; createBViewControllerBlock;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)jump </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tUIViewController *bController &#x3D; self.createBViewControllerBlock();</span><br><span class=\"line\">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[AController alloc] initWithCreateBlock:UIViewController* ^&#123;</span><br><span class=\"line\">\tBController *bController &#x3D; [[BController alloc] initWithTitle:@&quot;xxx&quot;];</span><br><span class=\"line\">\treturn bController;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>将BController的创建通过Block暴露出来，AController内部不关心BController是如何被创建的，那么AController对BController的依赖将通过外部的Block进行注入。</p>\n<p>这，就是依赖注入。</p>\n<p>当然这是最简单的依赖注入，无法满足我们复杂的需求，所以有时候我们需要使用第三方框架，如<code>Objection</code>和<code>Typhoon</code></p>\n<h4 id=\"Objection\"><a href=\"#Objection\" class=\"headerlink\" title=\"Objection\"></a>Objection</h4><p>接下来说明一下Objection的使用</p>\n<p>Objection 是一个依赖注入框架，能够在你获取一个类的实例的时候，这个类内部的属性也同时会被实例化。举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Car.h</span><br><span class=\"line\"></span><br><span class=\"line\">@class Engine,Break;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface Car : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, strong) Engine *engine;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, strong) Break *breaks;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Car.m</span><br><span class=\"line\"></span><br><span class=\"line\">#import &lt;Objection&#x2F;Objection.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Car</span><br><span class=\"line\">objection_requires(@&quot;engine&quot;, @&quot;breaks&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>创建一个默认注射器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSObjectionInjector *injector &#x3D; [JSObjection createInjector];</span><br><span class=\"line\">[JSObjection setDefaultInjector:injector];</span><br></pre></td></tr></table></figure>\n\n<p>实例化Car对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Car *car &#x3D; [[JSObjection defaultInjector] getObject:[Car class]];</span><br></pre></td></tr></table></figure>\n\n<p>这时候所依赖的<code>engine</code>对象和<code>breaks</code>对象都会通过<code>init</code>方法实例化</p>\n<p>最后打印属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">car &lt;Car: 0x6000006d8480&gt; engine &lt;Engine: 0x6000004841b0&gt; breaks &lt;Break: 0x6000004841e0&gt;</span><br></pre></td></tr></table></figure>\n\n<p>假如说Car对象不能通过<code>init</code>或者<code>initWithXXX</code>等自定义构造方法去实例化，那么我们需要指定方法，让注射器在指定的方法构建依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Car</span><br><span class=\"line\">objection_requires(@&quot;engine&quot;, @&quot;breaks&quot;)</span><br><span class=\"line\">- (void)awakeFromNib &#123;</span><br><span class=\"line\">  [[JSObjection defaultInjector] injectDependencies:self];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>当Car被注射器初始化完成之后，会调用<code>- awakeFromObjection</code>方法，这里可以额外赋一些值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)awakeFromObjection </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tself.test &#x3D; @&quot;111&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的说的都是直接init出来的对象，但是更多情况下我们需要指定构造方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Car</span><br><span class=\"line\">objection_initializer_sel(@selector(initWithObject:)) &#x2F;&#x2F; 该宏只需且只能出现一次</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithObject:(id)object</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (self &#x3D; [super init]) &#123;</span><br><span class=\"line\">        self.test &#x3D; object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>取出的时候加上<code>argumentList:</code>参数即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Car *car &#x3D; [[JSObjection defaultInjector] getObject:[Car class] argumentList:@[@&quot;aaaa&quot;]];</span><br></pre></td></tr></table></figure>\n\n<p>或者不想写<code>objection_initializer_sel()</code>宏的话<br>可以直接在取的方法那里改动一下变成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Car *car &#x3D; [[JSObjection defaultInjector] getObject:[Car class] initializer:@selector(initWithObject:) argumentList:@[@&quot;aaaa&quot;]];</span><br></pre></td></tr></table></figure>\n\n<p>效果也是一样的</p>\n<h5 id=\"对象工厂\"><a href=\"#对象工厂\" class=\"headerlink\" title=\"对象工厂\"></a>对象工厂</h5><p>在Car中添加一个对象工厂属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property(nonatomic, strong) JSObjectFactory *objectFactory;</span><br></pre></td></tr></table></figure>\n\n<p>然后标记注入里面加多一个<code>objectFactory</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objection_requires(@&quot;engine&quot;, @&quot;breaks&quot;,@&quot;objectFactory&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>然后你就可以通过</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id obj &#x3D; [self.objectFactory getObject:[Engine class]];</span><br></pre></td></tr></table></figure>\n\n<p>获取到对应的对象</p>\n<h5 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h5><p>你可以创建一个继承自<code>JSObjectionModule</code>的模块，在里面绑定相对应的<code>事物</code>，便可直接取到对应的值</p>\n<p>例如  一个协议和一个模块类，对象绑定了类名和这个类所遵循的协议</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">@protocol APIService &lt;NSObject&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)api:(NSString *)params;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@interface ModuleA : JSObjectionModule</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ModuleA</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)configure</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self bindClass:[MyAPIService class] toProtocol:@protocol(APIService)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这时候注射器初始化方式改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JSObjectionInjector *injectorA &#x3D; [JSObjection createInjector:ModuleA.new]; [JSObjection setDefaultInjector:injectorA];</span><br></pre></td></tr></table></figure>\n\n<p>你就可以直接拿到对应遵循了这个协议的对象而不用通过ModuleA的实例对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyAPIService *delegate &#x3D; [injectorA getObject:@protocol(APIService)];</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意由于绑定的时候是用了bindClass:方法，所以每次取出都是不同的对象</strong></p>\n<p>除了绑定对象类名和协议外，还可以绑定一个对象和绑定一个类名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation ModuleA</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)configure</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self bind:对象实例 toClass:[UIApplication class]];</span><br><span class=\"line\">    [self bind:对象实例 toProtocol:@protocol(UIApplicationDelegate)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>**注意由于绑定的时候是用了bind:方法，所以每次取出都是相同的对象 **</p>\n<p>当对象被创建的时候，可以通过bindBlock:方法进行干涉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation ModuleA</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)configure</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self bindClass:[MyAPIService class] toProtocol:@protocol(APIService)];</span><br><span class=\"line\">    [self bindBlock:^id(JSObjectionInjector *context) &#123;</span><br><span class=\"line\">        MyAPIService *service &#x3D; [[MyAPIService alloc] init];</span><br><span class=\"line\">        service.buildByMySelf &#x3D; YES;</span><br><span class=\"line\">        return service;</span><br><span class=\"line\">    &#125; toClass:[MyAPIService class]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>上面这个例子表示MyAPIService被实例化后都会带上<code>buildByMySelf = YES</code></p>\n<p>但是用这种方法的话，假如用注射器取出对象的时候带上了参数，那我们就没办法拿到参数了，所以我们需要用到<code>ObjectionProvider</code>协议</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface ProviderA : JSObjectionModule&lt;JSObjectionProvider&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation ProviderA</span><br><span class=\"line\">- (id)provide:(JSObjectionInjector *)context arguments:(NSArray *)arguments</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    MyAPIService *service &#x3D; [[MyAPIService alloc] init];</span><br><span class=\"line\">    service.buildByProvider &#x3D; YES;</span><br><span class=\"line\">    service.arguments &#x3D; arguments;</span><br><span class=\"line\">    return service;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)configure</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[self bindProvider:[ModuleA new] toClass:MyAPIService.class];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>这样子就能手动构建对象并且得到参数了</p>\n<h5 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h5><p>上面提及的<code>bindClass:</code>、<code>bindBlock:</code>、<code>bindProvider:</code>这些方法，都有一个拓展参数<code>inScope:(JSObjectionScope)scope;</code></p>\n<p>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[self bindClass:[MyAPIService class] toProtocol:@protocol(APIService) inScope:JSObjectionScopeSingleton named:@&quot;&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self bindBlock:^id(JSObjectionInjector *context) &#123;</span><br><span class=\"line\">\tMyAPIService *service &#x3D; [[MyAPIService alloc] init];</span><br><span class=\"line\">\tservice.buildByMySelf &#x3D; YES;</span><br><span class=\"line\">\treturn service;</span><br><span class=\"line\">&#125; toClass:[MyAPIService class] inScope:JSObjectionScopeSingleton named:@&quot;&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">[self bindProvider:[ModuleA new] toClass:MyAPIService.class inScope:JSObjectionScopeSingleton];</span><br></pre></td></tr></table></figure>\n\n<p><code>JSObjectionScopeSingleton</code>意味着注射器取出来的都是同个对象，<br><code>JSObjectionScopeNormal</code>意味着注射器取出来的是不同对象。</p>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>Objection 帮助你实现** 依赖注入 **，你只需要完成两件事情，配置依赖关系和获取依赖对象。配置依赖关系时，你可以使用几个常用的宏来快速的完成依赖关系的配置，另外你还可以使用模块的概念来完成更多的绑定操作，它允许你将某些类或某些协议接口绑定到某个或某一类的对象上，在配置完成后，你就可以使用关键的 injector 注入器获取到你所需要的对象。</p>\n<p>Objection 像是一种字典容器，通过多种形式将 value 和 key 关联起来，在完成配置之后，你只需要关注你通过何种 key 获取到需要的 value 即可。Objection 最主要的功能之一就是面向接口编程的实现，在上面的示例中也进行了演示，面向接口编程是一种非常重要的编程思想。</p>"},{"title":"关于案场管家的技术点总结","author":"Arclin","abbrlink":"8ff6aa28","date":"2016-06-11T16:00:00.000Z","_content":"案场管家的技术点总结\n\n<!-- more -->\n\n### xib与storyboard\n\n1. xib和storyboard均是用于布局所用，其实如果不需要过于复杂的布局的话完全也可以时候用masonry或者直接CGRect定位亦或者NSNSLayoutConstraint进行布局，如果要用代码的话个人觉得masonry是非常好用的，并且该框架所使用的函数式编程思想和链式编程思想也是值得学习的\n\n2. storyboard的作用类似于包含多个xib+视图管理，代码调用storyboard里面的控制器的代码如下\n\n\t```\n\tUIStoryboard *stroyboard = [UIStoryboard storyboardWithName:\"storyboard的文件名\" bundle:nil];\n\tXXXViewController *vc = [storyboard instantiateViewControllerWithIdentifier:“contorller的storyboard Id”];\n\t```\n\t如果是controller类xib，那么就直接 alloc init 一个该xib所绑定的controller就可以了\n\t如果是view类xib\n\t\n\t```\n\t[[[NSBundle mainBundle] loadNibNamed:@\"CMBuildingCell\" owner:nil options:nil] firstObject]\n\t```\n\n3. 之前曾经遇到过一个bug，从xib拖线到类文件的时候他会报错，原因是如果你的xib绑定的是一个继承UIView的类（比如一个cell），那么File Owner就应该保持为空，父view绑定类；如果绑定的是一个controller类，那父view绑定为空，File Owner绑定类，从以上说明我们可以得知，FileOwner就是这个xib所属的controller,如果他没有所属的controller，那么调用这个xib的controller就是他的File Owner，所以上面的代码里面的owner我们一直保持为nil就可以了\n \n### 关于网络获取与数据本地化\n\n1. 关于网络方面的话我之前写过一份xmind，大概流程是这样子的\n\t- 首先定义一个布尔变量，判断是否有存档\n\t- viewDidLoad 取档并刷新数据\n\t- viewWillAppear 中执行 loadDataFromNet\n\t- loadDataFromNet方法中判断是否有存档，没有存档并且获取网络数据失败的时候才提示数据刷新失败\n\t\n\t示例如下\n\t\n\t* 这里用NSCachesDirectory，也就是缓存目录，关于目录的选择看有道云笔记，上面有比较详细的说明 \n\t\n\t```\n\t #define XXFileName [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:@\"xx.data\"]\n\t- (void)viewDidLoad {\t\n\t\t [super viewDidLoad];\n\t\t // 取档\n\t    \tself.dataArray = [NSKeyedUnarchiver unarchiveObjectWithFile:XXFileName];\n\t    \n\t\t if (self.dataArray) {\n\t   \t\t[self.tableView reloadData];\n\t   \t\thasArchive = YES;\n\t\t}else{\n\t    \thasArchive = NO;\n\t    \t// 转菊花  或者 下拉刷新也行 \n\t    \t[SVProgressHUD setDefaultMaskType:SVProgressHUDMaskTypeBlack];\n\t \t    [SVProgressHUD show];\n\t\t}\n\t\t[self loadDataFromNet];\n\t}\n\t- (void)viewWillAppear:(BOOL)animated\n\t{\n\t    **如果能保证这个controller每次进来都会经过viewDidLoad(例如本身自己就是子控制器且自己也没有子控制器)则这里就不用写了**\n\t\t[self loadDataFromNet];\n\t}\t\n\t- (void)loadDataFromNet\n\t{\n\t\t[XXTool fetchMsg:^(XXData *data) {\n\t  \t\tself.data = data;\n\t    \t// 归档\n\t    \t[NSKeyedArchiver archiveRootObject:profile toFile:XXFileName];\n\t    \tdispatch_async(dispatch_get_main_queue(), ^{\n\t    \t\t[SVProgressHUD dismiss];\n\t        \t[self.tableView reloadData];\n\t    \t});\n\t\t } failure:^(NSError *error) {\n\t    \tNSLog(@\"%@\",error);\n\t    \tdispatch_async(dispatch_get_main_queue(), ^{\n\t    \t    if(!_hasArchive)[SVProgressHUD showErrorWithStatus:@\"加载失败\"];\n\t    \t});\n\t\t}];\n\t}\n\t```\n \t* 不过做项目的时候还是看实际情况进行调整吧，上面所说的只是一般情况下的网络处理\n\n\t近期稍微地研究了一下Runtime框架，加上一点脑洞和MJExtendsion的配合，感觉可以做出一个框架，能够实现获取数据之后直接生成跟远程数据库结构相同的本地数据库，一方面可以避开类似salesForce的SOQL语句无法进行多表查询之类的恶心问题，另一方面做数据筛选功能的时候也会简单很多，这个就待我去看看能不能搞出来\n\t\n### 关于单例\n1. 在这个项目里面我导入了一个外部框架（应该说是一个文件？）：Singleton.h\n这个东西使用起来很爽\n只要在你想单例的类的声明h里加 singleton_interface（类名）\n实现m里加 singleton_implementation（类名)\n就可以了\n之后你想调用这个类的时候就直接 [ClassName sharedClassName] 就可以直接获得到这个类的单例\n\n2. 什么情况下要用到单例？\n以案场这个为例子，我每次获取数据都需要加上限制条件，筛选当前项目下和当前登录用户的数据\n那么我就会频繁使用到projectId 和 userId ，__并且这两个值基本不变__\n所以我就给这个单例写了两个方法\n\n\t```\n\t- (NSString *)currentProjectId;\n\t- (NSString *)userId;\n\t- (CMProject *)currentProject\n\t{\t\n\t CMProject*currentProject = [NSKeyedUnarchiverunarchiveObjectWithFile:CMSelectProjectFileName];\n\t   \treturn currentProject;\n\t}\n\t\n\t- (NSString *)userId{ \n\treturn [SFUserAccountManager sharedInstance].currentUser.credentials.userId;\n\t}\n\t\n\t//使用\n\t[[CMUserTool sharedCMUserTool] userId];\n\t```\n\t\n### 关于传值\n\n1. 传值有三宝：代理、通知、block 另外还有storyboard专用segue传值和成员属性传值等，因为前三个比较重要所以我就说说前三个的使用\n\t- 代理用来两个视图之间的传值，最常用的就是自定义view上面的点击事件通过代理告诉调用它的controller，因为一个界面只能有一个controller，一般我们都是抽出另一个controller的view添加到这个controller上面，所以这时候就要用代理进行两个controller之间的数据传递\n通知，先说说使用方法\n\n\t```\n\t**消息接收方**\n\t[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(方法名) name:消息名 object:nil];\n\t\n\t**消息发送方**\n\t//创建一个消息对象\n\tNSNotification * notice = [NSNotification notificationWithName:消息名 object:nil userInfo:nil];\n\t//发送消息\n\t[[NSNotificationCenter defaultCenter]postNotification:notice];\n\t移除通知 \n\t\n\t移除单个通知\n\t[[NSNotificationCenter defaultCenter] removeObserver:self name:消息名 object:self];\n\t\n\t移除当前所有通知:[[NSNotificationCenterdefaultCenter]removeObserver:self];\n\t```\n\n\t但是优缺点并存\n\t\n\t> 优势：\n\t>\n\t> 1. 不需要编写多少代码，实现比较简单\n\t> 2. 对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单\n\t> 3. controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息\n\t\n\t> 缺点：\n\t>\n\t> 1. 在编译期不会检查通知是否能够被观察者正确的处理； \n\t> 2. 在释放注册的对象时，需要在通知中心取消注册；\n\t> 3. 在调试的时候应用的工作以及控制过程难跟踪；\n\t> 4. 需要第三方对象来管理controller与观察者对象之间的联系；\n\t> 5. controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；\n\t> 6. 通知发出后，controller不能从观察者获得任何的反馈信息。\n\t\n\n\t- block 用于反向传值，就是在子控制器操作数据后传值回到父控制器，这时候我们用block，不过block传值也有坑，很容易引起循环引用然后烧内存。解决方法就是用weak修饰对象比如 ` weak typeof(self) weakSelf = self `\n这样子我们用weakSelf.对象就不会引起循环引用\n\t\t- 还有block有一个小地方要注意，如果要在block里面调用外部变量的话，要给外部变量加一个__block修饰符\n\n### 关于枚举\n\n枚举不用讲太多，枚举就是为了方便判断而已，但是命名规范还是要说的,举个栗子\n\n```\ntypedef enum : NSUInteger {\n     CMRelatedTypeOpportunity,\n     CMRelatedTypeBooking,\n     CMRelatedTypeSalesOrder,\n     CMRelatedTypeContract,\n     CMRelatedTypeCollection,\n     CMRelatedTypeTrade\n } CMRelatedType;\n```\n \n枚举的成员名 = 枚举名 + 类型名\n\n### 关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller\n\n案场那个客户界是这个app中逻辑最复杂的一个界面，虽然通过了枚举的判断方便了一个代码的阅读，但总的来说上千行代码着实还是恶心。\n类似的场景应该以后应该还会经常发生，但是虽然开发的时候可能方便了但是维护起来也太费劲了，并且之前项目的种种维护的体验也告诉了我们一个事实：MVC框架不够用了\n\n所以——我们还是换个架构吧~\n\n我大概考虑了一下，逻辑层还是尽可能的细分，多几个类都行，然后耦合性应该低\n之前我们就已经习惯了把业务层从controller中抽取出来,这种方式应该保留\n然后我们可以尝试引入MVCS架构以及MVVM架构等，具体的demo应该会在近期实现","source":"_posts/关于案场管家的技术点总结.md","raw":"---\ntitle: 关于案场管家的技术点总结\nauthor: Arclin\ntags:\n  - iOS\n  - 杂谈\ncategories:\n  - iOS\nabbrlink: 8ff6aa28\ndate: 2016-06-12 00:00:00\n---\n案场管家的技术点总结\n\n<!-- more -->\n\n### xib与storyboard\n\n1. xib和storyboard均是用于布局所用，其实如果不需要过于复杂的布局的话完全也可以时候用masonry或者直接CGRect定位亦或者NSNSLayoutConstraint进行布局，如果要用代码的话个人觉得masonry是非常好用的，并且该框架所使用的函数式编程思想和链式编程思想也是值得学习的\n\n2. storyboard的作用类似于包含多个xib+视图管理，代码调用storyboard里面的控制器的代码如下\n\n\t```\n\tUIStoryboard *stroyboard = [UIStoryboard storyboardWithName:\"storyboard的文件名\" bundle:nil];\n\tXXXViewController *vc = [storyboard instantiateViewControllerWithIdentifier:“contorller的storyboard Id”];\n\t```\n\t如果是controller类xib，那么就直接 alloc init 一个该xib所绑定的controller就可以了\n\t如果是view类xib\n\t\n\t```\n\t[[[NSBundle mainBundle] loadNibNamed:@\"CMBuildingCell\" owner:nil options:nil] firstObject]\n\t```\n\n3. 之前曾经遇到过一个bug，从xib拖线到类文件的时候他会报错，原因是如果你的xib绑定的是一个继承UIView的类（比如一个cell），那么File Owner就应该保持为空，父view绑定类；如果绑定的是一个controller类，那父view绑定为空，File Owner绑定类，从以上说明我们可以得知，FileOwner就是这个xib所属的controller,如果他没有所属的controller，那么调用这个xib的controller就是他的File Owner，所以上面的代码里面的owner我们一直保持为nil就可以了\n \n### 关于网络获取与数据本地化\n\n1. 关于网络方面的话我之前写过一份xmind，大概流程是这样子的\n\t- 首先定义一个布尔变量，判断是否有存档\n\t- viewDidLoad 取档并刷新数据\n\t- viewWillAppear 中执行 loadDataFromNet\n\t- loadDataFromNet方法中判断是否有存档，没有存档并且获取网络数据失败的时候才提示数据刷新失败\n\t\n\t示例如下\n\t\n\t* 这里用NSCachesDirectory，也就是缓存目录，关于目录的选择看有道云笔记，上面有比较详细的说明 \n\t\n\t```\n\t #define XXFileName [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:@\"xx.data\"]\n\t- (void)viewDidLoad {\t\n\t\t [super viewDidLoad];\n\t\t // 取档\n\t    \tself.dataArray = [NSKeyedUnarchiver unarchiveObjectWithFile:XXFileName];\n\t    \n\t\t if (self.dataArray) {\n\t   \t\t[self.tableView reloadData];\n\t   \t\thasArchive = YES;\n\t\t}else{\n\t    \thasArchive = NO;\n\t    \t// 转菊花  或者 下拉刷新也行 \n\t    \t[SVProgressHUD setDefaultMaskType:SVProgressHUDMaskTypeBlack];\n\t \t    [SVProgressHUD show];\n\t\t}\n\t\t[self loadDataFromNet];\n\t}\n\t- (void)viewWillAppear:(BOOL)animated\n\t{\n\t    **如果能保证这个controller每次进来都会经过viewDidLoad(例如本身自己就是子控制器且自己也没有子控制器)则这里就不用写了**\n\t\t[self loadDataFromNet];\n\t}\t\n\t- (void)loadDataFromNet\n\t{\n\t\t[XXTool fetchMsg:^(XXData *data) {\n\t  \t\tself.data = data;\n\t    \t// 归档\n\t    \t[NSKeyedArchiver archiveRootObject:profile toFile:XXFileName];\n\t    \tdispatch_async(dispatch_get_main_queue(), ^{\n\t    \t\t[SVProgressHUD dismiss];\n\t        \t[self.tableView reloadData];\n\t    \t});\n\t\t } failure:^(NSError *error) {\n\t    \tNSLog(@\"%@\",error);\n\t    \tdispatch_async(dispatch_get_main_queue(), ^{\n\t    \t    if(!_hasArchive)[SVProgressHUD showErrorWithStatus:@\"加载失败\"];\n\t    \t});\n\t\t}];\n\t}\n\t```\n \t* 不过做项目的时候还是看实际情况进行调整吧，上面所说的只是一般情况下的网络处理\n\n\t近期稍微地研究了一下Runtime框架，加上一点脑洞和MJExtendsion的配合，感觉可以做出一个框架，能够实现获取数据之后直接生成跟远程数据库结构相同的本地数据库，一方面可以避开类似salesForce的SOQL语句无法进行多表查询之类的恶心问题，另一方面做数据筛选功能的时候也会简单很多，这个就待我去看看能不能搞出来\n\t\n### 关于单例\n1. 在这个项目里面我导入了一个外部框架（应该说是一个文件？）：Singleton.h\n这个东西使用起来很爽\n只要在你想单例的类的声明h里加 singleton_interface（类名）\n实现m里加 singleton_implementation（类名)\n就可以了\n之后你想调用这个类的时候就直接 [ClassName sharedClassName] 就可以直接获得到这个类的单例\n\n2. 什么情况下要用到单例？\n以案场这个为例子，我每次获取数据都需要加上限制条件，筛选当前项目下和当前登录用户的数据\n那么我就会频繁使用到projectId 和 userId ，__并且这两个值基本不变__\n所以我就给这个单例写了两个方法\n\n\t```\n\t- (NSString *)currentProjectId;\n\t- (NSString *)userId;\n\t- (CMProject *)currentProject\n\t{\t\n\t CMProject*currentProject = [NSKeyedUnarchiverunarchiveObjectWithFile:CMSelectProjectFileName];\n\t   \treturn currentProject;\n\t}\n\t\n\t- (NSString *)userId{ \n\treturn [SFUserAccountManager sharedInstance].currentUser.credentials.userId;\n\t}\n\t\n\t//使用\n\t[[CMUserTool sharedCMUserTool] userId];\n\t```\n\t\n### 关于传值\n\n1. 传值有三宝：代理、通知、block 另外还有storyboard专用segue传值和成员属性传值等，因为前三个比较重要所以我就说说前三个的使用\n\t- 代理用来两个视图之间的传值，最常用的就是自定义view上面的点击事件通过代理告诉调用它的controller，因为一个界面只能有一个controller，一般我们都是抽出另一个controller的view添加到这个controller上面，所以这时候就要用代理进行两个controller之间的数据传递\n通知，先说说使用方法\n\n\t```\n\t**消息接收方**\n\t[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(方法名) name:消息名 object:nil];\n\t\n\t**消息发送方**\n\t//创建一个消息对象\n\tNSNotification * notice = [NSNotification notificationWithName:消息名 object:nil userInfo:nil];\n\t//发送消息\n\t[[NSNotificationCenter defaultCenter]postNotification:notice];\n\t移除通知 \n\t\n\t移除单个通知\n\t[[NSNotificationCenter defaultCenter] removeObserver:self name:消息名 object:self];\n\t\n\t移除当前所有通知:[[NSNotificationCenterdefaultCenter]removeObserver:self];\n\t```\n\n\t但是优缺点并存\n\t\n\t> 优势：\n\t>\n\t> 1. 不需要编写多少代码，实现比较简单\n\t> 2. 对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单\n\t> 3. controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息\n\t\n\t> 缺点：\n\t>\n\t> 1. 在编译期不会检查通知是否能够被观察者正确的处理； \n\t> 2. 在释放注册的对象时，需要在通知中心取消注册；\n\t> 3. 在调试的时候应用的工作以及控制过程难跟踪；\n\t> 4. 需要第三方对象来管理controller与观察者对象之间的联系；\n\t> 5. controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；\n\t> 6. 通知发出后，controller不能从观察者获得任何的反馈信息。\n\t\n\n\t- block 用于反向传值，就是在子控制器操作数据后传值回到父控制器，这时候我们用block，不过block传值也有坑，很容易引起循环引用然后烧内存。解决方法就是用weak修饰对象比如 ` weak typeof(self) weakSelf = self `\n这样子我们用weakSelf.对象就不会引起循环引用\n\t\t- 还有block有一个小地方要注意，如果要在block里面调用外部变量的话，要给外部变量加一个__block修饰符\n\n### 关于枚举\n\n枚举不用讲太多，枚举就是为了方便判断而已，但是命名规范还是要说的,举个栗子\n\n```\ntypedef enum : NSUInteger {\n     CMRelatedTypeOpportunity,\n     CMRelatedTypeBooking,\n     CMRelatedTypeSalesOrder,\n     CMRelatedTypeContract,\n     CMRelatedTypeCollection,\n     CMRelatedTypeTrade\n } CMRelatedType;\n```\n \n枚举的成员名 = 枚举名 + 类型名\n\n### 关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller\n\n案场那个客户界是这个app中逻辑最复杂的一个界面，虽然通过了枚举的判断方便了一个代码的阅读，但总的来说上千行代码着实还是恶心。\n类似的场景应该以后应该还会经常发生，但是虽然开发的时候可能方便了但是维护起来也太费劲了，并且之前项目的种种维护的体验也告诉了我们一个事实：MVC框架不够用了\n\n所以——我们还是换个架构吧~\n\n我大概考虑了一下，逻辑层还是尽可能的细分，多几个类都行，然后耦合性应该低\n之前我们就已经习惯了把业务层从controller中抽取出来,这种方式应该保留\n然后我们可以尝试引入MVCS架构以及MVVM架构等，具体的demo应该会在近期实现","slug":"关于案场管家的技术点总结","published":1,"updated":"2021-06-06T18:52:24.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoih005utnn03h5ectep","content":"<p>案场管家的技术点总结</p>\n<span id=\"more\"></span>\n\n<h3 id=\"xib与storyboard\"><a href=\"#xib与storyboard\" class=\"headerlink\" title=\"xib与storyboard\"></a>xib与storyboard</h3><ol>\n<li><p>xib和storyboard均是用于布局所用，其实如果不需要过于复杂的布局的话完全也可以时候用masonry或者直接CGRect定位亦或者NSNSLayoutConstraint进行布局，如果要用代码的话个人觉得masonry是非常好用的，并且该框架所使用的函数式编程思想和链式编程思想也是值得学习的</p>\n</li>\n<li><p>storyboard的作用类似于包含多个xib+视图管理，代码调用storyboard里面的控制器的代码如下</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIStoryboard *stroyboard &#x3D; [UIStoryboard storyboardWithName:&quot;storyboard的文件名&quot; bundle:nil];</span><br><span class=\"line\">XXXViewController *vc &#x3D; [storyboard instantiateViewControllerWithIdentifier:“contorller的storyboard Id”];</span><br></pre></td></tr></table></figure>\n<p> 如果是controller类xib，那么就直接 alloc init 一个该xib所绑定的controller就可以了<br> 如果是view类xib</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[[NSBundle mainBundle] loadNibNamed:@&quot;CMBuildingCell&quot; owner:nil options:nil] firstObject]</span><br></pre></td></tr></table></figure></li>\n<li><p>之前曾经遇到过一个bug，从xib拖线到类文件的时候他会报错，原因是如果你的xib绑定的是一个继承UIView的类（比如一个cell），那么File Owner就应该保持为空，父view绑定类；如果绑定的是一个controller类，那父view绑定为空，File Owner绑定类，从以上说明我们可以得知，FileOwner就是这个xib所属的controller,如果他没有所属的controller，那么调用这个xib的controller就是他的File Owner，所以上面的代码里面的owner我们一直保持为nil就可以了</p>\n</li>\n</ol>\n<h3 id=\"关于网络获取与数据本地化\"><a href=\"#关于网络获取与数据本地化\" class=\"headerlink\" title=\"关于网络获取与数据本地化\"></a>关于网络获取与数据本地化</h3><ol>\n<li><p>关于网络方面的话我之前写过一份xmind，大概流程是这样子的</p>\n<ul>\n<li>首先定义一个布尔变量，判断是否有存档</li>\n<li>viewDidLoad 取档并刷新数据</li>\n<li>viewWillAppear 中执行 loadDataFromNet</li>\n<li>loadDataFromNet方法中判断是否有存档，没有存档并且获取网络数据失败的时候才提示数据刷新失败</li>\n</ul>\n<p> 示例如下</p>\n<ul>\n<li>这里用NSCachesDirectory，也就是缓存目录，关于目录的选择看有道云笔记，上面有比较详细的说明 </li>\n</ul>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> #define XXFileName [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:@&quot;xx.data&quot;]</span><br><span class=\"line\">- (void)viewDidLoad &#123;\t</span><br><span class=\"line\">\t [super viewDidLoad];</span><br><span class=\"line\">\t &#x2F;&#x2F; 取档</span><br><span class=\"line\">    \tself.dataArray &#x3D; [NSKeyedUnarchiver unarchiveObjectWithFile:XXFileName];</span><br><span class=\"line\">    </span><br><span class=\"line\">\t if (self.dataArray) &#123;</span><br><span class=\"line\">   \t\t[self.tableView reloadData];</span><br><span class=\"line\">   \t\thasArchive &#x3D; YES;</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">    \thasArchive &#x3D; NO;</span><br><span class=\"line\">    \t&#x2F;&#x2F; 转菊花  或者 下拉刷新也行 </span><br><span class=\"line\">    \t[SVProgressHUD setDefaultMaskType:SVProgressHUDMaskTypeBlack];</span><br><span class=\"line\"> \t    [SVProgressHUD show];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t[self loadDataFromNet];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)viewWillAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    **如果能保证这个controller每次进来都会经过viewDidLoad(例如本身自己就是子控制器且自己也没有子控制器)则这里就不用写了**</span><br><span class=\"line\">\t[self loadDataFromNet];</span><br><span class=\"line\">&#125;\t</span><br><span class=\"line\">- (void)loadDataFromNet</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[XXTool fetchMsg:^(XXData *data) &#123;</span><br><span class=\"line\">  \t\tself.data &#x3D; data;</span><br><span class=\"line\">    \t&#x2F;&#x2F; 归档</span><br><span class=\"line\">    \t[NSKeyedArchiver archiveRootObject:profile toFile:XXFileName];</span><br><span class=\"line\">    \tdispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    \t\t[SVProgressHUD dismiss];</span><br><span class=\"line\">        \t[self.tableView reloadData];</span><br><span class=\"line\">    \t&#125;);</span><br><span class=\"line\">\t &#125; failure:^(NSError *error) &#123;</span><br><span class=\"line\">    \tNSLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">    \tdispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    \t    if(!_hasArchive)[SVProgressHUD showErrorWithStatus:@&quot;加载失败&quot;];</span><br><span class=\"line\">    \t&#125;);</span><br><span class=\"line\">\t&#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>不过做项目的时候还是看实际情况进行调整吧，上面所说的只是一般情况下的网络处理</li>\n</ul>\n<p> 近期稍微地研究了一下Runtime框架，加上一点脑洞和MJExtendsion的配合，感觉可以做出一个框架，能够实现获取数据之后直接生成跟远程数据库结构相同的本地数据库，一方面可以避开类似salesForce的SOQL语句无法进行多表查询之类的恶心问题，另一方面做数据筛选功能的时候也会简单很多，这个就待我去看看能不能搞出来</p>\n</li>\n</ol>\n<h3 id=\"关于单例\"><a href=\"#关于单例\" class=\"headerlink\" title=\"关于单例\"></a>关于单例</h3><ol>\n<li><p>在这个项目里面我导入了一个外部框架（应该说是一个文件？）：Singleton.h<br>这个东西使用起来很爽<br>只要在你想单例的类的声明h里加 singleton_interface（类名）<br>实现m里加 singleton_implementation（类名)<br>就可以了<br>之后你想调用这个类的时候就直接 [ClassName sharedClassName] 就可以直接获得到这个类的单例</p>\n</li>\n<li><p>什么情况下要用到单例？<br>以案场这个为例子，我每次获取数据都需要加上限制条件，筛选当前项目下和当前登录用户的数据<br>那么我就会频繁使用到projectId 和 userId ，<strong>并且这两个值基本不变</strong><br>所以我就给这个单例写了两个方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSString *)currentProjectId;</span><br><span class=\"line\">- (NSString *)userId;</span><br><span class=\"line\">- (CMProject *)currentProject</span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\"> CMProject*currentProject &#x3D; [NSKeyedUnarchiverunarchiveObjectWithFile:CMSelectProjectFileName];</span><br><span class=\"line\">   \treturn currentProject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)userId&#123; </span><br><span class=\"line\">return [SFUserAccountManager sharedInstance].currentUser.credentials.userId;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;使用</span><br><span class=\"line\">[[CMUserTool sharedCMUserTool] userId];</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"关于传值\"><a href=\"#关于传值\" class=\"headerlink\" title=\"关于传值\"></a>关于传值</h3><ol>\n<li><p>传值有三宝：代理、通知、block 另外还有storyboard专用segue传值和成员属性传值等，因为前三个比较重要所以我就说说前三个的使用</p>\n<ul>\n<li>代理用来两个视图之间的传值，最常用的就是自定义view上面的点击事件通过代理告诉调用它的controller，因为一个界面只能有一个controller，一般我们都是抽出另一个controller的view添加到这个controller上面，所以这时候就要用代理进行两个controller之间的数据传递<br>通知，先说说使用方法</li>\n</ul>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**消息接收方**</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(方法名) name:消息名 object:nil];</span><br><span class=\"line\"></span><br><span class=\"line\">**消息发送方**</span><br><span class=\"line\">&#x2F;&#x2F;创建一个消息对象</span><br><span class=\"line\">NSNotification * notice &#x3D; [NSNotification notificationWithName:消息名 object:nil userInfo:nil];</span><br><span class=\"line\">&#x2F;&#x2F;发送消息</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter]postNotification:notice];</span><br><span class=\"line\">移除通知 </span><br><span class=\"line\"></span><br><span class=\"line\">移除单个通知</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter] removeObserver:self name:消息名 object:self];</span><br><span class=\"line\"></span><br><span class=\"line\">移除当前所有通知:[[NSNotificationCenterdefaultCenter]removeObserver:self];</span><br></pre></td></tr></table></figure>\n\n<p> 但是优缺点并存</p>\n<blockquote>\n<p>优势：</p>\n<ol>\n<li>不需要编写多少代码，实现比较简单</li>\n<li>对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单</li>\n<li>controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>缺点：</p>\n<ol>\n<li>在编译期不会检查通知是否能够被观察者正确的处理； </li>\n<li>在释放注册的对象时，需要在通知中心取消注册；</li>\n<li>在调试的时候应用的工作以及控制过程难跟踪；</li>\n<li>需要第三方对象来管理controller与观察者对象之间的联系；</li>\n<li>controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；</li>\n<li>通知发出后，controller不能从观察者获得任何的反馈信息。</li>\n</ol>\n</blockquote>\n<ul>\n<li>block 用于反向传值，就是在子控制器操作数据后传值回到父控制器，这时候我们用block，不过block传值也有坑，很容易引起循环引用然后烧内存。解决方法就是用weak修饰对象比如 <code>weak typeof(self) weakSelf = self</code><br>这样子我们用weakSelf.对象就不会引起循环引用<ul>\n<li>还有block有一个小地方要注意，如果要在block里面调用外部变量的话，要给外部变量加一个__block修饰符</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"关于枚举\"><a href=\"#关于枚举\" class=\"headerlink\" title=\"关于枚举\"></a>关于枚举</h3><p>枚举不用讲太多，枚举就是为了方便判断而已，但是命名规范还是要说的,举个栗子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef enum : NSUInteger &#123;</span><br><span class=\"line\">     CMRelatedTypeOpportunity,</span><br><span class=\"line\">     CMRelatedTypeBooking,</span><br><span class=\"line\">     CMRelatedTypeSalesOrder,</span><br><span class=\"line\">     CMRelatedTypeContract,</span><br><span class=\"line\">     CMRelatedTypeCollection,</span><br><span class=\"line\">     CMRelatedTypeTrade</span><br><span class=\"line\"> &#125; CMRelatedType;</span><br></pre></td></tr></table></figure>\n<p>枚举的成员名 = 枚举名 + 类型名</p>\n<h3 id=\"关于案场的客户界面-——-复杂的逻辑-TO-一个Controller\"><a href=\"#关于案场的客户界面-——-复杂的逻辑-TO-一个Controller\" class=\"headerlink\" title=\"关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller\"></a>关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller</h3><p>案场那个客户界是这个app中逻辑最复杂的一个界面，虽然通过了枚举的判断方便了一个代码的阅读，但总的来说上千行代码着实还是恶心。<br>类似的场景应该以后应该还会经常发生，但是虽然开发的时候可能方便了但是维护起来也太费劲了，并且之前项目的种种维护的体验也告诉了我们一个事实：MVC框架不够用了</p>\n<p>所以——我们还是换个架构吧~</p>\n<p>我大概考虑了一下，逻辑层还是尽可能的细分，多几个类都行，然后耦合性应该低<br>之前我们就已经习惯了把业务层从controller中抽取出来,这种方式应该保留<br>然后我们可以尝试引入MVCS架构以及MVVM架构等，具体的demo应该会在近期实现</p>\n","site":{"data":{}},"excerpt":"<p>案场管家的技术点总结</p>","more":"<h3 id=\"xib与storyboard\"><a href=\"#xib与storyboard\" class=\"headerlink\" title=\"xib与storyboard\"></a>xib与storyboard</h3><ol>\n<li><p>xib和storyboard均是用于布局所用，其实如果不需要过于复杂的布局的话完全也可以时候用masonry或者直接CGRect定位亦或者NSNSLayoutConstraint进行布局，如果要用代码的话个人觉得masonry是非常好用的，并且该框架所使用的函数式编程思想和链式编程思想也是值得学习的</p>\n</li>\n<li><p>storyboard的作用类似于包含多个xib+视图管理，代码调用storyboard里面的控制器的代码如下</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIStoryboard *stroyboard &#x3D; [UIStoryboard storyboardWithName:&quot;storyboard的文件名&quot; bundle:nil];</span><br><span class=\"line\">XXXViewController *vc &#x3D; [storyboard instantiateViewControllerWithIdentifier:“contorller的storyboard Id”];</span><br></pre></td></tr></table></figure>\n<p> 如果是controller类xib，那么就直接 alloc init 一个该xib所绑定的controller就可以了<br> 如果是view类xib</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[[NSBundle mainBundle] loadNibNamed:@&quot;CMBuildingCell&quot; owner:nil options:nil] firstObject]</span><br></pre></td></tr></table></figure></li>\n<li><p>之前曾经遇到过一个bug，从xib拖线到类文件的时候他会报错，原因是如果你的xib绑定的是一个继承UIView的类（比如一个cell），那么File Owner就应该保持为空，父view绑定类；如果绑定的是一个controller类，那父view绑定为空，File Owner绑定类，从以上说明我们可以得知，FileOwner就是这个xib所属的controller,如果他没有所属的controller，那么调用这个xib的controller就是他的File Owner，所以上面的代码里面的owner我们一直保持为nil就可以了</p>\n</li>\n</ol>\n<h3 id=\"关于网络获取与数据本地化\"><a href=\"#关于网络获取与数据本地化\" class=\"headerlink\" title=\"关于网络获取与数据本地化\"></a>关于网络获取与数据本地化</h3><ol>\n<li><p>关于网络方面的话我之前写过一份xmind，大概流程是这样子的</p>\n<ul>\n<li>首先定义一个布尔变量，判断是否有存档</li>\n<li>viewDidLoad 取档并刷新数据</li>\n<li>viewWillAppear 中执行 loadDataFromNet</li>\n<li>loadDataFromNet方法中判断是否有存档，没有存档并且获取网络数据失败的时候才提示数据刷新失败</li>\n</ul>\n<p> 示例如下</p>\n<ul>\n<li>这里用NSCachesDirectory，也就是缓存目录，关于目录的选择看有道云笔记，上面有比较详细的说明 </li>\n</ul>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> #define XXFileName [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:@&quot;xx.data&quot;]</span><br><span class=\"line\">- (void)viewDidLoad &#123;\t</span><br><span class=\"line\">\t [super viewDidLoad];</span><br><span class=\"line\">\t &#x2F;&#x2F; 取档</span><br><span class=\"line\">    \tself.dataArray &#x3D; [NSKeyedUnarchiver unarchiveObjectWithFile:XXFileName];</span><br><span class=\"line\">    </span><br><span class=\"line\">\t if (self.dataArray) &#123;</span><br><span class=\"line\">   \t\t[self.tableView reloadData];</span><br><span class=\"line\">   \t\thasArchive &#x3D; YES;</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">    \thasArchive &#x3D; NO;</span><br><span class=\"line\">    \t&#x2F;&#x2F; 转菊花  或者 下拉刷新也行 </span><br><span class=\"line\">    \t[SVProgressHUD setDefaultMaskType:SVProgressHUDMaskTypeBlack];</span><br><span class=\"line\"> \t    [SVProgressHUD show];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t[self loadDataFromNet];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)viewWillAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    **如果能保证这个controller每次进来都会经过viewDidLoad(例如本身自己就是子控制器且自己也没有子控制器)则这里就不用写了**</span><br><span class=\"line\">\t[self loadDataFromNet];</span><br><span class=\"line\">&#125;\t</span><br><span class=\"line\">- (void)loadDataFromNet</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[XXTool fetchMsg:^(XXData *data) &#123;</span><br><span class=\"line\">  \t\tself.data &#x3D; data;</span><br><span class=\"line\">    \t&#x2F;&#x2F; 归档</span><br><span class=\"line\">    \t[NSKeyedArchiver archiveRootObject:profile toFile:XXFileName];</span><br><span class=\"line\">    \tdispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    \t\t[SVProgressHUD dismiss];</span><br><span class=\"line\">        \t[self.tableView reloadData];</span><br><span class=\"line\">    \t&#125;);</span><br><span class=\"line\">\t &#125; failure:^(NSError *error) &#123;</span><br><span class=\"line\">    \tNSLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">    \tdispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    \t    if(!_hasArchive)[SVProgressHUD showErrorWithStatus:@&quot;加载失败&quot;];</span><br><span class=\"line\">    \t&#125;);</span><br><span class=\"line\">\t&#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>不过做项目的时候还是看实际情况进行调整吧，上面所说的只是一般情况下的网络处理</li>\n</ul>\n<p> 近期稍微地研究了一下Runtime框架，加上一点脑洞和MJExtendsion的配合，感觉可以做出一个框架，能够实现获取数据之后直接生成跟远程数据库结构相同的本地数据库，一方面可以避开类似salesForce的SOQL语句无法进行多表查询之类的恶心问题，另一方面做数据筛选功能的时候也会简单很多，这个就待我去看看能不能搞出来</p>\n</li>\n</ol>\n<h3 id=\"关于单例\"><a href=\"#关于单例\" class=\"headerlink\" title=\"关于单例\"></a>关于单例</h3><ol>\n<li><p>在这个项目里面我导入了一个外部框架（应该说是一个文件？）：Singleton.h<br>这个东西使用起来很爽<br>只要在你想单例的类的声明h里加 singleton_interface（类名）<br>实现m里加 singleton_implementation（类名)<br>就可以了<br>之后你想调用这个类的时候就直接 [ClassName sharedClassName] 就可以直接获得到这个类的单例</p>\n</li>\n<li><p>什么情况下要用到单例？<br>以案场这个为例子，我每次获取数据都需要加上限制条件，筛选当前项目下和当前登录用户的数据<br>那么我就会频繁使用到projectId 和 userId ，<strong>并且这两个值基本不变</strong><br>所以我就给这个单例写了两个方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSString *)currentProjectId;</span><br><span class=\"line\">- (NSString *)userId;</span><br><span class=\"line\">- (CMProject *)currentProject</span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\"> CMProject*currentProject &#x3D; [NSKeyedUnarchiverunarchiveObjectWithFile:CMSelectProjectFileName];</span><br><span class=\"line\">   \treturn currentProject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)userId&#123; </span><br><span class=\"line\">return [SFUserAccountManager sharedInstance].currentUser.credentials.userId;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;使用</span><br><span class=\"line\">[[CMUserTool sharedCMUserTool] userId];</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"关于传值\"><a href=\"#关于传值\" class=\"headerlink\" title=\"关于传值\"></a>关于传值</h3><ol>\n<li><p>传值有三宝：代理、通知、block 另外还有storyboard专用segue传值和成员属性传值等，因为前三个比较重要所以我就说说前三个的使用</p>\n<ul>\n<li>代理用来两个视图之间的传值，最常用的就是自定义view上面的点击事件通过代理告诉调用它的controller，因为一个界面只能有一个controller，一般我们都是抽出另一个controller的view添加到这个controller上面，所以这时候就要用代理进行两个controller之间的数据传递<br>通知，先说说使用方法</li>\n</ul>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**消息接收方**</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(方法名) name:消息名 object:nil];</span><br><span class=\"line\"></span><br><span class=\"line\">**消息发送方**</span><br><span class=\"line\">&#x2F;&#x2F;创建一个消息对象</span><br><span class=\"line\">NSNotification * notice &#x3D; [NSNotification notificationWithName:消息名 object:nil userInfo:nil];</span><br><span class=\"line\">&#x2F;&#x2F;发送消息</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter]postNotification:notice];</span><br><span class=\"line\">移除通知 </span><br><span class=\"line\"></span><br><span class=\"line\">移除单个通知</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter] removeObserver:self name:消息名 object:self];</span><br><span class=\"line\"></span><br><span class=\"line\">移除当前所有通知:[[NSNotificationCenterdefaultCenter]removeObserver:self];</span><br></pre></td></tr></table></figure>\n\n<p> 但是优缺点并存</p>\n<blockquote>\n<p>优势：</p>\n<ol>\n<li>不需要编写多少代码，实现比较简单</li>\n<li>对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单</li>\n<li>controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>缺点：</p>\n<ol>\n<li>在编译期不会检查通知是否能够被观察者正确的处理； </li>\n<li>在释放注册的对象时，需要在通知中心取消注册；</li>\n<li>在调试的时候应用的工作以及控制过程难跟踪；</li>\n<li>需要第三方对象来管理controller与观察者对象之间的联系；</li>\n<li>controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；</li>\n<li>通知发出后，controller不能从观察者获得任何的反馈信息。</li>\n</ol>\n</blockquote>\n<ul>\n<li>block 用于反向传值，就是在子控制器操作数据后传值回到父控制器，这时候我们用block，不过block传值也有坑，很容易引起循环引用然后烧内存。解决方法就是用weak修饰对象比如 <code>weak typeof(self) weakSelf = self</code><br>这样子我们用weakSelf.对象就不会引起循环引用<ul>\n<li>还有block有一个小地方要注意，如果要在block里面调用外部变量的话，要给外部变量加一个__block修饰符</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"关于枚举\"><a href=\"#关于枚举\" class=\"headerlink\" title=\"关于枚举\"></a>关于枚举</h3><p>枚举不用讲太多，枚举就是为了方便判断而已，但是命名规范还是要说的,举个栗子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef enum : NSUInteger &#123;</span><br><span class=\"line\">     CMRelatedTypeOpportunity,</span><br><span class=\"line\">     CMRelatedTypeBooking,</span><br><span class=\"line\">     CMRelatedTypeSalesOrder,</span><br><span class=\"line\">     CMRelatedTypeContract,</span><br><span class=\"line\">     CMRelatedTypeCollection,</span><br><span class=\"line\">     CMRelatedTypeTrade</span><br><span class=\"line\"> &#125; CMRelatedType;</span><br></pre></td></tr></table></figure>\n<p>枚举的成员名 = 枚举名 + 类型名</p>\n<h3 id=\"关于案场的客户界面-——-复杂的逻辑-TO-一个Controller\"><a href=\"#关于案场的客户界面-——-复杂的逻辑-TO-一个Controller\" class=\"headerlink\" title=\"关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller\"></a>关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller</h3><p>案场那个客户界是这个app中逻辑最复杂的一个界面，虽然通过了枚举的判断方便了一个代码的阅读，但总的来说上千行代码着实还是恶心。<br>类似的场景应该以后应该还会经常发生，但是虽然开发的时候可能方便了但是维护起来也太费劲了，并且之前项目的种种维护的体验也告诉了我们一个事实：MVC框架不够用了</p>\n<p>所以——我们还是换个架构吧~</p>\n<p>我大概考虑了一下，逻辑层还是尽可能的细分，多几个类都行，然后耦合性应该低<br>之前我们就已经习惯了把业务层从controller中抽取出来,这种方式应该保留<br>然后我们可以尝试引入MVCS架构以及MVVM架构等，具体的demo应该会在近期实现</p>"},{"title":"关于App混合开发的介绍","author":"Arclin","abbrlink":"b179ff40","date":"2017-03-13T16:00:00.000Z","_content":"![](https://ooo.0o0.ooo/2017/03/14/58c75bfb373da.png)\n\n### 前言\n\nHybrid App 混合开发意思是在web-app、native-app这两者之间的app开发,兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”, 并且也方便我们进行热修复.\n\n<!-- more -->\n\n> 跨平台就是你写一套代码,然后iOS和Android都能用,这样子可以大大节省人力成本和开发成本\n\n> 热修复就是应用发布之后你还可以通过下发补丁或者直接修改web部分代码去修改app的内容,由于iOS版本应用要上传到应用市场需要经过严格的审核,这将会花费很多时间,如果每次项目一有点小问题就重新发布上架,这将会是一场灾难,所以app的热修复技术在iOS中显得尤为重要\n\n目前比较流行的有Cordova/PhoneGap,HTML 5+,React Native,Weex,AppCan(因为这个平台在很多地方吐槽很严重所以暂时不讨论),接下来我们一个个地讨论这些开发框架.\n\n### Cordova/PhoneGap\t\n\n![Cordova logo](https://ooo.0o0.ooo/2017/03/14/58c7511a7b3cf.png)\n\n[Cordova 官网](http://cordova.apache.org/)\n\n#### 介绍\n为什么这两个要放在一起呢,因为PhoneGap被Adobe收购了,临走之前把核心代码给了Apache,Apache就把这个项目名作Cordova,所以说PhoneGap和Cordova出自同一家,他们都会被开源社区和Adobe所推动.\n\n这个框架是作为原生与web之间的中间件,它采用插件的形式调用原生模块,最后成品就是原生页面和web页面的一个混合应用,现在是一个为大多数混合应用所采用的框架,拥有广大的前景\n\n#### 优点\n用相对简单,学习成本低,对于不熟悉原生开发的前端工程师来说是不错的选择.\n\n#### 缺点\n说实话这个并不是Cordova的缺点,而是web应用共有的问题,就是页面响应迟钝和操作体验不佳的问题.但是这些问题在现在也已经有了足够多的解决方案,具体想了解可以自行上网查阅.\n\n### HTML 5+\n\n![HTML5+ logo](https://ooo.0o0.ooo/2017/03/14/58c7511a6ebea.png)\n\n[官方文档](http://ask.dcloud.net.cn/docs/)\n\n#### 介绍\nDCloud和H5中国产业联盟发起的项目,使用H5+框架自带的各种方法去进行与原生模块之间的沟通,结果产出的依然是web页面,但是\u0007性能相对比Cordova好.\n\n#### 优点\n上手简单,学习成本低,有完整的中文文档,作为移动端webView上的框架体验是很不错的,前端人员可以优先考虑使用这个框架.\n\n#### 缺点\n貌似国外基本没人知道这东西,第三方插件和资源相对较少,要是遇到问题也只能去dcloud社区里面找,stackoverflow是帮不到你的啦,而且就目前看来框架自带的bug还是有的.\n\n### ReactNative\n\n![ReactNative logo](https://ooo.0o0.ooo/2017/03/14/58c7511a63fec.jpg)\n\n[中文官网](http://reactnative.cn/)\n\n#### 介绍\nFacebook 发布的一个混合开发框架,使用ES5/ES6语法,通过ReactNative自带的框架去调用原生模块,但重点是他虽然写的是前端语言,JSX和ES5/ES6但是可以经过构建渲染,将DOM元素转为原生元素,也就是使用前端语言开发原生app已成为现实,既能保留原生的体验又能体现出跨平台和热修复的优势,所以近两年来这个框架十分火.\n\n#### 优点\n既有原生的体验,又能做到跨平台,虽然加载速度还是比纯原生慢一点,但是这个差距已经能达到毫秒级,基本不影响体验,目前像支付宝,手机QQ,淘宝 都已经在部分模块使用了React Native框架,市场前景广阔,拥有丰富的资料.\n\n#### 缺点\n因为这个框架还出现不久,目前还是0.x版本阶段,有部分原生模块还没有接入,只能等他更新\n\n需要一定的学习成本,如果你说你是个会HTML和CSS的前端工程师,那不好意思你还是从入门教程开始看吧╮(╯_╰)╭\n\n### Weex\n\n\n官网 … 额… 没官网..只有一个[论坛](http://www.weex.help/)\n\n#### 介绍\n阿里爸爸推出的跟ReactNative差不多的框架,所以介绍就跟上面差不多,其实我并不是很熟悉这个框架,而且这个框架是16年4月阿里才开放出来内测的,现在支持的原生元素还是不多,现在一年过去了感觉没引起多大关注,如果你学过Vue,那么这个框架你可能会比较好上手\n\n总之阿里爸爸推出了这个轮子还是很吊的.之后说不定会一鸣惊人呢?\n\n### AppCan\n\n[官网](http://www.appcan.cn/)\n\n#### 介绍\n国内的混合开发框架\n\n_(´ཀ`」 ∠) 这个东西是基于他们服务器运行的,所以说如果他们的服务器跪了,你的app就跪了,当然如果你是付费用户,他们就会很快地帮你处理.他们有自己的开发IDE,产出的是也是webView页面,这里就不过多介绍了,具体可以看他们官网.\n\n### 关于热修复\n前言就讲了热修复是啥东西,然后说说最近发生的一件事\n\n今年的三八妇女节那天,苹果发了邮件给使用了热修复的开发者,说你们在应用商店上面的app里面有使用了热修复框架,希望你们以后不要用,因为这会违反什么吧啦吧啦协议条款,然后一群不是很懂英文的程序员就猜来猜去,就说苹果不让用热修复了,JSPatch不能用了啊,ReactNative药丸啊╮(╯_╰)╭,我在V2看到的最多的就是iOS开发者的欢呼23333,感觉真是世态炎凉,原生的优势已经得通过保护才能体现了吗?\n\n嘛.认真看看邮件,苹果是说你们不能用热修复的手段去改变app的功能,像是调用runtime底层方法之类的,就比如说你这个功能本来是显示一个公司的产品展示的的,但是你通过了应用审核之后,远程下发补丁,然后一打开app就弹出一大堆广告,那这样子肯定是违反协议的,当然你用JSPatch的方式你想做啥就做啥,显然不是很好,所以现在JSPatch官方也说近期不要用(前几天我更新了一个app的新版本,没有移除JSPatch,居然也过审了???),但是RN框架是不会做这些事情的,收到邮件的RN开发者大多是因为里面用了Code Push或Expo之类的第三方.\n\n那结论就是,JSPatch不给用了,那也许大家会更倾向于RN或者web方案,所以近期RN的发展应该会更加迅速,反正无论如何,大家尝到热修复的甜头,肯定不会就此罢休.\n\n---\n\n文: Arclin\n\n2017.03.14","source":"_posts/关于App混合开发的介绍.md","raw":"---\ntitle: 关于App混合开发的介绍\nauthor: Arclin\ntags:\n  - React Native\n  - Cordova\n  - AppCan\n  - Weex\n  - HTML5+\ncategories:\n  - 杂谈\nabbrlink: b179ff40\ndate: 2017-03-14 00:00:00\n---\n![](https://ooo.0o0.ooo/2017/03/14/58c75bfb373da.png)\n\n### 前言\n\nHybrid App 混合开发意思是在web-app、native-app这两者之间的app开发,兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”, 并且也方便我们进行热修复.\n\n<!-- more -->\n\n> 跨平台就是你写一套代码,然后iOS和Android都能用,这样子可以大大节省人力成本和开发成本\n\n> 热修复就是应用发布之后你还可以通过下发补丁或者直接修改web部分代码去修改app的内容,由于iOS版本应用要上传到应用市场需要经过严格的审核,这将会花费很多时间,如果每次项目一有点小问题就重新发布上架,这将会是一场灾难,所以app的热修复技术在iOS中显得尤为重要\n\n目前比较流行的有Cordova/PhoneGap,HTML 5+,React Native,Weex,AppCan(因为这个平台在很多地方吐槽很严重所以暂时不讨论),接下来我们一个个地讨论这些开发框架.\n\n### Cordova/PhoneGap\t\n\n![Cordova logo](https://ooo.0o0.ooo/2017/03/14/58c7511a7b3cf.png)\n\n[Cordova 官网](http://cordova.apache.org/)\n\n#### 介绍\n为什么这两个要放在一起呢,因为PhoneGap被Adobe收购了,临走之前把核心代码给了Apache,Apache就把这个项目名作Cordova,所以说PhoneGap和Cordova出自同一家,他们都会被开源社区和Adobe所推动.\n\n这个框架是作为原生与web之间的中间件,它采用插件的形式调用原生模块,最后成品就是原生页面和web页面的一个混合应用,现在是一个为大多数混合应用所采用的框架,拥有广大的前景\n\n#### 优点\n用相对简单,学习成本低,对于不熟悉原生开发的前端工程师来说是不错的选择.\n\n#### 缺点\n说实话这个并不是Cordova的缺点,而是web应用共有的问题,就是页面响应迟钝和操作体验不佳的问题.但是这些问题在现在也已经有了足够多的解决方案,具体想了解可以自行上网查阅.\n\n### HTML 5+\n\n![HTML5+ logo](https://ooo.0o0.ooo/2017/03/14/58c7511a6ebea.png)\n\n[官方文档](http://ask.dcloud.net.cn/docs/)\n\n#### 介绍\nDCloud和H5中国产业联盟发起的项目,使用H5+框架自带的各种方法去进行与原生模块之间的沟通,结果产出的依然是web页面,但是\u0007性能相对比Cordova好.\n\n#### 优点\n上手简单,学习成本低,有完整的中文文档,作为移动端webView上的框架体验是很不错的,前端人员可以优先考虑使用这个框架.\n\n#### 缺点\n貌似国外基本没人知道这东西,第三方插件和资源相对较少,要是遇到问题也只能去dcloud社区里面找,stackoverflow是帮不到你的啦,而且就目前看来框架自带的bug还是有的.\n\n### ReactNative\n\n![ReactNative logo](https://ooo.0o0.ooo/2017/03/14/58c7511a63fec.jpg)\n\n[中文官网](http://reactnative.cn/)\n\n#### 介绍\nFacebook 发布的一个混合开发框架,使用ES5/ES6语法,通过ReactNative自带的框架去调用原生模块,但重点是他虽然写的是前端语言,JSX和ES5/ES6但是可以经过构建渲染,将DOM元素转为原生元素,也就是使用前端语言开发原生app已成为现实,既能保留原生的体验又能体现出跨平台和热修复的优势,所以近两年来这个框架十分火.\n\n#### 优点\n既有原生的体验,又能做到跨平台,虽然加载速度还是比纯原生慢一点,但是这个差距已经能达到毫秒级,基本不影响体验,目前像支付宝,手机QQ,淘宝 都已经在部分模块使用了React Native框架,市场前景广阔,拥有丰富的资料.\n\n#### 缺点\n因为这个框架还出现不久,目前还是0.x版本阶段,有部分原生模块还没有接入,只能等他更新\n\n需要一定的学习成本,如果你说你是个会HTML和CSS的前端工程师,那不好意思你还是从入门教程开始看吧╮(╯_╰)╭\n\n### Weex\n\n\n官网 … 额… 没官网..只有一个[论坛](http://www.weex.help/)\n\n#### 介绍\n阿里爸爸推出的跟ReactNative差不多的框架,所以介绍就跟上面差不多,其实我并不是很熟悉这个框架,而且这个框架是16年4月阿里才开放出来内测的,现在支持的原生元素还是不多,现在一年过去了感觉没引起多大关注,如果你学过Vue,那么这个框架你可能会比较好上手\n\n总之阿里爸爸推出了这个轮子还是很吊的.之后说不定会一鸣惊人呢?\n\n### AppCan\n\n[官网](http://www.appcan.cn/)\n\n#### 介绍\n国内的混合开发框架\n\n_(´ཀ`」 ∠) 这个东西是基于他们服务器运行的,所以说如果他们的服务器跪了,你的app就跪了,当然如果你是付费用户,他们就会很快地帮你处理.他们有自己的开发IDE,产出的是也是webView页面,这里就不过多介绍了,具体可以看他们官网.\n\n### 关于热修复\n前言就讲了热修复是啥东西,然后说说最近发生的一件事\n\n今年的三八妇女节那天,苹果发了邮件给使用了热修复的开发者,说你们在应用商店上面的app里面有使用了热修复框架,希望你们以后不要用,因为这会违反什么吧啦吧啦协议条款,然后一群不是很懂英文的程序员就猜来猜去,就说苹果不让用热修复了,JSPatch不能用了啊,ReactNative药丸啊╮(╯_╰)╭,我在V2看到的最多的就是iOS开发者的欢呼23333,感觉真是世态炎凉,原生的优势已经得通过保护才能体现了吗?\n\n嘛.认真看看邮件,苹果是说你们不能用热修复的手段去改变app的功能,像是调用runtime底层方法之类的,就比如说你这个功能本来是显示一个公司的产品展示的的,但是你通过了应用审核之后,远程下发补丁,然后一打开app就弹出一大堆广告,那这样子肯定是违反协议的,当然你用JSPatch的方式你想做啥就做啥,显然不是很好,所以现在JSPatch官方也说近期不要用(前几天我更新了一个app的新版本,没有移除JSPatch,居然也过审了???),但是RN框架是不会做这些事情的,收到邮件的RN开发者大多是因为里面用了Code Push或Expo之类的第三方.\n\n那结论就是,JSPatch不给用了,那也许大家会更倾向于RN或者web方案,所以近期RN的发展应该会更加迅速,反正无论如何,大家尝到热修复的甜头,肯定不会就此罢休.\n\n---\n\n文: Arclin\n\n2017.03.14","slug":"关于App混合开发的介绍","published":1,"updated":"2021-06-06T18:52:24.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoih005xtnn098ld86ow","content":"<p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c75bfb373da.png\"></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Hybrid App 混合开发意思是在web-app、native-app这两者之间的app开发,兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”, 并且也方便我们进行热修复.</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>跨平台就是你写一套代码,然后iOS和Android都能用,这样子可以大大节省人力成本和开发成本</p>\n</blockquote>\n<blockquote>\n<p>热修复就是应用发布之后你还可以通过下发补丁或者直接修改web部分代码去修改app的内容,由于iOS版本应用要上传到应用市场需要经过严格的审核,这将会花费很多时间,如果每次项目一有点小问题就重新发布上架,这将会是一场灾难,所以app的热修复技术在iOS中显得尤为重要</p>\n</blockquote>\n<p>目前比较流行的有Cordova/PhoneGap,HTML 5+,React Native,Weex,AppCan(因为这个平台在很多地方吐槽很严重所以暂时不讨论),接下来我们一个个地讨论这些开发框架.</p>\n<h3 id=\"Cordova-PhoneGap\"><a href=\"#Cordova-PhoneGap\" class=\"headerlink\" title=\"Cordova/PhoneGap\"></a>Cordova/PhoneGap</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a7b3cf.png\" alt=\"Cordova logo\"></p>\n<p><a href=\"http://cordova.apache.org/\">Cordova 官网</a></p>\n<h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>为什么这两个要放在一起呢,因为PhoneGap被Adobe收购了,临走之前把核心代码给了Apache,Apache就把这个项目名作Cordova,所以说PhoneGap和Cordova出自同一家,他们都会被开源社区和Adobe所推动.</p>\n<p>这个框架是作为原生与web之间的中间件,它采用插件的形式调用原生模块,最后成品就是原生页面和web页面的一个混合应用,现在是一个为大多数混合应用所采用的框架,拥有广大的前景</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>用相对简单,学习成本低,对于不熟悉原生开发的前端工程师来说是不错的选择.</p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>说实话这个并不是Cordova的缺点,而是web应用共有的问题,就是页面响应迟钝和操作体验不佳的问题.但是这些问题在现在也已经有了足够多的解决方案,具体想了解可以自行上网查阅.</p>\n<h3 id=\"HTML-5\"><a href=\"#HTML-5\" class=\"headerlink\" title=\"HTML 5+\"></a>HTML 5+</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a6ebea.png\" alt=\"HTML5+ logo\"></p>\n<p><a href=\"http://ask.dcloud.net.cn/docs/\">官方文档</a></p>\n<h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>DCloud和H5中国产业联盟发起的项目,使用H5+框架自带的各种方法去进行与原生模块之间的沟通,结果产出的依然是web页面,但是\u0007性能相对比Cordova好.</p>\n<h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>上手简单,学习成本低,有完整的中文文档,作为移动端webView上的框架体验是很不错的,前端人员可以优先考虑使用这个框架.</p>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>貌似国外基本没人知道这东西,第三方插件和资源相对较少,要是遇到问题也只能去dcloud社区里面找,stackoverflow是帮不到你的啦,而且就目前看来框架自带的bug还是有的.</p>\n<h3 id=\"ReactNative\"><a href=\"#ReactNative\" class=\"headerlink\" title=\"ReactNative\"></a>ReactNative</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a63fec.jpg\" alt=\"ReactNative logo\"></p>\n<p><a href=\"http://reactnative.cn/\">中文官网</a></p>\n<h4 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>Facebook 发布的一个混合开发框架,使用ES5/ES6语法,通过ReactNative自带的框架去调用原生模块,但重点是他虽然写的是前端语言,JSX和ES5/ES6但是可以经过构建渲染,将DOM元素转为原生元素,也就是使用前端语言开发原生app已成为现实,既能保留原生的体验又能体现出跨平台和热修复的优势,所以近两年来这个框架十分火.</p>\n<h4 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>既有原生的体验,又能做到跨平台,虽然加载速度还是比纯原生慢一点,但是这个差距已经能达到毫秒级,基本不影响体验,目前像支付宝,手机QQ,淘宝 都已经在部分模块使用了React Native框架,市场前景广阔,拥有丰富的资料.</p>\n<h4 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>因为这个框架还出现不久,目前还是0.x版本阶段,有部分原生模块还没有接入,只能等他更新</p>\n<p>需要一定的学习成本,如果你说你是个会HTML和CSS的前端工程师,那不好意思你还是从入门教程开始看吧╮(╯_╰)╭</p>\n<h3 id=\"Weex\"><a href=\"#Weex\" class=\"headerlink\" title=\"Weex\"></a>Weex</h3><p>官网 … 额… 没官网..只有一个<a href=\"http://www.weex.help/\">论坛</a></p>\n<h4 id=\"介绍-3\"><a href=\"#介绍-3\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>阿里爸爸推出的跟ReactNative差不多的框架,所以介绍就跟上面差不多,其实我并不是很熟悉这个框架,而且这个框架是16年4月阿里才开放出来内测的,现在支持的原生元素还是不多,现在一年过去了感觉没引起多大关注,如果你学过Vue,那么这个框架你可能会比较好上手</p>\n<p>总之阿里爸爸推出了这个轮子还是很吊的.之后说不定会一鸣惊人呢?</p>\n<h3 id=\"AppCan\"><a href=\"#AppCan\" class=\"headerlink\" title=\"AppCan\"></a>AppCan</h3><p><a href=\"http://www.appcan.cn/\">官网</a></p>\n<h4 id=\"介绍-4\"><a href=\"#介绍-4\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>国内的混合开发框架</p>\n<p>_(´ཀ`」 ∠) 这个东西是基于他们服务器运行的,所以说如果他们的服务器跪了,你的app就跪了,当然如果你是付费用户,他们就会很快地帮你处理.他们有自己的开发IDE,产出的是也是webView页面,这里就不过多介绍了,具体可以看他们官网.</p>\n<h3 id=\"关于热修复\"><a href=\"#关于热修复\" class=\"headerlink\" title=\"关于热修复\"></a>关于热修复</h3><p>前言就讲了热修复是啥东西,然后说说最近发生的一件事</p>\n<p>今年的三八妇女节那天,苹果发了邮件给使用了热修复的开发者,说你们在应用商店上面的app里面有使用了热修复框架,希望你们以后不要用,因为这会违反什么吧啦吧啦协议条款,然后一群不是很懂英文的程序员就猜来猜去,就说苹果不让用热修复了,JSPatch不能用了啊,ReactNative药丸啊╮(╯_╰)╭,我在V2看到的最多的就是iOS开发者的欢呼23333,感觉真是世态炎凉,原生的优势已经得通过保护才能体现了吗?</p>\n<p>嘛.认真看看邮件,苹果是说你们不能用热修复的手段去改变app的功能,像是调用runtime底层方法之类的,就比如说你这个功能本来是显示一个公司的产品展示的的,但是你通过了应用审核之后,远程下发补丁,然后一打开app就弹出一大堆广告,那这样子肯定是违反协议的,当然你用JSPatch的方式你想做啥就做啥,显然不是很好,所以现在JSPatch官方也说近期不要用(前几天我更新了一个app的新版本,没有移除JSPatch,居然也过审了???),但是RN框架是不会做这些事情的,收到邮件的RN开发者大多是因为里面用了Code Push或Expo之类的第三方.</p>\n<p>那结论就是,JSPatch不给用了,那也许大家会更倾向于RN或者web方案,所以近期RN的发展应该会更加迅速,反正无论如何,大家尝到热修复的甜头,肯定不会就此罢休.</p>\n<hr>\n<p>文: Arclin</p>\n<p>2017.03.14</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c75bfb373da.png\"></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Hybrid App 混合开发意思是在web-app、native-app这两者之间的app开发,兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”, 并且也方便我们进行热修复.</p>","more":"<blockquote>\n<p>跨平台就是你写一套代码,然后iOS和Android都能用,这样子可以大大节省人力成本和开发成本</p>\n</blockquote>\n<blockquote>\n<p>热修复就是应用发布之后你还可以通过下发补丁或者直接修改web部分代码去修改app的内容,由于iOS版本应用要上传到应用市场需要经过严格的审核,这将会花费很多时间,如果每次项目一有点小问题就重新发布上架,这将会是一场灾难,所以app的热修复技术在iOS中显得尤为重要</p>\n</blockquote>\n<p>目前比较流行的有Cordova/PhoneGap,HTML 5+,React Native,Weex,AppCan(因为这个平台在很多地方吐槽很严重所以暂时不讨论),接下来我们一个个地讨论这些开发框架.</p>\n<h3 id=\"Cordova-PhoneGap\"><a href=\"#Cordova-PhoneGap\" class=\"headerlink\" title=\"Cordova/PhoneGap\"></a>Cordova/PhoneGap</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a7b3cf.png\" alt=\"Cordova logo\"></p>\n<p><a href=\"http://cordova.apache.org/\">Cordova 官网</a></p>\n<h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>为什么这两个要放在一起呢,因为PhoneGap被Adobe收购了,临走之前把核心代码给了Apache,Apache就把这个项目名作Cordova,所以说PhoneGap和Cordova出自同一家,他们都会被开源社区和Adobe所推动.</p>\n<p>这个框架是作为原生与web之间的中间件,它采用插件的形式调用原生模块,最后成品就是原生页面和web页面的一个混合应用,现在是一个为大多数混合应用所采用的框架,拥有广大的前景</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>用相对简单,学习成本低,对于不熟悉原生开发的前端工程师来说是不错的选择.</p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>说实话这个并不是Cordova的缺点,而是web应用共有的问题,就是页面响应迟钝和操作体验不佳的问题.但是这些问题在现在也已经有了足够多的解决方案,具体想了解可以自行上网查阅.</p>\n<h3 id=\"HTML-5\"><a href=\"#HTML-5\" class=\"headerlink\" title=\"HTML 5+\"></a>HTML 5+</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a6ebea.png\" alt=\"HTML5+ logo\"></p>\n<p><a href=\"http://ask.dcloud.net.cn/docs/\">官方文档</a></p>\n<h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>DCloud和H5中国产业联盟发起的项目,使用H5+框架自带的各种方法去进行与原生模块之间的沟通,结果产出的依然是web页面,但是\u0007性能相对比Cordova好.</p>\n<h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>上手简单,学习成本低,有完整的中文文档,作为移动端webView上的框架体验是很不错的,前端人员可以优先考虑使用这个框架.</p>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>貌似国外基本没人知道这东西,第三方插件和资源相对较少,要是遇到问题也只能去dcloud社区里面找,stackoverflow是帮不到你的啦,而且就目前看来框架自带的bug还是有的.</p>\n<h3 id=\"ReactNative\"><a href=\"#ReactNative\" class=\"headerlink\" title=\"ReactNative\"></a>ReactNative</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a63fec.jpg\" alt=\"ReactNative logo\"></p>\n<p><a href=\"http://reactnative.cn/\">中文官网</a></p>\n<h4 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>Facebook 发布的一个混合开发框架,使用ES5/ES6语法,通过ReactNative自带的框架去调用原生模块,但重点是他虽然写的是前端语言,JSX和ES5/ES6但是可以经过构建渲染,将DOM元素转为原生元素,也就是使用前端语言开发原生app已成为现实,既能保留原生的体验又能体现出跨平台和热修复的优势,所以近两年来这个框架十分火.</p>\n<h4 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>既有原生的体验,又能做到跨平台,虽然加载速度还是比纯原生慢一点,但是这个差距已经能达到毫秒级,基本不影响体验,目前像支付宝,手机QQ,淘宝 都已经在部分模块使用了React Native框架,市场前景广阔,拥有丰富的资料.</p>\n<h4 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>因为这个框架还出现不久,目前还是0.x版本阶段,有部分原生模块还没有接入,只能等他更新</p>\n<p>需要一定的学习成本,如果你说你是个会HTML和CSS的前端工程师,那不好意思你还是从入门教程开始看吧╮(╯_╰)╭</p>\n<h3 id=\"Weex\"><a href=\"#Weex\" class=\"headerlink\" title=\"Weex\"></a>Weex</h3><p>官网 … 额… 没官网..只有一个<a href=\"http://www.weex.help/\">论坛</a></p>\n<h4 id=\"介绍-3\"><a href=\"#介绍-3\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>阿里爸爸推出的跟ReactNative差不多的框架,所以介绍就跟上面差不多,其实我并不是很熟悉这个框架,而且这个框架是16年4月阿里才开放出来内测的,现在支持的原生元素还是不多,现在一年过去了感觉没引起多大关注,如果你学过Vue,那么这个框架你可能会比较好上手</p>\n<p>总之阿里爸爸推出了这个轮子还是很吊的.之后说不定会一鸣惊人呢?</p>\n<h3 id=\"AppCan\"><a href=\"#AppCan\" class=\"headerlink\" title=\"AppCan\"></a>AppCan</h3><p><a href=\"http://www.appcan.cn/\">官网</a></p>\n<h4 id=\"介绍-4\"><a href=\"#介绍-4\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>国内的混合开发框架</p>\n<p>_(´ཀ`」 ∠) 这个东西是基于他们服务器运行的,所以说如果他们的服务器跪了,你的app就跪了,当然如果你是付费用户,他们就会很快地帮你处理.他们有自己的开发IDE,产出的是也是webView页面,这里就不过多介绍了,具体可以看他们官网.</p>\n<h3 id=\"关于热修复\"><a href=\"#关于热修复\" class=\"headerlink\" title=\"关于热修复\"></a>关于热修复</h3><p>前言就讲了热修复是啥东西,然后说说最近发生的一件事</p>\n<p>今年的三八妇女节那天,苹果发了邮件给使用了热修复的开发者,说你们在应用商店上面的app里面有使用了热修复框架,希望你们以后不要用,因为这会违反什么吧啦吧啦协议条款,然后一群不是很懂英文的程序员就猜来猜去,就说苹果不让用热修复了,JSPatch不能用了啊,ReactNative药丸啊╮(╯_╰)╭,我在V2看到的最多的就是iOS开发者的欢呼23333,感觉真是世态炎凉,原生的优势已经得通过保护才能体现了吗?</p>\n<p>嘛.认真看看邮件,苹果是说你们不能用热修复的手段去改变app的功能,像是调用runtime底层方法之类的,就比如说你这个功能本来是显示一个公司的产品展示的的,但是你通过了应用审核之后,远程下发补丁,然后一打开app就弹出一大堆广告,那这样子肯定是违反协议的,当然你用JSPatch的方式你想做啥就做啥,显然不是很好,所以现在JSPatch官方也说近期不要用(前几天我更新了一个app的新版本,没有移除JSPatch,居然也过审了???),但是RN框架是不会做这些事情的,收到邮件的RN开发者大多是因为里面用了Code Push或Expo之类的第三方.</p>\n<p>那结论就是,JSPatch不给用了,那也许大家会更倾向于RN或者web方案,所以近期RN的发展应该会更加迅速,反正无论如何,大家尝到热修复的甜头,肯定不会就此罢休.</p>\n<hr>\n<p>文: Arclin</p>\n<p>2017.03.14</p>"},{"title":"关于第三方单元测试框架的简单说明","author":"Arclin","abbrlink":"7daa41d8","date":"2018-05-23T05:12:00.000Z","_content":"关于第三方单元测试框架的简单说明\n\n<!-- more -->\n\n\n## Pod安装\n\nPodfile编写（框架只能安装在UnitTest的Target中）\n\n```\ntarget 'BaZiPaiPanSDK' do\n    ...\n    target 'BaZiPaiPanSDKTests' do\n        inherit! :search_paths\n        pod 'Specta'\n        pod 'Expecta'\n        pod 'OCMock'\n    end\nend\n```\n\n## Specta\n\n- Specta是一个BDD（行为驱动开发）框架\n\n```\n#import <OCMock/OCMock.h>\n#import <Specta/Specta.h>\n#import <Expecta/Expecta.h>\n#import <ReactiveCocoa/ReactiveCocoa.h>\n#import \"BZPPCaiYunViewModel.h\"\n\nSpecBegin(BZPPCaiYunViewModel)\t// 声明了一个测试类\n\n    __block BZPPCaiYunViewModel *viewModel; // 我们要测试这个类\n\n    beforeEach(^{ \t\t\t\t\t// 通过beforeEach 首先先初始化 \n        viewModel = [[BZPPCaiYunViewModel alloc] init];\n    });\n\n    describe(@\"BZPPCaiYunViewModel\", ^{  // 声明一组用例\n    \n        it(@\"refresh when data isn't empty\", ^{ // 通过 it 声明一个用例，前面的字符串是一个描述\n            __block id result;\n            waitUntil(^(DoneCallback done) { // 假设这里有网络请求，所以需要异步，有点像GCD的信号量\n                [[viewModel.loadDataCommand execute:nil] subscribeNext:^(id x) {\n                    result = x;\n                    done(); // 请求结束，告知框架可以继续往下走\n                }];\n            });\n            expect(result).notTo.beNull(); // 这里是Expecta框架的内容，后面解释\n        });\n    });\n\n    afterEach(^{\n        viewModel = nil; // 测试结束，清空\n    });\n\nSpecEnd // 类的结束，相当于 @end\n```\n\n\n## OCMock\n\n- OCMock一般用来构造伪数据，比如说有时候我们一个方法内部需要通过很多数据才能完成，但是这些数据需要其他复杂的实现去获取，这时候我们用OCMock就可以方便地创造这些数据\n\n- OCMock可以做的事情大概如下\n\t- 指定一个方法的返回值\n\t- 验证某个方法是否有被调用 (比如说指定了错误的数据会不会调用处理异常的方法)\n\t- 验证方法block传出来的参数是否符合预期\n\t- 模拟UI和验证UI的显示\n\n```\nSpecBegin(BZPPCaiYunViewModel)\n\n    __block BZPPCaiYunViewModel *viewModel;\n\n    beforeEach(^{\n    \n    });\n\n    describe(@\"Test OCMock\", ^{\n        it(@\"It should not to be null\", ^{\n            id mockManager = OCMClassMock([BZPPHunLianManager class]); // 因为是单例所以要用这种方法mock一个对象\n            OCMStub([mockManager sharedInstance]).andReturn([BZPPHunLianManager class]); // 同上，调用单例方法返回一个单例对象, OCMStub意思就是模拟执行某个方法, 用andReturn返回指定的值\n            OCMVerify([mockManager getGanQingHunYinData:OCMOCK_ANY isMale:YES]); // 验证这个方法是否在上面的过程中被调用了，结果是没有被调用，测试失败\n        });\n    });\n\n    afterEach(^{\n        \n    });\n\nSpecEnd\n```\n\n## Expecta\n\n- Expecta是一个断言框架, 语法十分地通俗易懂, 很接近自然语言\n- Expecta的用法比较简单\n\n```\nexpect(obj).to.beNull(); // 期望某对象应该是空值\nexpect(obj).toNot.beNull(); // 期望某对象不应该是空值\nexpect(obj).equal(xxx); // 期望等于某个值\n```\n\n诸如此类比较多可以去看Github官方文档","source":"_posts/关于第三方单元测试框架的简单说明.md","raw":"title: 关于第三方单元测试框架的简单说明\nauthor: Arclin\nabbrlink: 7daa41d8\ntags:\n  - iOS\ncategories:\n  - iOS\ndate: 2018-05-23 13:12:00\n---\n关于第三方单元测试框架的简单说明\n\n<!-- more -->\n\n\n## Pod安装\n\nPodfile编写（框架只能安装在UnitTest的Target中）\n\n```\ntarget 'BaZiPaiPanSDK' do\n    ...\n    target 'BaZiPaiPanSDKTests' do\n        inherit! :search_paths\n        pod 'Specta'\n        pod 'Expecta'\n        pod 'OCMock'\n    end\nend\n```\n\n## Specta\n\n- Specta是一个BDD（行为驱动开发）框架\n\n```\n#import <OCMock/OCMock.h>\n#import <Specta/Specta.h>\n#import <Expecta/Expecta.h>\n#import <ReactiveCocoa/ReactiveCocoa.h>\n#import \"BZPPCaiYunViewModel.h\"\n\nSpecBegin(BZPPCaiYunViewModel)\t// 声明了一个测试类\n\n    __block BZPPCaiYunViewModel *viewModel; // 我们要测试这个类\n\n    beforeEach(^{ \t\t\t\t\t// 通过beforeEach 首先先初始化 \n        viewModel = [[BZPPCaiYunViewModel alloc] init];\n    });\n\n    describe(@\"BZPPCaiYunViewModel\", ^{  // 声明一组用例\n    \n        it(@\"refresh when data isn't empty\", ^{ // 通过 it 声明一个用例，前面的字符串是一个描述\n            __block id result;\n            waitUntil(^(DoneCallback done) { // 假设这里有网络请求，所以需要异步，有点像GCD的信号量\n                [[viewModel.loadDataCommand execute:nil] subscribeNext:^(id x) {\n                    result = x;\n                    done(); // 请求结束，告知框架可以继续往下走\n                }];\n            });\n            expect(result).notTo.beNull(); // 这里是Expecta框架的内容，后面解释\n        });\n    });\n\n    afterEach(^{\n        viewModel = nil; // 测试结束，清空\n    });\n\nSpecEnd // 类的结束，相当于 @end\n```\n\n\n## OCMock\n\n- OCMock一般用来构造伪数据，比如说有时候我们一个方法内部需要通过很多数据才能完成，但是这些数据需要其他复杂的实现去获取，这时候我们用OCMock就可以方便地创造这些数据\n\n- OCMock可以做的事情大概如下\n\t- 指定一个方法的返回值\n\t- 验证某个方法是否有被调用 (比如说指定了错误的数据会不会调用处理异常的方法)\n\t- 验证方法block传出来的参数是否符合预期\n\t- 模拟UI和验证UI的显示\n\n```\nSpecBegin(BZPPCaiYunViewModel)\n\n    __block BZPPCaiYunViewModel *viewModel;\n\n    beforeEach(^{\n    \n    });\n\n    describe(@\"Test OCMock\", ^{\n        it(@\"It should not to be null\", ^{\n            id mockManager = OCMClassMock([BZPPHunLianManager class]); // 因为是单例所以要用这种方法mock一个对象\n            OCMStub([mockManager sharedInstance]).andReturn([BZPPHunLianManager class]); // 同上，调用单例方法返回一个单例对象, OCMStub意思就是模拟执行某个方法, 用andReturn返回指定的值\n            OCMVerify([mockManager getGanQingHunYinData:OCMOCK_ANY isMale:YES]); // 验证这个方法是否在上面的过程中被调用了，结果是没有被调用，测试失败\n        });\n    });\n\n    afterEach(^{\n        \n    });\n\nSpecEnd\n```\n\n## Expecta\n\n- Expecta是一个断言框架, 语法十分地通俗易懂, 很接近自然语言\n- Expecta的用法比较简单\n\n```\nexpect(obj).to.beNull(); // 期望某对象应该是空值\nexpect(obj).toNot.beNull(); // 期望某对象不应该是空值\nexpect(obj).equal(xxx); // 期望等于某个值\n```\n\n诸如此类比较多可以去看Github官方文档","slug":"关于第三方单元测试框架的简单说明","published":1,"updated":"2021-06-06T18:52:24.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoii0061tnn0ctnu9e47","content":"<p>关于第三方单元测试框架的简单说明</p>\n<span id=\"more\"></span>\n\n\n<h2 id=\"Pod安装\"><a href=\"#Pod安装\" class=\"headerlink\" title=\"Pod安装\"></a>Pod安装</h2><p>Podfile编写（框架只能安装在UnitTest的Target中）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target &#39;BaZiPaiPanSDK&#39; do</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    target &#39;BaZiPaiPanSDKTests&#39; do</span><br><span class=\"line\">        inherit! :search_paths</span><br><span class=\"line\">        pod &#39;Specta&#39;</span><br><span class=\"line\">        pod &#39;Expecta&#39;</span><br><span class=\"line\">        pod &#39;OCMock&#39;</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Specta\"><a href=\"#Specta\" class=\"headerlink\" title=\"Specta\"></a>Specta</h2><ul>\n<li>Specta是一个BDD（行为驱动开发）框架</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;OCMock&#x2F;OCMock.h&gt;</span><br><span class=\"line\">#import &lt;Specta&#x2F;Specta.h&gt;</span><br><span class=\"line\">#import &lt;Expecta&#x2F;Expecta.h&gt;</span><br><span class=\"line\">#import &lt;ReactiveCocoa&#x2F;ReactiveCocoa.h&gt;</span><br><span class=\"line\">#import &quot;BZPPCaiYunViewModel.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">SpecBegin(BZPPCaiYunViewModel)\t&#x2F;&#x2F; 声明了一个测试类</span><br><span class=\"line\"></span><br><span class=\"line\">    __block BZPPCaiYunViewModel *viewModel; &#x2F;&#x2F; 我们要测试这个类</span><br><span class=\"line\"></span><br><span class=\"line\">    beforeEach(^&#123; \t\t\t\t\t&#x2F;&#x2F; 通过beforeEach 首先先初始化 </span><br><span class=\"line\">        viewModel &#x3D; [[BZPPCaiYunViewModel alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    describe(@&quot;BZPPCaiYunViewModel&quot;, ^&#123;  &#x2F;&#x2F; 声明一组用例</span><br><span class=\"line\">    </span><br><span class=\"line\">        it(@&quot;refresh when data isn&#39;t empty&quot;, ^&#123; &#x2F;&#x2F; 通过 it 声明一个用例，前面的字符串是一个描述</span><br><span class=\"line\">            __block id result;</span><br><span class=\"line\">            waitUntil(^(DoneCallback done) &#123; &#x2F;&#x2F; 假设这里有网络请求，所以需要异步，有点像GCD的信号量</span><br><span class=\"line\">                [[viewModel.loadDataCommand execute:nil] subscribeNext:^(id x) &#123;</span><br><span class=\"line\">                    result &#x3D; x;</span><br><span class=\"line\">                    done(); &#x2F;&#x2F; 请求结束，告知框架可以继续往下走</span><br><span class=\"line\">                &#125;];</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            expect(result).notTo.beNull(); &#x2F;&#x2F; 这里是Expecta框架的内容，后面解释</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    afterEach(^&#123;</span><br><span class=\"line\">        viewModel &#x3D; nil; &#x2F;&#x2F; 测试结束，清空</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">SpecEnd &#x2F;&#x2F; 类的结束，相当于 @end</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"OCMock\"><a href=\"#OCMock\" class=\"headerlink\" title=\"OCMock\"></a>OCMock</h2><ul>\n<li><p>OCMock一般用来构造伪数据，比如说有时候我们一个方法内部需要通过很多数据才能完成，但是这些数据需要其他复杂的实现去获取，这时候我们用OCMock就可以方便地创造这些数据</p>\n</li>\n<li><p>OCMock可以做的事情大概如下</p>\n<ul>\n<li>指定一个方法的返回值</li>\n<li>验证某个方法是否有被调用 (比如说指定了错误的数据会不会调用处理异常的方法)</li>\n<li>验证方法block传出来的参数是否符合预期</li>\n<li>模拟UI和验证UI的显示</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SpecBegin(BZPPCaiYunViewModel)</span><br><span class=\"line\"></span><br><span class=\"line\">    __block BZPPCaiYunViewModel *viewModel;</span><br><span class=\"line\"></span><br><span class=\"line\">    beforeEach(^&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    describe(@&quot;Test OCMock&quot;, ^&#123;</span><br><span class=\"line\">        it(@&quot;It should not to be null&quot;, ^&#123;</span><br><span class=\"line\">            id mockManager &#x3D; OCMClassMock([BZPPHunLianManager class]); &#x2F;&#x2F; 因为是单例所以要用这种方法mock一个对象</span><br><span class=\"line\">            OCMStub([mockManager sharedInstance]).andReturn([BZPPHunLianManager class]); &#x2F;&#x2F; 同上，调用单例方法返回一个单例对象, OCMStub意思就是模拟执行某个方法, 用andReturn返回指定的值</span><br><span class=\"line\">            OCMVerify([mockManager getGanQingHunYinData:OCMOCK_ANY isMale:YES]); &#x2F;&#x2F; 验证这个方法是否在上面的过程中被调用了，结果是没有被调用，测试失败</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    afterEach(^&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">SpecEnd</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Expecta\"><a href=\"#Expecta\" class=\"headerlink\" title=\"Expecta\"></a>Expecta</h2><ul>\n<li>Expecta是一个断言框架, 语法十分地通俗易懂, 很接近自然语言</li>\n<li>Expecta的用法比较简单</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(obj).to.beNull(); &#x2F;&#x2F; 期望某对象应该是空值</span><br><span class=\"line\">expect(obj).toNot.beNull(); &#x2F;&#x2F; 期望某对象不应该是空值</span><br><span class=\"line\">expect(obj).equal(xxx); &#x2F;&#x2F; 期望等于某个值</span><br></pre></td></tr></table></figure>\n\n<p>诸如此类比较多可以去看Github官方文档</p>\n","site":{"data":{}},"excerpt":"<p>关于第三方单元测试框架的简单说明</p>","more":"<h2 id=\"Pod安装\"><a href=\"#Pod安装\" class=\"headerlink\" title=\"Pod安装\"></a>Pod安装</h2><p>Podfile编写（框架只能安装在UnitTest的Target中）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target &#39;BaZiPaiPanSDK&#39; do</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    target &#39;BaZiPaiPanSDKTests&#39; do</span><br><span class=\"line\">        inherit! :search_paths</span><br><span class=\"line\">        pod &#39;Specta&#39;</span><br><span class=\"line\">        pod &#39;Expecta&#39;</span><br><span class=\"line\">        pod &#39;OCMock&#39;</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Specta\"><a href=\"#Specta\" class=\"headerlink\" title=\"Specta\"></a>Specta</h2><ul>\n<li>Specta是一个BDD（行为驱动开发）框架</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;OCMock&#x2F;OCMock.h&gt;</span><br><span class=\"line\">#import &lt;Specta&#x2F;Specta.h&gt;</span><br><span class=\"line\">#import &lt;Expecta&#x2F;Expecta.h&gt;</span><br><span class=\"line\">#import &lt;ReactiveCocoa&#x2F;ReactiveCocoa.h&gt;</span><br><span class=\"line\">#import &quot;BZPPCaiYunViewModel.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">SpecBegin(BZPPCaiYunViewModel)\t&#x2F;&#x2F; 声明了一个测试类</span><br><span class=\"line\"></span><br><span class=\"line\">    __block BZPPCaiYunViewModel *viewModel; &#x2F;&#x2F; 我们要测试这个类</span><br><span class=\"line\"></span><br><span class=\"line\">    beforeEach(^&#123; \t\t\t\t\t&#x2F;&#x2F; 通过beforeEach 首先先初始化 </span><br><span class=\"line\">        viewModel &#x3D; [[BZPPCaiYunViewModel alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    describe(@&quot;BZPPCaiYunViewModel&quot;, ^&#123;  &#x2F;&#x2F; 声明一组用例</span><br><span class=\"line\">    </span><br><span class=\"line\">        it(@&quot;refresh when data isn&#39;t empty&quot;, ^&#123; &#x2F;&#x2F; 通过 it 声明一个用例，前面的字符串是一个描述</span><br><span class=\"line\">            __block id result;</span><br><span class=\"line\">            waitUntil(^(DoneCallback done) &#123; &#x2F;&#x2F; 假设这里有网络请求，所以需要异步，有点像GCD的信号量</span><br><span class=\"line\">                [[viewModel.loadDataCommand execute:nil] subscribeNext:^(id x) &#123;</span><br><span class=\"line\">                    result &#x3D; x;</span><br><span class=\"line\">                    done(); &#x2F;&#x2F; 请求结束，告知框架可以继续往下走</span><br><span class=\"line\">                &#125;];</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            expect(result).notTo.beNull(); &#x2F;&#x2F; 这里是Expecta框架的内容，后面解释</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    afterEach(^&#123;</span><br><span class=\"line\">        viewModel &#x3D; nil; &#x2F;&#x2F; 测试结束，清空</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">SpecEnd &#x2F;&#x2F; 类的结束，相当于 @end</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"OCMock\"><a href=\"#OCMock\" class=\"headerlink\" title=\"OCMock\"></a>OCMock</h2><ul>\n<li><p>OCMock一般用来构造伪数据，比如说有时候我们一个方法内部需要通过很多数据才能完成，但是这些数据需要其他复杂的实现去获取，这时候我们用OCMock就可以方便地创造这些数据</p>\n</li>\n<li><p>OCMock可以做的事情大概如下</p>\n<ul>\n<li>指定一个方法的返回值</li>\n<li>验证某个方法是否有被调用 (比如说指定了错误的数据会不会调用处理异常的方法)</li>\n<li>验证方法block传出来的参数是否符合预期</li>\n<li>模拟UI和验证UI的显示</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SpecBegin(BZPPCaiYunViewModel)</span><br><span class=\"line\"></span><br><span class=\"line\">    __block BZPPCaiYunViewModel *viewModel;</span><br><span class=\"line\"></span><br><span class=\"line\">    beforeEach(^&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    describe(@&quot;Test OCMock&quot;, ^&#123;</span><br><span class=\"line\">        it(@&quot;It should not to be null&quot;, ^&#123;</span><br><span class=\"line\">            id mockManager &#x3D; OCMClassMock([BZPPHunLianManager class]); &#x2F;&#x2F; 因为是单例所以要用这种方法mock一个对象</span><br><span class=\"line\">            OCMStub([mockManager sharedInstance]).andReturn([BZPPHunLianManager class]); &#x2F;&#x2F; 同上，调用单例方法返回一个单例对象, OCMStub意思就是模拟执行某个方法, 用andReturn返回指定的值</span><br><span class=\"line\">            OCMVerify([mockManager getGanQingHunYinData:OCMOCK_ANY isMale:YES]); &#x2F;&#x2F; 验证这个方法是否在上面的过程中被调用了，结果是没有被调用，测试失败</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    afterEach(^&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">SpecEnd</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Expecta\"><a href=\"#Expecta\" class=\"headerlink\" title=\"Expecta\"></a>Expecta</h2><ul>\n<li>Expecta是一个断言框架, 语法十分地通俗易懂, 很接近自然语言</li>\n<li>Expecta的用法比较简单</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(obj).to.beNull(); &#x2F;&#x2F; 期望某对象应该是空值</span><br><span class=\"line\">expect(obj).toNot.beNull(); &#x2F;&#x2F; 期望某对象不应该是空值</span><br><span class=\"line\">expect(obj).equal(xxx); &#x2F;&#x2F; 期望等于某个值</span><br></pre></td></tr></table></figure>\n\n<p>诸如此类比较多可以去看Github官方文档</p>"},{"title":"发现一个api","author":"Arclin","abbrlink":"54b26395","date":"2016-10-16T16:00:00.000Z","_content":"发现一个好用的api，用于找出selectedItem 在 dataSource 里面的位置，适用于tableView和collectionView\n\n```\nNSIndexSet *indexSet = [self.photos indexesOfObjectsPassingTest:^BOOL(DKPhoto * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n    if ([self.selectedPhotoArray containsObject:obj]) {\n        return YES;\n    }\n    return NO;\n}];\n```","source":"_posts/发现一个api.md","raw":"---\ntitle: 发现一个api\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 54b26395\ndate: 2016-10-17 00:00:00\n---\n发现一个好用的api，用于找出selectedItem 在 dataSource 里面的位置，适用于tableView和collectionView\n\n```\nNSIndexSet *indexSet = [self.photos indexesOfObjectsPassingTest:^BOOL(DKPhoto * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n    if ([self.selectedPhotoArray containsObject:obj]) {\n        return YES;\n    }\n    return NO;\n}];\n```","slug":"发现一个api","published":1,"updated":"2021-06-06T18:52:24.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoil0065tnn020pwci50","content":"<p>发现一个好用的api，用于找出selectedItem 在 dataSource 里面的位置，适用于tableView和collectionView</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSIndexSet *indexSet &#x3D; [self.photos indexesOfObjectsPassingTest:^BOOL(DKPhoto * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">    if ([self.selectedPhotoArray containsObject:obj]) &#123;</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>发现一个好用的api，用于找出selectedItem 在 dataSource 里面的位置，适用于tableView和collectionView</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSIndexSet *indexSet &#x3D; [self.photos indexesOfObjectsPassingTest:^BOOL(DKPhoto * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">    if ([self.selectedPhotoArray containsObject:obj]) &#123;</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>"},{"title":"在 iCloud Drive中显示 App的iCloud文件夹","author":"Arclin","abbrlink":"3eb7dc04","date":"2016-10-28T16:00:00.000Z","_content":"1. 修改 info.plist\n\n  ```\n  <key>NSUbiquitousContainers</key>\n      <dict>\n          <key>iCloud.com.example.app</key>\n          <dict>\n              <key>NSUbiquitousContainerIsDocumentScopePublic</key>\n              <true/>\n              <key>NSUbiquitousContainerName</key>\n              <string>App name to display in iCloud Drive</string>\n              <key>NSUbiquitousContainerSupportedFolderLevels</key>\n              <string>None</string>\n          </dict>\n      </dict>\n  ```\n\n2. 修改版本构件号(必改)","source":"_posts/在-iCloud-Drive中显示-App的iCloud文件夹.md","raw":"---\ntitle: 在 iCloud Drive中显示 App的iCloud文件夹\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 3eb7dc04\ndate: 2016-10-29 00:00:00\n---\n1. 修改 info.plist\n\n  ```\n  <key>NSUbiquitousContainers</key>\n      <dict>\n          <key>iCloud.com.example.app</key>\n          <dict>\n              <key>NSUbiquitousContainerIsDocumentScopePublic</key>\n              <true/>\n              <key>NSUbiquitousContainerName</key>\n              <string>App name to display in iCloud Drive</string>\n              <key>NSUbiquitousContainerSupportedFolderLevels</key>\n              <string>None</string>\n          </dict>\n      </dict>\n  ```\n\n2. 修改版本构件号(必改)","slug":"在-iCloud-Drive中显示-App的iCloud文件夹","published":1,"updated":"2021-06-06T18:52:24.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoim0068tnn085it1xbg","content":"<ol>\n<li>修改 info.plist</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;NSUbiquitousContainers&lt;&#x2F;key&gt;</span><br><span class=\"line\">    &lt;dict&gt;</span><br><span class=\"line\">        &lt;key&gt;iCloud.com.example.app&lt;&#x2F;key&gt;</span><br><span class=\"line\">        &lt;dict&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerIsDocumentScopePublic&lt;&#x2F;key&gt;</span><br><span class=\"line\">            &lt;true&#x2F;&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerName&lt;&#x2F;key&gt;</span><br><span class=\"line\">            &lt;string&gt;App name to display in iCloud Drive&lt;&#x2F;string&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerSupportedFolderLevels&lt;&#x2F;key&gt;</span><br><span class=\"line\">            &lt;string&gt;None&lt;&#x2F;string&gt;</span><br><span class=\"line\">        &lt;&#x2F;dict&gt;</span><br><span class=\"line\">    &lt;&#x2F;dict&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>修改版本构件号(必改)</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>修改 info.plist</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;NSUbiquitousContainers&lt;&#x2F;key&gt;</span><br><span class=\"line\">    &lt;dict&gt;</span><br><span class=\"line\">        &lt;key&gt;iCloud.com.example.app&lt;&#x2F;key&gt;</span><br><span class=\"line\">        &lt;dict&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerIsDocumentScopePublic&lt;&#x2F;key&gt;</span><br><span class=\"line\">            &lt;true&#x2F;&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerName&lt;&#x2F;key&gt;</span><br><span class=\"line\">            &lt;string&gt;App name to display in iCloud Drive&lt;&#x2F;string&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerSupportedFolderLevels&lt;&#x2F;key&gt;</span><br><span class=\"line\">            &lt;string&gt;None&lt;&#x2F;string&gt;</span><br><span class=\"line\">        &lt;&#x2F;dict&gt;</span><br><span class=\"line\">    &lt;&#x2F;dict&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>修改版本构件号(必改)</li>\n</ol>\n"},{"title":"利用MJExtension取出模型数组中的某个属性组成数组","author":"Arclin","abbrlink":"8e2ebfdf","date":"2016-10-16T16:00:00.000Z","_content":"利用MJExtension取出模型数组中的某个属性组成数组\n\n<!-- more -->\n\n在做otg的时候想做这么一件事，就是遍历模型数组然后取出里面的属性值然后再保存到数组里，后来翻了翻MJExtension好像有类似的方法声明，试了一下果然可以\n\n```\nMJProperty *p = [[MJProperty alloc] init];\n[p setValue:@\"text\" forKey:@\"name\"]; \\\\ 因为name是readonly，所以我就只能用keyValue的方式去给他赋值了\nNSArray *arr = [p valueForObject:self.topics];\nNSLog(@\"%@\",arr);\n```\n\n如果包装一下大概就是这样子\n\n```\n- (NSArray *)fetchPropertys:(NSString *)propertyName fromObjects:(NSArray *)objects{\n\tMJProperty *p = [[MJProperty alloc] init];\n\t[p setValue:propertyName forKey:@\"name\"]; \n\treturn [p valueForObject:objects];\n}\n```\n\n弄个分类可能会比较方便吧\n\n```\n- (NSArray *)fetchPropertys:(NSString *)propertyName{\n\tMJProperty *p = [[MJProperty alloc] init];\n\t[p setValue:propertyName forKey:@\"name\"]; \n\treturn [p valueForObject:self];\n}\n```","source":"_posts/利用MJExtension取出模型数组中的某个属性组成数组.md","raw":"---\ntitle: 利用MJExtension取出模型数组中的某个属性组成数组\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 8e2ebfdf\ndate: 2016-10-17 00:00:00\n---\n利用MJExtension取出模型数组中的某个属性组成数组\n\n<!-- more -->\n\n在做otg的时候想做这么一件事，就是遍历模型数组然后取出里面的属性值然后再保存到数组里，后来翻了翻MJExtension好像有类似的方法声明，试了一下果然可以\n\n```\nMJProperty *p = [[MJProperty alloc] init];\n[p setValue:@\"text\" forKey:@\"name\"]; \\\\ 因为name是readonly，所以我就只能用keyValue的方式去给他赋值了\nNSArray *arr = [p valueForObject:self.topics];\nNSLog(@\"%@\",arr);\n```\n\n如果包装一下大概就是这样子\n\n```\n- (NSArray *)fetchPropertys:(NSString *)propertyName fromObjects:(NSArray *)objects{\n\tMJProperty *p = [[MJProperty alloc] init];\n\t[p setValue:propertyName forKey:@\"name\"]; \n\treturn [p valueForObject:objects];\n}\n```\n\n弄个分类可能会比较方便吧\n\n```\n- (NSArray *)fetchPropertys:(NSString *)propertyName{\n\tMJProperty *p = [[MJProperty alloc] init];\n\t[p setValue:propertyName forKey:@\"name\"]; \n\treturn [p valueForObject:self];\n}\n```","slug":"利用MJExtension取出模型数组中的某个属性组成数组","published":1,"updated":"2021-06-06T18:52:24.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoin006ctnn05io48e0z","content":"<p>利用MJExtension取出模型数组中的某个属性组成数组</p>\n<span id=\"more\"></span>\n\n<p>在做otg的时候想做这么一件事，就是遍历模型数组然后取出里面的属性值然后再保存到数组里，后来翻了翻MJExtension好像有类似的方法声明，试了一下果然可以</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MJProperty *p &#x3D; [[MJProperty alloc] init];</span><br><span class=\"line\">[p setValue:@&quot;text&quot; forKey:@&quot;name&quot;]; \\\\ 因为name是readonly，所以我就只能用keyValue的方式去给他赋值了</span><br><span class=\"line\">NSArray *arr &#x3D; [p valueForObject:self.topics];</span><br><span class=\"line\">NSLog(@&quot;%@&quot;,arr);</span><br></pre></td></tr></table></figure>\n\n<p>如果包装一下大概就是这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)fetchPropertys:(NSString *)propertyName fromObjects:(NSArray *)objects&#123;</span><br><span class=\"line\">\tMJProperty *p &#x3D; [[MJProperty alloc] init];</span><br><span class=\"line\">\t[p setValue:propertyName forKey:@&quot;name&quot;]; </span><br><span class=\"line\">\treturn [p valueForObject:objects];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>弄个分类可能会比较方便吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)fetchPropertys:(NSString *)propertyName&#123;</span><br><span class=\"line\">\tMJProperty *p &#x3D; [[MJProperty alloc] init];</span><br><span class=\"line\">\t[p setValue:propertyName forKey:@&quot;name&quot;]; </span><br><span class=\"line\">\treturn [p valueForObject:self];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>利用MJExtension取出模型数组中的某个属性组成数组</p>","more":"<p>在做otg的时候想做这么一件事，就是遍历模型数组然后取出里面的属性值然后再保存到数组里，后来翻了翻MJExtension好像有类似的方法声明，试了一下果然可以</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MJProperty *p &#x3D; [[MJProperty alloc] init];</span><br><span class=\"line\">[p setValue:@&quot;text&quot; forKey:@&quot;name&quot;]; \\\\ 因为name是readonly，所以我就只能用keyValue的方式去给他赋值了</span><br><span class=\"line\">NSArray *arr &#x3D; [p valueForObject:self.topics];</span><br><span class=\"line\">NSLog(@&quot;%@&quot;,arr);</span><br></pre></td></tr></table></figure>\n\n<p>如果包装一下大概就是这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)fetchPropertys:(NSString *)propertyName fromObjects:(NSArray *)objects&#123;</span><br><span class=\"line\">\tMJProperty *p &#x3D; [[MJProperty alloc] init];</span><br><span class=\"line\">\t[p setValue:propertyName forKey:@&quot;name&quot;]; </span><br><span class=\"line\">\treturn [p valueForObject:objects];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>弄个分类可能会比较方便吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)fetchPropertys:(NSString *)propertyName&#123;</span><br><span class=\"line\">\tMJProperty *p &#x3D; [[MJProperty alloc] init];</span><br><span class=\"line\">\t[p setValue:propertyName forKey:@&quot;name&quot;]; </span><br><span class=\"line\">\treturn [p valueForObject:self];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"如何开发/管理一个项目","author":"Arclin","abbrlink":"3c7b026b","date":"2019-10-20T07:20:00.000Z","_content":"如何管理一个项目，这是个沉重的话题。实际上，目前很多人都是凭借经验进行项目管理和开发，事实上管理项目是有着大量的方法论，这些方法论整理起来被人归纳成了一个学科，名字叫做`软件工程`，接下来的内容将会归纳总结里面的一些要点，如果你有意成为一个项目管理者，请必须了解一下这些基础知识。\n\n<!--more-->\n\n## 软件系统模型\n\n开始一个项目之前，你需要做好准备，那就是建立系统模型，有了抽象的模型，才会有具像的实现。\n - 在软件开发中，软件系统模型大体可分为两类：`概念模型`和`软件模型`。\n - 概念模型是创建在需求层上的，它描述了系统是什么。\n - 软件模型是建立在抽象层上的，它描述了实现概念模型的软件解决方案。\n - 软件模型可进一步分为`设计模型`、`实现模型`和`部署模型`。\n \n \n## 需求\n\n### 特征\n 一个完整的需求需要有以下特征：\n 1. 必要的：该需求是用户所要求的（产品经常会提一些伪需求，比如说在帖子列表添加个一键评价，点击了就回复666，但实际上没有用户想毫无感情地666，所以这是伪需求，不满足该条件的请拒绝）；\n 2. 无歧义的：该需求只能用一种方式解释（这个就不用解释了，遇到有歧义的需求请问清楚）；\n 3. 可测的：该需求可以进行测试；\n 4. 可跟踪的：该需求可以从一个开发阶段跟踪到另一个开发阶段（意思就是这个需求不会因为开发的进行变得模糊、不清晰）；\n 5. 可测量的：该需求是可测量的（意思就是实现这个需求不能无限耗费人力物力，说好这个需求两个人一天能做完，就两个人一天真的能做完）。\n \n### 类别\n\n 1. 功能需求：系统或系统构件必须执行的功能\n 2. 非功能需求：分为性能需求、外部接口需求、设计约束需求、质量属性需求。\n \n### 怎么发现需求\n\n  |名称|情况|成功条件|风险|\n  |:---:|:---:|:---:|:---:|\n  |自悟|自己想|要比你的最终客户拥有更多的一样弄领域和过程方面的知识和丰富的想象力，也就是你要比你的用户更加清楚用户要啥|无法验证你想出来的东西是不是你的用户想要的|\n  |交谈|跟你的客户聊|你能提出正确的问题，回答人能揭示需求本质的能力|可能会获得一堆需求，而且越来越多，不断增长，可能还会推翻你之前的需求，可能导致超出项目成本和进度的限制<s>（甚至可能被你的开发揍一顿）</s>|\n  |观察|你去看你的用户怎么用你的软件|你需要有洞察事物本质的能力|1. 你的用户会抵触你的观察（很明显侵犯隐私了）2. 用户会觉得你是不是这软件没做好或者哪里需求不到位所以老是来看我，对你的软件产生怀疑 |\n  |小组会|项目组的人全部叫出来开会讨论需求|你小组的人有不同观点，并且有良好的发现需求的能力，能揭示需求中存在的问题，最重要的是需求能跟用户达成共识|会议组织不到位就凉了，而且天天开会你的项目组的人也受不了，可能会提出矛盾需求|\n  |提炼|针对已有的部分需求文档，看线上反馈情况，进行提炼|你需要有想象力和需求标识能力，包括熟悉相关的技术标准|跟自悟一样，你不能知道你发现的需求是否是对的|\n \n### 需求规约\n\n需求规约就是怎么写一个需求表，因为形式很多，所以最好就根据实际情况进行，这里不做规定，但是必须包含以下几个特征\n1. 重要性和稳定性：需求要根据重要程度和稳定程度分优先级，例如：基本需求、可选需求和期望需求。\n2. 可修改的：在不过多地影响其他需求的情况下，可以容易地修改一个单一需求。\n3. 完整的：没有被遗漏的需求。\n4. 一致的：不存在互斥的需求。\n\n为什么需求规约很重要？（概念性东西）\n1. 是软件开发组织和用户之间一份事实上的技术合同书，是产品功能及其环境的体现。\n2. 对于项目的其余大多数工作，需求规约是一个管理控制点。\n3. 对于产品/系统的设计，需求规约是一个正式的、受控的起点。\n\n## 结构化方法\n\n### 结构化需求分析\n\n1. 为什么要这么做？\n\n\t为了应对三大挑战：\n\t\t- 问题空间理解。（假如让你开发一个八字排盘App，但是你又不懂八字，所以要开发出一个高质量、满足用户要求的App，就不容易了）\n\t\t- 人与人之间的通信。（开发过程长、活动多、任务重，项目组成员多，直接面对面沟通起来难免有遗漏、误解等，所以这也是一个挑战）\n\t\t- 需求的变化性。（需求是不断变化的，所以这是软件开发人员面临的挑战）\n\n\t一种好的需求技术应该具有以下基本特征：\n\n\t\t1. 提供方便通信的机子，例如，在不同开发阶段，使用对相关人员易于理解的语言。\n\t\t2. 鼓励需求分析人员使用问题空间的术语思考问题，编写文档。\n\t\t3. 提供定义系统边界的方法。\n\t\t4. 提供支持抽象的基本机制，例如，\"划分\"，\"功能抽象\"，\"结构抽象\"等。\n\t\t5. 为需求分析人员提供多种可供选择的方案。\n\t\t6. 提供特定的技术，适应需求的变化等。\n\n2. 几种基本术语的解释\n\n\t(1) 数据流：数据流是数据的流动，用于表达在分析中所要使用的、用于表达\"客体\"的信息，用箭头表示。\n\t大概长这样：\n\t<img width=50px src='https://i.loli.net/2019/10/21/wM2SkZXGDY46lQh.png'>\n\t(2) 加工：加工是数据变换的单元，即它接受输入的数据，对其进行处理，并产生输出。\n\t大概长这样\n\t<img width=50px src='https://i.loli.net/2019/10/21/mcfwVCaJI1Sn8kZ.png'>\n\t(3) 数据存储：数据存储是数据的静态结构。\n\t大概长这样(可以是横的或者竖的)\n\t<img width=50px src='https://i.loli.net/2019/10/21/xbXKc45RlYpnNB9.png'>\n\t(4) 数据源和数据潭: 数据源是数据流的起点，数据潭是数据流的归宿地。数据源和数据潭是系统之外的实体，可以是人、物或其他软件系统。\n\t大概长这样\n\t<img width=50px src='https://i.loli.net/2019/10/21/LiwWbnSAs7Pqzoh.png'>\n\n3. 数据流图\n\n\t把上面的元素组成起来就是数据流图了\n\t大概长这样\n\t<img width=70% src=\"https://i.loli.net/2019/10/21/wDdaFiLe9Ps6UzA.png\">\n\n\t几个要点：1）数据流起到连接其他实体的作用，实体可以是加工、数据存储、数据源和数据潭；2）加工之间可以有多个数据流，这些数据流之间可以没有任何关系，数据流图也不表明他们的先后次序；3）对于一个比较大的软件系统，往往需要采用多层次的数据流图。\n\t\n4. 建模过程\n\n\t1. 建立系统环境图，确立系统语境\n\t2. 自顶向下，逐步求精，建立系统的层次数据流图\n\t3. 定义数据字典。数据字典有3种基本结构表示：顺序结构，选择结构，重复结构。\n\t\t- 顺序结构是指数据A由数据B和数据C顺序构成的，并记为\"+\"。例如：学生成绩=姓名+性别+学号+科目+成绩，其中\"=\"号表达的是\"定义为\".\n\t\t- 选择结构是指由数据A是由数据B或数据C定义的，即数据B不可能同时是B和C，并记为“|”，例如：性别=男|女\n\t\t- 重复结构是指数据A是由多个重复出现的数据B构成的，并记为\"| |\"，例如：学生成绩表=|学生成绩|\n\t\t<img width=\"50%\" src=\"https://i.loli.net/2019/10/21/43hSWgZPmVirHfA.png\">\n\t4. 描述加工：该步的目标为依据系统的数据流图，给出其中每一加工的小说明。加工可以有3种表达工具。\n\t\t1. 结构化自然语言（自然语言描述）\n\t\t2. 判定表: 由条件类别，条件组合，操作，操作执行构成。举例如图<img width=50% src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D22%2C0%2C590%2C389%3Bc0%3Dbaike80%2C5%2C5%2C80%2C26/sign=d64b6fc508087bf469a30da9cfe16500/42166d224f4a20a48dfd6c499a529822730ed059.jpg\">\n\t\t3. 判定树。举例如图<img width=60%  src=\"https://i.loli.net/2019/10/21/COmGSet5I61lFsH.png\">\n\t\t\n5. 注意事项：\n\t1. 模型平衡问题\n\t2. 信息复杂性控制问题\n6. 需求验证\n\t验证需求规格说明书中的每一单一需求是否满足5个性质，即必要性、无歧义性、可测性、可跟踪性、可测量性；验证需求规格说明是否满足4个性质，即重要性和稳定程度、可修改性、完整性和一致性。在必要时还需要验证其他特性，如设计无关性。\n\t\n### 结构化设计\n\n#### 总体设计步骤\n\n结构化设计方法基于`自顶向下，功能分解`的基本原则，针对两种不同类型的数据流图，分别提出了变换设计和事务设计。其中，变换设计的目标是将变换型数据流图映射为模块结构图，而事务设计的目标是将事务型数据流图映射为模块结构图。\n\n1. 变换型数据流图和事务性和数据流图\n（1）变换型数据流图：具有比较明显的输入部分和变换部分之间的界面、变换部分和输出部分之间界面的数据流图，称为变换型数据流图；\n![](https://www.sytm.net/ueditor/net/upload/2013-12-31/bdae1434-8b79-4209-b818-2502c7ea3bee.png)\n（2）事务型数据流图：数据到达一个加工T，该加工T根据输入的值，在其后若干动作序列中选出一个来执行，这类数据流图成为事务型数据流图。\n![](https://www.sytm.net/ueditor/net/upload/2013-12-31/142b2c91-a9ad-4c6e-b075-ecd6a900ee63.png)\n\n2. 总体设计分为3个阶段。第一阶段为初始设计，在对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。第二阶段为精化设计，依据模块“高内聚低耦合”的原则精化初始的模块结构图，并设计其中的全局数据结构和每一模块的接口。第三阶段为复审阶段，对前两个阶段所得到的高层软件结构进行复审，必要时还可能需要对该软件结构做一些精化工作，这对软件的一些性质，特别是对软件质量的提高，将产生非常大的影响。\n\n3. 天天扯着嗓子喊高内聚低耦合，到底什么是内聚什么是耦合？\n\n\t- 耦合：耦合是指不同模块之间相互依赖程度的度量\n\t\t- 内容耦合：当一个模块直接修改或操作另一个模块的数据，\u001d或当一个模块直接修改或操作，另一个模块的数据或一个模块不通过正常入口转入到一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该尽量避免使用。\n\t\t- 公共耦合：两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。\n\t\t- 控制耦合：一个模块通过接口向另一个模块传递一个控制信号，接收信号的模块根据信号值进行适当的动作，这种耦合被成为控制耦合。\n\t\t- 标记耦合：若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。\n\t\t- 数据耦合：模块之间通过参数来传递数据，则称为数据耦合。数据耦合是最低的一种耦合形式。\n\t- 内聚：内聚是指一个模块内部各成分之间相互关联程度的度量\n\t\t- 偶然内聚：如果一个模块的各成分之间基本不存在任何关系，则称为偶然内聚\n\t\t- 逻辑内聚：几个逻辑上相关的功能被放在同一模块中，则称为逻辑内聚。\n\t\t- 时间内聚：如果一个模块完成的功能必须在同一时间内执行（例如，初始化系统或一组变量），但这些功能只是因为时间因素关联在一起，则称为时间内聚。\n\t\t- 过程内聚：如果一个模块内部的处理成分是相关的，而且这些处理必须以特定的次序执行，则称为过程内聚。\n\t\t- 通信内聚：如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚\n\t\t- 顺序内聚：如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚\n\t\t- 功能内聚：最理想的内聚是功能内聚，模块所有的成分对于完成单一的功能都是基本的。功能内聚的模块对完成其功能而言是充分必要的。\n\t\t\n\t- 启发式规则：无论是变换设计还是事务设计，都涉一个共同的问题，即“基于高内聚低耦合的原理，采用一些经验性的启发式规则，对初始的模块结构图进行精化，形成最终的模块结构图”。\n\t\n\t- 怎么做？\n\t\t1. 改进软件结构，提高模块独立性。\n\t\t2. 力求模块规模适中。\n\t\t3. 力求深度、宽度、扇出和扇入适中。深度：表示其控制的`层数`(不包括自身)；宽度：同一层次上模块总数的`最大值`；扇出：一个模块`直接`控制（调用）的下级模块数目；扇入：一个模块有多少个上级模块`直接`调用它。\n\t\t4. 尽力使模块的作用域在其控制域之内。作用域：受该模块内`一个判定`所影响的所有模块的集合；控制域：模块本身以及所有`直接或间接`从属于它的模块的集合。\n\t\t\n#### 详细设计步骤\n\n1. 结构化程序设计\n\t包含三种基本控制结构：顺序结构、选择结构、循环结构\n2. 详细设计工具\n\t1. 程序流程图\n\t\t<img width=20% src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945069712&di=74b11092aae0042569e80dc22ee83438&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F09%2F17%2F02%2F27798515%2F15.files%2Ffile0001.jpg\">\n\t\t缺点：不是一种逐步求精的工具，过早地考虑程序的流程，不去考虑程序的全局结构；所表达的控制流，往往不受任何约束可随意转移，从而会影响甚至破坏好的系统结构设计；不易表示数据结构。\n\t2. 盒图（N-S图）\n\t\t<img width=40% src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945228461&di=10908d6d12f9c8984356e884b3c0aeb5&imgtype=0&src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fzhidao%2Fwh%253D450%252C600%2Fsign%3Da401ed95523d26972e86005960cb9ecd%2Fd833c895d143ad4bd5fe969f81025aafa50f0698.jpg\">\n\t3. PAD图（Problem Analysis Diagram）\n\t\t<img width=\"40%\" src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945326054&di=d66d2f92c755db3f26640c2bbb6bc338&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F12%2F15%2F14%2F51872755%2F6.files%2Ffile0001.jpeg\">\n\t\n\tN-S图和PAD图支持“自顶向下逐步求精”的设计。可节省人工编码工作，有利于提高软件的可靠性和软件生产率\n\t\n\t4. 类程序设计语言（伪码/PDL）\n\t\t是一种用正文形式表示数据结构和处理过程的设计工具，PDL是一种“混合”的语言。\n3. 设计规约\n\t完成软件设计后，应产生设计规约，完整准确地描述满足系统需求规约所要求的的所有功能模块，以及伴随功能模块而出现的非功能机制。设计规约通常包括`概要设计规约`和`详细设计规约`。\n\t\n\t`概要设计规约`指明高层软件体系结构，其主要功能如下：\n\t\n\t1.系统环境等与设计有关的限定条件 2. 软件模块的结构（模块之间的接口及设计的数据流和主要数据结构）3. 模块描述（接口定义，模块处理逻辑，必要的注释等）4. 文件结构和全局数据文件的逻辑结构 5.测试需求\n\t\n\t`详细设计规约`（包括各处理过程的算法和算法所涉及的全部数据结构的描述）主要作为软件设计人员与程序员之间交流的媒体。\n\t\n## UML\n\n### UML是一种图形化建模语言（Unified Modeling Language）\n\n为了支持抽象分析和设计中的事物，UML给了八个基本术语，即类、接口、协作、用况、主动类、构件、制品、节点、\n- 类： 类是一组拥有相同属性、操作、关系和语义的对象的描述。类主要用于抽象客观世界中的事物。\n- 接口：每个操作描述了类、构件或子系统的一个服务，接口就是操作的一个集合。接口是对系统/产品的“接缝”予以模型化，表明了一个类、构件、子系统所需要得到的、且与实现无关的行为。\n- 用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的、可观察的结果。\n- 协作：协作是一个交互，涉及交互的三要素：交互各方、交互方式以及交互内容\n- 用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的，可观察的结果。\n- 主动类：主动类是一种至少具有一个进程或线程的类。\n- 构件：构件是系统设计中的一种模块化部件，通过外部接口隐藏了它的内部实现。\n- 制品：制品是系统中包含物理信息（比特）的、可替代的物理部件。\n- 节点：节点是运行时存在的物理元素，通常表示一种具有记忆能力和处理能力的计算机资源。\n\t\n类在建模中的主要用途：\n1. 模型化问题域中的概念\n2. 建立系统的职责分布模型\n3. 模型化建模中使用的基本类型\n\n使用接口应注意的问题\n1. 接口只可以被其他类目使用，而本身不能访问其他类目\n2. 接口描述类的外部可见操作，通常是该类的一个特有限定行为。这些操作可以使用可见性、并发性、衍型、标记值和约束来修饰。\n3. 接口不描述其中操作的实现，也没有属性和状态。据此可见，接口在形式上等价于一个没有属性、没有方法而只有抽象操作的抽象类\n4. 接口之间没有关联、泛化、实现和依赖。但可以参与泛化、实现和依赖\n\t\n### 表达关系的术语\n\n\t关联：关联是一组具有相同结构、相同链的描述，是类目之间的一种结构关系。关联可以用一条连接两个类目的线段表示，并可对其命名，其结构可以具有方向性，用一个实心三角形来指示关联的方向。\n\t\t1. 关联名 。\n\t\t2. 导航：对于一个给定的类目，可以找到与之关联的另一个类目，这称为导航。\n\t\t3. 角色：角色是关联一端的类目对另一端的类目的一种呈现。\n\t\t4. 可见性：通过导航可以找到另一类目的实例，有时候需要限制访问。\n\t\t5. 多重性：类中对象参与一个关联的数目，成为该关联的多重性\n\t\t6. 限定符：限定符是一个关联的属性或属性表。\n\t\t7. 聚合：分类是增强客观实际问题语义的一种手段。聚合是对象之间（不是类之间）的一种结构关系。\n\t\t8. 组合：组合是聚合的一种特殊形式\n\t泛化：泛化是一般性类目和它的较为特殊类目之间的一种关系。子类可以继承父类的属性和操作，同时也可以替换父类的声明。\n\t\t泛化的四种约束：完整、不完整、互斥、重叠\n\t细化：细化是类目之间的语义关系，其中一个类目规约保证了另一个类目执行的契约。\n\t依赖：依赖用于描述一个类目使用另一个类目的信息和服务，是一种使用关系。\n\t\t依赖的分类：绑定、导出、允许、示例、实例化、幂类型、精化、使用。\n\t\t\n\t关联、泛化和细化都是一类特地类型的依赖。\n\t\n\t使用这四种术语，可以模型化以下各种关系：\n\t1. 结构关系（静态结构和动态结构）\n\t\t进行模型化时两种驱动方式：1.以数据驱动 2. 以行为驱动\n\t2. 继承关系\n\t3. 精化关系\n\t4. 依赖关系\n\t\n### 表达组合信息的术语————包\n\n为了控制信息组织的复杂性，UML提供了组织信息的一种通用机制————包，支持形成一些可管理的部分。换言之，包可以作为“模块化”和“构件化”的一种机制。\n\n包是模型元素的一个分组。一个包本身可以被嵌套在其他包中，并且可以含有子包和其他种类的模型元素。\n\n通过在包的名字前加上一个可见性符号（+，-，#），来指示该包的可见性。\n\n```\n+ 表示对其他包而言都是可见的\n# 表示对子孙包而言是可见的\n- 表示对其他包而言都是不可见的\n```\n\n为了模型化包之间的关系，UML给出了两种依赖，即访问和引入。\n- 访问：表明目标包中的内容可以被源包所引用，或被那些递归嵌套在源包中的其他包所引用。\n- 引入：表明目标包中具有适当可见性的内容（名字）被加入到源包的公共命名空间中。\n\nUML中用虚线加箭头的方式表示源包到目标包的依赖（访问和引入）。\n\n### UML术语的作用\n\n1. 类用于抽象客观事物\n2. 接口用于抽象事物之间的缝隙\n3. 协作用于抽象协作性行为\n4. 用况用于抽象功能\n5. 主动类用于抽象并发行为\n6. 构件用于抽象软件解中标识的成分\n7. 制品用于抽象工作产品\n8. 节点用于抽象计算单元\n9. 关联用于抽象结构关系\n10. 泛化用于抽象“一般/特殊”关系\n11. 实现用于抽象精化关系\n12. 依赖用于抽象使用关系\n\n### UML的模型表达式\n\n1. 结构图和行为图\n\t结构图用于表达系统或系统成分的静态结构模型，给出系统或系统成分的一些说明性信息\n\t行为图用于表系统或系统成分的动态结构模型，给出系统或系统成分的一些行为信息\n2. 类图、用况图、顺序图及状态图\n\t- 类图是可视化地表达系统静态结构功能模型的工具，使用类图所表达的系统静态结构模型，给出的是一些关于系统的说明性信息。\n\t![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176025075&di=1875f9ac829f33a38a45131069ee3e4a&imgtype=0&src=http%3A%2F%2Fimages.cnblogs.com%2Fcnblogs_com%2Fa-i%2FUml2.JPG)\n\t- 用况图是一种表达系统功能模型的图形化工具，它包含六个模型元素，分别是主题、用况、参与者、关联、泛化、依赖\n\t![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176303343&di=4146dfc9badef7bc95f4c750ab149eb0&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F09%2F24%2F23%2F28839740%2F23.files%2Ffile0001.png)\n\t- 顺序图由一组对象以及按时序组织的对象之间的关系组成，是一种交互图，包含对象之间传递的信息。控制操作包括`选择执行操作`、`条件操作`、`并发迭代操作`、`迭代执行操作`。\n\t![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176439921&di=d592e65ae4a1bc1c2e65a98e415a897a&imgtype=0&src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fpng%2F20180615101636402475.png)\n\t- 状态图强调了从一个状态到另一个状态的控制流，是显示一个状态机的图。状态图由状态、事件和状态转移构成。使用状态图的作用有两个：一是创建一个系统的动态模型，二是创建一个场景的模型\n\t![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176576658&di=70e3de58666cf1d7315cf56a05ec0d35&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F12%2F07%2F08%2F48638362%2F25.files%2Ffile0001.png)\n\t-\n3. 创建一个系统的类图的步骤\n\t- 模型化代建系统中的概念，形成类图中的基本元素\n\t- 模型化代建系统中的各种关系，形成该系统的初始类图\n\t- 模型化系统中的协作，给出该系统的最终类图\n\t- 模型化逻辑数据库模式\n4. 信号事件、调用事件、时间事件和变化事件\n\t- 信号事件是一种异步事件，信号通常由状态机处理。如果没有定义对该事件的响应，那么事件均可能丢失。事件的丢失，就有可能引发接受者——状态机的一个错误的状态转移。\n5. 状态转移所涉及的内容\n\t描述一个状态转换，一般涉及五个部分：\n\t1. 源状态：发生状态转移的那个状态\n\t2. 转移触发器：在源状态中由对象识别的事件，并且一旦满足其监护条件，则使状态发生转移。\n\t3. 监护条件：一个布尔表达式，当某个事件触发器接受一个事件时，如果该表达式有值为真，则触发一个转移；若有值为假，则不发生状态转移。\n\t4. 效应：一种可执行的行为\n\t5. 目标状态：转移完成后所处的状态\n6. 最常用的控制操作子\n\t选择执行操作子：该操作子由两部分组成：一是监护条件，二是控制体\n\t条件执行操作子：控制体通过水平线将其分为一些部分，每一部分表示一个条件分支，每一分支有一个监护条件。\n\t并发执行操作子：该控制操作子的体通过水平线将其分为多个部分，每一部分表示一个并行计算。该控制操作子表明，当进入该控制操作子是，所有部分并发执行。\n\t迭代执行操作子：该控制操作子表明，只要在每一次迭代之前该监护条件为真，那么该控制体就反复执行，当该控制体上面的监护条件为假时，控制绕过该控制操作子。\n7. 子状态机、简单状态和组合状态的概念\n\t子状态机：为了有效地组织状态、控制对象状态的复杂性，UML提供了组合状态，在一个状态机中引入了另一个状态机。被引入的状态机就称为子状态机。\n\t简单状态：子状态是被嵌套到另一状态中的状态。相对地，被引入的状态机就称为子状态机。\n\t组合状态：把含子状态的状态称为组合状态，组合状态可包含两种类型的子状态机，即非正交（顺序）子状态机和正交（并发）子状态机。\n## RUP\n\n### RUP(Rational Unified Process)的特点\nRUP的突出特点是，它是一种以用况（Use Case）为驱动的、以体系结构为中心的迭代、增量式开发。\n1. 以用况为驱动\n以用况为驱动是指在系统的生存周期中，以用况作为基础，驱动系统有关人员对所要建立系统的功能需求进行交流，驱动系统分析、设计、实现和测试等活动。\n2. 以体系结构为中心\n以体系结构为中心是指在系统的生存周期中，开发的任何阶段都要给出相关模型视角下有关体系结构的描述，作为构思、构造、管理和改善系统的主要标准。\n3. 迭代、增量式开发\n迭代、增量式开发是指通过开发活动的迭代，不断地产生相应的增量。在RUP中，规定了四个开发阶段：初始阶段、精化阶段、构造阶段和移交阶段。\n\n### 核心工作流\n核心工作流：需求获取、分析、设计、实现和测试\n#### 需求获取\n\n|基本步骤|产生的制品|\n|:---:|:---:|\n|列出候选的特征|特征表|\n|理解系统语境|领域模型或业务模型|\n|捕获功能需求|用况模型|\n|捕获非功能需求|补充需求或针对特殊需求的用况|\n\n### 业务用况模型和业务对象模型\n\n1. 业务用况模型。业务用况模型是以用框图予以表达的\n2. 业务对象模型。为了精化业务用况模型中的每一个业务用况，RUP引入了三个术语，用于表达参与业务的业务对象：`工作人员`、`业务实体`和`工作单元`。业务对象模型可通过交互图和活动图予以表达。\n\n### 标识用况应注意的问题\n\n1. 建立用况的结构中，应尽可能反映用况的实际情况。\n2. 在用况的结构化中，不论是施加什么结构，新引入的用况都不应该太小或太大\n3. 在建立用况的结构是，应尽量避免对用况模型中的用况功能进行分解。\n\n#### 需求分析\n\n1. 分析类是类的一种衍型，分为边界类、实体类和控制类\n2. 用况细化时一个协作，针对一个用况，其行为可用多个分析类之间的相互作用来细化，并记为用况细化。用况细化对用况模型中的一个特定的用况提供了一种直接跟踪的方式。\n3. 分析包是一种控制信息组织复杂性的机制，提供了分析制品的一种组织手段。其主要特征为：体现问题的分离；高内聚、低耦合；尽可能体现一个系统的完整顶层设计，尽可能成为一些子系统或者成为一些子系统的组成部分。\n\t\n#### 具有良好结构的分析包的特征\n\n1. 体现问题分离\n2. 高内聚、低耦合。\n3. 尽可能提现一个系统的完整顶层设计。\n\n#### 软件设计层上的术语\n\n软件设计是满足需求规约所需要的软件结构。RUP为了满足系统/产品分析模型规约需求的软件结构，为设计层提供了是个术语：设计类、用况细化、设计子系统和接口，用于表达软件结构中的基本元素。\n\n1. 设计类：一个设计类是对系统中实现一个类或类似构造的一个无缝抽象\n2. 用况细化：用况细化是设计模型的一个协作，其中使用设计类及其对象，描述一个特定用况是如何予以细化的，是如何执行的\n3. 设计子系统：设计子系统可以包含设计类、用况细化、接口，以及其他子系统，通过对其操作来显示其功能。\n4. 接口：接口用于规约由设计类和设计子系统，必须提供与该接口操作对应的实现方法。\n\n#### 创建系统/产品用况模型的活动和任务\n\n创建系统/产品用况模型的活动和任务如下\n1. 活动一：发现并描述参与者\n任务1：发现参与者，即直接发现一些候选的参与者\n任务2：描述参与者，即对参与者进行命名并描述\n2. 活动二：发现用况并对用况进行描述\n任务1：发现用况\n任务2：描述用况，即确定用况后对其进行描述\n3. 活动三：确定用况的优先级，目的是在寻找参与者并对其进行描述和发现用况的并对用况进行描述的基础上确定哪些用况适合在早期的迭代中开发，哪些适合在后期的迭代中开发。\n4. 活动四：精化用况。这一活动的目的是详细描述出每一用况的事件流，包括用况是怎样开始的，是怎样结束的，是怎样与参与者进行交互的，最终形成一系列精化的用况\n5. 活动五：构造用户界面原型。这一活动的目的在于建造用户界面原型，使用户可以有效地执行用况。\n6. 活动六：用况模型的结构化。需要进行以下工作。\n\t1. 抽取用况描述中的那些一般性的和共享的功能并使用泛化关系标识和描述那些共享功能\n\t2. 抽取用况描述附加的或可选的功能\n\t3. 标识用况之间的包含关系。通过用况模型的结构化，最终形成一个系统/产品的精化用户模型\n\t\n#### 创建系统/产品需求分析模型的活动和任务\n1. 活动1：体系结构分析。该活动的目标是通过标识分析包和分析类，建立分析模型和体系结构“骨架”，并标识有关分析包和分析类的特定需求。\n任务1：标识分析包。该任务的基本输入是系统的用况模型\n任务2：处理分析包之间的共性\n任务3：标识服务包\n任务4：定义分析包的依赖，该任务的目标是发现相对独立的包，实现包的高内聚和低耦合\n任务5：标识重要的实体类，该任务的目标是标识在体系结构方面具有意义的实体类。\n任务6：标识分析包和重要实体类的公共特定需求，该任务的目标是依据需求获取阶段所标识的非功能需求，针对在分析期间所标识的包和分析类，标识它们的一些公共的特定要求。\n2. 活动2：用况分析。该活动的目标是：一是标识那些在用况事件流执行中所需要的分析类和对象；二是将用况的行为分布到参与交互的各个分析对象；三是捕获用况细化上的特定需求。\n任务1：标识分析类，该任务的目标是标识在细化一个用况中所需要实体类、控制类和边界类，给出它们的名字、责任、属性和关系。\n任务2：描述分析类对象之间的交互。首先确定细化该用况所必要的交互，其次分派该用况的功能，最后根据其责任，发现该交互图中的各个链。\n3. 活动3：类的分析。该活动的目标：一是标识并维护分析类的属性和关系；二是捕获分析类细化中的特殊需求。\n任务1：标识责任，通过组合一个类在不同用况细化中所扮演的角色来完成。\n任务2：标识属性\n任务3：标识关联和聚合\n4. 活动4：包的分析。该活的目标是：一是确保分析包尽可能与其他包相对独立；而是确保分析包实现了它的目标；三是描述依赖，以益于可以估计未来的变化。\n\n###  创建系统/产品设计模型的活动和任务\n创建系统/产品设计模型的活动和任务如下：\n1. 活动1：体系结构设计，该活动的目标是创建设计模型和部署模型，以及它们视角下的体系结构描述\n任务1：标识节点和它们的网络配置，网络配置通常使用一种三元模式：客户端、数据库功能、业务/应用逻辑\n任务2：标识子系统和它们的接口，目的是为了寻求一些复用的可能，而后随着设计模型的开发，在形成子系统结构中不断发现并烟花。\n任务3：标识在体系结构方面有意义的设计类和它们的接口。标识在体系结构方面有意义的设计类的基本思想是：初始可以依据在体系结构方面有意义的分析类来标识一些体系结构上具有重要意义的设计类。标识在系统体系结构方面有意义的设计类时，应注意主动类往往是一类在体系结构方面具有重要意义的类。\n2. 活动2：用况的设计。其中分析模型用况细化分析是活动的输入、对应输出用况细化设计。\n为了实现用况设计的输入/输出，一般采用两种方法：\n\t1. 标识参与用况细化的设计类，首先基于分析模型研究相应用况细化分析中的分析类，来标识为细化这些分类所需要的设计类，然后基于用况的功能对每一个标识的设计类赋予相应的责任，最后为该细化创建一个类图，汇聚参与该用况细化的设计类，并给出类之间的关系。\n\t2. 标识参与用况细化的子系统和接口。\n3. 活动3：类的设计。该活动的目标是完成用况细化设计中每一个类的角色设计，并完成有关每一类的非功能需求的设计。\n任务1：概括描述设计类，该任务的输入为分析类/接口。\n任务2：标识的操作，一般应依据分析类来标识设计类所提供的、所需要的操作，其中需要使用程序设计语言的语法来描述说标识的操作。\n任务3：标识属性，该任务的目标是标识设计类所需要的属性，并使用程序设计语言的语法给出属性的描述。\n任务4：标识关联和聚合。\n任务5：标识泛化，基于分析模型中分析类之间的泛化，可以发现设计模型中的很多泛化。\n任务6：描述方法，在设计期间一般用自然语言或适当的使用伪码对方法进行规约，但是在实现期间直接使用程序设计语言对方法进行规约。\n任务7：描述状态，有些设计对象是受状态控制的，即它们的状态确定了它们接受一个消息的行为。在这种情况下，使用一个状态图描述一个对象的不同状态转移是有意义的。\n4. 活动4：子系统的设计。该活动的目标是：确保子系统尽可能独立于其他子系统或它们的接口；确保子系统提供正确的接口；确保子系统实现了它的目标，即给出了该子系统提供的那些接口所定义的操作的细化。\n\n### 设计模型包含的元素\n\nRUP设计的主要结果是设计模型，它尽量保持该系统具有分析模型的结构，并作为系统实现的输入，包含以下四个元素：\n\n1. 设计子系统和服务子系统，以及它们的接口、依赖和内容。\n2. 设计类以及它们具有的操作、属性、关系及其实现的需求。\n3. 用况细化设计。\n4. 设计模型视角下的体系结构描述。\n\n### 用况模型与分析模型的比较\n\n|用况模型|分析模型|\n|:----:|:---:|\n|使用客户语言来描述 |使用开发者语言来描述 |\n|给出的是系统对外的视图 | 给出的是系统对内的视图 |\n|使用用况予以结构化，但给出的是外部视角下的系统结构 | 使用衍型类予以结构化，当给出的是内部视角下的系统结构 |\n|可以作为客户与开发者之间关于“系统应该做什么，不应该做什么”的契约 |可以作为开发者理解系统如何勾画、如何设计和如何实现的基础|\n|在需求之间可能存在一些冗余、不一致和冲突等问题|在需求之间不应存在冗余、不一致和冲突问题|\n|捕获的是系统的功能，包括在体系结构方面有意义的功能|给出的是细化的系统功能，包括在体系结构方面具有意义的功能|\n|定义了一些进一步需要在分析模型中予以分析的|定义了用况模型中每一个用况的细化|\n\n### RUP实现活动\n\n目标：基于设计类和子系统生成构件；对构件进行单元测试，进行集成和连接；把可执行的构件映射到部署模型。\n\n|输入|活动|执行者|输出|\n|:----:|:---:|:---:|:---:|\n|设计模型、部署模型、体系结构描述【设计模型、部署模型角度】|实现体系结构|体系结构设计者|构件【概述】、体系结构描述【实现模型、部署模型角度】|\n|补充需求、用况模型、设计模型、实现模型【当前建造】|集成系统|系统集成者|集成建造计划、实现模型【连续的建造】|\n|集成建造计划、体系结构描述【实现模型角度】、设计子系统【已设计】、接口【已设计】|实现子接口|构件工程师|实现子系统【建造完成】、接口【建造完成】|\n|设计类【已设计】、接口【由设计类提供】|实现类|构件工程师|构件【完成】|\n|构件【完成】、接口|完成单元测试|构件工程师|构件【已完成单元测试】|\n\n### RUP测试活动\n\nRUP的测试包括内部测试、中间测试和最终测试\n\n|输入|活动|输出|\n|:----:|:---:|:---:|\n|补充需求、用况模型、分析模型、设计模型、实现模型、体系结构的描述|计划测试|测试计划|\n|补充需求、用况模型、分析模型、设计模型、实现模型、体系结构描述、测试计划|设计测试|测试用况 测试过程|\n|测试用况、测试过程、实现模型|实现测试|测试构件|\n|测试用况、测试过程、测试构件、实现模型|执行集成测试|缺陷|\n|测试用况、测试过程、测试构件、实现模型|执行系统测试|缺陷|\n|测试用况、测试模型、缺陷|评价测试|测试评价|\n\n## 软件测试\n\n### 软件测试目标与软件测试过程模型\n\n#### 软件测试及目标\n\n软件测试的定义为：按照特定规程发现软件错误的过程。其目的是检验它是否满足规定的需求，或清楚了解预期结构与实际结果之间的差异\n\n#### 软件测试与软件调试之间的区别\n\n软件测试与软件调试相比，在目的、技术和方法等方面都存在很大区别，主要表现在以下几个方面。\n1. 测试从一个侧面证明程序员的\"失败\".调试是为了证明程序员的正确。\n2. 测试以已知条件开始，使用预先定义的程序且有预知的结果，不可预见的仅是程序是否通过。调试一般是以不可知的内部条件开始，除统计性调试外，结果是不可预见的。\n3. 测试是有计划的，并要进行测试设计。调试是不受时间约束的。\n4. 测试是一个发现错误、改正错误、重新测试的过程。调试是一个推理过程。\n5. 测试的执行是有规程的。调试的执行往往要求程序员进行必要推理。\n6. 测试经常是由独立的测试组在不了解软件设计的条件下完成的。调试必须由了解详细设计的程序员完成。\n7. 大多数测试的执行和设计可由工具支持。调试时，程序员能利用的主要工具是调试器。\n\n#### 测试过程模型\n\n软件测试是一个有程序的过程，包括测试设计、测试执行以及测试结果比较。测试过程模型可分为三类：环境模型、被测对象模型和错误模型。\n\n1. 环境模型：是对程序运行环境的抽象。程序运行环境又包括支持其运行的硬件、固件和软件，如计算机、终端设备、网卡、操作系统、编译系统、实用程序等。在软件测试过程中，建立环境模型的主要目的是，确定所发现的错误是否为环境造成的。\n2. 被测对象模型：该模型是从测试的角度对程序的抽象。为了测试，必须简化程序，形成被测程序的抽象版本、即对象模型。\n3. 错误模型：该模型是对程序中的错误及其分类的抽象。在软件测试中，往往需要定义“什么是错误”、“什么是一般性错误”、“什么是严重性错误”等，即要给出“错误模型”。\n\n### 软件测试技术\n\n1. 测试覆盖及其他们之间的基本关系\n软件测试技术大体上可分为两大类：一类是白盒测试技术，又称为结构测试技术，典型的是路径测试技术；另一种是黑盒测试技术，又称为功能测试技术，包括事务处理流程技术、状态测试技术、定义域测试技术等。白盒测试技术依据的是程序的逻辑结构，而黑盒测试技术依据的是软件行为的描述。\n2. 路径测试技术的分类\n\n\t测试覆盖包括路径覆盖、分支覆盖、条件覆盖与条件组合覆盖。\n\n\t1. 路径覆盖：执行所以有可能穿过程序控制流程的路径。在路径测试中，该度量是最强的，一般是不可实现的。\n\t2. 语句覆盖：至少执行程序中所有语句一次\n\t3. 分支覆盖：至少将程序中的每一个分支执行一次\n\t4. 条件覆盖与条件组合覆盖：条件覆盖是指每个判定中所有的可能的条件的取值至少执行一次；条件组合覆盖是指设计足够的测试用例，使每个判定中所有可能的条件取值组合至少执行一次。\n\t\n\t这四种测试覆盖的测试覆盖率由弱到强的顺序是：语句覆盖 < 分支覆盖 < 条件组合覆盖 < 路径覆盖\n\n3. 事务流测试步骤\n\n\t事务流测试步骤具体如下。\n\t第一步：获得事务流程图。\n\t第二步：浏览、复审。\n\t第三步：用例设计。\n\t第四步：测试执行。\n\t\n4. 运用等价类划分技术进行测试的步骤\n\n\t具体测试步骤如下。\n\t第一步：建立等价类表\n\t第二步：为有效等价类设计测试用例\n\t第三步：为无效等价类至少设计一个测试用例\n\t\n5. 边界值分析的使用原则\n\n\t边界值分析是一种常用的黑盒测试技术。使用边界值分析在设计测试用例时，可以遵循以下原则。\n\t\n\t1. 如果某个输入条件规定了输入值的范围，则应该选择正好等于边界值的数据，以及刚刚超过边界值的数据作为测试数据。\n\t2. 如果某个输入条件规定了值的个数，则可用最大个数、最小个数、比最大个数多1、比最小个数少1的数据作为测试数据\n\t3. 根据规格说明的每个输出条件，使用前面的原则1\n\t4. 根据规格说明的每个输出条件，使用前面的原则2\n\t5. 如果程序的规格说明中，输入域或输出域是有序集合，在实践中则经常选取集合的第一个元素、最后一个元素以及典型元素作为测试用例。\n\t6. 如果程序中使用了内部数据结构，则应该选择这个内部数据结构的边界上的值作为测试用例。\n\t7. 分析规格说明，找出其他可能的边界条件。\n\t\n6. 使用因果图生成测试用例的步骤\n\n\t因果图技术是通过为判定表的每一列设计一个测试用例，从而实现测试用例的设计与选择的。该方法生成测试用例的基本步骤如下。\n\n\t1. 通过软件规格说明书的分析，找出一个模块的原因和结果，并给每个原因和结果赋予一个标识符\n\t2. 分析原因与结果之间以及原因之间对应的关系，并画出因果图。\n\t3. 在因果图上标识出一些特定的约束或限制条件。\n\t4. 把因果图转换成判定表。\n\t5. 把判定表的每一列拿出来作为依据，设计测试用例。\n\t\n### 软件测试步骤\n\n1. 单元测试\n\t单元测试主要检验软件设计的最小单元---模块。该测试以详细设计文档为指导，测试模块内的重要控制路径。一般来说，单元测试往往采用白盒测试技术。\n\t\n2. 集成测试\n\t集成测试是软件组装的一个系统化技术，其目标是发现与接口有关的错误，将经过单元测的模块构成一个满足设计要求的软件结构。集成测试集中于模块组合的功能和软件结构检验。集成测试可“自顶向下”地进行，称为自顶向下的集成测试；也可以“自底向上”地进行测试，称为自底向上的集成测试\n\n3. 有效性测试\n\t有效性测试的目标是发现软件实现的功能与需求规格说明书不一致的错误。因此有效性测试通常采用黑盒测试技术。\n\t\n4. 系统测试\n\t系统测试验证将软件融于更大系统中时整个系统的有效性。\n\n## 软件生存周期过程与管理\n\n### 软件生存周期过程概述\n\n1. 过程分类\n\n\t按过程主体把软件生存周期过程分为以下几个过程。\n\t1. 基本过程：是指那些与软件生产直接相关的活动集。该过程又可分为获取过程、供应过程、开发过程、运行过程和维护过程。\n\t2. 支持过程：是指有关各方按他们的目标所从事的一系列相关支持活动集。该过程又可分为文档过程、配置管理过程、质量保证过程、验证过程、确认过程、联合评审过程、审计过程和问题解决过程。\n\t3. 组织过程：是指那些与软件生产组织有关的活动集。该过程又可分为设计过程、基础设施过程、培训过程和改进过程。\n\t\n2. 系统语境的过程类\n\t系统语境的过程类包含四个过程组，分别是协议过程组、项目过程组、技术过程组和组织上项目使能过程组。\n\t1. 协议过程组包含两个过程：获取过程和供应过程。\n\t2. 项目过程组包含七个过程：项目规划过程、项目评价过程、决策管理过程、风险管理过程、配置管理过程、信息管理过程和测量过程。\n\t3. 技术过程组包含11个过程：利益攸关方需求定义过程、系统需求分析过程、系统体系结构设计过程、实现过程、系统集成过程、系统测试过程、软件安装过程、软件接受支持过程、软件运行过程、软件维护过程和软件销毁过程。\n\t4. 组织上使能过程组包含五个过程：生存周期模型管理过程、基础设施管理过程、项目包管理过程、人力资源管理过程和质量管理过程。\n\t\n3. 组织上使能过程的作用。\n\t组织上使能的过程一般来说是组织层面上的工作，为项目的执行提供基本保障。该过程包含五个子过程。\n\t1. 生存周期模型管理过程：其任务为过程建立、过程评估、过程改进。\n\t2. 基础设施管理过程：其任务为过程实现、基础设施的建立、基础设施的维护。\n\t3. 项目包管理过程：项目初始化、项目包评估、项目结束处理。\n\t4. 人力资源管理过程：其任务为技能标识、技能开发、技能获取和供给、知识管理。\n\t5. 质量管理过程：其任务为质量管理、质量管理纠正措施。\n\n### 过程描述\n\n软件验证过程包括两个活动：过程实现和验证。其中验证活动有五个任务：需求验证、设计验证、代码验证，集成验证和文档验证。\n\n一个过程可通过过程意图，期望的结果以及到达过程结果需要执行的活动和任务来描述。对于一个过程的完整技术上的描述，还应包括：达到过程意图和实现过程结果的方法或规程，以及过程和活动文档。\n\n### 应用说明\n\n1. 系统和软件的关系\n\n\t在《ISO/IEC系统与软件工程-软件生产周期过程12207-2008》标准中，把软件认为是整个系统的一个组成从部分，执行系统中所确定的功能主要包括三大功能：控制功能、耦合功能以及软件本身提供的功能。由于软件通常存在与一个系统的上下文中，因此软件产品或服务一般可被认为是系统的一个项或称为系统元素。\n\t\n2. 剪裁过程及应用\n\n\t剪裁过程是使剪裁这一标准过程慢速以下特定情况或因素。\n\t1. 围绕一个组织，其中该组织在一个协议中使用了这一标准\n\t2. 影响一个项目，其中要求该项目满足一个引用该标准的协议\n\t3. 反映一个组织的需要，其中该组织要供给产品或服务\n\t\n### 软件生存周期模型\n\n1. 瀑布模型\n\n\t瀑布模型是将软件生存周期各个活动规定为按固定顺序链接的若干阶段的模型。这一模型规定了个开发阶段的活动：系统需求、软件需求、需求分析、设计、编码、测试和运行，并且自上而下具有相互衔接的固定顺序；还规定了每一个阶段的输入，即工作对象以及本阶段的工作成果，作为输出传送到下一阶段。\n\n\t瀑布模型的提出，对软件工程的主要贡献如下。\n\t1. 在决定系统怎样做之前存在一个需求阶段，它鼓励对系统做什么进行规约。\n\t2. 在系统构造之前存在一个需求阶段，它鼓励规划系统结构。\n\t3. 在每一阶段结束时进行评审，从而允许获取方和用户的参与。\n\t4. 前一步可以作为下一步被认可的、文档化的基线，并允许基线和配置早期接受控制。\n\n\t瀑布模型的主要问题是：\n\n\t1. 要求客户能完整、正确和清晰地表达他们的需求；并要求开发人员一开始就要理解这一应用。\n\t2. 由于需求的不稳定性，使设计、编码和测试阶段都可能发生延期；并且当项目接近结束时，出现了大量的集成和测试工作。\n\t3. 在开始的阶段中，很难评估真正的进度状态；并且直到项目结束之前都不能演示系统的能力。\n\t4. 在一个项目的早期开发阶段，过分地强调了基线和里程碑处的文档；并可能需要花费更多的时间用于建立一些用处不大的文档。\n\t\n2. 增量模型\n\n\t增量模型是一种非整体开发的模型。软件在该模型中逐渐开发出来，开发出一部分，向用户展示一部分，可让用户及早看到部分软件，及早发现问题。该模型具有较大的灵活性，适合软件需求不明确、设计方案有一定风险的软件项目。\n\n3. 演化模型\n\n\t该模型主要针对事先不能完整定义需求的软件开发在用户提出待开发系统的核心需求的基础上，软件开发人员按照这一要求，首先开发一个核心系统并投入运行，以便用户能够有效地提出反馈，即精化系统、增强系统能力的需求；接着，软件开发人员根据用户反馈，实施开发的迭代过程；每一迭代过程均由需求、设计、编码、测试、集成等阶段组成，为整个系统增加一个可定义的，可管理的子集；如果在一次迭代中，有的需求不能满足用户的要求，可在下一次迭代中予以修正。\n\n\t主要特征：该模型显式地把需求获取扩展到需求阶段，既为了第二个构造增量，使用了第一个构造增量来精化需求。演化模型在一定程度上可以减少软件开发活动的盲目性。\n不足之处：在演化模型的使用中，即使很好地理解了需求或设计，也很容易弱化需求分析阶段的工作。\n\n4. 螺旋模型\n\n\t螺旋模型将瀑布模型与增量模型结合起来，加入了两种模型均忽略了的风险分析，弥补了这两种模型的不足。因而它是一种风险驱动的模型。螺旋模型将开放过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合。\n\n\t螺旋模型关注解决问题的基本步骤，即标识问题，标识一些可选方案，选择一个最佳方案，遵循动作步骤并实施后续工作。其一个突出特征是，在开发的迭代中实际上只有一个迭代过程真正开发了可交付的软件。螺旋模型与演化模型和增量模型相比，同样适用了瀑布模型作为一个嵌入的过程，但螺旋模型所关注的阶段以及它们的活动是不同的。如果项目的开发风险很大或客户不能确定系统需求，在更广泛的意义上来讲，还包括一个系统或系统类型的要求，这时螺旋模型就是一个很好的生存周期模型。\n\n5. 喷泉模型\n\n\t喷泉模型体现了软件创建所固有的迭代和无间隙的特征。该模型主要用于支持面向对象技术的软件开发。由于对象概念的引入，使分析、设计、实现之间的表达没有明显间隙。\n\n### 过程规划与管理\n\n1. 创建一个软件项目生存周期过程的步骤\n\n\t1. 选择软件生存周期模型\n\t2. 细化所选择的生存周期模型\n\t3. 为每一个活动或任务标识合适的实例数目\n\t4. 确定活动的时序关系，并检查信息流\n\t5. 建立过程计划的文档\n\t\n2. 软件评估中应考虑的影响因素\n\n\t1. 不管做怎么样的决策，都必须对所采取的的措施对生存周期过程所产生的影响进行评审，以便保证项目获得好的结果。在这一评估中，应考虑以下几方面的影响。\n\t\t1. 所要求的的“返工”\n\t\t2. 资源需求\n\t\t3. 实施时间\n\t\t4. 对项目和用户的益处\n\t\t5. 员工情绪\n\n## 集成化能力成熟度模型（CMMI）\n\n### 背景和原理\n\n1. 过程改善\n\n\t历史过程改善，是指人为设计的一个活动程序，其目的是改进组织的过程性能和成熟度，并改进这一程序的结果\n\n2. 过程域、专用目标和共用目标\n\n\t过程域是一个业务域中一束相关的实践，当它们一起得以实现时，就满足被认为对该过程域的改善具有重要作用的一组条件\n\t专用目标是用于描述满足该过程域必须呈现的一些独有特征。经可以用于帮助确定一个过程域是否得以满足。\n\t共用目标用于描述产现制度化的该过程必须呈现的特征，仅用于确定一个过程域是否得以满足。\n\n### CMMI的模型部件\n\n|过程域类名|包括的过程域|\n|:---:|:---|\n|项目管理类|项目规划<br/>项目监控<br/>定量项目管理<br/>集成项目管理<br/>风险管理<br/>提供方协议管理|\n|工程类|需求开发<br/>需求管理<br/>技术解决方案<br/>产品集成<br/>确认<br/>验证|\n|支持类|配置管理<br/>过程和产品质量保证<br/>测量与分析<br/>原因分析与解决<br/>决策分析与解决|\n|过程管理类|组织过程定义<br/>组织过程性能<br/>组织过程培训<br/>组织过程关注<br/>组织创新与部署|\n\n### CMMI的等级\n\n1. 能力等级的组成\n\n\t能力等级是用来表征组织对一个过程域的改善，是不断改善一个给定过程域的一种手段。在CMMI中，针对每个过程域设定了6个能力等级，即0级：未完成级；1级：已执行级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：待续优化级。\n\t\n2. 成熟度等级的组成\n\t\n\t在CMMI中，应用于一个组织过程改善的成熟度等级有5个。即1级：初始级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：持续优化级\n\t\n3. 能力等级与成熟度等级之间的基本关系\n\n\t1. 能力等级与成熟度等级是互补的关系，两者都是一种过程改善路径，即表征组织对单一过程域的改进。\n\t2. 成熟度等级的路径可使组织针对单一过程域不断改善一组相关过程域，即表征组织对一组过程域的改进。\n\t3. 两种等级的2-5级使用了同样的名字\n\t\n4. 达到各共用目标要实施的共同实践\n\n\t达到公用目标2、共用目标3、共用目标4和共用目标5所要实施的共同实践如下表所示\n\t\n||所要实施的共用实践|\n|:---:|:---:|\n|共用目标2：把过程制度化为一个管理过程|GP2.1 建立组织策略<br/>GP2.2 规划过程<br/>GP2.3 提供资源<br/>GP2.4 指派责任<br/>GP2.5 培训人员<br/>GP2.6 管理配置<br/>GP2.7 标识相关利益方的参与<br/>GP2.8 监控过程<br/>GP2.9 客观地评估符合性<br/>GP2.10 从高层管理的视觉评审状态<br/>|\n|共用目标3：把过程制度化为一个已定义过程|GP3.1 建立一个已定义的过程<br/>GP3.2 收信进信息 所要实施的共用实践|\n|共用目标4：把过程制度化为一个已定量管理过程|GP4.1 为该过程建立定量目的<br/>GP4.2 使子过程性能达到稳定|\n|共用目标5：把过程制度化为一个持续优化过程|GP5.1 确保不断进行过程改善<br/>GP5.2 收集问题的根本原因|\n\n完结\n","source":"_posts/如何开发-管理一个项目.md","raw":"title: 如何开发/管理一个项目\nauthor: Arclin\nabbrlink: 3c7b026b\ntags: []\ncategories:\n  - 杂谈\ndate: 2019-10-20 15:20:00\n---\n如何管理一个项目，这是个沉重的话题。实际上，目前很多人都是凭借经验进行项目管理和开发，事实上管理项目是有着大量的方法论，这些方法论整理起来被人归纳成了一个学科，名字叫做`软件工程`，接下来的内容将会归纳总结里面的一些要点，如果你有意成为一个项目管理者，请必须了解一下这些基础知识。\n\n<!--more-->\n\n## 软件系统模型\n\n开始一个项目之前，你需要做好准备，那就是建立系统模型，有了抽象的模型，才会有具像的实现。\n - 在软件开发中，软件系统模型大体可分为两类：`概念模型`和`软件模型`。\n - 概念模型是创建在需求层上的，它描述了系统是什么。\n - 软件模型是建立在抽象层上的，它描述了实现概念模型的软件解决方案。\n - 软件模型可进一步分为`设计模型`、`实现模型`和`部署模型`。\n \n \n## 需求\n\n### 特征\n 一个完整的需求需要有以下特征：\n 1. 必要的：该需求是用户所要求的（产品经常会提一些伪需求，比如说在帖子列表添加个一键评价，点击了就回复666，但实际上没有用户想毫无感情地666，所以这是伪需求，不满足该条件的请拒绝）；\n 2. 无歧义的：该需求只能用一种方式解释（这个就不用解释了，遇到有歧义的需求请问清楚）；\n 3. 可测的：该需求可以进行测试；\n 4. 可跟踪的：该需求可以从一个开发阶段跟踪到另一个开发阶段（意思就是这个需求不会因为开发的进行变得模糊、不清晰）；\n 5. 可测量的：该需求是可测量的（意思就是实现这个需求不能无限耗费人力物力，说好这个需求两个人一天能做完，就两个人一天真的能做完）。\n \n### 类别\n\n 1. 功能需求：系统或系统构件必须执行的功能\n 2. 非功能需求：分为性能需求、外部接口需求、设计约束需求、质量属性需求。\n \n### 怎么发现需求\n\n  |名称|情况|成功条件|风险|\n  |:---:|:---:|:---:|:---:|\n  |自悟|自己想|要比你的最终客户拥有更多的一样弄领域和过程方面的知识和丰富的想象力，也就是你要比你的用户更加清楚用户要啥|无法验证你想出来的东西是不是你的用户想要的|\n  |交谈|跟你的客户聊|你能提出正确的问题，回答人能揭示需求本质的能力|可能会获得一堆需求，而且越来越多，不断增长，可能还会推翻你之前的需求，可能导致超出项目成本和进度的限制<s>（甚至可能被你的开发揍一顿）</s>|\n  |观察|你去看你的用户怎么用你的软件|你需要有洞察事物本质的能力|1. 你的用户会抵触你的观察（很明显侵犯隐私了）2. 用户会觉得你是不是这软件没做好或者哪里需求不到位所以老是来看我，对你的软件产生怀疑 |\n  |小组会|项目组的人全部叫出来开会讨论需求|你小组的人有不同观点，并且有良好的发现需求的能力，能揭示需求中存在的问题，最重要的是需求能跟用户达成共识|会议组织不到位就凉了，而且天天开会你的项目组的人也受不了，可能会提出矛盾需求|\n  |提炼|针对已有的部分需求文档，看线上反馈情况，进行提炼|你需要有想象力和需求标识能力，包括熟悉相关的技术标准|跟自悟一样，你不能知道你发现的需求是否是对的|\n \n### 需求规约\n\n需求规约就是怎么写一个需求表，因为形式很多，所以最好就根据实际情况进行，这里不做规定，但是必须包含以下几个特征\n1. 重要性和稳定性：需求要根据重要程度和稳定程度分优先级，例如：基本需求、可选需求和期望需求。\n2. 可修改的：在不过多地影响其他需求的情况下，可以容易地修改一个单一需求。\n3. 完整的：没有被遗漏的需求。\n4. 一致的：不存在互斥的需求。\n\n为什么需求规约很重要？（概念性东西）\n1. 是软件开发组织和用户之间一份事实上的技术合同书，是产品功能及其环境的体现。\n2. 对于项目的其余大多数工作，需求规约是一个管理控制点。\n3. 对于产品/系统的设计，需求规约是一个正式的、受控的起点。\n\n## 结构化方法\n\n### 结构化需求分析\n\n1. 为什么要这么做？\n\n\t为了应对三大挑战：\n\t\t- 问题空间理解。（假如让你开发一个八字排盘App，但是你又不懂八字，所以要开发出一个高质量、满足用户要求的App，就不容易了）\n\t\t- 人与人之间的通信。（开发过程长、活动多、任务重，项目组成员多，直接面对面沟通起来难免有遗漏、误解等，所以这也是一个挑战）\n\t\t- 需求的变化性。（需求是不断变化的，所以这是软件开发人员面临的挑战）\n\n\t一种好的需求技术应该具有以下基本特征：\n\n\t\t1. 提供方便通信的机子，例如，在不同开发阶段，使用对相关人员易于理解的语言。\n\t\t2. 鼓励需求分析人员使用问题空间的术语思考问题，编写文档。\n\t\t3. 提供定义系统边界的方法。\n\t\t4. 提供支持抽象的基本机制，例如，\"划分\"，\"功能抽象\"，\"结构抽象\"等。\n\t\t5. 为需求分析人员提供多种可供选择的方案。\n\t\t6. 提供特定的技术，适应需求的变化等。\n\n2. 几种基本术语的解释\n\n\t(1) 数据流：数据流是数据的流动，用于表达在分析中所要使用的、用于表达\"客体\"的信息，用箭头表示。\n\t大概长这样：\n\t<img width=50px src='https://i.loli.net/2019/10/21/wM2SkZXGDY46lQh.png'>\n\t(2) 加工：加工是数据变换的单元，即它接受输入的数据，对其进行处理，并产生输出。\n\t大概长这样\n\t<img width=50px src='https://i.loli.net/2019/10/21/mcfwVCaJI1Sn8kZ.png'>\n\t(3) 数据存储：数据存储是数据的静态结构。\n\t大概长这样(可以是横的或者竖的)\n\t<img width=50px src='https://i.loli.net/2019/10/21/xbXKc45RlYpnNB9.png'>\n\t(4) 数据源和数据潭: 数据源是数据流的起点，数据潭是数据流的归宿地。数据源和数据潭是系统之外的实体，可以是人、物或其他软件系统。\n\t大概长这样\n\t<img width=50px src='https://i.loli.net/2019/10/21/LiwWbnSAs7Pqzoh.png'>\n\n3. 数据流图\n\n\t把上面的元素组成起来就是数据流图了\n\t大概长这样\n\t<img width=70% src=\"https://i.loli.net/2019/10/21/wDdaFiLe9Ps6UzA.png\">\n\n\t几个要点：1）数据流起到连接其他实体的作用，实体可以是加工、数据存储、数据源和数据潭；2）加工之间可以有多个数据流，这些数据流之间可以没有任何关系，数据流图也不表明他们的先后次序；3）对于一个比较大的软件系统，往往需要采用多层次的数据流图。\n\t\n4. 建模过程\n\n\t1. 建立系统环境图，确立系统语境\n\t2. 自顶向下，逐步求精，建立系统的层次数据流图\n\t3. 定义数据字典。数据字典有3种基本结构表示：顺序结构，选择结构，重复结构。\n\t\t- 顺序结构是指数据A由数据B和数据C顺序构成的，并记为\"+\"。例如：学生成绩=姓名+性别+学号+科目+成绩，其中\"=\"号表达的是\"定义为\".\n\t\t- 选择结构是指由数据A是由数据B或数据C定义的，即数据B不可能同时是B和C，并记为“|”，例如：性别=男|女\n\t\t- 重复结构是指数据A是由多个重复出现的数据B构成的，并记为\"| |\"，例如：学生成绩表=|学生成绩|\n\t\t<img width=\"50%\" src=\"https://i.loli.net/2019/10/21/43hSWgZPmVirHfA.png\">\n\t4. 描述加工：该步的目标为依据系统的数据流图，给出其中每一加工的小说明。加工可以有3种表达工具。\n\t\t1. 结构化自然语言（自然语言描述）\n\t\t2. 判定表: 由条件类别，条件组合，操作，操作执行构成。举例如图<img width=50% src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D22%2C0%2C590%2C389%3Bc0%3Dbaike80%2C5%2C5%2C80%2C26/sign=d64b6fc508087bf469a30da9cfe16500/42166d224f4a20a48dfd6c499a529822730ed059.jpg\">\n\t\t3. 判定树。举例如图<img width=60%  src=\"https://i.loli.net/2019/10/21/COmGSet5I61lFsH.png\">\n\t\t\n5. 注意事项：\n\t1. 模型平衡问题\n\t2. 信息复杂性控制问题\n6. 需求验证\n\t验证需求规格说明书中的每一单一需求是否满足5个性质，即必要性、无歧义性、可测性、可跟踪性、可测量性；验证需求规格说明是否满足4个性质，即重要性和稳定程度、可修改性、完整性和一致性。在必要时还需要验证其他特性，如设计无关性。\n\t\n### 结构化设计\n\n#### 总体设计步骤\n\n结构化设计方法基于`自顶向下，功能分解`的基本原则，针对两种不同类型的数据流图，分别提出了变换设计和事务设计。其中，变换设计的目标是将变换型数据流图映射为模块结构图，而事务设计的目标是将事务型数据流图映射为模块结构图。\n\n1. 变换型数据流图和事务性和数据流图\n（1）变换型数据流图：具有比较明显的输入部分和变换部分之间的界面、变换部分和输出部分之间界面的数据流图，称为变换型数据流图；\n![](https://www.sytm.net/ueditor/net/upload/2013-12-31/bdae1434-8b79-4209-b818-2502c7ea3bee.png)\n（2）事务型数据流图：数据到达一个加工T，该加工T根据输入的值，在其后若干动作序列中选出一个来执行，这类数据流图成为事务型数据流图。\n![](https://www.sytm.net/ueditor/net/upload/2013-12-31/142b2c91-a9ad-4c6e-b075-ecd6a900ee63.png)\n\n2. 总体设计分为3个阶段。第一阶段为初始设计，在对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。第二阶段为精化设计，依据模块“高内聚低耦合”的原则精化初始的模块结构图，并设计其中的全局数据结构和每一模块的接口。第三阶段为复审阶段，对前两个阶段所得到的高层软件结构进行复审，必要时还可能需要对该软件结构做一些精化工作，这对软件的一些性质，特别是对软件质量的提高，将产生非常大的影响。\n\n3. 天天扯着嗓子喊高内聚低耦合，到底什么是内聚什么是耦合？\n\n\t- 耦合：耦合是指不同模块之间相互依赖程度的度量\n\t\t- 内容耦合：当一个模块直接修改或操作另一个模块的数据，\u001d或当一个模块直接修改或操作，另一个模块的数据或一个模块不通过正常入口转入到一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该尽量避免使用。\n\t\t- 公共耦合：两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。\n\t\t- 控制耦合：一个模块通过接口向另一个模块传递一个控制信号，接收信号的模块根据信号值进行适当的动作，这种耦合被成为控制耦合。\n\t\t- 标记耦合：若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。\n\t\t- 数据耦合：模块之间通过参数来传递数据，则称为数据耦合。数据耦合是最低的一种耦合形式。\n\t- 内聚：内聚是指一个模块内部各成分之间相互关联程度的度量\n\t\t- 偶然内聚：如果一个模块的各成分之间基本不存在任何关系，则称为偶然内聚\n\t\t- 逻辑内聚：几个逻辑上相关的功能被放在同一模块中，则称为逻辑内聚。\n\t\t- 时间内聚：如果一个模块完成的功能必须在同一时间内执行（例如，初始化系统或一组变量），但这些功能只是因为时间因素关联在一起，则称为时间内聚。\n\t\t- 过程内聚：如果一个模块内部的处理成分是相关的，而且这些处理必须以特定的次序执行，则称为过程内聚。\n\t\t- 通信内聚：如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚\n\t\t- 顺序内聚：如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚\n\t\t- 功能内聚：最理想的内聚是功能内聚，模块所有的成分对于完成单一的功能都是基本的。功能内聚的模块对完成其功能而言是充分必要的。\n\t\t\n\t- 启发式规则：无论是变换设计还是事务设计，都涉一个共同的问题，即“基于高内聚低耦合的原理，采用一些经验性的启发式规则，对初始的模块结构图进行精化，形成最终的模块结构图”。\n\t\n\t- 怎么做？\n\t\t1. 改进软件结构，提高模块独立性。\n\t\t2. 力求模块规模适中。\n\t\t3. 力求深度、宽度、扇出和扇入适中。深度：表示其控制的`层数`(不包括自身)；宽度：同一层次上模块总数的`最大值`；扇出：一个模块`直接`控制（调用）的下级模块数目；扇入：一个模块有多少个上级模块`直接`调用它。\n\t\t4. 尽力使模块的作用域在其控制域之内。作用域：受该模块内`一个判定`所影响的所有模块的集合；控制域：模块本身以及所有`直接或间接`从属于它的模块的集合。\n\t\t\n#### 详细设计步骤\n\n1. 结构化程序设计\n\t包含三种基本控制结构：顺序结构、选择结构、循环结构\n2. 详细设计工具\n\t1. 程序流程图\n\t\t<img width=20% src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945069712&di=74b11092aae0042569e80dc22ee83438&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F09%2F17%2F02%2F27798515%2F15.files%2Ffile0001.jpg\">\n\t\t缺点：不是一种逐步求精的工具，过早地考虑程序的流程，不去考虑程序的全局结构；所表达的控制流，往往不受任何约束可随意转移，从而会影响甚至破坏好的系统结构设计；不易表示数据结构。\n\t2. 盒图（N-S图）\n\t\t<img width=40% src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945228461&di=10908d6d12f9c8984356e884b3c0aeb5&imgtype=0&src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fzhidao%2Fwh%253D450%252C600%2Fsign%3Da401ed95523d26972e86005960cb9ecd%2Fd833c895d143ad4bd5fe969f81025aafa50f0698.jpg\">\n\t3. PAD图（Problem Analysis Diagram）\n\t\t<img width=\"40%\" src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945326054&di=d66d2f92c755db3f26640c2bbb6bc338&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F12%2F15%2F14%2F51872755%2F6.files%2Ffile0001.jpeg\">\n\t\n\tN-S图和PAD图支持“自顶向下逐步求精”的设计。可节省人工编码工作，有利于提高软件的可靠性和软件生产率\n\t\n\t4. 类程序设计语言（伪码/PDL）\n\t\t是一种用正文形式表示数据结构和处理过程的设计工具，PDL是一种“混合”的语言。\n3. 设计规约\n\t完成软件设计后，应产生设计规约，完整准确地描述满足系统需求规约所要求的的所有功能模块，以及伴随功能模块而出现的非功能机制。设计规约通常包括`概要设计规约`和`详细设计规约`。\n\t\n\t`概要设计规约`指明高层软件体系结构，其主要功能如下：\n\t\n\t1.系统环境等与设计有关的限定条件 2. 软件模块的结构（模块之间的接口及设计的数据流和主要数据结构）3. 模块描述（接口定义，模块处理逻辑，必要的注释等）4. 文件结构和全局数据文件的逻辑结构 5.测试需求\n\t\n\t`详细设计规约`（包括各处理过程的算法和算法所涉及的全部数据结构的描述）主要作为软件设计人员与程序员之间交流的媒体。\n\t\n## UML\n\n### UML是一种图形化建模语言（Unified Modeling Language）\n\n为了支持抽象分析和设计中的事物，UML给了八个基本术语，即类、接口、协作、用况、主动类、构件、制品、节点、\n- 类： 类是一组拥有相同属性、操作、关系和语义的对象的描述。类主要用于抽象客观世界中的事物。\n- 接口：每个操作描述了类、构件或子系统的一个服务，接口就是操作的一个集合。接口是对系统/产品的“接缝”予以模型化，表明了一个类、构件、子系统所需要得到的、且与实现无关的行为。\n- 用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的、可观察的结果。\n- 协作：协作是一个交互，涉及交互的三要素：交互各方、交互方式以及交互内容\n- 用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的，可观察的结果。\n- 主动类：主动类是一种至少具有一个进程或线程的类。\n- 构件：构件是系统设计中的一种模块化部件，通过外部接口隐藏了它的内部实现。\n- 制品：制品是系统中包含物理信息（比特）的、可替代的物理部件。\n- 节点：节点是运行时存在的物理元素，通常表示一种具有记忆能力和处理能力的计算机资源。\n\t\n类在建模中的主要用途：\n1. 模型化问题域中的概念\n2. 建立系统的职责分布模型\n3. 模型化建模中使用的基本类型\n\n使用接口应注意的问题\n1. 接口只可以被其他类目使用，而本身不能访问其他类目\n2. 接口描述类的外部可见操作，通常是该类的一个特有限定行为。这些操作可以使用可见性、并发性、衍型、标记值和约束来修饰。\n3. 接口不描述其中操作的实现，也没有属性和状态。据此可见，接口在形式上等价于一个没有属性、没有方法而只有抽象操作的抽象类\n4. 接口之间没有关联、泛化、实现和依赖。但可以参与泛化、实现和依赖\n\t\n### 表达关系的术语\n\n\t关联：关联是一组具有相同结构、相同链的描述，是类目之间的一种结构关系。关联可以用一条连接两个类目的线段表示，并可对其命名，其结构可以具有方向性，用一个实心三角形来指示关联的方向。\n\t\t1. 关联名 。\n\t\t2. 导航：对于一个给定的类目，可以找到与之关联的另一个类目，这称为导航。\n\t\t3. 角色：角色是关联一端的类目对另一端的类目的一种呈现。\n\t\t4. 可见性：通过导航可以找到另一类目的实例，有时候需要限制访问。\n\t\t5. 多重性：类中对象参与一个关联的数目，成为该关联的多重性\n\t\t6. 限定符：限定符是一个关联的属性或属性表。\n\t\t7. 聚合：分类是增强客观实际问题语义的一种手段。聚合是对象之间（不是类之间）的一种结构关系。\n\t\t8. 组合：组合是聚合的一种特殊形式\n\t泛化：泛化是一般性类目和它的较为特殊类目之间的一种关系。子类可以继承父类的属性和操作，同时也可以替换父类的声明。\n\t\t泛化的四种约束：完整、不完整、互斥、重叠\n\t细化：细化是类目之间的语义关系，其中一个类目规约保证了另一个类目执行的契约。\n\t依赖：依赖用于描述一个类目使用另一个类目的信息和服务，是一种使用关系。\n\t\t依赖的分类：绑定、导出、允许、示例、实例化、幂类型、精化、使用。\n\t\t\n\t关联、泛化和细化都是一类特地类型的依赖。\n\t\n\t使用这四种术语，可以模型化以下各种关系：\n\t1. 结构关系（静态结构和动态结构）\n\t\t进行模型化时两种驱动方式：1.以数据驱动 2. 以行为驱动\n\t2. 继承关系\n\t3. 精化关系\n\t4. 依赖关系\n\t\n### 表达组合信息的术语————包\n\n为了控制信息组织的复杂性，UML提供了组织信息的一种通用机制————包，支持形成一些可管理的部分。换言之，包可以作为“模块化”和“构件化”的一种机制。\n\n包是模型元素的一个分组。一个包本身可以被嵌套在其他包中，并且可以含有子包和其他种类的模型元素。\n\n通过在包的名字前加上一个可见性符号（+，-，#），来指示该包的可见性。\n\n```\n+ 表示对其他包而言都是可见的\n# 表示对子孙包而言是可见的\n- 表示对其他包而言都是不可见的\n```\n\n为了模型化包之间的关系，UML给出了两种依赖，即访问和引入。\n- 访问：表明目标包中的内容可以被源包所引用，或被那些递归嵌套在源包中的其他包所引用。\n- 引入：表明目标包中具有适当可见性的内容（名字）被加入到源包的公共命名空间中。\n\nUML中用虚线加箭头的方式表示源包到目标包的依赖（访问和引入）。\n\n### UML术语的作用\n\n1. 类用于抽象客观事物\n2. 接口用于抽象事物之间的缝隙\n3. 协作用于抽象协作性行为\n4. 用况用于抽象功能\n5. 主动类用于抽象并发行为\n6. 构件用于抽象软件解中标识的成分\n7. 制品用于抽象工作产品\n8. 节点用于抽象计算单元\n9. 关联用于抽象结构关系\n10. 泛化用于抽象“一般/特殊”关系\n11. 实现用于抽象精化关系\n12. 依赖用于抽象使用关系\n\n### UML的模型表达式\n\n1. 结构图和行为图\n\t结构图用于表达系统或系统成分的静态结构模型，给出系统或系统成分的一些说明性信息\n\t行为图用于表系统或系统成分的动态结构模型，给出系统或系统成分的一些行为信息\n2. 类图、用况图、顺序图及状态图\n\t- 类图是可视化地表达系统静态结构功能模型的工具，使用类图所表达的系统静态结构模型，给出的是一些关于系统的说明性信息。\n\t![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176025075&di=1875f9ac829f33a38a45131069ee3e4a&imgtype=0&src=http%3A%2F%2Fimages.cnblogs.com%2Fcnblogs_com%2Fa-i%2FUml2.JPG)\n\t- 用况图是一种表达系统功能模型的图形化工具，它包含六个模型元素，分别是主题、用况、参与者、关联、泛化、依赖\n\t![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176303343&di=4146dfc9badef7bc95f4c750ab149eb0&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F09%2F24%2F23%2F28839740%2F23.files%2Ffile0001.png)\n\t- 顺序图由一组对象以及按时序组织的对象之间的关系组成，是一种交互图，包含对象之间传递的信息。控制操作包括`选择执行操作`、`条件操作`、`并发迭代操作`、`迭代执行操作`。\n\t![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176439921&di=d592e65ae4a1bc1c2e65a98e415a897a&imgtype=0&src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fpng%2F20180615101636402475.png)\n\t- 状态图强调了从一个状态到另一个状态的控制流，是显示一个状态机的图。状态图由状态、事件和状态转移构成。使用状态图的作用有两个：一是创建一个系统的动态模型，二是创建一个场景的模型\n\t![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176576658&di=70e3de58666cf1d7315cf56a05ec0d35&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F12%2F07%2F08%2F48638362%2F25.files%2Ffile0001.png)\n\t-\n3. 创建一个系统的类图的步骤\n\t- 模型化代建系统中的概念，形成类图中的基本元素\n\t- 模型化代建系统中的各种关系，形成该系统的初始类图\n\t- 模型化系统中的协作，给出该系统的最终类图\n\t- 模型化逻辑数据库模式\n4. 信号事件、调用事件、时间事件和变化事件\n\t- 信号事件是一种异步事件，信号通常由状态机处理。如果没有定义对该事件的响应，那么事件均可能丢失。事件的丢失，就有可能引发接受者——状态机的一个错误的状态转移。\n5. 状态转移所涉及的内容\n\t描述一个状态转换，一般涉及五个部分：\n\t1. 源状态：发生状态转移的那个状态\n\t2. 转移触发器：在源状态中由对象识别的事件，并且一旦满足其监护条件，则使状态发生转移。\n\t3. 监护条件：一个布尔表达式，当某个事件触发器接受一个事件时，如果该表达式有值为真，则触发一个转移；若有值为假，则不发生状态转移。\n\t4. 效应：一种可执行的行为\n\t5. 目标状态：转移完成后所处的状态\n6. 最常用的控制操作子\n\t选择执行操作子：该操作子由两部分组成：一是监护条件，二是控制体\n\t条件执行操作子：控制体通过水平线将其分为一些部分，每一部分表示一个条件分支，每一分支有一个监护条件。\n\t并发执行操作子：该控制操作子的体通过水平线将其分为多个部分，每一部分表示一个并行计算。该控制操作子表明，当进入该控制操作子是，所有部分并发执行。\n\t迭代执行操作子：该控制操作子表明，只要在每一次迭代之前该监护条件为真，那么该控制体就反复执行，当该控制体上面的监护条件为假时，控制绕过该控制操作子。\n7. 子状态机、简单状态和组合状态的概念\n\t子状态机：为了有效地组织状态、控制对象状态的复杂性，UML提供了组合状态，在一个状态机中引入了另一个状态机。被引入的状态机就称为子状态机。\n\t简单状态：子状态是被嵌套到另一状态中的状态。相对地，被引入的状态机就称为子状态机。\n\t组合状态：把含子状态的状态称为组合状态，组合状态可包含两种类型的子状态机，即非正交（顺序）子状态机和正交（并发）子状态机。\n## RUP\n\n### RUP(Rational Unified Process)的特点\nRUP的突出特点是，它是一种以用况（Use Case）为驱动的、以体系结构为中心的迭代、增量式开发。\n1. 以用况为驱动\n以用况为驱动是指在系统的生存周期中，以用况作为基础，驱动系统有关人员对所要建立系统的功能需求进行交流，驱动系统分析、设计、实现和测试等活动。\n2. 以体系结构为中心\n以体系结构为中心是指在系统的生存周期中，开发的任何阶段都要给出相关模型视角下有关体系结构的描述，作为构思、构造、管理和改善系统的主要标准。\n3. 迭代、增量式开发\n迭代、增量式开发是指通过开发活动的迭代，不断地产生相应的增量。在RUP中，规定了四个开发阶段：初始阶段、精化阶段、构造阶段和移交阶段。\n\n### 核心工作流\n核心工作流：需求获取、分析、设计、实现和测试\n#### 需求获取\n\n|基本步骤|产生的制品|\n|:---:|:---:|\n|列出候选的特征|特征表|\n|理解系统语境|领域模型或业务模型|\n|捕获功能需求|用况模型|\n|捕获非功能需求|补充需求或针对特殊需求的用况|\n\n### 业务用况模型和业务对象模型\n\n1. 业务用况模型。业务用况模型是以用框图予以表达的\n2. 业务对象模型。为了精化业务用况模型中的每一个业务用况，RUP引入了三个术语，用于表达参与业务的业务对象：`工作人员`、`业务实体`和`工作单元`。业务对象模型可通过交互图和活动图予以表达。\n\n### 标识用况应注意的问题\n\n1. 建立用况的结构中，应尽可能反映用况的实际情况。\n2. 在用况的结构化中，不论是施加什么结构，新引入的用况都不应该太小或太大\n3. 在建立用况的结构是，应尽量避免对用况模型中的用况功能进行分解。\n\n#### 需求分析\n\n1. 分析类是类的一种衍型，分为边界类、实体类和控制类\n2. 用况细化时一个协作，针对一个用况，其行为可用多个分析类之间的相互作用来细化，并记为用况细化。用况细化对用况模型中的一个特定的用况提供了一种直接跟踪的方式。\n3. 分析包是一种控制信息组织复杂性的机制，提供了分析制品的一种组织手段。其主要特征为：体现问题的分离；高内聚、低耦合；尽可能体现一个系统的完整顶层设计，尽可能成为一些子系统或者成为一些子系统的组成部分。\n\t\n#### 具有良好结构的分析包的特征\n\n1. 体现问题分离\n2. 高内聚、低耦合。\n3. 尽可能提现一个系统的完整顶层设计。\n\n#### 软件设计层上的术语\n\n软件设计是满足需求规约所需要的软件结构。RUP为了满足系统/产品分析模型规约需求的软件结构，为设计层提供了是个术语：设计类、用况细化、设计子系统和接口，用于表达软件结构中的基本元素。\n\n1. 设计类：一个设计类是对系统中实现一个类或类似构造的一个无缝抽象\n2. 用况细化：用况细化是设计模型的一个协作，其中使用设计类及其对象，描述一个特定用况是如何予以细化的，是如何执行的\n3. 设计子系统：设计子系统可以包含设计类、用况细化、接口，以及其他子系统，通过对其操作来显示其功能。\n4. 接口：接口用于规约由设计类和设计子系统，必须提供与该接口操作对应的实现方法。\n\n#### 创建系统/产品用况模型的活动和任务\n\n创建系统/产品用况模型的活动和任务如下\n1. 活动一：发现并描述参与者\n任务1：发现参与者，即直接发现一些候选的参与者\n任务2：描述参与者，即对参与者进行命名并描述\n2. 活动二：发现用况并对用况进行描述\n任务1：发现用况\n任务2：描述用况，即确定用况后对其进行描述\n3. 活动三：确定用况的优先级，目的是在寻找参与者并对其进行描述和发现用况的并对用况进行描述的基础上确定哪些用况适合在早期的迭代中开发，哪些适合在后期的迭代中开发。\n4. 活动四：精化用况。这一活动的目的是详细描述出每一用况的事件流，包括用况是怎样开始的，是怎样结束的，是怎样与参与者进行交互的，最终形成一系列精化的用况\n5. 活动五：构造用户界面原型。这一活动的目的在于建造用户界面原型，使用户可以有效地执行用况。\n6. 活动六：用况模型的结构化。需要进行以下工作。\n\t1. 抽取用况描述中的那些一般性的和共享的功能并使用泛化关系标识和描述那些共享功能\n\t2. 抽取用况描述附加的或可选的功能\n\t3. 标识用况之间的包含关系。通过用况模型的结构化，最终形成一个系统/产品的精化用户模型\n\t\n#### 创建系统/产品需求分析模型的活动和任务\n1. 活动1：体系结构分析。该活动的目标是通过标识分析包和分析类，建立分析模型和体系结构“骨架”，并标识有关分析包和分析类的特定需求。\n任务1：标识分析包。该任务的基本输入是系统的用况模型\n任务2：处理分析包之间的共性\n任务3：标识服务包\n任务4：定义分析包的依赖，该任务的目标是发现相对独立的包，实现包的高内聚和低耦合\n任务5：标识重要的实体类，该任务的目标是标识在体系结构方面具有意义的实体类。\n任务6：标识分析包和重要实体类的公共特定需求，该任务的目标是依据需求获取阶段所标识的非功能需求，针对在分析期间所标识的包和分析类，标识它们的一些公共的特定要求。\n2. 活动2：用况分析。该活动的目标是：一是标识那些在用况事件流执行中所需要的分析类和对象；二是将用况的行为分布到参与交互的各个分析对象；三是捕获用况细化上的特定需求。\n任务1：标识分析类，该任务的目标是标识在细化一个用况中所需要实体类、控制类和边界类，给出它们的名字、责任、属性和关系。\n任务2：描述分析类对象之间的交互。首先确定细化该用况所必要的交互，其次分派该用况的功能，最后根据其责任，发现该交互图中的各个链。\n3. 活动3：类的分析。该活动的目标：一是标识并维护分析类的属性和关系；二是捕获分析类细化中的特殊需求。\n任务1：标识责任，通过组合一个类在不同用况细化中所扮演的角色来完成。\n任务2：标识属性\n任务3：标识关联和聚合\n4. 活动4：包的分析。该活的目标是：一是确保分析包尽可能与其他包相对独立；而是确保分析包实现了它的目标；三是描述依赖，以益于可以估计未来的变化。\n\n###  创建系统/产品设计模型的活动和任务\n创建系统/产品设计模型的活动和任务如下：\n1. 活动1：体系结构设计，该活动的目标是创建设计模型和部署模型，以及它们视角下的体系结构描述\n任务1：标识节点和它们的网络配置，网络配置通常使用一种三元模式：客户端、数据库功能、业务/应用逻辑\n任务2：标识子系统和它们的接口，目的是为了寻求一些复用的可能，而后随着设计模型的开发，在形成子系统结构中不断发现并烟花。\n任务3：标识在体系结构方面有意义的设计类和它们的接口。标识在体系结构方面有意义的设计类的基本思想是：初始可以依据在体系结构方面有意义的分析类来标识一些体系结构上具有重要意义的设计类。标识在系统体系结构方面有意义的设计类时，应注意主动类往往是一类在体系结构方面具有重要意义的类。\n2. 活动2：用况的设计。其中分析模型用况细化分析是活动的输入、对应输出用况细化设计。\n为了实现用况设计的输入/输出，一般采用两种方法：\n\t1. 标识参与用况细化的设计类，首先基于分析模型研究相应用况细化分析中的分析类，来标识为细化这些分类所需要的设计类，然后基于用况的功能对每一个标识的设计类赋予相应的责任，最后为该细化创建一个类图，汇聚参与该用况细化的设计类，并给出类之间的关系。\n\t2. 标识参与用况细化的子系统和接口。\n3. 活动3：类的设计。该活动的目标是完成用况细化设计中每一个类的角色设计，并完成有关每一类的非功能需求的设计。\n任务1：概括描述设计类，该任务的输入为分析类/接口。\n任务2：标识的操作，一般应依据分析类来标识设计类所提供的、所需要的操作，其中需要使用程序设计语言的语法来描述说标识的操作。\n任务3：标识属性，该任务的目标是标识设计类所需要的属性，并使用程序设计语言的语法给出属性的描述。\n任务4：标识关联和聚合。\n任务5：标识泛化，基于分析模型中分析类之间的泛化，可以发现设计模型中的很多泛化。\n任务6：描述方法，在设计期间一般用自然语言或适当的使用伪码对方法进行规约，但是在实现期间直接使用程序设计语言对方法进行规约。\n任务7：描述状态，有些设计对象是受状态控制的，即它们的状态确定了它们接受一个消息的行为。在这种情况下，使用一个状态图描述一个对象的不同状态转移是有意义的。\n4. 活动4：子系统的设计。该活动的目标是：确保子系统尽可能独立于其他子系统或它们的接口；确保子系统提供正确的接口；确保子系统实现了它的目标，即给出了该子系统提供的那些接口所定义的操作的细化。\n\n### 设计模型包含的元素\n\nRUP设计的主要结果是设计模型，它尽量保持该系统具有分析模型的结构，并作为系统实现的输入，包含以下四个元素：\n\n1. 设计子系统和服务子系统，以及它们的接口、依赖和内容。\n2. 设计类以及它们具有的操作、属性、关系及其实现的需求。\n3. 用况细化设计。\n4. 设计模型视角下的体系结构描述。\n\n### 用况模型与分析模型的比较\n\n|用况模型|分析模型|\n|:----:|:---:|\n|使用客户语言来描述 |使用开发者语言来描述 |\n|给出的是系统对外的视图 | 给出的是系统对内的视图 |\n|使用用况予以结构化，但给出的是外部视角下的系统结构 | 使用衍型类予以结构化，当给出的是内部视角下的系统结构 |\n|可以作为客户与开发者之间关于“系统应该做什么，不应该做什么”的契约 |可以作为开发者理解系统如何勾画、如何设计和如何实现的基础|\n|在需求之间可能存在一些冗余、不一致和冲突等问题|在需求之间不应存在冗余、不一致和冲突问题|\n|捕获的是系统的功能，包括在体系结构方面有意义的功能|给出的是细化的系统功能，包括在体系结构方面具有意义的功能|\n|定义了一些进一步需要在分析模型中予以分析的|定义了用况模型中每一个用况的细化|\n\n### RUP实现活动\n\n目标：基于设计类和子系统生成构件；对构件进行单元测试，进行集成和连接；把可执行的构件映射到部署模型。\n\n|输入|活动|执行者|输出|\n|:----:|:---:|:---:|:---:|\n|设计模型、部署模型、体系结构描述【设计模型、部署模型角度】|实现体系结构|体系结构设计者|构件【概述】、体系结构描述【实现模型、部署模型角度】|\n|补充需求、用况模型、设计模型、实现模型【当前建造】|集成系统|系统集成者|集成建造计划、实现模型【连续的建造】|\n|集成建造计划、体系结构描述【实现模型角度】、设计子系统【已设计】、接口【已设计】|实现子接口|构件工程师|实现子系统【建造完成】、接口【建造完成】|\n|设计类【已设计】、接口【由设计类提供】|实现类|构件工程师|构件【完成】|\n|构件【完成】、接口|完成单元测试|构件工程师|构件【已完成单元测试】|\n\n### RUP测试活动\n\nRUP的测试包括内部测试、中间测试和最终测试\n\n|输入|活动|输出|\n|:----:|:---:|:---:|\n|补充需求、用况模型、分析模型、设计模型、实现模型、体系结构的描述|计划测试|测试计划|\n|补充需求、用况模型、分析模型、设计模型、实现模型、体系结构描述、测试计划|设计测试|测试用况 测试过程|\n|测试用况、测试过程、实现模型|实现测试|测试构件|\n|测试用况、测试过程、测试构件、实现模型|执行集成测试|缺陷|\n|测试用况、测试过程、测试构件、实现模型|执行系统测试|缺陷|\n|测试用况、测试模型、缺陷|评价测试|测试评价|\n\n## 软件测试\n\n### 软件测试目标与软件测试过程模型\n\n#### 软件测试及目标\n\n软件测试的定义为：按照特定规程发现软件错误的过程。其目的是检验它是否满足规定的需求，或清楚了解预期结构与实际结果之间的差异\n\n#### 软件测试与软件调试之间的区别\n\n软件测试与软件调试相比，在目的、技术和方法等方面都存在很大区别，主要表现在以下几个方面。\n1. 测试从一个侧面证明程序员的\"失败\".调试是为了证明程序员的正确。\n2. 测试以已知条件开始，使用预先定义的程序且有预知的结果，不可预见的仅是程序是否通过。调试一般是以不可知的内部条件开始，除统计性调试外，结果是不可预见的。\n3. 测试是有计划的，并要进行测试设计。调试是不受时间约束的。\n4. 测试是一个发现错误、改正错误、重新测试的过程。调试是一个推理过程。\n5. 测试的执行是有规程的。调试的执行往往要求程序员进行必要推理。\n6. 测试经常是由独立的测试组在不了解软件设计的条件下完成的。调试必须由了解详细设计的程序员完成。\n7. 大多数测试的执行和设计可由工具支持。调试时，程序员能利用的主要工具是调试器。\n\n#### 测试过程模型\n\n软件测试是一个有程序的过程，包括测试设计、测试执行以及测试结果比较。测试过程模型可分为三类：环境模型、被测对象模型和错误模型。\n\n1. 环境模型：是对程序运行环境的抽象。程序运行环境又包括支持其运行的硬件、固件和软件，如计算机、终端设备、网卡、操作系统、编译系统、实用程序等。在软件测试过程中，建立环境模型的主要目的是，确定所发现的错误是否为环境造成的。\n2. 被测对象模型：该模型是从测试的角度对程序的抽象。为了测试，必须简化程序，形成被测程序的抽象版本、即对象模型。\n3. 错误模型：该模型是对程序中的错误及其分类的抽象。在软件测试中，往往需要定义“什么是错误”、“什么是一般性错误”、“什么是严重性错误”等，即要给出“错误模型”。\n\n### 软件测试技术\n\n1. 测试覆盖及其他们之间的基本关系\n软件测试技术大体上可分为两大类：一类是白盒测试技术，又称为结构测试技术，典型的是路径测试技术；另一种是黑盒测试技术，又称为功能测试技术，包括事务处理流程技术、状态测试技术、定义域测试技术等。白盒测试技术依据的是程序的逻辑结构，而黑盒测试技术依据的是软件行为的描述。\n2. 路径测试技术的分类\n\n\t测试覆盖包括路径覆盖、分支覆盖、条件覆盖与条件组合覆盖。\n\n\t1. 路径覆盖：执行所以有可能穿过程序控制流程的路径。在路径测试中，该度量是最强的，一般是不可实现的。\n\t2. 语句覆盖：至少执行程序中所有语句一次\n\t3. 分支覆盖：至少将程序中的每一个分支执行一次\n\t4. 条件覆盖与条件组合覆盖：条件覆盖是指每个判定中所有的可能的条件的取值至少执行一次；条件组合覆盖是指设计足够的测试用例，使每个判定中所有可能的条件取值组合至少执行一次。\n\t\n\t这四种测试覆盖的测试覆盖率由弱到强的顺序是：语句覆盖 < 分支覆盖 < 条件组合覆盖 < 路径覆盖\n\n3. 事务流测试步骤\n\n\t事务流测试步骤具体如下。\n\t第一步：获得事务流程图。\n\t第二步：浏览、复审。\n\t第三步：用例设计。\n\t第四步：测试执行。\n\t\n4. 运用等价类划分技术进行测试的步骤\n\n\t具体测试步骤如下。\n\t第一步：建立等价类表\n\t第二步：为有效等价类设计测试用例\n\t第三步：为无效等价类至少设计一个测试用例\n\t\n5. 边界值分析的使用原则\n\n\t边界值分析是一种常用的黑盒测试技术。使用边界值分析在设计测试用例时，可以遵循以下原则。\n\t\n\t1. 如果某个输入条件规定了输入值的范围，则应该选择正好等于边界值的数据，以及刚刚超过边界值的数据作为测试数据。\n\t2. 如果某个输入条件规定了值的个数，则可用最大个数、最小个数、比最大个数多1、比最小个数少1的数据作为测试数据\n\t3. 根据规格说明的每个输出条件，使用前面的原则1\n\t4. 根据规格说明的每个输出条件，使用前面的原则2\n\t5. 如果程序的规格说明中，输入域或输出域是有序集合，在实践中则经常选取集合的第一个元素、最后一个元素以及典型元素作为测试用例。\n\t6. 如果程序中使用了内部数据结构，则应该选择这个内部数据结构的边界上的值作为测试用例。\n\t7. 分析规格说明，找出其他可能的边界条件。\n\t\n6. 使用因果图生成测试用例的步骤\n\n\t因果图技术是通过为判定表的每一列设计一个测试用例，从而实现测试用例的设计与选择的。该方法生成测试用例的基本步骤如下。\n\n\t1. 通过软件规格说明书的分析，找出一个模块的原因和结果，并给每个原因和结果赋予一个标识符\n\t2. 分析原因与结果之间以及原因之间对应的关系，并画出因果图。\n\t3. 在因果图上标识出一些特定的约束或限制条件。\n\t4. 把因果图转换成判定表。\n\t5. 把判定表的每一列拿出来作为依据，设计测试用例。\n\t\n### 软件测试步骤\n\n1. 单元测试\n\t单元测试主要检验软件设计的最小单元---模块。该测试以详细设计文档为指导，测试模块内的重要控制路径。一般来说，单元测试往往采用白盒测试技术。\n\t\n2. 集成测试\n\t集成测试是软件组装的一个系统化技术，其目标是发现与接口有关的错误，将经过单元测的模块构成一个满足设计要求的软件结构。集成测试集中于模块组合的功能和软件结构检验。集成测试可“自顶向下”地进行，称为自顶向下的集成测试；也可以“自底向上”地进行测试，称为自底向上的集成测试\n\n3. 有效性测试\n\t有效性测试的目标是发现软件实现的功能与需求规格说明书不一致的错误。因此有效性测试通常采用黑盒测试技术。\n\t\n4. 系统测试\n\t系统测试验证将软件融于更大系统中时整个系统的有效性。\n\n## 软件生存周期过程与管理\n\n### 软件生存周期过程概述\n\n1. 过程分类\n\n\t按过程主体把软件生存周期过程分为以下几个过程。\n\t1. 基本过程：是指那些与软件生产直接相关的活动集。该过程又可分为获取过程、供应过程、开发过程、运行过程和维护过程。\n\t2. 支持过程：是指有关各方按他们的目标所从事的一系列相关支持活动集。该过程又可分为文档过程、配置管理过程、质量保证过程、验证过程、确认过程、联合评审过程、审计过程和问题解决过程。\n\t3. 组织过程：是指那些与软件生产组织有关的活动集。该过程又可分为设计过程、基础设施过程、培训过程和改进过程。\n\t\n2. 系统语境的过程类\n\t系统语境的过程类包含四个过程组，分别是协议过程组、项目过程组、技术过程组和组织上项目使能过程组。\n\t1. 协议过程组包含两个过程：获取过程和供应过程。\n\t2. 项目过程组包含七个过程：项目规划过程、项目评价过程、决策管理过程、风险管理过程、配置管理过程、信息管理过程和测量过程。\n\t3. 技术过程组包含11个过程：利益攸关方需求定义过程、系统需求分析过程、系统体系结构设计过程、实现过程、系统集成过程、系统测试过程、软件安装过程、软件接受支持过程、软件运行过程、软件维护过程和软件销毁过程。\n\t4. 组织上使能过程组包含五个过程：生存周期模型管理过程、基础设施管理过程、项目包管理过程、人力资源管理过程和质量管理过程。\n\t\n3. 组织上使能过程的作用。\n\t组织上使能的过程一般来说是组织层面上的工作，为项目的执行提供基本保障。该过程包含五个子过程。\n\t1. 生存周期模型管理过程：其任务为过程建立、过程评估、过程改进。\n\t2. 基础设施管理过程：其任务为过程实现、基础设施的建立、基础设施的维护。\n\t3. 项目包管理过程：项目初始化、项目包评估、项目结束处理。\n\t4. 人力资源管理过程：其任务为技能标识、技能开发、技能获取和供给、知识管理。\n\t5. 质量管理过程：其任务为质量管理、质量管理纠正措施。\n\n### 过程描述\n\n软件验证过程包括两个活动：过程实现和验证。其中验证活动有五个任务：需求验证、设计验证、代码验证，集成验证和文档验证。\n\n一个过程可通过过程意图，期望的结果以及到达过程结果需要执行的活动和任务来描述。对于一个过程的完整技术上的描述，还应包括：达到过程意图和实现过程结果的方法或规程，以及过程和活动文档。\n\n### 应用说明\n\n1. 系统和软件的关系\n\n\t在《ISO/IEC系统与软件工程-软件生产周期过程12207-2008》标准中，把软件认为是整个系统的一个组成从部分，执行系统中所确定的功能主要包括三大功能：控制功能、耦合功能以及软件本身提供的功能。由于软件通常存在与一个系统的上下文中，因此软件产品或服务一般可被认为是系统的一个项或称为系统元素。\n\t\n2. 剪裁过程及应用\n\n\t剪裁过程是使剪裁这一标准过程慢速以下特定情况或因素。\n\t1. 围绕一个组织，其中该组织在一个协议中使用了这一标准\n\t2. 影响一个项目，其中要求该项目满足一个引用该标准的协议\n\t3. 反映一个组织的需要，其中该组织要供给产品或服务\n\t\n### 软件生存周期模型\n\n1. 瀑布模型\n\n\t瀑布模型是将软件生存周期各个活动规定为按固定顺序链接的若干阶段的模型。这一模型规定了个开发阶段的活动：系统需求、软件需求、需求分析、设计、编码、测试和运行，并且自上而下具有相互衔接的固定顺序；还规定了每一个阶段的输入，即工作对象以及本阶段的工作成果，作为输出传送到下一阶段。\n\n\t瀑布模型的提出，对软件工程的主要贡献如下。\n\t1. 在决定系统怎样做之前存在一个需求阶段，它鼓励对系统做什么进行规约。\n\t2. 在系统构造之前存在一个需求阶段，它鼓励规划系统结构。\n\t3. 在每一阶段结束时进行评审，从而允许获取方和用户的参与。\n\t4. 前一步可以作为下一步被认可的、文档化的基线，并允许基线和配置早期接受控制。\n\n\t瀑布模型的主要问题是：\n\n\t1. 要求客户能完整、正确和清晰地表达他们的需求；并要求开发人员一开始就要理解这一应用。\n\t2. 由于需求的不稳定性，使设计、编码和测试阶段都可能发生延期；并且当项目接近结束时，出现了大量的集成和测试工作。\n\t3. 在开始的阶段中，很难评估真正的进度状态；并且直到项目结束之前都不能演示系统的能力。\n\t4. 在一个项目的早期开发阶段，过分地强调了基线和里程碑处的文档；并可能需要花费更多的时间用于建立一些用处不大的文档。\n\t\n2. 增量模型\n\n\t增量模型是一种非整体开发的模型。软件在该模型中逐渐开发出来，开发出一部分，向用户展示一部分，可让用户及早看到部分软件，及早发现问题。该模型具有较大的灵活性，适合软件需求不明确、设计方案有一定风险的软件项目。\n\n3. 演化模型\n\n\t该模型主要针对事先不能完整定义需求的软件开发在用户提出待开发系统的核心需求的基础上，软件开发人员按照这一要求，首先开发一个核心系统并投入运行，以便用户能够有效地提出反馈，即精化系统、增强系统能力的需求；接着，软件开发人员根据用户反馈，实施开发的迭代过程；每一迭代过程均由需求、设计、编码、测试、集成等阶段组成，为整个系统增加一个可定义的，可管理的子集；如果在一次迭代中，有的需求不能满足用户的要求，可在下一次迭代中予以修正。\n\n\t主要特征：该模型显式地把需求获取扩展到需求阶段，既为了第二个构造增量，使用了第一个构造增量来精化需求。演化模型在一定程度上可以减少软件开发活动的盲目性。\n不足之处：在演化模型的使用中，即使很好地理解了需求或设计，也很容易弱化需求分析阶段的工作。\n\n4. 螺旋模型\n\n\t螺旋模型将瀑布模型与增量模型结合起来，加入了两种模型均忽略了的风险分析，弥补了这两种模型的不足。因而它是一种风险驱动的模型。螺旋模型将开放过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合。\n\n\t螺旋模型关注解决问题的基本步骤，即标识问题，标识一些可选方案，选择一个最佳方案，遵循动作步骤并实施后续工作。其一个突出特征是，在开发的迭代中实际上只有一个迭代过程真正开发了可交付的软件。螺旋模型与演化模型和增量模型相比，同样适用了瀑布模型作为一个嵌入的过程，但螺旋模型所关注的阶段以及它们的活动是不同的。如果项目的开发风险很大或客户不能确定系统需求，在更广泛的意义上来讲，还包括一个系统或系统类型的要求，这时螺旋模型就是一个很好的生存周期模型。\n\n5. 喷泉模型\n\n\t喷泉模型体现了软件创建所固有的迭代和无间隙的特征。该模型主要用于支持面向对象技术的软件开发。由于对象概念的引入，使分析、设计、实现之间的表达没有明显间隙。\n\n### 过程规划与管理\n\n1. 创建一个软件项目生存周期过程的步骤\n\n\t1. 选择软件生存周期模型\n\t2. 细化所选择的生存周期模型\n\t3. 为每一个活动或任务标识合适的实例数目\n\t4. 确定活动的时序关系，并检查信息流\n\t5. 建立过程计划的文档\n\t\n2. 软件评估中应考虑的影响因素\n\n\t1. 不管做怎么样的决策，都必须对所采取的的措施对生存周期过程所产生的影响进行评审，以便保证项目获得好的结果。在这一评估中，应考虑以下几方面的影响。\n\t\t1. 所要求的的“返工”\n\t\t2. 资源需求\n\t\t3. 实施时间\n\t\t4. 对项目和用户的益处\n\t\t5. 员工情绪\n\n## 集成化能力成熟度模型（CMMI）\n\n### 背景和原理\n\n1. 过程改善\n\n\t历史过程改善，是指人为设计的一个活动程序，其目的是改进组织的过程性能和成熟度，并改进这一程序的结果\n\n2. 过程域、专用目标和共用目标\n\n\t过程域是一个业务域中一束相关的实践，当它们一起得以实现时，就满足被认为对该过程域的改善具有重要作用的一组条件\n\t专用目标是用于描述满足该过程域必须呈现的一些独有特征。经可以用于帮助确定一个过程域是否得以满足。\n\t共用目标用于描述产现制度化的该过程必须呈现的特征，仅用于确定一个过程域是否得以满足。\n\n### CMMI的模型部件\n\n|过程域类名|包括的过程域|\n|:---:|:---|\n|项目管理类|项目规划<br/>项目监控<br/>定量项目管理<br/>集成项目管理<br/>风险管理<br/>提供方协议管理|\n|工程类|需求开发<br/>需求管理<br/>技术解决方案<br/>产品集成<br/>确认<br/>验证|\n|支持类|配置管理<br/>过程和产品质量保证<br/>测量与分析<br/>原因分析与解决<br/>决策分析与解决|\n|过程管理类|组织过程定义<br/>组织过程性能<br/>组织过程培训<br/>组织过程关注<br/>组织创新与部署|\n\n### CMMI的等级\n\n1. 能力等级的组成\n\n\t能力等级是用来表征组织对一个过程域的改善，是不断改善一个给定过程域的一种手段。在CMMI中，针对每个过程域设定了6个能力等级，即0级：未完成级；1级：已执行级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：待续优化级。\n\t\n2. 成熟度等级的组成\n\t\n\t在CMMI中，应用于一个组织过程改善的成熟度等级有5个。即1级：初始级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：持续优化级\n\t\n3. 能力等级与成熟度等级之间的基本关系\n\n\t1. 能力等级与成熟度等级是互补的关系，两者都是一种过程改善路径，即表征组织对单一过程域的改进。\n\t2. 成熟度等级的路径可使组织针对单一过程域不断改善一组相关过程域，即表征组织对一组过程域的改进。\n\t3. 两种等级的2-5级使用了同样的名字\n\t\n4. 达到各共用目标要实施的共同实践\n\n\t达到公用目标2、共用目标3、共用目标4和共用目标5所要实施的共同实践如下表所示\n\t\n||所要实施的共用实践|\n|:---:|:---:|\n|共用目标2：把过程制度化为一个管理过程|GP2.1 建立组织策略<br/>GP2.2 规划过程<br/>GP2.3 提供资源<br/>GP2.4 指派责任<br/>GP2.5 培训人员<br/>GP2.6 管理配置<br/>GP2.7 标识相关利益方的参与<br/>GP2.8 监控过程<br/>GP2.9 客观地评估符合性<br/>GP2.10 从高层管理的视觉评审状态<br/>|\n|共用目标3：把过程制度化为一个已定义过程|GP3.1 建立一个已定义的过程<br/>GP3.2 收信进信息 所要实施的共用实践|\n|共用目标4：把过程制度化为一个已定量管理过程|GP4.1 为该过程建立定量目的<br/>GP4.2 使子过程性能达到稳定|\n|共用目标5：把过程制度化为一个持续优化过程|GP5.1 确保不断进行过程改善<br/>GP5.2 收集问题的根本原因|\n\n完结\n","slug":"如何开发-管理一个项目","published":1,"updated":"2021-06-06T18:52:24.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoio006ftnn0dixn8l2f","content":"<p>如何管理一个项目，这是个沉重的话题。实际上，目前很多人都是凭借经验进行项目管理和开发，事实上管理项目是有着大量的方法论，这些方法论整理起来被人归纳成了一个学科，名字叫做<code>软件工程</code>，接下来的内容将会归纳总结里面的一些要点，如果你有意成为一个项目管理者，请必须了解一下这些基础知识。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"软件系统模型\"><a href=\"#软件系统模型\" class=\"headerlink\" title=\"软件系统模型\"></a>软件系统模型</h2><p>开始一个项目之前，你需要做好准备，那就是建立系统模型，有了抽象的模型，才会有具像的实现。</p>\n<ul>\n<li>在软件开发中，软件系统模型大体可分为两类：<code>概念模型</code>和<code>软件模型</code>。</li>\n<li>概念模型是创建在需求层上的，它描述了系统是什么。</li>\n<li>软件模型是建立在抽象层上的，它描述了实现概念模型的软件解决方案。</li>\n<li>软件模型可进一步分为<code>设计模型</code>、<code>实现模型</code>和<code>部署模型</code>。</li>\n</ul>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h3><p> 一个完整的需求需要有以下特征：</p>\n<ol>\n<li>必要的：该需求是用户所要求的（产品经常会提一些伪需求，比如说在帖子列表添加个一键评价，点击了就回复666，但实际上没有用户想毫无感情地666，所以这是伪需求，不满足该条件的请拒绝）；</li>\n<li>无歧义的：该需求只能用一种方式解释（这个就不用解释了，遇到有歧义的需求请问清楚）；</li>\n<li>可测的：该需求可以进行测试；</li>\n<li>可跟踪的：该需求可以从一个开发阶段跟踪到另一个开发阶段（意思就是这个需求不会因为开发的进行变得模糊、不清晰）；</li>\n<li>可测量的：该需求是可测量的（意思就是实现这个需求不能无限耗费人力物力，说好这个需求两个人一天能做完，就两个人一天真的能做完）。</li>\n</ol>\n<h3 id=\"类别\"><a href=\"#类别\" class=\"headerlink\" title=\"类别\"></a>类别</h3><ol>\n<li>功能需求：系统或系统构件必须执行的功能</li>\n<li>非功能需求：分为性能需求、外部接口需求、设计约束需求、质量属性需求。</li>\n</ol>\n<h3 id=\"怎么发现需求\"><a href=\"#怎么发现需求\" class=\"headerlink\" title=\"怎么发现需求\"></a>怎么发现需求</h3><table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">情况</th>\n<th align=\"center\">成功条件</th>\n<th align=\"center\">风险</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">自悟</td>\n<td align=\"center\">自己想</td>\n<td align=\"center\">要比你的最终客户拥有更多的一样弄领域和过程方面的知识和丰富的想象力，也就是你要比你的用户更加清楚用户要啥</td>\n<td align=\"center\">无法验证你想出来的东西是不是你的用户想要的</td>\n</tr>\n<tr>\n<td align=\"center\">交谈</td>\n<td align=\"center\">跟你的客户聊</td>\n<td align=\"center\">你能提出正确的问题，回答人能揭示需求本质的能力</td>\n<td align=\"center\">可能会获得一堆需求，而且越来越多，不断增长，可能还会推翻你之前的需求，可能导致超出项目成本和进度的限制<s>（甚至可能被你的开发揍一顿）</s></td>\n</tr>\n<tr>\n<td align=\"center\">观察</td>\n<td align=\"center\">你去看你的用户怎么用你的软件</td>\n<td align=\"center\">你需要有洞察事物本质的能力</td>\n<td align=\"center\">1. 你的用户会抵触你的观察（很明显侵犯隐私了）2. 用户会觉得你是不是这软件没做好或者哪里需求不到位所以老是来看我，对你的软件产生怀疑</td>\n</tr>\n<tr>\n<td align=\"center\">小组会</td>\n<td align=\"center\">项目组的人全部叫出来开会讨论需求</td>\n<td align=\"center\">你小组的人有不同观点，并且有良好的发现需求的能力，能揭示需求中存在的问题，最重要的是需求能跟用户达成共识</td>\n<td align=\"center\">会议组织不到位就凉了，而且天天开会你的项目组的人也受不了，可能会提出矛盾需求</td>\n</tr>\n<tr>\n<td align=\"center\">提炼</td>\n<td align=\"center\">针对已有的部分需求文档，看线上反馈情况，进行提炼</td>\n<td align=\"center\">你需要有想象力和需求标识能力，包括熟悉相关的技术标准</td>\n<td align=\"center\">跟自悟一样，你不能知道你发现的需求是否是对的</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"需求规约\"><a href=\"#需求规约\" class=\"headerlink\" title=\"需求规约\"></a>需求规约</h3><p>需求规约就是怎么写一个需求表，因为形式很多，所以最好就根据实际情况进行，这里不做规定，但是必须包含以下几个特征</p>\n<ol>\n<li>重要性和稳定性：需求要根据重要程度和稳定程度分优先级，例如：基本需求、可选需求和期望需求。</li>\n<li>可修改的：在不过多地影响其他需求的情况下，可以容易地修改一个单一需求。</li>\n<li>完整的：没有被遗漏的需求。</li>\n<li>一致的：不存在互斥的需求。</li>\n</ol>\n<p>为什么需求规约很重要？（概念性东西）</p>\n<ol>\n<li>是软件开发组织和用户之间一份事实上的技术合同书，是产品功能及其环境的体现。</li>\n<li>对于项目的其余大多数工作，需求规约是一个管理控制点。</li>\n<li>对于产品/系统的设计，需求规约是一个正式的、受控的起点。</li>\n</ol>\n<h2 id=\"结构化方法\"><a href=\"#结构化方法\" class=\"headerlink\" title=\"结构化方法\"></a>结构化方法</h2><h3 id=\"结构化需求分析\"><a href=\"#结构化需求分析\" class=\"headerlink\" title=\"结构化需求分析\"></a>结构化需求分析</h3><ol>\n<li><p>为什么要这么做？</p>\n<p> 为了应对三大挑战：</p>\n<pre><code> - 问题空间理解。（假如让你开发一个八字排盘App，但是你又不懂八字，所以要开发出一个高质量、满足用户要求的App，就不容易了）\n - 人与人之间的通信。（开发过程长、活动多、任务重，项目组成员多，直接面对面沟通起来难免有遗漏、误解等，所以这也是一个挑战）\n - 需求的变化性。（需求是不断变化的，所以这是软件开发人员面临的挑战）\n</code></pre>\n<p> 一种好的需求技术应该具有以下基本特征：</p>\n<pre><code> 1. 提供方便通信的机子，例如，在不同开发阶段，使用对相关人员易于理解的语言。\n 2. 鼓励需求分析人员使用问题空间的术语思考问题，编写文档。\n 3. 提供定义系统边界的方法。\n 4. 提供支持抽象的基本机制，例如，&quot;划分&quot;，&quot;功能抽象&quot;，&quot;结构抽象&quot;等。\n 5. 为需求分析人员提供多种可供选择的方案。\n 6. 提供特定的技术，适应需求的变化等。\n</code></pre>\n</li>\n<li><p>几种基本术语的解释</p>\n<p> (1) 数据流：数据流是数据的流动，用于表达在分析中所要使用的、用于表达”客体”的信息，用箭头表示。<br> 大概长这样：</p>\n <img width=50px src='https://i.loli.net/2019/10/21/wM2SkZXGDY46lQh.png'>\n (2) 加工：加工是数据变换的单元，即它接受输入的数据，对其进行处理，并产生输出。\n 大概长这样\n <img width=50px src='https://i.loli.net/2019/10/21/mcfwVCaJI1Sn8kZ.png'>\n (3) 数据存储：数据存储是数据的静态结构。\n 大概长这样(可以是横的或者竖的)\n <img width=50px src='https://i.loli.net/2019/10/21/xbXKc45RlYpnNB9.png'>\n (4) 数据源和数据潭: 数据源是数据流的起点，数据潭是数据流的归宿地。数据源和数据潭是系统之外的实体，可以是人、物或其他软件系统。\n 大概长这样\n <img width=50px src='https://i.loli.net/2019/10/21/LiwWbnSAs7Pqzoh.png'></li>\n<li><p>数据流图</p>\n<p> 把上面的元素组成起来就是数据流图了<br> 大概长这样</p>\n <img width=70% src=\"https://i.loli.net/2019/10/21/wDdaFiLe9Ps6UzA.png\">\n\n<p> 几个要点：1）数据流起到连接其他实体的作用，实体可以是加工、数据存储、数据源和数据潭；2）加工之间可以有多个数据流，这些数据流之间可以没有任何关系，数据流图也不表明他们的先后次序；3）对于一个比较大的软件系统，往往需要采用多层次的数据流图。</p>\n</li>\n<li><p>建模过程</p>\n<ol>\n<li>建立系统环境图，确立系统语境</li>\n<li>自顶向下，逐步求精，建立系统的层次数据流图</li>\n<li>定义数据字典。数据字典有3种基本结构表示：顺序结构，选择结构，重复结构。<ul>\n<li>顺序结构是指数据A由数据B和数据C顺序构成的，并记为”+”。例如：学生成绩=姓名+性别+学号+科目+成绩，其中”=”号表达的是”定义为”.</li>\n<li>选择结构是指由数据A是由数据B或数据C定义的，即数据B不可能同时是B和C，并记为“|”，例如：性别=男|女</li>\n<li>重复结构是指数据A是由多个重复出现的数据B构成的，并记为”| |”，例如：学生成绩表=|学生成绩|<img width=\"50%\" src=\"https://i.loli.net/2019/10/21/43hSWgZPmVirHfA.png\"></li>\n</ul>\n</li>\n<li>描述加工：该步的目标为依据系统的数据流图，给出其中每一加工的小说明。加工可以有3种表达工具。<ol>\n<li>结构化自然语言（自然语言描述）</li>\n<li>判定表: 由条件类别，条件组合，操作，操作执行构成。举例如图<img width=50% src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D22%2C0%2C590%2C389%3Bc0%3Dbaike80%2C5%2C5%2C80%2C26/sign=d64b6fc508087bf469a30da9cfe16500/42166d224f4a20a48dfd6c499a529822730ed059.jpg\"></li>\n<li>判定树。举例如图<img width=60%  src=\"https://i.loli.net/2019/10/21/COmGSet5I61lFsH.png\"></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>注意事项：</p>\n<ol>\n<li>模型平衡问题</li>\n<li>信息复杂性控制问题</li>\n</ol>\n</li>\n<li><p>需求验证<br> 验证需求规格说明书中的每一单一需求是否满足5个性质，即必要性、无歧义性、可测性、可跟踪性、可测量性；验证需求规格说明是否满足4个性质，即重要性和稳定程度、可修改性、完整性和一致性。在必要时还需要验证其他特性，如设计无关性。</p>\n</li>\n</ol>\n<h3 id=\"结构化设计\"><a href=\"#结构化设计\" class=\"headerlink\" title=\"结构化设计\"></a>结构化设计</h3><h4 id=\"总体设计步骤\"><a href=\"#总体设计步骤\" class=\"headerlink\" title=\"总体设计步骤\"></a>总体设计步骤</h4><p>结构化设计方法基于<code>自顶向下，功能分解</code>的基本原则，针对两种不同类型的数据流图，分别提出了变换设计和事务设计。其中，变换设计的目标是将变换型数据流图映射为模块结构图，而事务设计的目标是将事务型数据流图映射为模块结构图。</p>\n<ol>\n<li><p>变换型数据流图和事务性和数据流图<br>（1）变换型数据流图：具有比较明显的输入部分和变换部分之间的界面、变换部分和输出部分之间界面的数据流图，称为变换型数据流图；<br><img src=\"https://www.sytm.net/ueditor/net/upload/2013-12-31/bdae1434-8b79-4209-b818-2502c7ea3bee.png\"><br>（2）事务型数据流图：数据到达一个加工T，该加工T根据输入的值，在其后若干动作序列中选出一个来执行，这类数据流图成为事务型数据流图。<br><img src=\"https://www.sytm.net/ueditor/net/upload/2013-12-31/142b2c91-a9ad-4c6e-b075-ecd6a900ee63.png\"></p>\n</li>\n<li><p>总体设计分为3个阶段。第一阶段为初始设计，在对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。第二阶段为精化设计，依据模块“高内聚低耦合”的原则精化初始的模块结构图，并设计其中的全局数据结构和每一模块的接口。第三阶段为复审阶段，对前两个阶段所得到的高层软件结构进行复审，必要时还可能需要对该软件结构做一些精化工作，这对软件的一些性质，特别是对软件质量的提高，将产生非常大的影响。</p>\n</li>\n<li><p>天天扯着嗓子喊高内聚低耦合，到底什么是内聚什么是耦合？</p>\n<ul>\n<li>耦合：耦合是指不同模块之间相互依赖程度的度量<ul>\n<li>内容耦合：当一个模块直接修改或操作另一个模块的数据，\u001d或当一个模块直接修改或操作，另一个模块的数据或一个模块不通过正常入口转入到一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该尽量避免使用。</li>\n<li>公共耦合：两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。</li>\n<li>控制耦合：一个模块通过接口向另一个模块传递一个控制信号，接收信号的模块根据信号值进行适当的动作，这种耦合被成为控制耦合。</li>\n<li>标记耦合：若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。</li>\n<li>数据耦合：模块之间通过参数来传递数据，则称为数据耦合。数据耦合是最低的一种耦合形式。</li>\n</ul>\n</li>\n<li>内聚：内聚是指一个模块内部各成分之间相互关联程度的度量<ul>\n<li>偶然内聚：如果一个模块的各成分之间基本不存在任何关系，则称为偶然内聚</li>\n<li>逻辑内聚：几个逻辑上相关的功能被放在同一模块中，则称为逻辑内聚。</li>\n<li>时间内聚：如果一个模块完成的功能必须在同一时间内执行（例如，初始化系统或一组变量），但这些功能只是因为时间因素关联在一起，则称为时间内聚。</li>\n<li>过程内聚：如果一个模块内部的处理成分是相关的，而且这些处理必须以特定的次序执行，则称为过程内聚。</li>\n<li>通信内聚：如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚</li>\n<li>顺序内聚：如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚</li>\n<li>功能内聚：最理想的内聚是功能内聚，模块所有的成分对于完成单一的功能都是基本的。功能内聚的模块对完成其功能而言是充分必要的。</li>\n</ul>\n</li>\n<li>启发式规则：无论是变换设计还是事务设计，都涉一个共同的问题，即“基于高内聚低耦合的原理，采用一些经验性的启发式规则，对初始的模块结构图进行精化，形成最终的模块结构图”。</li>\n<li>怎么做？<ol>\n<li>改进软件结构，提高模块独立性。</li>\n<li>力求模块规模适中。</li>\n<li>力求深度、宽度、扇出和扇入适中。深度：表示其控制的<code>层数</code>(不包括自身)；宽度：同一层次上模块总数的<code>最大值</code>；扇出：一个模块<code>直接</code>控制（调用）的下级模块数目；扇入：一个模块有多少个上级模块<code>直接</code>调用它。</li>\n<li>尽力使模块的作用域在其控制域之内。作用域：受该模块内<code>一个判定</code>所影响的所有模块的集合；控制域：模块本身以及所有<code>直接或间接</code>从属于它的模块的集合。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"详细设计步骤\"><a href=\"#详细设计步骤\" class=\"headerlink\" title=\"详细设计步骤\"></a>详细设计步骤</h4><ol>\n<li>结构化程序设计<br> 包含三种基本控制结构：顺序结构、选择结构、循环结构</li>\n<li>详细设计工具<ol>\n<li>程序流程图 <img width=20% src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945069712&di=74b11092aae0042569e80dc22ee83438&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F09%2F17%2F02%2F27798515%2F15.files%2Ffile0001.jpg\">\n 缺点：不是一种逐步求精的工具，过早地考虑程序的流程，不去考虑程序的全局结构；所表达的控制流，往往不受任何约束可随意转移，从而会影响甚至破坏好的系统结构设计；不易表示数据结构。</li>\n<li>盒图（N-S图） <img width=40% src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945228461&di=10908d6d12f9c8984356e884b3c0aeb5&imgtype=0&src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fzhidao%2Fwh%253D450%252C600%2Fsign%3Da401ed95523d26972e86005960cb9ecd%2Fd833c895d143ad4bd5fe969f81025aafa50f0698.jpg\"></li>\n<li>PAD图（Problem Analysis Diagram） <img width=\"40%\" src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945326054&di=d66d2f92c755db3f26640c2bbb6bc338&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F12%2F15%2F14%2F51872755%2F6.files%2Ffile0001.jpeg\"></li>\n</ol>\n N-S图和PAD图支持“自顶向下逐步求精”的设计。可节省人工编码工作，有利于提高软件的可靠性和软件生产率<ol start=\"4\">\n<li>类程序设计语言（伪码/PDL）<br> 是一种用正文形式表示数据结构和处理过程的设计工具，PDL是一种“混合”的语言。</li>\n</ol>\n</li>\n<li>设计规约<br> 完成软件设计后，应产生设计规约，完整准确地描述满足系统需求规约所要求的的所有功能模块，以及伴随功能模块而出现的非功能机制。设计规约通常包括<code>概要设计规约</code>和<code>详细设计规约</code>。 <code>概要设计规约</code>指明高层软件体系结构，其主要功能如下： 1.系统环境等与设计有关的限定条件 2. 软件模块的结构（模块之间的接口及设计的数据流和主要数据结构）3. 模块描述（接口定义，模块处理逻辑，必要的注释等）4. 文件结构和全局数据文件的逻辑结构 5.测试需求 <code>详细设计规约</code>（包括各处理过程的算法和算法所涉及的全部数据结构的描述）主要作为软件设计人员与程序员之间交流的媒体。</li>\n</ol>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><h3 id=\"UML是一种图形化建模语言（Unified-Modeling-Language）\"><a href=\"#UML是一种图形化建模语言（Unified-Modeling-Language）\" class=\"headerlink\" title=\"UML是一种图形化建模语言（Unified Modeling Language）\"></a>UML是一种图形化建模语言（Unified Modeling Language）</h3><p>为了支持抽象分析和设计中的事物，UML给了八个基本术语，即类、接口、协作、用况、主动类、构件、制品、节点、</p>\n<ul>\n<li>类： 类是一组拥有相同属性、操作、关系和语义的对象的描述。类主要用于抽象客观世界中的事物。</li>\n<li>接口：每个操作描述了类、构件或子系统的一个服务，接口就是操作的一个集合。接口是对系统/产品的“接缝”予以模型化，表明了一个类、构件、子系统所需要得到的、且与实现无关的行为。</li>\n<li>用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的、可观察的结果。</li>\n<li>协作：协作是一个交互，涉及交互的三要素：交互各方、交互方式以及交互内容</li>\n<li>用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的，可观察的结果。</li>\n<li>主动类：主动类是一种至少具有一个进程或线程的类。</li>\n<li>构件：构件是系统设计中的一种模块化部件，通过外部接口隐藏了它的内部实现。</li>\n<li>制品：制品是系统中包含物理信息（比特）的、可替代的物理部件。</li>\n<li>节点：节点是运行时存在的物理元素，通常表示一种具有记忆能力和处理能力的计算机资源。</li>\n</ul>\n<p>类在建模中的主要用途：</p>\n<ol>\n<li>模型化问题域中的概念</li>\n<li>建立系统的职责分布模型</li>\n<li>模型化建模中使用的基本类型</li>\n</ol>\n<p>使用接口应注意的问题</p>\n<ol>\n<li>接口只可以被其他类目使用，而本身不能访问其他类目</li>\n<li>接口描述类的外部可见操作，通常是该类的一个特有限定行为。这些操作可以使用可见性、并发性、衍型、标记值和约束来修饰。</li>\n<li>接口不描述其中操作的实现，也没有属性和状态。据此可见，接口在形式上等价于一个没有属性、没有方法而只有抽象操作的抽象类</li>\n<li>接口之间没有关联、泛化、实现和依赖。但可以参与泛化、实现和依赖</li>\n</ol>\n<h3 id=\"表达关系的术语\"><a href=\"#表达关系的术语\" class=\"headerlink\" title=\"表达关系的术语\"></a>表达关系的术语</h3><pre><code>关联：关联是一组具有相同结构、相同链的描述，是类目之间的一种结构关系。关联可以用一条连接两个类目的线段表示，并可对其命名，其结构可以具有方向性，用一个实心三角形来指示关联的方向。\n    1. 关联名 。\n    2. 导航：对于一个给定的类目，可以找到与之关联的另一个类目，这称为导航。\n    3. 角色：角色是关联一端的类目对另一端的类目的一种呈现。\n    4. 可见性：通过导航可以找到另一类目的实例，有时候需要限制访问。\n    5. 多重性：类中对象参与一个关联的数目，成为该关联的多重性\n    6. 限定符：限定符是一个关联的属性或属性表。\n    7. 聚合：分类是增强客观实际问题语义的一种手段。聚合是对象之间（不是类之间）的一种结构关系。\n    8. 组合：组合是聚合的一种特殊形式\n泛化：泛化是一般性类目和它的较为特殊类目之间的一种关系。子类可以继承父类的属性和操作，同时也可以替换父类的声明。\n    泛化的四种约束：完整、不完整、互斥、重叠\n细化：细化是类目之间的语义关系，其中一个类目规约保证了另一个类目执行的契约。\n依赖：依赖用于描述一个类目使用另一个类目的信息和服务，是一种使用关系。\n    依赖的分类：绑定、导出、允许、示例、实例化、幂类型、精化、使用。\n    \n关联、泛化和细化都是一类特地类型的依赖。\n\n使用这四种术语，可以模型化以下各种关系：\n1. 结构关系（静态结构和动态结构）\n    进行模型化时两种驱动方式：1.以数据驱动 2. 以行为驱动\n2. 继承关系\n3. 精化关系\n4. 依赖关系\n</code></pre>\n<h3 id=\"表达组合信息的术语————包\"><a href=\"#表达组合信息的术语————包\" class=\"headerlink\" title=\"表达组合信息的术语————包\"></a>表达组合信息的术语————包</h3><p>为了控制信息组织的复杂性，UML提供了组织信息的一种通用机制————包，支持形成一些可管理的部分。换言之，包可以作为“模块化”和“构件化”的一种机制。</p>\n<p>包是模型元素的一个分组。一个包本身可以被嵌套在其他包中，并且可以含有子包和其他种类的模型元素。</p>\n<p>通过在包的名字前加上一个可见性符号（+，-，#），来指示该包的可见性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ 表示对其他包而言都是可见的</span><br><span class=\"line\"># 表示对子孙包而言是可见的</span><br><span class=\"line\">- 表示对其他包而言都是不可见的</span><br></pre></td></tr></table></figure>\n\n<p>为了模型化包之间的关系，UML给出了两种依赖，即访问和引入。</p>\n<ul>\n<li>访问：表明目标包中的内容可以被源包所引用，或被那些递归嵌套在源包中的其他包所引用。</li>\n<li>引入：表明目标包中具有适当可见性的内容（名字）被加入到源包的公共命名空间中。</li>\n</ul>\n<p>UML中用虚线加箭头的方式表示源包到目标包的依赖（访问和引入）。</p>\n<h3 id=\"UML术语的作用\"><a href=\"#UML术语的作用\" class=\"headerlink\" title=\"UML术语的作用\"></a>UML术语的作用</h3><ol>\n<li>类用于抽象客观事物</li>\n<li>接口用于抽象事物之间的缝隙</li>\n<li>协作用于抽象协作性行为</li>\n<li>用况用于抽象功能</li>\n<li>主动类用于抽象并发行为</li>\n<li>构件用于抽象软件解中标识的成分</li>\n<li>制品用于抽象工作产品</li>\n<li>节点用于抽象计算单元</li>\n<li>关联用于抽象结构关系</li>\n<li>泛化用于抽象“一般/特殊”关系</li>\n<li>实现用于抽象精化关系</li>\n<li>依赖用于抽象使用关系</li>\n</ol>\n<h3 id=\"UML的模型表达式\"><a href=\"#UML的模型表达式\" class=\"headerlink\" title=\"UML的模型表达式\"></a>UML的模型表达式</h3><ol>\n<li>结构图和行为图<br> 结构图用于表达系统或系统成分的静态结构模型，给出系统或系统成分的一些说明性信息<br> 行为图用于表系统或系统成分的动态结构模型，给出系统或系统成分的一些行为信息</li>\n<li>类图、用况图、顺序图及状态图<ul>\n<li>类图是可视化地表达系统静态结构功能模型的工具，使用类图所表达的系统静态结构模型，给出的是一些关于系统的说明性信息。<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176025075&di=1875f9ac829f33a38a45131069ee3e4a&imgtype=0&src=http://images.cnblogs.com/cnblogs_com/a-i/Uml2.JPG\"></li>\n<li>用况图是一种表达系统功能模型的图形化工具，它包含六个模型元素，分别是主题、用况、参与者、关联、泛化、依赖<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176303343&di=4146dfc9badef7bc95f4c750ab149eb0&imgtype=0&src=http://yzhtml01.book118.com/2016/09/24/23/28839740/23.files/file0001.png\"></li>\n<li>顺序图由一组对象以及按时序组织的对象之间的关系组成，是一种交互图，包含对象之间传递的信息。控制操作包括<code>选择执行操作</code>、<code>条件操作</code>、<code>并发迭代操作</code>、<code>迭代执行操作</code>。<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176439921&di=d592e65ae4a1bc1c2e65a98e415a897a&imgtype=0&src=http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/png/20180615101636402475.png\"></li>\n<li>状态图强调了从一个状态到另一个状态的控制流，是显示一个状态机的图。状态图由状态、事件和状态转移构成。使用状态图的作用有两个：一是创建一个系统的动态模型，二是创建一个场景的模型<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176576658&di=70e3de58666cf1d7315cf56a05ec0d35&imgtype=0&src=http://yzhtml01.book118.com/2016/12/07/08/48638362/25.files/file0001.png\"></li>\n<li></li>\n</ul>\n</li>\n<li>创建一个系统的类图的步骤<ul>\n<li>模型化代建系统中的概念，形成类图中的基本元素</li>\n<li>模型化代建系统中的各种关系，形成该系统的初始类图</li>\n<li>模型化系统中的协作，给出该系统的最终类图</li>\n<li>模型化逻辑数据库模式</li>\n</ul>\n</li>\n<li>信号事件、调用事件、时间事件和变化事件<ul>\n<li>信号事件是一种异步事件，信号通常由状态机处理。如果没有定义对该事件的响应，那么事件均可能丢失。事件的丢失，就有可能引发接受者——状态机的一个错误的状态转移。</li>\n</ul>\n</li>\n<li>状态转移所涉及的内容<br> 描述一个状态转换，一般涉及五个部分：<ol>\n<li>源状态：发生状态转移的那个状态</li>\n<li>转移触发器：在源状态中由对象识别的事件，并且一旦满足其监护条件，则使状态发生转移。</li>\n<li>监护条件：一个布尔表达式，当某个事件触发器接受一个事件时，如果该表达式有值为真，则触发一个转移；若有值为假，则不发生状态转移。</li>\n<li>效应：一种可执行的行为</li>\n<li>目标状态：转移完成后所处的状态</li>\n</ol>\n</li>\n<li>最常用的控制操作子<br> 选择执行操作子：该操作子由两部分组成：一是监护条件，二是控制体<br> 条件执行操作子：控制体通过水平线将其分为一些部分，每一部分表示一个条件分支，每一分支有一个监护条件。<br> 并发执行操作子：该控制操作子的体通过水平线将其分为多个部分，每一部分表示一个并行计算。该控制操作子表明，当进入该控制操作子是，所有部分并发执行。<br> 迭代执行操作子：该控制操作子表明，只要在每一次迭代之前该监护条件为真，那么该控制体就反复执行，当该控制体上面的监护条件为假时，控制绕过该控制操作子。</li>\n<li>子状态机、简单状态和组合状态的概念<br> 子状态机：为了有效地组织状态、控制对象状态的复杂性，UML提供了组合状态，在一个状态机中引入了另一个状态机。被引入的状态机就称为子状态机。<br> 简单状态：子状态是被嵌套到另一状态中的状态。相对地，被引入的状态机就称为子状态机。<br> 组合状态：把含子状态的状态称为组合状态，组合状态可包含两种类型的子状态机，即非正交（顺序）子状态机和正交（并发）子状态机。<h2 id=\"RUP\"><a href=\"#RUP\" class=\"headerlink\" title=\"RUP\"></a>RUP</h2></li>\n</ol>\n<h3 id=\"RUP-Rational-Unified-Process-的特点\"><a href=\"#RUP-Rational-Unified-Process-的特点\" class=\"headerlink\" title=\"RUP(Rational Unified Process)的特点\"></a>RUP(Rational Unified Process)的特点</h3><p>RUP的突出特点是，它是一种以用况（Use Case）为驱动的、以体系结构为中心的迭代、增量式开发。</p>\n<ol>\n<li>以用况为驱动<br>以用况为驱动是指在系统的生存周期中，以用况作为基础，驱动系统有关人员对所要建立系统的功能需求进行交流，驱动系统分析、设计、实现和测试等活动。</li>\n<li>以体系结构为中心<br>以体系结构为中心是指在系统的生存周期中，开发的任何阶段都要给出相关模型视角下有关体系结构的描述，作为构思、构造、管理和改善系统的主要标准。</li>\n<li>迭代、增量式开发<br>迭代、增量式开发是指通过开发活动的迭代，不断地产生相应的增量。在RUP中，规定了四个开发阶段：初始阶段、精化阶段、构造阶段和移交阶段。</li>\n</ol>\n<h3 id=\"核心工作流\"><a href=\"#核心工作流\" class=\"headerlink\" title=\"核心工作流\"></a>核心工作流</h3><p>核心工作流：需求获取、分析、设计、实现和测试</p>\n<h4 id=\"需求获取\"><a href=\"#需求获取\" class=\"headerlink\" title=\"需求获取\"></a>需求获取</h4><table>\n<thead>\n<tr>\n<th align=\"center\">基本步骤</th>\n<th align=\"center\">产生的制品</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">列出候选的特征</td>\n<td align=\"center\">特征表</td>\n</tr>\n<tr>\n<td align=\"center\">理解系统语境</td>\n<td align=\"center\">领域模型或业务模型</td>\n</tr>\n<tr>\n<td align=\"center\">捕获功能需求</td>\n<td align=\"center\">用况模型</td>\n</tr>\n<tr>\n<td align=\"center\">捕获非功能需求</td>\n<td align=\"center\">补充需求或针对特殊需求的用况</td>\n</tr>\n</tbody></table>\n<h3 id=\"业务用况模型和业务对象模型\"><a href=\"#业务用况模型和业务对象模型\" class=\"headerlink\" title=\"业务用况模型和业务对象模型\"></a>业务用况模型和业务对象模型</h3><ol>\n<li>业务用况模型。业务用况模型是以用框图予以表达的</li>\n<li>业务对象模型。为了精化业务用况模型中的每一个业务用况，RUP引入了三个术语，用于表达参与业务的业务对象：<code>工作人员</code>、<code>业务实体</code>和<code>工作单元</code>。业务对象模型可通过交互图和活动图予以表达。</li>\n</ol>\n<h3 id=\"标识用况应注意的问题\"><a href=\"#标识用况应注意的问题\" class=\"headerlink\" title=\"标识用况应注意的问题\"></a>标识用况应注意的问题</h3><ol>\n<li>建立用况的结构中，应尽可能反映用况的实际情况。</li>\n<li>在用况的结构化中，不论是施加什么结构，新引入的用况都不应该太小或太大</li>\n<li>在建立用况的结构是，应尽量避免对用况模型中的用况功能进行分解。</li>\n</ol>\n<h4 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h4><ol>\n<li>分析类是类的一种衍型，分为边界类、实体类和控制类</li>\n<li>用况细化时一个协作，针对一个用况，其行为可用多个分析类之间的相互作用来细化，并记为用况细化。用况细化对用况模型中的一个特定的用况提供了一种直接跟踪的方式。</li>\n<li>分析包是一种控制信息组织复杂性的机制，提供了分析制品的一种组织手段。其主要特征为：体现问题的分离；高内聚、低耦合；尽可能体现一个系统的完整顶层设计，尽可能成为一些子系统或者成为一些子系统的组成部分。</li>\n</ol>\n<h4 id=\"具有良好结构的分析包的特征\"><a href=\"#具有良好结构的分析包的特征\" class=\"headerlink\" title=\"具有良好结构的分析包的特征\"></a>具有良好结构的分析包的特征</h4><ol>\n<li>体现问题分离</li>\n<li>高内聚、低耦合。</li>\n<li>尽可能提现一个系统的完整顶层设计。</li>\n</ol>\n<h4 id=\"软件设计层上的术语\"><a href=\"#软件设计层上的术语\" class=\"headerlink\" title=\"软件设计层上的术语\"></a>软件设计层上的术语</h4><p>软件设计是满足需求规约所需要的软件结构。RUP为了满足系统/产品分析模型规约需求的软件结构，为设计层提供了是个术语：设计类、用况细化、设计子系统和接口，用于表达软件结构中的基本元素。</p>\n<ol>\n<li>设计类：一个设计类是对系统中实现一个类或类似构造的一个无缝抽象</li>\n<li>用况细化：用况细化是设计模型的一个协作，其中使用设计类及其对象，描述一个特定用况是如何予以细化的，是如何执行的</li>\n<li>设计子系统：设计子系统可以包含设计类、用况细化、接口，以及其他子系统，通过对其操作来显示其功能。</li>\n<li>接口：接口用于规约由设计类和设计子系统，必须提供与该接口操作对应的实现方法。</li>\n</ol>\n<h4 id=\"创建系统-产品用况模型的活动和任务\"><a href=\"#创建系统-产品用况模型的活动和任务\" class=\"headerlink\" title=\"创建系统/产品用况模型的活动和任务\"></a>创建系统/产品用况模型的活动和任务</h4><p>创建系统/产品用况模型的活动和任务如下</p>\n<ol>\n<li>活动一：发现并描述参与者<br>任务1：发现参与者，即直接发现一些候选的参与者<br>任务2：描述参与者，即对参与者进行命名并描述</li>\n<li>活动二：发现用况并对用况进行描述<br>任务1：发现用况<br>任务2：描述用况，即确定用况后对其进行描述</li>\n<li>活动三：确定用况的优先级，目的是在寻找参与者并对其进行描述和发现用况的并对用况进行描述的基础上确定哪些用况适合在早期的迭代中开发，哪些适合在后期的迭代中开发。</li>\n<li>活动四：精化用况。这一活动的目的是详细描述出每一用况的事件流，包括用况是怎样开始的，是怎样结束的，是怎样与参与者进行交互的，最终形成一系列精化的用况</li>\n<li>活动五：构造用户界面原型。这一活动的目的在于建造用户界面原型，使用户可以有效地执行用况。</li>\n<li>活动六：用况模型的结构化。需要进行以下工作。<ol>\n<li>抽取用况描述中的那些一般性的和共享的功能并使用泛化关系标识和描述那些共享功能</li>\n<li>抽取用况描述附加的或可选的功能</li>\n<li>标识用况之间的包含关系。通过用况模型的结构化，最终形成一个系统/产品的精化用户模型</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"创建系统-产品需求分析模型的活动和任务\"><a href=\"#创建系统-产品需求分析模型的活动和任务\" class=\"headerlink\" title=\"创建系统/产品需求分析模型的活动和任务\"></a>创建系统/产品需求分析模型的活动和任务</h4><ol>\n<li>活动1：体系结构分析。该活动的目标是通过标识分析包和分析类，建立分析模型和体系结构“骨架”，并标识有关分析包和分析类的特定需求。<br>任务1：标识分析包。该任务的基本输入是系统的用况模型<br>任务2：处理分析包之间的共性<br>任务3：标识服务包<br>任务4：定义分析包的依赖，该任务的目标是发现相对独立的包，实现包的高内聚和低耦合<br>任务5：标识重要的实体类，该任务的目标是标识在体系结构方面具有意义的实体类。<br>任务6：标识分析包和重要实体类的公共特定需求，该任务的目标是依据需求获取阶段所标识的非功能需求，针对在分析期间所标识的包和分析类，标识它们的一些公共的特定要求。</li>\n<li>活动2：用况分析。该活动的目标是：一是标识那些在用况事件流执行中所需要的分析类和对象；二是将用况的行为分布到参与交互的各个分析对象；三是捕获用况细化上的特定需求。<br>任务1：标识分析类，该任务的目标是标识在细化一个用况中所需要实体类、控制类和边界类，给出它们的名字、责任、属性和关系。<br>任务2：描述分析类对象之间的交互。首先确定细化该用况所必要的交互，其次分派该用况的功能，最后根据其责任，发现该交互图中的各个链。</li>\n<li>活动3：类的分析。该活动的目标：一是标识并维护分析类的属性和关系；二是捕获分析类细化中的特殊需求。<br>任务1：标识责任，通过组合一个类在不同用况细化中所扮演的角色来完成。<br>任务2：标识属性<br>任务3：标识关联和聚合</li>\n<li>活动4：包的分析。该活的目标是：一是确保分析包尽可能与其他包相对独立；而是确保分析包实现了它的目标；三是描述依赖，以益于可以估计未来的变化。</li>\n</ol>\n<h3 id=\"创建系统-产品设计模型的活动和任务\"><a href=\"#创建系统-产品设计模型的活动和任务\" class=\"headerlink\" title=\"创建系统/产品设计模型的活动和任务\"></a>创建系统/产品设计模型的活动和任务</h3><p>创建系统/产品设计模型的活动和任务如下：</p>\n<ol>\n<li>活动1：体系结构设计，该活动的目标是创建设计模型和部署模型，以及它们视角下的体系结构描述<br>任务1：标识节点和它们的网络配置，网络配置通常使用一种三元模式：客户端、数据库功能、业务/应用逻辑<br>任务2：标识子系统和它们的接口，目的是为了寻求一些复用的可能，而后随着设计模型的开发，在形成子系统结构中不断发现并烟花。<br>任务3：标识在体系结构方面有意义的设计类和它们的接口。标识在体系结构方面有意义的设计类的基本思想是：初始可以依据在体系结构方面有意义的分析类来标识一些体系结构上具有重要意义的设计类。标识在系统体系结构方面有意义的设计类时，应注意主动类往往是一类在体系结构方面具有重要意义的类。</li>\n<li>活动2：用况的设计。其中分析模型用况细化分析是活动的输入、对应输出用况细化设计。<br>为了实现用况设计的输入/输出，一般采用两种方法：<ol>\n<li>标识参与用况细化的设计类，首先基于分析模型研究相应用况细化分析中的分析类，来标识为细化这些分类所需要的设计类，然后基于用况的功能对每一个标识的设计类赋予相应的责任，最后为该细化创建一个类图，汇聚参与该用况细化的设计类，并给出类之间的关系。</li>\n<li>标识参与用况细化的子系统和接口。</li>\n</ol>\n</li>\n<li>活动3：类的设计。该活动的目标是完成用况细化设计中每一个类的角色设计，并完成有关每一类的非功能需求的设计。<br>任务1：概括描述设计类，该任务的输入为分析类/接口。<br>任务2：标识的操作，一般应依据分析类来标识设计类所提供的、所需要的操作，其中需要使用程序设计语言的语法来描述说标识的操作。<br>任务3：标识属性，该任务的目标是标识设计类所需要的属性，并使用程序设计语言的语法给出属性的描述。<br>任务4：标识关联和聚合。<br>任务5：标识泛化，基于分析模型中分析类之间的泛化，可以发现设计模型中的很多泛化。<br>任务6：描述方法，在设计期间一般用自然语言或适当的使用伪码对方法进行规约，但是在实现期间直接使用程序设计语言对方法进行规约。<br>任务7：描述状态，有些设计对象是受状态控制的，即它们的状态确定了它们接受一个消息的行为。在这种情况下，使用一个状态图描述一个对象的不同状态转移是有意义的。</li>\n<li>活动4：子系统的设计。该活动的目标是：确保子系统尽可能独立于其他子系统或它们的接口；确保子系统提供正确的接口；确保子系统实现了它的目标，即给出了该子系统提供的那些接口所定义的操作的细化。</li>\n</ol>\n<h3 id=\"设计模型包含的元素\"><a href=\"#设计模型包含的元素\" class=\"headerlink\" title=\"设计模型包含的元素\"></a>设计模型包含的元素</h3><p>RUP设计的主要结果是设计模型，它尽量保持该系统具有分析模型的结构，并作为系统实现的输入，包含以下四个元素：</p>\n<ol>\n<li>设计子系统和服务子系统，以及它们的接口、依赖和内容。</li>\n<li>设计类以及它们具有的操作、属性、关系及其实现的需求。</li>\n<li>用况细化设计。</li>\n<li>设计模型视角下的体系结构描述。</li>\n</ol>\n<h3 id=\"用况模型与分析模型的比较\"><a href=\"#用况模型与分析模型的比较\" class=\"headerlink\" title=\"用况模型与分析模型的比较\"></a>用况模型与分析模型的比较</h3><table>\n<thead>\n<tr>\n<th align=\"center\">用况模型</th>\n<th align=\"center\">分析模型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">使用客户语言来描述</td>\n<td align=\"center\">使用开发者语言来描述</td>\n</tr>\n<tr>\n<td align=\"center\">给出的是系统对外的视图</td>\n<td align=\"center\">给出的是系统对内的视图</td>\n</tr>\n<tr>\n<td align=\"center\">使用用况予以结构化，但给出的是外部视角下的系统结构</td>\n<td align=\"center\">使用衍型类予以结构化，当给出的是内部视角下的系统结构</td>\n</tr>\n<tr>\n<td align=\"center\">可以作为客户与开发者之间关于“系统应该做什么，不应该做什么”的契约</td>\n<td align=\"center\">可以作为开发者理解系统如何勾画、如何设计和如何实现的基础</td>\n</tr>\n<tr>\n<td align=\"center\">在需求之间可能存在一些冗余、不一致和冲突等问题</td>\n<td align=\"center\">在需求之间不应存在冗余、不一致和冲突问题</td>\n</tr>\n<tr>\n<td align=\"center\">捕获的是系统的功能，包括在体系结构方面有意义的功能</td>\n<td align=\"center\">给出的是细化的系统功能，包括在体系结构方面具有意义的功能</td>\n</tr>\n<tr>\n<td align=\"center\">定义了一些进一步需要在分析模型中予以分析的</td>\n<td align=\"center\">定义了用况模型中每一个用况的细化</td>\n</tr>\n</tbody></table>\n<h3 id=\"RUP实现活动\"><a href=\"#RUP实现活动\" class=\"headerlink\" title=\"RUP实现活动\"></a>RUP实现活动</h3><p>目标：基于设计类和子系统生成构件；对构件进行单元测试，进行集成和连接；把可执行的构件映射到部署模型。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">输入</th>\n<th align=\"center\">活动</th>\n<th align=\"center\">执行者</th>\n<th align=\"center\">输出</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">设计模型、部署模型、体系结构描述【设计模型、部署模型角度】</td>\n<td align=\"center\">实现体系结构</td>\n<td align=\"center\">体系结构设计者</td>\n<td align=\"center\">构件【概述】、体系结构描述【实现模型、部署模型角度】</td>\n</tr>\n<tr>\n<td align=\"center\">补充需求、用况模型、设计模型、实现模型【当前建造】</td>\n<td align=\"center\">集成系统</td>\n<td align=\"center\">系统集成者</td>\n<td align=\"center\">集成建造计划、实现模型【连续的建造】</td>\n</tr>\n<tr>\n<td align=\"center\">集成建造计划、体系结构描述【实现模型角度】、设计子系统【已设计】、接口【已设计】</td>\n<td align=\"center\">实现子接口</td>\n<td align=\"center\">构件工程师</td>\n<td align=\"center\">实现子系统【建造完成】、接口【建造完成】</td>\n</tr>\n<tr>\n<td align=\"center\">设计类【已设计】、接口【由设计类提供】</td>\n<td align=\"center\">实现类</td>\n<td align=\"center\">构件工程师</td>\n<td align=\"center\">构件【完成】</td>\n</tr>\n<tr>\n<td align=\"center\">构件【完成】、接口</td>\n<td align=\"center\">完成单元测试</td>\n<td align=\"center\">构件工程师</td>\n<td align=\"center\">构件【已完成单元测试】</td>\n</tr>\n</tbody></table>\n<h3 id=\"RUP测试活动\"><a href=\"#RUP测试活动\" class=\"headerlink\" title=\"RUP测试活动\"></a>RUP测试活动</h3><p>RUP的测试包括内部测试、中间测试和最终测试</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">输入</th>\n<th align=\"center\">活动</th>\n<th align=\"center\">输出</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">补充需求、用况模型、分析模型、设计模型、实现模型、体系结构的描述</td>\n<td align=\"center\">计划测试</td>\n<td align=\"center\">测试计划</td>\n</tr>\n<tr>\n<td align=\"center\">补充需求、用况模型、分析模型、设计模型、实现模型、体系结构描述、测试计划</td>\n<td align=\"center\">设计测试</td>\n<td align=\"center\">测试用况 测试过程</td>\n</tr>\n<tr>\n<td align=\"center\">测试用况、测试过程、实现模型</td>\n<td align=\"center\">实现测试</td>\n<td align=\"center\">测试构件</td>\n</tr>\n<tr>\n<td align=\"center\">测试用况、测试过程、测试构件、实现模型</td>\n<td align=\"center\">执行集成测试</td>\n<td align=\"center\">缺陷</td>\n</tr>\n<tr>\n<td align=\"center\">测试用况、测试过程、测试构件、实现模型</td>\n<td align=\"center\">执行系统测试</td>\n<td align=\"center\">缺陷</td>\n</tr>\n<tr>\n<td align=\"center\">测试用况、测试模型、缺陷</td>\n<td align=\"center\">评价测试</td>\n<td align=\"center\">测试评价</td>\n</tr>\n</tbody></table>\n<h2 id=\"软件测试\"><a href=\"#软件测试\" class=\"headerlink\" title=\"软件测试\"></a>软件测试</h2><h3 id=\"软件测试目标与软件测试过程模型\"><a href=\"#软件测试目标与软件测试过程模型\" class=\"headerlink\" title=\"软件测试目标与软件测试过程模型\"></a>软件测试目标与软件测试过程模型</h3><h4 id=\"软件测试及目标\"><a href=\"#软件测试及目标\" class=\"headerlink\" title=\"软件测试及目标\"></a>软件测试及目标</h4><p>软件测试的定义为：按照特定规程发现软件错误的过程。其目的是检验它是否满足规定的需求，或清楚了解预期结构与实际结果之间的差异</p>\n<h4 id=\"软件测试与软件调试之间的区别\"><a href=\"#软件测试与软件调试之间的区别\" class=\"headerlink\" title=\"软件测试与软件调试之间的区别\"></a>软件测试与软件调试之间的区别</h4><p>软件测试与软件调试相比，在目的、技术和方法等方面都存在很大区别，主要表现在以下几个方面。</p>\n<ol>\n<li>测试从一个侧面证明程序员的”失败”.调试是为了证明程序员的正确。</li>\n<li>测试以已知条件开始，使用预先定义的程序且有预知的结果，不可预见的仅是程序是否通过。调试一般是以不可知的内部条件开始，除统计性调试外，结果是不可预见的。</li>\n<li>测试是有计划的，并要进行测试设计。调试是不受时间约束的。</li>\n<li>测试是一个发现错误、改正错误、重新测试的过程。调试是一个推理过程。</li>\n<li>测试的执行是有规程的。调试的执行往往要求程序员进行必要推理。</li>\n<li>测试经常是由独立的测试组在不了解软件设计的条件下完成的。调试必须由了解详细设计的程序员完成。</li>\n<li>大多数测试的执行和设计可由工具支持。调试时，程序员能利用的主要工具是调试器。</li>\n</ol>\n<h4 id=\"测试过程模型\"><a href=\"#测试过程模型\" class=\"headerlink\" title=\"测试过程模型\"></a>测试过程模型</h4><p>软件测试是一个有程序的过程，包括测试设计、测试执行以及测试结果比较。测试过程模型可分为三类：环境模型、被测对象模型和错误模型。</p>\n<ol>\n<li>环境模型：是对程序运行环境的抽象。程序运行环境又包括支持其运行的硬件、固件和软件，如计算机、终端设备、网卡、操作系统、编译系统、实用程序等。在软件测试过程中，建立环境模型的主要目的是，确定所发现的错误是否为环境造成的。</li>\n<li>被测对象模型：该模型是从测试的角度对程序的抽象。为了测试，必须简化程序，形成被测程序的抽象版本、即对象模型。</li>\n<li>错误模型：该模型是对程序中的错误及其分类的抽象。在软件测试中，往往需要定义“什么是错误”、“什么是一般性错误”、“什么是严重性错误”等，即要给出“错误模型”。</li>\n</ol>\n<h3 id=\"软件测试技术\"><a href=\"#软件测试技术\" class=\"headerlink\" title=\"软件测试技术\"></a>软件测试技术</h3><ol>\n<li><p>测试覆盖及其他们之间的基本关系<br>软件测试技术大体上可分为两大类：一类是白盒测试技术，又称为结构测试技术，典型的是路径测试技术；另一种是黑盒测试技术，又称为功能测试技术，包括事务处理流程技术、状态测试技术、定义域测试技术等。白盒测试技术依据的是程序的逻辑结构，而黑盒测试技术依据的是软件行为的描述。</p>\n</li>\n<li><p>路径测试技术的分类</p>\n<p> 测试覆盖包括路径覆盖、分支覆盖、条件覆盖与条件组合覆盖。</p>\n<ol>\n<li>路径覆盖：执行所以有可能穿过程序控制流程的路径。在路径测试中，该度量是最强的，一般是不可实现的。</li>\n<li>语句覆盖：至少执行程序中所有语句一次</li>\n<li>分支覆盖：至少将程序中的每一个分支执行一次</li>\n<li>条件覆盖与条件组合覆盖：条件覆盖是指每个判定中所有的可能的条件的取值至少执行一次；条件组合覆盖是指设计足够的测试用例，使每个判定中所有可能的条件取值组合至少执行一次。</li>\n</ol>\n<p> 这四种测试覆盖的测试覆盖率由弱到强的顺序是：语句覆盖 &lt; 分支覆盖 &lt; 条件组合覆盖 &lt; 路径覆盖</p>\n</li>\n<li><p>事务流测试步骤</p>\n<p> 事务流测试步骤具体如下。<br> 第一步：获得事务流程图。<br> 第二步：浏览、复审。<br> 第三步：用例设计。<br> 第四步：测试执行。</p>\n</li>\n<li><p>运用等价类划分技术进行测试的步骤</p>\n<p> 具体测试步骤如下。<br> 第一步：建立等价类表<br> 第二步：为有效等价类设计测试用例<br> 第三步：为无效等价类至少设计一个测试用例</p>\n</li>\n<li><p>边界值分析的使用原则</p>\n<p> 边界值分析是一种常用的黑盒测试技术。使用边界值分析在设计测试用例时，可以遵循以下原则。</p>\n<ol>\n<li>如果某个输入条件规定了输入值的范围，则应该选择正好等于边界值的数据，以及刚刚超过边界值的数据作为测试数据。</li>\n<li>如果某个输入条件规定了值的个数，则可用最大个数、最小个数、比最大个数多1、比最小个数少1的数据作为测试数据</li>\n<li>根据规格说明的每个输出条件，使用前面的原则1</li>\n<li>根据规格说明的每个输出条件，使用前面的原则2</li>\n<li>如果程序的规格说明中，输入域或输出域是有序集合，在实践中则经常选取集合的第一个元素、最后一个元素以及典型元素作为测试用例。</li>\n<li>如果程序中使用了内部数据结构，则应该选择这个内部数据结构的边界上的值作为测试用例。</li>\n<li>分析规格说明，找出其他可能的边界条件。</li>\n</ol>\n</li>\n<li><p>使用因果图生成测试用例的步骤</p>\n<p> 因果图技术是通过为判定表的每一列设计一个测试用例，从而实现测试用例的设计与选择的。该方法生成测试用例的基本步骤如下。</p>\n<ol>\n<li>通过软件规格说明书的分析，找出一个模块的原因和结果，并给每个原因和结果赋予一个标识符</li>\n<li>分析原因与结果之间以及原因之间对应的关系，并画出因果图。</li>\n<li>在因果图上标识出一些特定的约束或限制条件。</li>\n<li>把因果图转换成判定表。</li>\n<li>把判定表的每一列拿出来作为依据，设计测试用例。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"软件测试步骤\"><a href=\"#软件测试步骤\" class=\"headerlink\" title=\"软件测试步骤\"></a>软件测试步骤</h3><ol>\n<li><p>单元测试<br> 单元测试主要检验软件设计的最小单元—模块。该测试以详细设计文档为指导，测试模块内的重要控制路径。一般来说，单元测试往往采用白盒测试技术。</p>\n</li>\n<li><p>集成测试<br> 集成测试是软件组装的一个系统化技术，其目标是发现与接口有关的错误，将经过单元测的模块构成一个满足设计要求的软件结构。集成测试集中于模块组合的功能和软件结构检验。集成测试可“自顶向下”地进行，称为自顶向下的集成测试；也可以“自底向上”地进行测试，称为自底向上的集成测试</p>\n</li>\n<li><p>有效性测试<br> 有效性测试的目标是发现软件实现的功能与需求规格说明书不一致的错误。因此有效性测试通常采用黑盒测试技术。</p>\n</li>\n<li><p>系统测试<br> 系统测试验证将软件融于更大系统中时整个系统的有效性。</p>\n</li>\n</ol>\n<h2 id=\"软件生存周期过程与管理\"><a href=\"#软件生存周期过程与管理\" class=\"headerlink\" title=\"软件生存周期过程与管理\"></a>软件生存周期过程与管理</h2><h3 id=\"软件生存周期过程概述\"><a href=\"#软件生存周期过程概述\" class=\"headerlink\" title=\"软件生存周期过程概述\"></a>软件生存周期过程概述</h3><ol>\n<li><p>过程分类</p>\n<p> 按过程主体把软件生存周期过程分为以下几个过程。</p>\n<ol>\n<li>基本过程：是指那些与软件生产直接相关的活动集。该过程又可分为获取过程、供应过程、开发过程、运行过程和维护过程。</li>\n<li>支持过程：是指有关各方按他们的目标所从事的一系列相关支持活动集。该过程又可分为文档过程、配置管理过程、质量保证过程、验证过程、确认过程、联合评审过程、审计过程和问题解决过程。</li>\n<li>组织过程：是指那些与软件生产组织有关的活动集。该过程又可分为设计过程、基础设施过程、培训过程和改进过程。</li>\n</ol>\n</li>\n<li><p>系统语境的过程类<br> 系统语境的过程类包含四个过程组，分别是协议过程组、项目过程组、技术过程组和组织上项目使能过程组。</p>\n<ol>\n<li>协议过程组包含两个过程：获取过程和供应过程。</li>\n<li>项目过程组包含七个过程：项目规划过程、项目评价过程、决策管理过程、风险管理过程、配置管理过程、信息管理过程和测量过程。</li>\n<li>技术过程组包含11个过程：利益攸关方需求定义过程、系统需求分析过程、系统体系结构设计过程、实现过程、系统集成过程、系统测试过程、软件安装过程、软件接受支持过程、软件运行过程、软件维护过程和软件销毁过程。</li>\n<li>组织上使能过程组包含五个过程：生存周期模型管理过程、基础设施管理过程、项目包管理过程、人力资源管理过程和质量管理过程。</li>\n</ol>\n</li>\n<li><p>组织上使能过程的作用。<br> 组织上使能的过程一般来说是组织层面上的工作，为项目的执行提供基本保障。该过程包含五个子过程。</p>\n<ol>\n<li>生存周期模型管理过程：其任务为过程建立、过程评估、过程改进。</li>\n<li>基础设施管理过程：其任务为过程实现、基础设施的建立、基础设施的维护。</li>\n<li>项目包管理过程：项目初始化、项目包评估、项目结束处理。</li>\n<li>人力资源管理过程：其任务为技能标识、技能开发、技能获取和供给、知识管理。</li>\n<li>质量管理过程：其任务为质量管理、质量管理纠正措施。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"过程描述\"><a href=\"#过程描述\" class=\"headerlink\" title=\"过程描述\"></a>过程描述</h3><p>软件验证过程包括两个活动：过程实现和验证。其中验证活动有五个任务：需求验证、设计验证、代码验证，集成验证和文档验证。</p>\n<p>一个过程可通过过程意图，期望的结果以及到达过程结果需要执行的活动和任务来描述。对于一个过程的完整技术上的描述，还应包括：达到过程意图和实现过程结果的方法或规程，以及过程和活动文档。</p>\n<h3 id=\"应用说明\"><a href=\"#应用说明\" class=\"headerlink\" title=\"应用说明\"></a>应用说明</h3><ol>\n<li><p>系统和软件的关系</p>\n<p> 在《ISO/IEC系统与软件工程-软件生产周期过程12207-2008》标准中，把软件认为是整个系统的一个组成从部分，执行系统中所确定的功能主要包括三大功能：控制功能、耦合功能以及软件本身提供的功能。由于软件通常存在与一个系统的上下文中，因此软件产品或服务一般可被认为是系统的一个项或称为系统元素。</p>\n</li>\n<li><p>剪裁过程及应用</p>\n<p> 剪裁过程是使剪裁这一标准过程慢速以下特定情况或因素。</p>\n<ol>\n<li>围绕一个组织，其中该组织在一个协议中使用了这一标准</li>\n<li>影响一个项目，其中要求该项目满足一个引用该标准的协议</li>\n<li>反映一个组织的需要，其中该组织要供给产品或服务</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"软件生存周期模型\"><a href=\"#软件生存周期模型\" class=\"headerlink\" title=\"软件生存周期模型\"></a>软件生存周期模型</h3><ol>\n<li><p>瀑布模型</p>\n<p> 瀑布模型是将软件生存周期各个活动规定为按固定顺序链接的若干阶段的模型。这一模型规定了个开发阶段的活动：系统需求、软件需求、需求分析、设计、编码、测试和运行，并且自上而下具有相互衔接的固定顺序；还规定了每一个阶段的输入，即工作对象以及本阶段的工作成果，作为输出传送到下一阶段。</p>\n<p> 瀑布模型的提出，对软件工程的主要贡献如下。</p>\n<ol>\n<li>在决定系统怎样做之前存在一个需求阶段，它鼓励对系统做什么进行规约。</li>\n<li>在系统构造之前存在一个需求阶段，它鼓励规划系统结构。</li>\n<li>在每一阶段结束时进行评审，从而允许获取方和用户的参与。</li>\n<li>前一步可以作为下一步被认可的、文档化的基线，并允许基线和配置早期接受控制。</li>\n</ol>\n<p> 瀑布模型的主要问题是：</p>\n<ol>\n<li>要求客户能完整、正确和清晰地表达他们的需求；并要求开发人员一开始就要理解这一应用。</li>\n<li>由于需求的不稳定性，使设计、编码和测试阶段都可能发生延期；并且当项目接近结束时，出现了大量的集成和测试工作。</li>\n<li>在开始的阶段中，很难评估真正的进度状态；并且直到项目结束之前都不能演示系统的能力。</li>\n<li>在一个项目的早期开发阶段，过分地强调了基线和里程碑处的文档；并可能需要花费更多的时间用于建立一些用处不大的文档。</li>\n</ol>\n</li>\n<li><p>增量模型</p>\n<p> 增量模型是一种非整体开发的模型。软件在该模型中逐渐开发出来，开发出一部分，向用户展示一部分，可让用户及早看到部分软件，及早发现问题。该模型具有较大的灵活性，适合软件需求不明确、设计方案有一定风险的软件项目。</p>\n</li>\n<li><p>演化模型</p>\n<p> 该模型主要针对事先不能完整定义需求的软件开发在用户提出待开发系统的核心需求的基础上，软件开发人员按照这一要求，首先开发一个核心系统并投入运行，以便用户能够有效地提出反馈，即精化系统、增强系统能力的需求；接着，软件开发人员根据用户反馈，实施开发的迭代过程；每一迭代过程均由需求、设计、编码、测试、集成等阶段组成，为整个系统增加一个可定义的，可管理的子集；如果在一次迭代中，有的需求不能满足用户的要求，可在下一次迭代中予以修正。</p>\n<p> 主要特征：该模型显式地把需求获取扩展到需求阶段，既为了第二个构造增量，使用了第一个构造增量来精化需求。演化模型在一定程度上可以减少软件开发活动的盲目性。<br>不足之处：在演化模型的使用中，即使很好地理解了需求或设计，也很容易弱化需求分析阶段的工作。</p>\n</li>\n<li><p>螺旋模型</p>\n<p> 螺旋模型将瀑布模型与增量模型结合起来，加入了两种模型均忽略了的风险分析，弥补了这两种模型的不足。因而它是一种风险驱动的模型。螺旋模型将开放过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合。</p>\n<p> 螺旋模型关注解决问题的基本步骤，即标识问题，标识一些可选方案，选择一个最佳方案，遵循动作步骤并实施后续工作。其一个突出特征是，在开发的迭代中实际上只有一个迭代过程真正开发了可交付的软件。螺旋模型与演化模型和增量模型相比，同样适用了瀑布模型作为一个嵌入的过程，但螺旋模型所关注的阶段以及它们的活动是不同的。如果项目的开发风险很大或客户不能确定系统需求，在更广泛的意义上来讲，还包括一个系统或系统类型的要求，这时螺旋模型就是一个很好的生存周期模型。</p>\n</li>\n<li><p>喷泉模型</p>\n<p> 喷泉模型体现了软件创建所固有的迭代和无间隙的特征。该模型主要用于支持面向对象技术的软件开发。由于对象概念的引入，使分析、设计、实现之间的表达没有明显间隙。</p>\n</li>\n</ol>\n<h3 id=\"过程规划与管理\"><a href=\"#过程规划与管理\" class=\"headerlink\" title=\"过程规划与管理\"></a>过程规划与管理</h3><ol>\n<li><p>创建一个软件项目生存周期过程的步骤</p>\n<ol>\n<li>选择软件生存周期模型</li>\n<li>细化所选择的生存周期模型</li>\n<li>为每一个活动或任务标识合适的实例数目</li>\n<li>确定活动的时序关系，并检查信息流</li>\n<li>建立过程计划的文档</li>\n</ol>\n</li>\n<li><p>软件评估中应考虑的影响因素</p>\n<ol>\n<li>不管做怎么样的决策，都必须对所采取的的措施对生存周期过程所产生的影响进行评审，以便保证项目获得好的结果。在这一评估中，应考虑以下几方面的影响。<ol>\n<li>所要求的的“返工”</li>\n<li>资源需求</li>\n<li>实施时间</li>\n<li>对项目和用户的益处</li>\n<li>员工情绪</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"集成化能力成熟度模型（CMMI）\"><a href=\"#集成化能力成熟度模型（CMMI）\" class=\"headerlink\" title=\"集成化能力成熟度模型（CMMI）\"></a>集成化能力成熟度模型（CMMI）</h2><h3 id=\"背景和原理\"><a href=\"#背景和原理\" class=\"headerlink\" title=\"背景和原理\"></a>背景和原理</h3><ol>\n<li><p>过程改善</p>\n<p> 历史过程改善，是指人为设计的一个活动程序，其目的是改进组织的过程性能和成熟度，并改进这一程序的结果</p>\n</li>\n<li><p>过程域、专用目标和共用目标</p>\n<p> 过程域是一个业务域中一束相关的实践，当它们一起得以实现时，就满足被认为对该过程域的改善具有重要作用的一组条件<br> 专用目标是用于描述满足该过程域必须呈现的一些独有特征。经可以用于帮助确定一个过程域是否得以满足。<br> 共用目标用于描述产现制度化的该过程必须呈现的特征，仅用于确定一个过程域是否得以满足。</p>\n</li>\n</ol>\n<h3 id=\"CMMI的模型部件\"><a href=\"#CMMI的模型部件\" class=\"headerlink\" title=\"CMMI的模型部件\"></a>CMMI的模型部件</h3><table>\n<thead>\n<tr>\n<th align=\"center\">过程域类名</th>\n<th align=\"left\">包括的过程域</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">项目管理类</td>\n<td align=\"left\">项目规划<br/>项目监控<br/>定量项目管理<br/>集成项目管理<br/>风险管理<br/>提供方协议管理</td>\n</tr>\n<tr>\n<td align=\"center\">工程类</td>\n<td align=\"left\">需求开发<br/>需求管理<br/>技术解决方案<br/>产品集成<br/>确认<br/>验证</td>\n</tr>\n<tr>\n<td align=\"center\">支持类</td>\n<td align=\"left\">配置管理<br/>过程和产品质量保证<br/>测量与分析<br/>原因分析与解决<br/>决策分析与解决</td>\n</tr>\n<tr>\n<td align=\"center\">过程管理类</td>\n<td align=\"left\">组织过程定义<br/>组织过程性能<br/>组织过程培训<br/>组织过程关注<br/>组织创新与部署</td>\n</tr>\n</tbody></table>\n<h3 id=\"CMMI的等级\"><a href=\"#CMMI的等级\" class=\"headerlink\" title=\"CMMI的等级\"></a>CMMI的等级</h3><ol>\n<li><p>能力等级的组成</p>\n<p> 能力等级是用来表征组织对一个过程域的改善，是不断改善一个给定过程域的一种手段。在CMMI中，针对每个过程域设定了6个能力等级，即0级：未完成级；1级：已执行级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：待续优化级。</p>\n</li>\n<li><p>成熟度等级的组成</p>\n<p> 在CMMI中，应用于一个组织过程改善的成熟度等级有5个。即1级：初始级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：持续优化级</p>\n</li>\n<li><p>能力等级与成熟度等级之间的基本关系</p>\n<ol>\n<li>能力等级与成熟度等级是互补的关系，两者都是一种过程改善路径，即表征组织对单一过程域的改进。</li>\n<li>成熟度等级的路径可使组织针对单一过程域不断改善一组相关过程域，即表征组织对一组过程域的改进。</li>\n<li>两种等级的2-5级使用了同样的名字</li>\n</ol>\n</li>\n<li><p>达到各共用目标要实施的共同实践</p>\n<p> 达到公用目标2、共用目标3、共用目标4和共用目标5所要实施的共同实践如下表所示</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">所要实施的共用实践</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">共用目标2：把过程制度化为一个管理过程</td>\n<td align=\"center\">GP2.1 建立组织策略<br/>GP2.2 规划过程<br/>GP2.3 提供资源<br/>GP2.4 指派责任<br/>GP2.5 培训人员<br/>GP2.6 管理配置<br/>GP2.7 标识相关利益方的参与<br/>GP2.8 监控过程<br/>GP2.9 客观地评估符合性<br/>GP2.10 从高层管理的视觉评审状态<br/></td>\n</tr>\n<tr>\n<td align=\"center\">共用目标3：把过程制度化为一个已定义过程</td>\n<td align=\"center\">GP3.1 建立一个已定义的过程<br/>GP3.2 收信进信息 所要实施的共用实践</td>\n</tr>\n<tr>\n<td align=\"center\">共用目标4：把过程制度化为一个已定量管理过程</td>\n<td align=\"center\">GP4.1 为该过程建立定量目的<br/>GP4.2 使子过程性能达到稳定</td>\n</tr>\n<tr>\n<td align=\"center\">共用目标5：把过程制度化为一个持续优化过程</td>\n<td align=\"center\">GP5.1 确保不断进行过程改善<br/>GP5.2 收集问题的根本原因</td>\n</tr>\n</tbody></table>\n<p>完结</p>\n","site":{"data":{}},"excerpt":"<p>如何管理一个项目，这是个沉重的话题。实际上，目前很多人都是凭借经验进行项目管理和开发，事实上管理项目是有着大量的方法论，这些方法论整理起来被人归纳成了一个学科，名字叫做<code>软件工程</code>，接下来的内容将会归纳总结里面的一些要点，如果你有意成为一个项目管理者，请必须了解一下这些基础知识。</p>","more":"<h2 id=\"软件系统模型\"><a href=\"#软件系统模型\" class=\"headerlink\" title=\"软件系统模型\"></a>软件系统模型</h2><p>开始一个项目之前，你需要做好准备，那就是建立系统模型，有了抽象的模型，才会有具像的实现。</p>\n<ul>\n<li>在软件开发中，软件系统模型大体可分为两类：<code>概念模型</code>和<code>软件模型</code>。</li>\n<li>概念模型是创建在需求层上的，它描述了系统是什么。</li>\n<li>软件模型是建立在抽象层上的，它描述了实现概念模型的软件解决方案。</li>\n<li>软件模型可进一步分为<code>设计模型</code>、<code>实现模型</code>和<code>部署模型</code>。</li>\n</ul>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h3><p> 一个完整的需求需要有以下特征：</p>\n<ol>\n<li>必要的：该需求是用户所要求的（产品经常会提一些伪需求，比如说在帖子列表添加个一键评价，点击了就回复666，但实际上没有用户想毫无感情地666，所以这是伪需求，不满足该条件的请拒绝）；</li>\n<li>无歧义的：该需求只能用一种方式解释（这个就不用解释了，遇到有歧义的需求请问清楚）；</li>\n<li>可测的：该需求可以进行测试；</li>\n<li>可跟踪的：该需求可以从一个开发阶段跟踪到另一个开发阶段（意思就是这个需求不会因为开发的进行变得模糊、不清晰）；</li>\n<li>可测量的：该需求是可测量的（意思就是实现这个需求不能无限耗费人力物力，说好这个需求两个人一天能做完，就两个人一天真的能做完）。</li>\n</ol>\n<h3 id=\"类别\"><a href=\"#类别\" class=\"headerlink\" title=\"类别\"></a>类别</h3><ol>\n<li>功能需求：系统或系统构件必须执行的功能</li>\n<li>非功能需求：分为性能需求、外部接口需求、设计约束需求、质量属性需求。</li>\n</ol>\n<h3 id=\"怎么发现需求\"><a href=\"#怎么发现需求\" class=\"headerlink\" title=\"怎么发现需求\"></a>怎么发现需求</h3><table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">情况</th>\n<th align=\"center\">成功条件</th>\n<th align=\"center\">风险</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">自悟</td>\n<td align=\"center\">自己想</td>\n<td align=\"center\">要比你的最终客户拥有更多的一样弄领域和过程方面的知识和丰富的想象力，也就是你要比你的用户更加清楚用户要啥</td>\n<td align=\"center\">无法验证你想出来的东西是不是你的用户想要的</td>\n</tr>\n<tr>\n<td align=\"center\">交谈</td>\n<td align=\"center\">跟你的客户聊</td>\n<td align=\"center\">你能提出正确的问题，回答人能揭示需求本质的能力</td>\n<td align=\"center\">可能会获得一堆需求，而且越来越多，不断增长，可能还会推翻你之前的需求，可能导致超出项目成本和进度的限制<s>（甚至可能被你的开发揍一顿）</s></td>\n</tr>\n<tr>\n<td align=\"center\">观察</td>\n<td align=\"center\">你去看你的用户怎么用你的软件</td>\n<td align=\"center\">你需要有洞察事物本质的能力</td>\n<td align=\"center\">1. 你的用户会抵触你的观察（很明显侵犯隐私了）2. 用户会觉得你是不是这软件没做好或者哪里需求不到位所以老是来看我，对你的软件产生怀疑</td>\n</tr>\n<tr>\n<td align=\"center\">小组会</td>\n<td align=\"center\">项目组的人全部叫出来开会讨论需求</td>\n<td align=\"center\">你小组的人有不同观点，并且有良好的发现需求的能力，能揭示需求中存在的问题，最重要的是需求能跟用户达成共识</td>\n<td align=\"center\">会议组织不到位就凉了，而且天天开会你的项目组的人也受不了，可能会提出矛盾需求</td>\n</tr>\n<tr>\n<td align=\"center\">提炼</td>\n<td align=\"center\">针对已有的部分需求文档，看线上反馈情况，进行提炼</td>\n<td align=\"center\">你需要有想象力和需求标识能力，包括熟悉相关的技术标准</td>\n<td align=\"center\">跟自悟一样，你不能知道你发现的需求是否是对的</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"需求规约\"><a href=\"#需求规约\" class=\"headerlink\" title=\"需求规约\"></a>需求规约</h3><p>需求规约就是怎么写一个需求表，因为形式很多，所以最好就根据实际情况进行，这里不做规定，但是必须包含以下几个特征</p>\n<ol>\n<li>重要性和稳定性：需求要根据重要程度和稳定程度分优先级，例如：基本需求、可选需求和期望需求。</li>\n<li>可修改的：在不过多地影响其他需求的情况下，可以容易地修改一个单一需求。</li>\n<li>完整的：没有被遗漏的需求。</li>\n<li>一致的：不存在互斥的需求。</li>\n</ol>\n<p>为什么需求规约很重要？（概念性东西）</p>\n<ol>\n<li>是软件开发组织和用户之间一份事实上的技术合同书，是产品功能及其环境的体现。</li>\n<li>对于项目的其余大多数工作，需求规约是一个管理控制点。</li>\n<li>对于产品/系统的设计，需求规约是一个正式的、受控的起点。</li>\n</ol>\n<h2 id=\"结构化方法\"><a href=\"#结构化方法\" class=\"headerlink\" title=\"结构化方法\"></a>结构化方法</h2><h3 id=\"结构化需求分析\"><a href=\"#结构化需求分析\" class=\"headerlink\" title=\"结构化需求分析\"></a>结构化需求分析</h3><ol>\n<li><p>为什么要这么做？</p>\n<p> 为了应对三大挑战：</p>\n<pre><code> - 问题空间理解。（假如让你开发一个八字排盘App，但是你又不懂八字，所以要开发出一个高质量、满足用户要求的App，就不容易了）\n - 人与人之间的通信。（开发过程长、活动多、任务重，项目组成员多，直接面对面沟通起来难免有遗漏、误解等，所以这也是一个挑战）\n - 需求的变化性。（需求是不断变化的，所以这是软件开发人员面临的挑战）\n</code></pre>\n<p> 一种好的需求技术应该具有以下基本特征：</p>\n<pre><code> 1. 提供方便通信的机子，例如，在不同开发阶段，使用对相关人员易于理解的语言。\n 2. 鼓励需求分析人员使用问题空间的术语思考问题，编写文档。\n 3. 提供定义系统边界的方法。\n 4. 提供支持抽象的基本机制，例如，&quot;划分&quot;，&quot;功能抽象&quot;，&quot;结构抽象&quot;等。\n 5. 为需求分析人员提供多种可供选择的方案。\n 6. 提供特定的技术，适应需求的变化等。\n</code></pre>\n</li>\n<li><p>几种基本术语的解释</p>\n<p> (1) 数据流：数据流是数据的流动，用于表达在分析中所要使用的、用于表达”客体”的信息，用箭头表示。<br> 大概长这样：</p>\n <img width=50px src='https://i.loli.net/2019/10/21/wM2SkZXGDY46lQh.png'>\n (2) 加工：加工是数据变换的单元，即它接受输入的数据，对其进行处理，并产生输出。\n 大概长这样\n <img width=50px src='https://i.loli.net/2019/10/21/mcfwVCaJI1Sn8kZ.png'>\n (3) 数据存储：数据存储是数据的静态结构。\n 大概长这样(可以是横的或者竖的)\n <img width=50px src='https://i.loli.net/2019/10/21/xbXKc45RlYpnNB9.png'>\n (4) 数据源和数据潭: 数据源是数据流的起点，数据潭是数据流的归宿地。数据源和数据潭是系统之外的实体，可以是人、物或其他软件系统。\n 大概长这样\n <img width=50px src='https://i.loli.net/2019/10/21/LiwWbnSAs7Pqzoh.png'></li>\n<li><p>数据流图</p>\n<p> 把上面的元素组成起来就是数据流图了<br> 大概长这样</p>\n <img width=70% src=\"https://i.loli.net/2019/10/21/wDdaFiLe9Ps6UzA.png\">\n\n<p> 几个要点：1）数据流起到连接其他实体的作用，实体可以是加工、数据存储、数据源和数据潭；2）加工之间可以有多个数据流，这些数据流之间可以没有任何关系，数据流图也不表明他们的先后次序；3）对于一个比较大的软件系统，往往需要采用多层次的数据流图。</p>\n</li>\n<li><p>建模过程</p>\n<ol>\n<li>建立系统环境图，确立系统语境</li>\n<li>自顶向下，逐步求精，建立系统的层次数据流图</li>\n<li>定义数据字典。数据字典有3种基本结构表示：顺序结构，选择结构，重复结构。<ul>\n<li>顺序结构是指数据A由数据B和数据C顺序构成的，并记为”+”。例如：学生成绩=姓名+性别+学号+科目+成绩，其中”=”号表达的是”定义为”.</li>\n<li>选择结构是指由数据A是由数据B或数据C定义的，即数据B不可能同时是B和C，并记为“|”，例如：性别=男|女</li>\n<li>重复结构是指数据A是由多个重复出现的数据B构成的，并记为”| |”，例如：学生成绩表=|学生成绩|<img width=\"50%\" src=\"https://i.loli.net/2019/10/21/43hSWgZPmVirHfA.png\"></li>\n</ul>\n</li>\n<li>描述加工：该步的目标为依据系统的数据流图，给出其中每一加工的小说明。加工可以有3种表达工具。<ol>\n<li>结构化自然语言（自然语言描述）</li>\n<li>判定表: 由条件类别，条件组合，操作，操作执行构成。举例如图<img width=50% src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D22%2C0%2C590%2C389%3Bc0%3Dbaike80%2C5%2C5%2C80%2C26/sign=d64b6fc508087bf469a30da9cfe16500/42166d224f4a20a48dfd6c499a529822730ed059.jpg\"></li>\n<li>判定树。举例如图<img width=60%  src=\"https://i.loli.net/2019/10/21/COmGSet5I61lFsH.png\"></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>注意事项：</p>\n<ol>\n<li>模型平衡问题</li>\n<li>信息复杂性控制问题</li>\n</ol>\n</li>\n<li><p>需求验证<br> 验证需求规格说明书中的每一单一需求是否满足5个性质，即必要性、无歧义性、可测性、可跟踪性、可测量性；验证需求规格说明是否满足4个性质，即重要性和稳定程度、可修改性、完整性和一致性。在必要时还需要验证其他特性，如设计无关性。</p>\n</li>\n</ol>\n<h3 id=\"结构化设计\"><a href=\"#结构化设计\" class=\"headerlink\" title=\"结构化设计\"></a>结构化设计</h3><h4 id=\"总体设计步骤\"><a href=\"#总体设计步骤\" class=\"headerlink\" title=\"总体设计步骤\"></a>总体设计步骤</h4><p>结构化设计方法基于<code>自顶向下，功能分解</code>的基本原则，针对两种不同类型的数据流图，分别提出了变换设计和事务设计。其中，变换设计的目标是将变换型数据流图映射为模块结构图，而事务设计的目标是将事务型数据流图映射为模块结构图。</p>\n<ol>\n<li><p>变换型数据流图和事务性和数据流图<br>（1）变换型数据流图：具有比较明显的输入部分和变换部分之间的界面、变换部分和输出部分之间界面的数据流图，称为变换型数据流图；<br><img src=\"https://www.sytm.net/ueditor/net/upload/2013-12-31/bdae1434-8b79-4209-b818-2502c7ea3bee.png\"><br>（2）事务型数据流图：数据到达一个加工T，该加工T根据输入的值，在其后若干动作序列中选出一个来执行，这类数据流图成为事务型数据流图。<br><img src=\"https://www.sytm.net/ueditor/net/upload/2013-12-31/142b2c91-a9ad-4c6e-b075-ecd6a900ee63.png\"></p>\n</li>\n<li><p>总体设计分为3个阶段。第一阶段为初始设计，在对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。第二阶段为精化设计，依据模块“高内聚低耦合”的原则精化初始的模块结构图，并设计其中的全局数据结构和每一模块的接口。第三阶段为复审阶段，对前两个阶段所得到的高层软件结构进行复审，必要时还可能需要对该软件结构做一些精化工作，这对软件的一些性质，特别是对软件质量的提高，将产生非常大的影响。</p>\n</li>\n<li><p>天天扯着嗓子喊高内聚低耦合，到底什么是内聚什么是耦合？</p>\n<ul>\n<li>耦合：耦合是指不同模块之间相互依赖程度的度量<ul>\n<li>内容耦合：当一个模块直接修改或操作另一个模块的数据，\u001d或当一个模块直接修改或操作，另一个模块的数据或一个模块不通过正常入口转入到一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该尽量避免使用。</li>\n<li>公共耦合：两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。</li>\n<li>控制耦合：一个模块通过接口向另一个模块传递一个控制信号，接收信号的模块根据信号值进行适当的动作，这种耦合被成为控制耦合。</li>\n<li>标记耦合：若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。</li>\n<li>数据耦合：模块之间通过参数来传递数据，则称为数据耦合。数据耦合是最低的一种耦合形式。</li>\n</ul>\n</li>\n<li>内聚：内聚是指一个模块内部各成分之间相互关联程度的度量<ul>\n<li>偶然内聚：如果一个模块的各成分之间基本不存在任何关系，则称为偶然内聚</li>\n<li>逻辑内聚：几个逻辑上相关的功能被放在同一模块中，则称为逻辑内聚。</li>\n<li>时间内聚：如果一个模块完成的功能必须在同一时间内执行（例如，初始化系统或一组变量），但这些功能只是因为时间因素关联在一起，则称为时间内聚。</li>\n<li>过程内聚：如果一个模块内部的处理成分是相关的，而且这些处理必须以特定的次序执行，则称为过程内聚。</li>\n<li>通信内聚：如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚</li>\n<li>顺序内聚：如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚</li>\n<li>功能内聚：最理想的内聚是功能内聚，模块所有的成分对于完成单一的功能都是基本的。功能内聚的模块对完成其功能而言是充分必要的。</li>\n</ul>\n</li>\n<li>启发式规则：无论是变换设计还是事务设计，都涉一个共同的问题，即“基于高内聚低耦合的原理，采用一些经验性的启发式规则，对初始的模块结构图进行精化，形成最终的模块结构图”。</li>\n<li>怎么做？<ol>\n<li>改进软件结构，提高模块独立性。</li>\n<li>力求模块规模适中。</li>\n<li>力求深度、宽度、扇出和扇入适中。深度：表示其控制的<code>层数</code>(不包括自身)；宽度：同一层次上模块总数的<code>最大值</code>；扇出：一个模块<code>直接</code>控制（调用）的下级模块数目；扇入：一个模块有多少个上级模块<code>直接</code>调用它。</li>\n<li>尽力使模块的作用域在其控制域之内。作用域：受该模块内<code>一个判定</code>所影响的所有模块的集合；控制域：模块本身以及所有<code>直接或间接</code>从属于它的模块的集合。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"详细设计步骤\"><a href=\"#详细设计步骤\" class=\"headerlink\" title=\"详细设计步骤\"></a>详细设计步骤</h4><ol>\n<li>结构化程序设计<br> 包含三种基本控制结构：顺序结构、选择结构、循环结构</li>\n<li>详细设计工具<ol>\n<li>程序流程图 <img width=20% src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945069712&di=74b11092aae0042569e80dc22ee83438&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F09%2F17%2F02%2F27798515%2F15.files%2Ffile0001.jpg\">\n 缺点：不是一种逐步求精的工具，过早地考虑程序的流程，不去考虑程序的全局结构；所表达的控制流，往往不受任何约束可随意转移，从而会影响甚至破坏好的系统结构设计；不易表示数据结构。</li>\n<li>盒图（N-S图） <img width=40% src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945228461&di=10908d6d12f9c8984356e884b3c0aeb5&imgtype=0&src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fzhidao%2Fwh%253D450%252C600%2Fsign%3Da401ed95523d26972e86005960cb9ecd%2Fd833c895d143ad4bd5fe969f81025aafa50f0698.jpg\"></li>\n<li>PAD图（Problem Analysis Diagram） <img width=\"40%\" src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945326054&di=d66d2f92c755db3f26640c2bbb6bc338&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F12%2F15%2F14%2F51872755%2F6.files%2Ffile0001.jpeg\"></li>\n</ol>\n N-S图和PAD图支持“自顶向下逐步求精”的设计。可节省人工编码工作，有利于提高软件的可靠性和软件生产率<ol start=\"4\">\n<li>类程序设计语言（伪码/PDL）<br> 是一种用正文形式表示数据结构和处理过程的设计工具，PDL是一种“混合”的语言。</li>\n</ol>\n</li>\n<li>设计规约<br> 完成软件设计后，应产生设计规约，完整准确地描述满足系统需求规约所要求的的所有功能模块，以及伴随功能模块而出现的非功能机制。设计规约通常包括<code>概要设计规约</code>和<code>详细设计规约</code>。 <code>概要设计规约</code>指明高层软件体系结构，其主要功能如下： 1.系统环境等与设计有关的限定条件 2. 软件模块的结构（模块之间的接口及设计的数据流和主要数据结构）3. 模块描述（接口定义，模块处理逻辑，必要的注释等）4. 文件结构和全局数据文件的逻辑结构 5.测试需求 <code>详细设计规约</code>（包括各处理过程的算法和算法所涉及的全部数据结构的描述）主要作为软件设计人员与程序员之间交流的媒体。</li>\n</ol>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><h3 id=\"UML是一种图形化建模语言（Unified-Modeling-Language）\"><a href=\"#UML是一种图形化建模语言（Unified-Modeling-Language）\" class=\"headerlink\" title=\"UML是一种图形化建模语言（Unified Modeling Language）\"></a>UML是一种图形化建模语言（Unified Modeling Language）</h3><p>为了支持抽象分析和设计中的事物，UML给了八个基本术语，即类、接口、协作、用况、主动类、构件、制品、节点、</p>\n<ul>\n<li>类： 类是一组拥有相同属性、操作、关系和语义的对象的描述。类主要用于抽象客观世界中的事物。</li>\n<li>接口：每个操作描述了类、构件或子系统的一个服务，接口就是操作的一个集合。接口是对系统/产品的“接缝”予以模型化，表明了一个类、构件、子系统所需要得到的、且与实现无关的行为。</li>\n<li>用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的、可观察的结果。</li>\n<li>协作：协作是一个交互，涉及交互的三要素：交互各方、交互方式以及交互内容</li>\n<li>用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的，可观察的结果。</li>\n<li>主动类：主动类是一种至少具有一个进程或线程的类。</li>\n<li>构件：构件是系统设计中的一种模块化部件，通过外部接口隐藏了它的内部实现。</li>\n<li>制品：制品是系统中包含物理信息（比特）的、可替代的物理部件。</li>\n<li>节点：节点是运行时存在的物理元素，通常表示一种具有记忆能力和处理能力的计算机资源。</li>\n</ul>\n<p>类在建模中的主要用途：</p>\n<ol>\n<li>模型化问题域中的概念</li>\n<li>建立系统的职责分布模型</li>\n<li>模型化建模中使用的基本类型</li>\n</ol>\n<p>使用接口应注意的问题</p>\n<ol>\n<li>接口只可以被其他类目使用，而本身不能访问其他类目</li>\n<li>接口描述类的外部可见操作，通常是该类的一个特有限定行为。这些操作可以使用可见性、并发性、衍型、标记值和约束来修饰。</li>\n<li>接口不描述其中操作的实现，也没有属性和状态。据此可见，接口在形式上等价于一个没有属性、没有方法而只有抽象操作的抽象类</li>\n<li>接口之间没有关联、泛化、实现和依赖。但可以参与泛化、实现和依赖</li>\n</ol>\n<h3 id=\"表达关系的术语\"><a href=\"#表达关系的术语\" class=\"headerlink\" title=\"表达关系的术语\"></a>表达关系的术语</h3><pre><code>关联：关联是一组具有相同结构、相同链的描述，是类目之间的一种结构关系。关联可以用一条连接两个类目的线段表示，并可对其命名，其结构可以具有方向性，用一个实心三角形来指示关联的方向。\n    1. 关联名 。\n    2. 导航：对于一个给定的类目，可以找到与之关联的另一个类目，这称为导航。\n    3. 角色：角色是关联一端的类目对另一端的类目的一种呈现。\n    4. 可见性：通过导航可以找到另一类目的实例，有时候需要限制访问。\n    5. 多重性：类中对象参与一个关联的数目，成为该关联的多重性\n    6. 限定符：限定符是一个关联的属性或属性表。\n    7. 聚合：分类是增强客观实际问题语义的一种手段。聚合是对象之间（不是类之间）的一种结构关系。\n    8. 组合：组合是聚合的一种特殊形式\n泛化：泛化是一般性类目和它的较为特殊类目之间的一种关系。子类可以继承父类的属性和操作，同时也可以替换父类的声明。\n    泛化的四种约束：完整、不完整、互斥、重叠\n细化：细化是类目之间的语义关系，其中一个类目规约保证了另一个类目执行的契约。\n依赖：依赖用于描述一个类目使用另一个类目的信息和服务，是一种使用关系。\n    依赖的分类：绑定、导出、允许、示例、实例化、幂类型、精化、使用。\n    \n关联、泛化和细化都是一类特地类型的依赖。\n\n使用这四种术语，可以模型化以下各种关系：\n1. 结构关系（静态结构和动态结构）\n    进行模型化时两种驱动方式：1.以数据驱动 2. 以行为驱动\n2. 继承关系\n3. 精化关系\n4. 依赖关系\n</code></pre>\n<h3 id=\"表达组合信息的术语————包\"><a href=\"#表达组合信息的术语————包\" class=\"headerlink\" title=\"表达组合信息的术语————包\"></a>表达组合信息的术语————包</h3><p>为了控制信息组织的复杂性，UML提供了组织信息的一种通用机制————包，支持形成一些可管理的部分。换言之，包可以作为“模块化”和“构件化”的一种机制。</p>\n<p>包是模型元素的一个分组。一个包本身可以被嵌套在其他包中，并且可以含有子包和其他种类的模型元素。</p>\n<p>通过在包的名字前加上一个可见性符号（+，-，#），来指示该包的可见性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ 表示对其他包而言都是可见的</span><br><span class=\"line\"># 表示对子孙包而言是可见的</span><br><span class=\"line\">- 表示对其他包而言都是不可见的</span><br></pre></td></tr></table></figure>\n\n<p>为了模型化包之间的关系，UML给出了两种依赖，即访问和引入。</p>\n<ul>\n<li>访问：表明目标包中的内容可以被源包所引用，或被那些递归嵌套在源包中的其他包所引用。</li>\n<li>引入：表明目标包中具有适当可见性的内容（名字）被加入到源包的公共命名空间中。</li>\n</ul>\n<p>UML中用虚线加箭头的方式表示源包到目标包的依赖（访问和引入）。</p>\n<h3 id=\"UML术语的作用\"><a href=\"#UML术语的作用\" class=\"headerlink\" title=\"UML术语的作用\"></a>UML术语的作用</h3><ol>\n<li>类用于抽象客观事物</li>\n<li>接口用于抽象事物之间的缝隙</li>\n<li>协作用于抽象协作性行为</li>\n<li>用况用于抽象功能</li>\n<li>主动类用于抽象并发行为</li>\n<li>构件用于抽象软件解中标识的成分</li>\n<li>制品用于抽象工作产品</li>\n<li>节点用于抽象计算单元</li>\n<li>关联用于抽象结构关系</li>\n<li>泛化用于抽象“一般/特殊”关系</li>\n<li>实现用于抽象精化关系</li>\n<li>依赖用于抽象使用关系</li>\n</ol>\n<h3 id=\"UML的模型表达式\"><a href=\"#UML的模型表达式\" class=\"headerlink\" title=\"UML的模型表达式\"></a>UML的模型表达式</h3><ol>\n<li>结构图和行为图<br> 结构图用于表达系统或系统成分的静态结构模型，给出系统或系统成分的一些说明性信息<br> 行为图用于表系统或系统成分的动态结构模型，给出系统或系统成分的一些行为信息</li>\n<li>类图、用况图、顺序图及状态图<ul>\n<li>类图是可视化地表达系统静态结构功能模型的工具，使用类图所表达的系统静态结构模型，给出的是一些关于系统的说明性信息。<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176025075&di=1875f9ac829f33a38a45131069ee3e4a&imgtype=0&src=http://images.cnblogs.com/cnblogs_com/a-i/Uml2.JPG\"></li>\n<li>用况图是一种表达系统功能模型的图形化工具，它包含六个模型元素，分别是主题、用况、参与者、关联、泛化、依赖<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176303343&di=4146dfc9badef7bc95f4c750ab149eb0&imgtype=0&src=http://yzhtml01.book118.com/2016/09/24/23/28839740/23.files/file0001.png\"></li>\n<li>顺序图由一组对象以及按时序组织的对象之间的关系组成，是一种交互图，包含对象之间传递的信息。控制操作包括<code>选择执行操作</code>、<code>条件操作</code>、<code>并发迭代操作</code>、<code>迭代执行操作</code>。<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176439921&di=d592e65ae4a1bc1c2e65a98e415a897a&imgtype=0&src=http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/png/20180615101636402475.png\"></li>\n<li>状态图强调了从一个状态到另一个状态的控制流，是显示一个状态机的图。状态图由状态、事件和状态转移构成。使用状态图的作用有两个：一是创建一个系统的动态模型，二是创建一个场景的模型<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176576658&di=70e3de58666cf1d7315cf56a05ec0d35&imgtype=0&src=http://yzhtml01.book118.com/2016/12/07/08/48638362/25.files/file0001.png\"></li>\n<li></li>\n</ul>\n</li>\n<li>创建一个系统的类图的步骤<ul>\n<li>模型化代建系统中的概念，形成类图中的基本元素</li>\n<li>模型化代建系统中的各种关系，形成该系统的初始类图</li>\n<li>模型化系统中的协作，给出该系统的最终类图</li>\n<li>模型化逻辑数据库模式</li>\n</ul>\n</li>\n<li>信号事件、调用事件、时间事件和变化事件<ul>\n<li>信号事件是一种异步事件，信号通常由状态机处理。如果没有定义对该事件的响应，那么事件均可能丢失。事件的丢失，就有可能引发接受者——状态机的一个错误的状态转移。</li>\n</ul>\n</li>\n<li>状态转移所涉及的内容<br> 描述一个状态转换，一般涉及五个部分：<ol>\n<li>源状态：发生状态转移的那个状态</li>\n<li>转移触发器：在源状态中由对象识别的事件，并且一旦满足其监护条件，则使状态发生转移。</li>\n<li>监护条件：一个布尔表达式，当某个事件触发器接受一个事件时，如果该表达式有值为真，则触发一个转移；若有值为假，则不发生状态转移。</li>\n<li>效应：一种可执行的行为</li>\n<li>目标状态：转移完成后所处的状态</li>\n</ol>\n</li>\n<li>最常用的控制操作子<br> 选择执行操作子：该操作子由两部分组成：一是监护条件，二是控制体<br> 条件执行操作子：控制体通过水平线将其分为一些部分，每一部分表示一个条件分支，每一分支有一个监护条件。<br> 并发执行操作子：该控制操作子的体通过水平线将其分为多个部分，每一部分表示一个并行计算。该控制操作子表明，当进入该控制操作子是，所有部分并发执行。<br> 迭代执行操作子：该控制操作子表明，只要在每一次迭代之前该监护条件为真，那么该控制体就反复执行，当该控制体上面的监护条件为假时，控制绕过该控制操作子。</li>\n<li>子状态机、简单状态和组合状态的概念<br> 子状态机：为了有效地组织状态、控制对象状态的复杂性，UML提供了组合状态，在一个状态机中引入了另一个状态机。被引入的状态机就称为子状态机。<br> 简单状态：子状态是被嵌套到另一状态中的状态。相对地，被引入的状态机就称为子状态机。<br> 组合状态：把含子状态的状态称为组合状态，组合状态可包含两种类型的子状态机，即非正交（顺序）子状态机和正交（并发）子状态机。<h2 id=\"RUP\"><a href=\"#RUP\" class=\"headerlink\" title=\"RUP\"></a>RUP</h2></li>\n</ol>\n<h3 id=\"RUP-Rational-Unified-Process-的特点\"><a href=\"#RUP-Rational-Unified-Process-的特点\" class=\"headerlink\" title=\"RUP(Rational Unified Process)的特点\"></a>RUP(Rational Unified Process)的特点</h3><p>RUP的突出特点是，它是一种以用况（Use Case）为驱动的、以体系结构为中心的迭代、增量式开发。</p>\n<ol>\n<li>以用况为驱动<br>以用况为驱动是指在系统的生存周期中，以用况作为基础，驱动系统有关人员对所要建立系统的功能需求进行交流，驱动系统分析、设计、实现和测试等活动。</li>\n<li>以体系结构为中心<br>以体系结构为中心是指在系统的生存周期中，开发的任何阶段都要给出相关模型视角下有关体系结构的描述，作为构思、构造、管理和改善系统的主要标准。</li>\n<li>迭代、增量式开发<br>迭代、增量式开发是指通过开发活动的迭代，不断地产生相应的增量。在RUP中，规定了四个开发阶段：初始阶段、精化阶段、构造阶段和移交阶段。</li>\n</ol>\n<h3 id=\"核心工作流\"><a href=\"#核心工作流\" class=\"headerlink\" title=\"核心工作流\"></a>核心工作流</h3><p>核心工作流：需求获取、分析、设计、实现和测试</p>\n<h4 id=\"需求获取\"><a href=\"#需求获取\" class=\"headerlink\" title=\"需求获取\"></a>需求获取</h4><table>\n<thead>\n<tr>\n<th align=\"center\">基本步骤</th>\n<th align=\"center\">产生的制品</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">列出候选的特征</td>\n<td align=\"center\">特征表</td>\n</tr>\n<tr>\n<td align=\"center\">理解系统语境</td>\n<td align=\"center\">领域模型或业务模型</td>\n</tr>\n<tr>\n<td align=\"center\">捕获功能需求</td>\n<td align=\"center\">用况模型</td>\n</tr>\n<tr>\n<td align=\"center\">捕获非功能需求</td>\n<td align=\"center\">补充需求或针对特殊需求的用况</td>\n</tr>\n</tbody></table>\n<h3 id=\"业务用况模型和业务对象模型\"><a href=\"#业务用况模型和业务对象模型\" class=\"headerlink\" title=\"业务用况模型和业务对象模型\"></a>业务用况模型和业务对象模型</h3><ol>\n<li>业务用况模型。业务用况模型是以用框图予以表达的</li>\n<li>业务对象模型。为了精化业务用况模型中的每一个业务用况，RUP引入了三个术语，用于表达参与业务的业务对象：<code>工作人员</code>、<code>业务实体</code>和<code>工作单元</code>。业务对象模型可通过交互图和活动图予以表达。</li>\n</ol>\n<h3 id=\"标识用况应注意的问题\"><a href=\"#标识用况应注意的问题\" class=\"headerlink\" title=\"标识用况应注意的问题\"></a>标识用况应注意的问题</h3><ol>\n<li>建立用况的结构中，应尽可能反映用况的实际情况。</li>\n<li>在用况的结构化中，不论是施加什么结构，新引入的用况都不应该太小或太大</li>\n<li>在建立用况的结构是，应尽量避免对用况模型中的用况功能进行分解。</li>\n</ol>\n<h4 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h4><ol>\n<li>分析类是类的一种衍型，分为边界类、实体类和控制类</li>\n<li>用况细化时一个协作，针对一个用况，其行为可用多个分析类之间的相互作用来细化，并记为用况细化。用况细化对用况模型中的一个特定的用况提供了一种直接跟踪的方式。</li>\n<li>分析包是一种控制信息组织复杂性的机制，提供了分析制品的一种组织手段。其主要特征为：体现问题的分离；高内聚、低耦合；尽可能体现一个系统的完整顶层设计，尽可能成为一些子系统或者成为一些子系统的组成部分。</li>\n</ol>\n<h4 id=\"具有良好结构的分析包的特征\"><a href=\"#具有良好结构的分析包的特征\" class=\"headerlink\" title=\"具有良好结构的分析包的特征\"></a>具有良好结构的分析包的特征</h4><ol>\n<li>体现问题分离</li>\n<li>高内聚、低耦合。</li>\n<li>尽可能提现一个系统的完整顶层设计。</li>\n</ol>\n<h4 id=\"软件设计层上的术语\"><a href=\"#软件设计层上的术语\" class=\"headerlink\" title=\"软件设计层上的术语\"></a>软件设计层上的术语</h4><p>软件设计是满足需求规约所需要的软件结构。RUP为了满足系统/产品分析模型规约需求的软件结构，为设计层提供了是个术语：设计类、用况细化、设计子系统和接口，用于表达软件结构中的基本元素。</p>\n<ol>\n<li>设计类：一个设计类是对系统中实现一个类或类似构造的一个无缝抽象</li>\n<li>用况细化：用况细化是设计模型的一个协作，其中使用设计类及其对象，描述一个特定用况是如何予以细化的，是如何执行的</li>\n<li>设计子系统：设计子系统可以包含设计类、用况细化、接口，以及其他子系统，通过对其操作来显示其功能。</li>\n<li>接口：接口用于规约由设计类和设计子系统，必须提供与该接口操作对应的实现方法。</li>\n</ol>\n<h4 id=\"创建系统-产品用况模型的活动和任务\"><a href=\"#创建系统-产品用况模型的活动和任务\" class=\"headerlink\" title=\"创建系统/产品用况模型的活动和任务\"></a>创建系统/产品用况模型的活动和任务</h4><p>创建系统/产品用况模型的活动和任务如下</p>\n<ol>\n<li>活动一：发现并描述参与者<br>任务1：发现参与者，即直接发现一些候选的参与者<br>任务2：描述参与者，即对参与者进行命名并描述</li>\n<li>活动二：发现用况并对用况进行描述<br>任务1：发现用况<br>任务2：描述用况，即确定用况后对其进行描述</li>\n<li>活动三：确定用况的优先级，目的是在寻找参与者并对其进行描述和发现用况的并对用况进行描述的基础上确定哪些用况适合在早期的迭代中开发，哪些适合在后期的迭代中开发。</li>\n<li>活动四：精化用况。这一活动的目的是详细描述出每一用况的事件流，包括用况是怎样开始的，是怎样结束的，是怎样与参与者进行交互的，最终形成一系列精化的用况</li>\n<li>活动五：构造用户界面原型。这一活动的目的在于建造用户界面原型，使用户可以有效地执行用况。</li>\n<li>活动六：用况模型的结构化。需要进行以下工作。<ol>\n<li>抽取用况描述中的那些一般性的和共享的功能并使用泛化关系标识和描述那些共享功能</li>\n<li>抽取用况描述附加的或可选的功能</li>\n<li>标识用况之间的包含关系。通过用况模型的结构化，最终形成一个系统/产品的精化用户模型</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"创建系统-产品需求分析模型的活动和任务\"><a href=\"#创建系统-产品需求分析模型的活动和任务\" class=\"headerlink\" title=\"创建系统/产品需求分析模型的活动和任务\"></a>创建系统/产品需求分析模型的活动和任务</h4><ol>\n<li>活动1：体系结构分析。该活动的目标是通过标识分析包和分析类，建立分析模型和体系结构“骨架”，并标识有关分析包和分析类的特定需求。<br>任务1：标识分析包。该任务的基本输入是系统的用况模型<br>任务2：处理分析包之间的共性<br>任务3：标识服务包<br>任务4：定义分析包的依赖，该任务的目标是发现相对独立的包，实现包的高内聚和低耦合<br>任务5：标识重要的实体类，该任务的目标是标识在体系结构方面具有意义的实体类。<br>任务6：标识分析包和重要实体类的公共特定需求，该任务的目标是依据需求获取阶段所标识的非功能需求，针对在分析期间所标识的包和分析类，标识它们的一些公共的特定要求。</li>\n<li>活动2：用况分析。该活动的目标是：一是标识那些在用况事件流执行中所需要的分析类和对象；二是将用况的行为分布到参与交互的各个分析对象；三是捕获用况细化上的特定需求。<br>任务1：标识分析类，该任务的目标是标识在细化一个用况中所需要实体类、控制类和边界类，给出它们的名字、责任、属性和关系。<br>任务2：描述分析类对象之间的交互。首先确定细化该用况所必要的交互，其次分派该用况的功能，最后根据其责任，发现该交互图中的各个链。</li>\n<li>活动3：类的分析。该活动的目标：一是标识并维护分析类的属性和关系；二是捕获分析类细化中的特殊需求。<br>任务1：标识责任，通过组合一个类在不同用况细化中所扮演的角色来完成。<br>任务2：标识属性<br>任务3：标识关联和聚合</li>\n<li>活动4：包的分析。该活的目标是：一是确保分析包尽可能与其他包相对独立；而是确保分析包实现了它的目标；三是描述依赖，以益于可以估计未来的变化。</li>\n</ol>\n<h3 id=\"创建系统-产品设计模型的活动和任务\"><a href=\"#创建系统-产品设计模型的活动和任务\" class=\"headerlink\" title=\"创建系统/产品设计模型的活动和任务\"></a>创建系统/产品设计模型的活动和任务</h3><p>创建系统/产品设计模型的活动和任务如下：</p>\n<ol>\n<li>活动1：体系结构设计，该活动的目标是创建设计模型和部署模型，以及它们视角下的体系结构描述<br>任务1：标识节点和它们的网络配置，网络配置通常使用一种三元模式：客户端、数据库功能、业务/应用逻辑<br>任务2：标识子系统和它们的接口，目的是为了寻求一些复用的可能，而后随着设计模型的开发，在形成子系统结构中不断发现并烟花。<br>任务3：标识在体系结构方面有意义的设计类和它们的接口。标识在体系结构方面有意义的设计类的基本思想是：初始可以依据在体系结构方面有意义的分析类来标识一些体系结构上具有重要意义的设计类。标识在系统体系结构方面有意义的设计类时，应注意主动类往往是一类在体系结构方面具有重要意义的类。</li>\n<li>活动2：用况的设计。其中分析模型用况细化分析是活动的输入、对应输出用况细化设计。<br>为了实现用况设计的输入/输出，一般采用两种方法：<ol>\n<li>标识参与用况细化的设计类，首先基于分析模型研究相应用况细化分析中的分析类，来标识为细化这些分类所需要的设计类，然后基于用况的功能对每一个标识的设计类赋予相应的责任，最后为该细化创建一个类图，汇聚参与该用况细化的设计类，并给出类之间的关系。</li>\n<li>标识参与用况细化的子系统和接口。</li>\n</ol>\n</li>\n<li>活动3：类的设计。该活动的目标是完成用况细化设计中每一个类的角色设计，并完成有关每一类的非功能需求的设计。<br>任务1：概括描述设计类，该任务的输入为分析类/接口。<br>任务2：标识的操作，一般应依据分析类来标识设计类所提供的、所需要的操作，其中需要使用程序设计语言的语法来描述说标识的操作。<br>任务3：标识属性，该任务的目标是标识设计类所需要的属性，并使用程序设计语言的语法给出属性的描述。<br>任务4：标识关联和聚合。<br>任务5：标识泛化，基于分析模型中分析类之间的泛化，可以发现设计模型中的很多泛化。<br>任务6：描述方法，在设计期间一般用自然语言或适当的使用伪码对方法进行规约，但是在实现期间直接使用程序设计语言对方法进行规约。<br>任务7：描述状态，有些设计对象是受状态控制的，即它们的状态确定了它们接受一个消息的行为。在这种情况下，使用一个状态图描述一个对象的不同状态转移是有意义的。</li>\n<li>活动4：子系统的设计。该活动的目标是：确保子系统尽可能独立于其他子系统或它们的接口；确保子系统提供正确的接口；确保子系统实现了它的目标，即给出了该子系统提供的那些接口所定义的操作的细化。</li>\n</ol>\n<h3 id=\"设计模型包含的元素\"><a href=\"#设计模型包含的元素\" class=\"headerlink\" title=\"设计模型包含的元素\"></a>设计模型包含的元素</h3><p>RUP设计的主要结果是设计模型，它尽量保持该系统具有分析模型的结构，并作为系统实现的输入，包含以下四个元素：</p>\n<ol>\n<li>设计子系统和服务子系统，以及它们的接口、依赖和内容。</li>\n<li>设计类以及它们具有的操作、属性、关系及其实现的需求。</li>\n<li>用况细化设计。</li>\n<li>设计模型视角下的体系结构描述。</li>\n</ol>\n<h3 id=\"用况模型与分析模型的比较\"><a href=\"#用况模型与分析模型的比较\" class=\"headerlink\" title=\"用况模型与分析模型的比较\"></a>用况模型与分析模型的比较</h3><table>\n<thead>\n<tr>\n<th align=\"center\">用况模型</th>\n<th align=\"center\">分析模型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">使用客户语言来描述</td>\n<td align=\"center\">使用开发者语言来描述</td>\n</tr>\n<tr>\n<td align=\"center\">给出的是系统对外的视图</td>\n<td align=\"center\">给出的是系统对内的视图</td>\n</tr>\n<tr>\n<td align=\"center\">使用用况予以结构化，但给出的是外部视角下的系统结构</td>\n<td align=\"center\">使用衍型类予以结构化，当给出的是内部视角下的系统结构</td>\n</tr>\n<tr>\n<td align=\"center\">可以作为客户与开发者之间关于“系统应该做什么，不应该做什么”的契约</td>\n<td align=\"center\">可以作为开发者理解系统如何勾画、如何设计和如何实现的基础</td>\n</tr>\n<tr>\n<td align=\"center\">在需求之间可能存在一些冗余、不一致和冲突等问题</td>\n<td align=\"center\">在需求之间不应存在冗余、不一致和冲突问题</td>\n</tr>\n<tr>\n<td align=\"center\">捕获的是系统的功能，包括在体系结构方面有意义的功能</td>\n<td align=\"center\">给出的是细化的系统功能，包括在体系结构方面具有意义的功能</td>\n</tr>\n<tr>\n<td align=\"center\">定义了一些进一步需要在分析模型中予以分析的</td>\n<td align=\"center\">定义了用况模型中每一个用况的细化</td>\n</tr>\n</tbody></table>\n<h3 id=\"RUP实现活动\"><a href=\"#RUP实现活动\" class=\"headerlink\" title=\"RUP实现活动\"></a>RUP实现活动</h3><p>目标：基于设计类和子系统生成构件；对构件进行单元测试，进行集成和连接；把可执行的构件映射到部署模型。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">输入</th>\n<th align=\"center\">活动</th>\n<th align=\"center\">执行者</th>\n<th align=\"center\">输出</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">设计模型、部署模型、体系结构描述【设计模型、部署模型角度】</td>\n<td align=\"center\">实现体系结构</td>\n<td align=\"center\">体系结构设计者</td>\n<td align=\"center\">构件【概述】、体系结构描述【实现模型、部署模型角度】</td>\n</tr>\n<tr>\n<td align=\"center\">补充需求、用况模型、设计模型、实现模型【当前建造】</td>\n<td align=\"center\">集成系统</td>\n<td align=\"center\">系统集成者</td>\n<td align=\"center\">集成建造计划、实现模型【连续的建造】</td>\n</tr>\n<tr>\n<td align=\"center\">集成建造计划、体系结构描述【实现模型角度】、设计子系统【已设计】、接口【已设计】</td>\n<td align=\"center\">实现子接口</td>\n<td align=\"center\">构件工程师</td>\n<td align=\"center\">实现子系统【建造完成】、接口【建造完成】</td>\n</tr>\n<tr>\n<td align=\"center\">设计类【已设计】、接口【由设计类提供】</td>\n<td align=\"center\">实现类</td>\n<td align=\"center\">构件工程师</td>\n<td align=\"center\">构件【完成】</td>\n</tr>\n<tr>\n<td align=\"center\">构件【完成】、接口</td>\n<td align=\"center\">完成单元测试</td>\n<td align=\"center\">构件工程师</td>\n<td align=\"center\">构件【已完成单元测试】</td>\n</tr>\n</tbody></table>\n<h3 id=\"RUP测试活动\"><a href=\"#RUP测试活动\" class=\"headerlink\" title=\"RUP测试活动\"></a>RUP测试活动</h3><p>RUP的测试包括内部测试、中间测试和最终测试</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">输入</th>\n<th align=\"center\">活动</th>\n<th align=\"center\">输出</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">补充需求、用况模型、分析模型、设计模型、实现模型、体系结构的描述</td>\n<td align=\"center\">计划测试</td>\n<td align=\"center\">测试计划</td>\n</tr>\n<tr>\n<td align=\"center\">补充需求、用况模型、分析模型、设计模型、实现模型、体系结构描述、测试计划</td>\n<td align=\"center\">设计测试</td>\n<td align=\"center\">测试用况 测试过程</td>\n</tr>\n<tr>\n<td align=\"center\">测试用况、测试过程、实现模型</td>\n<td align=\"center\">实现测试</td>\n<td align=\"center\">测试构件</td>\n</tr>\n<tr>\n<td align=\"center\">测试用况、测试过程、测试构件、实现模型</td>\n<td align=\"center\">执行集成测试</td>\n<td align=\"center\">缺陷</td>\n</tr>\n<tr>\n<td align=\"center\">测试用况、测试过程、测试构件、实现模型</td>\n<td align=\"center\">执行系统测试</td>\n<td align=\"center\">缺陷</td>\n</tr>\n<tr>\n<td align=\"center\">测试用况、测试模型、缺陷</td>\n<td align=\"center\">评价测试</td>\n<td align=\"center\">测试评价</td>\n</tr>\n</tbody></table>\n<h2 id=\"软件测试\"><a href=\"#软件测试\" class=\"headerlink\" title=\"软件测试\"></a>软件测试</h2><h3 id=\"软件测试目标与软件测试过程模型\"><a href=\"#软件测试目标与软件测试过程模型\" class=\"headerlink\" title=\"软件测试目标与软件测试过程模型\"></a>软件测试目标与软件测试过程模型</h3><h4 id=\"软件测试及目标\"><a href=\"#软件测试及目标\" class=\"headerlink\" title=\"软件测试及目标\"></a>软件测试及目标</h4><p>软件测试的定义为：按照特定规程发现软件错误的过程。其目的是检验它是否满足规定的需求，或清楚了解预期结构与实际结果之间的差异</p>\n<h4 id=\"软件测试与软件调试之间的区别\"><a href=\"#软件测试与软件调试之间的区别\" class=\"headerlink\" title=\"软件测试与软件调试之间的区别\"></a>软件测试与软件调试之间的区别</h4><p>软件测试与软件调试相比，在目的、技术和方法等方面都存在很大区别，主要表现在以下几个方面。</p>\n<ol>\n<li>测试从一个侧面证明程序员的”失败”.调试是为了证明程序员的正确。</li>\n<li>测试以已知条件开始，使用预先定义的程序且有预知的结果，不可预见的仅是程序是否通过。调试一般是以不可知的内部条件开始，除统计性调试外，结果是不可预见的。</li>\n<li>测试是有计划的，并要进行测试设计。调试是不受时间约束的。</li>\n<li>测试是一个发现错误、改正错误、重新测试的过程。调试是一个推理过程。</li>\n<li>测试的执行是有规程的。调试的执行往往要求程序员进行必要推理。</li>\n<li>测试经常是由独立的测试组在不了解软件设计的条件下完成的。调试必须由了解详细设计的程序员完成。</li>\n<li>大多数测试的执行和设计可由工具支持。调试时，程序员能利用的主要工具是调试器。</li>\n</ol>\n<h4 id=\"测试过程模型\"><a href=\"#测试过程模型\" class=\"headerlink\" title=\"测试过程模型\"></a>测试过程模型</h4><p>软件测试是一个有程序的过程，包括测试设计、测试执行以及测试结果比较。测试过程模型可分为三类：环境模型、被测对象模型和错误模型。</p>\n<ol>\n<li>环境模型：是对程序运行环境的抽象。程序运行环境又包括支持其运行的硬件、固件和软件，如计算机、终端设备、网卡、操作系统、编译系统、实用程序等。在软件测试过程中，建立环境模型的主要目的是，确定所发现的错误是否为环境造成的。</li>\n<li>被测对象模型：该模型是从测试的角度对程序的抽象。为了测试，必须简化程序，形成被测程序的抽象版本、即对象模型。</li>\n<li>错误模型：该模型是对程序中的错误及其分类的抽象。在软件测试中，往往需要定义“什么是错误”、“什么是一般性错误”、“什么是严重性错误”等，即要给出“错误模型”。</li>\n</ol>\n<h3 id=\"软件测试技术\"><a href=\"#软件测试技术\" class=\"headerlink\" title=\"软件测试技术\"></a>软件测试技术</h3><ol>\n<li><p>测试覆盖及其他们之间的基本关系<br>软件测试技术大体上可分为两大类：一类是白盒测试技术，又称为结构测试技术，典型的是路径测试技术；另一种是黑盒测试技术，又称为功能测试技术，包括事务处理流程技术、状态测试技术、定义域测试技术等。白盒测试技术依据的是程序的逻辑结构，而黑盒测试技术依据的是软件行为的描述。</p>\n</li>\n<li><p>路径测试技术的分类</p>\n<p> 测试覆盖包括路径覆盖、分支覆盖、条件覆盖与条件组合覆盖。</p>\n<ol>\n<li>路径覆盖：执行所以有可能穿过程序控制流程的路径。在路径测试中，该度量是最强的，一般是不可实现的。</li>\n<li>语句覆盖：至少执行程序中所有语句一次</li>\n<li>分支覆盖：至少将程序中的每一个分支执行一次</li>\n<li>条件覆盖与条件组合覆盖：条件覆盖是指每个判定中所有的可能的条件的取值至少执行一次；条件组合覆盖是指设计足够的测试用例，使每个判定中所有可能的条件取值组合至少执行一次。</li>\n</ol>\n<p> 这四种测试覆盖的测试覆盖率由弱到强的顺序是：语句覆盖 &lt; 分支覆盖 &lt; 条件组合覆盖 &lt; 路径覆盖</p>\n</li>\n<li><p>事务流测试步骤</p>\n<p> 事务流测试步骤具体如下。<br> 第一步：获得事务流程图。<br> 第二步：浏览、复审。<br> 第三步：用例设计。<br> 第四步：测试执行。</p>\n</li>\n<li><p>运用等价类划分技术进行测试的步骤</p>\n<p> 具体测试步骤如下。<br> 第一步：建立等价类表<br> 第二步：为有效等价类设计测试用例<br> 第三步：为无效等价类至少设计一个测试用例</p>\n</li>\n<li><p>边界值分析的使用原则</p>\n<p> 边界值分析是一种常用的黑盒测试技术。使用边界值分析在设计测试用例时，可以遵循以下原则。</p>\n<ol>\n<li>如果某个输入条件规定了输入值的范围，则应该选择正好等于边界值的数据，以及刚刚超过边界值的数据作为测试数据。</li>\n<li>如果某个输入条件规定了值的个数，则可用最大个数、最小个数、比最大个数多1、比最小个数少1的数据作为测试数据</li>\n<li>根据规格说明的每个输出条件，使用前面的原则1</li>\n<li>根据规格说明的每个输出条件，使用前面的原则2</li>\n<li>如果程序的规格说明中，输入域或输出域是有序集合，在实践中则经常选取集合的第一个元素、最后一个元素以及典型元素作为测试用例。</li>\n<li>如果程序中使用了内部数据结构，则应该选择这个内部数据结构的边界上的值作为测试用例。</li>\n<li>分析规格说明，找出其他可能的边界条件。</li>\n</ol>\n</li>\n<li><p>使用因果图生成测试用例的步骤</p>\n<p> 因果图技术是通过为判定表的每一列设计一个测试用例，从而实现测试用例的设计与选择的。该方法生成测试用例的基本步骤如下。</p>\n<ol>\n<li>通过软件规格说明书的分析，找出一个模块的原因和结果，并给每个原因和结果赋予一个标识符</li>\n<li>分析原因与结果之间以及原因之间对应的关系，并画出因果图。</li>\n<li>在因果图上标识出一些特定的约束或限制条件。</li>\n<li>把因果图转换成判定表。</li>\n<li>把判定表的每一列拿出来作为依据，设计测试用例。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"软件测试步骤\"><a href=\"#软件测试步骤\" class=\"headerlink\" title=\"软件测试步骤\"></a>软件测试步骤</h3><ol>\n<li><p>单元测试<br> 单元测试主要检验软件设计的最小单元—模块。该测试以详细设计文档为指导，测试模块内的重要控制路径。一般来说，单元测试往往采用白盒测试技术。</p>\n</li>\n<li><p>集成测试<br> 集成测试是软件组装的一个系统化技术，其目标是发现与接口有关的错误，将经过单元测的模块构成一个满足设计要求的软件结构。集成测试集中于模块组合的功能和软件结构检验。集成测试可“自顶向下”地进行，称为自顶向下的集成测试；也可以“自底向上”地进行测试，称为自底向上的集成测试</p>\n</li>\n<li><p>有效性测试<br> 有效性测试的目标是发现软件实现的功能与需求规格说明书不一致的错误。因此有效性测试通常采用黑盒测试技术。</p>\n</li>\n<li><p>系统测试<br> 系统测试验证将软件融于更大系统中时整个系统的有效性。</p>\n</li>\n</ol>\n<h2 id=\"软件生存周期过程与管理\"><a href=\"#软件生存周期过程与管理\" class=\"headerlink\" title=\"软件生存周期过程与管理\"></a>软件生存周期过程与管理</h2><h3 id=\"软件生存周期过程概述\"><a href=\"#软件生存周期过程概述\" class=\"headerlink\" title=\"软件生存周期过程概述\"></a>软件生存周期过程概述</h3><ol>\n<li><p>过程分类</p>\n<p> 按过程主体把软件生存周期过程分为以下几个过程。</p>\n<ol>\n<li>基本过程：是指那些与软件生产直接相关的活动集。该过程又可分为获取过程、供应过程、开发过程、运行过程和维护过程。</li>\n<li>支持过程：是指有关各方按他们的目标所从事的一系列相关支持活动集。该过程又可分为文档过程、配置管理过程、质量保证过程、验证过程、确认过程、联合评审过程、审计过程和问题解决过程。</li>\n<li>组织过程：是指那些与软件生产组织有关的活动集。该过程又可分为设计过程、基础设施过程、培训过程和改进过程。</li>\n</ol>\n</li>\n<li><p>系统语境的过程类<br> 系统语境的过程类包含四个过程组，分别是协议过程组、项目过程组、技术过程组和组织上项目使能过程组。</p>\n<ol>\n<li>协议过程组包含两个过程：获取过程和供应过程。</li>\n<li>项目过程组包含七个过程：项目规划过程、项目评价过程、决策管理过程、风险管理过程、配置管理过程、信息管理过程和测量过程。</li>\n<li>技术过程组包含11个过程：利益攸关方需求定义过程、系统需求分析过程、系统体系结构设计过程、实现过程、系统集成过程、系统测试过程、软件安装过程、软件接受支持过程、软件运行过程、软件维护过程和软件销毁过程。</li>\n<li>组织上使能过程组包含五个过程：生存周期模型管理过程、基础设施管理过程、项目包管理过程、人力资源管理过程和质量管理过程。</li>\n</ol>\n</li>\n<li><p>组织上使能过程的作用。<br> 组织上使能的过程一般来说是组织层面上的工作，为项目的执行提供基本保障。该过程包含五个子过程。</p>\n<ol>\n<li>生存周期模型管理过程：其任务为过程建立、过程评估、过程改进。</li>\n<li>基础设施管理过程：其任务为过程实现、基础设施的建立、基础设施的维护。</li>\n<li>项目包管理过程：项目初始化、项目包评估、项目结束处理。</li>\n<li>人力资源管理过程：其任务为技能标识、技能开发、技能获取和供给、知识管理。</li>\n<li>质量管理过程：其任务为质量管理、质量管理纠正措施。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"过程描述\"><a href=\"#过程描述\" class=\"headerlink\" title=\"过程描述\"></a>过程描述</h3><p>软件验证过程包括两个活动：过程实现和验证。其中验证活动有五个任务：需求验证、设计验证、代码验证，集成验证和文档验证。</p>\n<p>一个过程可通过过程意图，期望的结果以及到达过程结果需要执行的活动和任务来描述。对于一个过程的完整技术上的描述，还应包括：达到过程意图和实现过程结果的方法或规程，以及过程和活动文档。</p>\n<h3 id=\"应用说明\"><a href=\"#应用说明\" class=\"headerlink\" title=\"应用说明\"></a>应用说明</h3><ol>\n<li><p>系统和软件的关系</p>\n<p> 在《ISO/IEC系统与软件工程-软件生产周期过程12207-2008》标准中，把软件认为是整个系统的一个组成从部分，执行系统中所确定的功能主要包括三大功能：控制功能、耦合功能以及软件本身提供的功能。由于软件通常存在与一个系统的上下文中，因此软件产品或服务一般可被认为是系统的一个项或称为系统元素。</p>\n</li>\n<li><p>剪裁过程及应用</p>\n<p> 剪裁过程是使剪裁这一标准过程慢速以下特定情况或因素。</p>\n<ol>\n<li>围绕一个组织，其中该组织在一个协议中使用了这一标准</li>\n<li>影响一个项目，其中要求该项目满足一个引用该标准的协议</li>\n<li>反映一个组织的需要，其中该组织要供给产品或服务</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"软件生存周期模型\"><a href=\"#软件生存周期模型\" class=\"headerlink\" title=\"软件生存周期模型\"></a>软件生存周期模型</h3><ol>\n<li><p>瀑布模型</p>\n<p> 瀑布模型是将软件生存周期各个活动规定为按固定顺序链接的若干阶段的模型。这一模型规定了个开发阶段的活动：系统需求、软件需求、需求分析、设计、编码、测试和运行，并且自上而下具有相互衔接的固定顺序；还规定了每一个阶段的输入，即工作对象以及本阶段的工作成果，作为输出传送到下一阶段。</p>\n<p> 瀑布模型的提出，对软件工程的主要贡献如下。</p>\n<ol>\n<li>在决定系统怎样做之前存在一个需求阶段，它鼓励对系统做什么进行规约。</li>\n<li>在系统构造之前存在一个需求阶段，它鼓励规划系统结构。</li>\n<li>在每一阶段结束时进行评审，从而允许获取方和用户的参与。</li>\n<li>前一步可以作为下一步被认可的、文档化的基线，并允许基线和配置早期接受控制。</li>\n</ol>\n<p> 瀑布模型的主要问题是：</p>\n<ol>\n<li>要求客户能完整、正确和清晰地表达他们的需求；并要求开发人员一开始就要理解这一应用。</li>\n<li>由于需求的不稳定性，使设计、编码和测试阶段都可能发生延期；并且当项目接近结束时，出现了大量的集成和测试工作。</li>\n<li>在开始的阶段中，很难评估真正的进度状态；并且直到项目结束之前都不能演示系统的能力。</li>\n<li>在一个项目的早期开发阶段，过分地强调了基线和里程碑处的文档；并可能需要花费更多的时间用于建立一些用处不大的文档。</li>\n</ol>\n</li>\n<li><p>增量模型</p>\n<p> 增量模型是一种非整体开发的模型。软件在该模型中逐渐开发出来，开发出一部分，向用户展示一部分，可让用户及早看到部分软件，及早发现问题。该模型具有较大的灵活性，适合软件需求不明确、设计方案有一定风险的软件项目。</p>\n</li>\n<li><p>演化模型</p>\n<p> 该模型主要针对事先不能完整定义需求的软件开发在用户提出待开发系统的核心需求的基础上，软件开发人员按照这一要求，首先开发一个核心系统并投入运行，以便用户能够有效地提出反馈，即精化系统、增强系统能力的需求；接着，软件开发人员根据用户反馈，实施开发的迭代过程；每一迭代过程均由需求、设计、编码、测试、集成等阶段组成，为整个系统增加一个可定义的，可管理的子集；如果在一次迭代中，有的需求不能满足用户的要求，可在下一次迭代中予以修正。</p>\n<p> 主要特征：该模型显式地把需求获取扩展到需求阶段，既为了第二个构造增量，使用了第一个构造增量来精化需求。演化模型在一定程度上可以减少软件开发活动的盲目性。<br>不足之处：在演化模型的使用中，即使很好地理解了需求或设计，也很容易弱化需求分析阶段的工作。</p>\n</li>\n<li><p>螺旋模型</p>\n<p> 螺旋模型将瀑布模型与增量模型结合起来，加入了两种模型均忽略了的风险分析，弥补了这两种模型的不足。因而它是一种风险驱动的模型。螺旋模型将开放过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合。</p>\n<p> 螺旋模型关注解决问题的基本步骤，即标识问题，标识一些可选方案，选择一个最佳方案，遵循动作步骤并实施后续工作。其一个突出特征是，在开发的迭代中实际上只有一个迭代过程真正开发了可交付的软件。螺旋模型与演化模型和增量模型相比，同样适用了瀑布模型作为一个嵌入的过程，但螺旋模型所关注的阶段以及它们的活动是不同的。如果项目的开发风险很大或客户不能确定系统需求，在更广泛的意义上来讲，还包括一个系统或系统类型的要求，这时螺旋模型就是一个很好的生存周期模型。</p>\n</li>\n<li><p>喷泉模型</p>\n<p> 喷泉模型体现了软件创建所固有的迭代和无间隙的特征。该模型主要用于支持面向对象技术的软件开发。由于对象概念的引入，使分析、设计、实现之间的表达没有明显间隙。</p>\n</li>\n</ol>\n<h3 id=\"过程规划与管理\"><a href=\"#过程规划与管理\" class=\"headerlink\" title=\"过程规划与管理\"></a>过程规划与管理</h3><ol>\n<li><p>创建一个软件项目生存周期过程的步骤</p>\n<ol>\n<li>选择软件生存周期模型</li>\n<li>细化所选择的生存周期模型</li>\n<li>为每一个活动或任务标识合适的实例数目</li>\n<li>确定活动的时序关系，并检查信息流</li>\n<li>建立过程计划的文档</li>\n</ol>\n</li>\n<li><p>软件评估中应考虑的影响因素</p>\n<ol>\n<li>不管做怎么样的决策，都必须对所采取的的措施对生存周期过程所产生的影响进行评审，以便保证项目获得好的结果。在这一评估中，应考虑以下几方面的影响。<ol>\n<li>所要求的的“返工”</li>\n<li>资源需求</li>\n<li>实施时间</li>\n<li>对项目和用户的益处</li>\n<li>员工情绪</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"集成化能力成熟度模型（CMMI）\"><a href=\"#集成化能力成熟度模型（CMMI）\" class=\"headerlink\" title=\"集成化能力成熟度模型（CMMI）\"></a>集成化能力成熟度模型（CMMI）</h2><h3 id=\"背景和原理\"><a href=\"#背景和原理\" class=\"headerlink\" title=\"背景和原理\"></a>背景和原理</h3><ol>\n<li><p>过程改善</p>\n<p> 历史过程改善，是指人为设计的一个活动程序，其目的是改进组织的过程性能和成熟度，并改进这一程序的结果</p>\n</li>\n<li><p>过程域、专用目标和共用目标</p>\n<p> 过程域是一个业务域中一束相关的实践，当它们一起得以实现时，就满足被认为对该过程域的改善具有重要作用的一组条件<br> 专用目标是用于描述满足该过程域必须呈现的一些独有特征。经可以用于帮助确定一个过程域是否得以满足。<br> 共用目标用于描述产现制度化的该过程必须呈现的特征，仅用于确定一个过程域是否得以满足。</p>\n</li>\n</ol>\n<h3 id=\"CMMI的模型部件\"><a href=\"#CMMI的模型部件\" class=\"headerlink\" title=\"CMMI的模型部件\"></a>CMMI的模型部件</h3><table>\n<thead>\n<tr>\n<th align=\"center\">过程域类名</th>\n<th align=\"left\">包括的过程域</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">项目管理类</td>\n<td align=\"left\">项目规划<br/>项目监控<br/>定量项目管理<br/>集成项目管理<br/>风险管理<br/>提供方协议管理</td>\n</tr>\n<tr>\n<td align=\"center\">工程类</td>\n<td align=\"left\">需求开发<br/>需求管理<br/>技术解决方案<br/>产品集成<br/>确认<br/>验证</td>\n</tr>\n<tr>\n<td align=\"center\">支持类</td>\n<td align=\"left\">配置管理<br/>过程和产品质量保证<br/>测量与分析<br/>原因分析与解决<br/>决策分析与解决</td>\n</tr>\n<tr>\n<td align=\"center\">过程管理类</td>\n<td align=\"left\">组织过程定义<br/>组织过程性能<br/>组织过程培训<br/>组织过程关注<br/>组织创新与部署</td>\n</tr>\n</tbody></table>\n<h3 id=\"CMMI的等级\"><a href=\"#CMMI的等级\" class=\"headerlink\" title=\"CMMI的等级\"></a>CMMI的等级</h3><ol>\n<li><p>能力等级的组成</p>\n<p> 能力等级是用来表征组织对一个过程域的改善，是不断改善一个给定过程域的一种手段。在CMMI中，针对每个过程域设定了6个能力等级，即0级：未完成级；1级：已执行级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：待续优化级。</p>\n</li>\n<li><p>成熟度等级的组成</p>\n<p> 在CMMI中，应用于一个组织过程改善的成熟度等级有5个。即1级：初始级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：持续优化级</p>\n</li>\n<li><p>能力等级与成熟度等级之间的基本关系</p>\n<ol>\n<li>能力等级与成熟度等级是互补的关系，两者都是一种过程改善路径，即表征组织对单一过程域的改进。</li>\n<li>成熟度等级的路径可使组织针对单一过程域不断改善一组相关过程域，即表征组织对一组过程域的改进。</li>\n<li>两种等级的2-5级使用了同样的名字</li>\n</ol>\n</li>\n<li><p>达到各共用目标要实施的共同实践</p>\n<p> 达到公用目标2、共用目标3、共用目标4和共用目标5所要实施的共同实践如下表所示</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">所要实施的共用实践</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">共用目标2：把过程制度化为一个管理过程</td>\n<td align=\"center\">GP2.1 建立组织策略<br/>GP2.2 规划过程<br/>GP2.3 提供资源<br/>GP2.4 指派责任<br/>GP2.5 培训人员<br/>GP2.6 管理配置<br/>GP2.7 标识相关利益方的参与<br/>GP2.8 监控过程<br/>GP2.9 客观地评估符合性<br/>GP2.10 从高层管理的视觉评审状态<br/></td>\n</tr>\n<tr>\n<td align=\"center\">共用目标3：把过程制度化为一个已定义过程</td>\n<td align=\"center\">GP3.1 建立一个已定义的过程<br/>GP3.2 收信进信息 所要实施的共用实践</td>\n</tr>\n<tr>\n<td align=\"center\">共用目标4：把过程制度化为一个已定量管理过程</td>\n<td align=\"center\">GP4.1 为该过程建立定量目的<br/>GP4.2 使子过程性能达到稳定</td>\n</tr>\n<tr>\n<td align=\"center\">共用目标5：把过程制度化为一个持续优化过程</td>\n<td align=\"center\">GP5.1 确保不断进行过程改善<br/>GP5.2 收集问题的根本原因</td>\n</tr>\n</tbody></table>\n<p>完结</p>"},{"title":"建造者模式","author":"Arclin","abbrlink":"fe816c3c","date":"2016-10-29T16:00:00.000Z","_content":"关于建造者模式的个人理解\n建造者模式适用于一个复杂的对象,但是他有多种构建方式,而且每种构建方式都不简单,写在一起不方便维护.建造者模式可以帮助分离对象和它的构建,使得调用相同的一个方法可以创建不同的表示.\n<!-- more -->\n比如说 蛋糕 对象,使用者需要通过调用一个方法,只要传入不同的参数,就可以返回草莓蛋糕,黑森林蛋糕,芝士蛋糕(懒得写了)等.\n\n举蛋糕的例子:\n怎么做蛋糕\n\n```\n- (void)viewDidLoad\n{\n\t[super viewDidLoad];\n\t// 想要什么蛋糕就只要实例化这个蛋糕(下订单)\n\tCakeBulider *bulider = [[StraberryCakeBulider alloc] init];\t\n\t\n\t// 然后让蛋糕店去做蛋糕\n\tCake *cake = [CakeStore createCake:bulider];\n\t\n\t// 看看蛋糕长什么样子\n\tNSLog(@\"%@\",cake.description);\n}\n```\n\nCake.m 蛋糕实体\n\n```\n@interface Cake : NSObject\n\n@property (nonatomic, assign)NSInteger *self.scream;// 奶油分量\n@property (nonatomic, copy)NSString *self.ingredients;// 配料\n@property (nonatomic, assign)NSInteger *self.bakeTime;// 烘焙时间\n// 还有等等好多好多参数，但是我只关心这些\n\n@end\n\n@implementation Cake\n\n// 让它做自我介绍\n- (NSString *)description{\n   return [NSString stringWithFormat:@\"我是一个蛋糕:奶油分量%zd 配料%@ 烘焙时间是:%zd\",self.scream,self.ingredients,self.bakeTime];\n}\n```\n\nCakeStore.m 卖蛋糕的店铺\n\n```\n+ (Cake *)createCake:(CakeBulider *)bulider\n{\n\tCake *cake = [bulider bakeCake];\n\treturn cake;\n}\n```\n\nCakeBulider.m 蛋糕自动烘焙机\n\n```\n- (Cake *)bakeCake\n{\n\tCake *cake = [[Cake alloc] init];\n\tcake.scream = self.scream;\n\tcake.ingredients = self.ingredients;\n\tcake.bakeTime = self.bakeTime;\n\tretrn cake;\n}\n```\n\nStrawberryCakeBulider.m 草莓蛋糕\n\n```\n@interface StrawberryCakeBulider():Cake\n@end\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.scream = 10;\n        self.ingredients = @\"strawberry\";\n        self.bakeTime = 10;\n    }\n    return self;\n}\n```\n\nBlackForestCakeBulider.m 黑森林蛋糕\n\n```\n@interface BlackForestCakeBulider():Cake\n@end\n\n- (instancetype)init\n{\n\tself = [super init];\n\tif(self){\n\t\tself.scream = 11;\n\t\tself.ingredients = @\"cholocate\";\n\t\tself.bakeTime = 5;\n\t}\n\treturn self;\n}\n```\n\n(话说大半夜的写蛋糕真的好吗)\n其实QCCloud那个项目说不定就会用到这个模式,所以在这里稍微复习一下,回忆之前的知识.\n\n(明天再去复习别的即将会用到的设计模式)","source":"_posts/建造者模式.md","raw":"---\ntitle: 建造者模式\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: fe816c3c\ndate: 2016-10-30 00:00:00\n---\n关于建造者模式的个人理解\n建造者模式适用于一个复杂的对象,但是他有多种构建方式,而且每种构建方式都不简单,写在一起不方便维护.建造者模式可以帮助分离对象和它的构建,使得调用相同的一个方法可以创建不同的表示.\n<!-- more -->\n比如说 蛋糕 对象,使用者需要通过调用一个方法,只要传入不同的参数,就可以返回草莓蛋糕,黑森林蛋糕,芝士蛋糕(懒得写了)等.\n\n举蛋糕的例子:\n怎么做蛋糕\n\n```\n- (void)viewDidLoad\n{\n\t[super viewDidLoad];\n\t// 想要什么蛋糕就只要实例化这个蛋糕(下订单)\n\tCakeBulider *bulider = [[StraberryCakeBulider alloc] init];\t\n\t\n\t// 然后让蛋糕店去做蛋糕\n\tCake *cake = [CakeStore createCake:bulider];\n\t\n\t// 看看蛋糕长什么样子\n\tNSLog(@\"%@\",cake.description);\n}\n```\n\nCake.m 蛋糕实体\n\n```\n@interface Cake : NSObject\n\n@property (nonatomic, assign)NSInteger *self.scream;// 奶油分量\n@property (nonatomic, copy)NSString *self.ingredients;// 配料\n@property (nonatomic, assign)NSInteger *self.bakeTime;// 烘焙时间\n// 还有等等好多好多参数，但是我只关心这些\n\n@end\n\n@implementation Cake\n\n// 让它做自我介绍\n- (NSString *)description{\n   return [NSString stringWithFormat:@\"我是一个蛋糕:奶油分量%zd 配料%@ 烘焙时间是:%zd\",self.scream,self.ingredients,self.bakeTime];\n}\n```\n\nCakeStore.m 卖蛋糕的店铺\n\n```\n+ (Cake *)createCake:(CakeBulider *)bulider\n{\n\tCake *cake = [bulider bakeCake];\n\treturn cake;\n}\n```\n\nCakeBulider.m 蛋糕自动烘焙机\n\n```\n- (Cake *)bakeCake\n{\n\tCake *cake = [[Cake alloc] init];\n\tcake.scream = self.scream;\n\tcake.ingredients = self.ingredients;\n\tcake.bakeTime = self.bakeTime;\n\tretrn cake;\n}\n```\n\nStrawberryCakeBulider.m 草莓蛋糕\n\n```\n@interface StrawberryCakeBulider():Cake\n@end\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.scream = 10;\n        self.ingredients = @\"strawberry\";\n        self.bakeTime = 10;\n    }\n    return self;\n}\n```\n\nBlackForestCakeBulider.m 黑森林蛋糕\n\n```\n@interface BlackForestCakeBulider():Cake\n@end\n\n- (instancetype)init\n{\n\tself = [super init];\n\tif(self){\n\t\tself.scream = 11;\n\t\tself.ingredients = @\"cholocate\";\n\t\tself.bakeTime = 5;\n\t}\n\treturn self;\n}\n```\n\n(话说大半夜的写蛋糕真的好吗)\n其实QCCloud那个项目说不定就会用到这个模式,所以在这里稍微复习一下,回忆之前的知识.\n\n(明天再去复习别的即将会用到的设计模式)","slug":"建造者模式","published":1,"updated":"2021-06-06T18:52:24.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoio006jtnn0gj6p776i","content":"<p>关于建造者模式的个人理解<br>建造者模式适用于一个复杂的对象,但是他有多种构建方式,而且每种构建方式都不简单,写在一起不方便维护.建造者模式可以帮助分离对象和它的构建,使得调用相同的一个方法可以创建不同的表示.</p>\n<span id=\"more\"></span>\n<p>比如说 蛋糕 对象,使用者需要通过调用一个方法,只要传入不同的参数,就可以返回草莓蛋糕,黑森林蛋糕,芝士蛋糕(懒得写了)等.</p>\n<p>举蛋糕的例子:<br>怎么做蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[super viewDidLoad];</span><br><span class=\"line\">\t&#x2F;&#x2F; 想要什么蛋糕就只要实例化这个蛋糕(下订单)</span><br><span class=\"line\">\tCakeBulider *bulider &#x3D; [[StraberryCakeBulider alloc] init];\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F; 然后让蛋糕店去做蛋糕</span><br><span class=\"line\">\tCake *cake &#x3D; [CakeStore createCake:bulider];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F; 看看蛋糕长什么样子</span><br><span class=\"line\">\tNSLog(@&quot;%@&quot;,cake.description);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Cake.m 蛋糕实体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Cake : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, assign)NSInteger *self.scream;&#x2F;&#x2F; 奶油分量</span><br><span class=\"line\">@property (nonatomic, copy)NSString *self.ingredients;&#x2F;&#x2F; 配料</span><br><span class=\"line\">@property (nonatomic, assign)NSInteger *self.bakeTime;&#x2F;&#x2F; 烘焙时间</span><br><span class=\"line\">&#x2F;&#x2F; 还有等等好多好多参数，但是我只关心这些</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Cake</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 让它做自我介绍</span><br><span class=\"line\">- (NSString *)description&#123;</span><br><span class=\"line\">   return [NSString stringWithFormat:@&quot;我是一个蛋糕:奶油分量%zd 配料%@ 烘焙时间是:%zd&quot;,self.scream,self.ingredients,self.bakeTime];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>CakeStore.m 卖蛋糕的店铺</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (Cake *)createCake:(CakeBulider *)bulider</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tCake *cake &#x3D; [bulider bakeCake];</span><br><span class=\"line\">\treturn cake;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>CakeBulider.m 蛋糕自动烘焙机</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (Cake *)bakeCake</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tCake *cake &#x3D; [[Cake alloc] init];</span><br><span class=\"line\">\tcake.scream &#x3D; self.scream;</span><br><span class=\"line\">\tcake.ingredients &#x3D; self.ingredients;</span><br><span class=\"line\">\tcake.bakeTime &#x3D; self.bakeTime;</span><br><span class=\"line\">\tretrn cake;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>StrawberryCakeBulider.m 草莓蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface StrawberryCakeBulider():Cake</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self &#x3D; [super init];</span><br><span class=\"line\">    if (self) &#123;</span><br><span class=\"line\">        self.scream &#x3D; 10;</span><br><span class=\"line\">        self.ingredients &#x3D; @&quot;strawberry&quot;;</span><br><span class=\"line\">        self.bakeTime &#x3D; 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>BlackForestCakeBulider.m 黑森林蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface BlackForestCakeBulider():Cake</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tself &#x3D; [super init];</span><br><span class=\"line\">\tif(self)&#123;</span><br><span class=\"line\">\t\tself.scream &#x3D; 11;</span><br><span class=\"line\">\t\tself.ingredients &#x3D; @&quot;cholocate&quot;;</span><br><span class=\"line\">\t\tself.bakeTime &#x3D; 5;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(话说大半夜的写蛋糕真的好吗)<br>其实QCCloud那个项目说不定就会用到这个模式,所以在这里稍微复习一下,回忆之前的知识.</p>\n<p>(明天再去复习别的即将会用到的设计模式)</p>\n","site":{"data":{}},"excerpt":"<p>关于建造者模式的个人理解<br>建造者模式适用于一个复杂的对象,但是他有多种构建方式,而且每种构建方式都不简单,写在一起不方便维护.建造者模式可以帮助分离对象和它的构建,使得调用相同的一个方法可以创建不同的表示.</p>","more":"<p>比如说 蛋糕 对象,使用者需要通过调用一个方法,只要传入不同的参数,就可以返回草莓蛋糕,黑森林蛋糕,芝士蛋糕(懒得写了)等.</p>\n<p>举蛋糕的例子:<br>怎么做蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[super viewDidLoad];</span><br><span class=\"line\">\t&#x2F;&#x2F; 想要什么蛋糕就只要实例化这个蛋糕(下订单)</span><br><span class=\"line\">\tCakeBulider *bulider &#x3D; [[StraberryCakeBulider alloc] init];\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F; 然后让蛋糕店去做蛋糕</span><br><span class=\"line\">\tCake *cake &#x3D; [CakeStore createCake:bulider];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F; 看看蛋糕长什么样子</span><br><span class=\"line\">\tNSLog(@&quot;%@&quot;,cake.description);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Cake.m 蛋糕实体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Cake : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, assign)NSInteger *self.scream;&#x2F;&#x2F; 奶油分量</span><br><span class=\"line\">@property (nonatomic, copy)NSString *self.ingredients;&#x2F;&#x2F; 配料</span><br><span class=\"line\">@property (nonatomic, assign)NSInteger *self.bakeTime;&#x2F;&#x2F; 烘焙时间</span><br><span class=\"line\">&#x2F;&#x2F; 还有等等好多好多参数，但是我只关心这些</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Cake</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 让它做自我介绍</span><br><span class=\"line\">- (NSString *)description&#123;</span><br><span class=\"line\">   return [NSString stringWithFormat:@&quot;我是一个蛋糕:奶油分量%zd 配料%@ 烘焙时间是:%zd&quot;,self.scream,self.ingredients,self.bakeTime];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>CakeStore.m 卖蛋糕的店铺</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (Cake *)createCake:(CakeBulider *)bulider</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tCake *cake &#x3D; [bulider bakeCake];</span><br><span class=\"line\">\treturn cake;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>CakeBulider.m 蛋糕自动烘焙机</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (Cake *)bakeCake</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tCake *cake &#x3D; [[Cake alloc] init];</span><br><span class=\"line\">\tcake.scream &#x3D; self.scream;</span><br><span class=\"line\">\tcake.ingredients &#x3D; self.ingredients;</span><br><span class=\"line\">\tcake.bakeTime &#x3D; self.bakeTime;</span><br><span class=\"line\">\tretrn cake;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>StrawberryCakeBulider.m 草莓蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface StrawberryCakeBulider():Cake</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self &#x3D; [super init];</span><br><span class=\"line\">    if (self) &#123;</span><br><span class=\"line\">        self.scream &#x3D; 10;</span><br><span class=\"line\">        self.ingredients &#x3D; @&quot;strawberry&quot;;</span><br><span class=\"line\">        self.bakeTime &#x3D; 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>BlackForestCakeBulider.m 黑森林蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface BlackForestCakeBulider():Cake</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tself &#x3D; [super init];</span><br><span class=\"line\">\tif(self)&#123;</span><br><span class=\"line\">\t\tself.scream &#x3D; 11;</span><br><span class=\"line\">\t\tself.ingredients &#x3D; @&quot;cholocate&quot;;</span><br><span class=\"line\">\t\tself.bakeTime &#x3D; 5;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(话说大半夜的写蛋糕真的好吗)<br>其实QCCloud那个项目说不定就会用到这个模式,所以在这里稍微复习一下,回忆之前的知识.</p>\n<p>(明天再去复习别的即将会用到的设计模式)</p>"},{"title":"基于DKHTTPTool的业务层设计_尝试版","author":"Arclin","abbrlink":"838ddddd","date":"2016-11-29T16:00:00.000Z","_content":"基于DKHTTPTool的业务层设计_尝试版\n\n由于是尝试版,所以这里只是简单讲下思路.\n\n<!-- more -->\n\n- 首先 DKHTTPTool提供了缓存策略的选择,让方法调用和缓存可以进行统一的处理\n然后业务层进行缓存策略的选择, 但由于 ViewModel实际需要的是一个模型(数组) ,而 `DKHTTPTool`返回的是一个 `DKResponse` 对象,所以业务层除了进行缓存策略的选择外,还需要进行对 `DKResponse`的处理.\n\n- DKResponse 里面有一个成员属性result用来储存后台返回的 json 数据,所以业务层(以下称 Service)需要去对这个属性值进行封装 , 封装的方法我们选择使用 MJExtension 的方法就可以了\n\n- 对于一些数据量比较大,数据结构比较复杂的模型, `MJExtension` 处理之后应该还需要存入数据库,便于日后的筛选,排序等操作.那么,此时逻辑就出现了变化\n\n\t- 对于简单的数据,处理流程是 VM调用Service方法 -> Service 调用 HTTP方法 -> 返回原始数据 -> `MJExtension`处理数据 -> 返回给 VM\n\t- 对于复杂的数据,处理流程是 VM调用Service方法 -> Service 调用 HTTP方法 -> 返回原始数据 -> `MJExtension`处理数据 -> 插入 or 更新 数据库表 - -> 同时返回处理好的数据给 VM\n- 当然第一种是最好处理的,只要套一层方法就可以把数组返回回去了(如果要进行比较简单的数据筛选操作,用 `NSPredicate`,排序用`NSSortDescriptor`也是可以实现的),但是对于第二种方法,那就需要我们新增一个 Service基类去统一处理取数据库数据的操作,包括条件筛选,排序 ,去重的等等的操作","source":"_posts/基于DKHTTPTool的业务层设计-尝试版.md","raw":"---\ntitle: 基于DKHTTPTool的业务层设计_尝试版\nauthor: Arclin\ntags:\n  - iOS\n  - 杂谈\ncategories:\n  - iOS\nabbrlink: 838ddddd\ndate: 2016-11-30 00:00:00\n---\n基于DKHTTPTool的业务层设计_尝试版\n\n由于是尝试版,所以这里只是简单讲下思路.\n\n<!-- more -->\n\n- 首先 DKHTTPTool提供了缓存策略的选择,让方法调用和缓存可以进行统一的处理\n然后业务层进行缓存策略的选择, 但由于 ViewModel实际需要的是一个模型(数组) ,而 `DKHTTPTool`返回的是一个 `DKResponse` 对象,所以业务层除了进行缓存策略的选择外,还需要进行对 `DKResponse`的处理.\n\n- DKResponse 里面有一个成员属性result用来储存后台返回的 json 数据,所以业务层(以下称 Service)需要去对这个属性值进行封装 , 封装的方法我们选择使用 MJExtension 的方法就可以了\n\n- 对于一些数据量比较大,数据结构比较复杂的模型, `MJExtension` 处理之后应该还需要存入数据库,便于日后的筛选,排序等操作.那么,此时逻辑就出现了变化\n\n\t- 对于简单的数据,处理流程是 VM调用Service方法 -> Service 调用 HTTP方法 -> 返回原始数据 -> `MJExtension`处理数据 -> 返回给 VM\n\t- 对于复杂的数据,处理流程是 VM调用Service方法 -> Service 调用 HTTP方法 -> 返回原始数据 -> `MJExtension`处理数据 -> 插入 or 更新 数据库表 - -> 同时返回处理好的数据给 VM\n- 当然第一种是最好处理的,只要套一层方法就可以把数组返回回去了(如果要进行比较简单的数据筛选操作,用 `NSPredicate`,排序用`NSSortDescriptor`也是可以实现的),但是对于第二种方法,那就需要我们新增一个 Service基类去统一处理取数据库数据的操作,包括条件筛选,排序 ,去重的等等的操作","slug":"基于DKHTTPTool的业务层设计-尝试版","published":1,"updated":"2021-06-06T18:52:24.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoip006mtnn0c7shamh4","content":"<p>基于DKHTTPTool的业务层设计_尝试版</p>\n<p>由于是尝试版,所以这里只是简单讲下思路.</p>\n<span id=\"more\"></span>\n\n<ul>\n<li><p>首先 DKHTTPTool提供了缓存策略的选择,让方法调用和缓存可以进行统一的处理<br>然后业务层进行缓存策略的选择, 但由于 ViewModel实际需要的是一个模型(数组) ,而 <code>DKHTTPTool</code>返回的是一个 <code>DKResponse</code> 对象,所以业务层除了进行缓存策略的选择外,还需要进行对 <code>DKResponse</code>的处理.</p>\n</li>\n<li><p>DKResponse 里面有一个成员属性result用来储存后台返回的 json 数据,所以业务层(以下称 Service)需要去对这个属性值进行封装 , 封装的方法我们选择使用 MJExtension 的方法就可以了</p>\n</li>\n<li><p>对于一些数据量比较大,数据结构比较复杂的模型, <code>MJExtension</code> 处理之后应该还需要存入数据库,便于日后的筛选,排序等操作.那么,此时逻辑就出现了变化</p>\n<ul>\n<li>对于简单的数据,处理流程是 VM调用Service方法 -&gt; Service 调用 HTTP方法 -&gt; 返回原始数据 -&gt; <code>MJExtension</code>处理数据 -&gt; 返回给 VM</li>\n<li>对于复杂的数据,处理流程是 VM调用Service方法 -&gt; Service 调用 HTTP方法 -&gt; 返回原始数据 -&gt; <code>MJExtension</code>处理数据 -&gt; 插入 or 更新 数据库表 - -&gt; 同时返回处理好的数据给 VM</li>\n</ul>\n</li>\n<li><p>当然第一种是最好处理的,只要套一层方法就可以把数组返回回去了(如果要进行比较简单的数据筛选操作,用 <code>NSPredicate</code>,排序用<code>NSSortDescriptor</code>也是可以实现的),但是对于第二种方法,那就需要我们新增一个 Service基类去统一处理取数据库数据的操作,包括条件筛选,排序 ,去重的等等的操作</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>基于DKHTTPTool的业务层设计_尝试版</p>\n<p>由于是尝试版,所以这里只是简单讲下思路.</p>","more":"<ul>\n<li><p>首先 DKHTTPTool提供了缓存策略的选择,让方法调用和缓存可以进行统一的处理<br>然后业务层进行缓存策略的选择, 但由于 ViewModel实际需要的是一个模型(数组) ,而 <code>DKHTTPTool</code>返回的是一个 <code>DKResponse</code> 对象,所以业务层除了进行缓存策略的选择外,还需要进行对 <code>DKResponse</code>的处理.</p>\n</li>\n<li><p>DKResponse 里面有一个成员属性result用来储存后台返回的 json 数据,所以业务层(以下称 Service)需要去对这个属性值进行封装 , 封装的方法我们选择使用 MJExtension 的方法就可以了</p>\n</li>\n<li><p>对于一些数据量比较大,数据结构比较复杂的模型, <code>MJExtension</code> 处理之后应该还需要存入数据库,便于日后的筛选,排序等操作.那么,此时逻辑就出现了变化</p>\n<ul>\n<li>对于简单的数据,处理流程是 VM调用Service方法 -&gt; Service 调用 HTTP方法 -&gt; 返回原始数据 -&gt; <code>MJExtension</code>处理数据 -&gt; 返回给 VM</li>\n<li>对于复杂的数据,处理流程是 VM调用Service方法 -&gt; Service 调用 HTTP方法 -&gt; 返回原始数据 -&gt; <code>MJExtension</code>处理数据 -&gt; 插入 or 更新 数据库表 - -&gt; 同时返回处理好的数据给 VM</li>\n</ul>\n</li>\n<li><p>当然第一种是最好处理的,只要套一层方法就可以把数组返回回去了(如果要进行比较简单的数据筛选操作,用 <code>NSPredicate</code>,排序用<code>NSSortDescriptor</code>也是可以实现的),但是对于第二种方法,那就需要我们新增一个 Service基类去统一处理取数据库数据的操作,包括条件筛选,排序 ,去重的等等的操作</p>\n</li>\n</ul>"},{"title":"用Swift的框架Vapor写服务端初体验","author":"Arclin","abbrlink":"73291e5a","date":"2017-03-15T16:00:00.000Z","_content":"咦? 用Swift写后端? 一开始听到的时候懵逼了一秒,一秒自后想了想感觉也没毛病,那就试试看咯.(没看WWDC的后果)\n\n<!-- more -->\n\n## 安装Vapor\n\n`curl -sL toolbox.vapor.sh | bash`\n\n## 创建项目\n\n`vapor new Hello --template=light`\n\n`--template=light` 意思是使用light-template模板,如果不指定模板的话默认使用base-template模板\n\n下载依赖并编译项目\n`vapor build`\n\n50多M的包,好久…\n\n配置服务器\n创建Config文件夹,新建servers.json文件, 指定host地址和端口号\n\n```\n{\n  \"http\": {\n    \"host\": \"0.0.0.0\",\n    \"port\": 8000\n  }\n}\n```\n\n`0.0.0.0` 和 `127.0.0.1` 都表示本机，使用 `0.0.0.0` 的原因是，一个机器可能有多个 IP 地址，`0.0.0.0` 表示监听每个 IP `8000` 端口收到的请求。\n\n`127.0.0.1` 则表示只接受本机发给本机的请求，从网络上其他电脑发过来的请求，不论是请求的哪个 IP，都是不被处理的。\n\n## 打包成一个XCode项目\n`vapor xcode -y` 这样子打包之后就会自动打开了\n\n## 启动服务器\n`vapor run` 或者在XCode运行\n\n看到了控制台输出了\n\n```\nNo command supplied, defaulting to serve...\nNo preparations.\nServer 'http' starting at 0.0.0.0:8000\n```\n\n就可以了\n\n如果说什么`Can not bind to xxxx` 就应该是端口占用的问题,可以用`lsof -i tcp:端口号` 和 `kill -9` 端口号解决这个问题\n\n如果你在浏览器输入`http://localhost:8000`可以看到以下信息就证明服务器启动成功了\n\n```\nRequest  \n- GET / HTTP/1.1\n- Headers:\n    Host: 0.0.0.0:8000\n    Upgrade-Insecure-Requests: 1\n    Connection: keep-alive\n    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36\n    Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2\n    Accept-Encoding: gzip, deflate, sdch\n    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n- Body:\n```\n\n会出现这串东西是因为他执行了`Sources/App/main.swift`的内容,把请求体返回回来.\n\n修改`Sources/App/main.swift`\n把文件改成这样子\n\n```\nimport Vapor\n\nlet drop = Droplet()\n\ndrop.get { _ in\n    return try JSON(node: [\n            \"message\":\"Hello Vapor\"\n        ])\n}\n\ndrop.get(\"Hello\",\"There\") { request in\n    return try JSON (node:[\n            \"message\":\"Hello There\"\n        ])\n}\n\ndrop.get(\"TEST\") { request in\n    return try JSON (node:[\n            \"message\":\"Hello Test\"\n        ])\n}\n\ndrop.run()\n```\n\n然后我们使用Postman测试一下三个地址\n\n`http://localhost:8000/`\n\n![WX20170316-105233@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe803b931.png)\n\n`http://localhost:8000/Hello/There\n\n![WX20170316-105315@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe7f92afc.png)\n\n`http://localhost:8000/TEST`\n\n![WX20170316-105336@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe7fca399.png)\n\n接下来试试接受参数并返回\n\n继续在`drop.run()` 上面补充\n\n```\ndrop.post(\"post\") { request in\n    guard let name = request.data[\"name\"]?.string else {\n        throw Abort.badRequest\n    }\n    return try JSON(node: [\n        \"name\": \"Hello \\(name)!\"\n        ])\n}\n```\n\n> guard近似的看做是Assert，但是你可以优雅的退出而非崩溃。\n\n判断如果没有接收到’name’参数的话就会抛出异常Invalid request,有的话就返回Hello + 参数值 + !\n\n测试一下\n\n![WX20170316-110133@2x.png](https://ooo.0o0.ooo/2017/03/16/58ca001f306a5.png)\n\n部署服务器\nVapor支持Heroku,Ubuntu,Digital Ocean,AWS等等服务器,具体怎么做我还没试过,有时间再去试试看\n\n为什么要用Swift写服务器?\n额,看了一下资料,也没发现有谁说这东西有什么特别突出的优点,不过没试过,觉得挺新鲜,就试试嘛.\n\n> 学习资料 :\n\n> [服务端 Swift - Vapor 篇 （一）](http://www.jianshu.com/p/3fc28570d951)\n\n> [用 Swift 的框架 Vapor 写服务器这事儿怎么样？](http://tips.producter.io/yong-swift-de-kuang-jia-vapor-xie-fu-wu-qi-zhe-shi-er-zen-yao-yang/)","source":"_posts/用Swift的框架Vapor写服务端初体验.md","raw":"---\ntitle: 用Swift的框架Vapor写服务端初体验\nauthor: Arclin\ntags:\n  - Swift\ncategories:\n  - Swift\nabbrlink: 73291e5a\ndate: 2017-03-16 00:00:00\n---\n咦? 用Swift写后端? 一开始听到的时候懵逼了一秒,一秒自后想了想感觉也没毛病,那就试试看咯.(没看WWDC的后果)\n\n<!-- more -->\n\n## 安装Vapor\n\n`curl -sL toolbox.vapor.sh | bash`\n\n## 创建项目\n\n`vapor new Hello --template=light`\n\n`--template=light` 意思是使用light-template模板,如果不指定模板的话默认使用base-template模板\n\n下载依赖并编译项目\n`vapor build`\n\n50多M的包,好久…\n\n配置服务器\n创建Config文件夹,新建servers.json文件, 指定host地址和端口号\n\n```\n{\n  \"http\": {\n    \"host\": \"0.0.0.0\",\n    \"port\": 8000\n  }\n}\n```\n\n`0.0.0.0` 和 `127.0.0.1` 都表示本机，使用 `0.0.0.0` 的原因是，一个机器可能有多个 IP 地址，`0.0.0.0` 表示监听每个 IP `8000` 端口收到的请求。\n\n`127.0.0.1` 则表示只接受本机发给本机的请求，从网络上其他电脑发过来的请求，不论是请求的哪个 IP，都是不被处理的。\n\n## 打包成一个XCode项目\n`vapor xcode -y` 这样子打包之后就会自动打开了\n\n## 启动服务器\n`vapor run` 或者在XCode运行\n\n看到了控制台输出了\n\n```\nNo command supplied, defaulting to serve...\nNo preparations.\nServer 'http' starting at 0.0.0.0:8000\n```\n\n就可以了\n\n如果说什么`Can not bind to xxxx` 就应该是端口占用的问题,可以用`lsof -i tcp:端口号` 和 `kill -9` 端口号解决这个问题\n\n如果你在浏览器输入`http://localhost:8000`可以看到以下信息就证明服务器启动成功了\n\n```\nRequest  \n- GET / HTTP/1.1\n- Headers:\n    Host: 0.0.0.0:8000\n    Upgrade-Insecure-Requests: 1\n    Connection: keep-alive\n    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36\n    Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2\n    Accept-Encoding: gzip, deflate, sdch\n    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n- Body:\n```\n\n会出现这串东西是因为他执行了`Sources/App/main.swift`的内容,把请求体返回回来.\n\n修改`Sources/App/main.swift`\n把文件改成这样子\n\n```\nimport Vapor\n\nlet drop = Droplet()\n\ndrop.get { _ in\n    return try JSON(node: [\n            \"message\":\"Hello Vapor\"\n        ])\n}\n\ndrop.get(\"Hello\",\"There\") { request in\n    return try JSON (node:[\n            \"message\":\"Hello There\"\n        ])\n}\n\ndrop.get(\"TEST\") { request in\n    return try JSON (node:[\n            \"message\":\"Hello Test\"\n        ])\n}\n\ndrop.run()\n```\n\n然后我们使用Postman测试一下三个地址\n\n`http://localhost:8000/`\n\n![WX20170316-105233@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe803b931.png)\n\n`http://localhost:8000/Hello/There\n\n![WX20170316-105315@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe7f92afc.png)\n\n`http://localhost:8000/TEST`\n\n![WX20170316-105336@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe7fca399.png)\n\n接下来试试接受参数并返回\n\n继续在`drop.run()` 上面补充\n\n```\ndrop.post(\"post\") { request in\n    guard let name = request.data[\"name\"]?.string else {\n        throw Abort.badRequest\n    }\n    return try JSON(node: [\n        \"name\": \"Hello \\(name)!\"\n        ])\n}\n```\n\n> guard近似的看做是Assert，但是你可以优雅的退出而非崩溃。\n\n判断如果没有接收到’name’参数的话就会抛出异常Invalid request,有的话就返回Hello + 参数值 + !\n\n测试一下\n\n![WX20170316-110133@2x.png](https://ooo.0o0.ooo/2017/03/16/58ca001f306a5.png)\n\n部署服务器\nVapor支持Heroku,Ubuntu,Digital Ocean,AWS等等服务器,具体怎么做我还没试过,有时间再去试试看\n\n为什么要用Swift写服务器?\n额,看了一下资料,也没发现有谁说这东西有什么特别突出的优点,不过没试过,觉得挺新鲜,就试试嘛.\n\n> 学习资料 :\n\n> [服务端 Swift - Vapor 篇 （一）](http://www.jianshu.com/p/3fc28570d951)\n\n> [用 Swift 的框架 Vapor 写服务器这事儿怎么样？](http://tips.producter.io/yong-swift-de-kuang-jia-vapor-xie-fu-wu-qi-zhe-shi-er-zen-yao-yang/)","slug":"用Swift的框架Vapor写服务端初体验","published":1,"updated":"2021-06-06T18:52:24.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoip006qtnn022cth5j0","content":"<p>咦? 用Swift写后端? 一开始听到的时候懵逼了一秒,一秒自后想了想感觉也没毛病,那就试试看咯.(没看WWDC的后果)</p>\n<span id=\"more\"></span>\n\n<h2 id=\"安装Vapor\"><a href=\"#安装Vapor\" class=\"headerlink\" title=\"安装Vapor\"></a>安装Vapor</h2><p><code>curl -sL toolbox.vapor.sh | bash</code></p>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><p><code>vapor new Hello --template=light</code></p>\n<p><code>--template=light</code> 意思是使用light-template模板,如果不指定模板的话默认使用base-template模板</p>\n<p>下载依赖并编译项目<br><code>vapor build</code></p>\n<p>50多M的包,好久…</p>\n<p>配置服务器<br>创建Config文件夹,新建servers.json文件, 指定host地址和端口号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;http&quot;: &#123;</span><br><span class=\"line\">    &quot;host&quot;: &quot;0.0.0.0&quot;,</span><br><span class=\"line\">    &quot;port&quot;: 8000</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>0.0.0.0</code> 和 <code>127.0.0.1</code> 都表示本机，使用 <code>0.0.0.0</code> 的原因是，一个机器可能有多个 IP 地址，<code>0.0.0.0</code> 表示监听每个 IP <code>8000</code> 端口收到的请求。</p>\n<p><code>127.0.0.1</code> 则表示只接受本机发给本机的请求，从网络上其他电脑发过来的请求，不论是请求的哪个 IP，都是不被处理的。</p>\n<h2 id=\"打包成一个XCode项目\"><a href=\"#打包成一个XCode项目\" class=\"headerlink\" title=\"打包成一个XCode项目\"></a>打包成一个XCode项目</h2><p><code>vapor xcode -y</code> 这样子打包之后就会自动打开了</p>\n<h2 id=\"启动服务器\"><a href=\"#启动服务器\" class=\"headerlink\" title=\"启动服务器\"></a>启动服务器</h2><p><code>vapor run</code> 或者在XCode运行</p>\n<p>看到了控制台输出了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No command supplied, defaulting to serve...</span><br><span class=\"line\">No preparations.</span><br><span class=\"line\">Server &#39;http&#39; starting at 0.0.0.0:8000</span><br></pre></td></tr></table></figure>\n\n<p>就可以了</p>\n<p>如果说什么<code>Can not bind to xxxx</code> 就应该是端口占用的问题,可以用<code>lsof -i tcp:端口号</code> 和 <code>kill -9</code> 端口号解决这个问题</p>\n<p>如果你在浏览器输入<code>http://localhost:8000</code>可以看到以下信息就证明服务器启动成功了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Request  </span><br><span class=\"line\">- GET &#x2F; HTTP&#x2F;1.1</span><br><span class=\"line\">- Headers:</span><br><span class=\"line\">    Host: 0.0.0.0:8000</span><br><span class=\"line\">    Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">    Connection: keep-alive</span><br><span class=\"line\">    User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;57.0.2987.98 Safari&#x2F;537.36</span><br><span class=\"line\">    Accept-Language: en-US,en;q&#x3D;0.8,zh-CN;q&#x3D;0.6,zh;q&#x3D;0.4,zh-TW;q&#x3D;0.2</span><br><span class=\"line\">    Accept-Encoding: gzip, deflate, sdch</span><br><span class=\"line\">    Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8</span><br><span class=\"line\">- Body:</span><br></pre></td></tr></table></figure>\n\n<p>会出现这串东西是因为他执行了<code>Sources/App/main.swift</code>的内容,把请求体返回回来.</p>\n<p>修改<code>Sources/App/main.swift</code><br>把文件改成这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vapor</span><br><span class=\"line\"></span><br><span class=\"line\">let drop &#x3D; Droplet()</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get &#123; _ in</span><br><span class=\"line\">    return try JSON(node: [</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello Vapor&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get(&quot;Hello&quot;,&quot;There&quot;) &#123; request in</span><br><span class=\"line\">    return try JSON (node:[</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello There&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get(&quot;TEST&quot;) &#123; request in</span><br><span class=\"line\">    return try JSON (node:[</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello Test&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.run()</span><br></pre></td></tr></table></figure>\n\n<p>然后我们使用Postman测试一下三个地址</p>\n<p><code>http://localhost:8000/</code></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe803b931.png\" alt=\"WX20170316-105233@2x.png\"></p>\n<p>`<a href=\"http://localhost:8000/Hello/There\">http://localhost:8000/Hello/There</a></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe7f92afc.png\" alt=\"WX20170316-105315@2x.png\"></p>\n<p><code>http://localhost:8000/TEST</code></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe7fca399.png\" alt=\"WX20170316-105336@2x.png\"></p>\n<p>接下来试试接受参数并返回</p>\n<p>继续在<code>drop.run()</code> 上面补充</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drop.post(&quot;post&quot;) &#123; request in</span><br><span class=\"line\">    guard let name &#x3D; request.data[&quot;name&quot;]?.string else &#123;</span><br><span class=\"line\">        throw Abort.badRequest</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return try JSON(node: [</span><br><span class=\"line\">        &quot;name&quot;: &quot;Hello \\(name)!&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>guard近似的看做是Assert，但是你可以优雅的退出而非崩溃。</p>\n</blockquote>\n<p>判断如果没有接收到’name’参数的话就会抛出异常Invalid request,有的话就返回Hello + 参数值 + !</p>\n<p>测试一下</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58ca001f306a5.png\" alt=\"WX20170316-110133@2x.png\"></p>\n<p>部署服务器<br>Vapor支持Heroku,Ubuntu,Digital Ocean,AWS等等服务器,具体怎么做我还没试过,有时间再去试试看</p>\n<p>为什么要用Swift写服务器?<br>额,看了一下资料,也没发现有谁说这东西有什么特别突出的优点,不过没试过,觉得挺新鲜,就试试嘛.</p>\n<blockquote>\n<p>学习资料 :</p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://www.jianshu.com/p/3fc28570d951\">服务端 Swift - Vapor 篇 （一）</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://tips.producter.io/yong-swift-de-kuang-jia-vapor-xie-fu-wu-qi-zhe-shi-er-zen-yao-yang/\">用 Swift 的框架 Vapor 写服务器这事儿怎么样？</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>咦? 用Swift写后端? 一开始听到的时候懵逼了一秒,一秒自后想了想感觉也没毛病,那就试试看咯.(没看WWDC的后果)</p>","more":"<h2 id=\"安装Vapor\"><a href=\"#安装Vapor\" class=\"headerlink\" title=\"安装Vapor\"></a>安装Vapor</h2><p><code>curl -sL toolbox.vapor.sh | bash</code></p>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><p><code>vapor new Hello --template=light</code></p>\n<p><code>--template=light</code> 意思是使用light-template模板,如果不指定模板的话默认使用base-template模板</p>\n<p>下载依赖并编译项目<br><code>vapor build</code></p>\n<p>50多M的包,好久…</p>\n<p>配置服务器<br>创建Config文件夹,新建servers.json文件, 指定host地址和端口号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;http&quot;: &#123;</span><br><span class=\"line\">    &quot;host&quot;: &quot;0.0.0.0&quot;,</span><br><span class=\"line\">    &quot;port&quot;: 8000</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>0.0.0.0</code> 和 <code>127.0.0.1</code> 都表示本机，使用 <code>0.0.0.0</code> 的原因是，一个机器可能有多个 IP 地址，<code>0.0.0.0</code> 表示监听每个 IP <code>8000</code> 端口收到的请求。</p>\n<p><code>127.0.0.1</code> 则表示只接受本机发给本机的请求，从网络上其他电脑发过来的请求，不论是请求的哪个 IP，都是不被处理的。</p>\n<h2 id=\"打包成一个XCode项目\"><a href=\"#打包成一个XCode项目\" class=\"headerlink\" title=\"打包成一个XCode项目\"></a>打包成一个XCode项目</h2><p><code>vapor xcode -y</code> 这样子打包之后就会自动打开了</p>\n<h2 id=\"启动服务器\"><a href=\"#启动服务器\" class=\"headerlink\" title=\"启动服务器\"></a>启动服务器</h2><p><code>vapor run</code> 或者在XCode运行</p>\n<p>看到了控制台输出了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No command supplied, defaulting to serve...</span><br><span class=\"line\">No preparations.</span><br><span class=\"line\">Server &#39;http&#39; starting at 0.0.0.0:8000</span><br></pre></td></tr></table></figure>\n\n<p>就可以了</p>\n<p>如果说什么<code>Can not bind to xxxx</code> 就应该是端口占用的问题,可以用<code>lsof -i tcp:端口号</code> 和 <code>kill -9</code> 端口号解决这个问题</p>\n<p>如果你在浏览器输入<code>http://localhost:8000</code>可以看到以下信息就证明服务器启动成功了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Request  </span><br><span class=\"line\">- GET &#x2F; HTTP&#x2F;1.1</span><br><span class=\"line\">- Headers:</span><br><span class=\"line\">    Host: 0.0.0.0:8000</span><br><span class=\"line\">    Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">    Connection: keep-alive</span><br><span class=\"line\">    User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;57.0.2987.98 Safari&#x2F;537.36</span><br><span class=\"line\">    Accept-Language: en-US,en;q&#x3D;0.8,zh-CN;q&#x3D;0.6,zh;q&#x3D;0.4,zh-TW;q&#x3D;0.2</span><br><span class=\"line\">    Accept-Encoding: gzip, deflate, sdch</span><br><span class=\"line\">    Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8</span><br><span class=\"line\">- Body:</span><br></pre></td></tr></table></figure>\n\n<p>会出现这串东西是因为他执行了<code>Sources/App/main.swift</code>的内容,把请求体返回回来.</p>\n<p>修改<code>Sources/App/main.swift</code><br>把文件改成这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vapor</span><br><span class=\"line\"></span><br><span class=\"line\">let drop &#x3D; Droplet()</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get &#123; _ in</span><br><span class=\"line\">    return try JSON(node: [</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello Vapor&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get(&quot;Hello&quot;,&quot;There&quot;) &#123; request in</span><br><span class=\"line\">    return try JSON (node:[</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello There&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get(&quot;TEST&quot;) &#123; request in</span><br><span class=\"line\">    return try JSON (node:[</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello Test&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.run()</span><br></pre></td></tr></table></figure>\n\n<p>然后我们使用Postman测试一下三个地址</p>\n<p><code>http://localhost:8000/</code></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe803b931.png\" alt=\"WX20170316-105233@2x.png\"></p>\n<p>`<a href=\"http://localhost:8000/Hello/There\">http://localhost:8000/Hello/There</a></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe7f92afc.png\" alt=\"WX20170316-105315@2x.png\"></p>\n<p><code>http://localhost:8000/TEST</code></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe7fca399.png\" alt=\"WX20170316-105336@2x.png\"></p>\n<p>接下来试试接受参数并返回</p>\n<p>继续在<code>drop.run()</code> 上面补充</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drop.post(&quot;post&quot;) &#123; request in</span><br><span class=\"line\">    guard let name &#x3D; request.data[&quot;name&quot;]?.string else &#123;</span><br><span class=\"line\">        throw Abort.badRequest</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return try JSON(node: [</span><br><span class=\"line\">        &quot;name&quot;: &quot;Hello \\(name)!&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>guard近似的看做是Assert，但是你可以优雅的退出而非崩溃。</p>\n</blockquote>\n<p>判断如果没有接收到’name’参数的话就会抛出异常Invalid request,有的话就返回Hello + 参数值 + !</p>\n<p>测试一下</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58ca001f306a5.png\" alt=\"WX20170316-110133@2x.png\"></p>\n<p>部署服务器<br>Vapor支持Heroku,Ubuntu,Digital Ocean,AWS等等服务器,具体怎么做我还没试过,有时间再去试试看</p>\n<p>为什么要用Swift写服务器?<br>额,看了一下资料,也没发现有谁说这东西有什么特别突出的优点,不过没试过,觉得挺新鲜,就试试嘛.</p>\n<blockquote>\n<p>学习资料 :</p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://www.jianshu.com/p/3fc28570d951\">服务端 Swift - Vapor 篇 （一）</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://tips.producter.io/yong-swift-de-kuang-jia-vapor-xie-fu-wu-qi-zhe-shi-er-zen-yao-yang/\">用 Swift 的框架 Vapor 写服务器这事儿怎么样？</a></p>\n</blockquote>"},{"title":"用flow.ci做iOS的持续化集成","author":"Arclin","abbrlink":"2281692e","date":"2017-02-23T16:00:00.000Z","_content":"听说flow.ci上线公测了,赶紧拿着一把限时免费资格玩一玩体验一下.\n\n<!-- more -->\n\n结论: 一套下来行云流水,配置上基本没啥大问题,感觉还是挺好用的.可以支持简单的项目\n\n官方中文文档在这里\n\n里面讲的相当详细,在这里我就讲点注意点就好\n\n1. 如果你想达到的功能除了编译打包外,还想上传到fir,并且想拿最新的git commit 信息作为fir版本更新备注,那么你的工作流可以这么配\n![](https://github.com/Arc-lin/BlogImage/blob/master/1012.png?raw=true)\n2. ‘自定义脚本’里面写的是export CHANGE_LOG=$(git log --pretty=format:\"%s\" -1 $describe) 然后 fir.im 上传插件 中 FIR_CHANGELOG就直接写$CHANGE_LOG这样子就可以做到拿最新的git commit 信息作为fir版本更新备注, $FIR_APP_PATH里面就直接写$FIR_APP_PATH就好了\n3. ‘缓存’那里启用一下安装速度会快些\n4. 如果你的git的根目录不是你项目的根目录的话,你要添加一个’环境变量’(就像上面的图),详情看这里\n5. ‘编译’那里的’Workspace’,填的时候记得把’.xcworkspace’后缀带上\n6. ‘编译’那里的’Workspace’和’Project’两个选一个填,不能一起填\n7. 大概就这么多,以后我遇到啥再补充","source":"_posts/用flow-ci做iOS的持续化集成.md","raw":"---\ntitle: 用flow.ci做iOS的持续化集成\nauthor: Arclin\ntags:\n  - Flow.ci\n  - iOS\ncategories:\n  - iOS\nabbrlink: 2281692e\ndate: 2017-02-24 00:00:00\n---\n听说flow.ci上线公测了,赶紧拿着一把限时免费资格玩一玩体验一下.\n\n<!-- more -->\n\n结论: 一套下来行云流水,配置上基本没啥大问题,感觉还是挺好用的.可以支持简单的项目\n\n官方中文文档在这里\n\n里面讲的相当详细,在这里我就讲点注意点就好\n\n1. 如果你想达到的功能除了编译打包外,还想上传到fir,并且想拿最新的git commit 信息作为fir版本更新备注,那么你的工作流可以这么配\n![](https://github.com/Arc-lin/BlogImage/blob/master/1012.png?raw=true)\n2. ‘自定义脚本’里面写的是export CHANGE_LOG=$(git log --pretty=format:\"%s\" -1 $describe) 然后 fir.im 上传插件 中 FIR_CHANGELOG就直接写$CHANGE_LOG这样子就可以做到拿最新的git commit 信息作为fir版本更新备注, $FIR_APP_PATH里面就直接写$FIR_APP_PATH就好了\n3. ‘缓存’那里启用一下安装速度会快些\n4. 如果你的git的根目录不是你项目的根目录的话,你要添加一个’环境变量’(就像上面的图),详情看这里\n5. ‘编译’那里的’Workspace’,填的时候记得把’.xcworkspace’后缀带上\n6. ‘编译’那里的’Workspace’和’Project’两个选一个填,不能一起填\n7. 大概就这么多,以后我遇到啥再补充","slug":"用flow-ci做iOS的持续化集成","published":1,"updated":"2021-06-06T18:52:24.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoiq006ttnn0cbtpen41","content":"<p>听说flow.ci上线公测了,赶紧拿着一把限时免费资格玩一玩体验一下.</p>\n<span id=\"more\"></span>\n\n<p>结论: 一套下来行云流水,配置上基本没啥大问题,感觉还是挺好用的.可以支持简单的项目</p>\n<p>官方中文文档在这里</p>\n<p>里面讲的相当详细,在这里我就讲点注意点就好</p>\n<ol>\n<li>如果你想达到的功能除了编译打包外,还想上传到fir,并且想拿最新的git commit 信息作为fir版本更新备注,那么你的工作流可以这么配<br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/1012.png?raw=true\"></li>\n<li>‘自定义脚本’里面写的是export CHANGE_LOG=$(git log –pretty=format:”%s” -1 $describe) 然后 fir.im 上传插件 中 FIR_CHANGELOG就直接写$CHANGE_LOG这样子就可以做到拿最新的git commit 信息作为fir版本更新备注, $FIR_APP_PATH里面就直接写$FIR_APP_PATH就好了</li>\n<li>‘缓存’那里启用一下安装速度会快些</li>\n<li>如果你的git的根目录不是你项目的根目录的话,你要添加一个’环境变量’(就像上面的图),详情看这里</li>\n<li>‘编译’那里的’Workspace’,填的时候记得把’.xcworkspace’后缀带上</li>\n<li>‘编译’那里的’Workspace’和’Project’两个选一个填,不能一起填</li>\n<li>大概就这么多,以后我遇到啥再补充</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>听说flow.ci上线公测了,赶紧拿着一把限时免费资格玩一玩体验一下.</p>","more":"<p>结论: 一套下来行云流水,配置上基本没啥大问题,感觉还是挺好用的.可以支持简单的项目</p>\n<p>官方中文文档在这里</p>\n<p>里面讲的相当详细,在这里我就讲点注意点就好</p>\n<ol>\n<li>如果你想达到的功能除了编译打包外,还想上传到fir,并且想拿最新的git commit 信息作为fir版本更新备注,那么你的工作流可以这么配<br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/1012.png?raw=true\"></li>\n<li>‘自定义脚本’里面写的是export CHANGE_LOG=$(git log –pretty=format:”%s” -1 $describe) 然后 fir.im 上传插件 中 FIR_CHANGELOG就直接写$CHANGE_LOG这样子就可以做到拿最新的git commit 信息作为fir版本更新备注, $FIR_APP_PATH里面就直接写$FIR_APP_PATH就好了</li>\n<li>‘缓存’那里启用一下安装速度会快些</li>\n<li>如果你的git的根目录不是你项目的根目录的话,你要添加一个’环境变量’(就像上面的图),详情看这里</li>\n<li>‘编译’那里的’Workspace’,填的时候记得把’.xcworkspace’后缀带上</li>\n<li>‘编译’那里的’Workspace’和’Project’两个选一个填,不能一起填</li>\n<li>大概就这么多,以后我遇到啥再补充</li>\n</ol>"},{"title":"简易架构设计","author":"Arclin","abbrlink":"4948514e","date":"2016-10-28T16:00:00.000Z","_content":"### 继承关系：\n- UIViewController\n\n\t- DKViewContrller\n\n\t\t- DKLoginBaseViewCotroller\n\n\t\t\t- DKLoginViewController\n\t\t\t- DKRegisterViewController\n\t\t\t- DKFoundPswViewController\n\t\t- DKModuleABaseViewCotroller\n\t\t\t- DKAViewController\n\t\t- DKModuleBBaseViewCotroller\n\t\t\t- DKBViewController\n\n### 常量配置\n\n - DKLoginBaseViewController : DKLoginConfig.h\n\n - DKLoginConfig 里面定义常量\n\n\t相关的常量使用UIKIT_EXTERN / FOUNDATION_EXTERA，并且UIKIT_EXTERN / FOUNDATION_EXTERA建议写在模块外的全局DKConfig.h(会在pch里引入)\n - ps: pch建议只写宏，宏之外的其他东西，写在DKConfig.h里面，然后导入pch\n\n - DKModuelABaseViewController : DKModuelAConfig.h\n\n### 调用(import)\n\n```\nDKHomeViewController\n    |-DKLoginViewController\n        |-DKRegisterViewController\n        |-DKLoginBaseViewController\n            |—DKViewController\n                |_ UIKit\n```","source":"_posts/简易架构设计.md","raw":"---\ntitle: 简易架构设计\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 4948514e\ndate: 2016-10-29 00:00:00\n---\n### 继承关系：\n- UIViewController\n\n\t- DKViewContrller\n\n\t\t- DKLoginBaseViewCotroller\n\n\t\t\t- DKLoginViewController\n\t\t\t- DKRegisterViewController\n\t\t\t- DKFoundPswViewController\n\t\t- DKModuleABaseViewCotroller\n\t\t\t- DKAViewController\n\t\t- DKModuleBBaseViewCotroller\n\t\t\t- DKBViewController\n\n### 常量配置\n\n - DKLoginBaseViewController : DKLoginConfig.h\n\n - DKLoginConfig 里面定义常量\n\n\t相关的常量使用UIKIT_EXTERN / FOUNDATION_EXTERA，并且UIKIT_EXTERN / FOUNDATION_EXTERA建议写在模块外的全局DKConfig.h(会在pch里引入)\n - ps: pch建议只写宏，宏之外的其他东西，写在DKConfig.h里面，然后导入pch\n\n - DKModuelABaseViewController : DKModuelAConfig.h\n\n### 调用(import)\n\n```\nDKHomeViewController\n    |-DKLoginViewController\n        |-DKRegisterViewController\n        |-DKLoginBaseViewController\n            |—DKViewController\n                |_ UIKit\n```","slug":"简易架构设计","published":1,"updated":"2021-06-06T18:52:24.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoiq006ytnn06gwz8qs3","content":"<h3 id=\"继承关系：\"><a href=\"#继承关系：\" class=\"headerlink\" title=\"继承关系：\"></a>继承关系：</h3><ul>\n<li><p>UIViewController</p>\n<ul>\n<li><p>DKViewContrller</p>\n<ul>\n<li><p>DKLoginBaseViewCotroller</p>\n<ul>\n<li>DKLoginViewController</li>\n<li>DKRegisterViewController</li>\n<li>DKFoundPswViewController</li>\n</ul>\n</li>\n<li><p>DKModuleABaseViewCotroller</p>\n<ul>\n<li>DKAViewController</li>\n</ul>\n</li>\n<li><p>DKModuleBBaseViewCotroller</p>\n<ul>\n<li>DKBViewController</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常量配置\"><a href=\"#常量配置\" class=\"headerlink\" title=\"常量配置\"></a>常量配置</h3><ul>\n<li><p>DKLoginBaseViewController : DKLoginConfig.h</p>\n</li>\n<li><p>DKLoginConfig 里面定义常量</p>\n<p> 相关的常量使用UIKIT_EXTERN / FOUNDATION_EXTERA，并且UIKIT_EXTERN / FOUNDATION_EXTERA建议写在模块外的全局DKConfig.h(会在pch里引入)</p>\n</li>\n<li><p>ps: pch建议只写宏，宏之外的其他东西，写在DKConfig.h里面，然后导入pch</p>\n</li>\n<li><p>DKModuelABaseViewController : DKModuelAConfig.h</p>\n</li>\n</ul>\n<h3 id=\"调用-import\"><a href=\"#调用-import\" class=\"headerlink\" title=\"调用(import)\"></a>调用(import)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHomeViewController</span><br><span class=\"line\">    |-DKLoginViewController</span><br><span class=\"line\">        |-DKRegisterViewController</span><br><span class=\"line\">        |-DKLoginBaseViewController</span><br><span class=\"line\">            |—DKViewController</span><br><span class=\"line\">                |_ UIKit</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"继承关系：\"><a href=\"#继承关系：\" class=\"headerlink\" title=\"继承关系：\"></a>继承关系：</h3><ul>\n<li><p>UIViewController</p>\n<ul>\n<li><p>DKViewContrller</p>\n<ul>\n<li><p>DKLoginBaseViewCotroller</p>\n<ul>\n<li>DKLoginViewController</li>\n<li>DKRegisterViewController</li>\n<li>DKFoundPswViewController</li>\n</ul>\n</li>\n<li><p>DKModuleABaseViewCotroller</p>\n<ul>\n<li>DKAViewController</li>\n</ul>\n</li>\n<li><p>DKModuleBBaseViewCotroller</p>\n<ul>\n<li>DKBViewController</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常量配置\"><a href=\"#常量配置\" class=\"headerlink\" title=\"常量配置\"></a>常量配置</h3><ul>\n<li><p>DKLoginBaseViewController : DKLoginConfig.h</p>\n</li>\n<li><p>DKLoginConfig 里面定义常量</p>\n<p> 相关的常量使用UIKIT_EXTERN / FOUNDATION_EXTERA，并且UIKIT_EXTERN / FOUNDATION_EXTERA建议写在模块外的全局DKConfig.h(会在pch里引入)</p>\n</li>\n<li><p>ps: pch建议只写宏，宏之外的其他东西，写在DKConfig.h里面，然后导入pch</p>\n</li>\n<li><p>DKModuelABaseViewController : DKModuelAConfig.h</p>\n</li>\n</ul>\n<h3 id=\"调用-import\"><a href=\"#调用-import\" class=\"headerlink\" title=\"调用(import)\"></a>调用(import)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHomeViewController</span><br><span class=\"line\">    |-DKLoginViewController</span><br><span class=\"line\">        |-DKRegisterViewController</span><br><span class=\"line\">        |-DKLoginBaseViewController</span><br><span class=\"line\">            |—DKViewController</span><br><span class=\"line\">                |_ UIKit</span><br></pre></td></tr></table></figure>"},{"title":"组件化方案之强业务组件的设计","abbrlink":"be708589","date":"2020-02-04T02:48:31.000Z","_content":"\n本文简述组件化方案之强业务组件的设计\n\n<!-- more -->\n\n### 如何定义强业务组件\n\n涉及到具体业务需求，能单独完成App某个功能点（主要feature）的组件\n\n### 需要符合什么要求\n\nUI层和逻辑层的绝对独立\n\n需求内容完整\n\n可拓展，可维护\n\n可独立配置UI（UI只可重写、不可修改）\n\n逻辑层不可配置\n\n代码内容清晰明确\n\n### 接下来开始讲故事\n\n#### 背景\n\n随着业务发展，灵机大师说的咨询室模块需要抽离到各个App当中使用，但是由于不同App的网关配置和UI配置都不一样，造成了代码不可以完全进行复用，所以需要对原有代码重新设计。\n\n#### 基本思想\n\n如何设计组件是个比较复杂的问题\n\n首先参考其他第三方IM提供商的Demo，基本上要用他们的UI的话就只能全套用，提供的配置项比较有限，自己改里面的东西成本很大，也不方便。\n\n然后考虑自己如何修改原有代码\n\n参考原有MVVM架构的话，在View和ViewModel之间是一个强耦合的状态，View会直接依赖ViewModel，如果使用方需要定制UI则会十分懵逼，不明确自己的View需要做什么才能配合ViewModel的使用。但这并不意味着MVVM就不能用，在组件初期，为了快速成型，必须沿用之前的设计模式。\n\n接下来思考第二种方案，一种能够高度分离职责的架构，那便是VIPER。确实，在VIPER的设计思想中，单一职责原则体现得很好：Presenter寻找实现了InputProtocol的ViewController并给予数据，ViewController内的操作事件则通过实现了OutputProtocol的Presenter去执行，Presenter内部又通过Interactor和wireframe去实现数据获取和路由的交互，这种面相协议的开发也十分契合我们的需求，协议的方式能够很明确的让使用者知道他要做什么和他需要给予什么。但是VIPER的结构比较复杂比较适合后期在发展，目前还是以MVVM为主比较好。\n\n那么如何改进我们现有的MVVM模式？这里我们就要将VIPER的精髓，面向协议和依赖注入抽离出来。\n\n#### 依赖注入\n\n首先先说明什么叫做依赖注入\n\n比如AController跳转到BController,那么这时候BController就需要在AController内部进行实例化，如下\n\n```\n@implementation AController : UIViewController\n\n...\n\n- (void)jump \n{\n\tBController *bController = [[BController alloc] init];\n    [self.navigationController pushViewController:bController animated:YES];\n}\n\n@end\n\n```\n\n这么做的话，当AController被封装成组件之后，BController的配置将会被限制，外部无法改变BController任何细节，所以我们 ** 稍 加 改 进 **\n\n```\n@implementation AController : UIViewController\n\n...\n\n- (instancetype)initWithCreateBlock:(UIViewController *(^)(void))createBViewControllerBlock {\n\t....\n\tself.createBViewControllerBlock = createBViewControllerBlock;\n\t...\n}\n\n- (void)jump \n{\n\tUIViewController *bController = self.createBViewControllerBlock();\n    [self.navigationController pushViewController:bController animated:YES];\n}\n\n@end\n\n```\n\n```\n[[AController alloc] initWithCreateBlock:UIViewController* ^{\n\tBController *bController = [[BController alloc] initWithTitle:@\"xxx\"];\n\treturn bController;\n}];\n```\n\n将BController的创建通过Block暴露出来，AController内部不关心BController是如何被创建的，那么AController对BController的依赖将通过外部的Block进行注入。\n\n这，就是依赖注入。\n\n\n当然这是最简单的依赖注入，无法满足我们复杂的需求，所以有时候我们需要使用第三方框架，如`Objection`和`Typhoon`\n\n#### 依赖倒置\n\n依赖倒置是是六个设计原则之一。依赖倒置意味着实现依赖于抽象，抽象不依赖实现。\n\n举个例子\n\n当你需要买一杯饮料，你不需要到具体哪家店买，反正任意一个便利店都有饮料卖，所以你需要的并不是获得美宜佳的地址或者711的地址，你需要的只是一个“卖饮料的店”，这是一个抽象的概念，这样子就是依赖被倒置了，本来是你去寻找美宜佳，现在变成拥有“卖饮料”功能的店去满足你。\n\n在iOS中，抽象是通过代理体现的\n\n同样的，我们再来看看刚刚的代码\n\n```\n@implementation AController : UIViewController\n\n...\n\n- (void)jump \n{\n\tBController *bController = [[BController alloc] init];\n    [self.navigationController pushViewController:bController animated:YES];\n}\n\n@end\n```\n\n根据依赖倒置原则进行改造\n\n```\n\n@interface AController()\n\n@property(weak) id<BControllerProtocol> bViewController;\n\n@end\n\n@implementation AController : UIViewController\n\n...\n\n- (void)jump \n{\n    [self.navigationController pushViewController:self.bViewController animated:YES];\n}\n\n@end\n```\n\n```\nAViewController *aViewController = [[AViewController alloc] init];\nid<BControllerProtocol> bViewController = [[BViewController alloc] init];\naViewController.bViewController = bViewController;\n```\n\n\n#### 依赖注入+依赖倒置\n\n将协议和注入的模式进行结合，仿照上面的代码，估计就是这样子\n\n```\n[[AController alloc] initWithCreateBlock:UIViewController<BControllerProtocol>* ^{\n\tid<BControllerProtocol> bController = [[BController alloc] initWithTitle:@\"xxx\"];\n\treturn bController;\n}];\n```\n\n当然 这种模式只是个例子，给大家一种具体的观感\n\n实际上在编码的时候，一个控制器往往有很多依赖，这里分为`可注入依赖`和`不可注入依赖`\n\n可注入的依赖往往是一些可以配置的依赖，使用者通过将自己自定义的配置注入，覆盖原有的默认依赖，达到配置内部样式的效果\n\n反之，不可注入的依赖就会是代码中固定的耦合项目，合理的耦合以不至于组件产生过多未知问题。\n\n刚刚说到一些依赖注入的第三方框架`Objection`和`Typhoon`，这个之后再详细介绍，这里简单说明一下，当使用方需要使用自定义类注入组件的时候，都是需要依赖这两种框架，不能只由组件内部依赖，所以为了避免不必要的学习成本，暂时先不使用，后面如果拓展开了使用方法，可能会修改使用，我们这里先用一些理解起来比较简单但是操作起来可能比较麻烦的注入方式。\n\n首先我们这里我们新增一个单例用于注入，通过反射机制实例化自定义的对象，然后进行注入。\n\n当然这个对象是需要遵循我们对应的协议的。\n\n协议我们按照VIPIER的规范，分为两种`InputProtocol`和`OutputProtocol`\n\n`InputProtocol`包括控制器需要的外部参数\n`OutputProtocol`包括控制器的回调参数\n\n按照目前咨询室的设计模式看来，是由三个控制器（一个父控制器和两个子控制器）构成，他们分别会有自己的`InputProtocol`和`OutputProtocol`，如果业务端需要自己实现UI则自己实现协议然后进行注入即可。\n\n\n待续\n\n有空继续写\n\n","source":"_posts/组件化方案之强业务组件的设计.md","raw":"---\ntitle: 组件化方案之强业务组件的设计\ntags:\n  - iOS\n  - 架构\ncategories:\n  - iOS\nabbrlink: be708589\ndate: 2020-02-04 10:48:31\n---\n\n本文简述组件化方案之强业务组件的设计\n\n<!-- more -->\n\n### 如何定义强业务组件\n\n涉及到具体业务需求，能单独完成App某个功能点（主要feature）的组件\n\n### 需要符合什么要求\n\nUI层和逻辑层的绝对独立\n\n需求内容完整\n\n可拓展，可维护\n\n可独立配置UI（UI只可重写、不可修改）\n\n逻辑层不可配置\n\n代码内容清晰明确\n\n### 接下来开始讲故事\n\n#### 背景\n\n随着业务发展，灵机大师说的咨询室模块需要抽离到各个App当中使用，但是由于不同App的网关配置和UI配置都不一样，造成了代码不可以完全进行复用，所以需要对原有代码重新设计。\n\n#### 基本思想\n\n如何设计组件是个比较复杂的问题\n\n首先参考其他第三方IM提供商的Demo，基本上要用他们的UI的话就只能全套用，提供的配置项比较有限，自己改里面的东西成本很大，也不方便。\n\n然后考虑自己如何修改原有代码\n\n参考原有MVVM架构的话，在View和ViewModel之间是一个强耦合的状态，View会直接依赖ViewModel，如果使用方需要定制UI则会十分懵逼，不明确自己的View需要做什么才能配合ViewModel的使用。但这并不意味着MVVM就不能用，在组件初期，为了快速成型，必须沿用之前的设计模式。\n\n接下来思考第二种方案，一种能够高度分离职责的架构，那便是VIPER。确实，在VIPER的设计思想中，单一职责原则体现得很好：Presenter寻找实现了InputProtocol的ViewController并给予数据，ViewController内的操作事件则通过实现了OutputProtocol的Presenter去执行，Presenter内部又通过Interactor和wireframe去实现数据获取和路由的交互，这种面相协议的开发也十分契合我们的需求，协议的方式能够很明确的让使用者知道他要做什么和他需要给予什么。但是VIPER的结构比较复杂比较适合后期在发展，目前还是以MVVM为主比较好。\n\n那么如何改进我们现有的MVVM模式？这里我们就要将VIPER的精髓，面向协议和依赖注入抽离出来。\n\n#### 依赖注入\n\n首先先说明什么叫做依赖注入\n\n比如AController跳转到BController,那么这时候BController就需要在AController内部进行实例化，如下\n\n```\n@implementation AController : UIViewController\n\n...\n\n- (void)jump \n{\n\tBController *bController = [[BController alloc] init];\n    [self.navigationController pushViewController:bController animated:YES];\n}\n\n@end\n\n```\n\n这么做的话，当AController被封装成组件之后，BController的配置将会被限制，外部无法改变BController任何细节，所以我们 ** 稍 加 改 进 **\n\n```\n@implementation AController : UIViewController\n\n...\n\n- (instancetype)initWithCreateBlock:(UIViewController *(^)(void))createBViewControllerBlock {\n\t....\n\tself.createBViewControllerBlock = createBViewControllerBlock;\n\t...\n}\n\n- (void)jump \n{\n\tUIViewController *bController = self.createBViewControllerBlock();\n    [self.navigationController pushViewController:bController animated:YES];\n}\n\n@end\n\n```\n\n```\n[[AController alloc] initWithCreateBlock:UIViewController* ^{\n\tBController *bController = [[BController alloc] initWithTitle:@\"xxx\"];\n\treturn bController;\n}];\n```\n\n将BController的创建通过Block暴露出来，AController内部不关心BController是如何被创建的，那么AController对BController的依赖将通过外部的Block进行注入。\n\n这，就是依赖注入。\n\n\n当然这是最简单的依赖注入，无法满足我们复杂的需求，所以有时候我们需要使用第三方框架，如`Objection`和`Typhoon`\n\n#### 依赖倒置\n\n依赖倒置是是六个设计原则之一。依赖倒置意味着实现依赖于抽象，抽象不依赖实现。\n\n举个例子\n\n当你需要买一杯饮料，你不需要到具体哪家店买，反正任意一个便利店都有饮料卖，所以你需要的并不是获得美宜佳的地址或者711的地址，你需要的只是一个“卖饮料的店”，这是一个抽象的概念，这样子就是依赖被倒置了，本来是你去寻找美宜佳，现在变成拥有“卖饮料”功能的店去满足你。\n\n在iOS中，抽象是通过代理体现的\n\n同样的，我们再来看看刚刚的代码\n\n```\n@implementation AController : UIViewController\n\n...\n\n- (void)jump \n{\n\tBController *bController = [[BController alloc] init];\n    [self.navigationController pushViewController:bController animated:YES];\n}\n\n@end\n```\n\n根据依赖倒置原则进行改造\n\n```\n\n@interface AController()\n\n@property(weak) id<BControllerProtocol> bViewController;\n\n@end\n\n@implementation AController : UIViewController\n\n...\n\n- (void)jump \n{\n    [self.navigationController pushViewController:self.bViewController animated:YES];\n}\n\n@end\n```\n\n```\nAViewController *aViewController = [[AViewController alloc] init];\nid<BControllerProtocol> bViewController = [[BViewController alloc] init];\naViewController.bViewController = bViewController;\n```\n\n\n#### 依赖注入+依赖倒置\n\n将协议和注入的模式进行结合，仿照上面的代码，估计就是这样子\n\n```\n[[AController alloc] initWithCreateBlock:UIViewController<BControllerProtocol>* ^{\n\tid<BControllerProtocol> bController = [[BController alloc] initWithTitle:@\"xxx\"];\n\treturn bController;\n}];\n```\n\n当然 这种模式只是个例子，给大家一种具体的观感\n\n实际上在编码的时候，一个控制器往往有很多依赖，这里分为`可注入依赖`和`不可注入依赖`\n\n可注入的依赖往往是一些可以配置的依赖，使用者通过将自己自定义的配置注入，覆盖原有的默认依赖，达到配置内部样式的效果\n\n反之，不可注入的依赖就会是代码中固定的耦合项目，合理的耦合以不至于组件产生过多未知问题。\n\n刚刚说到一些依赖注入的第三方框架`Objection`和`Typhoon`，这个之后再详细介绍，这里简单说明一下，当使用方需要使用自定义类注入组件的时候，都是需要依赖这两种框架，不能只由组件内部依赖，所以为了避免不必要的学习成本，暂时先不使用，后面如果拓展开了使用方法，可能会修改使用，我们这里先用一些理解起来比较简单但是操作起来可能比较麻烦的注入方式。\n\n首先我们这里我们新增一个单例用于注入，通过反射机制实例化自定义的对象，然后进行注入。\n\n当然这个对象是需要遵循我们对应的协议的。\n\n协议我们按照VIPIER的规范，分为两种`InputProtocol`和`OutputProtocol`\n\n`InputProtocol`包括控制器需要的外部参数\n`OutputProtocol`包括控制器的回调参数\n\n按照目前咨询室的设计模式看来，是由三个控制器（一个父控制器和两个子控制器）构成，他们分别会有自己的`InputProtocol`和`OutputProtocol`，如果业务端需要自己实现UI则自己实现协议然后进行注入即可。\n\n\n待续\n\n有空继续写\n\n","slug":"组件化方案之强业务组件的设计","published":1,"updated":"2021-06-06T18:52:24.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoir0071tnn0fyq74sb2","content":"<p>本文简述组件化方案之强业务组件的设计</p>\n<span id=\"more\"></span>\n\n<h3 id=\"如何定义强业务组件\"><a href=\"#如何定义强业务组件\" class=\"headerlink\" title=\"如何定义强业务组件\"></a>如何定义强业务组件</h3><p>涉及到具体业务需求，能单独完成App某个功能点（主要feature）的组件</p>\n<h3 id=\"需要符合什么要求\"><a href=\"#需要符合什么要求\" class=\"headerlink\" title=\"需要符合什么要求\"></a>需要符合什么要求</h3><p>UI层和逻辑层的绝对独立</p>\n<p>需求内容完整</p>\n<p>可拓展，可维护</p>\n<p>可独立配置UI（UI只可重写、不可修改）</p>\n<p>逻辑层不可配置</p>\n<p>代码内容清晰明确</p>\n<h3 id=\"接下来开始讲故事\"><a href=\"#接下来开始讲故事\" class=\"headerlink\" title=\"接下来开始讲故事\"></a>接下来开始讲故事</h3><h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4><p>随着业务发展，灵机大师说的咨询室模块需要抽离到各个App当中使用，但是由于不同App的网关配置和UI配置都不一样，造成了代码不可以完全进行复用，所以需要对原有代码重新设计。</p>\n<h4 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h4><p>如何设计组件是个比较复杂的问题</p>\n<p>首先参考其他第三方IM提供商的Demo，基本上要用他们的UI的话就只能全套用，提供的配置项比较有限，自己改里面的东西成本很大，也不方便。</p>\n<p>然后考虑自己如何修改原有代码</p>\n<p>参考原有MVVM架构的话，在View和ViewModel之间是一个强耦合的状态，View会直接依赖ViewModel，如果使用方需要定制UI则会十分懵逼，不明确自己的View需要做什么才能配合ViewModel的使用。但这并不意味着MVVM就不能用，在组件初期，为了快速成型，必须沿用之前的设计模式。</p>\n<p>接下来思考第二种方案，一种能够高度分离职责的架构，那便是VIPER。确实，在VIPER的设计思想中，单一职责原则体现得很好：Presenter寻找实现了InputProtocol的ViewController并给予数据，ViewController内的操作事件则通过实现了OutputProtocol的Presenter去执行，Presenter内部又通过Interactor和wireframe去实现数据获取和路由的交互，这种面相协议的开发也十分契合我们的需求，协议的方式能够很明确的让使用者知道他要做什么和他需要给予什么。但是VIPER的结构比较复杂比较适合后期在发展，目前还是以MVVM为主比较好。</p>\n<p>那么如何改进我们现有的MVVM模式？这里我们就要将VIPER的精髓，面向协议和依赖注入抽离出来。</p>\n<h4 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h4><p>首先先说明什么叫做依赖注入</p>\n<p>比如AController跳转到BController,那么这时候BController就需要在AController内部进行实例化，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation AController : UIViewController</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)jump </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBController *bController &#x3D; [[BController alloc] init];</span><br><span class=\"line\">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这么做的话，当AController被封装成组件之后，BController的配置将会被限制，外部无法改变BController任何细节，所以我们 ** 稍 加 改 进 **</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation AController : UIViewController</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithCreateBlock:(UIViewController *(^)(void))createBViewControllerBlock &#123;</span><br><span class=\"line\">\t....</span><br><span class=\"line\">\tself.createBViewControllerBlock &#x3D; createBViewControllerBlock;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)jump </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tUIViewController *bController &#x3D; self.createBViewControllerBlock();</span><br><span class=\"line\">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[AController alloc] initWithCreateBlock:UIViewController* ^&#123;</span><br><span class=\"line\">\tBController *bController &#x3D; [[BController alloc] initWithTitle:@&quot;xxx&quot;];</span><br><span class=\"line\">\treturn bController;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>将BController的创建通过Block暴露出来，AController内部不关心BController是如何被创建的，那么AController对BController的依赖将通过外部的Block进行注入。</p>\n<p>这，就是依赖注入。</p>\n<p>当然这是最简单的依赖注入，无法满足我们复杂的需求，所以有时候我们需要使用第三方框架，如<code>Objection</code>和<code>Typhoon</code></p>\n<h4 id=\"依赖倒置\"><a href=\"#依赖倒置\" class=\"headerlink\" title=\"依赖倒置\"></a>依赖倒置</h4><p>依赖倒置是是六个设计原则之一。依赖倒置意味着实现依赖于抽象，抽象不依赖实现。</p>\n<p>举个例子</p>\n<p>当你需要买一杯饮料，你不需要到具体哪家店买，反正任意一个便利店都有饮料卖，所以你需要的并不是获得美宜佳的地址或者711的地址，你需要的只是一个“卖饮料的店”，这是一个抽象的概念，这样子就是依赖被倒置了，本来是你去寻找美宜佳，现在变成拥有“卖饮料”功能的店去满足你。</p>\n<p>在iOS中，抽象是通过代理体现的</p>\n<p>同样的，我们再来看看刚刚的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation AController : UIViewController</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)jump </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBController *bController &#x3D; [[BController alloc] init];</span><br><span class=\"line\">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>根据依赖倒置原则进行改造</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">@interface AController()</span><br><span class=\"line\"></span><br><span class=\"line\">@property(weak) id&lt;BControllerProtocol&gt; bViewController;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation AController : UIViewController</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)jump </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.navigationController pushViewController:self.bViewController animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AViewController *aViewController &#x3D; [[AViewController alloc] init];</span><br><span class=\"line\">id&lt;BControllerProtocol&gt; bViewController &#x3D; [[BViewController alloc] init];</span><br><span class=\"line\">aViewController.bViewController &#x3D; bViewController;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"依赖注入-依赖倒置\"><a href=\"#依赖注入-依赖倒置\" class=\"headerlink\" title=\"依赖注入+依赖倒置\"></a>依赖注入+依赖倒置</h4><p>将协议和注入的模式进行结合，仿照上面的代码，估计就是这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[AController alloc] initWithCreateBlock:UIViewController&lt;BControllerProtocol&gt;* ^&#123;</span><br><span class=\"line\">\tid&lt;BControllerProtocol&gt; bController &#x3D; [[BController alloc] initWithTitle:@&quot;xxx&quot;];</span><br><span class=\"line\">\treturn bController;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>当然 这种模式只是个例子，给大家一种具体的观感</p>\n<p>实际上在编码的时候，一个控制器往往有很多依赖，这里分为<code>可注入依赖</code>和<code>不可注入依赖</code></p>\n<p>可注入的依赖往往是一些可以配置的依赖，使用者通过将自己自定义的配置注入，覆盖原有的默认依赖，达到配置内部样式的效果</p>\n<p>反之，不可注入的依赖就会是代码中固定的耦合项目，合理的耦合以不至于组件产生过多未知问题。</p>\n<p>刚刚说到一些依赖注入的第三方框架<code>Objection</code>和<code>Typhoon</code>，这个之后再详细介绍，这里简单说明一下，当使用方需要使用自定义类注入组件的时候，都是需要依赖这两种框架，不能只由组件内部依赖，所以为了避免不必要的学习成本，暂时先不使用，后面如果拓展开了使用方法，可能会修改使用，我们这里先用一些理解起来比较简单但是操作起来可能比较麻烦的注入方式。</p>\n<p>首先我们这里我们新增一个单例用于注入，通过反射机制实例化自定义的对象，然后进行注入。</p>\n<p>当然这个对象是需要遵循我们对应的协议的。</p>\n<p>协议我们按照VIPIER的规范，分为两种<code>InputProtocol</code>和<code>OutputProtocol</code></p>\n<p><code>InputProtocol</code>包括控制器需要的外部参数<br><code>OutputProtocol</code>包括控制器的回调参数</p>\n<p>按照目前咨询室的设计模式看来，是由三个控制器（一个父控制器和两个子控制器）构成，他们分别会有自己的<code>InputProtocol</code>和<code>OutputProtocol</code>，如果业务端需要自己实现UI则自己实现协议然后进行注入即可。</p>\n<p>待续</p>\n<p>有空继续写</p>\n","site":{"data":{}},"excerpt":"<p>本文简述组件化方案之强业务组件的设计</p>","more":"<h3 id=\"如何定义强业务组件\"><a href=\"#如何定义强业务组件\" class=\"headerlink\" title=\"如何定义强业务组件\"></a>如何定义强业务组件</h3><p>涉及到具体业务需求，能单独完成App某个功能点（主要feature）的组件</p>\n<h3 id=\"需要符合什么要求\"><a href=\"#需要符合什么要求\" class=\"headerlink\" title=\"需要符合什么要求\"></a>需要符合什么要求</h3><p>UI层和逻辑层的绝对独立</p>\n<p>需求内容完整</p>\n<p>可拓展，可维护</p>\n<p>可独立配置UI（UI只可重写、不可修改）</p>\n<p>逻辑层不可配置</p>\n<p>代码内容清晰明确</p>\n<h3 id=\"接下来开始讲故事\"><a href=\"#接下来开始讲故事\" class=\"headerlink\" title=\"接下来开始讲故事\"></a>接下来开始讲故事</h3><h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4><p>随着业务发展，灵机大师说的咨询室模块需要抽离到各个App当中使用，但是由于不同App的网关配置和UI配置都不一样，造成了代码不可以完全进行复用，所以需要对原有代码重新设计。</p>\n<h4 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h4><p>如何设计组件是个比较复杂的问题</p>\n<p>首先参考其他第三方IM提供商的Demo，基本上要用他们的UI的话就只能全套用，提供的配置项比较有限，自己改里面的东西成本很大，也不方便。</p>\n<p>然后考虑自己如何修改原有代码</p>\n<p>参考原有MVVM架构的话，在View和ViewModel之间是一个强耦合的状态，View会直接依赖ViewModel，如果使用方需要定制UI则会十分懵逼，不明确自己的View需要做什么才能配合ViewModel的使用。但这并不意味着MVVM就不能用，在组件初期，为了快速成型，必须沿用之前的设计模式。</p>\n<p>接下来思考第二种方案，一种能够高度分离职责的架构，那便是VIPER。确实，在VIPER的设计思想中，单一职责原则体现得很好：Presenter寻找实现了InputProtocol的ViewController并给予数据，ViewController内的操作事件则通过实现了OutputProtocol的Presenter去执行，Presenter内部又通过Interactor和wireframe去实现数据获取和路由的交互，这种面相协议的开发也十分契合我们的需求，协议的方式能够很明确的让使用者知道他要做什么和他需要给予什么。但是VIPER的结构比较复杂比较适合后期在发展，目前还是以MVVM为主比较好。</p>\n<p>那么如何改进我们现有的MVVM模式？这里我们就要将VIPER的精髓，面向协议和依赖注入抽离出来。</p>\n<h4 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h4><p>首先先说明什么叫做依赖注入</p>\n<p>比如AController跳转到BController,那么这时候BController就需要在AController内部进行实例化，如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation AController : UIViewController</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)jump </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBController *bController &#x3D; [[BController alloc] init];</span><br><span class=\"line\">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这么做的话，当AController被封装成组件之后，BController的配置将会被限制，外部无法改变BController任何细节，所以我们 ** 稍 加 改 进 **</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation AController : UIViewController</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithCreateBlock:(UIViewController *(^)(void))createBViewControllerBlock &#123;</span><br><span class=\"line\">\t....</span><br><span class=\"line\">\tself.createBViewControllerBlock &#x3D; createBViewControllerBlock;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)jump </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tUIViewController *bController &#x3D; self.createBViewControllerBlock();</span><br><span class=\"line\">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[AController alloc] initWithCreateBlock:UIViewController* ^&#123;</span><br><span class=\"line\">\tBController *bController &#x3D; [[BController alloc] initWithTitle:@&quot;xxx&quot;];</span><br><span class=\"line\">\treturn bController;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>将BController的创建通过Block暴露出来，AController内部不关心BController是如何被创建的，那么AController对BController的依赖将通过外部的Block进行注入。</p>\n<p>这，就是依赖注入。</p>\n<p>当然这是最简单的依赖注入，无法满足我们复杂的需求，所以有时候我们需要使用第三方框架，如<code>Objection</code>和<code>Typhoon</code></p>\n<h4 id=\"依赖倒置\"><a href=\"#依赖倒置\" class=\"headerlink\" title=\"依赖倒置\"></a>依赖倒置</h4><p>依赖倒置是是六个设计原则之一。依赖倒置意味着实现依赖于抽象，抽象不依赖实现。</p>\n<p>举个例子</p>\n<p>当你需要买一杯饮料，你不需要到具体哪家店买，反正任意一个便利店都有饮料卖，所以你需要的并不是获得美宜佳的地址或者711的地址，你需要的只是一个“卖饮料的店”，这是一个抽象的概念，这样子就是依赖被倒置了，本来是你去寻找美宜佳，现在变成拥有“卖饮料”功能的店去满足你。</p>\n<p>在iOS中，抽象是通过代理体现的</p>\n<p>同样的，我们再来看看刚刚的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation AController : UIViewController</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)jump </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBController *bController &#x3D; [[BController alloc] init];</span><br><span class=\"line\">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>根据依赖倒置原则进行改造</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">@interface AController()</span><br><span class=\"line\"></span><br><span class=\"line\">@property(weak) id&lt;BControllerProtocol&gt; bViewController;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation AController : UIViewController</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)jump </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.navigationController pushViewController:self.bViewController animated:YES];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AViewController *aViewController &#x3D; [[AViewController alloc] init];</span><br><span class=\"line\">id&lt;BControllerProtocol&gt; bViewController &#x3D; [[BViewController alloc] init];</span><br><span class=\"line\">aViewController.bViewController &#x3D; bViewController;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"依赖注入-依赖倒置\"><a href=\"#依赖注入-依赖倒置\" class=\"headerlink\" title=\"依赖注入+依赖倒置\"></a>依赖注入+依赖倒置</h4><p>将协议和注入的模式进行结合，仿照上面的代码，估计就是这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[AController alloc] initWithCreateBlock:UIViewController&lt;BControllerProtocol&gt;* ^&#123;</span><br><span class=\"line\">\tid&lt;BControllerProtocol&gt; bController &#x3D; [[BController alloc] initWithTitle:@&quot;xxx&quot;];</span><br><span class=\"line\">\treturn bController;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>当然 这种模式只是个例子，给大家一种具体的观感</p>\n<p>实际上在编码的时候，一个控制器往往有很多依赖，这里分为<code>可注入依赖</code>和<code>不可注入依赖</code></p>\n<p>可注入的依赖往往是一些可以配置的依赖，使用者通过将自己自定义的配置注入，覆盖原有的默认依赖，达到配置内部样式的效果</p>\n<p>反之，不可注入的依赖就会是代码中固定的耦合项目，合理的耦合以不至于组件产生过多未知问题。</p>\n<p>刚刚说到一些依赖注入的第三方框架<code>Objection</code>和<code>Typhoon</code>，这个之后再详细介绍，这里简单说明一下，当使用方需要使用自定义类注入组件的时候，都是需要依赖这两种框架，不能只由组件内部依赖，所以为了避免不必要的学习成本，暂时先不使用，后面如果拓展开了使用方法，可能会修改使用，我们这里先用一些理解起来比较简单但是操作起来可能比较麻烦的注入方式。</p>\n<p>首先我们这里我们新增一个单例用于注入，通过反射机制实例化自定义的对象，然后进行注入。</p>\n<p>当然这个对象是需要遵循我们对应的协议的。</p>\n<p>协议我们按照VIPIER的规范，分为两种<code>InputProtocol</code>和<code>OutputProtocol</code></p>\n<p><code>InputProtocol</code>包括控制器需要的外部参数<br><code>OutputProtocol</code>包括控制器的回调参数</p>\n<p>按照目前咨询室的设计模式看来，是由三个控制器（一个父控制器和两个子控制器）构成，他们分别会有自己的<code>InputProtocol</code>和<code>OutputProtocol</code>，如果业务端需要自己实现UI则自己实现协议然后进行注入即可。</p>\n<p>待续</p>\n<p>有空继续写</p>"},{"title":"组合模式","author":"Arclin","abbrlink":"df879792","date":"2016-10-31T16:00:00.000Z","_content":"其实组合模式就是为了便于管理一个树形结构（抽象的）的对象，能让客户端统一处理这个对象的一种设计模式\n\n<!-- more -->\n\n举个例子\n\n```\n帽子\n  |_贝雷帽\n  |_鸭舌帽\n      |_黑色鸭舌\n衣服\n  |_衬衫\n      |_蓝色衬衫\n      |_白色衬衫\n  |_T恤\n裤子\n  |_牛仔裤\n      |_蓝色牛仔裤\n  |_短裤\n\n```\n\n那么这时候如果客户端要拿到一顶黑色鸭舌帽，一件白色衬衫和一条蓝色牛仔裤，那么应该怎么取到呢？或者想从对象中删除这些东西呢？\n\n首先我们需要有一个衣柜\n\n```\nWardrobe *wardrobe = [[Wardrobe alloc] init];\n```\n\n然后为其我们添加子节点\n\n```\n[wardrobe addDress:hat];\n[wardrobe addDress:clothes];\n[wardrobe addDress:trousers];\n```\n\n那 `hat` 和 `clothes` 和 `trousers` 怎么来 (以 hat 举例)\n\n```\nHat *hat = [[Hat alloc] init];\nHat *yashe_hat = [[Hat alloc] initWithType:@\"Yashe\"];\nHat *beilei_hat = [[Hat alloc] initWithType:@\"Beilei\"];\nHat *black_hat = [[Hat alloc] initWithColor:@\"Black Yashe\"];\n\n[hat addDress:beilei_hat];\n\n[yashe_hat addDress:black_hat];\n[hat addDress:yashe_hat];\n```\n\n现在我们需要注意一下\n· 上面的三个对象，必须遵守一个协议，我们姑且命名为 DressProtocol (服饰）\n\n```\n@protocol DressProtocol\n\n- (void)addDress:(id<DressProtocol>)dress;\n- (void)removeDress:(id<DressProtocol>)dress;\n\n- (void)showDresses;\n@end\n\n```\n\n上面经过一轮 AddDress:之后，帽子那块应该就会生成这样子的结构\n\n```\n衣橱\n|_帽子\n  |_贝雷帽\n  |_鸭舌帽\n    |_黑色鸭舌帽\n```\n然后我们来看看里面代理方法的实现\n\n```\n- (void)addDress:(id<DressProtocol>)dress\n{\n\t// 有一个数组成员属性用来储存这些对象\n\t[_child addObject:dress];\n}\n- (void)removeDress:(id<DressProtocol>)dress\n{\n\t[_child removeObject:dress];\n}\n- (void)showDresses\n{\n\tNSLog(@\"%@\",_child);\n}\n```\n\n顺便看看 Init的时候我们使用的两个方法\n\n```\n- (instancetype)initWithType:(NSString *)type\n{\n\tif(self = [super init]){\n\t\tself.type = type;\n\t\tself.color = nil;\n\t}\n\treturn self;\n}\n\n- (instancetype)initWithColor:(NSString *)color\n{\n\tif(self = [super init]){\n\t\tself.type = nil;\n\t\tself.color = color;\n\t}\n\treturn self;\n}\n\n```\n\n大概就是这种感觉\n\n如果不是很清楚的话，可以想想 `UIView`的 `addSubView:`\n`addSubView:`就是把一个新的 View加入到子节点，如果 subView 还有 subView，那就在 subView 上面继续添加 `addSubView:` 最后我们打印 subViews的时候就可以得到该View的所有的subview\n\n","source":"_posts/组合模式.md","raw":"---\ntitle: 组合模式\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: df879792\ndate: 2016-11-01 00:00:00\n---\n其实组合模式就是为了便于管理一个树形结构（抽象的）的对象，能让客户端统一处理这个对象的一种设计模式\n\n<!-- more -->\n\n举个例子\n\n```\n帽子\n  |_贝雷帽\n  |_鸭舌帽\n      |_黑色鸭舌\n衣服\n  |_衬衫\n      |_蓝色衬衫\n      |_白色衬衫\n  |_T恤\n裤子\n  |_牛仔裤\n      |_蓝色牛仔裤\n  |_短裤\n\n```\n\n那么这时候如果客户端要拿到一顶黑色鸭舌帽，一件白色衬衫和一条蓝色牛仔裤，那么应该怎么取到呢？或者想从对象中删除这些东西呢？\n\n首先我们需要有一个衣柜\n\n```\nWardrobe *wardrobe = [[Wardrobe alloc] init];\n```\n\n然后为其我们添加子节点\n\n```\n[wardrobe addDress:hat];\n[wardrobe addDress:clothes];\n[wardrobe addDress:trousers];\n```\n\n那 `hat` 和 `clothes` 和 `trousers` 怎么来 (以 hat 举例)\n\n```\nHat *hat = [[Hat alloc] init];\nHat *yashe_hat = [[Hat alloc] initWithType:@\"Yashe\"];\nHat *beilei_hat = [[Hat alloc] initWithType:@\"Beilei\"];\nHat *black_hat = [[Hat alloc] initWithColor:@\"Black Yashe\"];\n\n[hat addDress:beilei_hat];\n\n[yashe_hat addDress:black_hat];\n[hat addDress:yashe_hat];\n```\n\n现在我们需要注意一下\n· 上面的三个对象，必须遵守一个协议，我们姑且命名为 DressProtocol (服饰）\n\n```\n@protocol DressProtocol\n\n- (void)addDress:(id<DressProtocol>)dress;\n- (void)removeDress:(id<DressProtocol>)dress;\n\n- (void)showDresses;\n@end\n\n```\n\n上面经过一轮 AddDress:之后，帽子那块应该就会生成这样子的结构\n\n```\n衣橱\n|_帽子\n  |_贝雷帽\n  |_鸭舌帽\n    |_黑色鸭舌帽\n```\n然后我们来看看里面代理方法的实现\n\n```\n- (void)addDress:(id<DressProtocol>)dress\n{\n\t// 有一个数组成员属性用来储存这些对象\n\t[_child addObject:dress];\n}\n- (void)removeDress:(id<DressProtocol>)dress\n{\n\t[_child removeObject:dress];\n}\n- (void)showDresses\n{\n\tNSLog(@\"%@\",_child);\n}\n```\n\n顺便看看 Init的时候我们使用的两个方法\n\n```\n- (instancetype)initWithType:(NSString *)type\n{\n\tif(self = [super init]){\n\t\tself.type = type;\n\t\tself.color = nil;\n\t}\n\treturn self;\n}\n\n- (instancetype)initWithColor:(NSString *)color\n{\n\tif(self = [super init]){\n\t\tself.type = nil;\n\t\tself.color = color;\n\t}\n\treturn self;\n}\n\n```\n\n大概就是这种感觉\n\n如果不是很清楚的话，可以想想 `UIView`的 `addSubView:`\n`addSubView:`就是把一个新的 View加入到子节点，如果 subView 还有 subView，那就在 subView 上面继续添加 `addSubView:` 最后我们打印 subViews的时候就可以得到该View的所有的subview\n\n","slug":"组合模式","published":1,"updated":"2021-06-06T18:52:24.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoiu0075tnn07j1ga5y5","content":"<p>其实组合模式就是为了便于管理一个树形结构（抽象的）的对象，能让客户端统一处理这个对象的一种设计模式</p>\n<span id=\"more\"></span>\n\n<p>举个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">帽子</span><br><span class=\"line\">  |_贝雷帽</span><br><span class=\"line\">  |_鸭舌帽</span><br><span class=\"line\">      |_黑色鸭舌</span><br><span class=\"line\">衣服</span><br><span class=\"line\">  |_衬衫</span><br><span class=\"line\">      |_蓝色衬衫</span><br><span class=\"line\">      |_白色衬衫</span><br><span class=\"line\">  |_T恤</span><br><span class=\"line\">裤子</span><br><span class=\"line\">  |_牛仔裤</span><br><span class=\"line\">      |_蓝色牛仔裤</span><br><span class=\"line\">  |_短裤</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>那么这时候如果客户端要拿到一顶黑色鸭舌帽，一件白色衬衫和一条蓝色牛仔裤，那么应该怎么取到呢？或者想从对象中删除这些东西呢？</p>\n<p>首先我们需要有一个衣柜</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Wardrobe *wardrobe &#x3D; [[Wardrobe alloc] init];</span><br></pre></td></tr></table></figure>\n\n<p>然后为其我们添加子节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[wardrobe addDress:hat];</span><br><span class=\"line\">[wardrobe addDress:clothes];</span><br><span class=\"line\">[wardrobe addDress:trousers];</span><br></pre></td></tr></table></figure>\n\n<p>那 <code>hat</code> 和 <code>clothes</code> 和 <code>trousers</code> 怎么来 (以 hat 举例)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hat *hat &#x3D; [[Hat alloc] init];</span><br><span class=\"line\">Hat *yashe_hat &#x3D; [[Hat alloc] initWithType:@&quot;Yashe&quot;];</span><br><span class=\"line\">Hat *beilei_hat &#x3D; [[Hat alloc] initWithType:@&quot;Beilei&quot;];</span><br><span class=\"line\">Hat *black_hat &#x3D; [[Hat alloc] initWithColor:@&quot;Black Yashe&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">[hat addDress:beilei_hat];</span><br><span class=\"line\"></span><br><span class=\"line\">[yashe_hat addDress:black_hat];</span><br><span class=\"line\">[hat addDress:yashe_hat];</span><br></pre></td></tr></table></figure>\n\n<p>现在我们需要注意一下<br>· 上面的三个对象，必须遵守一个协议，我们姑且命名为 DressProtocol (服饰）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@protocol DressProtocol</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)addDress:(id&lt;DressProtocol&gt;)dress;</span><br><span class=\"line\">- (void)removeDress:(id&lt;DressProtocol&gt;)dress;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)showDresses;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面经过一轮 AddDress:之后，帽子那块应该就会生成这样子的结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">衣橱</span><br><span class=\"line\">|_帽子</span><br><span class=\"line\">  |_贝雷帽</span><br><span class=\"line\">  |_鸭舌帽</span><br><span class=\"line\">    |_黑色鸭舌帽</span><br></pre></td></tr></table></figure>\n<p>然后我们来看看里面代理方法的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addDress:(id&lt;DressProtocol&gt;)dress</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 有一个数组成员属性用来储存这些对象</span><br><span class=\"line\">\t[_child addObject:dress];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)removeDress:(id&lt;DressProtocol&gt;)dress</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[_child removeObject:dress];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)showDresses</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNSLog(@&quot;%@&quot;,_child);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>顺便看看 Init的时候我们使用的两个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithType:(NSString *)type</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(self &#x3D; [super init])&#123;</span><br><span class=\"line\">\t\tself.type &#x3D; type;</span><br><span class=\"line\">\t\tself.color &#x3D; nil;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithColor:(NSString *)color</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(self &#x3D; [super init])&#123;</span><br><span class=\"line\">\t\tself.type &#x3D; nil;</span><br><span class=\"line\">\t\tself.color &#x3D; color;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>大概就是这种感觉</p>\n<p>如果不是很清楚的话，可以想想 <code>UIView</code>的 <code>addSubView:</code><br><code>addSubView:</code>就是把一个新的 View加入到子节点，如果 subView 还有 subView，那就在 subView 上面继续添加 <code>addSubView:</code> 最后我们打印 subViews的时候就可以得到该View的所有的subview</p>\n","site":{"data":{}},"excerpt":"<p>其实组合模式就是为了便于管理一个树形结构（抽象的）的对象，能让客户端统一处理这个对象的一种设计模式</p>","more":"<p>举个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">帽子</span><br><span class=\"line\">  |_贝雷帽</span><br><span class=\"line\">  |_鸭舌帽</span><br><span class=\"line\">      |_黑色鸭舌</span><br><span class=\"line\">衣服</span><br><span class=\"line\">  |_衬衫</span><br><span class=\"line\">      |_蓝色衬衫</span><br><span class=\"line\">      |_白色衬衫</span><br><span class=\"line\">  |_T恤</span><br><span class=\"line\">裤子</span><br><span class=\"line\">  |_牛仔裤</span><br><span class=\"line\">      |_蓝色牛仔裤</span><br><span class=\"line\">  |_短裤</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>那么这时候如果客户端要拿到一顶黑色鸭舌帽，一件白色衬衫和一条蓝色牛仔裤，那么应该怎么取到呢？或者想从对象中删除这些东西呢？</p>\n<p>首先我们需要有一个衣柜</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Wardrobe *wardrobe &#x3D; [[Wardrobe alloc] init];</span><br></pre></td></tr></table></figure>\n\n<p>然后为其我们添加子节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[wardrobe addDress:hat];</span><br><span class=\"line\">[wardrobe addDress:clothes];</span><br><span class=\"line\">[wardrobe addDress:trousers];</span><br></pre></td></tr></table></figure>\n\n<p>那 <code>hat</code> 和 <code>clothes</code> 和 <code>trousers</code> 怎么来 (以 hat 举例)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hat *hat &#x3D; [[Hat alloc] init];</span><br><span class=\"line\">Hat *yashe_hat &#x3D; [[Hat alloc] initWithType:@&quot;Yashe&quot;];</span><br><span class=\"line\">Hat *beilei_hat &#x3D; [[Hat alloc] initWithType:@&quot;Beilei&quot;];</span><br><span class=\"line\">Hat *black_hat &#x3D; [[Hat alloc] initWithColor:@&quot;Black Yashe&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">[hat addDress:beilei_hat];</span><br><span class=\"line\"></span><br><span class=\"line\">[yashe_hat addDress:black_hat];</span><br><span class=\"line\">[hat addDress:yashe_hat];</span><br></pre></td></tr></table></figure>\n\n<p>现在我们需要注意一下<br>· 上面的三个对象，必须遵守一个协议，我们姑且命名为 DressProtocol (服饰）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@protocol DressProtocol</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)addDress:(id&lt;DressProtocol&gt;)dress;</span><br><span class=\"line\">- (void)removeDress:(id&lt;DressProtocol&gt;)dress;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)showDresses;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面经过一轮 AddDress:之后，帽子那块应该就会生成这样子的结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">衣橱</span><br><span class=\"line\">|_帽子</span><br><span class=\"line\">  |_贝雷帽</span><br><span class=\"line\">  |_鸭舌帽</span><br><span class=\"line\">    |_黑色鸭舌帽</span><br></pre></td></tr></table></figure>\n<p>然后我们来看看里面代理方法的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addDress:(id&lt;DressProtocol&gt;)dress</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 有一个数组成员属性用来储存这些对象</span><br><span class=\"line\">\t[_child addObject:dress];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)removeDress:(id&lt;DressProtocol&gt;)dress</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[_child removeObject:dress];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)showDresses</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNSLog(@&quot;%@&quot;,_child);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>顺便看看 Init的时候我们使用的两个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithType:(NSString *)type</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(self &#x3D; [super init])&#123;</span><br><span class=\"line\">\t\tself.type &#x3D; type;</span><br><span class=\"line\">\t\tself.color &#x3D; nil;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithColor:(NSString *)color</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(self &#x3D; [super init])&#123;</span><br><span class=\"line\">\t\tself.type &#x3D; nil;</span><br><span class=\"line\">\t\tself.color &#x3D; color;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>大概就是这种感觉</p>\n<p>如果不是很清楚的话，可以想想 <code>UIView</code>的 <code>addSubView:</code><br><code>addSubView:</code>就是把一个新的 View加入到子节点，如果 subView 还有 subView，那就在 subView 上面继续添加 <code>addSubView:</code> 最后我们打印 subViews的时候就可以得到该View的所有的subview</p>"},{"title":"给 APP添加外部文件导入功能","author":"Arclin","abbrlink":"d2301e87","date":"2016-10-29T16:00:00.000Z","_content":"给 APP添加外部文件导入功能\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/333.jpeg)\n\n<!-- more -->\n\n修改 info.plist(这里是允许所有文件类型,如果要特定某种类型的文件,那么就得添加多个CFBundleTypeName CFBundleTypeRole LSHandlerRank LSItemContentTypes 具体见百度)\n\n```\n<key>CFBundleDocumentTypes</key>\n   <array>\n       <dict>\n           <key>CFBundleTypeIconFiles</key>\n           <array/>\n           <key>CFBundleTypeName</key>\n           <string>data</string>\n           <key>CFBundleTypeRole</key>\n           <string>Viewer</string>\n           <key>LSHandlerRank</key>\n           <string>Default</string>\n           <key>LSItemContentTypes</key>\n           <array>\n               <string>public.data</string>\n           </array>\n       </dict>\n   </array>\n ```\n \nAPPDelegate.h\n\n获取到根控制器,执行复制到Document文件夹方法\n源路径:url.path\n\n```\n@property (strong, nonatomic) NSURL *sharedURL;\n\n- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary<NSString *,id> *)options\n{\n\tif(url.fileURL){\n        self.sharedURL = url;\n        UIViewController *vc = self.window.rootViewController;\n        if ([vc isKindOfClass:[UINavigationController class]]) {\n            UINavigationController * nav = (UINavigationController *)self.window.rootViewController;\n            UIViewController *topVC = nav.childViewControllers.firstObject;\n            if ([topVC respondsToSelector:@selector(handleSharedFile)]) {\n                [topVC performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];\n            }\n        } else {\n            if ([vc respondsToSelector:@selector(handleSharedFile)]) {\n                [vc performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];\n            }\n        }\n    }\n}\n```\n\n根控制器方法(头文件需要声明方法)\n\n```\n- (void)handleSharedFile {\n    AppDelegate *app = (AppDelegate *)[UIApplication sharedApplication].delegate;\n    if (app.sharedURL != nil) {\n        self.sharedURL = [app.sharedURL copy];\n        app.sharedURL = nil;\n        [self saveSharedFile:self.sharedURL];\n    }\n}\n- (void)saveSharedFile:(NSURL *)url {\n    MBProgressHUD *hud = [MBProgressHUD showButtonHUDAddedTo:self.view animated:YES];\n    DKFile *file = [[DKFile alloc] init];\n    file.fullPath = url.path;\n    file.fileName = url.path.lastPathComponent;\n    [[DKFileManager sharedInstance] copyItemsOfSelectFiles:@[file] fromStorage:DKFileStorageTypeInternal toStorage:DKFileStorageTypeInternal toPath:[DKFileManager defaultPath:kShareDirectory storage:DKFileStorageTypeInternal] progressHUD:hud complete:^{\n        [SVProgressHUD showSuccessWithStatus:@\"已保存到 iPhone -> SharedFiles\"];\n    } failure:^(NSError *errors) {\n        \n    }];\n}\n```","source":"_posts/给-APP添加外部文件导入功能.md","raw":"---\ntitle: 给 APP添加外部文件导入功能\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: d2301e87\ndate: 2016-10-30 00:00:00\n---\n给 APP添加外部文件导入功能\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/333.jpeg)\n\n<!-- more -->\n\n修改 info.plist(这里是允许所有文件类型,如果要特定某种类型的文件,那么就得添加多个CFBundleTypeName CFBundleTypeRole LSHandlerRank LSItemContentTypes 具体见百度)\n\n```\n<key>CFBundleDocumentTypes</key>\n   <array>\n       <dict>\n           <key>CFBundleTypeIconFiles</key>\n           <array/>\n           <key>CFBundleTypeName</key>\n           <string>data</string>\n           <key>CFBundleTypeRole</key>\n           <string>Viewer</string>\n           <key>LSHandlerRank</key>\n           <string>Default</string>\n           <key>LSItemContentTypes</key>\n           <array>\n               <string>public.data</string>\n           </array>\n       </dict>\n   </array>\n ```\n \nAPPDelegate.h\n\n获取到根控制器,执行复制到Document文件夹方法\n源路径:url.path\n\n```\n@property (strong, nonatomic) NSURL *sharedURL;\n\n- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary<NSString *,id> *)options\n{\n\tif(url.fileURL){\n        self.sharedURL = url;\n        UIViewController *vc = self.window.rootViewController;\n        if ([vc isKindOfClass:[UINavigationController class]]) {\n            UINavigationController * nav = (UINavigationController *)self.window.rootViewController;\n            UIViewController *topVC = nav.childViewControllers.firstObject;\n            if ([topVC respondsToSelector:@selector(handleSharedFile)]) {\n                [topVC performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];\n            }\n        } else {\n            if ([vc respondsToSelector:@selector(handleSharedFile)]) {\n                [vc performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];\n            }\n        }\n    }\n}\n```\n\n根控制器方法(头文件需要声明方法)\n\n```\n- (void)handleSharedFile {\n    AppDelegate *app = (AppDelegate *)[UIApplication sharedApplication].delegate;\n    if (app.sharedURL != nil) {\n        self.sharedURL = [app.sharedURL copy];\n        app.sharedURL = nil;\n        [self saveSharedFile:self.sharedURL];\n    }\n}\n- (void)saveSharedFile:(NSURL *)url {\n    MBProgressHUD *hud = [MBProgressHUD showButtonHUDAddedTo:self.view animated:YES];\n    DKFile *file = [[DKFile alloc] init];\n    file.fullPath = url.path;\n    file.fileName = url.path.lastPathComponent;\n    [[DKFileManager sharedInstance] copyItemsOfSelectFiles:@[file] fromStorage:DKFileStorageTypeInternal toStorage:DKFileStorageTypeInternal toPath:[DKFileManager defaultPath:kShareDirectory storage:DKFileStorageTypeInternal] progressHUD:hud complete:^{\n        [SVProgressHUD showSuccessWithStatus:@\"已保存到 iPhone -> SharedFiles\"];\n    } failure:^(NSError *errors) {\n        \n    }];\n}\n```","slug":"给-APP添加外部文件导入功能","published":1,"updated":"2021-06-06T18:52:24.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoiv0078tnn0a33wc7dt","content":"<p>给 APP添加外部文件导入功能</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/333.jpeg\"></p>\n<span id=\"more\"></span>\n\n<p>修改 info.plist(这里是允许所有文件类型,如果要特定某种类型的文件,那么就得添加多个CFBundleTypeName CFBundleTypeRole LSHandlerRank LSItemContentTypes 具体见百度)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;CFBundleDocumentTypes&lt;&#x2F;key&gt;</span><br><span class=\"line\">   &lt;array&gt;</span><br><span class=\"line\">       &lt;dict&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeIconFiles&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;array&#x2F;&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeName&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;string&gt;data&lt;&#x2F;string&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeRole&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;string&gt;Viewer&lt;&#x2F;string&gt;</span><br><span class=\"line\">           &lt;key&gt;LSHandlerRank&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;string&gt;Default&lt;&#x2F;string&gt;</span><br><span class=\"line\">           &lt;key&gt;LSItemContentTypes&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;array&gt;</span><br><span class=\"line\">               &lt;string&gt;public.data&lt;&#x2F;string&gt;</span><br><span class=\"line\">           &lt;&#x2F;array&gt;</span><br><span class=\"line\">       &lt;&#x2F;dict&gt;</span><br><span class=\"line\">   &lt;&#x2F;array&gt;</span><br></pre></td></tr></table></figure>\n<p>APPDelegate.h</p>\n<p>获取到根控制器,执行复制到Document文件夹方法<br>源路径:url.path</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property (strong, nonatomic) NSURL *sharedURL;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(url.fileURL)&#123;</span><br><span class=\"line\">        self.sharedURL &#x3D; url;</span><br><span class=\"line\">        UIViewController *vc &#x3D; self.window.rootViewController;</span><br><span class=\"line\">        if ([vc isKindOfClass:[UINavigationController class]]) &#123;</span><br><span class=\"line\">            UINavigationController * nav &#x3D; (UINavigationController *)self.window.rootViewController;</span><br><span class=\"line\">            UIViewController *topVC &#x3D; nav.childViewControllers.firstObject;</span><br><span class=\"line\">            if ([topVC respondsToSelector:@selector(handleSharedFile)]) &#123;</span><br><span class=\"line\">                [topVC performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if ([vc respondsToSelector:@selector(handleSharedFile)]) &#123;</span><br><span class=\"line\">                [vc performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>根控制器方法(头文件需要声明方法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)handleSharedFile &#123;</span><br><span class=\"line\">    AppDelegate *app &#x3D; (AppDelegate *)[UIApplication sharedApplication].delegate;</span><br><span class=\"line\">    if (app.sharedURL !&#x3D; nil) &#123;</span><br><span class=\"line\">        self.sharedURL &#x3D; [app.sharedURL copy];</span><br><span class=\"line\">        app.sharedURL &#x3D; nil;</span><br><span class=\"line\">        [self saveSharedFile:self.sharedURL];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)saveSharedFile:(NSURL *)url &#123;</span><br><span class=\"line\">    MBProgressHUD *hud &#x3D; [MBProgressHUD showButtonHUDAddedTo:self.view animated:YES];</span><br><span class=\"line\">    DKFile *file &#x3D; [[DKFile alloc] init];</span><br><span class=\"line\">    file.fullPath &#x3D; url.path;</span><br><span class=\"line\">    file.fileName &#x3D; url.path.lastPathComponent;</span><br><span class=\"line\">    [[DKFileManager sharedInstance] copyItemsOfSelectFiles:@[file] fromStorage:DKFileStorageTypeInternal toStorage:DKFileStorageTypeInternal toPath:[DKFileManager defaultPath:kShareDirectory storage:DKFileStorageTypeInternal] progressHUD:hud complete:^&#123;</span><br><span class=\"line\">        [SVProgressHUD showSuccessWithStatus:@&quot;已保存到 iPhone -&gt; SharedFiles&quot;];</span><br><span class=\"line\">    &#125; failure:^(NSError *errors) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>给 APP添加外部文件导入功能</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/333.jpeg\"></p>","more":"<p>修改 info.plist(这里是允许所有文件类型,如果要特定某种类型的文件,那么就得添加多个CFBundleTypeName CFBundleTypeRole LSHandlerRank LSItemContentTypes 具体见百度)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;CFBundleDocumentTypes&lt;&#x2F;key&gt;</span><br><span class=\"line\">   &lt;array&gt;</span><br><span class=\"line\">       &lt;dict&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeIconFiles&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;array&#x2F;&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeName&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;string&gt;data&lt;&#x2F;string&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeRole&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;string&gt;Viewer&lt;&#x2F;string&gt;</span><br><span class=\"line\">           &lt;key&gt;LSHandlerRank&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;string&gt;Default&lt;&#x2F;string&gt;</span><br><span class=\"line\">           &lt;key&gt;LSItemContentTypes&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;array&gt;</span><br><span class=\"line\">               &lt;string&gt;public.data&lt;&#x2F;string&gt;</span><br><span class=\"line\">           &lt;&#x2F;array&gt;</span><br><span class=\"line\">       &lt;&#x2F;dict&gt;</span><br><span class=\"line\">   &lt;&#x2F;array&gt;</span><br></pre></td></tr></table></figure>\n<p>APPDelegate.h</p>\n<p>获取到根控制器,执行复制到Document文件夹方法<br>源路径:url.path</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property (strong, nonatomic) NSURL *sharedURL;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(url.fileURL)&#123;</span><br><span class=\"line\">        self.sharedURL &#x3D; url;</span><br><span class=\"line\">        UIViewController *vc &#x3D; self.window.rootViewController;</span><br><span class=\"line\">        if ([vc isKindOfClass:[UINavigationController class]]) &#123;</span><br><span class=\"line\">            UINavigationController * nav &#x3D; (UINavigationController *)self.window.rootViewController;</span><br><span class=\"line\">            UIViewController *topVC &#x3D; nav.childViewControllers.firstObject;</span><br><span class=\"line\">            if ([topVC respondsToSelector:@selector(handleSharedFile)]) &#123;</span><br><span class=\"line\">                [topVC performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if ([vc respondsToSelector:@selector(handleSharedFile)]) &#123;</span><br><span class=\"line\">                [vc performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>根控制器方法(头文件需要声明方法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)handleSharedFile &#123;</span><br><span class=\"line\">    AppDelegate *app &#x3D; (AppDelegate *)[UIApplication sharedApplication].delegate;</span><br><span class=\"line\">    if (app.sharedURL !&#x3D; nil) &#123;</span><br><span class=\"line\">        self.sharedURL &#x3D; [app.sharedURL copy];</span><br><span class=\"line\">        app.sharedURL &#x3D; nil;</span><br><span class=\"line\">        [self saveSharedFile:self.sharedURL];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)saveSharedFile:(NSURL *)url &#123;</span><br><span class=\"line\">    MBProgressHUD *hud &#x3D; [MBProgressHUD showButtonHUDAddedTo:self.view animated:YES];</span><br><span class=\"line\">    DKFile *file &#x3D; [[DKFile alloc] init];</span><br><span class=\"line\">    file.fullPath &#x3D; url.path;</span><br><span class=\"line\">    file.fileName &#x3D; url.path.lastPathComponent;</span><br><span class=\"line\">    [[DKFileManager sharedInstance] copyItemsOfSelectFiles:@[file] fromStorage:DKFileStorageTypeInternal toStorage:DKFileStorageTypeInternal toPath:[DKFileManager defaultPath:kShareDirectory storage:DKFileStorageTypeInternal] progressHUD:hud complete:^&#123;</span><br><span class=\"line\">        [SVProgressHUD showSuccessWithStatus:@&quot;已保存到 iPhone -&gt; SharedFiles&quot;];</span><br><span class=\"line\">    &#125; failure:^(NSError *errors) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"网络层方法封装","author":"Arclin","abbrlink":"3d9cee8d","date":"2016-10-28T16:00:00.000Z","_content":"网络层的方法封装\n<!-- more -->\n\n## 特点\n - 集成AFNetworking\n - 集成MJExtension\n - 统一回调\n - 方便顶层调用\n - 统一错误处理\n - 适应接口设计\n\n## 设计（以POST和退出登录接口举例）\n1. 接口设计\n  ```\n  typedef void (^DKResponseBlock)(DKResponse *response);\n\n  + (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters success:(nonnull DKResponseBlock)callBack;\n  1.1 DKResponse 回调模型设计（根据接口进行设计）\n\n\n   #import <Foundation/Foundation.h>\n\n  @interface DKResponse : NSObject\n\n  /** state */\n  @property (nonatomic,copy) NSString *state;\n\n  /** result */\n  @property (nonatomic,copy) NSDictionary *result;\n\n  /** message */\n  @property (nonatomic,copy) NSString *message;\n\n  /** 纯数据 */\n  @property (nonatomic, strong) id rawData;\n\n  /** error */\n  @property (nonatomic,copy) NSError *error;\n\n  @end\n  ```\n2. 底层方法实现\n  ```\n  (DKConfiguration.h 或者使用 plist)\n   static NSString *kDKTimeoutInterval = 10.0f;\n   static NSString *kDKSuccessMessage = @\"success\";\n\n  + (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters callBack:(nonnull DKResponseBlock)callBack {\n      AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n      mgr.requestSerializer.timeoutInterval = kDKTimeoutInterval;\n      [mgr POST:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n          DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject]; // 转为响应信息模型\n          resp.rawData = responseObject; // 储存源数据\n          if(callBack){\n              if (![resp.message isEqualToString:kDKSuccessMessage]) { // 判断是否是成功的\n                  resp.error = [NSError errorWithDomain:@\"dankal.cn\" code:[resp.state integerValue] userInfo:@{@\"message\":resp.message}]; // 生成错误对象\n                  callBack(resp);\n              }else{\n                  callBack(resp); // 没有错误直接返回\n              }\n          }\n\n      } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n          DKLog(@\"%@\",error);\n          DKResponse *response = [[DKResponse alloc] init]; // 随便看看\n          response.error = error;\n          if(callBack){\n              callBack(response);\n          }\n      }];\n  }\n  ```\n3. 业务层接口设计\n  ```\n  (DKLogin.h)\n  typedef void (^DKBlockSuccessOrError)(BOOL isSuccessful,NSError *error);\n  // 其他需求可以定制其他回调，如下\n  typedef void (^DKArrayResultBlock)(NSArray *result,NSError *error);\n  typedef void (^DKIntegerResultBlock)(NSInteger number, NSError *error) ;\n  typedef void (^DKUserResultBlock)(DKUser *user, NSError *error); // DKUser为模型\n\n  + (void)logout:(DKBlockSuccessOrError)callBack;\n  ```\n4. 业务层接口实现\n  ```\n  + (void)logout:(DKBlockSuccessOrError)callBack\n  {\n      NSString *url = @\"xxxx\";\n      NSDictionary *params = @{@\"xxx\":@\"xxx\"};\n      [DKHTTPTool POST:url parameters:params success:^(DKResponse *response) {\n          if (callBack) {\n            response.error ? callBack(NO,response.error) : callBack(YES,nil);\n          }\n       }];\n   }\n  ```\n5. ViewModel 或 ViewController 调用\n  ```\n  [DKLoginService logout:^(BOOL isSuccess,NSError *error){\n      if(isSuccess){\n\n      }else{\n\n      }\n  }];\n  ```","source":"_posts/网络层方法封装.md","raw":"---\ntitle: 网络层方法封装\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 3d9cee8d\ndate: 2016-10-29 00:00:00\n---\n网络层的方法封装\n<!-- more -->\n\n## 特点\n - 集成AFNetworking\n - 集成MJExtension\n - 统一回调\n - 方便顶层调用\n - 统一错误处理\n - 适应接口设计\n\n## 设计（以POST和退出登录接口举例）\n1. 接口设计\n  ```\n  typedef void (^DKResponseBlock)(DKResponse *response);\n\n  + (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters success:(nonnull DKResponseBlock)callBack;\n  1.1 DKResponse 回调模型设计（根据接口进行设计）\n\n\n   #import <Foundation/Foundation.h>\n\n  @interface DKResponse : NSObject\n\n  /** state */\n  @property (nonatomic,copy) NSString *state;\n\n  /** result */\n  @property (nonatomic,copy) NSDictionary *result;\n\n  /** message */\n  @property (nonatomic,copy) NSString *message;\n\n  /** 纯数据 */\n  @property (nonatomic, strong) id rawData;\n\n  /** error */\n  @property (nonatomic,copy) NSError *error;\n\n  @end\n  ```\n2. 底层方法实现\n  ```\n  (DKConfiguration.h 或者使用 plist)\n   static NSString *kDKTimeoutInterval = 10.0f;\n   static NSString *kDKSuccessMessage = @\"success\";\n\n  + (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters callBack:(nonnull DKResponseBlock)callBack {\n      AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n      mgr.requestSerializer.timeoutInterval = kDKTimeoutInterval;\n      [mgr POST:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n          DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject]; // 转为响应信息模型\n          resp.rawData = responseObject; // 储存源数据\n          if(callBack){\n              if (![resp.message isEqualToString:kDKSuccessMessage]) { // 判断是否是成功的\n                  resp.error = [NSError errorWithDomain:@\"dankal.cn\" code:[resp.state integerValue] userInfo:@{@\"message\":resp.message}]; // 生成错误对象\n                  callBack(resp);\n              }else{\n                  callBack(resp); // 没有错误直接返回\n              }\n          }\n\n      } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n          DKLog(@\"%@\",error);\n          DKResponse *response = [[DKResponse alloc] init]; // 随便看看\n          response.error = error;\n          if(callBack){\n              callBack(response);\n          }\n      }];\n  }\n  ```\n3. 业务层接口设计\n  ```\n  (DKLogin.h)\n  typedef void (^DKBlockSuccessOrError)(BOOL isSuccessful,NSError *error);\n  // 其他需求可以定制其他回调，如下\n  typedef void (^DKArrayResultBlock)(NSArray *result,NSError *error);\n  typedef void (^DKIntegerResultBlock)(NSInteger number, NSError *error) ;\n  typedef void (^DKUserResultBlock)(DKUser *user, NSError *error); // DKUser为模型\n\n  + (void)logout:(DKBlockSuccessOrError)callBack;\n  ```\n4. 业务层接口实现\n  ```\n  + (void)logout:(DKBlockSuccessOrError)callBack\n  {\n      NSString *url = @\"xxxx\";\n      NSDictionary *params = @{@\"xxx\":@\"xxx\"};\n      [DKHTTPTool POST:url parameters:params success:^(DKResponse *response) {\n          if (callBack) {\n            response.error ? callBack(NO,response.error) : callBack(YES,nil);\n          }\n       }];\n   }\n  ```\n5. ViewModel 或 ViewController 调用\n  ```\n  [DKLoginService logout:^(BOOL isSuccess,NSError *error){\n      if(isSuccess){\n\n      }else{\n\n      }\n  }];\n  ```","slug":"网络层方法封装","published":1,"updated":"2021-06-06T18:52:24.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoiw007btnn088p33ub3","content":"<p>网络层的方法封装</p>\n<span id=\"more\"></span>\n\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>集成AFNetworking</li>\n<li>集成MJExtension</li>\n<li>统一回调</li>\n<li>方便顶层调用</li>\n<li>统一错误处理</li>\n<li>适应接口设计</li>\n</ul>\n<h2 id=\"设计（以POST和退出登录接口举例）\"><a href=\"#设计（以POST和退出登录接口举例）\" class=\"headerlink\" title=\"设计（以POST和退出登录接口举例）\"></a>设计（以POST和退出登录接口举例）</h2><ol>\n<li>接口设计<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef void (^DKResponseBlock)(DKResponse *response);</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters success:(nonnull DKResponseBlock)callBack;</span><br><span class=\"line\">1.1 DKResponse 回调模型设计（根据接口进行设计）</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> #import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface DKResponse : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** state *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSString *state;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** result *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSDictionary *result;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** message *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSString *message;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 纯数据 *&#x2F;</span><br><span class=\"line\">@property (nonatomic, strong) id rawData;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** error *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSError *error;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></li>\n<li>底层方法实现<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(DKConfiguration.h 或者使用 plist)</span><br><span class=\"line\"> static NSString *kDKTimeoutInterval &#x3D; 10.0f;</span><br><span class=\"line\"> static NSString *kDKSuccessMessage &#x3D; @&quot;success&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters callBack:(nonnull DKResponseBlock)callBack &#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];</span><br><span class=\"line\">    mgr.requestSerializer.timeoutInterval &#x3D; kDKTimeoutInterval;</span><br><span class=\"line\">    [mgr POST:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject]; &#x2F;&#x2F; 转为响应信息模型</span><br><span class=\"line\">        resp.rawData &#x3D; responseObject; &#x2F;&#x2F; 储存源数据</span><br><span class=\"line\">        if(callBack)&#123;</span><br><span class=\"line\">            if (![resp.message isEqualToString:kDKSuccessMessage]) &#123; &#x2F;&#x2F; 判断是否是成功的</span><br><span class=\"line\">                resp.error &#x3D; [NSError errorWithDomain:@&quot;dankal.cn&quot; code:[resp.state integerValue] userInfo:@&#123;@&quot;message&quot;:resp.message&#125;]; &#x2F;&#x2F; 生成错误对象</span><br><span class=\"line\">                callBack(resp);</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                callBack(resp); &#x2F;&#x2F; 没有错误直接返回</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">        DKResponse *response &#x3D; [[DKResponse alloc] init]; &#x2F;&#x2F; 随便看看</span><br><span class=\"line\">        response.error &#x3D; error;</span><br><span class=\"line\">        if(callBack)&#123;</span><br><span class=\"line\">            callBack(response);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>业务层接口设计<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(DKLogin.h)</span><br><span class=\"line\">typedef void (^DKBlockSuccessOrError)(BOOL isSuccessful,NSError *error);</span><br><span class=\"line\">&#x2F;&#x2F; 其他需求可以定制其他回调，如下</span><br><span class=\"line\">typedef void (^DKArrayResultBlock)(NSArray *result,NSError *error);</span><br><span class=\"line\">typedef void (^DKIntegerResultBlock)(NSInteger number, NSError *error) ;</span><br><span class=\"line\">typedef void (^DKUserResultBlock)(DKUser *user, NSError *error); &#x2F;&#x2F; DKUser为模型</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)logout:(DKBlockSuccessOrError)callBack;</span><br></pre></td></tr></table></figure></li>\n<li>业务层接口实现<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)logout:(DKBlockSuccessOrError)callBack</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSString *url &#x3D; @&quot;xxxx&quot;;</span><br><span class=\"line\">    NSDictionary *params &#x3D; @&#123;@&quot;xxx&quot;:@&quot;xxx&quot;&#125;;</span><br><span class=\"line\">    [DKHTTPTool POST:url parameters:params success:^(DKResponse *response) &#123;</span><br><span class=\"line\">        if (callBack) &#123;</span><br><span class=\"line\">          response.error ? callBack(NO,response.error) : callBack(YES,nil);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;];</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></li>\n<li>ViewModel 或 ViewController 调用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKLoginService logout:^(BOOL isSuccess,NSError *error)&#123;</span><br><span class=\"line\">    if(isSuccess)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>网络层的方法封装</p>","more":"<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>集成AFNetworking</li>\n<li>集成MJExtension</li>\n<li>统一回调</li>\n<li>方便顶层调用</li>\n<li>统一错误处理</li>\n<li>适应接口设计</li>\n</ul>\n<h2 id=\"设计（以POST和退出登录接口举例）\"><a href=\"#设计（以POST和退出登录接口举例）\" class=\"headerlink\" title=\"设计（以POST和退出登录接口举例）\"></a>设计（以POST和退出登录接口举例）</h2><ol>\n<li>接口设计<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef void (^DKResponseBlock)(DKResponse *response);</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters success:(nonnull DKResponseBlock)callBack;</span><br><span class=\"line\">1.1 DKResponse 回调模型设计（根据接口进行设计）</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> #import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface DKResponse : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** state *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSString *state;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** result *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSDictionary *result;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** message *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSString *message;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 纯数据 *&#x2F;</span><br><span class=\"line\">@property (nonatomic, strong) id rawData;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** error *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSError *error;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></li>\n<li>底层方法实现<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(DKConfiguration.h 或者使用 plist)</span><br><span class=\"line\"> static NSString *kDKTimeoutInterval &#x3D; 10.0f;</span><br><span class=\"line\"> static NSString *kDKSuccessMessage &#x3D; @&quot;success&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters callBack:(nonnull DKResponseBlock)callBack &#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];</span><br><span class=\"line\">    mgr.requestSerializer.timeoutInterval &#x3D; kDKTimeoutInterval;</span><br><span class=\"line\">    [mgr POST:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject]; &#x2F;&#x2F; 转为响应信息模型</span><br><span class=\"line\">        resp.rawData &#x3D; responseObject; &#x2F;&#x2F; 储存源数据</span><br><span class=\"line\">        if(callBack)&#123;</span><br><span class=\"line\">            if (![resp.message isEqualToString:kDKSuccessMessage]) &#123; &#x2F;&#x2F; 判断是否是成功的</span><br><span class=\"line\">                resp.error &#x3D; [NSError errorWithDomain:@&quot;dankal.cn&quot; code:[resp.state integerValue] userInfo:@&#123;@&quot;message&quot;:resp.message&#125;]; &#x2F;&#x2F; 生成错误对象</span><br><span class=\"line\">                callBack(resp);</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                callBack(resp); &#x2F;&#x2F; 没有错误直接返回</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">        DKResponse *response &#x3D; [[DKResponse alloc] init]; &#x2F;&#x2F; 随便看看</span><br><span class=\"line\">        response.error &#x3D; error;</span><br><span class=\"line\">        if(callBack)&#123;</span><br><span class=\"line\">            callBack(response);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>业务层接口设计<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(DKLogin.h)</span><br><span class=\"line\">typedef void (^DKBlockSuccessOrError)(BOOL isSuccessful,NSError *error);</span><br><span class=\"line\">&#x2F;&#x2F; 其他需求可以定制其他回调，如下</span><br><span class=\"line\">typedef void (^DKArrayResultBlock)(NSArray *result,NSError *error);</span><br><span class=\"line\">typedef void (^DKIntegerResultBlock)(NSInteger number, NSError *error) ;</span><br><span class=\"line\">typedef void (^DKUserResultBlock)(DKUser *user, NSError *error); &#x2F;&#x2F; DKUser为模型</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)logout:(DKBlockSuccessOrError)callBack;</span><br></pre></td></tr></table></figure></li>\n<li>业务层接口实现<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)logout:(DKBlockSuccessOrError)callBack</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSString *url &#x3D; @&quot;xxxx&quot;;</span><br><span class=\"line\">    NSDictionary *params &#x3D; @&#123;@&quot;xxx&quot;:@&quot;xxx&quot;&#125;;</span><br><span class=\"line\">    [DKHTTPTool POST:url parameters:params success:^(DKResponse *response) &#123;</span><br><span class=\"line\">        if (callBack) &#123;</span><br><span class=\"line\">          response.error ? callBack(NO,response.error) : callBack(YES,nil);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;];</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></li>\n<li>ViewModel 或 ViewController 调用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKLoginService logout:^(BOOL isSuccess,NSError *error)&#123;</span><br><span class=\"line\">    if(isSuccess)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></li>\n</ol>"},{"title":"网络层方法封装2","author":"Arclin","abbrlink":"89e1dd7e","date":"2016-11-02T16:00:00.000Z","_content":"网络层方法封装2\n\n<!-- more -->\n - 为了便于进行请求的管理，特地对之前的网络层方法封装加以改进，为了就是避免请求发送出去之后就管理不了的问题。\n - 其中最为重要的就是请求的取消\n \n> 当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。-Casa\n\n - 另外还添加了请求头，有需求的话就调用有添加请求头的方法\n\n - 接下来说说改造\n\n   1. 添加单例方法，使用 sharedTool 管理请求\n   2. 改原先的类方法为实例方法，并添加 NSInteger的返回值\n   3. 添加取消请求和取消全部请求的方法\n   4. DKResponse 添加 taskIdentifier（NSInteger）属性\n\n- 声明部分\n\n```\n/** 请求头 */\n@property (nonatomic,strong)  NSDictionary *header;\n\n+ (instancetype)sharedTool;\n\n- (NSInteger)GET:(NSString *)URLString parameters:(id)parameters\nresponseBlock:(DKHTTPResponseBlock)block;\n\n- (NSInteger)POST:(NSString *)URLString parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block;\n```\n\n- 方法实现\n\n```\nstatic DKHTTPTool *_tool;\n\n+ (id)allocWithZone:(struct _NSZone *)zone\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        _tool = [super allocWithZone:zone];\n    });\n    return _tool;\n}\n\n+ (instancetype)sharedTool\n{\n    if (_tool == nil) {\n        _tool = [[DKHTTPTool alloc] init];\n    }\n    return _tool;\n}\n```\n\n- GET请求添加请求头\n\n```\n- (NSInteger)GET:(NSString *)URLString header:(NSDictionary *)header parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block\n{\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n    AFHTTPRequestSerializer *requestSerializer = mgr.requestSerializer;\n    [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        [requestSerializer setValue:obj forHTTPHeaderField:key];\n    }];\n    requestSerializer.timeoutInterval = kTimeOutInterval;\n    NSURLSessionTask *task = [mgr GET:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\n        resp.rawData = responseObject;\n        resp.taskIdentifier = task.taskIdentifier;\n        if(block){\n            block(resp);\n        }\n        \n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        DKResponse *resp = [[DKResponse alloc] init];\n        resp.error = error;\n        if (block) {\n            block(resp);\n        }\n    }];\n    NSNumber *requestId = @(task.taskIdentifier);\n    [self.dispatchTable setObject:task forKey:requestId];\n    return task.taskIdentifier;\n}\n```\n\n- 取消请求\n\n```\n- (void)cancelRequestWithRequestIds:(NSArray *)requestIds\n{\n    for (NSInteger i = 0; i < requestIds.count ; i++) {\n        NSInteger requestId = [requestIds[i] integerValue];\n        NSURLSessionTask *task = [self.dispatchTable objectForKey:@(requestId)];\n        [task cancel];\n        [self.dispatchTable removeObjectForKey:@(requestId)];\n    }\n}\n\n- (void)cancelAllRequest\n{\n    [self.dispatchTable enumerateKeysAndObjectsUsingBlock:^(NSNumber * _Nonnull key, NSURLSessionTask * _Nonnull obj, BOOL * _Nonnull stop) {\n        [obj cancel];\n    }];\n}\n```\n\n- 其他方法\n\n```\n#pragma mark - seter & getter\n- (NSMutableDictionary<NSNumber *,NSURLSessionTask *> *)dispatchTable\n{\n    if (!_dispatchTable) {\n        _dispatchTable = [NSMutableDictionary dictionary];\n    }\n    return _dispatchTable;\n}\n```","source":"_posts/网络层方法封装2.md","raw":"---\ntitle: 网络层方法封装2\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 89e1dd7e\ndate: 2016-11-03 00:00:00\n---\n网络层方法封装2\n\n<!-- more -->\n - 为了便于进行请求的管理，特地对之前的网络层方法封装加以改进，为了就是避免请求发送出去之后就管理不了的问题。\n - 其中最为重要的就是请求的取消\n \n> 当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。-Casa\n\n - 另外还添加了请求头，有需求的话就调用有添加请求头的方法\n\n - 接下来说说改造\n\n   1. 添加单例方法，使用 sharedTool 管理请求\n   2. 改原先的类方法为实例方法，并添加 NSInteger的返回值\n   3. 添加取消请求和取消全部请求的方法\n   4. DKResponse 添加 taskIdentifier（NSInteger）属性\n\n- 声明部分\n\n```\n/** 请求头 */\n@property (nonatomic,strong)  NSDictionary *header;\n\n+ (instancetype)sharedTool;\n\n- (NSInteger)GET:(NSString *)URLString parameters:(id)parameters\nresponseBlock:(DKHTTPResponseBlock)block;\n\n- (NSInteger)POST:(NSString *)URLString parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block;\n```\n\n- 方法实现\n\n```\nstatic DKHTTPTool *_tool;\n\n+ (id)allocWithZone:(struct _NSZone *)zone\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        _tool = [super allocWithZone:zone];\n    });\n    return _tool;\n}\n\n+ (instancetype)sharedTool\n{\n    if (_tool == nil) {\n        _tool = [[DKHTTPTool alloc] init];\n    }\n    return _tool;\n}\n```\n\n- GET请求添加请求头\n\n```\n- (NSInteger)GET:(NSString *)URLString header:(NSDictionary *)header parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block\n{\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n    AFHTTPRequestSerializer *requestSerializer = mgr.requestSerializer;\n    [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        [requestSerializer setValue:obj forHTTPHeaderField:key];\n    }];\n    requestSerializer.timeoutInterval = kTimeOutInterval;\n    NSURLSessionTask *task = [mgr GET:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\n        resp.rawData = responseObject;\n        resp.taskIdentifier = task.taskIdentifier;\n        if(block){\n            block(resp);\n        }\n        \n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        DKResponse *resp = [[DKResponse alloc] init];\n        resp.error = error;\n        if (block) {\n            block(resp);\n        }\n    }];\n    NSNumber *requestId = @(task.taskIdentifier);\n    [self.dispatchTable setObject:task forKey:requestId];\n    return task.taskIdentifier;\n}\n```\n\n- 取消请求\n\n```\n- (void)cancelRequestWithRequestIds:(NSArray *)requestIds\n{\n    for (NSInteger i = 0; i < requestIds.count ; i++) {\n        NSInteger requestId = [requestIds[i] integerValue];\n        NSURLSessionTask *task = [self.dispatchTable objectForKey:@(requestId)];\n        [task cancel];\n        [self.dispatchTable removeObjectForKey:@(requestId)];\n    }\n}\n\n- (void)cancelAllRequest\n{\n    [self.dispatchTable enumerateKeysAndObjectsUsingBlock:^(NSNumber * _Nonnull key, NSURLSessionTask * _Nonnull obj, BOOL * _Nonnull stop) {\n        [obj cancel];\n    }];\n}\n```\n\n- 其他方法\n\n```\n#pragma mark - seter & getter\n- (NSMutableDictionary<NSNumber *,NSURLSessionTask *> *)dispatchTable\n{\n    if (!_dispatchTable) {\n        _dispatchTable = [NSMutableDictionary dictionary];\n    }\n    return _dispatchTable;\n}\n```","slug":"网络层方法封装2","published":1,"updated":"2021-06-06T18:52:24.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoix007ftnn068fh91te","content":"<p>网络层方法封装2</p>\n<span id=\"more\"></span>\n<ul>\n<li>为了便于进行请求的管理，特地对之前的网络层方法封装加以改进，为了就是避免请求发送出去之后就管理不了的问题。</li>\n<li>其中最为重要的就是请求的取消</li>\n</ul>\n<blockquote>\n<p>当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。-Casa</p>\n</blockquote>\n<ul>\n<li><p>另外还添加了请求头，有需求的话就调用有添加请求头的方法</p>\n</li>\n<li><p>接下来说说改造</p>\n<ol>\n<li>添加单例方法，使用 sharedTool 管理请求</li>\n<li>改原先的类方法为实例方法，并添加 NSInteger的返回值</li>\n<li>添加取消请求和取消全部请求的方法</li>\n<li>DKResponse 添加 taskIdentifier（NSInteger）属性</li>\n</ol>\n</li>\n<li><p>声明部分</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 请求头 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,strong)  NSDictionary *header;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)sharedTool;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSInteger)GET:(NSString *)URLString parameters:(id)parameters</span><br><span class=\"line\">responseBlock:(DKHTTPResponseBlock)block;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSInteger)POST:(NSString *)URLString parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方法实现</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static DKHTTPTool *_tool;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (id)allocWithZone:(struct _NSZone *)zone</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        _tool &#x3D; [super allocWithZone:zone];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return _tool;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)sharedTool</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (_tool &#x3D;&#x3D; nil) &#123;</span><br><span class=\"line\">        _tool &#x3D; [[DKHTTPTool alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _tool;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>GET请求添加请求头</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)GET:(NSString *)URLString header:(NSDictionary *)header parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer &#x3D; mgr.requestSerializer;</span><br><span class=\"line\">    [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [requestSerializer setValue:obj forHTTPHeaderField:key];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    requestSerializer.timeoutInterval &#x3D; kTimeOutInterval;</span><br><span class=\"line\">    NSURLSessionTask *task &#x3D; [mgr GET:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject];</span><br><span class=\"line\">        resp.rawData &#x3D; responseObject;</span><br><span class=\"line\">        resp.taskIdentifier &#x3D; task.taskIdentifier;</span><br><span class=\"line\">        if(block)&#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [[DKResponse alloc] init];</span><br><span class=\"line\">        resp.error &#x3D; error;</span><br><span class=\"line\">        if (block) &#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    NSNumber *requestId &#x3D; @(task.taskIdentifier);</span><br><span class=\"line\">    [self.dispatchTable setObject:task forKey:requestId];</span><br><span class=\"line\">    return task.taskIdentifier;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>取消请求</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)cancelRequestWithRequestIds:(NSArray *)requestIds</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (NSInteger i &#x3D; 0; i &lt; requestIds.count ; i++) &#123;</span><br><span class=\"line\">        NSInteger requestId &#x3D; [requestIds[i] integerValue];</span><br><span class=\"line\">        NSURLSessionTask *task &#x3D; [self.dispatchTable objectForKey:@(requestId)];</span><br><span class=\"line\">        [task cancel];</span><br><span class=\"line\">        [self.dispatchTable removeObjectForKey:@(requestId)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)cancelAllRequest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.dispatchTable enumerateKeysAndObjectsUsingBlock:^(NSNumber * _Nonnull key, NSURLSessionTask * _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [obj cancel];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其他方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - seter &amp; getter</span><br><span class=\"line\">- (NSMutableDictionary&lt;NSNumber *,NSURLSessionTask *&gt; *)dispatchTable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!_dispatchTable) &#123;</span><br><span class=\"line\">        _dispatchTable &#x3D; [NSMutableDictionary dictionary];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _dispatchTable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>网络层方法封装2</p>","more":"<ul>\n<li>为了便于进行请求的管理，特地对之前的网络层方法封装加以改进，为了就是避免请求发送出去之后就管理不了的问题。</li>\n<li>其中最为重要的就是请求的取消</li>\n</ul>\n<blockquote>\n<p>当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。-Casa</p>\n</blockquote>\n<ul>\n<li><p>另外还添加了请求头，有需求的话就调用有添加请求头的方法</p>\n</li>\n<li><p>接下来说说改造</p>\n<ol>\n<li>添加单例方法，使用 sharedTool 管理请求</li>\n<li>改原先的类方法为实例方法，并添加 NSInteger的返回值</li>\n<li>添加取消请求和取消全部请求的方法</li>\n<li>DKResponse 添加 taskIdentifier（NSInteger）属性</li>\n</ol>\n</li>\n<li><p>声明部分</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 请求头 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,strong)  NSDictionary *header;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)sharedTool;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSInteger)GET:(NSString *)URLString parameters:(id)parameters</span><br><span class=\"line\">responseBlock:(DKHTTPResponseBlock)block;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSInteger)POST:(NSString *)URLString parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方法实现</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static DKHTTPTool *_tool;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (id)allocWithZone:(struct _NSZone *)zone</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        _tool &#x3D; [super allocWithZone:zone];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return _tool;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)sharedTool</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (_tool &#x3D;&#x3D; nil) &#123;</span><br><span class=\"line\">        _tool &#x3D; [[DKHTTPTool alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _tool;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>GET请求添加请求头</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)GET:(NSString *)URLString header:(NSDictionary *)header parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer &#x3D; mgr.requestSerializer;</span><br><span class=\"line\">    [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [requestSerializer setValue:obj forHTTPHeaderField:key];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    requestSerializer.timeoutInterval &#x3D; kTimeOutInterval;</span><br><span class=\"line\">    NSURLSessionTask *task &#x3D; [mgr GET:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject];</span><br><span class=\"line\">        resp.rawData &#x3D; responseObject;</span><br><span class=\"line\">        resp.taskIdentifier &#x3D; task.taskIdentifier;</span><br><span class=\"line\">        if(block)&#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [[DKResponse alloc] init];</span><br><span class=\"line\">        resp.error &#x3D; error;</span><br><span class=\"line\">        if (block) &#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    NSNumber *requestId &#x3D; @(task.taskIdentifier);</span><br><span class=\"line\">    [self.dispatchTable setObject:task forKey:requestId];</span><br><span class=\"line\">    return task.taskIdentifier;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>取消请求</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)cancelRequestWithRequestIds:(NSArray *)requestIds</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (NSInteger i &#x3D; 0; i &lt; requestIds.count ; i++) &#123;</span><br><span class=\"line\">        NSInteger requestId &#x3D; [requestIds[i] integerValue];</span><br><span class=\"line\">        NSURLSessionTask *task &#x3D; [self.dispatchTable objectForKey:@(requestId)];</span><br><span class=\"line\">        [task cancel];</span><br><span class=\"line\">        [self.dispatchTable removeObjectForKey:@(requestId)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)cancelAllRequest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.dispatchTable enumerateKeysAndObjectsUsingBlock:^(NSNumber * _Nonnull key, NSURLSessionTask * _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [obj cancel];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其他方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - seter &amp; getter</span><br><span class=\"line\">- (NSMutableDictionary&lt;NSNumber *,NSURLSessionTask *&gt; *)dispatchTable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!_dispatchTable) &#123;</span><br><span class=\"line\">        _dispatchTable &#x3D; [NSMutableDictionary dictionary];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _dispatchTable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"网络层方法封装3","author":"Arclin","abbrlink":"fee6ede8","date":"2016-11-20T16:00:00.000Z","_content":"网络层方法封装3.1\n\n<!-- more -->\n\n** 其实很久之前就想写写这个东西,不过因为项目的原因一直没时间去整理出来,所以决定还是分开几天去写完这个东西吧\n\n- 新增特性:\n\t- 3.0\n\t\t- 多缓存策略\n\t\t- 用宏定义减少代码量\n\t\t- 使用 plist统一错误信息设置\n\t- 3.1\n\t\t- 输出一个漂亮的Log\n\n- 先讲讲本地持久化策略的选择\n\n\t- 数据量小,单一的时候(比如一个模型数组,数组不大而且模型的成员属性不是很多),可以使用 `NSKeyArchive` 归档\n\n\t- `NSUserDefault` 用于储存用户首选项\n\n\t- `KeyChain`储存一些密码之类的东西\n\n\t- 数据库储存数据量比较大,字段比较多的模型数组\n\n- 缓存策略\n\n```\ntypedef NS_ENUM(NSInteger,DKCacheStrategy){\n    DKCacheStrategy_CACHE_ONLY, // 只从本地取数据\n    DKCacheStrategy_NETWORK_ONLY, // 只从网络取数据(不缓存)\n    DKCacheStrategy_NETWORK_AND_CACHE, // 从网络取数据后缓存(缓存结束不回调)\n    DKCacheStrategy_CACHE_ELSE_NETWORK, // 先取缓存,如果没有数据的话,才从网络取数据\n    DKCacheStrategy_CACHE_THEN_NETWORK // 先取缓存,再加载网络数据,网络数据加载完会更新缓存,这个选择会有两次回调\n    DKCacheStrategy_AUTOMATIC // 根据当前网络环境自动选择,如果有网络(WIFI/WLAN)就取网络数据,没网络就取缓存数据\n};\n```\n\n- Demo 说明\n   - github地址:没有\n   - 下载地址: NetworkDemo\n   - 选择本地持久化方式: `YYCache`,如果有更适合的缓存机制,那改一改也挺简单\n \n- 方法接口设计\n\n```\n/**\n *  发送HTTP请求\n *\n *  @param method 请求方法,你可以写@\"get\"或者@\"post\"(不区分大小写)或者已经定义好的 kGET 或 kPOST\n *  @param strategy  缓存策略\n *  @param header 请求头,可为空\n *  @param params 请求参数,可为空\n *  @param block  返回回调,这个就不要空啦\n *\n *  @return 请求标示 id 可以用来取消请求\n */\n- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block;\n```\n\n之前两个方法继续保留,在这里就不说明了\n\n```\n- (void)cancelAllRequest;\n- (void)cancelRequestWithRequestIds:(NSArray *)requestIds;\n```\n\n然后写两个内部方法,分别是取缓存和取网络数据\n\n```\n#pragma mark - 仅本地\n- (NSInteger)requestWithCacheOnlyStrategyWithUrl:(NSString *)URLString params:(NSDictionary *)params requestBlock:(DKHTTPResponseBlock)block\n{\n    DKResponse *response = (DKResponse *)[self.cache objectForKey:[self cacheKeyForRequestUrl:URLString params:params]];\n    if (block) {\n        if (response) {\n            block(response);\n        }else{\n            block(KERROR_RESPONSE(-1));\n        }\n    }\n    return 0;\n}\n\n#pragma mark - 仅网络\n- (NSInteger)requestWithNetworkOnlyStrategyForMethod:(NSString *)method url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block\n{\n    NSNumber *taskIdentifier = 0;\n    if ([method.uppercaseString isEqualToString:@\"GET\"]) {\n        DKCALLAPI(GET, taskIdentifier);\n    }else if([method.uppercaseString isEqualToString:@\"POST\"]){\n        DKCALLAPI(POST, taskIdentifier);\n    }else{\n        return 0;\n    }\n    return taskIdentifier.integerValue;\n}\n```\n\n这里的宏DKCALLAPI 定义 主要是为了不想写 POST和 GET两个方法,在这里写一次就够了\n\n```\n#define DKCALLAPI(REQUEST_METHOD,REQUEST_ID) \\\n{\\\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\\\n    AFHTTPRequestSerializer *requestSerializer = mgr.requestSerializer;\\\n    if (header) {\\\n        [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id obj, BOOL * _Nonnull stop) {\\\n            [requestSerializer setValue:obj forHTTPHeaderField:key];\\\n        }];\\\n    }\\\n    requestSerializer.timeoutInterval = kTimeOutInterval;\\\n    NSURLSessionTask *task = [mgr REQUEST_METHOD:URLString parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\\\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\\\n        resp.rawData = responseObject;\\\n        resp.taskIdentifier = task.taskIdentifier;\\\n        if(block){\\\n            block(resp);\\\n        }\\\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\\\n        DKResponse *resp = [DKResponse responseWithErrorOnly:error.description code:error.code];\\\n        if (block) {\\\n            block(resp);\\\n        }\\\n    }];\\\n    REQUEST_ID = @(task.taskIdentifier);\\\n    [self.dispatchTable setObject:task forKey:REQUEST_ID];\\\n}\n```\n\n然后 就可以实现我们的接口了 switch 里面的东西就就根据注释写吧\n\n```\n- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block\n{\n    __weak typeof(self) weakSelf = self;\n    NSInteger requestId;\n    switch (strategy) {\n        case DKCacheStrategy_CACHE_ONLY:\n        // 调用获取缓存方法\n            break;\n        case DKCacheStrategy_NETWORK_ONLY:\n        // 调用获取网络方法\n            break;\n        case DKCacheStrategy_NETWORK_AND_CACHE:\n        // 调用网络方法,回调后写入本地缓存\n            break;\n        case DKCacheStrategy_CACHE_ELSE_NETWORK:\n        // 调用本地缓存方法,在回调中判断是否有缓存,如果没有的话调用网络方法\n            break;\n        case DKCacheStrategy_CACHE_THEN_NETWORK:\n        // 调用本地方法接着调用网络方法 \n            break;\n        case DKCacheStrategy_AUTOMATICALLY:\n         // 调用网络方法,回调中如果返回错误则调用本地缓存方法\n            break;\n        default:\n            break;\n    }\n    return requestId;\n}\n```\n\n统一错误表处理\n-建立一个plist 文件\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>-2</key>\n\t<string>网络连接失败</string>\n\t<key>-1</key>\n\t<string>没有缓存</string>\n</dict>\n</plist>\n```\n\n一个成员属性加一个方法去调用\n\n```\n- (NSDictionary *)errorDic\n{\n    if (!_errorDic) {\n        NSString *path = [[NSBundle mainBundle] pathForResource:@\"DKError\" ofType:@\"plist\"];\n        _errorDic = [NSDictionary dictionaryWithContentsOfFile:path];\n    }\n    return _errorDic;\n}\n\n- (NSString *)errorDescriptionWithCode:(NSInteger)code\n{\n    NSString *codeStr = [NSString stringWithFormat:@\"%zd\",code];\n    if ([self.errorDic.allKeys containsObject:codeStr]) {\n        return self.errorDic[codeStr];\n    }else{\n        NSLog(@\"没有定义该类型错误\");\n        return nil;\n    }\n}\n```\n\n包装成宏方便调用\n\n```\n#define KERROR_RESPONSE(errCode) [DKResponse responseWithErrorOnly:[self errorDescriptionWithCode:errCode] code:errCode]\n```\n\n3.1 输出一个漂亮的 Log\n\n```\n/**\n *  打印一个漂亮的 log\n *\n *  @param method              请求方法\n *  @param url                 接口地址\n *  @param params              参数\n *  @param response            响应对象\n *  @param showRequestContent  是否显示响应数据\n */\n+ (void)logDebugInfoWithMethod:(NSString *)method URL:(NSString *)url params:(NSDictionary *)params response:(DKResponse *)response showRequestContent:(BOOL)showRequestContent;\n```\n\n里面主要是字符串拼接.要看详细的话就去下载 Demo吧!\n\n","source":"_posts/网络层方法封装3.md","raw":"---\ntitle: 网络层方法封装3\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: fee6ede8\ndate: 2016-11-21 00:00:00\n---\n网络层方法封装3.1\n\n<!-- more -->\n\n** 其实很久之前就想写写这个东西,不过因为项目的原因一直没时间去整理出来,所以决定还是分开几天去写完这个东西吧\n\n- 新增特性:\n\t- 3.0\n\t\t- 多缓存策略\n\t\t- 用宏定义减少代码量\n\t\t- 使用 plist统一错误信息设置\n\t- 3.1\n\t\t- 输出一个漂亮的Log\n\n- 先讲讲本地持久化策略的选择\n\n\t- 数据量小,单一的时候(比如一个模型数组,数组不大而且模型的成员属性不是很多),可以使用 `NSKeyArchive` 归档\n\n\t- `NSUserDefault` 用于储存用户首选项\n\n\t- `KeyChain`储存一些密码之类的东西\n\n\t- 数据库储存数据量比较大,字段比较多的模型数组\n\n- 缓存策略\n\n```\ntypedef NS_ENUM(NSInteger,DKCacheStrategy){\n    DKCacheStrategy_CACHE_ONLY, // 只从本地取数据\n    DKCacheStrategy_NETWORK_ONLY, // 只从网络取数据(不缓存)\n    DKCacheStrategy_NETWORK_AND_CACHE, // 从网络取数据后缓存(缓存结束不回调)\n    DKCacheStrategy_CACHE_ELSE_NETWORK, // 先取缓存,如果没有数据的话,才从网络取数据\n    DKCacheStrategy_CACHE_THEN_NETWORK // 先取缓存,再加载网络数据,网络数据加载完会更新缓存,这个选择会有两次回调\n    DKCacheStrategy_AUTOMATIC // 根据当前网络环境自动选择,如果有网络(WIFI/WLAN)就取网络数据,没网络就取缓存数据\n};\n```\n\n- Demo 说明\n   - github地址:没有\n   - 下载地址: NetworkDemo\n   - 选择本地持久化方式: `YYCache`,如果有更适合的缓存机制,那改一改也挺简单\n \n- 方法接口设计\n\n```\n/**\n *  发送HTTP请求\n *\n *  @param method 请求方法,你可以写@\"get\"或者@\"post\"(不区分大小写)或者已经定义好的 kGET 或 kPOST\n *  @param strategy  缓存策略\n *  @param header 请求头,可为空\n *  @param params 请求参数,可为空\n *  @param block  返回回调,这个就不要空啦\n *\n *  @return 请求标示 id 可以用来取消请求\n */\n- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block;\n```\n\n之前两个方法继续保留,在这里就不说明了\n\n```\n- (void)cancelAllRequest;\n- (void)cancelRequestWithRequestIds:(NSArray *)requestIds;\n```\n\n然后写两个内部方法,分别是取缓存和取网络数据\n\n```\n#pragma mark - 仅本地\n- (NSInteger)requestWithCacheOnlyStrategyWithUrl:(NSString *)URLString params:(NSDictionary *)params requestBlock:(DKHTTPResponseBlock)block\n{\n    DKResponse *response = (DKResponse *)[self.cache objectForKey:[self cacheKeyForRequestUrl:URLString params:params]];\n    if (block) {\n        if (response) {\n            block(response);\n        }else{\n            block(KERROR_RESPONSE(-1));\n        }\n    }\n    return 0;\n}\n\n#pragma mark - 仅网络\n- (NSInteger)requestWithNetworkOnlyStrategyForMethod:(NSString *)method url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block\n{\n    NSNumber *taskIdentifier = 0;\n    if ([method.uppercaseString isEqualToString:@\"GET\"]) {\n        DKCALLAPI(GET, taskIdentifier);\n    }else if([method.uppercaseString isEqualToString:@\"POST\"]){\n        DKCALLAPI(POST, taskIdentifier);\n    }else{\n        return 0;\n    }\n    return taskIdentifier.integerValue;\n}\n```\n\n这里的宏DKCALLAPI 定义 主要是为了不想写 POST和 GET两个方法,在这里写一次就够了\n\n```\n#define DKCALLAPI(REQUEST_METHOD,REQUEST_ID) \\\n{\\\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\\\n    AFHTTPRequestSerializer *requestSerializer = mgr.requestSerializer;\\\n    if (header) {\\\n        [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id obj, BOOL * _Nonnull stop) {\\\n            [requestSerializer setValue:obj forHTTPHeaderField:key];\\\n        }];\\\n    }\\\n    requestSerializer.timeoutInterval = kTimeOutInterval;\\\n    NSURLSessionTask *task = [mgr REQUEST_METHOD:URLString parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\\\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\\\n        resp.rawData = responseObject;\\\n        resp.taskIdentifier = task.taskIdentifier;\\\n        if(block){\\\n            block(resp);\\\n        }\\\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\\\n        DKResponse *resp = [DKResponse responseWithErrorOnly:error.description code:error.code];\\\n        if (block) {\\\n            block(resp);\\\n        }\\\n    }];\\\n    REQUEST_ID = @(task.taskIdentifier);\\\n    [self.dispatchTable setObject:task forKey:REQUEST_ID];\\\n}\n```\n\n然后 就可以实现我们的接口了 switch 里面的东西就就根据注释写吧\n\n```\n- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block\n{\n    __weak typeof(self) weakSelf = self;\n    NSInteger requestId;\n    switch (strategy) {\n        case DKCacheStrategy_CACHE_ONLY:\n        // 调用获取缓存方法\n            break;\n        case DKCacheStrategy_NETWORK_ONLY:\n        // 调用获取网络方法\n            break;\n        case DKCacheStrategy_NETWORK_AND_CACHE:\n        // 调用网络方法,回调后写入本地缓存\n            break;\n        case DKCacheStrategy_CACHE_ELSE_NETWORK:\n        // 调用本地缓存方法,在回调中判断是否有缓存,如果没有的话调用网络方法\n            break;\n        case DKCacheStrategy_CACHE_THEN_NETWORK:\n        // 调用本地方法接着调用网络方法 \n            break;\n        case DKCacheStrategy_AUTOMATICALLY:\n         // 调用网络方法,回调中如果返回错误则调用本地缓存方法\n            break;\n        default:\n            break;\n    }\n    return requestId;\n}\n```\n\n统一错误表处理\n-建立一个plist 文件\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>-2</key>\n\t<string>网络连接失败</string>\n\t<key>-1</key>\n\t<string>没有缓存</string>\n</dict>\n</plist>\n```\n\n一个成员属性加一个方法去调用\n\n```\n- (NSDictionary *)errorDic\n{\n    if (!_errorDic) {\n        NSString *path = [[NSBundle mainBundle] pathForResource:@\"DKError\" ofType:@\"plist\"];\n        _errorDic = [NSDictionary dictionaryWithContentsOfFile:path];\n    }\n    return _errorDic;\n}\n\n- (NSString *)errorDescriptionWithCode:(NSInteger)code\n{\n    NSString *codeStr = [NSString stringWithFormat:@\"%zd\",code];\n    if ([self.errorDic.allKeys containsObject:codeStr]) {\n        return self.errorDic[codeStr];\n    }else{\n        NSLog(@\"没有定义该类型错误\");\n        return nil;\n    }\n}\n```\n\n包装成宏方便调用\n\n```\n#define KERROR_RESPONSE(errCode) [DKResponse responseWithErrorOnly:[self errorDescriptionWithCode:errCode] code:errCode]\n```\n\n3.1 输出一个漂亮的 Log\n\n```\n/**\n *  打印一个漂亮的 log\n *\n *  @param method              请求方法\n *  @param url                 接口地址\n *  @param params              参数\n *  @param response            响应对象\n *  @param showRequestContent  是否显示响应数据\n */\n+ (void)logDebugInfoWithMethod:(NSString *)method URL:(NSString *)url params:(NSDictionary *)params response:(DKResponse *)response showRequestContent:(BOOL)showRequestContent;\n```\n\n里面主要是字符串拼接.要看详细的话就去下载 Demo吧!\n\n","slug":"网络层方法封装3","published":1,"updated":"2021-06-06T18:52:24.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoix007itnn03v0d14ba","content":"<p>网络层方法封装3.1</p>\n<span id=\"more\"></span>\n\n<p>** 其实很久之前就想写写这个东西,不过因为项目的原因一直没时间去整理出来,所以决定还是分开几天去写完这个东西吧</p>\n<ul>\n<li><p>新增特性:</p>\n<ul>\n<li>3.0<ul>\n<li>多缓存策略</li>\n<li>用宏定义减少代码量</li>\n<li>使用 plist统一错误信息设置</li>\n</ul>\n</li>\n<li>3.1<ul>\n<li>输出一个漂亮的Log</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>先讲讲本地持久化策略的选择</p>\n<ul>\n<li><p>数据量小,单一的时候(比如一个模型数组,数组不大而且模型的成员属性不是很多),可以使用 <code>NSKeyArchive</code> 归档</p>\n</li>\n<li><p><code>NSUserDefault</code> 用于储存用户首选项</p>\n</li>\n<li><p><code>KeyChain</code>储存一些密码之类的东西</p>\n</li>\n<li><p>数据库储存数据量比较大,字段比较多的模型数组</p>\n</li>\n</ul>\n</li>\n<li><p>缓存策略</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_ENUM(NSInteger,DKCacheStrategy)&#123;</span><br><span class=\"line\">    DKCacheStrategy_CACHE_ONLY, &#x2F;&#x2F; 只从本地取数据</span><br><span class=\"line\">    DKCacheStrategy_NETWORK_ONLY, &#x2F;&#x2F; 只从网络取数据(不缓存)</span><br><span class=\"line\">    DKCacheStrategy_NETWORK_AND_CACHE, &#x2F;&#x2F; 从网络取数据后缓存(缓存结束不回调)</span><br><span class=\"line\">    DKCacheStrategy_CACHE_ELSE_NETWORK, &#x2F;&#x2F; 先取缓存,如果没有数据的话,才从网络取数据</span><br><span class=\"line\">    DKCacheStrategy_CACHE_THEN_NETWORK &#x2F;&#x2F; 先取缓存,再加载网络数据,网络数据加载完会更新缓存,这个选择会有两次回调</span><br><span class=\"line\">    DKCacheStrategy_AUTOMATIC &#x2F;&#x2F; 根据当前网络环境自动选择,如果有网络(WIFI&#x2F;WLAN)就取网络数据,没网络就取缓存数据</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Demo 说明<ul>\n<li>github地址:没有</li>\n<li>下载地址: NetworkDemo</li>\n<li>选择本地持久化方式: <code>YYCache</code>,如果有更适合的缓存机制,那改一改也挺简单</li>\n</ul>\n</li>\n<li>方法接口设计</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> *  发送HTTP请求</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param method 请求方法,你可以写@&quot;get&quot;或者@&quot;post&quot;(不区分大小写)或者已经定义好的 kGET 或 kPOST</span><br><span class=\"line\"> *  @param strategy  缓存策略</span><br><span class=\"line\"> *  @param header 请求头,可为空</span><br><span class=\"line\"> *  @param params 请求参数,可为空</span><br><span class=\"line\"> *  @param block  返回回调,这个就不要空啦</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @return 请求标示 id 可以用来取消请求</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n\n<p>之前两个方法继续保留,在这里就不说明了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)cancelAllRequest;</span><br><span class=\"line\">- (void)cancelRequestWithRequestIds:(NSArray *)requestIds;</span><br></pre></td></tr></table></figure>\n\n<p>然后写两个内部方法,分别是取缓存和取网络数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - 仅本地</span><br><span class=\"line\">- (NSInteger)requestWithCacheOnlyStrategyWithUrl:(NSString *)URLString params:(NSDictionary *)params requestBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DKResponse *response &#x3D; (DKResponse *)[self.cache objectForKey:[self cacheKeyForRequestUrl:URLString params:params]];</span><br><span class=\"line\">    if (block) &#123;</span><br><span class=\"line\">        if (response) &#123;</span><br><span class=\"line\">            block(response);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            block(KERROR_RESPONSE(-1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - 仅网络</span><br><span class=\"line\">- (NSInteger)requestWithNetworkOnlyStrategyForMethod:(NSString *)method url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSNumber *taskIdentifier &#x3D; 0;</span><br><span class=\"line\">    if ([method.uppercaseString isEqualToString:@&quot;GET&quot;]) &#123;</span><br><span class=\"line\">        DKCALLAPI(GET, taskIdentifier);</span><br><span class=\"line\">    &#125;else if([method.uppercaseString isEqualToString:@&quot;POST&quot;])&#123;</span><br><span class=\"line\">        DKCALLAPI(POST, taskIdentifier);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return taskIdentifier.integerValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的宏DKCALLAPI 定义 主要是为了不想写 POST和 GET两个方法,在这里写一次就够了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKCALLAPI(REQUEST_METHOD,REQUEST_ID) \\</span><br><span class=\"line\">&#123;\\</span><br><span class=\"line\">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];\\</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer &#x3D; mgr.requestSerializer;\\</span><br><span class=\"line\">    if (header) &#123;\\</span><br><span class=\"line\">        [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id obj, BOOL * _Nonnull stop) &#123;\\</span><br><span class=\"line\">            [requestSerializer setValue:obj forHTTPHeaderField:key];\\</span><br><span class=\"line\">        &#125;];\\</span><br><span class=\"line\">    &#125;\\</span><br><span class=\"line\">    requestSerializer.timeoutInterval &#x3D; kTimeOutInterval;\\</span><br><span class=\"line\">    NSURLSessionTask *task &#x3D; [mgr REQUEST_METHOD:URLString parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;\\</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject];\\</span><br><span class=\"line\">        resp.rawData &#x3D; responseObject;\\</span><br><span class=\"line\">        resp.taskIdentifier &#x3D; task.taskIdentifier;\\</span><br><span class=\"line\">        if(block)&#123;\\</span><br><span class=\"line\">            block(resp);\\</span><br><span class=\"line\">        &#125;\\</span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;\\</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse responseWithErrorOnly:error.description code:error.code];\\</span><br><span class=\"line\">        if (block) &#123;\\</span><br><span class=\"line\">            block(resp);\\</span><br><span class=\"line\">        &#125;\\</span><br><span class=\"line\">    &#125;];\\</span><br><span class=\"line\">    REQUEST_ID &#x3D; @(task.taskIdentifier);\\</span><br><span class=\"line\">    [self.dispatchTable setObject:task forKey:REQUEST_ID];\\</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后 就可以实现我们的接口了 switch 里面的东西就就根据注释写吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __weak typeof(self) weakSelf &#x3D; self;</span><br><span class=\"line\">    NSInteger requestId;</span><br><span class=\"line\">    switch (strategy) &#123;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_ONLY:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用获取缓存方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_NETWORK_ONLY:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用获取网络方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_NETWORK_AND_CACHE:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用网络方法,回调后写入本地缓存</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_ELSE_NETWORK:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用本地缓存方法,在回调中判断是否有缓存,如果没有的话调用网络方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_THEN_NETWORK:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用本地方法接着调用网络方法 </span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_AUTOMATICALLY:</span><br><span class=\"line\">         &#x2F;&#x2F; 调用网络方法,回调中如果返回错误则调用本地缓存方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return requestId;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>统一错误表处理<br>-建立一个plist 文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class=\"line\">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class=\"line\">&lt;dict&gt;</span><br><span class=\"line\">\t&lt;key&gt;-2&lt;&#x2F;key&gt;</span><br><span class=\"line\">\t&lt;string&gt;网络连接失败&lt;&#x2F;string&gt;</span><br><span class=\"line\">\t&lt;key&gt;-1&lt;&#x2F;key&gt;</span><br><span class=\"line\">\t&lt;string&gt;没有缓存&lt;&#x2F;string&gt;</span><br><span class=\"line\">&lt;&#x2F;dict&gt;</span><br><span class=\"line\">&lt;&#x2F;plist&gt;</span><br></pre></td></tr></table></figure>\n\n<p>一个成员属性加一个方法去调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSDictionary *)errorDic</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!_errorDic) &#123;</span><br><span class=\"line\">        NSString *path &#x3D; [[NSBundle mainBundle] pathForResource:@&quot;DKError&quot; ofType:@&quot;plist&quot;];</span><br><span class=\"line\">        _errorDic &#x3D; [NSDictionary dictionaryWithContentsOfFile:path];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _errorDic;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)errorDescriptionWithCode:(NSInteger)code</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSString *codeStr &#x3D; [NSString stringWithFormat:@&quot;%zd&quot;,code];</span><br><span class=\"line\">    if ([self.errorDic.allKeys containsObject:codeStr]) &#123;</span><br><span class=\"line\">        return self.errorDic[codeStr];</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        NSLog(@&quot;没有定义该类型错误&quot;);</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>包装成宏方便调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define KERROR_RESPONSE(errCode) [DKResponse responseWithErrorOnly:[self errorDescriptionWithCode:errCode] code:errCode]</span><br></pre></td></tr></table></figure>\n\n<p>3.1 输出一个漂亮的 Log</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> *  打印一个漂亮的 log</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param method              请求方法</span><br><span class=\"line\"> *  @param url                 接口地址</span><br><span class=\"line\"> *  @param params              参数</span><br><span class=\"line\"> *  @param response            响应对象</span><br><span class=\"line\"> *  @param showRequestContent  是否显示响应数据</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">+ (void)logDebugInfoWithMethod:(NSString *)method URL:(NSString *)url params:(NSDictionary *)params response:(DKResponse *)response showRequestContent:(BOOL)showRequestContent;</span><br></pre></td></tr></table></figure>\n\n<p>里面主要是字符串拼接.要看详细的话就去下载 Demo吧!</p>\n","site":{"data":{}},"excerpt":"<p>网络层方法封装3.1</p>","more":"<p>** 其实很久之前就想写写这个东西,不过因为项目的原因一直没时间去整理出来,所以决定还是分开几天去写完这个东西吧</p>\n<ul>\n<li><p>新增特性:</p>\n<ul>\n<li>3.0<ul>\n<li>多缓存策略</li>\n<li>用宏定义减少代码量</li>\n<li>使用 plist统一错误信息设置</li>\n</ul>\n</li>\n<li>3.1<ul>\n<li>输出一个漂亮的Log</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>先讲讲本地持久化策略的选择</p>\n<ul>\n<li><p>数据量小,单一的时候(比如一个模型数组,数组不大而且模型的成员属性不是很多),可以使用 <code>NSKeyArchive</code> 归档</p>\n</li>\n<li><p><code>NSUserDefault</code> 用于储存用户首选项</p>\n</li>\n<li><p><code>KeyChain</code>储存一些密码之类的东西</p>\n</li>\n<li><p>数据库储存数据量比较大,字段比较多的模型数组</p>\n</li>\n</ul>\n</li>\n<li><p>缓存策略</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_ENUM(NSInteger,DKCacheStrategy)&#123;</span><br><span class=\"line\">    DKCacheStrategy_CACHE_ONLY, &#x2F;&#x2F; 只从本地取数据</span><br><span class=\"line\">    DKCacheStrategy_NETWORK_ONLY, &#x2F;&#x2F; 只从网络取数据(不缓存)</span><br><span class=\"line\">    DKCacheStrategy_NETWORK_AND_CACHE, &#x2F;&#x2F; 从网络取数据后缓存(缓存结束不回调)</span><br><span class=\"line\">    DKCacheStrategy_CACHE_ELSE_NETWORK, &#x2F;&#x2F; 先取缓存,如果没有数据的话,才从网络取数据</span><br><span class=\"line\">    DKCacheStrategy_CACHE_THEN_NETWORK &#x2F;&#x2F; 先取缓存,再加载网络数据,网络数据加载完会更新缓存,这个选择会有两次回调</span><br><span class=\"line\">    DKCacheStrategy_AUTOMATIC &#x2F;&#x2F; 根据当前网络环境自动选择,如果有网络(WIFI&#x2F;WLAN)就取网络数据,没网络就取缓存数据</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Demo 说明<ul>\n<li>github地址:没有</li>\n<li>下载地址: NetworkDemo</li>\n<li>选择本地持久化方式: <code>YYCache</code>,如果有更适合的缓存机制,那改一改也挺简单</li>\n</ul>\n</li>\n<li>方法接口设计</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> *  发送HTTP请求</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param method 请求方法,你可以写@&quot;get&quot;或者@&quot;post&quot;(不区分大小写)或者已经定义好的 kGET 或 kPOST</span><br><span class=\"line\"> *  @param strategy  缓存策略</span><br><span class=\"line\"> *  @param header 请求头,可为空</span><br><span class=\"line\"> *  @param params 请求参数,可为空</span><br><span class=\"line\"> *  @param block  返回回调,这个就不要空啦</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @return 请求标示 id 可以用来取消请求</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n\n<p>之前两个方法继续保留,在这里就不说明了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)cancelAllRequest;</span><br><span class=\"line\">- (void)cancelRequestWithRequestIds:(NSArray *)requestIds;</span><br></pre></td></tr></table></figure>\n\n<p>然后写两个内部方法,分别是取缓存和取网络数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - 仅本地</span><br><span class=\"line\">- (NSInteger)requestWithCacheOnlyStrategyWithUrl:(NSString *)URLString params:(NSDictionary *)params requestBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DKResponse *response &#x3D; (DKResponse *)[self.cache objectForKey:[self cacheKeyForRequestUrl:URLString params:params]];</span><br><span class=\"line\">    if (block) &#123;</span><br><span class=\"line\">        if (response) &#123;</span><br><span class=\"line\">            block(response);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            block(KERROR_RESPONSE(-1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - 仅网络</span><br><span class=\"line\">- (NSInteger)requestWithNetworkOnlyStrategyForMethod:(NSString *)method url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSNumber *taskIdentifier &#x3D; 0;</span><br><span class=\"line\">    if ([method.uppercaseString isEqualToString:@&quot;GET&quot;]) &#123;</span><br><span class=\"line\">        DKCALLAPI(GET, taskIdentifier);</span><br><span class=\"line\">    &#125;else if([method.uppercaseString isEqualToString:@&quot;POST&quot;])&#123;</span><br><span class=\"line\">        DKCALLAPI(POST, taskIdentifier);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return taskIdentifier.integerValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的宏DKCALLAPI 定义 主要是为了不想写 POST和 GET两个方法,在这里写一次就够了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKCALLAPI(REQUEST_METHOD,REQUEST_ID) \\</span><br><span class=\"line\">&#123;\\</span><br><span class=\"line\">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];\\</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer &#x3D; mgr.requestSerializer;\\</span><br><span class=\"line\">    if (header) &#123;\\</span><br><span class=\"line\">        [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id obj, BOOL * _Nonnull stop) &#123;\\</span><br><span class=\"line\">            [requestSerializer setValue:obj forHTTPHeaderField:key];\\</span><br><span class=\"line\">        &#125;];\\</span><br><span class=\"line\">    &#125;\\</span><br><span class=\"line\">    requestSerializer.timeoutInterval &#x3D; kTimeOutInterval;\\</span><br><span class=\"line\">    NSURLSessionTask *task &#x3D; [mgr REQUEST_METHOD:URLString parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;\\</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject];\\</span><br><span class=\"line\">        resp.rawData &#x3D; responseObject;\\</span><br><span class=\"line\">        resp.taskIdentifier &#x3D; task.taskIdentifier;\\</span><br><span class=\"line\">        if(block)&#123;\\</span><br><span class=\"line\">            block(resp);\\</span><br><span class=\"line\">        &#125;\\</span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;\\</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse responseWithErrorOnly:error.description code:error.code];\\</span><br><span class=\"line\">        if (block) &#123;\\</span><br><span class=\"line\">            block(resp);\\</span><br><span class=\"line\">        &#125;\\</span><br><span class=\"line\">    &#125;];\\</span><br><span class=\"line\">    REQUEST_ID &#x3D; @(task.taskIdentifier);\\</span><br><span class=\"line\">    [self.dispatchTable setObject:task forKey:REQUEST_ID];\\</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后 就可以实现我们的接口了 switch 里面的东西就就根据注释写吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __weak typeof(self) weakSelf &#x3D; self;</span><br><span class=\"line\">    NSInteger requestId;</span><br><span class=\"line\">    switch (strategy) &#123;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_ONLY:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用获取缓存方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_NETWORK_ONLY:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用获取网络方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_NETWORK_AND_CACHE:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用网络方法,回调后写入本地缓存</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_ELSE_NETWORK:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用本地缓存方法,在回调中判断是否有缓存,如果没有的话调用网络方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_THEN_NETWORK:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用本地方法接着调用网络方法 </span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_AUTOMATICALLY:</span><br><span class=\"line\">         &#x2F;&#x2F; 调用网络方法,回调中如果返回错误则调用本地缓存方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return requestId;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>统一错误表处理<br>-建立一个plist 文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class=\"line\">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class=\"line\">&lt;dict&gt;</span><br><span class=\"line\">\t&lt;key&gt;-2&lt;&#x2F;key&gt;</span><br><span class=\"line\">\t&lt;string&gt;网络连接失败&lt;&#x2F;string&gt;</span><br><span class=\"line\">\t&lt;key&gt;-1&lt;&#x2F;key&gt;</span><br><span class=\"line\">\t&lt;string&gt;没有缓存&lt;&#x2F;string&gt;</span><br><span class=\"line\">&lt;&#x2F;dict&gt;</span><br><span class=\"line\">&lt;&#x2F;plist&gt;</span><br></pre></td></tr></table></figure>\n\n<p>一个成员属性加一个方法去调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSDictionary *)errorDic</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!_errorDic) &#123;</span><br><span class=\"line\">        NSString *path &#x3D; [[NSBundle mainBundle] pathForResource:@&quot;DKError&quot; ofType:@&quot;plist&quot;];</span><br><span class=\"line\">        _errorDic &#x3D; [NSDictionary dictionaryWithContentsOfFile:path];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _errorDic;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)errorDescriptionWithCode:(NSInteger)code</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSString *codeStr &#x3D; [NSString stringWithFormat:@&quot;%zd&quot;,code];</span><br><span class=\"line\">    if ([self.errorDic.allKeys containsObject:codeStr]) &#123;</span><br><span class=\"line\">        return self.errorDic[codeStr];</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        NSLog(@&quot;没有定义该类型错误&quot;);</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>包装成宏方便调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define KERROR_RESPONSE(errCode) [DKResponse responseWithErrorOnly:[self errorDescriptionWithCode:errCode] code:errCode]</span><br></pre></td></tr></table></figure>\n\n<p>3.1 输出一个漂亮的 Log</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> *  打印一个漂亮的 log</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param method              请求方法</span><br><span class=\"line\"> *  @param url                 接口地址</span><br><span class=\"line\"> *  @param params              参数</span><br><span class=\"line\"> *  @param response            响应对象</span><br><span class=\"line\"> *  @param showRequestContent  是否显示响应数据</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">+ (void)logDebugInfoWithMethod:(NSString *)method URL:(NSString *)url params:(NSDictionary *)params response:(DKResponse *)response showRequestContent:(BOOL)showRequestContent;</span><br></pre></td></tr></table></figure>\n\n<p>里面主要是字符串拼接.要看详细的话就去下载 Demo吧!</p>"},{"title":"网络层方法封装5","author":"Arclin","abbrlink":"178548dd","date":"2016-12-14T19:00:00.000Z","_content":"网络层方法封装5.2.1\n\n- 特性\n\t- 添加链式调用方法\n- 5.1\n\t- 开启/关闭 Log\n\t- 自定义 Logger\n\t- RAC支持\n- 5.2.1\n\t- 修复了一些 bug\n\t- 由于服务器异常而返回的 NSData 转为 HTML 页面并展示出来（需要打开 DebugMode）\n\t- 把链式调用方法抽出为一个 DKHTTPChainTool 类\n    \n<!-- more -->\n    \n1. 添加链式调用方法\n\n链式调用的好处就是要啥参数就添加啥,方便快捷,不用担心代码不够漂亮！\n\n```\n#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]\n\n/** 链式调用 */\n- (DKHTTPChainTool * (^)(NSString *method))method;\n- (DKHTTPChainTool * (^)(NSString *url))url;\n- (DKHTTPChainTool * (^)(NSDictionary *header))header;\n- (DKHTTPChainTool * (^)(DKCacheStrategy strategy))cacheStrategy;\n- (DKHTTPChainTool * (^)(DKHTTPParamsVarifyBlock paramsVerify))verifyParams;\n- (DKHTTPChainTool * (^)(DKHTTPRequestFilterBlock resultFilter))requestFilter;\n- (DKHTTPChainTool * (^)(NSDictionary *params))params;\n/** block返回请求Id */\n- (NSInteger (^)(DKHTTPResponseBlock responseBlock))execute;\n```\n\n使用起来感觉是这样子的\n\n```\nDKHTTPChainInstance.method(@\"POST\")\n           .url(@\"\")\n           .params(@{@\"account\":@\"m13643046965@163.com\",@\"password\":@\"123456\"})\n           .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)\n           .verifyParams(^NSString *(NSDictionary *params){\n               return nil;\n           })\n           .requestFilter(^DKRequest *(DKRequest *request){\n               return request;\n           })\n           .execute(^(DKResponse *response){\n               NSLog(@\"%@\",response.rawData);\n           });\n```\n\n- 5.1\n\n开启/关闭 Log\n\n```\nDKHTTPSharedTool.showLog = YES/NO;\n```\n\n自定义 Logger\n\n```\n#define DKLog(...) NSLog(@\"%s %zd行 %@\",__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])\n\n[DKHTTPTool setLogger:^(NSString *msg) {\n  DKLog(@\"%@\",msg);\n}];\n```\n\nRAC支持\n\n```\n- (RACSignal *(^)())executeSignal;\n```\n\n使用\n```\nRACSignal *signal = DKHTTPChainInstance.method(@\"POST\")\n                                        .url()\n                                        .header(@{@\"token\":@\"0e83179ac83741416e50b0ea12113f6e\"})\n                                        .params(@{@\"account\":@\"\",@\"password\":@\"123456\"})\n                                        .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)\n                                        .verifyParams(^NSString *(NSDictionary *params){\n                                        return nil;\n                                        })\n                                      .requestFilter(^DKRequest *(DKRequest *request){\n                                        return request;\n                                        })\n                                      .executeSignal();\n[signal subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n}];\n```\n\n- 5.2.1\n\n1.DKHTTPTool的链式调用\n\n```\n#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]\n```\n\n使用方法和上面说的一样\n\n2.调试模式\n\n```\nDKHTTPSharedTool.debugMode = YES; // 开启 Log 和 服务器异常弹窗\n如果服务器发生异常，那么就会发生如图情况\n```\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/555.png?raw=true)\n![](https://github.com/Arc-lin/BlogImage/blob/master/666.png?raw=true)\n![](https://github.com/Arc-lin/BlogImage/blob/master/777.png?raw=true)\n\n\n","source":"_posts/网络层方法封装5.md","raw":"---\ntitle: 网络层方法封装5\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 178548dd\ndate: 2016-12-15 03:00:00\n---\n网络层方法封装5.2.1\n\n- 特性\n\t- 添加链式调用方法\n- 5.1\n\t- 开启/关闭 Log\n\t- 自定义 Logger\n\t- RAC支持\n- 5.2.1\n\t- 修复了一些 bug\n\t- 由于服务器异常而返回的 NSData 转为 HTML 页面并展示出来（需要打开 DebugMode）\n\t- 把链式调用方法抽出为一个 DKHTTPChainTool 类\n    \n<!-- more -->\n    \n1. 添加链式调用方法\n\n链式调用的好处就是要啥参数就添加啥,方便快捷,不用担心代码不够漂亮！\n\n```\n#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]\n\n/** 链式调用 */\n- (DKHTTPChainTool * (^)(NSString *method))method;\n- (DKHTTPChainTool * (^)(NSString *url))url;\n- (DKHTTPChainTool * (^)(NSDictionary *header))header;\n- (DKHTTPChainTool * (^)(DKCacheStrategy strategy))cacheStrategy;\n- (DKHTTPChainTool * (^)(DKHTTPParamsVarifyBlock paramsVerify))verifyParams;\n- (DKHTTPChainTool * (^)(DKHTTPRequestFilterBlock resultFilter))requestFilter;\n- (DKHTTPChainTool * (^)(NSDictionary *params))params;\n/** block返回请求Id */\n- (NSInteger (^)(DKHTTPResponseBlock responseBlock))execute;\n```\n\n使用起来感觉是这样子的\n\n```\nDKHTTPChainInstance.method(@\"POST\")\n           .url(@\"\")\n           .params(@{@\"account\":@\"m13643046965@163.com\",@\"password\":@\"123456\"})\n           .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)\n           .verifyParams(^NSString *(NSDictionary *params){\n               return nil;\n           })\n           .requestFilter(^DKRequest *(DKRequest *request){\n               return request;\n           })\n           .execute(^(DKResponse *response){\n               NSLog(@\"%@\",response.rawData);\n           });\n```\n\n- 5.1\n\n开启/关闭 Log\n\n```\nDKHTTPSharedTool.showLog = YES/NO;\n```\n\n自定义 Logger\n\n```\n#define DKLog(...) NSLog(@\"%s %zd行 %@\",__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])\n\n[DKHTTPTool setLogger:^(NSString *msg) {\n  DKLog(@\"%@\",msg);\n}];\n```\n\nRAC支持\n\n```\n- (RACSignal *(^)())executeSignal;\n```\n\n使用\n```\nRACSignal *signal = DKHTTPChainInstance.method(@\"POST\")\n                                        .url()\n                                        .header(@{@\"token\":@\"0e83179ac83741416e50b0ea12113f6e\"})\n                                        .params(@{@\"account\":@\"\",@\"password\":@\"123456\"})\n                                        .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)\n                                        .verifyParams(^NSString *(NSDictionary *params){\n                                        return nil;\n                                        })\n                                      .requestFilter(^DKRequest *(DKRequest *request){\n                                        return request;\n                                        })\n                                      .executeSignal();\n[signal subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n}];\n```\n\n- 5.2.1\n\n1.DKHTTPTool的链式调用\n\n```\n#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]\n```\n\n使用方法和上面说的一样\n\n2.调试模式\n\n```\nDKHTTPSharedTool.debugMode = YES; // 开启 Log 和 服务器异常弹窗\n如果服务器发生异常，那么就会发生如图情况\n```\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/555.png?raw=true)\n![](https://github.com/Arc-lin/BlogImage/blob/master/666.png?raw=true)\n![](https://github.com/Arc-lin/BlogImage/blob/master/777.png?raw=true)\n\n\n","slug":"网络层方法封装5","published":1,"updated":"2021-06-06T18:52:24.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoiy007mtnn0c5o46pee","content":"<p>网络层方法封装5.2.1</p>\n<ul>\n<li>特性<ul>\n<li>添加链式调用方法</li>\n</ul>\n</li>\n<li>5.1<ul>\n<li>开启/关闭 Log</li>\n<li>自定义 Logger</li>\n<li>RAC支持</li>\n</ul>\n</li>\n<li>5.2.1<ul>\n<li>修复了一些 bug</li>\n<li>由于服务器异常而返回的 NSData 转为 HTML 页面并展示出来（需要打开 DebugMode）</li>\n<li>把链式调用方法抽出为一个 DKHTTPChainTool 类</li>\n</ul>\n</li>\n</ul>\n<span id=\"more\"></span>\n<ol>\n<li>添加链式调用方法</li>\n</ol>\n<p>链式调用的好处就是要啥参数就添加啥,方便快捷,不用担心代码不够漂亮！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 链式调用 *&#x2F;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSString *method))method;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSString *url))url;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSDictionary *header))header;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKCacheStrategy strategy))cacheStrategy;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKHTTPParamsVarifyBlock paramsVerify))verifyParams;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKHTTPRequestFilterBlock resultFilter))requestFilter;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSDictionary *params))params;</span><br><span class=\"line\">&#x2F;** block返回请求Id *&#x2F;</span><br><span class=\"line\">- (NSInteger (^)(DKHTTPResponseBlock responseBlock))execute;</span><br></pre></td></tr></table></figure>\n\n<p>使用起来感觉是这样子的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">           .url(@&quot;&quot;)</span><br><span class=\"line\">           .params(@&#123;@&quot;account&quot;:@&quot;m13643046965@163.com&quot;,@&quot;password&quot;:@&quot;123456&quot;&#125;)</span><br><span class=\"line\">           .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)</span><br><span class=\"line\">           .verifyParams(^NSString *(NSDictionary *params)&#123;</span><br><span class=\"line\">               return nil;</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">           .requestFilter(^DKRequest *(DKRequest *request)&#123;</span><br><span class=\"line\">               return request;</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">           .execute(^(DKResponse *response)&#123;</span><br><span class=\"line\">               NSLog(@&quot;%@&quot;,response.rawData);</span><br><span class=\"line\">           &#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>5.1</li>\n</ul>\n<p>开启/关闭 Log</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPSharedTool.showLog &#x3D; YES&#x2F;NO;</span><br></pre></td></tr></table></figure>\n\n<p>自定义 Logger</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKLog(...) NSLog(@&quot;%s %zd行 %@&quot;,__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])</span><br><span class=\"line\"></span><br><span class=\"line\">[DKHTTPTool setLogger:^(NSString *msg) &#123;</span><br><span class=\"line\">  DKLog(@&quot;%@&quot;,msg);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>RAC支持</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (RACSignal *(^)())executeSignal;</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *signal &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url()</span><br><span class=\"line\">                                        .header(@&#123;@&quot;token&quot;:@&quot;0e83179ac83741416e50b0ea12113f6e&quot;&#125;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;account&quot;:@&quot;&quot;,@&quot;password&quot;:@&quot;123456&quot;&#125;)</span><br><span class=\"line\">                                        .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)</span><br><span class=\"line\">                                        .verifyParams(^NSString *(NSDictionary *params)&#123;</span><br><span class=\"line\">                                        return nil;</span><br><span class=\"line\">                                        &#125;)</span><br><span class=\"line\">                                      .requestFilter(^DKRequest *(DKRequest *request)&#123;</span><br><span class=\"line\">                                        return request;</span><br><span class=\"line\">                                        &#125;)</span><br><span class=\"line\">                                      .executeSignal();</span><br><span class=\"line\">[signal subscribeNext:^(id x) &#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>5.2.1</li>\n</ul>\n<p>1.DKHTTPTool的链式调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]</span><br></pre></td></tr></table></figure>\n\n<p>使用方法和上面说的一样</p>\n<p>2.调试模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPSharedTool.debugMode &#x3D; YES; &#x2F;&#x2F; 开启 Log 和 服务器异常弹窗</span><br><span class=\"line\">如果服务器发生异常，那么就会发生如图情况</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/555.png?raw=true\"><br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/666.png?raw=true\"><br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/777.png?raw=true\"></p>\n","site":{"data":{}},"excerpt":"<p>网络层方法封装5.2.1</p>\n<ul>\n<li>特性<ul>\n<li>添加链式调用方法</li>\n</ul>\n</li>\n<li>5.1<ul>\n<li>开启/关闭 Log</li>\n<li>自定义 Logger</li>\n<li>RAC支持</li>\n</ul>\n</li>\n<li>5.2.1<ul>\n<li>修复了一些 bug</li>\n<li>由于服务器异常而返回的 NSData 转为 HTML 页面并展示出来（需要打开 DebugMode）</li>\n<li>把链式调用方法抽出为一个 DKHTTPChainTool 类</li>\n</ul>\n</li>\n</ul>","more":"<ol>\n<li>添加链式调用方法</li>\n</ol>\n<p>链式调用的好处就是要啥参数就添加啥,方便快捷,不用担心代码不够漂亮！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 链式调用 *&#x2F;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSString *method))method;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSString *url))url;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSDictionary *header))header;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKCacheStrategy strategy))cacheStrategy;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKHTTPParamsVarifyBlock paramsVerify))verifyParams;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKHTTPRequestFilterBlock resultFilter))requestFilter;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSDictionary *params))params;</span><br><span class=\"line\">&#x2F;** block返回请求Id *&#x2F;</span><br><span class=\"line\">- (NSInteger (^)(DKHTTPResponseBlock responseBlock))execute;</span><br></pre></td></tr></table></figure>\n\n<p>使用起来感觉是这样子的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">           .url(@&quot;&quot;)</span><br><span class=\"line\">           .params(@&#123;@&quot;account&quot;:@&quot;m13643046965@163.com&quot;,@&quot;password&quot;:@&quot;123456&quot;&#125;)</span><br><span class=\"line\">           .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)</span><br><span class=\"line\">           .verifyParams(^NSString *(NSDictionary *params)&#123;</span><br><span class=\"line\">               return nil;</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">           .requestFilter(^DKRequest *(DKRequest *request)&#123;</span><br><span class=\"line\">               return request;</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">           .execute(^(DKResponse *response)&#123;</span><br><span class=\"line\">               NSLog(@&quot;%@&quot;,response.rawData);</span><br><span class=\"line\">           &#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>5.1</li>\n</ul>\n<p>开启/关闭 Log</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPSharedTool.showLog &#x3D; YES&#x2F;NO;</span><br></pre></td></tr></table></figure>\n\n<p>自定义 Logger</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKLog(...) NSLog(@&quot;%s %zd行 %@&quot;,__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])</span><br><span class=\"line\"></span><br><span class=\"line\">[DKHTTPTool setLogger:^(NSString *msg) &#123;</span><br><span class=\"line\">  DKLog(@&quot;%@&quot;,msg);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>RAC支持</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (RACSignal *(^)())executeSignal;</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *signal &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url()</span><br><span class=\"line\">                                        .header(@&#123;@&quot;token&quot;:@&quot;0e83179ac83741416e50b0ea12113f6e&quot;&#125;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;account&quot;:@&quot;&quot;,@&quot;password&quot;:@&quot;123456&quot;&#125;)</span><br><span class=\"line\">                                        .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)</span><br><span class=\"line\">                                        .verifyParams(^NSString *(NSDictionary *params)&#123;</span><br><span class=\"line\">                                        return nil;</span><br><span class=\"line\">                                        &#125;)</span><br><span class=\"line\">                                      .requestFilter(^DKRequest *(DKRequest *request)&#123;</span><br><span class=\"line\">                                        return request;</span><br><span class=\"line\">                                        &#125;)</span><br><span class=\"line\">                                      .executeSignal();</span><br><span class=\"line\">[signal subscribeNext:^(id x) &#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>5.2.1</li>\n</ul>\n<p>1.DKHTTPTool的链式调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]</span><br></pre></td></tr></table></figure>\n\n<p>使用方法和上面说的一样</p>\n<p>2.调试模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPSharedTool.debugMode &#x3D; YES; &#x2F;&#x2F; 开启 Log 和 服务器异常弹窗</span><br><span class=\"line\">如果服务器发生异常，那么就会发生如图情况</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/555.png?raw=true\"><br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/666.png?raw=true\"><br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/777.png?raw=true\"></p>"},{"title":"网络层方法封装4","author":"Arclin","abbrlink":"6082784b","date":"2016-12-14T16:00:00.000Z","_content":"网络层方法封装4\n<!-- more -->\n\n- 新增特性:\n   - 拦截器和验证器\n   - 封装请求对象\n   \n1. 说明\n\n  拦截器顾名思义就是在请求发送之前拦截请求，拦截到的请求可以进行修改之后进行发送，或者阻止请求的发送。可以用于添加分页参数之类的需求。\n\n  验证器指的是验证参数（验证结果的方法后面再补充），验证参数主要用于判断输入参数的合法性，如果验证不通过则可以返回一个错误信息，由请求方法抛出错误，如果验证通过那就返回一个 nil就可以了。\n\n2. 代码\n\n  先说说请求对象模型\n\n  ```\n  @interface DKRequest : NSObject\n\n  /** 请求地址 */\n  @property (nonatomic,copy) NSString * urlStr;\n\n  /** 请求方法 */\n  @property (nonatomic,copy) NSString * method;\n\n  /** 请求参数 */\n  @property (nonatomic,strong) NSDictionary *params;\n\n  /** 请求头 */\n  @property (nonatomic,strong) NSDictionary *header;\n\n  /** 缓存策略 */\n  @property (nonatomic,assign) DKCacheStrategy cacheStrategy;\n\n  /** 请求回调 */\n  @property (nonatomic,copy) DKHTTPResponseBlock responseBlock;\n\n  + (instancetype)requestWithUrlStr:(NSString *)urlStr method:(NSString *)method header:(NSDictionary *)header params:(NSDictionary *)params strategy:(DKCacheStrategy)strategy;\n  @end\n  ```\n\n  完整的接口示例\n\n  ```\n  /**\n   发送HTTP请求\n\n   @param method 请求方法,你可以写@\"get\"或者@\"post\"(不区分大小写)或者已经定义好的 kGET 或 kPOST\n   @param strategy 缓存策略\n   @param URLString 请求地址\n   @param header 请求头,可为空\n   @param params 请求参数,可为空\n   @param filterBlock  拦截器\n   @param verifyBlock 验证参数\n   @param block 回调\n   @return 请求 Id\n   */\n  - (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params filter:(DKHTTPRequestFilterBlock)filterBlock verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock responseBlock:(DKHTTPResponseBlock)block;\n  ```\n\n  拦截器的 block\n  给你一个对象，你可以修改这个对象然后返回回去\n\n  ```\n  typedef DKRequest *(^DKHTTPRequestFilterBlock)(DKRequest *request);\n  ```\n\n  验证器的 block\n  给你参数，验证参数后你可以返回一个验证不通过的错误信息，也可以返回空表示验证通过\n\n  ```\n  typedef NSString *(^DKHTTPParamsVarifyBlock)(NSDictionary *params);\n  ```\n\n3. 关于验证参数\n\n\t如果只是想单纯地验证参数是否是全部不为空(这里指空字符串，并不是nil,因为nil根本插不进字典)，那这里也提供了一个宏可以快速实现。\n    ```\n    /** 验证参数是否全部不为空 有空值的话会返回错误 */\n    @property (nonatomic,copy) DKHTTPParamsVarifyBlock verifyIsAllNonNullBlock;\n    ```\n  \n4. 关于过滤（验证）响应体\n  过滤响应体主要是为了防止错误的数据传回到 Service层，比如一些JSON 串解析后会传回 NSNull之类的恶心东西，如果误当做字符串操作的话会导致程序崩溃。不过因为 MJExtension 框架里面已经做了之类的处理，所以如果使用了MJExtension 框架的话，一般来说是不会出现问题，所以这个过滤方法作为单例的成员属性加入,设计为全局作用！\n  传给你一个 DKResponse, 你可以经过处理之后返回一个想要的 DKResponse\n\n  ```\n  /** 过滤响应体 */\n  @property (nonatomic,copy) DKHTTPResultFilterBlock resultFilterBlock;\n  ```\n\n今天逼哥放我假，所以我就写了这个.就这样子,demo我还是放在这里\n\n","source":"_posts/网络层方法封装4.md","raw":"---\ntitle: 网络层方法封装4\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 6082784b\ndate: 2016-12-15 00:00:00\n---\n网络层方法封装4\n<!-- more -->\n\n- 新增特性:\n   - 拦截器和验证器\n   - 封装请求对象\n   \n1. 说明\n\n  拦截器顾名思义就是在请求发送之前拦截请求，拦截到的请求可以进行修改之后进行发送，或者阻止请求的发送。可以用于添加分页参数之类的需求。\n\n  验证器指的是验证参数（验证结果的方法后面再补充），验证参数主要用于判断输入参数的合法性，如果验证不通过则可以返回一个错误信息，由请求方法抛出错误，如果验证通过那就返回一个 nil就可以了。\n\n2. 代码\n\n  先说说请求对象模型\n\n  ```\n  @interface DKRequest : NSObject\n\n  /** 请求地址 */\n  @property (nonatomic,copy) NSString * urlStr;\n\n  /** 请求方法 */\n  @property (nonatomic,copy) NSString * method;\n\n  /** 请求参数 */\n  @property (nonatomic,strong) NSDictionary *params;\n\n  /** 请求头 */\n  @property (nonatomic,strong) NSDictionary *header;\n\n  /** 缓存策略 */\n  @property (nonatomic,assign) DKCacheStrategy cacheStrategy;\n\n  /** 请求回调 */\n  @property (nonatomic,copy) DKHTTPResponseBlock responseBlock;\n\n  + (instancetype)requestWithUrlStr:(NSString *)urlStr method:(NSString *)method header:(NSDictionary *)header params:(NSDictionary *)params strategy:(DKCacheStrategy)strategy;\n  @end\n  ```\n\n  完整的接口示例\n\n  ```\n  /**\n   发送HTTP请求\n\n   @param method 请求方法,你可以写@\"get\"或者@\"post\"(不区分大小写)或者已经定义好的 kGET 或 kPOST\n   @param strategy 缓存策略\n   @param URLString 请求地址\n   @param header 请求头,可为空\n   @param params 请求参数,可为空\n   @param filterBlock  拦截器\n   @param verifyBlock 验证参数\n   @param block 回调\n   @return 请求 Id\n   */\n  - (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params filter:(DKHTTPRequestFilterBlock)filterBlock verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock responseBlock:(DKHTTPResponseBlock)block;\n  ```\n\n  拦截器的 block\n  给你一个对象，你可以修改这个对象然后返回回去\n\n  ```\n  typedef DKRequest *(^DKHTTPRequestFilterBlock)(DKRequest *request);\n  ```\n\n  验证器的 block\n  给你参数，验证参数后你可以返回一个验证不通过的错误信息，也可以返回空表示验证通过\n\n  ```\n  typedef NSString *(^DKHTTPParamsVarifyBlock)(NSDictionary *params);\n  ```\n\n3. 关于验证参数\n\n\t如果只是想单纯地验证参数是否是全部不为空(这里指空字符串，并不是nil,因为nil根本插不进字典)，那这里也提供了一个宏可以快速实现。\n    ```\n    /** 验证参数是否全部不为空 有空值的话会返回错误 */\n    @property (nonatomic,copy) DKHTTPParamsVarifyBlock verifyIsAllNonNullBlock;\n    ```\n  \n4. 关于过滤（验证）响应体\n  过滤响应体主要是为了防止错误的数据传回到 Service层，比如一些JSON 串解析后会传回 NSNull之类的恶心东西，如果误当做字符串操作的话会导致程序崩溃。不过因为 MJExtension 框架里面已经做了之类的处理，所以如果使用了MJExtension 框架的话，一般来说是不会出现问题，所以这个过滤方法作为单例的成员属性加入,设计为全局作用！\n  传给你一个 DKResponse, 你可以经过处理之后返回一个想要的 DKResponse\n\n  ```\n  /** 过滤响应体 */\n  @property (nonatomic,copy) DKHTTPResultFilterBlock resultFilterBlock;\n  ```\n\n今天逼哥放我假，所以我就写了这个.就这样子,demo我还是放在这里\n\n","slug":"网络层方法封装4","published":1,"updated":"2021-06-06T18:52:24.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoj3007ptnn046j6hvdg","content":"<p>网络层方法封装4</p>\n<span id=\"more\"></span>\n\n<ul>\n<li>新增特性:<ul>\n<li>拦截器和验证器</li>\n<li>封装请求对象</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>说明</li>\n</ol>\n<p>  拦截器顾名思义就是在请求发送之前拦截请求，拦截到的请求可以进行修改之后进行发送，或者阻止请求的发送。可以用于添加分页参数之类的需求。</p>\n<p>  验证器指的是验证参数（验证结果的方法后面再补充），验证参数主要用于判断输入参数的合法性，如果验证不通过则可以返回一个错误信息，由请求方法抛出错误，如果验证通过那就返回一个 nil就可以了。</p>\n<ol start=\"2\">\n<li>代码</li>\n</ol>\n<p>  先说说请求对象模型</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface DKRequest : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求地址 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSString * urlStr;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求方法 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSString * method;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求参数 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,strong) NSDictionary *params;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求头 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,strong) NSDictionary *header;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 缓存策略 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,assign) DKCacheStrategy cacheStrategy;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求回调 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPResponseBlock responseBlock;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)requestWithUrlStr:(NSString *)urlStr method:(NSString *)method header:(NSDictionary *)header params:(NSDictionary *)params strategy:(DKCacheStrategy)strategy;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>  完整的接口示例</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> 发送HTTP请求</span><br><span class=\"line\"></span><br><span class=\"line\"> @param method 请求方法,你可以写@&quot;get&quot;或者@&quot;post&quot;(不区分大小写)或者已经定义好的 kGET 或 kPOST</span><br><span class=\"line\"> @param strategy 缓存策略</span><br><span class=\"line\"> @param URLString 请求地址</span><br><span class=\"line\"> @param header 请求头,可为空</span><br><span class=\"line\"> @param params 请求参数,可为空</span><br><span class=\"line\"> @param filterBlock  拦截器</span><br><span class=\"line\"> @param verifyBlock 验证参数</span><br><span class=\"line\"> @param block 回调</span><br><span class=\"line\"> @return 请求 Id</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params filter:(DKHTTPRequestFilterBlock)filterBlock verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n\n<p>  拦截器的 block<br>  给你一个对象，你可以修改这个对象然后返回回去</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef DKRequest *(^DKHTTPRequestFilterBlock)(DKRequest *request);</span><br></pre></td></tr></table></figure>\n\n<p>  验证器的 block<br>  给你参数，验证参数后你可以返回一个验证不通过的错误信息，也可以返回空表示验证通过</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NSString *(^DKHTTPParamsVarifyBlock)(NSDictionary *params);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>关于验证参数</p>\n<p> 如果只是想单纯地验证参数是否是全部不为空(这里指空字符串，并不是nil,因为nil根本插不进字典)，那这里也提供了一个宏可以快速实现。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 验证参数是否全部不为空 有空值的话会返回错误 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPParamsVarifyBlock verifyIsAllNonNullBlock;</span><br></pre></td></tr></table></figure></li>\n<li><p>关于过滤（验证）响应体<br>过滤响应体主要是为了防止错误的数据传回到 Service层，比如一些JSON 串解析后会传回 NSNull之类的恶心东西，如果误当做字符串操作的话会导致程序崩溃。不过因为 MJExtension 框架里面已经做了之类的处理，所以如果使用了MJExtension 框架的话，一般来说是不会出现问题，所以这个过滤方法作为单例的成员属性加入,设计为全局作用！<br>传给你一个 DKResponse, 你可以经过处理之后返回一个想要的 DKResponse</p>\n</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 过滤响应体 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPResultFilterBlock resultFilterBlock;</span><br></pre></td></tr></table></figure>\n\n<p>今天逼哥放我假，所以我就写了这个.就这样子,demo我还是放在这里</p>\n","site":{"data":{}},"excerpt":"<p>网络层方法封装4</p>","more":"<ul>\n<li>新增特性:<ul>\n<li>拦截器和验证器</li>\n<li>封装请求对象</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>说明</li>\n</ol>\n<p>  拦截器顾名思义就是在请求发送之前拦截请求，拦截到的请求可以进行修改之后进行发送，或者阻止请求的发送。可以用于添加分页参数之类的需求。</p>\n<p>  验证器指的是验证参数（验证结果的方法后面再补充），验证参数主要用于判断输入参数的合法性，如果验证不通过则可以返回一个错误信息，由请求方法抛出错误，如果验证通过那就返回一个 nil就可以了。</p>\n<ol start=\"2\">\n<li>代码</li>\n</ol>\n<p>  先说说请求对象模型</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface DKRequest : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求地址 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSString * urlStr;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求方法 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSString * method;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求参数 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,strong) NSDictionary *params;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求头 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,strong) NSDictionary *header;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 缓存策略 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,assign) DKCacheStrategy cacheStrategy;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求回调 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPResponseBlock responseBlock;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)requestWithUrlStr:(NSString *)urlStr method:(NSString *)method header:(NSDictionary *)header params:(NSDictionary *)params strategy:(DKCacheStrategy)strategy;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>  完整的接口示例</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> 发送HTTP请求</span><br><span class=\"line\"></span><br><span class=\"line\"> @param method 请求方法,你可以写@&quot;get&quot;或者@&quot;post&quot;(不区分大小写)或者已经定义好的 kGET 或 kPOST</span><br><span class=\"line\"> @param strategy 缓存策略</span><br><span class=\"line\"> @param URLString 请求地址</span><br><span class=\"line\"> @param header 请求头,可为空</span><br><span class=\"line\"> @param params 请求参数,可为空</span><br><span class=\"line\"> @param filterBlock  拦截器</span><br><span class=\"line\"> @param verifyBlock 验证参数</span><br><span class=\"line\"> @param block 回调</span><br><span class=\"line\"> @return 请求 Id</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params filter:(DKHTTPRequestFilterBlock)filterBlock verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n\n<p>  拦截器的 block<br>  给你一个对象，你可以修改这个对象然后返回回去</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef DKRequest *(^DKHTTPRequestFilterBlock)(DKRequest *request);</span><br></pre></td></tr></table></figure>\n\n<p>  验证器的 block<br>  给你参数，验证参数后你可以返回一个验证不通过的错误信息，也可以返回空表示验证通过</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NSString *(^DKHTTPParamsVarifyBlock)(NSDictionary *params);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>关于验证参数</p>\n<p> 如果只是想单纯地验证参数是否是全部不为空(这里指空字符串，并不是nil,因为nil根本插不进字典)，那这里也提供了一个宏可以快速实现。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 验证参数是否全部不为空 有空值的话会返回错误 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPParamsVarifyBlock verifyIsAllNonNullBlock;</span><br></pre></td></tr></table></figure></li>\n<li><p>关于过滤（验证）响应体<br>过滤响应体主要是为了防止错误的数据传回到 Service层，比如一些JSON 串解析后会传回 NSNull之类的恶心东西，如果误当做字符串操作的话会导致程序崩溃。不过因为 MJExtension 框架里面已经做了之类的处理，所以如果使用了MJExtension 框架的话，一般来说是不会出现问题，所以这个过滤方法作为单例的成员属性加入,设计为全局作用！<br>传给你一个 DKResponse, 你可以经过处理之后返回一个想要的 DKResponse</p>\n</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 过滤响应体 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPResultFilterBlock resultFilterBlock;</span><br></pre></td></tr></table></figure>\n\n<p>今天逼哥放我假，所以我就写了这个.就这样子,demo我还是放在这里</p>"},{"title":"解决git status中文问题","author":"Arclin","abbrlink":"93da1b70","date":"2017-08-07T16:00:00.000Z","_content":"在中文情况下`git status`是 `\\344\\272\\247\\345\\223\\201\\351\\234\\200\\346\\261\\202` 差不多这样的。\n\n解决这个问题方法是：\n\n`git config --global core.quotepath false`","source":"_posts/解决git-status中文问题.md","raw":"---\ntitle: 解决git status中文问题\nauthor: Arclin\ntags:\n  - 技巧\n  - Git\ncategories:\n  - Git\nabbrlink: 93da1b70\ndate: 2017-08-08 00:00:00\n---\n在中文情况下`git status`是 `\\344\\272\\247\\345\\223\\201\\351\\234\\200\\346\\261\\202` 差不多这样的。\n\n解决这个问题方法是：\n\n`git config --global core.quotepath false`","slug":"解决git-status中文问题","published":1,"updated":"2021-06-06T18:52:24.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoj6007ttnn0hqkncvze","content":"<p>在中文情况下<code>git status</code>是 <code>\\344\\272\\247\\345\\223\\201\\351\\234\\200\\346\\261\\202</code> 差不多这样的。</p>\n<p>解决这个问题方法是：</p>\n<p><code>git config --global core.quotepath false</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在中文情况下<code>git status</code>是 <code>\\344\\272\\247\\345\\223\\201\\351\\234\\200\\346\\261\\202</code> 差不多这样的。</p>\n<p>解决这个问题方法是：</p>\n<p><code>git config --global core.quotepath false</code></p>\n"},{"title":"记录一些关于iOS的一些小技巧","author":"Arclin","abbrlink":"1b8f24c7","date":"2016-06-11T16:30:00.000Z","_content":"记录一些关于iOS的一些小技巧\n\n<!-- more -->\n\nXCode Profile 的路径\nxcode5 provisioning profile path： \n`~/Library/MobileDevice/Provisioning Profiles`\n\n在升级XCode7.0使用UICollectionViewLayout进行自定义布局时，调试台会出现以下的警告打印。\n\n```\nUICollectionViewFlowLayout has cached frame mismatch for index path {length = 2, path = 0 - 0} - cached value: {{122, 15}, {170, 170}}; expected value: {{157, 50}, {100, 100}} \nThis is likely occurring because the flow layout subclass LineLayout is modifying attributes returned by UICollectionViewFlowLayout without copying them\n```\n\n这个警告来源主要是在使用layoutAttributesForElementsInRect：方法返回的数组时，没有使用该数组的拷贝对象，而是直接使用了该数组。解决办法对该数组进行拷贝，并且是深拷贝。拷贝代码如下：\n\n```\n- (NSArray *)deepCopyWithArray:(NSArray *)array\n{\n    NSMutableArray *copys = [NSMutableArray arrayWithCapacity:array.count];\n\n    for (UICollectionViewLayoutAttributes *attris in array) {\n        [copys addObject:[attris copy]];\n    }\n    return copys;\n}\n```\n\n将layoutAttributesForElementsInRect：方法返回的数组扔到这个方法中，并且使用返回后的数组就行了。\n\n- 在navigationController中插入ScrollView后，scrollView的ContentInset的值发生了变化\n\n\t- 解决： self.automaticallyAdjustsScrollViewInsets = NO;\n\t- 原因： self.automaticallyAdjustsScrollViewInsets 默认值是YES，选择YES表示你允许视图控制器调整它内部插入的滑动视图来应对状态栏，导航栏，工具栏，和标签栏所消耗的屏幕区域。如果你设置为NO呢，就代表呀你要自己调整你插入的滑动视图，比如你的视图层次里面有多于一个的滑动视图。\n这大概是个什么意思呢，就是你的视图控制器在没经你允许的情况下调整你的控件位置了","source":"_posts/记录一些关于iOS的一些小技巧.md","raw":"---\ntitle: 记录一些关于iOS的一些小技巧\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 1b8f24c7\ndate: 2016-06-12 00:30:00\n---\n记录一些关于iOS的一些小技巧\n\n<!-- more -->\n\nXCode Profile 的路径\nxcode5 provisioning profile path： \n`~/Library/MobileDevice/Provisioning Profiles`\n\n在升级XCode7.0使用UICollectionViewLayout进行自定义布局时，调试台会出现以下的警告打印。\n\n```\nUICollectionViewFlowLayout has cached frame mismatch for index path {length = 2, path = 0 - 0} - cached value: {{122, 15}, {170, 170}}; expected value: {{157, 50}, {100, 100}} \nThis is likely occurring because the flow layout subclass LineLayout is modifying attributes returned by UICollectionViewFlowLayout without copying them\n```\n\n这个警告来源主要是在使用layoutAttributesForElementsInRect：方法返回的数组时，没有使用该数组的拷贝对象，而是直接使用了该数组。解决办法对该数组进行拷贝，并且是深拷贝。拷贝代码如下：\n\n```\n- (NSArray *)deepCopyWithArray:(NSArray *)array\n{\n    NSMutableArray *copys = [NSMutableArray arrayWithCapacity:array.count];\n\n    for (UICollectionViewLayoutAttributes *attris in array) {\n        [copys addObject:[attris copy]];\n    }\n    return copys;\n}\n```\n\n将layoutAttributesForElementsInRect：方法返回的数组扔到这个方法中，并且使用返回后的数组就行了。\n\n- 在navigationController中插入ScrollView后，scrollView的ContentInset的值发生了变化\n\n\t- 解决： self.automaticallyAdjustsScrollViewInsets = NO;\n\t- 原因： self.automaticallyAdjustsScrollViewInsets 默认值是YES，选择YES表示你允许视图控制器调整它内部插入的滑动视图来应对状态栏，导航栏，工具栏，和标签栏所消耗的屏幕区域。如果你设置为NO呢，就代表呀你要自己调整你插入的滑动视图，比如你的视图层次里面有多于一个的滑动视图。\n这大概是个什么意思呢，就是你的视图控制器在没经你允许的情况下调整你的控件位置了","slug":"记录一些关于iOS的一些小技巧","published":1,"updated":"2021-06-06T18:52:24.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyoja007wtnn0ccv7g11t","content":"<p>记录一些关于iOS的一些小技巧</p>\n<span id=\"more\"></span>\n\n<p>XCode Profile 的路径<br>xcode5 provisioning profile path：<br><code>~/Library/MobileDevice/Provisioning Profiles</code></p>\n<p>在升级XCode7.0使用UICollectionViewLayout进行自定义布局时，调试台会出现以下的警告打印。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UICollectionViewFlowLayout has cached frame mismatch for index path &#123;length &#x3D; 2, path &#x3D; 0 - 0&#125; - cached value: &#123;&#123;122, 15&#125;, &#123;170, 170&#125;&#125;; expected value: &#123;&#123;157, 50&#125;, &#123;100, 100&#125;&#125; </span><br><span class=\"line\">This is likely occurring because the flow layout subclass LineLayout is modifying attributes returned by UICollectionViewFlowLayout without copying them</span><br></pre></td></tr></table></figure>\n\n<p>这个警告来源主要是在使用layoutAttributesForElementsInRect：方法返回的数组时，没有使用该数组的拷贝对象，而是直接使用了该数组。解决办法对该数组进行拷贝，并且是深拷贝。拷贝代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)deepCopyWithArray:(NSArray *)array</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSMutableArray *copys &#x3D; [NSMutableArray arrayWithCapacity:array.count];</span><br><span class=\"line\"></span><br><span class=\"line\">    for (UICollectionViewLayoutAttributes *attris in array) &#123;</span><br><span class=\"line\">        [copys addObject:[attris copy]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return copys;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将layoutAttributesForElementsInRect：方法返回的数组扔到这个方法中，并且使用返回后的数组就行了。</p>\n<ul>\n<li><p>在navigationController中插入ScrollView后，scrollView的ContentInset的值发生了变化</p>\n<ul>\n<li>解决： self.automaticallyAdjustsScrollViewInsets = NO;</li>\n<li>原因： self.automaticallyAdjustsScrollViewInsets 默认值是YES，选择YES表示你允许视图控制器调整它内部插入的滑动视图来应对状态栏，导航栏，工具栏，和标签栏所消耗的屏幕区域。如果你设置为NO呢，就代表呀你要自己调整你插入的滑动视图，比如你的视图层次里面有多于一个的滑动视图。<br>这大概是个什么意思呢，就是你的视图控制器在没经你允许的情况下调整你的控件位置了</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>记录一些关于iOS的一些小技巧</p>","more":"<p>XCode Profile 的路径<br>xcode5 provisioning profile path：<br><code>~/Library/MobileDevice/Provisioning Profiles</code></p>\n<p>在升级XCode7.0使用UICollectionViewLayout进行自定义布局时，调试台会出现以下的警告打印。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UICollectionViewFlowLayout has cached frame mismatch for index path &#123;length &#x3D; 2, path &#x3D; 0 - 0&#125; - cached value: &#123;&#123;122, 15&#125;, &#123;170, 170&#125;&#125;; expected value: &#123;&#123;157, 50&#125;, &#123;100, 100&#125;&#125; </span><br><span class=\"line\">This is likely occurring because the flow layout subclass LineLayout is modifying attributes returned by UICollectionViewFlowLayout without copying them</span><br></pre></td></tr></table></figure>\n\n<p>这个警告来源主要是在使用layoutAttributesForElementsInRect：方法返回的数组时，没有使用该数组的拷贝对象，而是直接使用了该数组。解决办法对该数组进行拷贝，并且是深拷贝。拷贝代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)deepCopyWithArray:(NSArray *)array</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSMutableArray *copys &#x3D; [NSMutableArray arrayWithCapacity:array.count];</span><br><span class=\"line\"></span><br><span class=\"line\">    for (UICollectionViewLayoutAttributes *attris in array) &#123;</span><br><span class=\"line\">        [copys addObject:[attris copy]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return copys;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将layoutAttributesForElementsInRect：方法返回的数组扔到这个方法中，并且使用返回后的数组就行了。</p>\n<ul>\n<li><p>在navigationController中插入ScrollView后，scrollView的ContentInset的值发生了变化</p>\n<ul>\n<li>解决： self.automaticallyAdjustsScrollViewInsets = NO;</li>\n<li>原因： self.automaticallyAdjustsScrollViewInsets 默认值是YES，选择YES表示你允许视图控制器调整它内部插入的滑动视图来应对状态栏，导航栏，工具栏，和标签栏所消耗的屏幕区域。如果你设置为NO呢，就代表呀你要自己调整你插入的滑动视图，比如你的视图层次里面有多于一个的滑动视图。<br>这大概是个什么意思呢，就是你的视图控制器在没经你允许的情况下调整你的控件位置了</li>\n</ul>\n</li>\n</ul>"},{"layout":"application","title":"Application Loader / Fastlane pilot 通过代理上传方案","date":"2018-08-03T08:10:07.000Z","_content":"\n## Application Loader / Fastlane pilot 通过代理上传方案\n\n### 需求分析\n\n为了避免苹果审核马甲包情况, 我们需要通过其他IP去上传包, 这里提供几种方案并记录踩坑过程.\n\n<!-- more -->\n\n### 问题解决思路\n\n1. 用Application Loader(后面简称uploader)上传包, 电脑使用SS, VPN会导致上传失败, 原因是uploader内部自带开启代理配置, 但是默认是关闭的,  所以需要修改内部代理配置, 路径是`/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/java/lib/net.properties`, 配置如下(1086是本地ss的端口)\n\t\n\t```\n\tjava.net.useSystemProxies=true\n\thttp.proxyHost=127.0.0.1\n\thttp.proxyPort=1086\n\thttps.proxyHost=127.0.0.1\n\thttps.proxyPort=1086\n\tjdk.http.auth.tunneling.disabledSchemes=Basic\n\t```\n\t\n2. 本来`net.properties`内是有socks代理的配置的, Shadowsocks开启socks代理后, 在配置文件中配置好ip(127.0.0.1)和端口(1086)之后测试发现无法连接到苹果服务器, 故只能选用`http/https`代理\n\t> 查询shadowsocks本地端口的方法, 执行`lsof -iTCP -sTCP:LISTEN -n -P | grep ss-local`, 就可以查到\n\t\n3. 现在问题在于怎么将socks代理转成http/https代理, 通过查阅资料得知可以通过安装`privoxy`解决, 安装之后配置`/usr/local/etc/privoxy/config`文件, 把`forward-socks5t`那行注释掉, 加上本地socks ip和端口, 就像下面那段一样, 然后把`listen-address  127.0.0.1:8118` 改成 `listen-address  0.0.0.0:8118`就可以实现给局域网内共享你的代理.\n\n\t```\n\tforward           /               127.0.0.1:1086 .\n\tforward-socks4    /               127.0.0.1:1086 .\n\tforward-socks4a   /               127.0.0.1:1086 .\n\tforward-socks5    /               127.0.0.1:1086 .\n\tforward-socks5t   /               127.0.0.1:1086 .\n\t```\n\t\n4. 打开`系统偏好设置-网络-高级-代理`, 把网页代理和安全网页代理勾上, 填上ip `127.0.0.1` 端口 `8118` , 就可以了.  这里的`8118`是刚刚说到的`listen-address  0.0.0.0:8118`里面的端口号, 要改也可以改, 记得同步就行.\n\n### 校验\n\n1. 校验`privoxy`是否代理成功可以通过浏览器访问`http://config.privoxy.org/`这个网址就能看到成功与否了\n\n2. 执行`netstat -an | grep 8118` 查看`8188`是否全局监听着, 如果是就会看到\n\t`tcp4       0      0  *.8118                 *.*                    LISTEN  `执行`ps aux | grep privoxy`, 则可以看到`privoxy`进程是否正在运行中. 可以通过`sudo /Applications/Privoxy/stopPrivoxy.sh`停止`privoxy`和`sudo /Applications/Privoxy/startPrivoxy.sh`启动`privoxy`\n\t\n3. 浏览器访问`https://ip.cn`,就可以得知网页代理是否成功了\n\t\n4. fastlane上传包实际上是调用了`/Applications/Xcode.app/Contents/Applications/Application\\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool`, 也就是Xcode自带的命令行工具 , uploader就不用说了, 反正殊途同归, 最后都会根据`net.properties`去走代理,  那么问题来了 , 如何验证命令行和桌面应用uploader走的都是代理方式呢. 很遗憾苹果并不会弄出一个界面或者打印出一行log告诉你现在是用哪个ip上传, 我现在能想到的办法是通过工具查看上传过程中的流量波动, 通过实验, 两种方式再上传过程中, `ss-local`进程有过较大数据上传的流量波动(会有100k/s以上的上传流量速度), 因此我判定确实是走了代理上传包的.  如果要再证据确凿的话, 只能想办法抓包查看他的信息收集了, 但是`Charles`抓包的原理是再开一个代理, 会造成混乱....所以这就很头疼了.\n\n5. 开启了网页代理之后, 影响的只是网页, 实际上只是为了验证`Privoxy`的可用性, 开启之后你如果在命令行中使用`curl ip.cn`得到的结果会是你真实网络的出网ip, 而不是你想要的代理的ip, 实际上`uploader`和`fastlane pilot`命令行是否真正走了代理, 目前我只能通过`ss-local`这个代理的进程查看他的上传流量去判断, 具有一定风险. 或者通过安装命令行工具`proxychains`, 然后执行`proxychains4 fastlane pilot upload`传包, 但是这种方式100%上传失败 , 原因猜想是`net.properties`的配置没改, `proxychains`怎么转发请求都没用.  所以这是不是从某种意义上证明了`fastlane pilot`是走`net.properties`配置的呢, 至少我觉得按照目前情况可以这么认为,  后续如果有想法我会进行更多实验去证明的.","source":"_posts/通过代理上传方案.md","raw":"---\nlayout: application\ntitle:  Application Loader / Fastlane pilot 通过代理上传方案\ndate: 2018-08-03 16:10:07\ntags: iOS\n---\n\n## Application Loader / Fastlane pilot 通过代理上传方案\n\n### 需求分析\n\n为了避免苹果审核马甲包情况, 我们需要通过其他IP去上传包, 这里提供几种方案并记录踩坑过程.\n\n<!-- more -->\n\n### 问题解决思路\n\n1. 用Application Loader(后面简称uploader)上传包, 电脑使用SS, VPN会导致上传失败, 原因是uploader内部自带开启代理配置, 但是默认是关闭的,  所以需要修改内部代理配置, 路径是`/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/java/lib/net.properties`, 配置如下(1086是本地ss的端口)\n\t\n\t```\n\tjava.net.useSystemProxies=true\n\thttp.proxyHost=127.0.0.1\n\thttp.proxyPort=1086\n\thttps.proxyHost=127.0.0.1\n\thttps.proxyPort=1086\n\tjdk.http.auth.tunneling.disabledSchemes=Basic\n\t```\n\t\n2. 本来`net.properties`内是有socks代理的配置的, Shadowsocks开启socks代理后, 在配置文件中配置好ip(127.0.0.1)和端口(1086)之后测试发现无法连接到苹果服务器, 故只能选用`http/https`代理\n\t> 查询shadowsocks本地端口的方法, 执行`lsof -iTCP -sTCP:LISTEN -n -P | grep ss-local`, 就可以查到\n\t\n3. 现在问题在于怎么将socks代理转成http/https代理, 通过查阅资料得知可以通过安装`privoxy`解决, 安装之后配置`/usr/local/etc/privoxy/config`文件, 把`forward-socks5t`那行注释掉, 加上本地socks ip和端口, 就像下面那段一样, 然后把`listen-address  127.0.0.1:8118` 改成 `listen-address  0.0.0.0:8118`就可以实现给局域网内共享你的代理.\n\n\t```\n\tforward           /               127.0.0.1:1086 .\n\tforward-socks4    /               127.0.0.1:1086 .\n\tforward-socks4a   /               127.0.0.1:1086 .\n\tforward-socks5    /               127.0.0.1:1086 .\n\tforward-socks5t   /               127.0.0.1:1086 .\n\t```\n\t\n4. 打开`系统偏好设置-网络-高级-代理`, 把网页代理和安全网页代理勾上, 填上ip `127.0.0.1` 端口 `8118` , 就可以了.  这里的`8118`是刚刚说到的`listen-address  0.0.0.0:8118`里面的端口号, 要改也可以改, 记得同步就行.\n\n### 校验\n\n1. 校验`privoxy`是否代理成功可以通过浏览器访问`http://config.privoxy.org/`这个网址就能看到成功与否了\n\n2. 执行`netstat -an | grep 8118` 查看`8188`是否全局监听着, 如果是就会看到\n\t`tcp4       0      0  *.8118                 *.*                    LISTEN  `执行`ps aux | grep privoxy`, 则可以看到`privoxy`进程是否正在运行中. 可以通过`sudo /Applications/Privoxy/stopPrivoxy.sh`停止`privoxy`和`sudo /Applications/Privoxy/startPrivoxy.sh`启动`privoxy`\n\t\n3. 浏览器访问`https://ip.cn`,就可以得知网页代理是否成功了\n\t\n4. fastlane上传包实际上是调用了`/Applications/Xcode.app/Contents/Applications/Application\\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool`, 也就是Xcode自带的命令行工具 , uploader就不用说了, 反正殊途同归, 最后都会根据`net.properties`去走代理,  那么问题来了 , 如何验证命令行和桌面应用uploader走的都是代理方式呢. 很遗憾苹果并不会弄出一个界面或者打印出一行log告诉你现在是用哪个ip上传, 我现在能想到的办法是通过工具查看上传过程中的流量波动, 通过实验, 两种方式再上传过程中, `ss-local`进程有过较大数据上传的流量波动(会有100k/s以上的上传流量速度), 因此我判定确实是走了代理上传包的.  如果要再证据确凿的话, 只能想办法抓包查看他的信息收集了, 但是`Charles`抓包的原理是再开一个代理, 会造成混乱....所以这就很头疼了.\n\n5. 开启了网页代理之后, 影响的只是网页, 实际上只是为了验证`Privoxy`的可用性, 开启之后你如果在命令行中使用`curl ip.cn`得到的结果会是你真实网络的出网ip, 而不是你想要的代理的ip, 实际上`uploader`和`fastlane pilot`命令行是否真正走了代理, 目前我只能通过`ss-local`这个代理的进程查看他的上传流量去判断, 具有一定风险. 或者通过安装命令行工具`proxychains`, 然后执行`proxychains4 fastlane pilot upload`传包, 但是这种方式100%上传失败 , 原因猜想是`net.properties`的配置没改, `proxychains`怎么转发请求都没用.  所以这是不是从某种意义上证明了`fastlane pilot`是走`net.properties`配置的呢, 至少我觉得按照目前情况可以这么认为,  后续如果有想法我会进行更多实验去证明的.","slug":"通过代理上传方案","published":1,"updated":"2021-06-06T18:52:24.974Z","comments":1,"photos":[],"link":"","_id":"ckqqxyojg0081tnn0bxxt93zl","content":"<h2 id=\"Application-Loader-Fastlane-pilot-通过代理上传方案\"><a href=\"#Application-Loader-Fastlane-pilot-通过代理上传方案\" class=\"headerlink\" title=\"Application Loader / Fastlane pilot 通过代理上传方案\"></a>Application Loader / Fastlane pilot 通过代理上传方案</h2><h3 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h3><p>为了避免苹果审核马甲包情况, 我们需要通过其他IP去上传包, 这里提供几种方案并记录踩坑过程.</p>\n<span id=\"more\"></span>\n\n<h3 id=\"问题解决思路\"><a href=\"#问题解决思路\" class=\"headerlink\" title=\"问题解决思路\"></a>问题解决思路</h3><ol>\n<li><p>用Application Loader(后面简称uploader)上传包, 电脑使用SS, VPN会导致上传失败, 原因是uploader内部自带开启代理配置, 但是默认是关闭的,  所以需要修改内部代理配置, 路径是<code>/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/java/lib/net.properties</code>, 配置如下(1086是本地ss的端口)</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.net.useSystemProxies&#x3D;true</span><br><span class=\"line\">http.proxyHost&#x3D;127.0.0.1</span><br><span class=\"line\">http.proxyPort&#x3D;1086</span><br><span class=\"line\">https.proxyHost&#x3D;127.0.0.1</span><br><span class=\"line\">https.proxyPort&#x3D;1086</span><br><span class=\"line\">jdk.http.auth.tunneling.disabledSchemes&#x3D;Basic</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本来<code>net.properties</code>内是有socks代理的配置的, Shadowsocks开启socks代理后, 在配置文件中配置好ip(127.0.0.1)和端口(1086)之后测试发现无法连接到苹果服务器, 故只能选用<code>http/https</code>代理</p>\n<blockquote>\n<p>查询shadowsocks本地端口的方法, 执行<code>lsof -iTCP -sTCP:LISTEN -n -P | grep ss-local</code>, 就可以查到</p>\n</blockquote>\n</li>\n<li><p>现在问题在于怎么将socks代理转成http/https代理, 通过查阅资料得知可以通过安装<code>privoxy</code>解决, 安装之后配置<code>/usr/local/etc/privoxy/config</code>文件, 把<code>forward-socks5t</code>那行注释掉, 加上本地socks ip和端口, 就像下面那段一样, 然后把<code>listen-address  127.0.0.1:8118</code> 改成 <code>listen-address  0.0.0.0:8118</code>就可以实现给局域网内共享你的代理.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">forward           &#x2F;               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks4    &#x2F;               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks4a   &#x2F;               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks5    &#x2F;               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks5t   &#x2F;               127.0.0.1:1086 .</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打开<code>系统偏好设置-网络-高级-代理</code>, 把网页代理和安全网页代理勾上, 填上ip <code>127.0.0.1</code> 端口 <code>8118</code> , 就可以了.  这里的<code>8118</code>是刚刚说到的<code>listen-address  0.0.0.0:8118</code>里面的端口号, 要改也可以改, 记得同步就行.</p>\n</li>\n</ol>\n<h3 id=\"校验\"><a href=\"#校验\" class=\"headerlink\" title=\"校验\"></a>校验</h3><ol>\n<li><p>校验<code>privoxy</code>是否代理成功可以通过浏览器访问<code>http://config.privoxy.org/</code>这个网址就能看到成功与否了</p>\n</li>\n<li><p>执行<code>netstat -an | grep 8118</code> 查看<code>8188</code>是否全局监听着, 如果是就会看到<br> <code>tcp4       0      0  *.8118                 *.*                    LISTEN  </code>执行<code>ps aux | grep privoxy</code>, 则可以看到<code>privoxy</code>进程是否正在运行中. 可以通过<code>sudo /Applications/Privoxy/stopPrivoxy.sh</code>停止<code>privoxy</code>和<code>sudo /Applications/Privoxy/startPrivoxy.sh</code>启动<code>privoxy</code></p>\n</li>\n<li><p>浏览器访问<code>https://ip.cn</code>,就可以得知网页代理是否成功了</p>\n</li>\n<li><p>fastlane上传包实际上是调用了<code>/Applications/Xcode.app/Contents/Applications/Application\\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool</code>, 也就是Xcode自带的命令行工具 , uploader就不用说了, 反正殊途同归, 最后都会根据<code>net.properties</code>去走代理,  那么问题来了 , 如何验证命令行和桌面应用uploader走的都是代理方式呢. 很遗憾苹果并不会弄出一个界面或者打印出一行log告诉你现在是用哪个ip上传, 我现在能想到的办法是通过工具查看上传过程中的流量波动, 通过实验, 两种方式再上传过程中, <code>ss-local</code>进程有过较大数据上传的流量波动(会有100k/s以上的上传流量速度), 因此我判定确实是走了代理上传包的.  如果要再证据确凿的话, 只能想办法抓包查看他的信息收集了, 但是<code>Charles</code>抓包的原理是再开一个代理, 会造成混乱….所以这就很头疼了.</p>\n</li>\n<li><p>开启了网页代理之后, 影响的只是网页, 实际上只是为了验证<code>Privoxy</code>的可用性, 开启之后你如果在命令行中使用<code>curl ip.cn</code>得到的结果会是你真实网络的出网ip, 而不是你想要的代理的ip, 实际上<code>uploader</code>和<code>fastlane pilot</code>命令行是否真正走了代理, 目前我只能通过<code>ss-local</code>这个代理的进程查看他的上传流量去判断, 具有一定风险. 或者通过安装命令行工具<code>proxychains</code>, 然后执行<code>proxychains4 fastlane pilot upload</code>传包, 但是这种方式100%上传失败 , 原因猜想是<code>net.properties</code>的配置没改, <code>proxychains</code>怎么转发请求都没用.  所以这是不是从某种意义上证明了<code>fastlane pilot</code>是走<code>net.properties</code>配置的呢, 至少我觉得按照目前情况可以这么认为,  后续如果有想法我会进行更多实验去证明的.</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"Application-Loader-Fastlane-pilot-通过代理上传方案\"><a href=\"#Application-Loader-Fastlane-pilot-通过代理上传方案\" class=\"headerlink\" title=\"Application Loader / Fastlane pilot 通过代理上传方案\"></a>Application Loader / Fastlane pilot 通过代理上传方案</h2><h3 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h3><p>为了避免苹果审核马甲包情况, 我们需要通过其他IP去上传包, 这里提供几种方案并记录踩坑过程.</p>","more":"<h3 id=\"问题解决思路\"><a href=\"#问题解决思路\" class=\"headerlink\" title=\"问题解决思路\"></a>问题解决思路</h3><ol>\n<li><p>用Application Loader(后面简称uploader)上传包, 电脑使用SS, VPN会导致上传失败, 原因是uploader内部自带开启代理配置, 但是默认是关闭的,  所以需要修改内部代理配置, 路径是<code>/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/java/lib/net.properties</code>, 配置如下(1086是本地ss的端口)</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.net.useSystemProxies&#x3D;true</span><br><span class=\"line\">http.proxyHost&#x3D;127.0.0.1</span><br><span class=\"line\">http.proxyPort&#x3D;1086</span><br><span class=\"line\">https.proxyHost&#x3D;127.0.0.1</span><br><span class=\"line\">https.proxyPort&#x3D;1086</span><br><span class=\"line\">jdk.http.auth.tunneling.disabledSchemes&#x3D;Basic</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本来<code>net.properties</code>内是有socks代理的配置的, Shadowsocks开启socks代理后, 在配置文件中配置好ip(127.0.0.1)和端口(1086)之后测试发现无法连接到苹果服务器, 故只能选用<code>http/https</code>代理</p>\n<blockquote>\n<p>查询shadowsocks本地端口的方法, 执行<code>lsof -iTCP -sTCP:LISTEN -n -P | grep ss-local</code>, 就可以查到</p>\n</blockquote>\n</li>\n<li><p>现在问题在于怎么将socks代理转成http/https代理, 通过查阅资料得知可以通过安装<code>privoxy</code>解决, 安装之后配置<code>/usr/local/etc/privoxy/config</code>文件, 把<code>forward-socks5t</code>那行注释掉, 加上本地socks ip和端口, 就像下面那段一样, 然后把<code>listen-address  127.0.0.1:8118</code> 改成 <code>listen-address  0.0.0.0:8118</code>就可以实现给局域网内共享你的代理.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">forward           &#x2F;               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks4    &#x2F;               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks4a   &#x2F;               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks5    &#x2F;               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks5t   &#x2F;               127.0.0.1:1086 .</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打开<code>系统偏好设置-网络-高级-代理</code>, 把网页代理和安全网页代理勾上, 填上ip <code>127.0.0.1</code> 端口 <code>8118</code> , 就可以了.  这里的<code>8118</code>是刚刚说到的<code>listen-address  0.0.0.0:8118</code>里面的端口号, 要改也可以改, 记得同步就行.</p>\n</li>\n</ol>\n<h3 id=\"校验\"><a href=\"#校验\" class=\"headerlink\" title=\"校验\"></a>校验</h3><ol>\n<li><p>校验<code>privoxy</code>是否代理成功可以通过浏览器访问<code>http://config.privoxy.org/</code>这个网址就能看到成功与否了</p>\n</li>\n<li><p>执行<code>netstat -an | grep 8118</code> 查看<code>8188</code>是否全局监听着, 如果是就会看到<br> <code>tcp4       0      0  *.8118                 *.*                    LISTEN  </code>执行<code>ps aux | grep privoxy</code>, 则可以看到<code>privoxy</code>进程是否正在运行中. 可以通过<code>sudo /Applications/Privoxy/stopPrivoxy.sh</code>停止<code>privoxy</code>和<code>sudo /Applications/Privoxy/startPrivoxy.sh</code>启动<code>privoxy</code></p>\n</li>\n<li><p>浏览器访问<code>https://ip.cn</code>,就可以得知网页代理是否成功了</p>\n</li>\n<li><p>fastlane上传包实际上是调用了<code>/Applications/Xcode.app/Contents/Applications/Application\\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool</code>, 也就是Xcode自带的命令行工具 , uploader就不用说了, 反正殊途同归, 最后都会根据<code>net.properties</code>去走代理,  那么问题来了 , 如何验证命令行和桌面应用uploader走的都是代理方式呢. 很遗憾苹果并不会弄出一个界面或者打印出一行log告诉你现在是用哪个ip上传, 我现在能想到的办法是通过工具查看上传过程中的流量波动, 通过实验, 两种方式再上传过程中, <code>ss-local</code>进程有过较大数据上传的流量波动(会有100k/s以上的上传流量速度), 因此我判定确实是走了代理上传包的.  如果要再证据确凿的话, 只能想办法抓包查看他的信息收集了, 但是<code>Charles</code>抓包的原理是再开一个代理, 会造成混乱….所以这就很头疼了.</p>\n</li>\n<li><p>开启了网页代理之后, 影响的只是网页, 实际上只是为了验证<code>Privoxy</code>的可用性, 开启之后你如果在命令行中使用<code>curl ip.cn</code>得到的结果会是你真实网络的出网ip, 而不是你想要的代理的ip, 实际上<code>uploader</code>和<code>fastlane pilot</code>命令行是否真正走了代理, 目前我只能通过<code>ss-local</code>这个代理的进程查看他的上传流量去判断, 具有一定风险. 或者通过安装命令行工具<code>proxychains</code>, 然后执行<code>proxychains4 fastlane pilot upload</code>传包, 但是这种方式100%上传失败 , 原因猜想是<code>net.properties</code>的配置没改, <code>proxychains</code>怎么转发请求都没用.  所以这是不是从某种意义上证明了<code>fastlane pilot</code>是走<code>net.properties</code>配置的呢, 至少我觉得按照目前情况可以这么认为,  后续如果有想法我会进行更多实验去证明的.</p>\n</li>\n</ol>"},{"title":"项目里面的库和框架里面的库冲突问题","author":"Arclin","abbrlink":"b072216a","date":"2016-10-28T16:00:00.000Z","_content":"项目里面有一个libFat.a 然后项目里面的KxMovie.framework 里面也有一个libFat.a，编译时会冲突\n如果有用Cocopods,那么只要删掉-ObjC编译选项就可以\n\n<!-- more -->\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/111.png)\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/222.png)","source":"_posts/项目里面的库和框架里面的库冲突问题.md","raw":"---\ntitle: 项目里面的库和框架里面的库冲突问题\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: b072216a\ndate: 2016-10-29 00:00:00\n---\n项目里面有一个libFat.a 然后项目里面的KxMovie.framework 里面也有一个libFat.a，编译时会冲突\n如果有用Cocopods,那么只要删掉-ObjC编译选项就可以\n\n<!-- more -->\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/111.png)\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/222.png)","slug":"项目里面的库和框架里面的库冲突问题","published":1,"updated":"2021-06-06T18:52:24.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqqxyojg0084tnn0a6mzffu5","content":"<p>项目里面有一个libFat.a 然后项目里面的KxMovie.framework 里面也有一个libFat.a，编译时会冲突<br>如果有用Cocopods,那么只要删掉-ObjC编译选项就可以</p>\n<span id=\"more\"></span>\n\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/111.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/222.png\"></p>\n","site":{"data":{}},"excerpt":"<p>项目里面有一个libFat.a 然后项目里面的KxMovie.framework 里面也有一个libFat.a，编译时会冲突<br>如果有用Cocopods,那么只要删掉-ObjC编译选项就可以</p>","more":"<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/111.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/222.png\"></p>"},{"title":"iOS 底层原理 -- Runtime API","author":"Arclin","abbrlink":"11ed4e5e","date":"2021-07-17T15:13:00.000Z","_content":"本文主要简述Runtime的一些常用API\n\n<!--more-->\n\n## 类\n\n动态创建一个类（参数：父类，类名，额外的内存空间）\n\n`Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)`\n\n注册一个类（要在类注册之前添加成员变量）\n\n`void objc_registerClassPair(Class cls) `\n\n销毁一个类\n\n`void objc_disposeClassPair(Class cls)`\n\n获取isa指向的Class\n\n`Class object_getClass(id obj)`\n\n设置isa指向的Class\n\n`Class object_setClass(id obj, Class cls)`\n\n判断一个OC对象是否为Class\n\n`BOOL object_isClass(id obj)`\n\n判断一个Class是否为元类\n\n`BOOL class_isMetaClass(Class cls)`\n\n获取父类\n\n`Class class_getSuperclass(Class cls)`\n\n## 成员变量\n\n获取一个实例变量信息\n\n`Ivar class_getInstanceVariable(Class cls, const char *name)`\n\n拷贝实例变量列表（最后需要调用free释放）\n\n`Ivar *class_copyIvarList(Class cls, unsigned int *outCount)`\n\n设置和获取成员变量的值\n\n`void object_setIvar(id obj, Ivar ivar, id value)`\n\n`id object_getIvar(id obj, Ivar ivar)`\n\n动态添加成员变量（已经注册的类是不能动态添加成员变量的,alignment一般传1，types传成员变量类型，如`@encode(int)`，`@encode(NSObject *)`）\n\n`BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types)`\n\n获取成员变量的相关信息\n\n`const char *ivar_getName(Ivar v)`\n\n`const char *ivar_getTypeEncoding(Ivar v)`\n\n## 属性\n\n获取一个属性\n\n`objc_property_t class_getProperty(Class cls, const char *name)`\n\n拷贝属性列表（最后需要调用free释放）\n\n`objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)`\n\n动态添加属性\n\n`BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)`\n\n动态替换属性\n\n`void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)`\n\n获取属性的一些信息\n\n`const char *property_getName(objc_property_t property)`\n\n`const char *property_getAttributes(objc_property_t property)`\n\n## 方法\n\n获得一个实例方法、类方法\n\n`Method class_getInstanceMethod(Class cls, SEL name)`\n\n`Method class_getClassMethod(Class cls, SEL name)`\n\n方法实现相关操作\n\n`IMP class_getMethodImplementation(Class cls, SEL name) `\n\n`IMP method_setImplementation(Method m, IMP imp)`\n\n方法交换（方法交换之后会清空方法缓存）\n`void method_exchangeImplementations(Method m1, Method m2) `\n\n拷贝方法列表（最后需要调用free释放）\n\n`Method *class_copyMethodList(Class cls, unsigned int *outCount)`\n\n动态添加方法\n\n`BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)`\n\n动态替换方法（不存在原有方法则动态添加该方法并且返回nil）\n\n`IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)`\n\n获取方法的相关信息（带有copy的需要调用free去释放）\n\n`SEL method_getName(Method m)`\n\n`IMP method_getImplementation(Method m)`\n\n`const char *method_getTypeEncoding(Method m)`\n\n`unsigned int method_getNumberOfArguments(Method m)`\n\n`char *method_copyReturnType(Method m)`\n\n`char *method_copyArgumentType(Method m, unsigned int index)`\n\n选择器相关\n\n`const char *sel_getName(SEL sel)`\n\n`SEL sel_registerName(const char *str)`\n\n用block作为方法实现\n\n`IMP imp_implementationWithBlock(id block)`\n\n`id imp_getBlock(IMP anImp)`\n\n`BOOL imp_removeBlock(IMP anImp)`","source":"_posts/iOS-底层原理-Runtime-API.md","raw":"---\ntitle: iOS 底层原理 -- Runtime API\nauthor: Arclin\ntags:\n  - iOS\n  - 底层原理\ncategories:\n  - iOS\nabbrlink: 11ed4e5e\ndate: 2021-07-17 23:13:00\n---\n本文主要简述Runtime的一些常用API\n\n<!--more-->\n\n## 类\n\n动态创建一个类（参数：父类，类名，额外的内存空间）\n\n`Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)`\n\n注册一个类（要在类注册之前添加成员变量）\n\n`void objc_registerClassPair(Class cls) `\n\n销毁一个类\n\n`void objc_disposeClassPair(Class cls)`\n\n获取isa指向的Class\n\n`Class object_getClass(id obj)`\n\n设置isa指向的Class\n\n`Class object_setClass(id obj, Class cls)`\n\n判断一个OC对象是否为Class\n\n`BOOL object_isClass(id obj)`\n\n判断一个Class是否为元类\n\n`BOOL class_isMetaClass(Class cls)`\n\n获取父类\n\n`Class class_getSuperclass(Class cls)`\n\n## 成员变量\n\n获取一个实例变量信息\n\n`Ivar class_getInstanceVariable(Class cls, const char *name)`\n\n拷贝实例变量列表（最后需要调用free释放）\n\n`Ivar *class_copyIvarList(Class cls, unsigned int *outCount)`\n\n设置和获取成员变量的值\n\n`void object_setIvar(id obj, Ivar ivar, id value)`\n\n`id object_getIvar(id obj, Ivar ivar)`\n\n动态添加成员变量（已经注册的类是不能动态添加成员变量的,alignment一般传1，types传成员变量类型，如`@encode(int)`，`@encode(NSObject *)`）\n\n`BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types)`\n\n获取成员变量的相关信息\n\n`const char *ivar_getName(Ivar v)`\n\n`const char *ivar_getTypeEncoding(Ivar v)`\n\n## 属性\n\n获取一个属性\n\n`objc_property_t class_getProperty(Class cls, const char *name)`\n\n拷贝属性列表（最后需要调用free释放）\n\n`objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)`\n\n动态添加属性\n\n`BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)`\n\n动态替换属性\n\n`void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)`\n\n获取属性的一些信息\n\n`const char *property_getName(objc_property_t property)`\n\n`const char *property_getAttributes(objc_property_t property)`\n\n## 方法\n\n获得一个实例方法、类方法\n\n`Method class_getInstanceMethod(Class cls, SEL name)`\n\n`Method class_getClassMethod(Class cls, SEL name)`\n\n方法实现相关操作\n\n`IMP class_getMethodImplementation(Class cls, SEL name) `\n\n`IMP method_setImplementation(Method m, IMP imp)`\n\n方法交换（方法交换之后会清空方法缓存）\n`void method_exchangeImplementations(Method m1, Method m2) `\n\n拷贝方法列表（最后需要调用free释放）\n\n`Method *class_copyMethodList(Class cls, unsigned int *outCount)`\n\n动态添加方法\n\n`BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)`\n\n动态替换方法（不存在原有方法则动态添加该方法并且返回nil）\n\n`IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)`\n\n获取方法的相关信息（带有copy的需要调用free去释放）\n\n`SEL method_getName(Method m)`\n\n`IMP method_getImplementation(Method m)`\n\n`const char *method_getTypeEncoding(Method m)`\n\n`unsigned int method_getNumberOfArguments(Method m)`\n\n`char *method_copyReturnType(Method m)`\n\n`char *method_copyArgumentType(Method m, unsigned int index)`\n\n选择器相关\n\n`const char *sel_getName(SEL sel)`\n\n`SEL sel_registerName(const char *str)`\n\n用block作为方法实现\n\n`IMP imp_implementationWithBlock(id block)`\n\n`id imp_getBlock(IMP anImp)`\n\n`BOOL imp_removeBlock(IMP anImp)`","slug":"iOS-底层原理-Runtime-API","published":1,"updated":"2021-07-17T15:53:09.367Z","_id":"ckr7wtb4d00004an03rmc3pfa","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文主要简述Runtime的一些常用API</p>\n<span id=\"more\"></span>\n\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><p>动态创建一个类（参数：父类，类名，额外的内存空间）</p>\n<p><code>Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</code></p>\n<p>注册一个类（要在类注册之前添加成员变量）</p>\n<p><code>void objc_registerClassPair(Class cls) </code></p>\n<p>销毁一个类</p>\n<p><code>void objc_disposeClassPair(Class cls)</code></p>\n<p>获取isa指向的Class</p>\n<p><code>Class object_getClass(id obj)</code></p>\n<p>设置isa指向的Class</p>\n<p><code>Class object_setClass(id obj, Class cls)</code></p>\n<p>判断一个OC对象是否为Class</p>\n<p><code>BOOL object_isClass(id obj)</code></p>\n<p>判断一个Class是否为元类</p>\n<p><code>BOOL class_isMetaClass(Class cls)</code></p>\n<p>获取父类</p>\n<p><code>Class class_getSuperclass(Class cls)</code></p>\n<h2 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h2><p>获取一个实例变量信息</p>\n<p><code>Ivar class_getInstanceVariable(Class cls, const char *name)</code></p>\n<p>拷贝实例变量列表（最后需要调用free释放）</p>\n<p><code>Ivar *class_copyIvarList(Class cls, unsigned int *outCount)</code></p>\n<p>设置和获取成员变量的值</p>\n<p><code>void object_setIvar(id obj, Ivar ivar, id value)</code></p>\n<p><code>id object_getIvar(id obj, Ivar ivar)</code></p>\n<p>动态添加成员变量（已经注册的类是不能动态添加成员变量的,alignment一般传1，types传成员变量类型，如<code>@encode(int)</code>，<code>@encode(NSObject *)</code>）</p>\n<p><code>BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types)</code></p>\n<p>获取成员变量的相关信息</p>\n<p><code>const char *ivar_getName(Ivar v)</code></p>\n<p><code>const char *ivar_getTypeEncoding(Ivar v)</code></p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>获取一个属性</p>\n<p><code>objc_property_t class_getProperty(Class cls, const char *name)</code></p>\n<p>拷贝属性列表（最后需要调用free释放）</p>\n<p><code>objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</code></p>\n<p>动态添加属性</p>\n<p><code>BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)</code></p>\n<p>动态替换属性</p>\n<p><code>void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)</code></p>\n<p>获取属性的一些信息</p>\n<p><code>const char *property_getName(objc_property_t property)</code></p>\n<p><code>const char *property_getAttributes(objc_property_t property)</code></p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>获得一个实例方法、类方法</p>\n<p><code>Method class_getInstanceMethod(Class cls, SEL name)</code></p>\n<p><code>Method class_getClassMethod(Class cls, SEL name)</code></p>\n<p>方法实现相关操作</p>\n<p><code>IMP class_getMethodImplementation(Class cls, SEL name) </code></p>\n<p><code>IMP method_setImplementation(Method m, IMP imp)</code></p>\n<p>方法交换（方法交换之后会清空方法缓存）<br><code>void method_exchangeImplementations(Method m1, Method m2) </code></p>\n<p>拷贝方法列表（最后需要调用free释放）</p>\n<p><code>Method *class_copyMethodList(Class cls, unsigned int *outCount)</code></p>\n<p>动态添加方法</p>\n<p><code>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</code></p>\n<p>动态替换方法（不存在原有方法则动态添加该方法并且返回nil）</p>\n<p><code>IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)</code></p>\n<p>获取方法的相关信息（带有copy的需要调用free去释放）</p>\n<p><code>SEL method_getName(Method m)</code></p>\n<p><code>IMP method_getImplementation(Method m)</code></p>\n<p><code>const char *method_getTypeEncoding(Method m)</code></p>\n<p><code>unsigned int method_getNumberOfArguments(Method m)</code></p>\n<p><code>char *method_copyReturnType(Method m)</code></p>\n<p><code>char *method_copyArgumentType(Method m, unsigned int index)</code></p>\n<p>选择器相关</p>\n<p><code>const char *sel_getName(SEL sel)</code></p>\n<p><code>SEL sel_registerName(const char *str)</code></p>\n<p>用block作为方法实现</p>\n<p><code>IMP imp_implementationWithBlock(id block)</code></p>\n<p><code>id imp_getBlock(IMP anImp)</code></p>\n<p><code>BOOL imp_removeBlock(IMP anImp)</code></p>\n","site":{"data":{}},"excerpt":"<p>本文主要简述Runtime的一些常用API</p>","more":"<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><p>动态创建一个类（参数：父类，类名，额外的内存空间）</p>\n<p><code>Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</code></p>\n<p>注册一个类（要在类注册之前添加成员变量）</p>\n<p><code>void objc_registerClassPair(Class cls) </code></p>\n<p>销毁一个类</p>\n<p><code>void objc_disposeClassPair(Class cls)</code></p>\n<p>获取isa指向的Class</p>\n<p><code>Class object_getClass(id obj)</code></p>\n<p>设置isa指向的Class</p>\n<p><code>Class object_setClass(id obj, Class cls)</code></p>\n<p>判断一个OC对象是否为Class</p>\n<p><code>BOOL object_isClass(id obj)</code></p>\n<p>判断一个Class是否为元类</p>\n<p><code>BOOL class_isMetaClass(Class cls)</code></p>\n<p>获取父类</p>\n<p><code>Class class_getSuperclass(Class cls)</code></p>\n<h2 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h2><p>获取一个实例变量信息</p>\n<p><code>Ivar class_getInstanceVariable(Class cls, const char *name)</code></p>\n<p>拷贝实例变量列表（最后需要调用free释放）</p>\n<p><code>Ivar *class_copyIvarList(Class cls, unsigned int *outCount)</code></p>\n<p>设置和获取成员变量的值</p>\n<p><code>void object_setIvar(id obj, Ivar ivar, id value)</code></p>\n<p><code>id object_getIvar(id obj, Ivar ivar)</code></p>\n<p>动态添加成员变量（已经注册的类是不能动态添加成员变量的,alignment一般传1，types传成员变量类型，如<code>@encode(int)</code>，<code>@encode(NSObject *)</code>）</p>\n<p><code>BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types)</code></p>\n<p>获取成员变量的相关信息</p>\n<p><code>const char *ivar_getName(Ivar v)</code></p>\n<p><code>const char *ivar_getTypeEncoding(Ivar v)</code></p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>获取一个属性</p>\n<p><code>objc_property_t class_getProperty(Class cls, const char *name)</code></p>\n<p>拷贝属性列表（最后需要调用free释放）</p>\n<p><code>objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</code></p>\n<p>动态添加属性</p>\n<p><code>BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)</code></p>\n<p>动态替换属性</p>\n<p><code>void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)</code></p>\n<p>获取属性的一些信息</p>\n<p><code>const char *property_getName(objc_property_t property)</code></p>\n<p><code>const char *property_getAttributes(objc_property_t property)</code></p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>获得一个实例方法、类方法</p>\n<p><code>Method class_getInstanceMethod(Class cls, SEL name)</code></p>\n<p><code>Method class_getClassMethod(Class cls, SEL name)</code></p>\n<p>方法实现相关操作</p>\n<p><code>IMP class_getMethodImplementation(Class cls, SEL name) </code></p>\n<p><code>IMP method_setImplementation(Method m, IMP imp)</code></p>\n<p>方法交换（方法交换之后会清空方法缓存）<br><code>void method_exchangeImplementations(Method m1, Method m2) </code></p>\n<p>拷贝方法列表（最后需要调用free释放）</p>\n<p><code>Method *class_copyMethodList(Class cls, unsigned int *outCount)</code></p>\n<p>动态添加方法</p>\n<p><code>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</code></p>\n<p>动态替换方法（不存在原有方法则动态添加该方法并且返回nil）</p>\n<p><code>IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)</code></p>\n<p>获取方法的相关信息（带有copy的需要调用free去释放）</p>\n<p><code>SEL method_getName(Method m)</code></p>\n<p><code>IMP method_getImplementation(Method m)</code></p>\n<p><code>const char *method_getTypeEncoding(Method m)</code></p>\n<p><code>unsigned int method_getNumberOfArguments(Method m)</code></p>\n<p><code>char *method_copyReturnType(Method m)</code></p>\n<p><code>char *method_copyArgumentType(Method m, unsigned int index)</code></p>\n<p>选择器相关</p>\n<p><code>const char *sel_getName(SEL sel)</code></p>\n<p><code>SEL sel_registerName(const char *str)</code></p>\n<p>用block作为方法实现</p>\n<p><code>IMP imp_implementationWithBlock(id block)</code></p>\n<p><code>id imp_getBlock(IMP anImp)</code></p>\n<p><code>BOOL imp_removeBlock(IMP anImp)</code></p>"},{"title":"Swift 5.4 Result Builder","author":"Arclin","abbrlink":"4bf15bdf","date":"2021-07-18T02:13:00.000Z","_content":"本文主要讲述Swift 5.4的新特性 Result Builder在设计上的一些使用方式\n\n<!-- more -->\n\n## 需求\n\n假如我们有一个需求，需要往ScrollView上加入不同类型的View，并且根据不确定的的顺序从上往下进行排列，所以一般情况下我们可以这样子设计框架\n\n1. 首先定义一个协议，遵循协议的对象使用一个build方法返回一个View\n\n  ```swift\n  protocol ViewBuilder {\n      func build() -> UIView\n  }\n  ```\n \n2. 这里我们设计四种颜色的View，宽度均为屏幕宽度，高度不定\n\n  ```swift\n  struct WhiteView : ViewBuilder {\n      func build() -> UIView {\n          let view = UIView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: 100))\n          view.backgroundColor = .white\n          return view\n      }\n  }\n\n  struct RedView : ViewBuilder {\n      func build() -> UIView {\n          let banner = UIView.init(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: 200))\n          banner.backgroundColor = UIColor.red\n          return banner\n      }\n  }\n\n  struct BlueView : ViewBuilder {\n      func build() -> UIView {\n          let goodsView = UIView.init(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: 350))\n          goodsView.backgroundColor = UIColor.blue\n          return goodsView\n      }\n  }\n\n  struct GreenView : ViewBuilder {\n      func build() -> UIView {\n          let dynamicView = UIView.init(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: 400))\n          dynamicView.backgroundColor = UIColor.green\n          return dynamicView\n      }\n  }\n  ```\n  \n3. 最后我们再定义一个ScrollView的容器，传入一个数组，让其从上到下进行排列\n\n\t```swift\n    struct ScrollableContainer : ViewBuilder {\n    var contents : [ViewBuilder]\n    func build() -> UIView {\n        let scrollView = UIScrollView.init(frame: UIScreen.main.bounds)\n        _ = contents.reduce(CGFloat(0)) { currentY, builder in\n            let view = builder.build()\n            view.frame.origin.y = currentY\n            scrollView.addSubview(view)\n            scrollView.contentSize = CGSize(width: UIScreen.main.bounds.size.width, height: scrollView.subviews.last!.frame.maxY)\n            return currentY + view.frame.size.height\n        }\n        return scrollView\n    }\n    ```\n    \n4. 这样子我们就可以开始布局了\n\n\t```swift\n    let scrollView = ScrollableContainer(contents: [\n        RedView(),\n        BlueView(),\n        GreenView()\n    ])\n    view.addSubview(scrollView.build())\n    ```\n    \n    效果如下\n    \n    <img src=\"https://p6-tt.byteimg.com/origin/pgc-image/8f8201d352eb44a7aab4b0b68ba6e9e2.png\" width=50%>\n    \n5. 通过这种方式，我们就可以随意调整内部的布局顺序，也可以方便的新增多个View\n\n## 优化\n\n但是上述方法有一个缺点，就是当如果要重复添加多个相同的View或者说想要通过某个条件再添加View，就会有点复杂，比如当`needBlue == true`成立的时候再添加`BlueView`，那么可能需要这么写\n\n```swift\nvar contents = [\n    RedView(),\n    GreenView()\n]\n\nif needBlue == true {\n\tcontents = [\n        RedView(),\n        BlueView(),\n        GreenView()\n    ]\n}\n\nlet scrollView = ScrollableContainer(contents: contents)\nview.addSubview(scrollView.build())\n```\n\n为了让可读性更加好，我们可以模仿SwiftUI的DSL语法进行设计，这里就需要使用到Swift 5.4的新特性 Result Builder\n    \n1. 首先我们要添加一个容器结构体，因为从上到下写的`View`会被整成一个数组或者多参数传进来，所以要加一个容器把他们从上到下排列好，最后排列完了，再把这个容器放进去ScrollView中\n\n\t```swift\n\tstruct ViewContainer : ViewBuilder {\n      var contents : [ViewBuilder]\n      func build() -> UIView {\n          let container = UIView(frame: UIScreen.main.bounds)\n          _ = contents.reduce(CGFloat(0), { currentY, builder in\n              let view = builder.build()\n              view.frame.origin.y = currentY\n              container.addSubview(view)\n              container.frame.size = CGSize(width: UIScreen.main.bounds.size.width, height: container.subviews.last!.frame.maxY)\n              return currentY + view.frame.size.height\n          })\n          return container\n      }\n\t}\n    ```\n    \n2. 创建一个Result builder，使用`@resultBuilder`注解会要求我们添加一个`buildBlock`方法，实现这个方法，把我们外面传进来的多个View放进去`VieContainer`容器中，然后实现`buildFinalResult`在编写结束的时候把\n`VieContainer`放进去`ScrollView`容器中\n\n\t```swift\n    @resultBuilder\n    struct ScrollableViewBuilder {\n        static func buildBlock(_ components: ViewBuilder...) -> ViewBuilder {\n            return ViewContainer(contents: components)\n        }\n        static func buildFinalResult(_ component: ViewBuilder) -> ViewBuilder {\n            return ScrollableContainer(contents: [component])\n        }\n    }\n    ```\n    \n3. 这时候我们通过新增的`ScrollableViewBuilder`来创建一个方法，这里的闭包就是待会我们要写DSL的地方\n\n\t```swift\n    func build(@ScrollableViewBuilder content: () -> ViewBuilder) -> ViewBuilder {\n        return content()\n    }\n    ```\n    \n    这个方法传入一个闭包，这个由于我们已经实现了`buildBlock`，所以`content`被`@ScrollableViewBuilder`修饰之后，会自动将闭包内的东西转化成多参数，传入`buildBlock`方法，在那里面我们把各种各样的`View`给添加到`ViewContainer`上，方法调用如下\n    \n    ```swift\n    let result = build {\n        RedView()\n        BlueView()\n        GreenView()\n    }\n        \n    view.addSubview(result.build())\n    ```\n\n\t这时候运行效果同上图一致\n    \n4. 接下来我们需要让这个闭包内支持if语句、else if语句、else语句和for语句，\n\n\t```swift\n    struct ScrollableViewBuilder {\n      static func buildBlock(_ components: ViewBuilder...) -> ViewBuilder {\n          return ScrollableContainer(contents: components)\n      }\n      /// 表示if语句\n      static func buildEither(first component: ViewBuilder) -> ViewBuilder {\n          return component\n      }\n      /// 表示eles if语句\n      static func buildEither(second component: ViewBuilder) -> ViewBuilder {\n          return component\n      }\n      /// 表示else语句和其他的可选值（即？修饰的View）\n      static func buildOptional(_ component: ViewBuilder?) -> ViewBuilder {\n          return component ?? DefaultView()\n      }\n    }\n    ```\n    \n    然后我们试一试这么写\n    \n    ```swift\n    let flag = 2\n    let result = build {\n        RedView()\n        BlueView()\n        GreenView()\n        if flag == 1 {\n            RedView()\n            RedView()\n        } else if flag == 2 {\n            GreenView()\n            GreenView()\n            GreenView()\n        } else if flag == 3 {\n            GreenView()\n        } else {\n            BlueView()\n            BlueView()\n            BlueView()\n        }\n    }\n    ```\n    \n    当flag = 1的时候，首先两个`RedView()`会先进入`buildBlock`方法，然后被包装成一个`ViewContainer`，然后再进去`buildEither(first component: ViewBuilder)`方法，这里我没处理就直接把传进来的值返回出去了\n    \n    当flag = 2 或者 flag = 3 的时候，首先括号内的多个`GreenView()`会先进入`buildBlock`方法，然后被包装成一个`ViewContainer`，然后再进去`buildEither(second component: ViewBuilder)`方法，这里我没处理就直接把传进来的值返回出去了\n    \n    当 flag 为其他值的时候，首先括号内的多个`BlueView()`会先进入`buildBlock`方法，然后被包装成一个`ViewContainer`，然后再进去`buildEither(second component: ViewBuilder)`方法。当没有写`eles`语句的时候，需要实现`buildOptional(_ component: ViewBuilder?)`方法，去处理没有进入`if`语句而导致的不返回`View`的情况，如果没有写`else`语句，那么不会进入`buildBlock`，会直接取空值情况下你返回的默认`View`。\n    \n5. 处理for语句，比如这样\n\n    ```swift\n    let result = build {\n        RedView()\n        BlueView()\n        GreenView()\n        for _ in 0...2 {\n            GreenView()\n            BlueView()\n        }\n    }\n    ```\n    \n    `for`里面需要返回3个`GreenView+BlueView`，这里他每次调用for的括号里面的内容，都会走一遍`buildBlock`把里面的`GreenView+BlueView`封装成一个`ViewContainer`，所以这里会产生3个`ViewContainer`，最后这三个会变成一个数组，进入`buildArray`方法，再封装成一个`ViewContainer`，代码如下\n    \n    ```swift\n    @resultBuilder\n    struct ScrollableViewBuilder {\n        static func buildBlock(_ components: ViewBuilder...) -> ViewBuilder {\n            return ViewContainer(contents: components)\n        }\n        static func buildEither(first component: ViewBuilder) -> ViewBuilder {\n            return component\n        }\n        static func buildEither(second component: ViewBuilder) -> ViewBuilder {\n            return component\n        }\n        static func buildOptional(_ component: ViewBuilder?) -> ViewBuilder {\n            return component ?? WhiteView()\n        }\n        static func buildArray(_ components: [ViewBuilder]) -> ViewBuilder {\n            return ViewContainer(contents: components)\n        }\n        static func buildFinalResult(_ component: ViewBuilder) -> ViewBuilder {\n            return ScrollableContainer(contents: [component])\n        }\n    }\n    ```\n    \n6. 处理表达式，如果我们要在DSL里面插一些除了`View`之外的一些东西，那么就需要添加对应的处理方法，比如\n\n\t```swift\n    let result = build {\n        print(\"a123\")\n        RedView()\n        BlueView()\n        GreenView()\n    }\n    ```\n    \n    针对这个`print`我们添加表达式处理\n    \n    ScrollableViewBuilder\n    \n    ```swift\n    /// 针对正常的表达式，就直接返回\n    static func buildExpression(_ expression: ViewBuilder) -> ViewBuilder {\n        return expression\n    }\n    \n    /// 针对特殊的表达式，返回空View\n    static func buildExpression(_ expression: ()) -> ViewBuilder {\n        return EmptyBuilder()\n    }\n    ```\n    \n    EmptyBuilder\n    \n    ```swift\n    struct EmptyBuilder : ViewBuilder {\n      func build() -> UIView {\n          return UIView.init()\n      }\n    }\n    ```\n    \n## 总结\n\n到这里就说的差不多了，其他本文没提及到的内容可以参阅[Write a DSL in Swift using result builders](https://developer.apple.com/videos/play/wwdc2021/10253/)\n\n本文[Demo](https://github.com/Arc-lin/ResultBuilderDemo)地址","source":"_posts/Swift-5-4-Result-Builder.md","raw":"title: Swift 5.4 Result Builder\nauthor: Arclin\ntags:\n  - iOS\n  - Swift\ncategories:\n  - iOS\nabbrlink: 4bf15bdf\ndate: 2021-07-18 10:13:00\n---\n本文主要讲述Swift 5.4的新特性 Result Builder在设计上的一些使用方式\n\n<!-- more -->\n\n## 需求\n\n假如我们有一个需求，需要往ScrollView上加入不同类型的View，并且根据不确定的的顺序从上往下进行排列，所以一般情况下我们可以这样子设计框架\n\n1. 首先定义一个协议，遵循协议的对象使用一个build方法返回一个View\n\n  ```swift\n  protocol ViewBuilder {\n      func build() -> UIView\n  }\n  ```\n \n2. 这里我们设计四种颜色的View，宽度均为屏幕宽度，高度不定\n\n  ```swift\n  struct WhiteView : ViewBuilder {\n      func build() -> UIView {\n          let view = UIView(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: 100))\n          view.backgroundColor = .white\n          return view\n      }\n  }\n\n  struct RedView : ViewBuilder {\n      func build() -> UIView {\n          let banner = UIView.init(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: 200))\n          banner.backgroundColor = UIColor.red\n          return banner\n      }\n  }\n\n  struct BlueView : ViewBuilder {\n      func build() -> UIView {\n          let goodsView = UIView.init(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: 350))\n          goodsView.backgroundColor = UIColor.blue\n          return goodsView\n      }\n  }\n\n  struct GreenView : ViewBuilder {\n      func build() -> UIView {\n          let dynamicView = UIView.init(frame: CGRect(x: 0, y: 0, width: UIScreen.main.bounds.width, height: 400))\n          dynamicView.backgroundColor = UIColor.green\n          return dynamicView\n      }\n  }\n  ```\n  \n3. 最后我们再定义一个ScrollView的容器，传入一个数组，让其从上到下进行排列\n\n\t```swift\n    struct ScrollableContainer : ViewBuilder {\n    var contents : [ViewBuilder]\n    func build() -> UIView {\n        let scrollView = UIScrollView.init(frame: UIScreen.main.bounds)\n        _ = contents.reduce(CGFloat(0)) { currentY, builder in\n            let view = builder.build()\n            view.frame.origin.y = currentY\n            scrollView.addSubview(view)\n            scrollView.contentSize = CGSize(width: UIScreen.main.bounds.size.width, height: scrollView.subviews.last!.frame.maxY)\n            return currentY + view.frame.size.height\n        }\n        return scrollView\n    }\n    ```\n    \n4. 这样子我们就可以开始布局了\n\n\t```swift\n    let scrollView = ScrollableContainer(contents: [\n        RedView(),\n        BlueView(),\n        GreenView()\n    ])\n    view.addSubview(scrollView.build())\n    ```\n    \n    效果如下\n    \n    <img src=\"https://p6-tt.byteimg.com/origin/pgc-image/8f8201d352eb44a7aab4b0b68ba6e9e2.png\" width=50%>\n    \n5. 通过这种方式，我们就可以随意调整内部的布局顺序，也可以方便的新增多个View\n\n## 优化\n\n但是上述方法有一个缺点，就是当如果要重复添加多个相同的View或者说想要通过某个条件再添加View，就会有点复杂，比如当`needBlue == true`成立的时候再添加`BlueView`，那么可能需要这么写\n\n```swift\nvar contents = [\n    RedView(),\n    GreenView()\n]\n\nif needBlue == true {\n\tcontents = [\n        RedView(),\n        BlueView(),\n        GreenView()\n    ]\n}\n\nlet scrollView = ScrollableContainer(contents: contents)\nview.addSubview(scrollView.build())\n```\n\n为了让可读性更加好，我们可以模仿SwiftUI的DSL语法进行设计，这里就需要使用到Swift 5.4的新特性 Result Builder\n    \n1. 首先我们要添加一个容器结构体，因为从上到下写的`View`会被整成一个数组或者多参数传进来，所以要加一个容器把他们从上到下排列好，最后排列完了，再把这个容器放进去ScrollView中\n\n\t```swift\n\tstruct ViewContainer : ViewBuilder {\n      var contents : [ViewBuilder]\n      func build() -> UIView {\n          let container = UIView(frame: UIScreen.main.bounds)\n          _ = contents.reduce(CGFloat(0), { currentY, builder in\n              let view = builder.build()\n              view.frame.origin.y = currentY\n              container.addSubview(view)\n              container.frame.size = CGSize(width: UIScreen.main.bounds.size.width, height: container.subviews.last!.frame.maxY)\n              return currentY + view.frame.size.height\n          })\n          return container\n      }\n\t}\n    ```\n    \n2. 创建一个Result builder，使用`@resultBuilder`注解会要求我们添加一个`buildBlock`方法，实现这个方法，把我们外面传进来的多个View放进去`VieContainer`容器中，然后实现`buildFinalResult`在编写结束的时候把\n`VieContainer`放进去`ScrollView`容器中\n\n\t```swift\n    @resultBuilder\n    struct ScrollableViewBuilder {\n        static func buildBlock(_ components: ViewBuilder...) -> ViewBuilder {\n            return ViewContainer(contents: components)\n        }\n        static func buildFinalResult(_ component: ViewBuilder) -> ViewBuilder {\n            return ScrollableContainer(contents: [component])\n        }\n    }\n    ```\n    \n3. 这时候我们通过新增的`ScrollableViewBuilder`来创建一个方法，这里的闭包就是待会我们要写DSL的地方\n\n\t```swift\n    func build(@ScrollableViewBuilder content: () -> ViewBuilder) -> ViewBuilder {\n        return content()\n    }\n    ```\n    \n    这个方法传入一个闭包，这个由于我们已经实现了`buildBlock`，所以`content`被`@ScrollableViewBuilder`修饰之后，会自动将闭包内的东西转化成多参数，传入`buildBlock`方法，在那里面我们把各种各样的`View`给添加到`ViewContainer`上，方法调用如下\n    \n    ```swift\n    let result = build {\n        RedView()\n        BlueView()\n        GreenView()\n    }\n        \n    view.addSubview(result.build())\n    ```\n\n\t这时候运行效果同上图一致\n    \n4. 接下来我们需要让这个闭包内支持if语句、else if语句、else语句和for语句，\n\n\t```swift\n    struct ScrollableViewBuilder {\n      static func buildBlock(_ components: ViewBuilder...) -> ViewBuilder {\n          return ScrollableContainer(contents: components)\n      }\n      /// 表示if语句\n      static func buildEither(first component: ViewBuilder) -> ViewBuilder {\n          return component\n      }\n      /// 表示eles if语句\n      static func buildEither(second component: ViewBuilder) -> ViewBuilder {\n          return component\n      }\n      /// 表示else语句和其他的可选值（即？修饰的View）\n      static func buildOptional(_ component: ViewBuilder?) -> ViewBuilder {\n          return component ?? DefaultView()\n      }\n    }\n    ```\n    \n    然后我们试一试这么写\n    \n    ```swift\n    let flag = 2\n    let result = build {\n        RedView()\n        BlueView()\n        GreenView()\n        if flag == 1 {\n            RedView()\n            RedView()\n        } else if flag == 2 {\n            GreenView()\n            GreenView()\n            GreenView()\n        } else if flag == 3 {\n            GreenView()\n        } else {\n            BlueView()\n            BlueView()\n            BlueView()\n        }\n    }\n    ```\n    \n    当flag = 1的时候，首先两个`RedView()`会先进入`buildBlock`方法，然后被包装成一个`ViewContainer`，然后再进去`buildEither(first component: ViewBuilder)`方法，这里我没处理就直接把传进来的值返回出去了\n    \n    当flag = 2 或者 flag = 3 的时候，首先括号内的多个`GreenView()`会先进入`buildBlock`方法，然后被包装成一个`ViewContainer`，然后再进去`buildEither(second component: ViewBuilder)`方法，这里我没处理就直接把传进来的值返回出去了\n    \n    当 flag 为其他值的时候，首先括号内的多个`BlueView()`会先进入`buildBlock`方法，然后被包装成一个`ViewContainer`，然后再进去`buildEither(second component: ViewBuilder)`方法。当没有写`eles`语句的时候，需要实现`buildOptional(_ component: ViewBuilder?)`方法，去处理没有进入`if`语句而导致的不返回`View`的情况，如果没有写`else`语句，那么不会进入`buildBlock`，会直接取空值情况下你返回的默认`View`。\n    \n5. 处理for语句，比如这样\n\n    ```swift\n    let result = build {\n        RedView()\n        BlueView()\n        GreenView()\n        for _ in 0...2 {\n            GreenView()\n            BlueView()\n        }\n    }\n    ```\n    \n    `for`里面需要返回3个`GreenView+BlueView`，这里他每次调用for的括号里面的内容，都会走一遍`buildBlock`把里面的`GreenView+BlueView`封装成一个`ViewContainer`，所以这里会产生3个`ViewContainer`，最后这三个会变成一个数组，进入`buildArray`方法，再封装成一个`ViewContainer`，代码如下\n    \n    ```swift\n    @resultBuilder\n    struct ScrollableViewBuilder {\n        static func buildBlock(_ components: ViewBuilder...) -> ViewBuilder {\n            return ViewContainer(contents: components)\n        }\n        static func buildEither(first component: ViewBuilder) -> ViewBuilder {\n            return component\n        }\n        static func buildEither(second component: ViewBuilder) -> ViewBuilder {\n            return component\n        }\n        static func buildOptional(_ component: ViewBuilder?) -> ViewBuilder {\n            return component ?? WhiteView()\n        }\n        static func buildArray(_ components: [ViewBuilder]) -> ViewBuilder {\n            return ViewContainer(contents: components)\n        }\n        static func buildFinalResult(_ component: ViewBuilder) -> ViewBuilder {\n            return ScrollableContainer(contents: [component])\n        }\n    }\n    ```\n    \n6. 处理表达式，如果我们要在DSL里面插一些除了`View`之外的一些东西，那么就需要添加对应的处理方法，比如\n\n\t```swift\n    let result = build {\n        print(\"a123\")\n        RedView()\n        BlueView()\n        GreenView()\n    }\n    ```\n    \n    针对这个`print`我们添加表达式处理\n    \n    ScrollableViewBuilder\n    \n    ```swift\n    /// 针对正常的表达式，就直接返回\n    static func buildExpression(_ expression: ViewBuilder) -> ViewBuilder {\n        return expression\n    }\n    \n    /// 针对特殊的表达式，返回空View\n    static func buildExpression(_ expression: ()) -> ViewBuilder {\n        return EmptyBuilder()\n    }\n    ```\n    \n    EmptyBuilder\n    \n    ```swift\n    struct EmptyBuilder : ViewBuilder {\n      func build() -> UIView {\n          return UIView.init()\n      }\n    }\n    ```\n    \n## 总结\n\n到这里就说的差不多了，其他本文没提及到的内容可以参阅[Write a DSL in Swift using result builders](https://developer.apple.com/videos/play/wwdc2021/10253/)\n\n本文[Demo](https://github.com/Arc-lin/ResultBuilderDemo)地址","slug":"Swift-5-4-Result-Builder","published":1,"updated":"2021-08-21T09:01:12.999Z","_id":"ckr8kf53y000066n0gqc05jiv","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文主要讲述Swift 5.4的新特性 Result Builder在设计上的一些使用方式</p>\n<span id=\"more\"></span>\n\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>假如我们有一个需求，需要往ScrollView上加入不同类型的View，并且根据不确定的的顺序从上往下进行排列，所以一般情况下我们可以这样子设计框架</p>\n<ol>\n<li>首先定义一个协议，遵循协议的对象使用一个build方法返回一个View</li>\n</ol>\n  <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">ViewBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>()</span> -&gt; <span class=\"type\">UIView</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>这里我们设计四种颜色的View，宽度均为屏幕宽度，高度不定</li>\n</ol>\n  <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">WhiteView</span> : <span class=\"title\">ViewBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>()</span> -&gt; <span class=\"type\">UIView</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> view <span class=\"operator\">=</span> <span class=\"type\">UIView</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"type\">UIScreen</span>.main.bounds.width, height: <span class=\"number\">100</span>))</span><br><span class=\"line\">        view.backgroundColor <span class=\"operator\">=</span> .white</span><br><span class=\"line\">        <span class=\"keyword\">return</span> view</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">RedView</span> : <span class=\"title\">ViewBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>()</span> -&gt; <span class=\"type\">UIView</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> banner <span class=\"operator\">=</span> <span class=\"type\">UIView</span>.<span class=\"keyword\">init</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"type\">UIScreen</span>.main.bounds.width, height: <span class=\"number\">200</span>))</span><br><span class=\"line\">        banner.backgroundColor <span class=\"operator\">=</span> <span class=\"type\">UIColor</span>.red</span><br><span class=\"line\">        <span class=\"keyword\">return</span> banner</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BlueView</span> : <span class=\"title\">ViewBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>()</span> -&gt; <span class=\"type\">UIView</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> goodsView <span class=\"operator\">=</span> <span class=\"type\">UIView</span>.<span class=\"keyword\">init</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"type\">UIScreen</span>.main.bounds.width, height: <span class=\"number\">350</span>))</span><br><span class=\"line\">        goodsView.backgroundColor <span class=\"operator\">=</span> <span class=\"type\">UIColor</span>.blue</span><br><span class=\"line\">        <span class=\"keyword\">return</span> goodsView</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GreenView</span> : <span class=\"title\">ViewBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>()</span> -&gt; <span class=\"type\">UIView</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> dynamicView <span class=\"operator\">=</span> <span class=\"type\">UIView</span>.<span class=\"keyword\">init</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"type\">UIScreen</span>.main.bounds.width, height: <span class=\"number\">400</span>))</span><br><span class=\"line\">        dynamicView.backgroundColor <span class=\"operator\">=</span> <span class=\"type\">UIColor</span>.green</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dynamicView</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li><p>最后我们再定义一个ScrollView的容器，传入一个数组，让其从上到下进行排列</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ScrollableContainer</span> : <span class=\"title\">ViewBuilder</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> contents : [<span class=\"type\">ViewBuilder</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>()</span> -&gt; <span class=\"type\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> scrollView <span class=\"operator\">=</span> <span class=\"type\">UIScrollView</span>.<span class=\"keyword\">init</span>(frame: <span class=\"type\">UIScreen</span>.main.bounds)</span><br><span class=\"line\">    <span class=\"keyword\">_</span> <span class=\"operator\">=</span> contents.reduce(<span class=\"type\">CGFloat</span>(<span class=\"number\">0</span>)) &#123; currentY, builder <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> view <span class=\"operator\">=</span> builder.build()</span><br><span class=\"line\">        view.frame.origin.y <span class=\"operator\">=</span> currentY</span><br><span class=\"line\">        scrollView.addSubview(view)</span><br><span class=\"line\">        scrollView.contentSize <span class=\"operator\">=</span> <span class=\"type\">CGSize</span>(width: <span class=\"type\">UIScreen</span>.main.bounds.size.width, height: scrollView.subviews.last<span class=\"operator\">!</span>.frame.maxY)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentY <span class=\"operator\">+</span> view.frame.size.height</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scrollView</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这样子我们就可以开始布局了</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> scrollView <span class=\"operator\">=</span> <span class=\"type\">ScrollableContainer</span>(contents: [</span><br><span class=\"line\">    <span class=\"type\">RedView</span>(),</span><br><span class=\"line\">    <span class=\"type\">BlueView</span>(),</span><br><span class=\"line\">    <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">])</span><br><span class=\"line\">view.addSubview(scrollView.build())</span><br></pre></td></tr></table></figure>\n<p> 效果如下</p>\n <img src=\"https://p6-tt.byteimg.com/origin/pgc-image/8f8201d352eb44a7aab4b0b68ba6e9e2.png\" width=50%>\n </li>\n<li><p>通过这种方式，我们就可以随意调整内部的布局顺序，也可以方便的新增多个View</p>\n</li>\n</ol>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>但是上述方法有一个缺点，就是当如果要重复添加多个相同的View或者说想要通过某个条件再添加View，就会有点复杂，比如当<code>needBlue == true</code>成立的时候再添加<code>BlueView</code>，那么可能需要这么写</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> contents <span class=\"operator\">=</span> [</span><br><span class=\"line\">    <span class=\"type\">RedView</span>(),</span><br><span class=\"line\">    <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> needBlue <span class=\"operator\">==</span> <span class=\"literal\">true</span> &#123;</span><br><span class=\"line\">\tcontents <span class=\"operator\">=</span> [</span><br><span class=\"line\">        <span class=\"type\">RedView</span>(),</span><br><span class=\"line\">        <span class=\"type\">BlueView</span>(),</span><br><span class=\"line\">        <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> scrollView <span class=\"operator\">=</span> <span class=\"type\">ScrollableContainer</span>(contents: contents)</span><br><span class=\"line\">view.addSubview(scrollView.build())</span><br></pre></td></tr></table></figure>\n\n<p>为了让可读性更加好，我们可以模仿SwiftUI的DSL语法进行设计，这里就需要使用到Swift 5.4的新特性 Result Builder</p>\n<ol>\n<li><p>首先我们要添加一个容器结构体，因为从上到下写的<code>View</code>会被整成一个数组或者多参数传进来，所以要加一个容器把他们从上到下排列好，最后排列完了，再把这个容器放进去ScrollView中</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ViewContainer</span> : <span class=\"title\">ViewBuilder</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> contents : [<span class=\"type\">ViewBuilder</span>]</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>()</span> -&gt; <span class=\"type\">UIView</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">let</span> container <span class=\"operator\">=</span> <span class=\"type\">UIView</span>(frame: <span class=\"type\">UIScreen</span>.main.bounds)</span><br><span class=\"line\">         <span class=\"keyword\">_</span> <span class=\"operator\">=</span> contents.reduce(<span class=\"type\">CGFloat</span>(<span class=\"number\">0</span>), &#123; currentY, builder <span class=\"keyword\">in</span></span><br><span class=\"line\">             <span class=\"keyword\">let</span> view <span class=\"operator\">=</span> builder.build()</span><br><span class=\"line\">             view.frame.origin.y <span class=\"operator\">=</span> currentY</span><br><span class=\"line\">             container.addSubview(view)</span><br><span class=\"line\">             container.frame.size <span class=\"operator\">=</span> <span class=\"type\">CGSize</span>(width: <span class=\"type\">UIScreen</span>.main.bounds.size.width, height: container.subviews.last<span class=\"operator\">!</span>.frame.maxY)</span><br><span class=\"line\">             <span class=\"keyword\">return</span> currentY <span class=\"operator\">+</span> view.frame.size.height</span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\">         <span class=\"keyword\">return</span> container</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个Result builder，使用<code>@resultBuilder</code>注解会要求我们添加一个<code>buildBlock</code>方法，实现这个方法，把我们外面传进来的多个View放进去<code>VieContainer</code>容器中，然后实现<code>buildFinalResult</code>在编写结束的时候把<br><code>VieContainer</code>放进去<code>ScrollView</code>容器中</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@resultBuilder</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ScrollableViewBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildBlock</span>(<span class=\"keyword\">_</span> <span class=\"params\">components</span>: <span class=\"type\">ViewBuilder</span>...)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">ViewContainer</span>(contents: components)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildFinalResult</span>(<span class=\"keyword\">_</span> <span class=\"params\">component</span>: <span class=\"type\">ViewBuilder</span>)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">ScrollableContainer</span>(contents: [component])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这时候我们通过新增的<code>ScrollableViewBuilder</code>来创建一个方法，这里的闭包就是待会我们要写DSL的地方</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>(<span class=\"meta\">@ScrollableViewBuilder</span> <span class=\"params\">content</span>: () -&gt; <span class=\"type\">ViewBuilder</span>)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> content()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 这个方法传入一个闭包，这个由于我们已经实现了<code>buildBlock</code>，所以<code>content</code>被<code>@ScrollableViewBuilder</code>修饰之后，会自动将闭包内的东西转化成多参数，传入<code>buildBlock</code>方法，在那里面我们把各种各样的<code>View</code>给添加到<code>ViewContainer</code>上，方法调用如下</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> build &#123;</span><br><span class=\"line\">    <span class=\"type\">RedView</span>()</span><br><span class=\"line\">    <span class=\"type\">BlueView</span>()</span><br><span class=\"line\">    <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">view.addSubview(result.build())</span><br></pre></td></tr></table></figure>\n\n<p> 这时候运行效果同上图一致</p>\n</li>\n<li><p>接下来我们需要让这个闭包内支持if语句、else if语句、else语句和for语句，</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ScrollableViewBuilder</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildBlock</span>(<span class=\"keyword\">_</span> <span class=\"params\">components</span>: <span class=\"type\">ViewBuilder</span>...)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"type\">ScrollableContainer</span>(contents: components)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/// 表示if语句</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildEither</span>(<span class=\"params\">first</span> <span class=\"params\">component</span>: <span class=\"type\">ViewBuilder</span>)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> component</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/// 表示eles if语句</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildEither</span>(<span class=\"params\">second</span> <span class=\"params\">component</span>: <span class=\"type\">ViewBuilder</span>)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> component</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/// 表示else语句和其他的可选值（即？修饰的View）</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildOptional</span>(<span class=\"keyword\">_</span> <span class=\"params\">component</span>: <span class=\"type\">ViewBuilder</span>?)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> component <span class=\"operator\">??</span> <span class=\"type\">DefaultView</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 然后我们试一试这么写</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> flag <span class=\"operator\">=</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> build &#123;</span><br><span class=\"line\">    <span class=\"type\">RedView</span>()</span><br><span class=\"line\">    <span class=\"type\">BlueView</span>()</span><br><span class=\"line\">    <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag <span class=\"operator\">==</span> <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RedView</span>()</span><br><span class=\"line\">        <span class=\"type\">RedView</span>()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> flag <span class=\"operator\">==</span> <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">        <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">        <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> flag <span class=\"operator\">==</span> <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">BlueView</span>()</span><br><span class=\"line\">        <span class=\"type\">BlueView</span>()</span><br><span class=\"line\">        <span class=\"type\">BlueView</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 当flag = 1的时候，首先两个<code>RedView()</code>会先进入<code>buildBlock</code>方法，然后被包装成一个<code>ViewContainer</code>，然后再进去<code>buildEither(first component: ViewBuilder)</code>方法，这里我没处理就直接把传进来的值返回出去了</p>\n<p> 当flag = 2 或者 flag = 3 的时候，首先括号内的多个<code>GreenView()</code>会先进入<code>buildBlock</code>方法，然后被包装成一个<code>ViewContainer</code>，然后再进去<code>buildEither(second component: ViewBuilder)</code>方法，这里我没处理就直接把传进来的值返回出去了</p>\n<p> 当 flag 为其他值的时候，首先括号内的多个<code>BlueView()</code>会先进入<code>buildBlock</code>方法，然后被包装成一个<code>ViewContainer</code>，然后再进去<code>buildEither(second component: ViewBuilder)</code>方法。当没有写<code>eles</code>语句的时候，需要实现<code>buildOptional(_ component: ViewBuilder?)</code>方法，去处理没有进入<code>if</code>语句而导致的不返回<code>View</code>的情况，如果没有写<code>else</code>语句，那么不会进入<code>buildBlock</code>，会直接取空值情况下你返回的默认<code>View</code>。</p>\n</li>\n<li><p>处理for语句，比如这样</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> build &#123;</span><br><span class=\"line\">    <span class=\"type\">RedView</span>()</span><br><span class=\"line\">    <span class=\"type\">BlueView</span>()</span><br><span class=\"line\">    <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"keyword\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span><span class=\"operator\">...</span><span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">        <span class=\"type\">BlueView</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> <code>for</code>里面需要返回3个<code>GreenView+BlueView</code>，这里他每次调用for的括号里面的内容，都会走一遍<code>buildBlock</code>把里面的<code>GreenView+BlueView</code>封装成一个<code>ViewContainer</code>，所以这里会产生3个<code>ViewContainer</code>，最后这三个会变成一个数组，进入<code>buildArray</code>方法，再封装成一个<code>ViewContainer</code>，代码如下</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@resultBuilder</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ScrollableViewBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildBlock</span>(<span class=\"keyword\">_</span> <span class=\"params\">components</span>: <span class=\"type\">ViewBuilder</span>...)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">ViewContainer</span>(contents: components)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildEither</span>(<span class=\"params\">first</span> <span class=\"params\">component</span>: <span class=\"type\">ViewBuilder</span>)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> component</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildEither</span>(<span class=\"params\">second</span> <span class=\"params\">component</span>: <span class=\"type\">ViewBuilder</span>)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> component</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildOptional</span>(<span class=\"keyword\">_</span> <span class=\"params\">component</span>: <span class=\"type\">ViewBuilder</span>?)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> component <span class=\"operator\">??</span> <span class=\"type\">WhiteView</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildArray</span>(<span class=\"keyword\">_</span> <span class=\"params\">components</span>: [<span class=\"type\">ViewBuilder</span>])</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">ViewContainer</span>(contents: components)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildFinalResult</span>(<span class=\"keyword\">_</span> <span class=\"params\">component</span>: <span class=\"type\">ViewBuilder</span>)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">ScrollableContainer</span>(contents: [component])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>处理表达式，如果我们要在DSL里面插一些除了<code>View</code>之外的一些东西，那么就需要添加对应的处理方法，比如</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> build &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;a123&quot;</span>)</span><br><span class=\"line\">    <span class=\"type\">RedView</span>()</span><br><span class=\"line\">    <span class=\"type\">BlueView</span>()</span><br><span class=\"line\">    <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 针对这个<code>print</code>我们添加表达式处理</p>\n<p> ScrollableViewBuilder</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 针对正常的表达式，就直接返回</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildExpression</span>(<span class=\"keyword\">_</span> <span class=\"params\">expression</span>: <span class=\"type\">ViewBuilder</span>)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> expression</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 针对特殊的表达式，返回空View</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildExpression</span>(<span class=\"keyword\">_</span> <span class=\"params\">expression</span>: ())</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">EmptyBuilder</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> EmptyBuilder</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EmptyBuilder</span> : <span class=\"title\">ViewBuilder</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>()</span> -&gt; <span class=\"type\">UIView</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"type\">UIView</span>.<span class=\"keyword\">init</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到这里就说的差不多了，其他本文没提及到的内容可以参阅<a href=\"https://developer.apple.com/videos/play/wwdc2021/10253/\">Write a DSL in Swift using result builders</a></p>\n<p>本文<a href=\"https://github.com/Arc-lin/ResultBuilderDemo\">Demo</a>地址</p>\n","site":{"data":{}},"excerpt":"<p>本文主要讲述Swift 5.4的新特性 Result Builder在设计上的一些使用方式</p>","more":"<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><p>假如我们有一个需求，需要往ScrollView上加入不同类型的View，并且根据不确定的的顺序从上往下进行排列，所以一般情况下我们可以这样子设计框架</p>\n<ol>\n<li>首先定义一个协议，遵循协议的对象使用一个build方法返回一个View</li>\n</ol>\n  <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">ViewBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>()</span> -&gt; <span class=\"type\">UIView</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>这里我们设计四种颜色的View，宽度均为屏幕宽度，高度不定</li>\n</ol>\n  <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">WhiteView</span> : <span class=\"title\">ViewBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>()</span> -&gt; <span class=\"type\">UIView</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> view <span class=\"operator\">=</span> <span class=\"type\">UIView</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"type\">UIScreen</span>.main.bounds.width, height: <span class=\"number\">100</span>))</span><br><span class=\"line\">        view.backgroundColor <span class=\"operator\">=</span> .white</span><br><span class=\"line\">        <span class=\"keyword\">return</span> view</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">RedView</span> : <span class=\"title\">ViewBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>()</span> -&gt; <span class=\"type\">UIView</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> banner <span class=\"operator\">=</span> <span class=\"type\">UIView</span>.<span class=\"keyword\">init</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"type\">UIScreen</span>.main.bounds.width, height: <span class=\"number\">200</span>))</span><br><span class=\"line\">        banner.backgroundColor <span class=\"operator\">=</span> <span class=\"type\">UIColor</span>.red</span><br><span class=\"line\">        <span class=\"keyword\">return</span> banner</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BlueView</span> : <span class=\"title\">ViewBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>()</span> -&gt; <span class=\"type\">UIView</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> goodsView <span class=\"operator\">=</span> <span class=\"type\">UIView</span>.<span class=\"keyword\">init</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"type\">UIScreen</span>.main.bounds.width, height: <span class=\"number\">350</span>))</span><br><span class=\"line\">        goodsView.backgroundColor <span class=\"operator\">=</span> <span class=\"type\">UIColor</span>.blue</span><br><span class=\"line\">        <span class=\"keyword\">return</span> goodsView</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">GreenView</span> : <span class=\"title\">ViewBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>()</span> -&gt; <span class=\"type\">UIView</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> dynamicView <span class=\"operator\">=</span> <span class=\"type\">UIView</span>.<span class=\"keyword\">init</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"type\">UIScreen</span>.main.bounds.width, height: <span class=\"number\">400</span>))</span><br><span class=\"line\">        dynamicView.backgroundColor <span class=\"operator\">=</span> <span class=\"type\">UIColor</span>.green</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dynamicView</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li><p>最后我们再定义一个ScrollView的容器，传入一个数组，让其从上到下进行排列</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ScrollableContainer</span> : <span class=\"title\">ViewBuilder</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> contents : [<span class=\"type\">ViewBuilder</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>()</span> -&gt; <span class=\"type\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> scrollView <span class=\"operator\">=</span> <span class=\"type\">UIScrollView</span>.<span class=\"keyword\">init</span>(frame: <span class=\"type\">UIScreen</span>.main.bounds)</span><br><span class=\"line\">    <span class=\"keyword\">_</span> <span class=\"operator\">=</span> contents.reduce(<span class=\"type\">CGFloat</span>(<span class=\"number\">0</span>)) &#123; currentY, builder <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> view <span class=\"operator\">=</span> builder.build()</span><br><span class=\"line\">        view.frame.origin.y <span class=\"operator\">=</span> currentY</span><br><span class=\"line\">        scrollView.addSubview(view)</span><br><span class=\"line\">        scrollView.contentSize <span class=\"operator\">=</span> <span class=\"type\">CGSize</span>(width: <span class=\"type\">UIScreen</span>.main.bounds.size.width, height: scrollView.subviews.last<span class=\"operator\">!</span>.frame.maxY)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentY <span class=\"operator\">+</span> view.frame.size.height</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> scrollView</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这样子我们就可以开始布局了</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> scrollView <span class=\"operator\">=</span> <span class=\"type\">ScrollableContainer</span>(contents: [</span><br><span class=\"line\">    <span class=\"type\">RedView</span>(),</span><br><span class=\"line\">    <span class=\"type\">BlueView</span>(),</span><br><span class=\"line\">    <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">])</span><br><span class=\"line\">view.addSubview(scrollView.build())</span><br></pre></td></tr></table></figure>\n<p> 效果如下</p>\n <img src=\"https://p6-tt.byteimg.com/origin/pgc-image/8f8201d352eb44a7aab4b0b68ba6e9e2.png\" width=50%>\n </li>\n<li><p>通过这种方式，我们就可以随意调整内部的布局顺序，也可以方便的新增多个View</p>\n</li>\n</ol>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>但是上述方法有一个缺点，就是当如果要重复添加多个相同的View或者说想要通过某个条件再添加View，就会有点复杂，比如当<code>needBlue == true</code>成立的时候再添加<code>BlueView</code>，那么可能需要这么写</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> contents <span class=\"operator\">=</span> [</span><br><span class=\"line\">    <span class=\"type\">RedView</span>(),</span><br><span class=\"line\">    <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> needBlue <span class=\"operator\">==</span> <span class=\"literal\">true</span> &#123;</span><br><span class=\"line\">\tcontents <span class=\"operator\">=</span> [</span><br><span class=\"line\">        <span class=\"type\">RedView</span>(),</span><br><span class=\"line\">        <span class=\"type\">BlueView</span>(),</span><br><span class=\"line\">        <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> scrollView <span class=\"operator\">=</span> <span class=\"type\">ScrollableContainer</span>(contents: contents)</span><br><span class=\"line\">view.addSubview(scrollView.build())</span><br></pre></td></tr></table></figure>\n\n<p>为了让可读性更加好，我们可以模仿SwiftUI的DSL语法进行设计，这里就需要使用到Swift 5.4的新特性 Result Builder</p>\n<ol>\n<li><p>首先我们要添加一个容器结构体，因为从上到下写的<code>View</code>会被整成一个数组或者多参数传进来，所以要加一个容器把他们从上到下排列好，最后排列完了，再把这个容器放进去ScrollView中</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ViewContainer</span> : <span class=\"title\">ViewBuilder</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> contents : [<span class=\"type\">ViewBuilder</span>]</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>()</span> -&gt; <span class=\"type\">UIView</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">let</span> container <span class=\"operator\">=</span> <span class=\"type\">UIView</span>(frame: <span class=\"type\">UIScreen</span>.main.bounds)</span><br><span class=\"line\">         <span class=\"keyword\">_</span> <span class=\"operator\">=</span> contents.reduce(<span class=\"type\">CGFloat</span>(<span class=\"number\">0</span>), &#123; currentY, builder <span class=\"keyword\">in</span></span><br><span class=\"line\">             <span class=\"keyword\">let</span> view <span class=\"operator\">=</span> builder.build()</span><br><span class=\"line\">             view.frame.origin.y <span class=\"operator\">=</span> currentY</span><br><span class=\"line\">             container.addSubview(view)</span><br><span class=\"line\">             container.frame.size <span class=\"operator\">=</span> <span class=\"type\">CGSize</span>(width: <span class=\"type\">UIScreen</span>.main.bounds.size.width, height: container.subviews.last<span class=\"operator\">!</span>.frame.maxY)</span><br><span class=\"line\">             <span class=\"keyword\">return</span> currentY <span class=\"operator\">+</span> view.frame.size.height</span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\">         <span class=\"keyword\">return</span> container</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建一个Result builder，使用<code>@resultBuilder</code>注解会要求我们添加一个<code>buildBlock</code>方法，实现这个方法，把我们外面传进来的多个View放进去<code>VieContainer</code>容器中，然后实现<code>buildFinalResult</code>在编写结束的时候把<br><code>VieContainer</code>放进去<code>ScrollView</code>容器中</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@resultBuilder</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ScrollableViewBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildBlock</span>(<span class=\"keyword\">_</span> <span class=\"params\">components</span>: <span class=\"type\">ViewBuilder</span>...)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">ViewContainer</span>(contents: components)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildFinalResult</span>(<span class=\"keyword\">_</span> <span class=\"params\">component</span>: <span class=\"type\">ViewBuilder</span>)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">ScrollableContainer</span>(contents: [component])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这时候我们通过新增的<code>ScrollableViewBuilder</code>来创建一个方法，这里的闭包就是待会我们要写DSL的地方</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>(<span class=\"meta\">@ScrollableViewBuilder</span> <span class=\"params\">content</span>: () -&gt; <span class=\"type\">ViewBuilder</span>)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> content()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 这个方法传入一个闭包，这个由于我们已经实现了<code>buildBlock</code>，所以<code>content</code>被<code>@ScrollableViewBuilder</code>修饰之后，会自动将闭包内的东西转化成多参数，传入<code>buildBlock</code>方法，在那里面我们把各种各样的<code>View</code>给添加到<code>ViewContainer</code>上，方法调用如下</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> build &#123;</span><br><span class=\"line\">    <span class=\"type\">RedView</span>()</span><br><span class=\"line\">    <span class=\"type\">BlueView</span>()</span><br><span class=\"line\">    <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">view.addSubview(result.build())</span><br></pre></td></tr></table></figure>\n\n<p> 这时候运行效果同上图一致</p>\n</li>\n<li><p>接下来我们需要让这个闭包内支持if语句、else if语句、else语句和for语句，</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ScrollableViewBuilder</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildBlock</span>(<span class=\"keyword\">_</span> <span class=\"params\">components</span>: <span class=\"type\">ViewBuilder</span>...)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"type\">ScrollableContainer</span>(contents: components)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/// 表示if语句</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildEither</span>(<span class=\"params\">first</span> <span class=\"params\">component</span>: <span class=\"type\">ViewBuilder</span>)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> component</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/// 表示eles if语句</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildEither</span>(<span class=\"params\">second</span> <span class=\"params\">component</span>: <span class=\"type\">ViewBuilder</span>)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> component</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/// 表示else语句和其他的可选值（即？修饰的View）</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildOptional</span>(<span class=\"keyword\">_</span> <span class=\"params\">component</span>: <span class=\"type\">ViewBuilder</span>?)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> component <span class=\"operator\">??</span> <span class=\"type\">DefaultView</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 然后我们试一试这么写</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> flag <span class=\"operator\">=</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> build &#123;</span><br><span class=\"line\">    <span class=\"type\">RedView</span>()</span><br><span class=\"line\">    <span class=\"type\">BlueView</span>()</span><br><span class=\"line\">    <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> flag <span class=\"operator\">==</span> <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RedView</span>()</span><br><span class=\"line\">        <span class=\"type\">RedView</span>()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> flag <span class=\"operator\">==</span> <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">        <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">        <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> flag <span class=\"operator\">==</span> <span class=\"number\">3</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">BlueView</span>()</span><br><span class=\"line\">        <span class=\"type\">BlueView</span>()</span><br><span class=\"line\">        <span class=\"type\">BlueView</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 当flag = 1的时候，首先两个<code>RedView()</code>会先进入<code>buildBlock</code>方法，然后被包装成一个<code>ViewContainer</code>，然后再进去<code>buildEither(first component: ViewBuilder)</code>方法，这里我没处理就直接把传进来的值返回出去了</p>\n<p> 当flag = 2 或者 flag = 3 的时候，首先括号内的多个<code>GreenView()</code>会先进入<code>buildBlock</code>方法，然后被包装成一个<code>ViewContainer</code>，然后再进去<code>buildEither(second component: ViewBuilder)</code>方法，这里我没处理就直接把传进来的值返回出去了</p>\n<p> 当 flag 为其他值的时候，首先括号内的多个<code>BlueView()</code>会先进入<code>buildBlock</code>方法，然后被包装成一个<code>ViewContainer</code>，然后再进去<code>buildEither(second component: ViewBuilder)</code>方法。当没有写<code>eles</code>语句的时候，需要实现<code>buildOptional(_ component: ViewBuilder?)</code>方法，去处理没有进入<code>if</code>语句而导致的不返回<code>View</code>的情况，如果没有写<code>else</code>语句，那么不会进入<code>buildBlock</code>，会直接取空值情况下你返回的默认<code>View</code>。</p>\n</li>\n<li><p>处理for语句，比如这样</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> build &#123;</span><br><span class=\"line\">    <span class=\"type\">RedView</span>()</span><br><span class=\"line\">    <span class=\"type\">BlueView</span>()</span><br><span class=\"line\">    <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"keyword\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span><span class=\"operator\">...</span><span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">        <span class=\"type\">BlueView</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> <code>for</code>里面需要返回3个<code>GreenView+BlueView</code>，这里他每次调用for的括号里面的内容，都会走一遍<code>buildBlock</code>把里面的<code>GreenView+BlueView</code>封装成一个<code>ViewContainer</code>，所以这里会产生3个<code>ViewContainer</code>，最后这三个会变成一个数组，进入<code>buildArray</code>方法，再封装成一个<code>ViewContainer</code>，代码如下</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@resultBuilder</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ScrollableViewBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildBlock</span>(<span class=\"keyword\">_</span> <span class=\"params\">components</span>: <span class=\"type\">ViewBuilder</span>...)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">ViewContainer</span>(contents: components)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildEither</span>(<span class=\"params\">first</span> <span class=\"params\">component</span>: <span class=\"type\">ViewBuilder</span>)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> component</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildEither</span>(<span class=\"params\">second</span> <span class=\"params\">component</span>: <span class=\"type\">ViewBuilder</span>)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> component</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildOptional</span>(<span class=\"keyword\">_</span> <span class=\"params\">component</span>: <span class=\"type\">ViewBuilder</span>?)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> component <span class=\"operator\">??</span> <span class=\"type\">WhiteView</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildArray</span>(<span class=\"keyword\">_</span> <span class=\"params\">components</span>: [<span class=\"type\">ViewBuilder</span>])</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">ViewContainer</span>(contents: components)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildFinalResult</span>(<span class=\"keyword\">_</span> <span class=\"params\">component</span>: <span class=\"type\">ViewBuilder</span>)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">ScrollableContainer</span>(contents: [component])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>处理表达式，如果我们要在DSL里面插一些除了<code>View</code>之外的一些东西，那么就需要添加对应的处理方法，比如</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> build &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;a123&quot;</span>)</span><br><span class=\"line\">    <span class=\"type\">RedView</span>()</span><br><span class=\"line\">    <span class=\"type\">BlueView</span>()</span><br><span class=\"line\">    <span class=\"type\">GreenView</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 针对这个<code>print</code>我们添加表达式处理</p>\n<p> ScrollableViewBuilder</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 针对正常的表达式，就直接返回</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildExpression</span>(<span class=\"keyword\">_</span> <span class=\"params\">expression</span>: <span class=\"type\">ViewBuilder</span>)</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> expression</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 针对特殊的表达式，返回空View</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildExpression</span>(<span class=\"keyword\">_</span> <span class=\"params\">expression</span>: ())</span> -&gt; <span class=\"type\">ViewBuilder</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">EmptyBuilder</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> EmptyBuilder</p>\n <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EmptyBuilder</span> : <span class=\"title\">ViewBuilder</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">build</span>()</span> -&gt; <span class=\"type\">UIView</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"type\">UIView</span>.<span class=\"keyword\">init</span>()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>到这里就说的差不多了，其他本文没提及到的内容可以参阅<a href=\"https://developer.apple.com/videos/play/wwdc2021/10253/\">Write a DSL in Swift using result builders</a></p>\n<p>本文<a href=\"https://github.com/Arc-lin/ResultBuilderDemo\">Demo</a>地址</p>"},{"title":"iOS 底层原理 -- Runloop","author":"Arclin","abbrlink":"fee6666f","date":"2021-07-21T14:10:50.000Z","_content":"本文讲述iOS中Runloop的一些使用以及原理\n\n<!--more-->\n\n## Runloop对象\n\n- iOS中有两套API来访问和使用Runloop\n\t- Foundation : NSRunLoop\n    - Core Foundation : CFRunloopRef\n \n- NSRunloop和CFRunloopRef都代表着Runloop对象\n- NSRunloop是基于CFRunloopRef的一层OC包装\n- CFRunloopRef是开源的\n\n获取当前Runloop的两个方法\n\n```objective-c\nNSRunLoop *runloop = [NSRunLoop currentRunLoop];\nCFRunLoopRef runloopRef = CFRunLoopGetCurrent();\n```\n\n打印runloop可以发现类型是`<CFRunLoop 0x600001994300 [0x101405a98]>`，跟runloopRef一致，但是打印地址不一样，原因是`NSRunLoop`是对`CFRunLoopRef`的封装，`CFRunLoopRef`是存储在其内部，所以会不一样\n\n## Runloop与线程\n\n- 每条线程都有唯一的一个与之对应的Runloop对象\n\n- Runloop保存在一个全局的Dictionary里，线程作为key，Runloop作为Value\n\t- Runloop源码 `CFRunloop.c`中我们可以找到`CFRunLoopGetCurrent()`内调用了`_CFRunLoopGet0()`，在这里面可以看到这行代码得以验证\n    \n    ```\n    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));\n    ```\n\n- 线程刚创建的时候并没有Runloop对象，Runloop会在第一次获取它时创建\n\n\t- 主线程一开始也是没有Runloop的，只是因为在`main.m`中调用了`UIApplicationMain`函数，在这里面回去获取Runloop从而创建了Runloop\n    - 对应源码如下\n    \n    ```objectivec\n    CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) {\n        ...\n         if (!loop) {\n            CFRunLoopRef newLoop = __CFRunLoopCreate(t);\n            __CFLock(&loopsLock);\n            loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops,pthreadPointer(t));\n            if (!loop) {\n                CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);\n                loop = newLoop;\n            }\n             __CFUnlock(&loopsLock);\n\t \t    CFRelease(newLoop);\n        }\n        ...\n    }\n    ```\n   \n- Runloop会在线程结束时销毁\n- 主线程的Runloop已经自动获取（创建），子线程默认没有开启Runloop\n\n\n## Runloop相关的类\n\nCore Foundation 中关于Runloop的5个类\n\n- CFRunloopRef\n- CFRunloopModeRef\n- CFRunloopSourceRef\n- CFRunloopTimerRef\n- CFRunloopObserverRef\n\n```objectivec\ntypedef struct __CFRunLoop * CFRunloopRef;\n\nstruct __CFRunLoop {\n    ...\n    pthread_t _pthread;\n    CFMutableSetRef _commonModes;\n    CFMutableSetRef _commonModeItems;\n    CFRunloopModeRef _currentMode;\n    CFMutableSetRef _modes;\n    ...\n};\n\ntypedef struct __CFRunLoopMode *CFRunLoopModeRef;\n\nstruct __CFRunLoopMode {\n    ...\n    CFStringRef _name;\n    CFMutableSetRef _sources0; // CFRunloopSourceRef数组\n    CFMutableSetRef _sources1; // CFRunloopSourceRef数组\n    CFMutableArrayRef _observers; // CFRunloopObserverRef数组\n    CFMutableArrayRef _timers; // CFRunloopTimerRef数组 \n    ...\n}\n```\n\n通过源码我们可以得知，一个Runloop对象里面有多个mode，存放在`_modes`成员属性里面。其中有一个mode是`_currentMode`。 然后每个mode都有`name`、`source0`、`source1`等数组属性\n\n- CFRunloopModeRef 代表Runloop的运行模式\n- Runloop启动只能选择其中一个Mode作为currentMode\n- 如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入\n\t- 不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响\n- 如果Mode里面没有任何Source0/Source1/Timer/Observer，Runloop会立马退出\n\n### CFRunloopModeRef\n\n- 两种常见的Mode\n\t- `kCFRunLoopDefaultMode`（`NSDefaultRunloopMode`）: App的默认Mode，通常主线程是在这个Mode下运行\n    - `UITrackingRunLoopMode`界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响\n\n- Source0\n\t- 触摸事件处理\n    - `performSelector:onThread:`\n\n- Source1\n\t- 基于Port的线程间通信\n    - 系统事件捕捉（捕捉后到Source0去处理）\n    \n- Timers\n\t- NSTimer\n    - `performSelector:withObject:afterDelay:`\n\n- Observers\n\t- 用于监听Runloop的状态\n    - UI刷新（BeforeWaiting）在Runloop休眠之前会执行一次UI刷新\n    - Autorelease pool 在Runloop休眠之前自动释放某些内存\n    \n    \n### CFRunloopObserverRef\n\nRunloop的几种状态\n\n```objectivec\n/* Run Loop Observer Activities */\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),         // 即将进入Loop \n    kCFRunLoopBeforeTimers = (1UL << 1),  // 即将处理Timer\n    kCFRunLoopBeforeSources = (1UL << 2), // 即将处理Source\n    kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠\n    kCFRunLoopAfterWaiting = (1UL << 6),  // 刚从休眠中唤醒\n    kCFRunLoopExit = (1UL << 7),          // 即将退出Loop\n    kCFRunLoopAllActivities = 0x0FFFFFFFU\n};\n```\n\n我们可以自己添加一个监听者来监听Runloop的状态变化\n\n1. 定义监听回调\n\n  ```objectivec\n  void observeRunLoopActivities(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) {\n      switch (activity) {\n          case kCFRunLoopEntry:\n              NSLog(@\"kCFRunLoopEntry\");\n              break;\n          case kCFRunLoopBeforeTimers:\n              NSLog(@\"kCFRunLoopBeforeTimers\");\n              break;\n          case kCFRunLoopBeforeSources:\n              NSLog(@\"kCFRunLoopBeforeSources\");\n              break;\n          case kCFRunLoopBeforeWaiting:\n              NSLog(@\"kCFRunLoopBeforeWaiting\");\n              break;\n          case kCFRunLoopAfterWaiting:\n              NSLog(@\"kCFRunLoopAfterWaiting\");\n              break;\n          case kCFRunLoopExit:\n              NSLog(@\"kCFRunLoopExit\");\n              break;\n          default:\n              break;\n      }\n  }\n  ```\n\n2. 创建监听者\n\n  ```objectivec\n  /// 创建Observer\n  CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, observeRunLoopActivities, NULL);\n  /// 添加Observer\n  CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n  CFRelease(observer);\n  ```\n  \n## Runloop的运行逻辑\n\n\n### 流程分析\n\n1. 通知Observers：进入Loop\n2. 通知Observers：即将处理Timers\n3. 通知Observers：即将处理Sources\n4. 处理Blocks（特指执行CFRunLoopPerformBlock内的block参数）\n\t```\n    CFRunLoopPerformBlock(CFRunLoopGetCurrent(), kCFRunLoopCommonModes, ^{\n        \n    });\n    ```\n5. 处理Source0（可能会再次处理Blocks，因为有可能在处理Source0的时候添加了Blocks）\n6. 如果存在Source1，就跳转到第8步\n7. 通知Observers：开始休眠（等待消息唤醒）\n8. 通知Observers：结束休眠（被某个消息唤醒，被什么东西唤醒就处理什么东西）\n\t- 处理Timer\n    - 处理GCD Async To Main Queue\n    - 处理Source1\n9. 处理Blocks\n10. 根据前面的执行结果，决定如何操作（如下几种可能）\n\t1. 回到第2步\n    2. 退出Loop\n11. 通知Observers：退出Loop\n\n### 源码分析\n\n通过在控制台执行命令`bt`我们可以看到开始是调用了`CFRunLoopRunSpecific`函数，核心源码如下\n\n```objectivec\nSInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     /* DOES CALLOUT */\n    \n    ...\n    /// 通知Observers：进入Loop\n\t__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);\n    \n    /// 具体要做的事情\n\tresult = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);\n\t\n    /// 通知Observers：退出Loop\n    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);\n\n    ...\n    return result;\n}\n\n```\n\n然后查看一下`__CFRunLoopRun`内的核心处理代码\n\n```objectivec\nstatic int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {\n    ...\n    int32_t retVal = 0;\n    do {\n        \n        /// 通知Observers：即将处理Timers\n        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);\n        \n        /// 通知Observers：即将处理Sources\n         __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);\n        \n        /// 处理Blocks\n        __CFRunLoopDoBlocks(rl, rlm);\n        \n        /// 处理Source0\n        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);\n        if (sourceHandledThisLoop) {\n            /// 处理Blocks\n            __CFRunLoopDoBlocks(rl, rlm);\n        }\n        \n        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context->termTSR);\n        \n        /// 判断有无Source1\n        if (__CFRunLoopServiceMachPort(dispatchPort, &msg, sizeof(msg_buffer), &livePort, 0, &voucherState, NULL)) {\n            /// 如果有Source1，就跳转到handle_msg\n            goto handle_msg;\n        }\n        \n        /// 通知Observers：即将休眠\n        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);\n        __CFRunLoopSetSleeping(rl);\n        \n        do {\n            /// 等待别的消息来唤醒当前线程\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);\n        } while (1);\n        \n        __CFRunLoopSetIgnoreWakeUps(rl);\n        \n        __CFRunLoopUnsetSleeping(rl);\n        /// 通知Observers：结束休眠\n        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);\n        \n    handle_msg:;\n        /// 被Timer唤醒\n        if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            /// 处理Timers\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                // Re-arm the next timer, because we apparently fired early\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n        /// 被GCD唤醒\n        } else if (livePort == dispatchPort) {\n            CFRUNLOOP_WAKEUP_FOR_DISPATCH();\n            /// 处理GCD\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n        } else { /// 被Source1唤醒\n            CFRUNLOOP_WAKEUP_FOR_SOURCE();\n            /// 处理Source1\n            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply) || sourceHandledThisLoop;\n            \n        }\n        \n        /// 处理Blocks\n        __CFRunLoopDoBlocks(rl, rlm);\n        \n        /// 设置返回值\n        if (sourceHandledThisLoop && stopAfterHandle) {\n            retVal = kCFRunLoopRunHandledSource;\n        } else if (timeout_context->termTSR < mach_absolute_time()) {\n            retVal = kCFRunLoopRunTimedOut;\n        } else if (__CFRunLoopIsStopped(rl)) {\n            __CFRunLoopUnsetStopped(rl);\n            retVal = kCFRunLoopRunStopped;\n        } else if (rlm->_stopped) {\n            rlm->_stopped = false;\n            retVal = kCFRunLoopRunStopped;\n        } else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {\n            retVal = kCFRunLoopRunFinished;\n        }\n        \n    } while (0 == retVal);\n    \n    return retVal;\n}\n```\n\n执行顺序跟我们上面提及的执行流程是相似的，最后的返回值如果是0的话，那么就继续循环，如果是其他值，那么就会退出循环，继而退出Runloop\n\n\n上面提及的处理Timers函数，处理GCD函数和处理Source1的函数，都会调用到`__CFRUNLOOP_IS_CALLING_OUT_TO_A_xxx_FUNCTION__`这个函数(这个xxx代表Observer、Block、Source0或者Timer等，见下表)，在这个函数里面，再去执行对应的操作，比如UIKit的界面刷新、Foundation定时器的执行\n\n|执行的事情|调用的函数|\n|---|---|\n|进入Loop|__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__|\n|处理Blocks|__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__|\n|处理Source0|__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__|\n|处理Timer|__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__|\n|处理GCD|__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__|\n|处理SOURCE1|__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__|\n\nGCD只有在回调到主线程的时候才会调用到Runloop的函数，比如下面这种情况 \n\n```objectivec\ndispatch_async(dispatch_get_global_queue(0,0), ^{\n    dispatch_async(dispatch_get_main_queue(), ^{\n    \t...\n    });\n});\n```\n\n### Runloop休眠的实现原理\n\n当Runloop需要休眠的时候，会调用用户态的API，然后内部调用mach_msg()切换到内核态，当有消息的时候，就会从内核态切换回用户态的API去处理消息\n\n用户态 ： mach_msg() -> 内核态： mach_msg() -> 用户态：处理消息\n\n内核态：\n1. 等待消息\n2. 没有消息就让线程休眠\n3. 有消息就唤醒线程\n\n## NSTimer\n\n由于NSTimer默认是运行在`NSDefaultRunloopMode`的，所以在滚动的时候不会执行定时器，因为滚动的时候系统会切换到`UITrackingRunLoopMode`\n\n这时候我们需要把NSTimer设置到`NSRunLoopCommonModes`里，如下\n\n```objectivec\nstatic int count = 0;\nNSTimer *timer = [NSTimer timerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {\n    NSLog(@\"%d\",++count);\n}];\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n```\n\n`NSDefaultRunloopMode`、`UITrackingRunLoopMode`才是真正存在的模式\n\n`NSRunLoopCommonModes`并不是一个真的模式，它只是一个标记\n\ntimer能在`_commonModes`数组中存放的模式下工作\n\n```objectivec\nstruct __CFRunLoop {\n    ...\n    pthread_t _pthread;\n    CFMutableSetRef _commonModes; // 存放着NSDefaultRunloopMod，UITrackingRunLoopMode\n    CFMutableSetRef _commonModeItems; // 存放着common模式下要处理的对象，比如上面的timer\n    CFRunloopModeRef _currentMode;\n    CFMutableSetRef _modes; \t// 存放着所有的模式\n    ...\n};\n```\n\n## 线程保活\n\n### 基本原理\n\n\n一般情况下，我们创建线程后，当线程的任务执行完了，线程就会销毁，所以有时候我们需要让线程执行完任务后依旧存在，等到我们主动让他销毁他才会销毁。\n\n首先我们创建一条线程\n\n```objectivec\nself.thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];\n```\n\n要让这条线程一直活着，我们可以让这个`run`方法不要结束\n\n这里添加一个Runloop，由于获取Runloop的时候就会创建Runloop，所以我们获取Runloop即可，然后调用`addPort:forMode:`方法，添加一个`Source0`\n\n这样子线程就会卡在`[[NSRunLoop currentRunLoop] run];`这一行中，不会让方法执行完，线程也就不会销毁\n\n```objectivec\n- (void)run {\n    NSLog(@\"%@ %s begin\",NSThread.currentThread,__func__);\n    [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n    [[NSRunLoop currentRunLoop] run];\n    /// 不会走到这里\n    NSLog(@\"%@ %s end\",NSThread.currentThread,__func__);\n}\n```\n\n然后下一步我们需要调用一个方法去销毁这个线程，比如`CFRunLoopStop(CFRunLoopGetCurrent())`，但是如果我们这么做\n\n```objectivec\n- (void)stop {\n    CFRunLoopStop(CFRunLoopGetCurrent());\n}\n\n/// 尝试在我们指定的线程上停止这个线程内的Runloop\n[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];\n```\n\n发现线程不会销毁，原因是`[[NSRunLoop currentRunLoop] run];`执行后，会在一个死循环内执行Runloop的`runMode:beforeDate:`方法，类似于\n\n```objectivec\nwhile(1) {\n    [[NSRunLoop currentRunLoop] runMode: beforeDate:xxx];\n}\n```\n\n`CFRunLoopStop(CFRunLoopGetCurrent());`只是停止了其中的一次方法调用，进入下个循环后又会开启，所以用这个方法去完全停止Runloop是没用的\n\n所以我们要使用别的方式去替代`[[NSRunLoop currentRunLoop] run];`开启线程，因为这个`run`方法是专门用于开启一个永不销毁的线程。\n\n只需要改造一下上面那个while方法就好，给self添加一个bool属性\n\n```objectivec\n\n@property(nonatomic,assign) BOOL isStop;\n\n- (void)run {\n    NSLog(@\"%@ %s begin\",NSThread.currentThread,__func__);\n    [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n    while(!self.isStop) {\n\t\t[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n\t}\n    NSLog(@\"%@ %s end\",NSThread.currentThread,__func__);\n}\n\n- (void)stop {\n    self.isStop = YES;\n    CFRunLoopStop(CFRunLoopGetCurrent());\n}\n\n```\n\n这样子我们调用run方法线程就会启动，调用stop方法，while循环就会退出，`CFRunLoopStop(CFRunLoopGetCurrent());`停止了本次RunLoop，Runloop退出，这样子就能走到打印end那里，线程的方法走完了，线程就可以销毁了\n\n### 封装\n\n```objectivec\n@interface MyThread : NSObject\n\n/// 开启线程\n- (void)run;\n\n/// 销毁线程\n- (void)stop;\n\n/// 执行任务\n- (void)executeTask:(void(^)(void))block;\n\n@end\n\n@interface MyThread()\n\n@property (nonatomic, strong) Thread *innerThread;\n\n@property (nonatomic, assign, getter=isStopped) BOOL stopped;\n\n@end\n\n@implementation MyThread\n\n- (instancetype)init {\n    if (self = [super init]) {\n        \n        __weak typeof(self) weakSelf = self;\n        \n        /// 创建线程 开启Runloop\n        self.innerThread = [[Thread alloc] initWithBlock:^{\n            [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n            \n            /// 因为dealloc的时候weakSelf已经空了，所以要明确self存在并且不停止时候，才循环启动Runloop\n            while (weakSelf && !weakSelf.isStopped) {\n                [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n            }\n        }];\n    }\n    return self;\n}\n\n- (void)run {\n    if (!self.innerThread) return;\n    \n    /// 开启线程，启动Runloop\n    [self.innerThread start];\n}\n\n- (void)stop {\n    if (!self.innerThread) return;\n    \n    /// 停止线程\n    [self performSelector:@selector(__stop) onThread:self.innerThread withObject:nil waitUntilDone:YES];\n}\n\n- (void)executeTask:(void (^)(void))block {\n    if (!self.innerThread || !block) return;\n    \n    /// 执行子线程任务\n    [self performSelector:@selector(__executeTask:) onThread:self.innerThread withObject:block waitUntilDone:NO];\n}\n\n#pragma mark - private method\n\n- (void)__stop {\n\n\t/// 标记需要退出Runloop\n    self.stopped = YES;\n    \n    /// 退出本次Runloop\n    CFRunLoopStop(CFRunLoopGetCurrent());\n    \n    /// 取消强引用\n    self.innerThread = nil;\n}\n\n- (void)__executeTask:(void (^)(void))block {\n    block();\n}\n\n- (void)dealloc {\n    /// 自动调用停止方法\n    [self stop];\n    NSLog(@\"%s\",__func__);\n}\n\n@end\n\n/// 只是为了监听线程的销毁行为\n@interface Thread : NSThread\n@end\n\n@implementation Thread\n\n- (void)dealloc {\n    NSLog(@\"%s\",__func__);\n}\n\n@end\n```","source":"_posts/iOS-底层原理-Runloop.md","raw":"title: iOS 底层原理 -- Runloop\nauthor: Arclin\nabbrlink: fee6666f\ntags:\n  - iOS\n  - 底层原理\ncategories:\n  - iOS\ndate: 2021-07-21 22:10:50\n---\n本文讲述iOS中Runloop的一些使用以及原理\n\n<!--more-->\n\n## Runloop对象\n\n- iOS中有两套API来访问和使用Runloop\n\t- Foundation : NSRunLoop\n    - Core Foundation : CFRunloopRef\n \n- NSRunloop和CFRunloopRef都代表着Runloop对象\n- NSRunloop是基于CFRunloopRef的一层OC包装\n- CFRunloopRef是开源的\n\n获取当前Runloop的两个方法\n\n```objective-c\nNSRunLoop *runloop = [NSRunLoop currentRunLoop];\nCFRunLoopRef runloopRef = CFRunLoopGetCurrent();\n```\n\n打印runloop可以发现类型是`<CFRunLoop 0x600001994300 [0x101405a98]>`，跟runloopRef一致，但是打印地址不一样，原因是`NSRunLoop`是对`CFRunLoopRef`的封装，`CFRunLoopRef`是存储在其内部，所以会不一样\n\n## Runloop与线程\n\n- 每条线程都有唯一的一个与之对应的Runloop对象\n\n- Runloop保存在一个全局的Dictionary里，线程作为key，Runloop作为Value\n\t- Runloop源码 `CFRunloop.c`中我们可以找到`CFRunLoopGetCurrent()`内调用了`_CFRunLoopGet0()`，在这里面可以看到这行代码得以验证\n    \n    ```\n    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));\n    ```\n\n- 线程刚创建的时候并没有Runloop对象，Runloop会在第一次获取它时创建\n\n\t- 主线程一开始也是没有Runloop的，只是因为在`main.m`中调用了`UIApplicationMain`函数，在这里面回去获取Runloop从而创建了Runloop\n    - 对应源码如下\n    \n    ```objectivec\n    CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) {\n        ...\n         if (!loop) {\n            CFRunLoopRef newLoop = __CFRunLoopCreate(t);\n            __CFLock(&loopsLock);\n            loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops,pthreadPointer(t));\n            if (!loop) {\n                CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);\n                loop = newLoop;\n            }\n             __CFUnlock(&loopsLock);\n\t \t    CFRelease(newLoop);\n        }\n        ...\n    }\n    ```\n   \n- Runloop会在线程结束时销毁\n- 主线程的Runloop已经自动获取（创建），子线程默认没有开启Runloop\n\n\n## Runloop相关的类\n\nCore Foundation 中关于Runloop的5个类\n\n- CFRunloopRef\n- CFRunloopModeRef\n- CFRunloopSourceRef\n- CFRunloopTimerRef\n- CFRunloopObserverRef\n\n```objectivec\ntypedef struct __CFRunLoop * CFRunloopRef;\n\nstruct __CFRunLoop {\n    ...\n    pthread_t _pthread;\n    CFMutableSetRef _commonModes;\n    CFMutableSetRef _commonModeItems;\n    CFRunloopModeRef _currentMode;\n    CFMutableSetRef _modes;\n    ...\n};\n\ntypedef struct __CFRunLoopMode *CFRunLoopModeRef;\n\nstruct __CFRunLoopMode {\n    ...\n    CFStringRef _name;\n    CFMutableSetRef _sources0; // CFRunloopSourceRef数组\n    CFMutableSetRef _sources1; // CFRunloopSourceRef数组\n    CFMutableArrayRef _observers; // CFRunloopObserverRef数组\n    CFMutableArrayRef _timers; // CFRunloopTimerRef数组 \n    ...\n}\n```\n\n通过源码我们可以得知，一个Runloop对象里面有多个mode，存放在`_modes`成员属性里面。其中有一个mode是`_currentMode`。 然后每个mode都有`name`、`source0`、`source1`等数组属性\n\n- CFRunloopModeRef 代表Runloop的运行模式\n- Runloop启动只能选择其中一个Mode作为currentMode\n- 如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入\n\t- 不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响\n- 如果Mode里面没有任何Source0/Source1/Timer/Observer，Runloop会立马退出\n\n### CFRunloopModeRef\n\n- 两种常见的Mode\n\t- `kCFRunLoopDefaultMode`（`NSDefaultRunloopMode`）: App的默认Mode，通常主线程是在这个Mode下运行\n    - `UITrackingRunLoopMode`界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响\n\n- Source0\n\t- 触摸事件处理\n    - `performSelector:onThread:`\n\n- Source1\n\t- 基于Port的线程间通信\n    - 系统事件捕捉（捕捉后到Source0去处理）\n    \n- Timers\n\t- NSTimer\n    - `performSelector:withObject:afterDelay:`\n\n- Observers\n\t- 用于监听Runloop的状态\n    - UI刷新（BeforeWaiting）在Runloop休眠之前会执行一次UI刷新\n    - Autorelease pool 在Runloop休眠之前自动释放某些内存\n    \n    \n### CFRunloopObserverRef\n\nRunloop的几种状态\n\n```objectivec\n/* Run Loop Observer Activities */\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry = (1UL << 0),         // 即将进入Loop \n    kCFRunLoopBeforeTimers = (1UL << 1),  // 即将处理Timer\n    kCFRunLoopBeforeSources = (1UL << 2), // 即将处理Source\n    kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠\n    kCFRunLoopAfterWaiting = (1UL << 6),  // 刚从休眠中唤醒\n    kCFRunLoopExit = (1UL << 7),          // 即将退出Loop\n    kCFRunLoopAllActivities = 0x0FFFFFFFU\n};\n```\n\n我们可以自己添加一个监听者来监听Runloop的状态变化\n\n1. 定义监听回调\n\n  ```objectivec\n  void observeRunLoopActivities(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) {\n      switch (activity) {\n          case kCFRunLoopEntry:\n              NSLog(@\"kCFRunLoopEntry\");\n              break;\n          case kCFRunLoopBeforeTimers:\n              NSLog(@\"kCFRunLoopBeforeTimers\");\n              break;\n          case kCFRunLoopBeforeSources:\n              NSLog(@\"kCFRunLoopBeforeSources\");\n              break;\n          case kCFRunLoopBeforeWaiting:\n              NSLog(@\"kCFRunLoopBeforeWaiting\");\n              break;\n          case kCFRunLoopAfterWaiting:\n              NSLog(@\"kCFRunLoopAfterWaiting\");\n              break;\n          case kCFRunLoopExit:\n              NSLog(@\"kCFRunLoopExit\");\n              break;\n          default:\n              break;\n      }\n  }\n  ```\n\n2. 创建监听者\n\n  ```objectivec\n  /// 创建Observer\n  CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, observeRunLoopActivities, NULL);\n  /// 添加Observer\n  CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);\n  CFRelease(observer);\n  ```\n  \n## Runloop的运行逻辑\n\n\n### 流程分析\n\n1. 通知Observers：进入Loop\n2. 通知Observers：即将处理Timers\n3. 通知Observers：即将处理Sources\n4. 处理Blocks（特指执行CFRunLoopPerformBlock内的block参数）\n\t```\n    CFRunLoopPerformBlock(CFRunLoopGetCurrent(), kCFRunLoopCommonModes, ^{\n        \n    });\n    ```\n5. 处理Source0（可能会再次处理Blocks，因为有可能在处理Source0的时候添加了Blocks）\n6. 如果存在Source1，就跳转到第8步\n7. 通知Observers：开始休眠（等待消息唤醒）\n8. 通知Observers：结束休眠（被某个消息唤醒，被什么东西唤醒就处理什么东西）\n\t- 处理Timer\n    - 处理GCD Async To Main Queue\n    - 处理Source1\n9. 处理Blocks\n10. 根据前面的执行结果，决定如何操作（如下几种可能）\n\t1. 回到第2步\n    2. 退出Loop\n11. 通知Observers：退出Loop\n\n### 源码分析\n\n通过在控制台执行命令`bt`我们可以看到开始是调用了`CFRunLoopRunSpecific`函数，核心源码如下\n\n```objectivec\nSInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     /* DOES CALLOUT */\n    \n    ...\n    /// 通知Observers：进入Loop\n\t__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);\n    \n    /// 具体要做的事情\n\tresult = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);\n\t\n    /// 通知Observers：退出Loop\n    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);\n\n    ...\n    return result;\n}\n\n```\n\n然后查看一下`__CFRunLoopRun`内的核心处理代码\n\n```objectivec\nstatic int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {\n    ...\n    int32_t retVal = 0;\n    do {\n        \n        /// 通知Observers：即将处理Timers\n        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);\n        \n        /// 通知Observers：即将处理Sources\n         __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);\n        \n        /// 处理Blocks\n        __CFRunLoopDoBlocks(rl, rlm);\n        \n        /// 处理Source0\n        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);\n        if (sourceHandledThisLoop) {\n            /// 处理Blocks\n            __CFRunLoopDoBlocks(rl, rlm);\n        }\n        \n        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context->termTSR);\n        \n        /// 判断有无Source1\n        if (__CFRunLoopServiceMachPort(dispatchPort, &msg, sizeof(msg_buffer), &livePort, 0, &voucherState, NULL)) {\n            /// 如果有Source1，就跳转到handle_msg\n            goto handle_msg;\n        }\n        \n        /// 通知Observers：即将休眠\n        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);\n        __CFRunLoopSetSleeping(rl);\n        \n        do {\n            /// 等待别的消息来唤醒当前线程\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);\n        } while (1);\n        \n        __CFRunLoopSetIgnoreWakeUps(rl);\n        \n        __CFRunLoopUnsetSleeping(rl);\n        /// 通知Observers：结束休眠\n        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);\n        \n    handle_msg:;\n        /// 被Timer唤醒\n        if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            /// 处理Timers\n            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {\n                // Re-arm the next timer, because we apparently fired early\n                __CFArmNextTimerInMode(rlm, rl);\n            }\n        /// 被GCD唤醒\n        } else if (livePort == dispatchPort) {\n            CFRUNLOOP_WAKEUP_FOR_DISPATCH();\n            /// 处理GCD\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n        } else { /// 被Source1唤醒\n            CFRUNLOOP_WAKEUP_FOR_SOURCE();\n            /// 处理Source1\n            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply) || sourceHandledThisLoop;\n            \n        }\n        \n        /// 处理Blocks\n        __CFRunLoopDoBlocks(rl, rlm);\n        \n        /// 设置返回值\n        if (sourceHandledThisLoop && stopAfterHandle) {\n            retVal = kCFRunLoopRunHandledSource;\n        } else if (timeout_context->termTSR < mach_absolute_time()) {\n            retVal = kCFRunLoopRunTimedOut;\n        } else if (__CFRunLoopIsStopped(rl)) {\n            __CFRunLoopUnsetStopped(rl);\n            retVal = kCFRunLoopRunStopped;\n        } else if (rlm->_stopped) {\n            rlm->_stopped = false;\n            retVal = kCFRunLoopRunStopped;\n        } else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {\n            retVal = kCFRunLoopRunFinished;\n        }\n        \n    } while (0 == retVal);\n    \n    return retVal;\n}\n```\n\n执行顺序跟我们上面提及的执行流程是相似的，最后的返回值如果是0的话，那么就继续循环，如果是其他值，那么就会退出循环，继而退出Runloop\n\n\n上面提及的处理Timers函数，处理GCD函数和处理Source1的函数，都会调用到`__CFRUNLOOP_IS_CALLING_OUT_TO_A_xxx_FUNCTION__`这个函数(这个xxx代表Observer、Block、Source0或者Timer等，见下表)，在这个函数里面，再去执行对应的操作，比如UIKit的界面刷新、Foundation定时器的执行\n\n|执行的事情|调用的函数|\n|---|---|\n|进入Loop|__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__|\n|处理Blocks|__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__|\n|处理Source0|__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__|\n|处理Timer|__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__|\n|处理GCD|__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__|\n|处理SOURCE1|__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__|\n\nGCD只有在回调到主线程的时候才会调用到Runloop的函数，比如下面这种情况 \n\n```objectivec\ndispatch_async(dispatch_get_global_queue(0,0), ^{\n    dispatch_async(dispatch_get_main_queue(), ^{\n    \t...\n    });\n});\n```\n\n### Runloop休眠的实现原理\n\n当Runloop需要休眠的时候，会调用用户态的API，然后内部调用mach_msg()切换到内核态，当有消息的时候，就会从内核态切换回用户态的API去处理消息\n\n用户态 ： mach_msg() -> 内核态： mach_msg() -> 用户态：处理消息\n\n内核态：\n1. 等待消息\n2. 没有消息就让线程休眠\n3. 有消息就唤醒线程\n\n## NSTimer\n\n由于NSTimer默认是运行在`NSDefaultRunloopMode`的，所以在滚动的时候不会执行定时器，因为滚动的时候系统会切换到`UITrackingRunLoopMode`\n\n这时候我们需要把NSTimer设置到`NSRunLoopCommonModes`里，如下\n\n```objectivec\nstatic int count = 0;\nNSTimer *timer = [NSTimer timerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {\n    NSLog(@\"%d\",++count);\n}];\n[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];\n```\n\n`NSDefaultRunloopMode`、`UITrackingRunLoopMode`才是真正存在的模式\n\n`NSRunLoopCommonModes`并不是一个真的模式，它只是一个标记\n\ntimer能在`_commonModes`数组中存放的模式下工作\n\n```objectivec\nstruct __CFRunLoop {\n    ...\n    pthread_t _pthread;\n    CFMutableSetRef _commonModes; // 存放着NSDefaultRunloopMod，UITrackingRunLoopMode\n    CFMutableSetRef _commonModeItems; // 存放着common模式下要处理的对象，比如上面的timer\n    CFRunloopModeRef _currentMode;\n    CFMutableSetRef _modes; \t// 存放着所有的模式\n    ...\n};\n```\n\n## 线程保活\n\n### 基本原理\n\n\n一般情况下，我们创建线程后，当线程的任务执行完了，线程就会销毁，所以有时候我们需要让线程执行完任务后依旧存在，等到我们主动让他销毁他才会销毁。\n\n首先我们创建一条线程\n\n```objectivec\nself.thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];\n```\n\n要让这条线程一直活着，我们可以让这个`run`方法不要结束\n\n这里添加一个Runloop，由于获取Runloop的时候就会创建Runloop，所以我们获取Runloop即可，然后调用`addPort:forMode:`方法，添加一个`Source0`\n\n这样子线程就会卡在`[[NSRunLoop currentRunLoop] run];`这一行中，不会让方法执行完，线程也就不会销毁\n\n```objectivec\n- (void)run {\n    NSLog(@\"%@ %s begin\",NSThread.currentThread,__func__);\n    [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n    [[NSRunLoop currentRunLoop] run];\n    /// 不会走到这里\n    NSLog(@\"%@ %s end\",NSThread.currentThread,__func__);\n}\n```\n\n然后下一步我们需要调用一个方法去销毁这个线程，比如`CFRunLoopStop(CFRunLoopGetCurrent())`，但是如果我们这么做\n\n```objectivec\n- (void)stop {\n    CFRunLoopStop(CFRunLoopGetCurrent());\n}\n\n/// 尝试在我们指定的线程上停止这个线程内的Runloop\n[self performSelector:@selector(stop) onThread:self.thread withObject:nil waitUntilDone:NO];\n```\n\n发现线程不会销毁，原因是`[[NSRunLoop currentRunLoop] run];`执行后，会在一个死循环内执行Runloop的`runMode:beforeDate:`方法，类似于\n\n```objectivec\nwhile(1) {\n    [[NSRunLoop currentRunLoop] runMode: beforeDate:xxx];\n}\n```\n\n`CFRunLoopStop(CFRunLoopGetCurrent());`只是停止了其中的一次方法调用，进入下个循环后又会开启，所以用这个方法去完全停止Runloop是没用的\n\n所以我们要使用别的方式去替代`[[NSRunLoop currentRunLoop] run];`开启线程，因为这个`run`方法是专门用于开启一个永不销毁的线程。\n\n只需要改造一下上面那个while方法就好，给self添加一个bool属性\n\n```objectivec\n\n@property(nonatomic,assign) BOOL isStop;\n\n- (void)run {\n    NSLog(@\"%@ %s begin\",NSThread.currentThread,__func__);\n    [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n    while(!self.isStop) {\n\t\t[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n\t}\n    NSLog(@\"%@ %s end\",NSThread.currentThread,__func__);\n}\n\n- (void)stop {\n    self.isStop = YES;\n    CFRunLoopStop(CFRunLoopGetCurrent());\n}\n\n```\n\n这样子我们调用run方法线程就会启动，调用stop方法，while循环就会退出，`CFRunLoopStop(CFRunLoopGetCurrent());`停止了本次RunLoop，Runloop退出，这样子就能走到打印end那里，线程的方法走完了，线程就可以销毁了\n\n### 封装\n\n```objectivec\n@interface MyThread : NSObject\n\n/// 开启线程\n- (void)run;\n\n/// 销毁线程\n- (void)stop;\n\n/// 执行任务\n- (void)executeTask:(void(^)(void))block;\n\n@end\n\n@interface MyThread()\n\n@property (nonatomic, strong) Thread *innerThread;\n\n@property (nonatomic, assign, getter=isStopped) BOOL stopped;\n\n@end\n\n@implementation MyThread\n\n- (instancetype)init {\n    if (self = [super init]) {\n        \n        __weak typeof(self) weakSelf = self;\n        \n        /// 创建线程 开启Runloop\n        self.innerThread = [[Thread alloc] initWithBlock:^{\n            [[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunLoopMode];\n            \n            /// 因为dealloc的时候weakSelf已经空了，所以要明确self存在并且不停止时候，才循环启动Runloop\n            while (weakSelf && !weakSelf.isStopped) {\n                [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];\n            }\n        }];\n    }\n    return self;\n}\n\n- (void)run {\n    if (!self.innerThread) return;\n    \n    /// 开启线程，启动Runloop\n    [self.innerThread start];\n}\n\n- (void)stop {\n    if (!self.innerThread) return;\n    \n    /// 停止线程\n    [self performSelector:@selector(__stop) onThread:self.innerThread withObject:nil waitUntilDone:YES];\n}\n\n- (void)executeTask:(void (^)(void))block {\n    if (!self.innerThread || !block) return;\n    \n    /// 执行子线程任务\n    [self performSelector:@selector(__executeTask:) onThread:self.innerThread withObject:block waitUntilDone:NO];\n}\n\n#pragma mark - private method\n\n- (void)__stop {\n\n\t/// 标记需要退出Runloop\n    self.stopped = YES;\n    \n    /// 退出本次Runloop\n    CFRunLoopStop(CFRunLoopGetCurrent());\n    \n    /// 取消强引用\n    self.innerThread = nil;\n}\n\n- (void)__executeTask:(void (^)(void))block {\n    block();\n}\n\n- (void)dealloc {\n    /// 自动调用停止方法\n    [self stop];\n    NSLog(@\"%s\",__func__);\n}\n\n@end\n\n/// 只是为了监听线程的销毁行为\n@interface Thread : NSThread\n@end\n\n@implementation Thread\n\n- (void)dealloc {\n    NSLog(@\"%s\",__func__);\n}\n\n@end\n```","slug":"iOS-底层原理-Runloop","published":1,"updated":"2021-08-25T16:02:31.329Z","_id":"ckrdjtzhk00009dn0akhp1lol","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文讲述iOS中Runloop的一些使用以及原理</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Runloop对象\"><a href=\"#Runloop对象\" class=\"headerlink\" title=\"Runloop对象\"></a>Runloop对象</h2><ul>\n<li>iOS中有两套API来访问和使用Runloop<ul>\n<li>Foundation : NSRunLoop</li>\n<li>Core Foundation : CFRunloopRef</li>\n</ul>\n</li>\n<li>NSRunloop和CFRunloopRef都代表着Runloop对象</li>\n<li>NSRunloop是基于CFRunloopRef的一层OC包装</li>\n<li>CFRunloopRef是开源的</li>\n</ul>\n<p>获取当前Runloop的两个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSRunLoop *runloop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class=\"line\">CFRunLoopRef runloopRef &#x3D; CFRunLoopGetCurrent();</span><br></pre></td></tr></table></figure>\n\n<p>打印runloop可以发现类型是<code>&lt;CFRunLoop 0x600001994300 [0x101405a98]&gt;</code>，跟runloopRef一致，但是打印地址不一样，原因是<code>NSRunLoop</code>是对<code>CFRunLoopRef</code>的封装，<code>CFRunLoopRef</code>是存储在其内部，所以会不一样</p>\n<h2 id=\"Runloop与线程\"><a href=\"#Runloop与线程\" class=\"headerlink\" title=\"Runloop与线程\"></a>Runloop与线程</h2><ul>\n<li><p>每条线程都有唯一的一个与之对应的Runloop对象</p>\n</li>\n<li><p>Runloop保存在一个全局的Dictionary里，线程作为key，Runloop作为Value</p>\n<ul>\n<li>Runloop源码 <code>CFRunloop.c</code>中我们可以找到<code>CFRunLoopGetCurrent()</code>内调用了<code>_CFRunLoopGet0()</code>，在这里面可以看到这行代码得以验证</li>\n</ul>\n  <figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFRunLoopRef loop = (CFRunLoopRef)<span class=\"constructor\">CFDictionaryGetValue(<span class=\"params\">__CFRunLoops</span>, <span class=\"params\">pthreadPointer</span>(<span class=\"params\">t</span>)</span>);</span><br></pre></td></tr></table></figure></li>\n<li><p>线程刚创建的时候并没有Runloop对象，Runloop会在第一次获取它时创建</p>\n<ul>\n<li>主线程一开始也是没有Runloop的，只是因为在<code>main.m</code>中调用了<code>UIApplicationMain</code>函数，在这里面回去获取Runloop从而创建了Runloop</li>\n<li>对应源码如下</li>\n</ul>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CF_EXPORT</span> <span class=\"built_in\">CFRunLoopRef</span> _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!loop) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CFRunLoopRef</span> newLoop = __CFRunLoopCreate(t);</span><br><span class=\"line\">        __CFLock(&amp;loopsLock);</span><br><span class=\"line\">        loop = (<span class=\"built_in\">CFRunLoopRef</span>)<span class=\"built_in\">CFDictionaryGetValue</span>(__CFRunLoops,pthreadPointer(t));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!loop) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">CFDictionarySetValue</span>(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class=\"line\">            loop = newLoop;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         __CFUnlock(&amp;loopsLock);</span><br><span class=\"line\">   <span class=\"built_in\">CFRelease</span>(newLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Runloop会在线程结束时销毁</p>\n</li>\n<li><p>主线程的Runloop已经自动获取（创建），子线程默认没有开启Runloop</p>\n</li>\n</ul>\n<h2 id=\"Runloop相关的类\"><a href=\"#Runloop相关的类\" class=\"headerlink\" title=\"Runloop相关的类\"></a>Runloop相关的类</h2><p>Core Foundation 中关于Runloop的5个类</p>\n<ul>\n<li>CFRunloopRef</li>\n<li>CFRunloopModeRef</li>\n<li>CFRunloopSourceRef</li>\n<li>CFRunloopTimerRef</li>\n<li>CFRunloopObserverRef</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> __CFRunLoop * <span class=\"built_in\">CFRunloopRef</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoop &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    pthread_t _pthread;</span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModes;</span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModeItems;</span><br><span class=\"line\">    <span class=\"built_in\">CFRunloopModeRef</span> _currentMode;</span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _modes;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> __CFRunLoopMode *<span class=\"built_in\">CFRunLoopModeRef</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoopMode &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"built_in\">CFStringRef</span> _name;</span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources0; <span class=\"comment\">// CFRunloopSourceRef数组</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources1; <span class=\"comment\">// CFRunloopSourceRef数组</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _observers; <span class=\"comment\">// CFRunloopObserverRef数组</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _timers; <span class=\"comment\">// CFRunloopTimerRef数组 </span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过源码我们可以得知，一个Runloop对象里面有多个mode，存放在<code>_modes</code>成员属性里面。其中有一个mode是<code>_currentMode</code>。 然后每个mode都有<code>name</code>、<code>source0</code>、<code>source1</code>等数组属性</p>\n<ul>\n<li>CFRunloopModeRef 代表Runloop的运行模式</li>\n<li>Runloop启动只能选择其中一个Mode作为currentMode</li>\n<li>如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入<ul>\n<li>不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响</li>\n</ul>\n</li>\n<li>如果Mode里面没有任何Source0/Source1/Timer/Observer，Runloop会立马退出</li>\n</ul>\n<h3 id=\"CFRunloopModeRef\"><a href=\"#CFRunloopModeRef\" class=\"headerlink\" title=\"CFRunloopModeRef\"></a>CFRunloopModeRef</h3><ul>\n<li><p>两种常见的Mode</p>\n<ul>\n<li><code>kCFRunLoopDefaultMode</code>（<code>NSDefaultRunloopMode</code>）: App的默认Mode，通常主线程是在这个Mode下运行</li>\n<li><code>UITrackingRunLoopMode</code>界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响</li>\n</ul>\n</li>\n<li><p>Source0</p>\n<ul>\n<li>触摸事件处理</li>\n<li><code>performSelector:onThread:</code></li>\n</ul>\n</li>\n<li><p>Source1</p>\n<ul>\n<li>基于Port的线程间通信</li>\n<li>系统事件捕捉（捕捉后到Source0去处理）</li>\n</ul>\n</li>\n<li><p>Timers</p>\n<ul>\n<li>NSTimer</li>\n<li><code>performSelector:withObject:afterDelay:</code></li>\n</ul>\n</li>\n<li><p>Observers</p>\n<ul>\n<li>用于监听Runloop的状态</li>\n<li>UI刷新（BeforeWaiting）在Runloop休眠之前会执行一次UI刷新</li>\n<li>Autorelease pool 在Runloop休眠之前自动释放某些内存</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CFRunloopObserverRef\"><a href=\"#CFRunloopObserverRef\" class=\"headerlink\" title=\"CFRunloopObserverRef\"></a>CFRunloopObserverRef</h3><p>Runloop的几种状态</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Run Loop Observer Activities */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">CF_OPTIONS</span>(<span class=\"built_in\">CFOptionFlags</span>, <span class=\"built_in\">CFRunLoopActivity</span>) &#123;</span><br><span class=\"line\">    kCFRunLoopEntry = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">0</span>),         <span class=\"comment\">// 即将进入Loop </span></span><br><span class=\"line\">    kCFRunLoopBeforeTimers = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">1</span>),  <span class=\"comment\">// 即将处理Timer</span></span><br><span class=\"line\">    kCFRunLoopBeforeSources = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">2</span>), <span class=\"comment\">// 即将处理Source</span></span><br><span class=\"line\">    kCFRunLoopBeforeWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">5</span>), <span class=\"comment\">// 即将进入休眠</span></span><br><span class=\"line\">    kCFRunLoopAfterWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">6</span>),  <span class=\"comment\">// 刚从休眠中唤醒</span></span><br><span class=\"line\">    kCFRunLoopExit = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">7</span>),          <span class=\"comment\">// 即将退出Loop</span></span><br><span class=\"line\">    kCFRunLoopAllActivities = <span class=\"number\">0x0FFFFFFF</span>U</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以自己添加一个监听者来监听Runloop的状态变化</p>\n<ol>\n<li>定义监听回调</li>\n</ol>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> observeRunLoopActivities(<span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFRunLoopActivity</span> activity, <span class=\"keyword\">void</span> *info) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (activity) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopEntry:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;kCFRunLoopEntry&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopBeforeTimers:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;kCFRunLoopBeforeTimers&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopBeforeSources:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;kCFRunLoopBeforeSources&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopBeforeWaiting:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;kCFRunLoopBeforeWaiting&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopAfterWaiting:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;kCFRunLoopAfterWaiting&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopExit:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;kCFRunLoopExit&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>创建监听者</li>\n</ol>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 创建Observer</span></span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopObserverRef</span> observer = <span class=\"built_in\">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class=\"literal\">YES</span>, <span class=\"number\">0</span>, observeRunLoopActivities, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"comment\">/// 添加Observer</span></span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopAddObserver</span>(<span class=\"built_in\">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br><span class=\"line\"><span class=\"built_in\">CFRelease</span>(observer);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Runloop的运行逻辑\"><a href=\"#Runloop的运行逻辑\" class=\"headerlink\" title=\"Runloop的运行逻辑\"></a>Runloop的运行逻辑</h2><h3 id=\"流程分析\"><a href=\"#流程分析\" class=\"headerlink\" title=\"流程分析\"></a>流程分析</h3><ol>\n<li>通知Observers：进入Loop</li>\n<li>通知Observers：即将处理Timers</li>\n<li>通知Observers：即将处理Sources</li>\n<li>处理Blocks（特指执行CFRunLoopPerformBlock内的block参数） <figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">CFRunLoopPerformBlock</span>(CFRunLoopGetCurrent(), kCFRunLoopCommonModes, ^&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>处理Source0（可能会再次处理Blocks，因为有可能在处理Source0的时候添加了Blocks）</li>\n<li>如果存在Source1，就跳转到第8步</li>\n<li>通知Observers：开始休眠（等待消息唤醒）</li>\n<li>通知Observers：结束休眠（被某个消息唤醒，被什么东西唤醒就处理什么东西）<ul>\n<li>处理Timer</li>\n<li>处理GCD Async To Main Queue</li>\n<li>处理Source1</li>\n</ul>\n</li>\n<li>处理Blocks</li>\n<li>根据前面的执行结果，决定如何操作（如下几种可能）<ol>\n<li>回到第2步</li>\n<li>退出Loop</li>\n</ol>\n</li>\n<li>通知Observers：退出Loop</li>\n</ol>\n<h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>通过在控制台执行命令<code>bt</code>我们可以看到开始是调用了<code>CFRunLoopRunSpecific</code>函数，核心源码如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SInt32 <span class=\"built_in\">CFRunLoopRunSpecific</span>(<span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFStringRef</span> modeName, <span class=\"built_in\">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;     <span class=\"comment\">/* DOES CALLOUT */</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">/// 通知Observers：进入Loop</span></span><br><span class=\"line\">\t__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 具体要做的事情</span></span><br><span class=\"line\">\tresult = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">/// 通知Observers：退出Loop</span></span><br><span class=\"line\">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>然后查看一下<code>__CFRunLoopRun</code>内的核心处理代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> int32_t __CFRunLoopRun(<span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFRunLoopModeRef</span> rlm, <span class=\"built_in\">CFTimeInterval</span> seconds, Boolean stopAfterHandle, <span class=\"built_in\">CFRunLoopModeRef</span> previousMode) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    int32_t retVal = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 通知Observers：即将处理Timers</span></span><br><span class=\"line\">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 通知Observers：即将处理Sources</span></span><br><span class=\"line\">         __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 处理Blocks</span></span><br><span class=\"line\">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 处理Source0</span></span><br><span class=\"line\">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sourceHandledThisLoop) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/// 处理Blocks</span></span><br><span class=\"line\">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Boolean poll = sourceHandledThisLoop || (<span class=\"number\">0</span>ULL == timeout_context-&gt;termTSR);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 判断有无Source1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class=\"keyword\">sizeof</span>(msg_buffer), &amp;livePort, <span class=\"number\">0</span>, &amp;voucherState, <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/// 如果有Source1，就跳转到handle_msg</span></span><br><span class=\"line\">            <span class=\"keyword\">goto</span> handle_msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 通知Observers：即将休眠</span></span><br><span class=\"line\">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class=\"line\">        __CFRunLoopSetSleeping(rl);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">/// 等待别的消息来唤醒当前线程</span></span><br><span class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class=\"keyword\">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class=\"number\">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (<span class=\"number\">1</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class=\"line\">        </span><br><span class=\"line\">        __CFRunLoopUnsetSleeping(rl);</span><br><span class=\"line\">        <span class=\"comment\">/// 通知Observers：结束休眠</span></span><br><span class=\"line\">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class=\"line\">        </span><br><span class=\"line\">    handle_msg:;</span><br><span class=\"line\">        <span class=\"comment\">/// 被Timer唤醒</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">CFRUNLOOP_WAKEUP_FOR_TIMER</span>();</span><br><span class=\"line\">            <span class=\"comment\">/// 处理Timers</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Re-arm the next timer, because we apparently fired early</span></span><br><span class=\"line\">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"comment\">/// 被GCD唤醒</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (livePort == dispatchPort) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">CFRUNLOOP_WAKEUP_FOR_DISPATCH</span>();</span><br><span class=\"line\">            <span class=\"comment\">/// 处理GCD</span></span><br><span class=\"line\">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/// 被Source1唤醒</span></span><br><span class=\"line\">            <span class=\"built_in\">CFRUNLOOP_WAKEUP_FOR_SOURCE</span>();</span><br><span class=\"line\">            <span class=\"comment\">/// 处理Source1</span></span><br><span class=\"line\">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 处理Blocks</span></span><br><span class=\"line\">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 设置返回值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class=\"line\">            retVal = kCFRunLoopRunHandledSource;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class=\"line\">            retVal = kCFRunLoopRunTimedOut;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class=\"line\">            __CFRunLoopUnsetStopped(rl);</span><br><span class=\"line\">            retVal = kCFRunLoopRunStopped;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class=\"line\">            rlm-&gt;_stopped = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            retVal = kCFRunLoopRunStopped;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class=\"line\">            retVal = kCFRunLoopRunFinished;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span> == retVal);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> retVal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行顺序跟我们上面提及的执行流程是相似的，最后的返回值如果是0的话，那么就继续循环，如果是其他值，那么就会退出循环，继而退出Runloop</p>\n<p>上面提及的处理Timers函数，处理GCD函数和处理Source1的函数，都会调用到<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_xxx_FUNCTION__</code>这个函数(这个xxx代表Observer、Block、Source0或者Timer等，见下表)，在这个函数里面，再去执行对应的操作，比如UIKit的界面刷新、Foundation定时器的执行</p>\n<table>\n<thead>\n<tr>\n<th>执行的事情</th>\n<th>调用的函数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>进入Loop</td>\n<td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</strong></td>\n</tr>\n<tr>\n<td>处理Blocks</td>\n<td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK</strong></td>\n</tr>\n<tr>\n<td>处理Source0</td>\n<td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong></td>\n</tr>\n<tr>\n<td>处理Timer</td>\n<td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong></td>\n</tr>\n<tr>\n<td>处理GCD</td>\n<td><strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong></td>\n</tr>\n<tr>\n<td>处理SOURCE1</td>\n<td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</strong></td>\n</tr>\n</tbody></table>\n<p>GCD只有在回调到主线程的时候才会调用到Runloop的函数，比如下面这种情况 </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>,<span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    \t...</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Runloop休眠的实现原理\"><a href=\"#Runloop休眠的实现原理\" class=\"headerlink\" title=\"Runloop休眠的实现原理\"></a>Runloop休眠的实现原理</h3><p>当Runloop需要休眠的时候，会调用用户态的API，然后内部调用mach_msg()切换到内核态，当有消息的时候，就会从内核态切换回用户态的API去处理消息</p>\n<p>用户态 ： mach_msg() -&gt; 内核态： mach_msg() -&gt; 用户态：处理消息</p>\n<p>内核态：</p>\n<ol>\n<li>等待消息</li>\n<li>没有消息就让线程休眠</li>\n<li>有消息就唤醒线程</li>\n</ol>\n<h2 id=\"NSTimer\"><a href=\"#NSTimer\" class=\"headerlink\" title=\"NSTimer\"></a>NSTimer</h2><p>由于NSTimer默认是运行在<code>NSDefaultRunloopMode</code>的，所以在滚动的时候不会执行定时器，因为滚动的时候系统会切换到<code>UITrackingRunLoopMode</code></p>\n<p>这时候我们需要把NSTimer设置到<code>NSRunLoopCommonModes</code>里，如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1.0</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>,++count);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>\n\n<p><code>NSDefaultRunloopMode</code>、<code>UITrackingRunLoopMode</code>才是真正存在的模式</p>\n<p><code>NSRunLoopCommonModes</code>并不是一个真的模式，它只是一个标记</p>\n<p>timer能在<code>_commonModes</code>数组中存放的模式下工作</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoop &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    pthread_t _pthread;</span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModes; <span class=\"comment\">// 存放着NSDefaultRunloopMod，UITrackingRunLoopMode</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModeItems; <span class=\"comment\">// 存放着common模式下要处理的对象，比如上面的timer</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunloopModeRef</span> _currentMode;</span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _modes; \t<span class=\"comment\">// 存放着所有的模式</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程保活\"><a href=\"#线程保活\" class=\"headerlink\" title=\"线程保活\"></a>线程保活</h2><h3 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h3><p>一般情况下，我们创建线程后，当线程的任务执行完了，线程就会销毁，所以有时候我们需要让线程执行完任务后依旧存在，等到我们主动让他销毁他才会销毁。</p>\n<p>首先我们创建一条线程</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.thread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run) object:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n\n<p>要让这条线程一直活着，我们可以让这个<code>run</code>方法不要结束</p>\n<p>这里添加一个Runloop，由于获取Runloop的时候就会创建Runloop，所以我们获取Runloop即可，然后调用<code>addPort:forMode:</code>方法，添加一个<code>Source0</code></p>\n<p>这样子线程就会卡在<code>[[NSRunLoop currentRunLoop] run];</code>这一行中，不会让方法执行完，线程也就不会销毁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)run &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@ %s begin&quot;</span>,<span class=\"built_in\">NSThread</span>.currentThread,__func__);</span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addPort:[[<span class=\"built_in\">NSPort</span> alloc] init] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</span><br><span class=\"line\">    <span class=\"comment\">/// 不会走到这里</span></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@ %s end&quot;</span>,<span class=\"built_in\">NSThread</span>.currentThread,__func__);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后下一步我们需要调用一个方法去销毁这个线程，比如<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>，但是如果我们这么做</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)stop &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopStop</span>(<span class=\"built_in\">CFRunLoopGetCurrent</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 尝试在我们指定的线程上停止这个线程内的Runloop</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(stop) onThread:<span class=\"keyword\">self</span>.thread withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span>];</span><br></pre></td></tr></table></figure>\n\n<p>发现线程不会销毁，原因是<code>[[NSRunLoop currentRunLoop] run];</code>执行后，会在一个死循环内执行Runloop的<code>runMode:beforeDate:</code>方法，类似于</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] runMode: beforeDate:xxx];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>CFRunLoopStop(CFRunLoopGetCurrent());</code>只是停止了其中的一次方法调用，进入下个循环后又会开启，所以用这个方法去完全停止Runloop是没用的</p>\n<p>所以我们要使用别的方式去替代<code>[[NSRunLoop currentRunLoop] run];</code>开启线程，因为这个<code>run</code>方法是专门用于开启一个永不销毁的线程。</p>\n<p>只需要改造一下上面那个while方法就好，给self添加一个bool属性</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">assign</span>) <span class=\"built_in\">BOOL</span> isStop;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)run &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@ %s begin&quot;</span>,<span class=\"built_in\">NSThread</span>.currentThread,__func__);</span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addPort:[[<span class=\"built_in\">NSPort</span> alloc] init] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"keyword\">self</span>.isStop) &#123;</span><br><span class=\"line\">\t\t[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] runMode:<span class=\"built_in\">NSDefaultRunLoopMode</span> beforeDate:[<span class=\"built_in\">NSDate</span> distantFuture]];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@ %s end&quot;</span>,<span class=\"built_in\">NSThread</span>.currentThread,__func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)stop &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isStop = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopStop</span>(<span class=\"built_in\">CFRunLoopGetCurrent</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这样子我们调用run方法线程就会启动，调用stop方法，while循环就会退出，<code>CFRunLoopStop(CFRunLoopGetCurrent());</code>停止了本次RunLoop，Runloop退出，这样子就能走到打印end那里，线程的方法走完了，线程就可以销毁了</p>\n<h3 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyThread</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 开启线程</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)run;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 销毁线程</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)stop;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 执行任务</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)executeTask:(<span class=\"keyword\">void</span>(^)(<span class=\"keyword\">void</span>))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyThread</span>()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) Thread *innerThread;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>, <span class=\"keyword\">getter</span>=isStopped) <span class=\"built_in\">BOOL</span> stopped;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyThread</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 创建线程 开启Runloop</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.innerThread = [[Thread alloc] initWithBlock:^&#123;</span><br><span class=\"line\">            [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addPort:[[<span class=\"built_in\">NSPort</span> alloc] init] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">/// 因为dealloc的时候weakSelf已经空了，所以要明确self存在并且不停止时候，才循环启动Runloop</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;</span><br><span class=\"line\">                [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] runMode:<span class=\"built_in\">NSDefaultRunLoopMode</span> beforeDate:[<span class=\"built_in\">NSDate</span> distantFuture]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)run &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.innerThread) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 开启线程，启动Runloop</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.innerThread start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)stop &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.innerThread) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 停止线程</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(__stop) onThread:<span class=\"keyword\">self</span>.innerThread withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)executeTask:(<span class=\"keyword\">void</span> (^)(<span class=\"keyword\">void</span>))block &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.innerThread || !block) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 执行子线程任务</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(__executeTask:) onThread:<span class=\"keyword\">self</span>.innerThread withObject:block waitUntilDone:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> mark - private method</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)__stop &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/// 标记需要退出Runloop</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.stopped = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 退出本次Runloop</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopStop</span>(<span class=\"built_in\">CFRunLoopGetCurrent</span>());</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 取消强引用</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.innerThread = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)__executeTask:(<span class=\"keyword\">void</span> (^)(<span class=\"keyword\">void</span>))block &#123;</span><br><span class=\"line\">    block();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// 自动调用停止方法</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> stop];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>,__func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 只是为了监听线程的销毁行为</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Thread</span> : <span class=\"title\">NSThread</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Thread</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>,__func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>本文讲述iOS中Runloop的一些使用以及原理</p>","more":"<h2 id=\"Runloop对象\"><a href=\"#Runloop对象\" class=\"headerlink\" title=\"Runloop对象\"></a>Runloop对象</h2><ul>\n<li>iOS中有两套API来访问和使用Runloop<ul>\n<li>Foundation : NSRunLoop</li>\n<li>Core Foundation : CFRunloopRef</li>\n</ul>\n</li>\n<li>NSRunloop和CFRunloopRef都代表着Runloop对象</li>\n<li>NSRunloop是基于CFRunloopRef的一层OC包装</li>\n<li>CFRunloopRef是开源的</li>\n</ul>\n<p>获取当前Runloop的两个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSRunLoop *runloop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class=\"line\">CFRunLoopRef runloopRef &#x3D; CFRunLoopGetCurrent();</span><br></pre></td></tr></table></figure>\n\n<p>打印runloop可以发现类型是<code>&lt;CFRunLoop 0x600001994300 [0x101405a98]&gt;</code>，跟runloopRef一致，但是打印地址不一样，原因是<code>NSRunLoop</code>是对<code>CFRunLoopRef</code>的封装，<code>CFRunLoopRef</code>是存储在其内部，所以会不一样</p>\n<h2 id=\"Runloop与线程\"><a href=\"#Runloop与线程\" class=\"headerlink\" title=\"Runloop与线程\"></a>Runloop与线程</h2><ul>\n<li><p>每条线程都有唯一的一个与之对应的Runloop对象</p>\n</li>\n<li><p>Runloop保存在一个全局的Dictionary里，线程作为key，Runloop作为Value</p>\n<ul>\n<li>Runloop源码 <code>CFRunloop.c</code>中我们可以找到<code>CFRunLoopGetCurrent()</code>内调用了<code>_CFRunLoopGet0()</code>，在这里面可以看到这行代码得以验证</li>\n</ul>\n  <figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFRunLoopRef loop = (CFRunLoopRef)<span class=\"constructor\">CFDictionaryGetValue(<span class=\"params\">__CFRunLoops</span>, <span class=\"params\">pthreadPointer</span>(<span class=\"params\">t</span>)</span>);</span><br></pre></td></tr></table></figure></li>\n<li><p>线程刚创建的时候并没有Runloop对象，Runloop会在第一次获取它时创建</p>\n<ul>\n<li>主线程一开始也是没有Runloop的，只是因为在<code>main.m</code>中调用了<code>UIApplicationMain</code>函数，在这里面回去获取Runloop从而创建了Runloop</li>\n<li>对应源码如下</li>\n</ul>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CF_EXPORT</span> <span class=\"built_in\">CFRunLoopRef</span> _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!loop) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CFRunLoopRef</span> newLoop = __CFRunLoopCreate(t);</span><br><span class=\"line\">        __CFLock(&amp;loopsLock);</span><br><span class=\"line\">        loop = (<span class=\"built_in\">CFRunLoopRef</span>)<span class=\"built_in\">CFDictionaryGetValue</span>(__CFRunLoops,pthreadPointer(t));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!loop) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">CFDictionarySetValue</span>(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class=\"line\">            loop = newLoop;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         __CFUnlock(&amp;loopsLock);</span><br><span class=\"line\">   <span class=\"built_in\">CFRelease</span>(newLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Runloop会在线程结束时销毁</p>\n</li>\n<li><p>主线程的Runloop已经自动获取（创建），子线程默认没有开启Runloop</p>\n</li>\n</ul>\n<h2 id=\"Runloop相关的类\"><a href=\"#Runloop相关的类\" class=\"headerlink\" title=\"Runloop相关的类\"></a>Runloop相关的类</h2><p>Core Foundation 中关于Runloop的5个类</p>\n<ul>\n<li>CFRunloopRef</li>\n<li>CFRunloopModeRef</li>\n<li>CFRunloopSourceRef</li>\n<li>CFRunloopTimerRef</li>\n<li>CFRunloopObserverRef</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> __CFRunLoop * <span class=\"built_in\">CFRunloopRef</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoop &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    pthread_t _pthread;</span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModes;</span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModeItems;</span><br><span class=\"line\">    <span class=\"built_in\">CFRunloopModeRef</span> _currentMode;</span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _modes;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> __CFRunLoopMode *<span class=\"built_in\">CFRunLoopModeRef</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoopMode &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"built_in\">CFStringRef</span> _name;</span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources0; <span class=\"comment\">// CFRunloopSourceRef数组</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources1; <span class=\"comment\">// CFRunloopSourceRef数组</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _observers; <span class=\"comment\">// CFRunloopObserverRef数组</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _timers; <span class=\"comment\">// CFRunloopTimerRef数组 </span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过源码我们可以得知，一个Runloop对象里面有多个mode，存放在<code>_modes</code>成员属性里面。其中有一个mode是<code>_currentMode</code>。 然后每个mode都有<code>name</code>、<code>source0</code>、<code>source1</code>等数组属性</p>\n<ul>\n<li>CFRunloopModeRef 代表Runloop的运行模式</li>\n<li>Runloop启动只能选择其中一个Mode作为currentMode</li>\n<li>如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入<ul>\n<li>不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响</li>\n</ul>\n</li>\n<li>如果Mode里面没有任何Source0/Source1/Timer/Observer，Runloop会立马退出</li>\n</ul>\n<h3 id=\"CFRunloopModeRef\"><a href=\"#CFRunloopModeRef\" class=\"headerlink\" title=\"CFRunloopModeRef\"></a>CFRunloopModeRef</h3><ul>\n<li><p>两种常见的Mode</p>\n<ul>\n<li><code>kCFRunLoopDefaultMode</code>（<code>NSDefaultRunloopMode</code>）: App的默认Mode，通常主线程是在这个Mode下运行</li>\n<li><code>UITrackingRunLoopMode</code>界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响</li>\n</ul>\n</li>\n<li><p>Source0</p>\n<ul>\n<li>触摸事件处理</li>\n<li><code>performSelector:onThread:</code></li>\n</ul>\n</li>\n<li><p>Source1</p>\n<ul>\n<li>基于Port的线程间通信</li>\n<li>系统事件捕捉（捕捉后到Source0去处理）</li>\n</ul>\n</li>\n<li><p>Timers</p>\n<ul>\n<li>NSTimer</li>\n<li><code>performSelector:withObject:afterDelay:</code></li>\n</ul>\n</li>\n<li><p>Observers</p>\n<ul>\n<li>用于监听Runloop的状态</li>\n<li>UI刷新（BeforeWaiting）在Runloop休眠之前会执行一次UI刷新</li>\n<li>Autorelease pool 在Runloop休眠之前自动释放某些内存</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CFRunloopObserverRef\"><a href=\"#CFRunloopObserverRef\" class=\"headerlink\" title=\"CFRunloopObserverRef\"></a>CFRunloopObserverRef</h3><p>Runloop的几种状态</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Run Loop Observer Activities */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">CF_OPTIONS</span>(<span class=\"built_in\">CFOptionFlags</span>, <span class=\"built_in\">CFRunLoopActivity</span>) &#123;</span><br><span class=\"line\">    kCFRunLoopEntry = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">0</span>),         <span class=\"comment\">// 即将进入Loop </span></span><br><span class=\"line\">    kCFRunLoopBeforeTimers = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">1</span>),  <span class=\"comment\">// 即将处理Timer</span></span><br><span class=\"line\">    kCFRunLoopBeforeSources = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">2</span>), <span class=\"comment\">// 即将处理Source</span></span><br><span class=\"line\">    kCFRunLoopBeforeWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">5</span>), <span class=\"comment\">// 即将进入休眠</span></span><br><span class=\"line\">    kCFRunLoopAfterWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">6</span>),  <span class=\"comment\">// 刚从休眠中唤醒</span></span><br><span class=\"line\">    kCFRunLoopExit = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">7</span>),          <span class=\"comment\">// 即将退出Loop</span></span><br><span class=\"line\">    kCFRunLoopAllActivities = <span class=\"number\">0x0FFFFFFF</span>U</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以自己添加一个监听者来监听Runloop的状态变化</p>\n<ol>\n<li>定义监听回调</li>\n</ol>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> observeRunLoopActivities(<span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFRunLoopActivity</span> activity, <span class=\"keyword\">void</span> *info) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (activity) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopEntry:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;kCFRunLoopEntry&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopBeforeTimers:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;kCFRunLoopBeforeTimers&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopBeforeSources:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;kCFRunLoopBeforeSources&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopBeforeWaiting:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;kCFRunLoopBeforeWaiting&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopAfterWaiting:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;kCFRunLoopAfterWaiting&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> kCFRunLoopExit:</span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;kCFRunLoopExit&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>创建监听者</li>\n</ol>\n  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 创建Observer</span></span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopObserverRef</span> observer = <span class=\"built_in\">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class=\"literal\">YES</span>, <span class=\"number\">0</span>, observeRunLoopActivities, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"comment\">/// 添加Observer</span></span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopAddObserver</span>(<span class=\"built_in\">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br><span class=\"line\"><span class=\"built_in\">CFRelease</span>(observer);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Runloop的运行逻辑\"><a href=\"#Runloop的运行逻辑\" class=\"headerlink\" title=\"Runloop的运行逻辑\"></a>Runloop的运行逻辑</h2><h3 id=\"流程分析\"><a href=\"#流程分析\" class=\"headerlink\" title=\"流程分析\"></a>流程分析</h3><ol>\n<li>通知Observers：进入Loop</li>\n<li>通知Observers：即将处理Timers</li>\n<li>通知Observers：即将处理Sources</li>\n<li>处理Blocks（特指执行CFRunLoopPerformBlock内的block参数） <figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">CFRunLoopPerformBlock</span>(CFRunLoopGetCurrent(), kCFRunLoopCommonModes, ^&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li>处理Source0（可能会再次处理Blocks，因为有可能在处理Source0的时候添加了Blocks）</li>\n<li>如果存在Source1，就跳转到第8步</li>\n<li>通知Observers：开始休眠（等待消息唤醒）</li>\n<li>通知Observers：结束休眠（被某个消息唤醒，被什么东西唤醒就处理什么东西）<ul>\n<li>处理Timer</li>\n<li>处理GCD Async To Main Queue</li>\n<li>处理Source1</li>\n</ul>\n</li>\n<li>处理Blocks</li>\n<li>根据前面的执行结果，决定如何操作（如下几种可能）<ol>\n<li>回到第2步</li>\n<li>退出Loop</li>\n</ol>\n</li>\n<li>通知Observers：退出Loop</li>\n</ol>\n<h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>通过在控制台执行命令<code>bt</code>我们可以看到开始是调用了<code>CFRunLoopRunSpecific</code>函数，核心源码如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SInt32 <span class=\"built_in\">CFRunLoopRunSpecific</span>(<span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFStringRef</span> modeName, <span class=\"built_in\">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;     <span class=\"comment\">/* DOES CALLOUT */</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">/// 通知Observers：进入Loop</span></span><br><span class=\"line\">\t__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 具体要做的事情</span></span><br><span class=\"line\">\tresult = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">/// 通知Observers：退出Loop</span></span><br><span class=\"line\">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>然后查看一下<code>__CFRunLoopRun</code>内的核心处理代码</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> int32_t __CFRunLoopRun(<span class=\"built_in\">CFRunLoopRef</span> rl, <span class=\"built_in\">CFRunLoopModeRef</span> rlm, <span class=\"built_in\">CFTimeInterval</span> seconds, Boolean stopAfterHandle, <span class=\"built_in\">CFRunLoopModeRef</span> previousMode) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    int32_t retVal = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 通知Observers：即将处理Timers</span></span><br><span class=\"line\">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 通知Observers：即将处理Sources</span></span><br><span class=\"line\">         __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 处理Blocks</span></span><br><span class=\"line\">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 处理Source0</span></span><br><span class=\"line\">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sourceHandledThisLoop) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/// 处理Blocks</span></span><br><span class=\"line\">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Boolean poll = sourceHandledThisLoop || (<span class=\"number\">0</span>ULL == timeout_context-&gt;termTSR);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 判断有无Source1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class=\"keyword\">sizeof</span>(msg_buffer), &amp;livePort, <span class=\"number\">0</span>, &amp;voucherState, <span class=\"literal\">NULL</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/// 如果有Source1，就跳转到handle_msg</span></span><br><span class=\"line\">            <span class=\"keyword\">goto</span> handle_msg;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 通知Observers：即将休眠</span></span><br><span class=\"line\">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class=\"line\">        __CFRunLoopSetSleeping(rl);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">/// 等待别的消息来唤醒当前线程</span></span><br><span class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class=\"keyword\">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class=\"number\">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (<span class=\"number\">1</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class=\"line\">        </span><br><span class=\"line\">        __CFRunLoopUnsetSleeping(rl);</span><br><span class=\"line\">        <span class=\"comment\">/// 通知Observers：结束休眠</span></span><br><span class=\"line\">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class=\"line\">        </span><br><span class=\"line\">    handle_msg:;</span><br><span class=\"line\">        <span class=\"comment\">/// 被Timer唤醒</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">CFRUNLOOP_WAKEUP_FOR_TIMER</span>();</span><br><span class=\"line\">            <span class=\"comment\">/// 处理Timers</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Re-arm the next timer, because we apparently fired early</span></span><br><span class=\"line\">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"comment\">/// 被GCD唤醒</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (livePort == dispatchPort) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">CFRUNLOOP_WAKEUP_FOR_DISPATCH</span>();</span><br><span class=\"line\">            <span class=\"comment\">/// 处理GCD</span></span><br><span class=\"line\">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">/// 被Source1唤醒</span></span><br><span class=\"line\">            <span class=\"built_in\">CFRUNLOOP_WAKEUP_FOR_SOURCE</span>();</span><br><span class=\"line\">            <span class=\"comment\">/// 处理Source1</span></span><br><span class=\"line\">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 处理Blocks</span></span><br><span class=\"line\">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 设置返回值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class=\"line\">            retVal = kCFRunLoopRunHandledSource;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class=\"line\">            retVal = kCFRunLoopRunTimedOut;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class=\"line\">            __CFRunLoopUnsetStopped(rl);</span><br><span class=\"line\">            retVal = kCFRunLoopRunStopped;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class=\"line\">            rlm-&gt;_stopped = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            retVal = kCFRunLoopRunStopped;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class=\"line\">            retVal = kCFRunLoopRunFinished;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span> == retVal);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> retVal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行顺序跟我们上面提及的执行流程是相似的，最后的返回值如果是0的话，那么就继续循环，如果是其他值，那么就会退出循环，继而退出Runloop</p>\n<p>上面提及的处理Timers函数，处理GCD函数和处理Source1的函数，都会调用到<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_xxx_FUNCTION__</code>这个函数(这个xxx代表Observer、Block、Source0或者Timer等，见下表)，在这个函数里面，再去执行对应的操作，比如UIKit的界面刷新、Foundation定时器的执行</p>\n<table>\n<thead>\n<tr>\n<th>执行的事情</th>\n<th>调用的函数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>进入Loop</td>\n<td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</strong></td>\n</tr>\n<tr>\n<td>处理Blocks</td>\n<td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK</strong></td>\n</tr>\n<tr>\n<td>处理Source0</td>\n<td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong></td>\n</tr>\n<tr>\n<td>处理Timer</td>\n<td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong></td>\n</tr>\n<tr>\n<td>处理GCD</td>\n<td><strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong></td>\n</tr>\n<tr>\n<td>处理SOURCE1</td>\n<td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</strong></td>\n</tr>\n</tbody></table>\n<p>GCD只有在回调到主线程的时候才会调用到Runloop的函数，比如下面这种情况 </p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>,<span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    \t...</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Runloop休眠的实现原理\"><a href=\"#Runloop休眠的实现原理\" class=\"headerlink\" title=\"Runloop休眠的实现原理\"></a>Runloop休眠的实现原理</h3><p>当Runloop需要休眠的时候，会调用用户态的API，然后内部调用mach_msg()切换到内核态，当有消息的时候，就会从内核态切换回用户态的API去处理消息</p>\n<p>用户态 ： mach_msg() -&gt; 内核态： mach_msg() -&gt; 用户态：处理消息</p>\n<p>内核态：</p>\n<ol>\n<li>等待消息</li>\n<li>没有消息就让线程休眠</li>\n<li>有消息就唤醒线程</li>\n</ol>\n<h2 id=\"NSTimer\"><a href=\"#NSTimer\" class=\"headerlink\" title=\"NSTimer\"></a>NSTimer</h2><p>由于NSTimer默认是运行在<code>NSDefaultRunloopMode</code>的，所以在滚动的时候不会执行定时器，因为滚动的时候系统会切换到<code>UITrackingRunLoopMode</code></p>\n<p>这时候我们需要把NSTimer设置到<code>NSRunLoopCommonModes</code>里，如下</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1.0</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>,++count);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class=\"built_in\">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>\n\n<p><code>NSDefaultRunloopMode</code>、<code>UITrackingRunLoopMode</code>才是真正存在的模式</p>\n<p><code>NSRunLoopCommonModes</code>并不是一个真的模式，它只是一个标记</p>\n<p>timer能在<code>_commonModes</code>数组中存放的模式下工作</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoop &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    pthread_t _pthread;</span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModes; <span class=\"comment\">// 存放着NSDefaultRunloopMod，UITrackingRunLoopMode</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModeItems; <span class=\"comment\">// 存放着common模式下要处理的对象，比如上面的timer</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunloopModeRef</span> _currentMode;</span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _modes; \t<span class=\"comment\">// 存放着所有的模式</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程保活\"><a href=\"#线程保活\" class=\"headerlink\" title=\"线程保活\"></a>线程保活</h2><h3 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h3><p>一般情况下，我们创建线程后，当线程的任务执行完了，线程就会销毁，所以有时候我们需要让线程执行完任务后依旧存在，等到我们主动让他销毁他才会销毁。</p>\n<p>首先我们创建一条线程</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.thread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(run) object:<span class=\"literal\">nil</span>];</span><br></pre></td></tr></table></figure>\n\n<p>要让这条线程一直活着，我们可以让这个<code>run</code>方法不要结束</p>\n<p>这里添加一个Runloop，由于获取Runloop的时候就会创建Runloop，所以我们获取Runloop即可，然后调用<code>addPort:forMode:</code>方法，添加一个<code>Source0</code></p>\n<p>这样子线程就会卡在<code>[[NSRunLoop currentRunLoop] run];</code>这一行中，不会让方法执行完，线程也就不会销毁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)run &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@ %s begin&quot;</span>,<span class=\"built_in\">NSThread</span>.currentThread,__func__);</span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addPort:[[<span class=\"built_in\">NSPort</span> alloc] init] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</span><br><span class=\"line\">    <span class=\"comment\">/// 不会走到这里</span></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@ %s end&quot;</span>,<span class=\"built_in\">NSThread</span>.currentThread,__func__);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后下一步我们需要调用一个方法去销毁这个线程，比如<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>，但是如果我们这么做</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)stop &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopStop</span>(<span class=\"built_in\">CFRunLoopGetCurrent</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 尝试在我们指定的线程上停止这个线程内的Runloop</span></span><br><span class=\"line\">[<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(stop) onThread:<span class=\"keyword\">self</span>.thread withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">NO</span>];</span><br></pre></td></tr></table></figure>\n\n<p>发现线程不会销毁，原因是<code>[[NSRunLoop currentRunLoop] run];</code>执行后，会在一个死循环内执行Runloop的<code>runMode:beforeDate:</code>方法，类似于</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] runMode: beforeDate:xxx];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>CFRunLoopStop(CFRunLoopGetCurrent());</code>只是停止了其中的一次方法调用，进入下个循环后又会开启，所以用这个方法去完全停止Runloop是没用的</p>\n<p>所以我们要使用别的方式去替代<code>[[NSRunLoop currentRunLoop] run];</code>开启线程，因为这个<code>run</code>方法是专门用于开启一个永不销毁的线程。</p>\n<p>只需要改造一下上面那个while方法就好，给self添加一个bool属性</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">nonatomic</span>,<span class=\"keyword\">assign</span>) <span class=\"built_in\">BOOL</span> isStop;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)run &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@ %s begin&quot;</span>,<span class=\"built_in\">NSThread</span>.currentThread,__func__);</span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addPort:[[<span class=\"built_in\">NSPort</span> alloc] init] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"keyword\">self</span>.isStop) &#123;</span><br><span class=\"line\">\t\t[[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] runMode:<span class=\"built_in\">NSDefaultRunLoopMode</span> beforeDate:[<span class=\"built_in\">NSDate</span> distantFuture]];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@ %s end&quot;</span>,<span class=\"built_in\">NSThread</span>.currentThread,__func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)stop &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.isStop = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopStop</span>(<span class=\"built_in\">CFRunLoopGetCurrent</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这样子我们调用run方法线程就会启动，调用stop方法，while循环就会退出，<code>CFRunLoopStop(CFRunLoopGetCurrent());</code>停止了本次RunLoop，Runloop退出，这样子就能走到打印end那里，线程的方法走完了，线程就可以销毁了</p>\n<h3 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyThread</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 开启线程</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)run;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 销毁线程</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)stop;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 执行任务</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)executeTask:(<span class=\"keyword\">void</span>(^)(<span class=\"keyword\">void</span>))block;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyThread</span>()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) Thread *innerThread;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>, <span class=\"keyword\">getter</span>=isStopped) <span class=\"built_in\">BOOL</span> stopped;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyThread</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)init &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> init]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/// 创建线程 开启Runloop</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.innerThread = [[Thread alloc] initWithBlock:^&#123;</span><br><span class=\"line\">            [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addPort:[[<span class=\"built_in\">NSPort</span> alloc] init] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">/// 因为dealloc的时候weakSelf已经空了，所以要明确self存在并且不停止时候，才循环启动Runloop</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;</span><br><span class=\"line\">                [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] runMode:<span class=\"built_in\">NSDefaultRunLoopMode</span> beforeDate:[<span class=\"built_in\">NSDate</span> distantFuture]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)run &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.innerThread) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 开启线程，启动Runloop</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.innerThread start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)stop &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.innerThread) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 停止线程</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(__stop) onThread:<span class=\"keyword\">self</span>.innerThread withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)executeTask:(<span class=\"keyword\">void</span> (^)(<span class=\"keyword\">void</span>))block &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>.innerThread || !block) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 执行子线程任务</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(__executeTask:) onThread:<span class=\"keyword\">self</span>.innerThread withObject:block waitUntilDone:<span class=\"literal\">NO</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> mark - private method</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)__stop &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/// 标记需要退出Runloop</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.stopped = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 退出本次Runloop</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopStop</span>(<span class=\"built_in\">CFRunLoopGetCurrent</span>());</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 取消强引用</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.innerThread = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)__executeTask:(<span class=\"keyword\">void</span> (^)(<span class=\"keyword\">void</span>))block &#123;</span><br><span class=\"line\">    block();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// 自动调用停止方法</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> stop];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>,__func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 只是为了监听线程的销毁行为</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">Thread</span> : <span class=\"title\">NSThread</span></span></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">Thread</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)dealloc &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>,__func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>"},{"title":"Swift 5 Property Wrapper","author":"Arclin","abbrlink":"1bf095f2","date":"2021-07-29T16:14:00.000Z","_content":"本文主要讲述Swift5新特性Property Wrapper的使用\n\n<!-- more -->\n\nProperty Wrapper即属性包装器，用于对某个属性进行包装，包装后可以对其做一些约束、限制或者修改\n\n## 使用\n\n举例，比如我们需要添加一个属性包装器用来包装字符串，对字符串长度进行限制，只有当字符串长度在允许范围内，才能被赋值到属性中\n\n创建一个属性包装器，`wrappedValue`是必须的，并且需要实现其setter和getter，在里面添加赋值判断逻辑\n\n我们可以提供两种属性包装器的初始化方法，一种是设置默认字符串长度上下限，一种是设置特定的字符串长度上下限\n\n```swift\n@propertyWrapper\nstruct StringWrapper {\n    private var value : String\n    private var minLength : Int\n    private var maxLength : Int\n    \n    var wrappedValue : String {\n        get { return value }\n        set {\n            if (minLength...maxLength).contains(newValue.count) {\n                value = newValue\n            } else if minLength > newValue.count {\n                print(\"字符串太短了\")\n            } else {\n                print(\"字符串太长了\")\n            }\n        }\n    }\n    \n    /// 默认5-10个字\n    init() {\n        minLength = 5\n        maxLength = 10\n        value = \"\"\n    }\n    \n    /// 设置默认值\n    init(minLength: Int, maxLength: Int, value: String = \"\") {\n        self.maxLength = maxLength\n        self.minLength = minLength\n        self.value = value\n    }\n}\n```\n\n使用属性包装器的方式如下\n\n```swift\nstruct Person {\n     /// 自定义初始化方式\n    @StringWrapper(minLength: 3, maxLength: 5) var name: String\n    /// 默认初始化方式\n    @StringWrapper var title : String\n}\n\nvar person = Person()\nperson.name = \"ARCLIN\"\nperson.title = \"Hyper Agent GridMan\"\nprint(person.name) /// ARCLIN\nprint(person.title) /// 字符串太长了\n```\n\n## 从属性包装器中呈现一个值\n\n属性包装器还提供了另外一个属性，这个属性一般情况下可以用来标记被包装的属性是否被修改过\n\n```swift\n@propertyWrapper\nstruct StringWrapper {\n  ···\n  var projectedValue = false\n  var wrappedValue : String {\n      get { return value }\n      set {\n          if (minLength...maxLength).contains(newValue.count) {\n              value = newValue\n              projectedValue = false\n          } else if minLength > newValue.count {\n              print(\"字符串太短了\")\n              projectedValue = true\n          } else {\n              print(\"字符串太长了\")\n              projectedValue = true\n          }\n      }\n  }\n  ···\n}\n```\n\n我们可以通过`$`符号来调用这个值\n\n```swift\nstruct Person {\n    @StringWrapper(minLength: 3, maxLength: 5) var name: String\n}\n\nvar person = Person()\nperson.name = \"JASON\"\nprint(person.$name) // 打印false，因为这时候长度符合规范\nperson.name = \"HyperJASON\"\nprint(person.$name) // 打印true，因为这时候长度太长了\n```\n\n这个属性也用来可以返回别的东西\n\n```swift\n@propertyWrapper\nstruct StringWrapper {\n  ···\n  var projectedValue : NSAttributedString {\n      /// 构建出一个富文本对象\n      return NSAttributedString(string: \"--- \\(self.value) ---\", attributes: [\n          .foregroundColor : UIColor.red,\n          .font : UIFont.systemFont(ofSize: 15)\n      ])\n  }\n\n  var wrappedValue : String {\n      get { return value }\n      set {\n          if (minLength...maxLength).contains(newValue.count) {\n              value = newValue\n          } else if minLength > newValue.count {\n              print(\"字符串太短了\")\n          } else {\n              print(\"字符串太长了\")\n          }\n      }\n  }\n  ···\n}\n```\n\n```swift\nstruct Person {\n    @StringWrapper(minLength: 3, maxLength: 5) var name: String\n}\n\nvar person = Person()\nperson.name = \"JASON\"\nprint(person.$name)\n/*  打印出一个富文本对象\n--- JASON ---{\n    NSColor = \"UIExtendedSRGBColorSpace 1 0 0 1\";\n    NSFont = \"<UICTFont: 0x7fc199f06660> font-family: \\\".SFUI-Regular\\\"; font-weight: normal; font-style: normal; font-size: 15.00pt\";\n}\n*/\n```","source":"_posts/Swift5-属性包装器.md","raw":"title: Swift 5 Property Wrapper\nauthor: Arclin\ntags:\n  - iOS\n  - Swift\ncategories:\n  - iOS\nabbrlink: 1bf095f2\ndate: 2021-07-30 00:14:00\n---\n本文主要讲述Swift5新特性Property Wrapper的使用\n\n<!-- more -->\n\nProperty Wrapper即属性包装器，用于对某个属性进行包装，包装后可以对其做一些约束、限制或者修改\n\n## 使用\n\n举例，比如我们需要添加一个属性包装器用来包装字符串，对字符串长度进行限制，只有当字符串长度在允许范围内，才能被赋值到属性中\n\n创建一个属性包装器，`wrappedValue`是必须的，并且需要实现其setter和getter，在里面添加赋值判断逻辑\n\n我们可以提供两种属性包装器的初始化方法，一种是设置默认字符串长度上下限，一种是设置特定的字符串长度上下限\n\n```swift\n@propertyWrapper\nstruct StringWrapper {\n    private var value : String\n    private var minLength : Int\n    private var maxLength : Int\n    \n    var wrappedValue : String {\n        get { return value }\n        set {\n            if (minLength...maxLength).contains(newValue.count) {\n                value = newValue\n            } else if minLength > newValue.count {\n                print(\"字符串太短了\")\n            } else {\n                print(\"字符串太长了\")\n            }\n        }\n    }\n    \n    /// 默认5-10个字\n    init() {\n        minLength = 5\n        maxLength = 10\n        value = \"\"\n    }\n    \n    /// 设置默认值\n    init(minLength: Int, maxLength: Int, value: String = \"\") {\n        self.maxLength = maxLength\n        self.minLength = minLength\n        self.value = value\n    }\n}\n```\n\n使用属性包装器的方式如下\n\n```swift\nstruct Person {\n     /// 自定义初始化方式\n    @StringWrapper(minLength: 3, maxLength: 5) var name: String\n    /// 默认初始化方式\n    @StringWrapper var title : String\n}\n\nvar person = Person()\nperson.name = \"ARCLIN\"\nperson.title = \"Hyper Agent GridMan\"\nprint(person.name) /// ARCLIN\nprint(person.title) /// 字符串太长了\n```\n\n## 从属性包装器中呈现一个值\n\n属性包装器还提供了另外一个属性，这个属性一般情况下可以用来标记被包装的属性是否被修改过\n\n```swift\n@propertyWrapper\nstruct StringWrapper {\n  ···\n  var projectedValue = false\n  var wrappedValue : String {\n      get { return value }\n      set {\n          if (minLength...maxLength).contains(newValue.count) {\n              value = newValue\n              projectedValue = false\n          } else if minLength > newValue.count {\n              print(\"字符串太短了\")\n              projectedValue = true\n          } else {\n              print(\"字符串太长了\")\n              projectedValue = true\n          }\n      }\n  }\n  ···\n}\n```\n\n我们可以通过`$`符号来调用这个值\n\n```swift\nstruct Person {\n    @StringWrapper(minLength: 3, maxLength: 5) var name: String\n}\n\nvar person = Person()\nperson.name = \"JASON\"\nprint(person.$name) // 打印false，因为这时候长度符合规范\nperson.name = \"HyperJASON\"\nprint(person.$name) // 打印true，因为这时候长度太长了\n```\n\n这个属性也用来可以返回别的东西\n\n```swift\n@propertyWrapper\nstruct StringWrapper {\n  ···\n  var projectedValue : NSAttributedString {\n      /// 构建出一个富文本对象\n      return NSAttributedString(string: \"--- \\(self.value) ---\", attributes: [\n          .foregroundColor : UIColor.red,\n          .font : UIFont.systemFont(ofSize: 15)\n      ])\n  }\n\n  var wrappedValue : String {\n      get { return value }\n      set {\n          if (minLength...maxLength).contains(newValue.count) {\n              value = newValue\n          } else if minLength > newValue.count {\n              print(\"字符串太短了\")\n          } else {\n              print(\"字符串太长了\")\n          }\n      }\n  }\n  ···\n}\n```\n\n```swift\nstruct Person {\n    @StringWrapper(minLength: 3, maxLength: 5) var name: String\n}\n\nvar person = Person()\nperson.name = \"JASON\"\nprint(person.$name)\n/*  打印出一个富文本对象\n--- JASON ---{\n    NSColor = \"UIExtendedSRGBColorSpace 1 0 0 1\";\n    NSFont = \"<UICTFont: 0x7fc199f06660> font-family: \\\".SFUI-Regular\\\"; font-weight: normal; font-style: normal; font-size: 15.00pt\";\n}\n*/\n```","slug":"Swift5-属性包装器","published":1,"updated":"2021-08-21T08:59:39.068Z","_id":"ckrp49yyd0000men04pnq2trc","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文主要讲述Swift5新特性Property Wrapper的使用</p>\n<span id=\"more\"></span>\n\n<p>Property Wrapper即属性包装器，用于对某个属性进行包装，包装后可以对其做一些约束、限制或者修改</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>举例，比如我们需要添加一个属性包装器用来包装字符串，对字符串长度进行限制，只有当字符串长度在允许范围内，才能被赋值到属性中</p>\n<p>创建一个属性包装器，<code>wrappedValue</code>是必须的，并且需要实现其setter和getter，在里面添加赋值判断逻辑</p>\n<p>我们可以提供两种属性包装器的初始化方法，一种是设置默认字符串长度上下限，一种是设置特定的字符串长度上下限</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@propertyWrapper</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StringWrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> value : <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> minLength : <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> maxLength : <span class=\"type\">Int</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> wrappedValue : <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> value &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (minLength<span class=\"operator\">...</span>maxLength).contains(newValue.count) &#123;</span><br><span class=\"line\">                value <span class=\"operator\">=</span> newValue</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> minLength <span class=\"operator\">&gt;</span> newValue.count &#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;字符串太短了&quot;</span>)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;字符串太长了&quot;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 默认5-10个字</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">init</span>()</span> &#123;</span><br><span class=\"line\">        minLength <span class=\"operator\">=</span> <span class=\"number\">5</span></span><br><span class=\"line\">        maxLength <span class=\"operator\">=</span> <span class=\"number\">10</span></span><br><span class=\"line\">        value <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 设置默认值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">minLength</span>: <span class=\"type\">Int</span>, <span class=\"params\">maxLength</span>: <span class=\"type\">Int</span>, <span class=\"params\">value</span>: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.maxLength <span class=\"operator\">=</span> maxLength</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.minLength <span class=\"operator\">=</span> minLength</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.value <span class=\"operator\">=</span> value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用属性包装器的方式如下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">/// 自定义初始化方式</span></span><br><span class=\"line\">    <span class=\"meta\">@StringWrapper</span>(minLength: <span class=\"number\">3</span>, maxLength: <span class=\"number\">5</span>) <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"comment\">/// 默认初始化方式</span></span><br><span class=\"line\">    <span class=\"meta\">@StringWrapper</span> <span class=\"keyword\">var</span> title : <span class=\"type\">String</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person <span class=\"operator\">=</span> <span class=\"type\">Person</span>()</span><br><span class=\"line\">person.name <span class=\"operator\">=</span> <span class=\"string\">&quot;ARCLIN&quot;</span></span><br><span class=\"line\">person.title <span class=\"operator\">=</span> <span class=\"string\">&quot;Hyper Agent GridMan&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(person.name) <span class=\"comment\">/// ARCLIN</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(person.title) <span class=\"comment\">/// 字符串太长了</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"从属性包装器中呈现一个值\"><a href=\"#从属性包装器中呈现一个值\" class=\"headerlink\" title=\"从属性包装器中呈现一个值\"></a>从属性包装器中呈现一个值</h2><p>属性包装器还提供了另外一个属性，这个属性一般情况下可以用来标记被包装的属性是否被修改过</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@propertyWrapper</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StringWrapper</span> </span>&#123;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">  <span class=\"keyword\">var</span> projectedValue <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> wrappedValue : <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> value &#125;</span><br><span class=\"line\">      <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (minLength<span class=\"operator\">...</span>maxLength).contains(newValue.count) &#123;</span><br><span class=\"line\">              value <span class=\"operator\">=</span> newValue</span><br><span class=\"line\">              projectedValue <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> minLength <span class=\"operator\">&gt;</span> newValue.count &#123;</span><br><span class=\"line\">              <span class=\"built_in\">print</span>(<span class=\"string\">&quot;字符串太短了&quot;</span>)</span><br><span class=\"line\">              projectedValue <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"built_in\">print</span>(<span class=\"string\">&quot;字符串太长了&quot;</span>)</span><br><span class=\"line\">              projectedValue <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过<code>$</code>符号来调用这个值</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@StringWrapper</span>(minLength: <span class=\"number\">3</span>, maxLength: <span class=\"number\">5</span>) <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person <span class=\"operator\">=</span> <span class=\"type\">Person</span>()</span><br><span class=\"line\">person.name <span class=\"operator\">=</span> <span class=\"string\">&quot;JASON&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(person.<span class=\"variable\">$name</span>) <span class=\"comment\">// 打印false，因为这时候长度符合规范</span></span><br><span class=\"line\">person.name <span class=\"operator\">=</span> <span class=\"string\">&quot;HyperJASON&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(person.<span class=\"variable\">$name</span>) <span class=\"comment\">// 打印true，因为这时候长度太长了</span></span><br></pre></td></tr></table></figure>\n\n<p>这个属性也用来可以返回别的东西</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@propertyWrapper</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StringWrapper</span> </span>&#123;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">  <span class=\"keyword\">var</span> projectedValue : <span class=\"type\">NSAttributedString</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">/// 构建出一个富文本对象</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"type\">NSAttributedString</span>(string: <span class=\"string\">&quot;--- <span class=\"subst\">\\(<span class=\"keyword\">self</span>.value)</span> ---&quot;</span>, attributes: [</span><br><span class=\"line\">          .foregroundColor : <span class=\"type\">UIColor</span>.red,</span><br><span class=\"line\">          .font : <span class=\"type\">UIFont</span>.systemFont(ofSize: <span class=\"number\">15</span>)</span><br><span class=\"line\">      ])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> wrappedValue : <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> value &#125;</span><br><span class=\"line\">      <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (minLength<span class=\"operator\">...</span>maxLength).contains(newValue.count) &#123;</span><br><span class=\"line\">              value <span class=\"operator\">=</span> newValue</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> minLength <span class=\"operator\">&gt;</span> newValue.count &#123;</span><br><span class=\"line\">              <span class=\"built_in\">print</span>(<span class=\"string\">&quot;字符串太短了&quot;</span>)</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"built_in\">print</span>(<span class=\"string\">&quot;字符串太长了&quot;</span>)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@StringWrapper</span>(minLength: <span class=\"number\">3</span>, maxLength: <span class=\"number\">5</span>) <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person <span class=\"operator\">=</span> <span class=\"type\">Person</span>()</span><br><span class=\"line\">person.name <span class=\"operator\">=</span> <span class=\"string\">&quot;JASON&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(person.<span class=\"variable\">$name</span>)</span><br><span class=\"line\"><span class=\"comment\">/*  打印出一个富文本对象</span></span><br><span class=\"line\"><span class=\"comment\">--- JASON ---&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    NSColor = &quot;UIExtendedSRGBColorSpace 1 0 0 1&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">    NSFont = &quot;&lt;UICTFont: 0x7fc199f06660&gt; font-family: \\&quot;.SFUI-Regular\\&quot;; font-weight: normal; font-style: normal; font-size: 15.00pt&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>本文主要讲述Swift5新特性Property Wrapper的使用</p>","more":"<p>Property Wrapper即属性包装器，用于对某个属性进行包装，包装后可以对其做一些约束、限制或者修改</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>举例，比如我们需要添加一个属性包装器用来包装字符串，对字符串长度进行限制，只有当字符串长度在允许范围内，才能被赋值到属性中</p>\n<p>创建一个属性包装器，<code>wrappedValue</code>是必须的，并且需要实现其setter和getter，在里面添加赋值判断逻辑</p>\n<p>我们可以提供两种属性包装器的初始化方法，一种是设置默认字符串长度上下限，一种是设置特定的字符串长度上下限</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@propertyWrapper</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StringWrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> value : <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> minLength : <span class=\"type\">Int</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> maxLength : <span class=\"type\">Int</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> wrappedValue : <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> value &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (minLength<span class=\"operator\">...</span>maxLength).contains(newValue.count) &#123;</span><br><span class=\"line\">                value <span class=\"operator\">=</span> newValue</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> minLength <span class=\"operator\">&gt;</span> newValue.count &#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;字符串太短了&quot;</span>)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&quot;字符串太长了&quot;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 默认5-10个字</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">init</span>()</span> &#123;</span><br><span class=\"line\">        minLength <span class=\"operator\">=</span> <span class=\"number\">5</span></span><br><span class=\"line\">        maxLength <span class=\"operator\">=</span> <span class=\"number\">10</span></span><br><span class=\"line\">        value <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 设置默认值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">minLength</span>: <span class=\"type\">Int</span>, <span class=\"params\">maxLength</span>: <span class=\"type\">Int</span>, <span class=\"params\">value</span>: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.maxLength <span class=\"operator\">=</span> maxLength</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.minLength <span class=\"operator\">=</span> minLength</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.value <span class=\"operator\">=</span> value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用属性包装器的方式如下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">/// 自定义初始化方式</span></span><br><span class=\"line\">    <span class=\"meta\">@StringWrapper</span>(minLength: <span class=\"number\">3</span>, maxLength: <span class=\"number\">5</span>) <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"comment\">/// 默认初始化方式</span></span><br><span class=\"line\">    <span class=\"meta\">@StringWrapper</span> <span class=\"keyword\">var</span> title : <span class=\"type\">String</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person <span class=\"operator\">=</span> <span class=\"type\">Person</span>()</span><br><span class=\"line\">person.name <span class=\"operator\">=</span> <span class=\"string\">&quot;ARCLIN&quot;</span></span><br><span class=\"line\">person.title <span class=\"operator\">=</span> <span class=\"string\">&quot;Hyper Agent GridMan&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(person.name) <span class=\"comment\">/// ARCLIN</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(person.title) <span class=\"comment\">/// 字符串太长了</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"从属性包装器中呈现一个值\"><a href=\"#从属性包装器中呈现一个值\" class=\"headerlink\" title=\"从属性包装器中呈现一个值\"></a>从属性包装器中呈现一个值</h2><p>属性包装器还提供了另外一个属性，这个属性一般情况下可以用来标记被包装的属性是否被修改过</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@propertyWrapper</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StringWrapper</span> </span>&#123;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">  <span class=\"keyword\">var</span> projectedValue <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> wrappedValue : <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> value &#125;</span><br><span class=\"line\">      <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (minLength<span class=\"operator\">...</span>maxLength).contains(newValue.count) &#123;</span><br><span class=\"line\">              value <span class=\"operator\">=</span> newValue</span><br><span class=\"line\">              projectedValue <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> minLength <span class=\"operator\">&gt;</span> newValue.count &#123;</span><br><span class=\"line\">              <span class=\"built_in\">print</span>(<span class=\"string\">&quot;字符串太短了&quot;</span>)</span><br><span class=\"line\">              projectedValue <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"built_in\">print</span>(<span class=\"string\">&quot;字符串太长了&quot;</span>)</span><br><span class=\"line\">              projectedValue <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以通过<code>$</code>符号来调用这个值</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@StringWrapper</span>(minLength: <span class=\"number\">3</span>, maxLength: <span class=\"number\">5</span>) <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person <span class=\"operator\">=</span> <span class=\"type\">Person</span>()</span><br><span class=\"line\">person.name <span class=\"operator\">=</span> <span class=\"string\">&quot;JASON&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(person.<span class=\"variable\">$name</span>) <span class=\"comment\">// 打印false，因为这时候长度符合规范</span></span><br><span class=\"line\">person.name <span class=\"operator\">=</span> <span class=\"string\">&quot;HyperJASON&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(person.<span class=\"variable\">$name</span>) <span class=\"comment\">// 打印true，因为这时候长度太长了</span></span><br></pre></td></tr></table></figure>\n\n<p>这个属性也用来可以返回别的东西</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@propertyWrapper</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StringWrapper</span> </span>&#123;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">  <span class=\"keyword\">var</span> projectedValue : <span class=\"type\">NSAttributedString</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">/// 构建出一个富文本对象</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"type\">NSAttributedString</span>(string: <span class=\"string\">&quot;--- <span class=\"subst\">\\(<span class=\"keyword\">self</span>.value)</span> ---&quot;</span>, attributes: [</span><br><span class=\"line\">          .foregroundColor : <span class=\"type\">UIColor</span>.red,</span><br><span class=\"line\">          .font : <span class=\"type\">UIFont</span>.systemFont(ofSize: <span class=\"number\">15</span>)</span><br><span class=\"line\">      ])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> wrappedValue : <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> value &#125;</span><br><span class=\"line\">      <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (minLength<span class=\"operator\">...</span>maxLength).contains(newValue.count) &#123;</span><br><span class=\"line\">              value <span class=\"operator\">=</span> newValue</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> minLength <span class=\"operator\">&gt;</span> newValue.count &#123;</span><br><span class=\"line\">              <span class=\"built_in\">print</span>(<span class=\"string\">&quot;字符串太短了&quot;</span>)</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"built_in\">print</span>(<span class=\"string\">&quot;字符串太长了&quot;</span>)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@StringWrapper</span>(minLength: <span class=\"number\">3</span>, maxLength: <span class=\"number\">5</span>) <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person <span class=\"operator\">=</span> <span class=\"type\">Person</span>()</span><br><span class=\"line\">person.name <span class=\"operator\">=</span> <span class=\"string\">&quot;JASON&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(person.<span class=\"variable\">$name</span>)</span><br><span class=\"line\"><span class=\"comment\">/*  打印出一个富文本对象</span></span><br><span class=\"line\"><span class=\"comment\">--- JASON ---&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    NSColor = &quot;UIExtendedSRGBColorSpace 1 0 0 1&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">    NSFont = &quot;&lt;UICTFont: 0x7fc199f06660&gt; font-family: \\&quot;.SFUI-Regular\\&quot;; font-weight: normal; font-style: normal; font-size: 15.00pt&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>"},{"title":"iOS 底层原理 --- 多线程","author":"Arclin","abbrlink":"f4b0e2bd","date":"2021-08-29T13:49:00.000Z","_content":"本文主要简述iOS中多线程的使用及其原理\n<!--more-->\n\n## 常见的多线程方案\n\n|技术方案|简介|语言|线程生命周期|使用频率|\n|:---:|:---|:---:|:---:|:---:|\n|pthread|<ul><li>一套通用的多线程API</li><li>适用于Unix\\Linux\\Windows等系统</li><li>跨平台\\可移植</li><li>使用难度大</li></ul>|C|程序员管理|几乎不用|\n|NSThread|<ul><li>使用更加面向对象</li><li>简单易用，可直接操作线程对象</li></ul>|OC|程序员管理|偶尔使用|\n|GCD|<ul><li>旨在替代NSThread等线程技术</li><li>充分利用设备的多核</li></ul>|C|自动管理|经常使用|\n|NSOperation|<ul><li>基于GCD</li><li>比GCD多了一些简单实用的功能</li><li>使用更加面向对象</li></ul>|OC|自动管理|经常使用|\n\n### 一些多线程术语\n\n- 同步、异步：能不能开启新的线程\n\t- 同步：在当前线程中执行任务，不具备开启新线程的能力\n    - 异步：在新的线程中执行任务，具备开启新线程的能力\n- 并发、串行：任务的执行方式\n\t- 并发：多个任务并发（同时）执行\n    - 串行：一个任务执行完毕后，再执行下一个任务\n\n### 各种队列的执行效果\n\n||并发队列|手动创建的串行队列|主队列|\n|---|---|---|---|\n|同步（sync）|没有开启新线程<br>串行执行任务|没有开启新线程<br>串行执行任务|没有开启新线程<br>串行执行任务|\n|异步（async）|有开启新线程<br>并发执行任务|有开启新线程<br>串行执行任务|没有开启新线程<br>串行执行任务|\n\n- 使用`sync`函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）\n\n- 死锁问题主要产生在串行队列中。由于串行队列的FIFO（First in first out）性质，如果串行队列中有同步函数，那么同步函数要等待串行队列执行完才能执行，又因为同步函数的性质是在当前线程立马执行函数体，所以同步函数后面的代码要等待同步函数执行完才能执行，在这种情况下就会出现死锁\n\n- 因为并发队列允许同时执行多个任务，所以不存在等待队列中其他人完成后才能开始执行的情况，所以一般情况下并发队列不会产生环路等待死锁\n\n## GCD\n\n### GCD的常用函数\n\n- 用同步的方式执行任务\n\n```objectivec\n/// queue 队列\n/// block 任务\ndispatch_sync(dispatch_queue_t queue,dispatch_block_t block);\n```\n\n- 用异步的方式执行任务\n\n```objectivec\n/// queue 队列\n/// block 任务\ndispatch_sync(dispatch_queue_t queue,dispatch_block_t block);\n```\n\n### GCD的队列\n\nGCD的队列可以分为2大类型\n\n- 并发队列（Concurrent Dispatch Queue）\n\n\t- 可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）\n    - 并发功能只有在异步（dispatch_async）函数下才有效\n    \n- 串行队列（Serial Dispatch Queue）\n\n\t- 让任务一个接着一个执行（一个任务执行完毕后，在执行下一个任务）\n    \n    \n### GCD的队列组\n\n```objectivec\n// 创建队列组\ndispatch_group_t group = dispatch_group_create();\n\n// 创建并发队列\ndispatch_queue_t queue = dispatch_queue_create(\"my_queue\", DISPATCH_QUEUE_CONCURRENT);\n\n// 添加异步任务\ndispatch_group_async(group, queue, ^{\n    for (int i = 0; i < 5; i++) {\n        NSLog(@\"任务1-%@\",[NSThread currentThread]);\n    }\n});\ndispatch_group_async(group, queue, ^{\n    for (int i = 0; i < 5; i++) {\n        NSLog(@\"任务2-%@\",[NSThread currentThread]);\n    }\n});\n\n// 等前面的任务执行完毕后，会自动执行这个任务\ndispatch_group_notify(group, dispatch_get_main_queue(), ^{\n    for (int i = 0; i < 5; i++) {\n        NSLog(@\"任务3-%@\",[NSThread currentThread]);\n    }\n});\n```\n\n## 多线程的安全隐患\n\n- 资源共享\n\t- 1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源\n    - 比如多个线程访问同一个对象，同一个变量，同一个文件\n    \n- 当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题\n\n\n解决方案：使用线程同步技术（同步，就是协同步调，按预定的先后持续进行）\n\n- 常见的线程同步技术是：加锁，常见线程同步方案如下\n\t- OSSpinLock\n    - os_unfair_lock\n    - pthread_mutex\n    - dispatch_semaphore\n    - dispatch_queue(DISPATCH_QUEUE_SERIAL)\n    - NSLock\n    - NSRecursiveLock\n    - NSCondition\n    - NSConditionLock\n    - @synchronized\n    \n### 串行队列\n\n线程同步的最直接的方案就是串行队列，让多条线程按顺序执行\n\n```\ndispatch_queue_t queue = dispatch_queue_create(\"queue\",DISPATCH_QUEUE_SERIAL);\n\ndispatch_sync(queue,^{\n    xxxx\n});\n\ndispatch_sync(queue,^{\n    xxxx\n});\n```\n\n### OSSpinLock\n\n> 这个锁在iOS 10之后被废弃了\n\n自旋锁，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源\n\n> 忙等：一边等待一边忙着做事情，相当于while(1){xxx}。自旋：自己一直在那里旋转\n\n> 需要导入头文件`<libkern/OSAtomic.h>`\n\n初始化\n\n```\nOSSpinLock lock = OS_SPINLOCK_INIT;\n```\n\n加锁\n\n```\nOSSpinLockLock(&_lock);\n```\n\n尝试加锁：如果需要等待就返回false，不加锁；如果不需要等待就返回true，加锁。\n\n```\nBool result = OSSpinLockTry(&_lock)\n```\n\n解锁\n\n```\nOSSpinLockUnlock(&_lock);\n```\n\n自旋锁现在已经不再安全，可能会出现优先级反转问题\n\n如果等待锁的优先级线程较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁\n\n\n### os_unfair_lock\n\n- `os_unfair_lock`用于取代不安全的`OSSpinLock`，从iOS10开始才支持\n- 从底层调用看，等待`os_unfair_lock`锁的线程会处于休眠状态，并非忙等\n- 需要导入头文件`<os/lock.h>`\n\n初始化\n\n```\nos_unfair_lock lock = OS_UNFAIR_LOCK_INIT;\n```\n\n加锁\n\n```objectivec\nos_unfair_lock_lock(&lock);\n```\n\n解锁\n\n```objectivec\nos_unfair_lock_unlock(&lock);\n```\n\n### phread_mutex\n\n- `mutex`叫做互斥锁，等待锁的线程会处于休眠状态\n- 需要导入头文件`<pthread.h>`\n\n初始化方法1\n\n```\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n```\n\n初始化方法2\n\n```\npthread_mutexattr_t attr;\npthread_mutexattr_init(&attr);\npthread_mutexattr_settype(&attr, PTHREAD_MUTEX_DEFAULT);\n\n/// 这里的第二个参数如果传NULL的话表示使用默认属性\npthread_mutex_init(&_mutex, &attr);\n\npthread_mutexattr_destory(&attr);\n```\n\n尝试加锁\n\n```\npthread_mutex_trylock(&mutex);\n```\n\n加锁\n\n```\npthread_mutex_lock(&mutex);\n```\n\n解锁\n\n```\npthread_mutex_unlock(&mutex);\n```\n\n\n#### 递归锁 \n\n锁的属性可以改为递归锁，即允许**同一个线程**对一把锁进行重复加锁\n```\n  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n```\n\n#### 条件锁\n\n初始化条件\n\n```\npthread_cond_t condition;\npthread_cond_init(&condition, NULL);\n```\n\n等待条件（进入休眠，放开mutex锁；被唤醒后，会再次对mutex加锁）\n\n```\npthread_cond_wait(&condition, &mutex);\n```\n\n激活**一个**等待该条件的线程（如果这时候有多个在等待，那么也只会激活最先等待的那个）\n\n```\npthread_cond_signal(&condition);\n```\n\n激活所有等待该条件的线程\n\n```\npthread_cond_brodcast(&condition);\n```\n\n销毁资源\n\n```\npthread_mutex_destory(&mutex);\npthread_cond_destory(&condition);\n```\n\n### NSLock\n\n- `NSLock`是对`mutex`普通锁的封装，即`pthread_mutex_init(&_mutex, NULL);`\n\n初始化\n\n```objectivec\nNSLock *lock = [[NSLock alloc] init];\n```\n\n加锁\n\n```objectivec\n- (void)lock;\n```\n\n尝试加锁(调用的瞬间立马去判断当前能不能加锁，能加就加，然后返回YES，然后继续往下走，如果不能加就返回NO，然后继续往下走)\n\n```objectivec\n- (BOOL)tryLock;\n```\n\n等待锁（调用的时候先阻塞，如果现在能加锁，就返回YES，加锁成功，继续往下走；如果不能加锁，就阻塞，如果在limit之前，锁被放开了，那么就加锁，返回YES，代码继续往下走；如果直到limit到了，锁还没被放开，那么就返回NO，加锁失败，代码继续往下走）\n\n```objectivec\n- (BOOL)lockBeforeDate:(NSDate *)limit;\n```\n\n解锁\n\n```objectivec\n- (void)unlock;\n```\n\n### NSRecursiveLock\n\n- `NSRecurseiveLock`也是对`mutex`递归锁的封装，API跟`NSLock`基本一致\n\n### NSCondition\n\n- `NSCondition`也是对`mutex`和`cont`的封装\n\n等待锁\n\n```objectivec\n- (void)wait;\n- (void)waitUtilDate:(NSDate *)limit;\n```\n\n激活锁\n\n```objectivec\n- (void)signal; // 激活单个\n- (void)boardcast; // 激活多个\n```\n\n### NSConditionLock\n\n- `NSConditionLock`是对`NSCondition`的进一步封装，可以设置具体的条件值\n\n初始化设定一个条件值，如果直接`init`的话那么默认值是0\n\n```\n - (instancetype)initWithCondition:(NSInteger)condition;\n```\n\n加锁并且设定条件值为`condition`\n\n```objectivec\n- (void)lockWhenCondition:(NSInteger)condition;\n- (BOOL)tryLockWhenCondition:(NSInteger)condition; // 尝试加锁\n- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit; // 在指定时间到达之前等待条件成立加锁\n```\n\n如果直接使用`lock`方法，那么会无视条件值，直接加锁或者等待加锁\n\n解当前的锁并且设置条件值为`condition`，如果这时候有条件值为`condition`的锁在加着，那么就会释放\n\n```objectivec\n- (void)unlockWhenCondition:(NSInteger)condition;\n```\n\n如果直接使用`unlock`方法，那么那些带条件的`lockWhenCondition`不会解锁\n\n### dispatch_semaphore\n\n- `semaphore`叫做信号量\n- 信号量的初始值，可以用来控制线程并发访问的最大数量\n\n初始化，传入一个允许的最大并发线程数`count`\n\n```\ndispatch_sempathore semaphore = dispatch_semaphore_create(count);\n```\n\n如果信号量的值<=0，当前线程就会进入休眠等待（直到信号量的值>0）\n如果信号量的值>0，就减1，然后往下执行后面的代码\n\n```\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n```\n\n让信号量的值加1\n```\ndispatch_semaphore_signal(semaphore);\n```\n\n### @synchronized\n\n- `@synchronized`是对`mutex`递归锁的封装\n\n传入对象即可，用于标记是不是同个锁，一个对象标记一把锁 \n\n```\n@synchronized(xxx) {\n\n}\n```\n\n### 线程同步方案性能比较\n\n- 性能从高到低排序\n\t- os_unfair_lock\n    - OSSpinLock\n    - dispatch_semaphore\n    - pthread_mutex\n    - dispatch_queue(DISPATCH_QUEUE_SERIAL)\n    - NSLock\n    - NSCondition\n    - pthread_mutex(recursive)\n    - NSRecursiveLock\n    - NSConditionLock\n    - @synchronized\n\n    \n## 自旋锁、互斥锁比较\n\n> iOS10之后已经不推荐使用自旋锁了\n\n- 什么情况使用自旋锁比较划算？\n\t- 预计线程等待锁的时间很短\n    - 加锁的代码（临界区）经常被调用，但竞争情况很少发生\n    - CPU资源不紧张\n    - 多核处理器\n   \n- 什么情况使用互斥锁比较划算？\n\t- 预计线程等待锁的时间较长\n    - 单核处理器\n    - 临界区有IO操作（因为比较占用CPU资源）\n    - 临界区代码复杂或者循环量大\n    \n\n## 读写安全\n\n### atomic\n\n`nonatomic`和`atomic` ：给属性加上`atomic`修饰，可以保证属性的`setter`和`getter`都是原子性操作，也就是保证`setter`和`getter`内部是线程同步的\n    \n参照runtime源码中 `objc-accessors.mm`的`objc_getProperty`和`reallySetProperty`方法，分别是get方法和set方法的内部实现\n\n```objectivec\nid objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) {\n    if (offset == 0) {\n        return object_getClass(self);\n    }\n\n    // Retain release world\n    id *slot = (id*) ((char*)self + offset);\n    if (!atomic) return *slot;\n    \n    // 如果是atomic的时候，会加上锁\n    \n    // Atomic retain release world\n    spinlock_t& slotlock = PropertyLocks[slot];\n    slotlock.lock();\n    id value = objc_retain(*slot);\n    slotlock.unlock();\n    \n    // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.\n    return objc_autoreleaseReturnValue(value);\n}\n\n```\n\n```objectivec\nstatic inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)\n{\n    if (offset == 0) {\n        object_setClass(self, newValue);\n        return;\n    }\n\n    id oldValue;\n    id *slot = (id*) ((char*)self + offset);\n\n    if (copy) {\n        newValue = [newValue copyWithZone:nil];\n    } else if (mutableCopy) {\n        newValue = [newValue mutableCopyWithZone:nil];\n    } else {\n        if (*slot == newValue) return;\n        newValue = objc_retain(newValue);\n    }\n\n    if (!atomic) {\n        oldValue = *slot;\n        *slot = newValue;\n    } else {\n    \t/// 这里可以看出如果是atomic的时候，是会加上锁的\n        spinlock_t& slotlock = PropertyLocks[slot];\n        slotlock.lock();\n        oldValue = *slot;\n        *slot = newValue;        \n        slotlock.unlock();\n    }\n\n    objc_release(oldValue);\n}\n```\n\n`atmoic`是不能保证使用属性的过程中是线程安全的，即虽然他的setter和getter是线程安全的，但是用这个属性去调用其他方法的时候依旧不一定属性安全，比如`[self.array addObject:xxx]`，这里只能保证取出array属性的时候线程安全，但是添加对象进去的时候就有可能出现线程同步问题\n\n### 读写安全方案\n\n#### 多读单写\n\n需求\n\n- 同一时间，只能有1条线程进行写的操作\n- 同一时间，允许有多条线程进行读的操作\n- 同一时间，不允许既有写的操作，又有读的操作\n\n解决方案\n\n- pthread_rwlock：读写锁\n- dispatch_barrier_async：异步栅栏调用\n\n#### pthread_rwlock\n\n- 等待锁的线程会进入休眠\n- 需要引入头文件<pthread.h>\n\n初始化锁\n\n```objectivec\npthread_rwlock_t lock;\npthread_rwlock_init(&lock,NULL);\n```\n\n读-加锁/尝试加锁\n\n```objectivec\npthread_rwlock_rdlock(&lock);\npthread_rwlock_tryrdlock(&lock);\n```\n\n写-加锁/尝试加锁\n\n```objectivec\npthread_rwlock_wrlock(&lock);\npthread_rwlock_trywrlock(&lock);\n```\n\n解锁\n\n```objectivec\npthread_rwlock_unlock(&lock);\n```\n\n销毁\n\n```objectivec\npthread_rwlock_destory(&lock);\n```\n\n#### dispatch_barrier_async\n\n- 这个函数传入的并发队列必须是自己通过`dispatch_queue_create`创建的\n- 如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于`dispatch_async`函数的效果\n\n```objctivec\n// 初始化队列\ndispatch_queue_t queue = dispatch_queue_create(\"rw_queue\",DISPATCH_QUEUE_CONCURRENT);\n\n// 读\ndispatch_async(queue,^{\n\t\n});\n\n// 写\ndispatch_barrier_async(queue, ^{\n\n});\n```\n    \n## 其他\n\n1. 子线程中，`performSelector:withObject:afterDelay:`不起作用的原因\n\t```objectivec\n    dispatch_queue_t queue = dispatch_get_global_queue(0,0);\n    dispatch_async(queue, ^{\n        NSLog(@\"1\");\n        [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n        NSLog(@\"3\");\n    });\n    ```\n\t- `performSelector:withObject:afterDelay:` 的本质是往Runloop中添加定时器\n\t- 子线程中默认没有启动`Runloop`\n    - 补充代码启动Runloop即可\n    \t```objectivec\n        [[NSRunloop currentRunloop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunloopMode];\n        [[NSRunloop currentRunloop] runMode:NSDefaultRunloopMode beforeDate:[NSDate distantFeature]];\n    \t```","source":"_posts/iOS-底层原理-多线程.md","raw":"title: iOS 底层原理 --- 多线程\nauthor: Arclin\ntags:\n  - iOS\n  - 底层原理\ncategories:\n  - iOS\nabbrlink: f4b0e2bd\ndate: 2021-08-29 21:49:00\n---\n本文主要简述iOS中多线程的使用及其原理\n<!--more-->\n\n## 常见的多线程方案\n\n|技术方案|简介|语言|线程生命周期|使用频率|\n|:---:|:---|:---:|:---:|:---:|\n|pthread|<ul><li>一套通用的多线程API</li><li>适用于Unix\\Linux\\Windows等系统</li><li>跨平台\\可移植</li><li>使用难度大</li></ul>|C|程序员管理|几乎不用|\n|NSThread|<ul><li>使用更加面向对象</li><li>简单易用，可直接操作线程对象</li></ul>|OC|程序员管理|偶尔使用|\n|GCD|<ul><li>旨在替代NSThread等线程技术</li><li>充分利用设备的多核</li></ul>|C|自动管理|经常使用|\n|NSOperation|<ul><li>基于GCD</li><li>比GCD多了一些简单实用的功能</li><li>使用更加面向对象</li></ul>|OC|自动管理|经常使用|\n\n### 一些多线程术语\n\n- 同步、异步：能不能开启新的线程\n\t- 同步：在当前线程中执行任务，不具备开启新线程的能力\n    - 异步：在新的线程中执行任务，具备开启新线程的能力\n- 并发、串行：任务的执行方式\n\t- 并发：多个任务并发（同时）执行\n    - 串行：一个任务执行完毕后，再执行下一个任务\n\n### 各种队列的执行效果\n\n||并发队列|手动创建的串行队列|主队列|\n|---|---|---|---|\n|同步（sync）|没有开启新线程<br>串行执行任务|没有开启新线程<br>串行执行任务|没有开启新线程<br>串行执行任务|\n|异步（async）|有开启新线程<br>并发执行任务|有开启新线程<br>串行执行任务|没有开启新线程<br>串行执行任务|\n\n- 使用`sync`函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）\n\n- 死锁问题主要产生在串行队列中。由于串行队列的FIFO（First in first out）性质，如果串行队列中有同步函数，那么同步函数要等待串行队列执行完才能执行，又因为同步函数的性质是在当前线程立马执行函数体，所以同步函数后面的代码要等待同步函数执行完才能执行，在这种情况下就会出现死锁\n\n- 因为并发队列允许同时执行多个任务，所以不存在等待队列中其他人完成后才能开始执行的情况，所以一般情况下并发队列不会产生环路等待死锁\n\n## GCD\n\n### GCD的常用函数\n\n- 用同步的方式执行任务\n\n```objectivec\n/// queue 队列\n/// block 任务\ndispatch_sync(dispatch_queue_t queue,dispatch_block_t block);\n```\n\n- 用异步的方式执行任务\n\n```objectivec\n/// queue 队列\n/// block 任务\ndispatch_sync(dispatch_queue_t queue,dispatch_block_t block);\n```\n\n### GCD的队列\n\nGCD的队列可以分为2大类型\n\n- 并发队列（Concurrent Dispatch Queue）\n\n\t- 可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）\n    - 并发功能只有在异步（dispatch_async）函数下才有效\n    \n- 串行队列（Serial Dispatch Queue）\n\n\t- 让任务一个接着一个执行（一个任务执行完毕后，在执行下一个任务）\n    \n    \n### GCD的队列组\n\n```objectivec\n// 创建队列组\ndispatch_group_t group = dispatch_group_create();\n\n// 创建并发队列\ndispatch_queue_t queue = dispatch_queue_create(\"my_queue\", DISPATCH_QUEUE_CONCURRENT);\n\n// 添加异步任务\ndispatch_group_async(group, queue, ^{\n    for (int i = 0; i < 5; i++) {\n        NSLog(@\"任务1-%@\",[NSThread currentThread]);\n    }\n});\ndispatch_group_async(group, queue, ^{\n    for (int i = 0; i < 5; i++) {\n        NSLog(@\"任务2-%@\",[NSThread currentThread]);\n    }\n});\n\n// 等前面的任务执行完毕后，会自动执行这个任务\ndispatch_group_notify(group, dispatch_get_main_queue(), ^{\n    for (int i = 0; i < 5; i++) {\n        NSLog(@\"任务3-%@\",[NSThread currentThread]);\n    }\n});\n```\n\n## 多线程的安全隐患\n\n- 资源共享\n\t- 1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源\n    - 比如多个线程访问同一个对象，同一个变量，同一个文件\n    \n- 当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题\n\n\n解决方案：使用线程同步技术（同步，就是协同步调，按预定的先后持续进行）\n\n- 常见的线程同步技术是：加锁，常见线程同步方案如下\n\t- OSSpinLock\n    - os_unfair_lock\n    - pthread_mutex\n    - dispatch_semaphore\n    - dispatch_queue(DISPATCH_QUEUE_SERIAL)\n    - NSLock\n    - NSRecursiveLock\n    - NSCondition\n    - NSConditionLock\n    - @synchronized\n    \n### 串行队列\n\n线程同步的最直接的方案就是串行队列，让多条线程按顺序执行\n\n```\ndispatch_queue_t queue = dispatch_queue_create(\"queue\",DISPATCH_QUEUE_SERIAL);\n\ndispatch_sync(queue,^{\n    xxxx\n});\n\ndispatch_sync(queue,^{\n    xxxx\n});\n```\n\n### OSSpinLock\n\n> 这个锁在iOS 10之后被废弃了\n\n自旋锁，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源\n\n> 忙等：一边等待一边忙着做事情，相当于while(1){xxx}。自旋：自己一直在那里旋转\n\n> 需要导入头文件`<libkern/OSAtomic.h>`\n\n初始化\n\n```\nOSSpinLock lock = OS_SPINLOCK_INIT;\n```\n\n加锁\n\n```\nOSSpinLockLock(&_lock);\n```\n\n尝试加锁：如果需要等待就返回false，不加锁；如果不需要等待就返回true，加锁。\n\n```\nBool result = OSSpinLockTry(&_lock)\n```\n\n解锁\n\n```\nOSSpinLockUnlock(&_lock);\n```\n\n自旋锁现在已经不再安全，可能会出现优先级反转问题\n\n如果等待锁的优先级线程较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁\n\n\n### os_unfair_lock\n\n- `os_unfair_lock`用于取代不安全的`OSSpinLock`，从iOS10开始才支持\n- 从底层调用看，等待`os_unfair_lock`锁的线程会处于休眠状态，并非忙等\n- 需要导入头文件`<os/lock.h>`\n\n初始化\n\n```\nos_unfair_lock lock = OS_UNFAIR_LOCK_INIT;\n```\n\n加锁\n\n```objectivec\nos_unfair_lock_lock(&lock);\n```\n\n解锁\n\n```objectivec\nos_unfair_lock_unlock(&lock);\n```\n\n### phread_mutex\n\n- `mutex`叫做互斥锁，等待锁的线程会处于休眠状态\n- 需要导入头文件`<pthread.h>`\n\n初始化方法1\n\n```\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n```\n\n初始化方法2\n\n```\npthread_mutexattr_t attr;\npthread_mutexattr_init(&attr);\npthread_mutexattr_settype(&attr, PTHREAD_MUTEX_DEFAULT);\n\n/// 这里的第二个参数如果传NULL的话表示使用默认属性\npthread_mutex_init(&_mutex, &attr);\n\npthread_mutexattr_destory(&attr);\n```\n\n尝试加锁\n\n```\npthread_mutex_trylock(&mutex);\n```\n\n加锁\n\n```\npthread_mutex_lock(&mutex);\n```\n\n解锁\n\n```\npthread_mutex_unlock(&mutex);\n```\n\n\n#### 递归锁 \n\n锁的属性可以改为递归锁，即允许**同一个线程**对一把锁进行重复加锁\n```\n  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n```\n\n#### 条件锁\n\n初始化条件\n\n```\npthread_cond_t condition;\npthread_cond_init(&condition, NULL);\n```\n\n等待条件（进入休眠，放开mutex锁；被唤醒后，会再次对mutex加锁）\n\n```\npthread_cond_wait(&condition, &mutex);\n```\n\n激活**一个**等待该条件的线程（如果这时候有多个在等待，那么也只会激活最先等待的那个）\n\n```\npthread_cond_signal(&condition);\n```\n\n激活所有等待该条件的线程\n\n```\npthread_cond_brodcast(&condition);\n```\n\n销毁资源\n\n```\npthread_mutex_destory(&mutex);\npthread_cond_destory(&condition);\n```\n\n### NSLock\n\n- `NSLock`是对`mutex`普通锁的封装，即`pthread_mutex_init(&_mutex, NULL);`\n\n初始化\n\n```objectivec\nNSLock *lock = [[NSLock alloc] init];\n```\n\n加锁\n\n```objectivec\n- (void)lock;\n```\n\n尝试加锁(调用的瞬间立马去判断当前能不能加锁，能加就加，然后返回YES，然后继续往下走，如果不能加就返回NO，然后继续往下走)\n\n```objectivec\n- (BOOL)tryLock;\n```\n\n等待锁（调用的时候先阻塞，如果现在能加锁，就返回YES，加锁成功，继续往下走；如果不能加锁，就阻塞，如果在limit之前，锁被放开了，那么就加锁，返回YES，代码继续往下走；如果直到limit到了，锁还没被放开，那么就返回NO，加锁失败，代码继续往下走）\n\n```objectivec\n- (BOOL)lockBeforeDate:(NSDate *)limit;\n```\n\n解锁\n\n```objectivec\n- (void)unlock;\n```\n\n### NSRecursiveLock\n\n- `NSRecurseiveLock`也是对`mutex`递归锁的封装，API跟`NSLock`基本一致\n\n### NSCondition\n\n- `NSCondition`也是对`mutex`和`cont`的封装\n\n等待锁\n\n```objectivec\n- (void)wait;\n- (void)waitUtilDate:(NSDate *)limit;\n```\n\n激活锁\n\n```objectivec\n- (void)signal; // 激活单个\n- (void)boardcast; // 激活多个\n```\n\n### NSConditionLock\n\n- `NSConditionLock`是对`NSCondition`的进一步封装，可以设置具体的条件值\n\n初始化设定一个条件值，如果直接`init`的话那么默认值是0\n\n```\n - (instancetype)initWithCondition:(NSInteger)condition;\n```\n\n加锁并且设定条件值为`condition`\n\n```objectivec\n- (void)lockWhenCondition:(NSInteger)condition;\n- (BOOL)tryLockWhenCondition:(NSInteger)condition; // 尝试加锁\n- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit; // 在指定时间到达之前等待条件成立加锁\n```\n\n如果直接使用`lock`方法，那么会无视条件值，直接加锁或者等待加锁\n\n解当前的锁并且设置条件值为`condition`，如果这时候有条件值为`condition`的锁在加着，那么就会释放\n\n```objectivec\n- (void)unlockWhenCondition:(NSInteger)condition;\n```\n\n如果直接使用`unlock`方法，那么那些带条件的`lockWhenCondition`不会解锁\n\n### dispatch_semaphore\n\n- `semaphore`叫做信号量\n- 信号量的初始值，可以用来控制线程并发访问的最大数量\n\n初始化，传入一个允许的最大并发线程数`count`\n\n```\ndispatch_sempathore semaphore = dispatch_semaphore_create(count);\n```\n\n如果信号量的值<=0，当前线程就会进入休眠等待（直到信号量的值>0）\n如果信号量的值>0，就减1，然后往下执行后面的代码\n\n```\ndispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n```\n\n让信号量的值加1\n```\ndispatch_semaphore_signal(semaphore);\n```\n\n### @synchronized\n\n- `@synchronized`是对`mutex`递归锁的封装\n\n传入对象即可，用于标记是不是同个锁，一个对象标记一把锁 \n\n```\n@synchronized(xxx) {\n\n}\n```\n\n### 线程同步方案性能比较\n\n- 性能从高到低排序\n\t- os_unfair_lock\n    - OSSpinLock\n    - dispatch_semaphore\n    - pthread_mutex\n    - dispatch_queue(DISPATCH_QUEUE_SERIAL)\n    - NSLock\n    - NSCondition\n    - pthread_mutex(recursive)\n    - NSRecursiveLock\n    - NSConditionLock\n    - @synchronized\n\n    \n## 自旋锁、互斥锁比较\n\n> iOS10之后已经不推荐使用自旋锁了\n\n- 什么情况使用自旋锁比较划算？\n\t- 预计线程等待锁的时间很短\n    - 加锁的代码（临界区）经常被调用，但竞争情况很少发生\n    - CPU资源不紧张\n    - 多核处理器\n   \n- 什么情况使用互斥锁比较划算？\n\t- 预计线程等待锁的时间较长\n    - 单核处理器\n    - 临界区有IO操作（因为比较占用CPU资源）\n    - 临界区代码复杂或者循环量大\n    \n\n## 读写安全\n\n### atomic\n\n`nonatomic`和`atomic` ：给属性加上`atomic`修饰，可以保证属性的`setter`和`getter`都是原子性操作，也就是保证`setter`和`getter`内部是线程同步的\n    \n参照runtime源码中 `objc-accessors.mm`的`objc_getProperty`和`reallySetProperty`方法，分别是get方法和set方法的内部实现\n\n```objectivec\nid objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) {\n    if (offset == 0) {\n        return object_getClass(self);\n    }\n\n    // Retain release world\n    id *slot = (id*) ((char*)self + offset);\n    if (!atomic) return *slot;\n    \n    // 如果是atomic的时候，会加上锁\n    \n    // Atomic retain release world\n    spinlock_t& slotlock = PropertyLocks[slot];\n    slotlock.lock();\n    id value = objc_retain(*slot);\n    slotlock.unlock();\n    \n    // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.\n    return objc_autoreleaseReturnValue(value);\n}\n\n```\n\n```objectivec\nstatic inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)\n{\n    if (offset == 0) {\n        object_setClass(self, newValue);\n        return;\n    }\n\n    id oldValue;\n    id *slot = (id*) ((char*)self + offset);\n\n    if (copy) {\n        newValue = [newValue copyWithZone:nil];\n    } else if (mutableCopy) {\n        newValue = [newValue mutableCopyWithZone:nil];\n    } else {\n        if (*slot == newValue) return;\n        newValue = objc_retain(newValue);\n    }\n\n    if (!atomic) {\n        oldValue = *slot;\n        *slot = newValue;\n    } else {\n    \t/// 这里可以看出如果是atomic的时候，是会加上锁的\n        spinlock_t& slotlock = PropertyLocks[slot];\n        slotlock.lock();\n        oldValue = *slot;\n        *slot = newValue;        \n        slotlock.unlock();\n    }\n\n    objc_release(oldValue);\n}\n```\n\n`atmoic`是不能保证使用属性的过程中是线程安全的，即虽然他的setter和getter是线程安全的，但是用这个属性去调用其他方法的时候依旧不一定属性安全，比如`[self.array addObject:xxx]`，这里只能保证取出array属性的时候线程安全，但是添加对象进去的时候就有可能出现线程同步问题\n\n### 读写安全方案\n\n#### 多读单写\n\n需求\n\n- 同一时间，只能有1条线程进行写的操作\n- 同一时间，允许有多条线程进行读的操作\n- 同一时间，不允许既有写的操作，又有读的操作\n\n解决方案\n\n- pthread_rwlock：读写锁\n- dispatch_barrier_async：异步栅栏调用\n\n#### pthread_rwlock\n\n- 等待锁的线程会进入休眠\n- 需要引入头文件<pthread.h>\n\n初始化锁\n\n```objectivec\npthread_rwlock_t lock;\npthread_rwlock_init(&lock,NULL);\n```\n\n读-加锁/尝试加锁\n\n```objectivec\npthread_rwlock_rdlock(&lock);\npthread_rwlock_tryrdlock(&lock);\n```\n\n写-加锁/尝试加锁\n\n```objectivec\npthread_rwlock_wrlock(&lock);\npthread_rwlock_trywrlock(&lock);\n```\n\n解锁\n\n```objectivec\npthread_rwlock_unlock(&lock);\n```\n\n销毁\n\n```objectivec\npthread_rwlock_destory(&lock);\n```\n\n#### dispatch_barrier_async\n\n- 这个函数传入的并发队列必须是自己通过`dispatch_queue_create`创建的\n- 如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于`dispatch_async`函数的效果\n\n```objctivec\n// 初始化队列\ndispatch_queue_t queue = dispatch_queue_create(\"rw_queue\",DISPATCH_QUEUE_CONCURRENT);\n\n// 读\ndispatch_async(queue,^{\n\t\n});\n\n// 写\ndispatch_barrier_async(queue, ^{\n\n});\n```\n    \n## 其他\n\n1. 子线程中，`performSelector:withObject:afterDelay:`不起作用的原因\n\t```objectivec\n    dispatch_queue_t queue = dispatch_get_global_queue(0,0);\n    dispatch_async(queue, ^{\n        NSLog(@\"1\");\n        [self performSelector:@selector(test) withObject:nil afterDelay:.0];\n        NSLog(@\"3\");\n    });\n    ```\n\t- `performSelector:withObject:afterDelay:` 的本质是往Runloop中添加定时器\n\t- 子线程中默认没有启动`Runloop`\n    - 补充代码启动Runloop即可\n    \t```objectivec\n        [[NSRunloop currentRunloop] addPort:[[NSPort alloc] init] forMode:NSDefaultRunloopMode];\n        [[NSRunloop currentRunloop] runMode:NSDefaultRunloopMode beforeDate:[NSDate distantFeature]];\n    \t```","slug":"iOS-底层原理-多线程","published":1,"updated":"2021-08-29T09:21:53.755Z","_id":"ckrqejbaa0000i0n043mvdn10","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文主要简述iOS中多线程的使用及其原理</p>\n<span id=\"more\"></span>\n\n<h2 id=\"常见的多线程方案\"><a href=\"#常见的多线程方案\" class=\"headerlink\" title=\"常见的多线程方案\"></a>常见的多线程方案</h2><table>\n<thead>\n<tr>\n<th align=\"center\">技术方案</th>\n<th align=\"left\">简介</th>\n<th align=\"center\">语言</th>\n<th align=\"center\">线程生命周期</th>\n<th align=\"center\">使用频率</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">pthread</td>\n<td align=\"left\"><ul><li>一套通用的多线程API</li><li>适用于Unix\\Linux\\Windows等系统</li><li>跨平台\\可移植</li><li>使用难度大</li></ul></td>\n<td align=\"center\">C</td>\n<td align=\"center\">程序员管理</td>\n<td align=\"center\">几乎不用</td>\n</tr>\n<tr>\n<td align=\"center\">NSThread</td>\n<td align=\"left\"><ul><li>使用更加面向对象</li><li>简单易用，可直接操作线程对象</li></ul></td>\n<td align=\"center\">OC</td>\n<td align=\"center\">程序员管理</td>\n<td align=\"center\">偶尔使用</td>\n</tr>\n<tr>\n<td align=\"center\">GCD</td>\n<td align=\"left\"><ul><li>旨在替代NSThread等线程技术</li><li>充分利用设备的多核</li></ul></td>\n<td align=\"center\">C</td>\n<td align=\"center\">自动管理</td>\n<td align=\"center\">经常使用</td>\n</tr>\n<tr>\n<td align=\"center\">NSOperation</td>\n<td align=\"left\"><ul><li>基于GCD</li><li>比GCD多了一些简单实用的功能</li><li>使用更加面向对象</li></ul></td>\n<td align=\"center\">OC</td>\n<td align=\"center\">自动管理</td>\n<td align=\"center\">经常使用</td>\n</tr>\n</tbody></table>\n<h3 id=\"一些多线程术语\"><a href=\"#一些多线程术语\" class=\"headerlink\" title=\"一些多线程术语\"></a>一些多线程术语</h3><ul>\n<li>同步、异步：能不能开启新的线程<ul>\n<li>同步：在当前线程中执行任务，不具备开启新线程的能力</li>\n<li>异步：在新的线程中执行任务，具备开启新线程的能力</li>\n</ul>\n</li>\n<li>并发、串行：任务的执行方式<ul>\n<li>并发：多个任务并发（同时）执行</li>\n<li>串行：一个任务执行完毕后，再执行下一个任务</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"各种队列的执行效果\"><a href=\"#各种队列的执行效果\" class=\"headerlink\" title=\"各种队列的执行效果\"></a>各种队列的执行效果</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>并发队列</th>\n<th>手动创建的串行队列</th>\n<th>主队列</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>同步（sync）</td>\n<td>没有开启新线程<br>串行执行任务</td>\n<td>没有开启新线程<br>串行执行任务</td>\n<td>没有开启新线程<br>串行执行任务</td>\n</tr>\n<tr>\n<td>异步（async）</td>\n<td>有开启新线程<br>并发执行任务</td>\n<td>有开启新线程<br>串行执行任务</td>\n<td>没有开启新线程<br>串行执行任务</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>使用<code>sync</code>函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）</p>\n</li>\n<li><p>死锁问题主要产生在串行队列中。由于串行队列的FIFO（First in first out）性质，如果串行队列中有同步函数，那么同步函数要等待串行队列执行完才能执行，又因为同步函数的性质是在当前线程立马执行函数体，所以同步函数后面的代码要等待同步函数执行完才能执行，在这种情况下就会出现死锁</p>\n</li>\n<li><p>因为并发队列允许同时执行多个任务，所以不存在等待队列中其他人完成后才能开始执行的情况，所以一般情况下并发队列不会产生环路等待死锁</p>\n</li>\n</ul>\n<h2 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h2><h3 id=\"GCD的常用函数\"><a href=\"#GCD的常用函数\" class=\"headerlink\" title=\"GCD的常用函数\"></a>GCD的常用函数</h3><ul>\n<li>用同步的方式执行任务</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// queue 队列</span></span><br><span class=\"line\"><span class=\"comment\">/// block 任务</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(<span class=\"built_in\">dispatch_queue_t</span> queue,dispatch_block_t block);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>用异步的方式执行任务</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// queue 队列</span></span><br><span class=\"line\"><span class=\"comment\">/// block 任务</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(<span class=\"built_in\">dispatch_queue_t</span> queue,dispatch_block_t block);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"GCD的队列\"><a href=\"#GCD的队列\" class=\"headerlink\" title=\"GCD的队列\"></a>GCD的队列</h3><p>GCD的队列可以分为2大类型</p>\n<ul>\n<li><p>并发队列（Concurrent Dispatch Queue）</p>\n<ul>\n<li>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）</li>\n<li>并发功能只有在异步（dispatch_async）函数下才有效</li>\n</ul>\n</li>\n<li><p>串行队列（Serial Dispatch Queue）</p>\n<ul>\n<li>让任务一个接着一个执行（一个任务执行完毕后，在执行下一个任务）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GCD的队列组\"><a href=\"#GCD的队列组\" class=\"headerlink\" title=\"GCD的队列组\"></a>GCD的队列组</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建队列组</span></span><br><span class=\"line\">dispatch_group_t group = dispatch_group_create();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并发队列</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_queue_create(<span class=\"string\">&quot;my_queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加异步任务</span></span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;任务1-%@&quot;</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;任务2-%@&quot;</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等前面的任务执行完毕后，会自动执行这个任务</span></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;任务3-%@&quot;</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"多线程的安全隐患\"><a href=\"#多线程的安全隐患\" class=\"headerlink\" title=\"多线程的安全隐患\"></a>多线程的安全隐患</h2><ul>\n<li>资源共享<ul>\n<li>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源</li>\n<li>比如多个线程访问同一个对象，同一个变量，同一个文件</li>\n</ul>\n</li>\n<li>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题</li>\n</ul>\n<p>解决方案：使用线程同步技术（同步，就是协同步调，按预定的先后持续进行）</p>\n<ul>\n<li>常见的线程同步技术是：加锁，常见线程同步方案如下<ul>\n<li>OSSpinLock</li>\n<li>os_unfair_lock</li>\n<li>pthread_mutex</li>\n<li>dispatch_semaphore</li>\n<li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li>\n<li>NSLock</li>\n<li>NSRecursiveLock</li>\n<li>NSCondition</li>\n<li>NSConditionLock</li>\n<li>@synchronized</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"串行队列\"><a href=\"#串行队列\" class=\"headerlink\" title=\"串行队列\"></a>串行队列</h3><p>线程同步的最直接的方案就是串行队列，让多条线程按顺序执行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dispatch_queue_t</span> queue = <span class=\"built_in\">dispatch_queue_create</span>(<span class=\"string\">&quot;queue&quot;</span>,DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(queue,^&#123;</span><br><span class=\"line\">    xxxx</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(queue,^&#123;</span><br><span class=\"line\">    xxxx</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"OSSpinLock\"><a href=\"#OSSpinLock\" class=\"headerlink\" title=\"OSSpinLock\"></a>OSSpinLock</h3><blockquote>\n<p>这个锁在iOS 10之后被废弃了</p>\n</blockquote>\n<p>自旋锁，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源</p>\n<blockquote>\n<p>忙等：一边等待一边忙着做事情，相当于while(1){xxx}。自旋：自己一直在那里旋转</p>\n</blockquote>\n<blockquote>\n<p>需要导入头文件<code>&lt;libkern/OSAtomic.h&gt;</code></p>\n</blockquote>\n<p>初始化</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">OSSpinLock lock</span> = OS_SPINLOCK_INIT;</span><br></pre></td></tr></table></figure>\n\n<p>加锁</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"constructor\">OSSpinLockLock(&amp;<span class=\"params\">_lock</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>尝试加锁：如果需要等待就返回false，不加锁；如果不需要等待就返回true，加锁。</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">Bool</span> <span class=\"variable\"><span class=\"class\">result</span></span> = <span class=\"function\"><span class=\"title\">OSSpinLockTry</span>(&amp;<span class=\"variable\">_lock</span>)</span></span><br></pre></td></tr></table></figure>\n\n<p>解锁</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"constructor\">OSSpinLockUnlock(&amp;<span class=\"params\">_lock</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>自旋锁现在已经不再安全，可能会出现优先级反转问题</p>\n<p>如果等待锁的优先级线程较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁</p>\n<h3 id=\"os-unfair-lock\"><a href=\"#os-unfair-lock\" class=\"headerlink\" title=\"os_unfair_lock\"></a>os_unfair_lock</h3><ul>\n<li><code>os_unfair_lock</code>用于取代不安全的<code>OSSpinLock</code>，从iOS10开始才支持</li>\n<li>从底层调用看，等待<code>os_unfair_lock</code>锁的线程会处于休眠状态，并非忙等</li>\n<li>需要导入头文件<code>&lt;os/lock.h&gt;</code></li>\n</ul>\n<p>初始化</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">os_unfair_lock lock</span> = OS_UNFAIR_LOCK_INIT;</span><br></pre></td></tr></table></figure>\n\n<p>加锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">os_unfair_lock_lock(&amp;lock);</span><br></pre></td></tr></table></figure>\n\n<p>解锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">os_unfair_lock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"phread-mutex\"><a href=\"#phread-mutex\" class=\"headerlink\" title=\"phread_mutex\"></a>phread_mutex</h3><ul>\n<li><code>mutex</code>叫做互斥锁，等待锁的线程会处于休眠状态</li>\n<li>需要导入头文件<code>&lt;pthread.h&gt;</code></li>\n</ul>\n<p>初始化方法1</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">pthread_mutex_t mutex</span> = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>\n\n<p>初始化方法2</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread_mutexattr_t attr;</span><br><span class=\"line\">pthread<span class=\"constructor\">_mutexattr_init(&amp;<span class=\"params\">attr</span>)</span>;</span><br><span class=\"line\">pthread<span class=\"constructor\">_mutexattr_settype(&amp;<span class=\"params\">attr</span>, PTHREAD_MUTEX_DEFAULT)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 这里的第二个参数如果传NULL的话表示使用默认属性</span></span><br><span class=\"line\">pthread<span class=\"constructor\">_mutex_init(&amp;<span class=\"params\">_mutex</span>, &amp;<span class=\"params\">attr</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">pthread<span class=\"constructor\">_mutexattr_destory(&amp;<span class=\"params\">attr</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>尝试加锁</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread<span class=\"constructor\">_mutex_trylock(&amp;<span class=\"params\">mutex</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>加锁</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread<span class=\"constructor\">_mutex_lock(&amp;<span class=\"params\">mutex</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>解锁</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread<span class=\"constructor\">_mutex_unlock(&amp;<span class=\"params\">mutex</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"递归锁\"><a href=\"#递归锁\" class=\"headerlink\" title=\"递归锁\"></a>递归锁</h4><p>锁的属性可以改为递归锁，即允许<strong>同一个线程</strong>对一把锁进行重复加锁</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread<span class=\"constructor\">_mutexattr_settype(&amp;<span class=\"params\">attr</span>, PTHREAD_MUTEX_RECURSIVE)</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"条件锁\"><a href=\"#条件锁\" class=\"headerlink\" title=\"条件锁\"></a>条件锁</h4><p>初始化条件</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread_cond_t <span class=\"keyword\">condition</span>;</span><br><span class=\"line\">pthread_cond_init(<span class=\"operator\">&amp;</span><span class=\"keyword\">condition</span>, <span class=\"keyword\">NULL</span>);</span><br></pre></td></tr></table></figure>\n\n<p>等待条件（进入休眠，放开mutex锁；被唤醒后，会再次对mutex加锁）</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread<span class=\"constructor\">_cond_wait(&amp;<span class=\"params\">condition</span>, &amp;<span class=\"params\">mutex</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>激活<strong>一个</strong>等待该条件的线程（如果这时候有多个在等待，那么也只会激活最先等待的那个）</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread<span class=\"constructor\">_cond_signal(&amp;<span class=\"params\">condition</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>激活所有等待该条件的线程</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread<span class=\"constructor\">_cond_brodcast(&amp;<span class=\"params\">condition</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>销毁资源</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread<span class=\"constructor\">_mutex_destory(&amp;<span class=\"params\">mutex</span>)</span>;</span><br><span class=\"line\">pthread<span class=\"constructor\">_cond_destory(&amp;<span class=\"params\">condition</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NSLock\"><a href=\"#NSLock\" class=\"headerlink\" title=\"NSLock\"></a>NSLock</h3><ul>\n<li><code>NSLock</code>是对<code>mutex</code>普通锁的封装，即<code>pthread_mutex_init(&amp;_mutex, NULL);</code></li>\n</ul>\n<p>初始化</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSLock</span> *lock = [[<span class=\"built_in\">NSLock</span> alloc] init];</span><br></pre></td></tr></table></figure>\n\n<p>加锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)lock;</span><br></pre></td></tr></table></figure>\n\n<p>尝试加锁(调用的瞬间立马去判断当前能不能加锁，能加就加，然后返回YES，然后继续往下走，如果不能加就返回NO，然后继续往下走)</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)tryLock;</span><br></pre></td></tr></table></figure>\n\n<p>等待锁（调用的时候先阻塞，如果现在能加锁，就返回YES，加锁成功，继续往下走；如果不能加锁，就阻塞，如果在limit之前，锁被放开了，那么就加锁，返回YES，代码继续往下走；如果直到limit到了，锁还没被放开，那么就返回NO，加锁失败，代码继续往下走）</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)lockBeforeDate:(<span class=\"built_in\">NSDate</span> *)limit;</span><br></pre></td></tr></table></figure>\n\n<p>解锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)unlock;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NSRecursiveLock\"><a href=\"#NSRecursiveLock\" class=\"headerlink\" title=\"NSRecursiveLock\"></a>NSRecursiveLock</h3><ul>\n<li><code>NSRecurseiveLock</code>也是对<code>mutex</code>递归锁的封装，API跟<code>NSLock</code>基本一致</li>\n</ul>\n<h3 id=\"NSCondition\"><a href=\"#NSCondition\" class=\"headerlink\" title=\"NSCondition\"></a>NSCondition</h3><ul>\n<li><code>NSCondition</code>也是对<code>mutex</code>和<code>cont</code>的封装</li>\n</ul>\n<p>等待锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)wait;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)waitUtilDate:(<span class=\"built_in\">NSDate</span> *)limit;</span><br></pre></td></tr></table></figure>\n\n<p>激活锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)signal; <span class=\"comment\">// 激活单个</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)boardcast; <span class=\"comment\">// 激活多个</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NSConditionLock\"><a href=\"#NSConditionLock\" class=\"headerlink\" title=\"NSConditionLock\"></a>NSConditionLock</h3><ul>\n<li><code>NSConditionLock</code>是对<code>NSCondition</code>的进一步封装，可以设置具体的条件值</li>\n</ul>\n<p>初始化设定一个条件值，如果直接<code>init</code>的话那么默认值是0</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instance<span class=\"keyword\">type</span>)initWithCondition:(<span class=\"type\">NSInteger</span>)condition;</span><br></pre></td></tr></table></figure>\n\n<p>加锁并且设定条件值为<code>condition</code></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)lockWhenCondition:(<span class=\"built_in\">NSInteger</span>)condition;</span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)tryLockWhenCondition:(<span class=\"built_in\">NSInteger</span>)condition; <span class=\"comment\">// 尝试加锁</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)lockWhenCondition:(<span class=\"built_in\">NSInteger</span>)condition beforeDate:(<span class=\"built_in\">NSDate</span> *)limit; <span class=\"comment\">// 在指定时间到达之前等待条件成立加锁</span></span><br></pre></td></tr></table></figure>\n\n<p>如果直接使用<code>lock</code>方法，那么会无视条件值，直接加锁或者等待加锁</p>\n<p>解当前的锁并且设置条件值为<code>condition</code>，如果这时候有条件值为<code>condition</code>的锁在加着，那么就会释放</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)unlockWhenCondition:(<span class=\"built_in\">NSInteger</span>)condition;</span><br></pre></td></tr></table></figure>\n\n<p>如果直接使用<code>unlock</code>方法，那么那些带条件的<code>lockWhenCondition</code>不会解锁</p>\n<h3 id=\"dispatch-semaphore\"><a href=\"#dispatch-semaphore\" class=\"headerlink\" title=\"dispatch_semaphore\"></a>dispatch_semaphore</h3><ul>\n<li><code>semaphore</code>叫做信号量</li>\n<li>信号量的初始值，可以用来控制线程并发访问的最大数量</li>\n</ul>\n<p>初始化，传入一个允许的最大并发线程数<code>count</code></p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">dispatch_sempathore semaphore</span> = dispatch_semaphore_create(count);</span><br></pre></td></tr></table></figure>\n\n<p>如果信号量的值&lt;=0，当前线程就会进入休眠等待（直到信号量的值&gt;0）<br>如果信号量的值&gt;0，就减1，然后往下执行后面的代码</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch<span class=\"constructor\">_semaphore_wait(<span class=\"params\">semaphore</span>, DISPATCH_TIME_FOREVER)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>让信号量的值加1</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch<span class=\"constructor\">_semaphore_signal(<span class=\"params\">semaphore</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"@synchronized\"></a>@synchronized</h3><ul>\n<li><code>@synchronized</code>是对<code>mutex</code>递归锁的封装</li>\n</ul>\n<p>传入对象即可，用于标记是不是同个锁，一个对象标记一把锁 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@synchronized(xxx)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"线程同步方案性能比较\"><a href=\"#线程同步方案性能比较\" class=\"headerlink\" title=\"线程同步方案性能比较\"></a>线程同步方案性能比较</h3><ul>\n<li>性能从高到低排序<ul>\n<li>os_unfair_lock</li>\n<li>OSSpinLock</li>\n<li>dispatch_semaphore</li>\n<li>pthread_mutex</li>\n<li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li>\n<li>NSLock</li>\n<li>NSCondition</li>\n<li>pthread_mutex(recursive)</li>\n<li>NSRecursiveLock</li>\n<li>NSConditionLock</li>\n<li>@synchronized</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"自旋锁、互斥锁比较\"><a href=\"#自旋锁、互斥锁比较\" class=\"headerlink\" title=\"自旋锁、互斥锁比较\"></a>自旋锁、互斥锁比较</h2><blockquote>\n<p>iOS10之后已经不推荐使用自旋锁了</p>\n</blockquote>\n<ul>\n<li>什么情况使用自旋锁比较划算？<ul>\n<li>预计线程等待锁的时间很短</li>\n<li>加锁的代码（临界区）经常被调用，但竞争情况很少发生</li>\n<li>CPU资源不紧张</li>\n<li>多核处理器</li>\n</ul>\n</li>\n<li>什么情况使用互斥锁比较划算？<ul>\n<li>预计线程等待锁的时间较长</li>\n<li>单核处理器</li>\n<li>临界区有IO操作（因为比较占用CPU资源）</li>\n<li>临界区代码复杂或者循环量大</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"读写安全\"><a href=\"#读写安全\" class=\"headerlink\" title=\"读写安全\"></a>读写安全</h2><h3 id=\"atomic\"><a href=\"#atomic\" class=\"headerlink\" title=\"atomic\"></a>atomic</h3><p><code>nonatomic</code>和<code>atomic</code> ：给属性加上<code>atomic</code>修饰，可以保证属性的<code>setter</code>和<code>getter</code>都是原子性操作，也就是保证<code>setter</code>和<code>getter</code>内部是线程同步的</p>\n<p>参照runtime源码中 <code>objc-accessors.mm</code>的<code>objc_getProperty</code>和<code>reallySetProperty</code>方法，分别是get方法和set方法的内部实现</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> objc_getProperty(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, ptrdiff_t offset, <span class=\"built_in\">BOOL</span> atomic) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offset == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object_getClass(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Retain release world</span></span><br><span class=\"line\">    <span class=\"keyword\">id</span> *slot = (<span class=\"keyword\">id</span>*) ((<span class=\"keyword\">char</span>*)<span class=\"keyword\">self</span> + offset);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!atomic) <span class=\"keyword\">return</span> *slot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果是atomic的时候，会加上锁</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Atomic retain release world</span></span><br><span class=\"line\">    spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class=\"line\">    slotlock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">id</span> value = objc_retain(*slot);</span><br><span class=\"line\">    slotlock.unlock();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_autoreleaseReturnValue(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> reallySetProperty(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, <span class=\"keyword\">id</span> newValue, ptrdiff_t offset, <span class=\"keyword\">bool</span> atomic, <span class=\"keyword\">bool</span> <span class=\"keyword\">copy</span>, <span class=\"keyword\">bool</span> mutableCopy)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offset == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        object_setClass(<span class=\"keyword\">self</span>, newValue);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">id</span> oldValue;</span><br><span class=\"line\">    <span class=\"keyword\">id</span> *slot = (<span class=\"keyword\">id</span>*) ((<span class=\"keyword\">char</span>*)<span class=\"keyword\">self</span> + offset);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">copy</span>) &#123;</span><br><span class=\"line\">        newValue = [newValue copyWithZone:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mutableCopy) &#123;</span><br><span class=\"line\">        newValue = [newValue mutableCopyWithZone:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*slot == newValue) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        newValue = objc_retain(newValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!atomic) &#123;</span><br><span class=\"line\">        oldValue = *slot;</span><br><span class=\"line\">        *slot = newValue;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">/// 这里可以看出如果是atomic的时候，是会加上锁的</span></span><br><span class=\"line\">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class=\"line\">        slotlock.lock();</span><br><span class=\"line\">        oldValue = *slot;</span><br><span class=\"line\">        *slot = newValue;        </span><br><span class=\"line\">        slotlock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    objc_release(oldValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>atmoic</code>是不能保证使用属性的过程中是线程安全的，即虽然他的setter和getter是线程安全的，但是用这个属性去调用其他方法的时候依旧不一定属性安全，比如<code>[self.array addObject:xxx]</code>，这里只能保证取出array属性的时候线程安全，但是添加对象进去的时候就有可能出现线程同步问题</p>\n<h3 id=\"读写安全方案\"><a href=\"#读写安全方案\" class=\"headerlink\" title=\"读写安全方案\"></a>读写安全方案</h3><h4 id=\"多读单写\"><a href=\"#多读单写\" class=\"headerlink\" title=\"多读单写\"></a>多读单写</h4><p>需求</p>\n<ul>\n<li>同一时间，只能有1条线程进行写的操作</li>\n<li>同一时间，允许有多条线程进行读的操作</li>\n<li>同一时间，不允许既有写的操作，又有读的操作</li>\n</ul>\n<p>解决方案</p>\n<ul>\n<li>pthread_rwlock：读写锁</li>\n<li>dispatch_barrier_async：异步栅栏调用</li>\n</ul>\n<h4 id=\"pthread-rwlock\"><a href=\"#pthread-rwlock\" class=\"headerlink\" title=\"pthread_rwlock\"></a>pthread_rwlock</h4><ul>\n<li>等待锁的线程会进入休眠</li>\n<li>需要引入头文件&lt;pthread.h&gt;</li>\n</ul>\n<p>初始化锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread_rwlock_t lock;</span><br><span class=\"line\">pthread_rwlock_init(&amp;lock,<span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure>\n\n<p>读-加锁/尝试加锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread_rwlock_rdlock(&amp;lock);</span><br><span class=\"line\">pthread_rwlock_tryrdlock(&amp;lock);</span><br></pre></td></tr></table></figure>\n\n<p>写-加锁/尝试加锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread_rwlock_wrlock(&amp;lock);</span><br><span class=\"line\">pthread_rwlock_trywrlock(&amp;lock);</span><br></pre></td></tr></table></figure>\n\n<p>解锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread_rwlock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>\n\n<p>销毁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread_rwlock_destory(&amp;lock);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"dispatch-barrier-async\"><a href=\"#dispatch-barrier-async\" class=\"headerlink\" title=\"dispatch_barrier_async\"></a>dispatch_barrier_async</h4><ul>\n<li>这个函数传入的并发队列必须是自己通过<code>dispatch_queue_create</code>创建的</li>\n<li>如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于<code>dispatch_async</code>函数的效果</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 初始化队列</span><br><span class=\"line\">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;rw_queue&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 读</span><br><span class=\"line\">dispatch_async(queue,^&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 写</span><br><span class=\"line\">dispatch_barrier_async(queue, ^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ol>\n<li>子线程中，<code>performSelector:withObject:afterDelay:</code>不起作用的原因 <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;1&quot;</span>);</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(test) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">.0</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;3&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>performSelector:withObject:afterDelay:</code> 的本质是往Runloop中添加定时器</li>\n<li>子线程中默认没有启动<code>Runloop</code></li>\n<li>补充代码启动Runloop即可  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">NSRunloop</span> currentRunloop] addPort:[[<span class=\"built_in\">NSPort</span> alloc] init] forMode:<span class=\"built_in\">NSDefaultRunloopMode</span>];</span><br><span class=\"line\">[[<span class=\"built_in\">NSRunloop</span> currentRunloop] runMode:<span class=\"built_in\">NSDefaultRunloopMode</span> beforeDate:[<span class=\"built_in\">NSDate</span> distantFeature]];</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本文主要简述iOS中多线程的使用及其原理</p>","more":"<h2 id=\"常见的多线程方案\"><a href=\"#常见的多线程方案\" class=\"headerlink\" title=\"常见的多线程方案\"></a>常见的多线程方案</h2><table>\n<thead>\n<tr>\n<th align=\"center\">技术方案</th>\n<th align=\"left\">简介</th>\n<th align=\"center\">语言</th>\n<th align=\"center\">线程生命周期</th>\n<th align=\"center\">使用频率</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">pthread</td>\n<td align=\"left\"><ul><li>一套通用的多线程API</li><li>适用于Unix\\Linux\\Windows等系统</li><li>跨平台\\可移植</li><li>使用难度大</li></ul></td>\n<td align=\"center\">C</td>\n<td align=\"center\">程序员管理</td>\n<td align=\"center\">几乎不用</td>\n</tr>\n<tr>\n<td align=\"center\">NSThread</td>\n<td align=\"left\"><ul><li>使用更加面向对象</li><li>简单易用，可直接操作线程对象</li></ul></td>\n<td align=\"center\">OC</td>\n<td align=\"center\">程序员管理</td>\n<td align=\"center\">偶尔使用</td>\n</tr>\n<tr>\n<td align=\"center\">GCD</td>\n<td align=\"left\"><ul><li>旨在替代NSThread等线程技术</li><li>充分利用设备的多核</li></ul></td>\n<td align=\"center\">C</td>\n<td align=\"center\">自动管理</td>\n<td align=\"center\">经常使用</td>\n</tr>\n<tr>\n<td align=\"center\">NSOperation</td>\n<td align=\"left\"><ul><li>基于GCD</li><li>比GCD多了一些简单实用的功能</li><li>使用更加面向对象</li></ul></td>\n<td align=\"center\">OC</td>\n<td align=\"center\">自动管理</td>\n<td align=\"center\">经常使用</td>\n</tr>\n</tbody></table>\n<h3 id=\"一些多线程术语\"><a href=\"#一些多线程术语\" class=\"headerlink\" title=\"一些多线程术语\"></a>一些多线程术语</h3><ul>\n<li>同步、异步：能不能开启新的线程<ul>\n<li>同步：在当前线程中执行任务，不具备开启新线程的能力</li>\n<li>异步：在新的线程中执行任务，具备开启新线程的能力</li>\n</ul>\n</li>\n<li>并发、串行：任务的执行方式<ul>\n<li>并发：多个任务并发（同时）执行</li>\n<li>串行：一个任务执行完毕后，再执行下一个任务</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"各种队列的执行效果\"><a href=\"#各种队列的执行效果\" class=\"headerlink\" title=\"各种队列的执行效果\"></a>各种队列的执行效果</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>并发队列</th>\n<th>手动创建的串行队列</th>\n<th>主队列</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>同步（sync）</td>\n<td>没有开启新线程<br>串行执行任务</td>\n<td>没有开启新线程<br>串行执行任务</td>\n<td>没有开启新线程<br>串行执行任务</td>\n</tr>\n<tr>\n<td>异步（async）</td>\n<td>有开启新线程<br>并发执行任务</td>\n<td>有开启新线程<br>串行执行任务</td>\n<td>没有开启新线程<br>串行执行任务</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>使用<code>sync</code>函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）</p>\n</li>\n<li><p>死锁问题主要产生在串行队列中。由于串行队列的FIFO（First in first out）性质，如果串行队列中有同步函数，那么同步函数要等待串行队列执行完才能执行，又因为同步函数的性质是在当前线程立马执行函数体，所以同步函数后面的代码要等待同步函数执行完才能执行，在这种情况下就会出现死锁</p>\n</li>\n<li><p>因为并发队列允许同时执行多个任务，所以不存在等待队列中其他人完成后才能开始执行的情况，所以一般情况下并发队列不会产生环路等待死锁</p>\n</li>\n</ul>\n<h2 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h2><h3 id=\"GCD的常用函数\"><a href=\"#GCD的常用函数\" class=\"headerlink\" title=\"GCD的常用函数\"></a>GCD的常用函数</h3><ul>\n<li>用同步的方式执行任务</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// queue 队列</span></span><br><span class=\"line\"><span class=\"comment\">/// block 任务</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(<span class=\"built_in\">dispatch_queue_t</span> queue,dispatch_block_t block);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>用异步的方式执行任务</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// queue 队列</span></span><br><span class=\"line\"><span class=\"comment\">/// block 任务</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(<span class=\"built_in\">dispatch_queue_t</span> queue,dispatch_block_t block);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"GCD的队列\"><a href=\"#GCD的队列\" class=\"headerlink\" title=\"GCD的队列\"></a>GCD的队列</h3><p>GCD的队列可以分为2大类型</p>\n<ul>\n<li><p>并发队列（Concurrent Dispatch Queue）</p>\n<ul>\n<li>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）</li>\n<li>并发功能只有在异步（dispatch_async）函数下才有效</li>\n</ul>\n</li>\n<li><p>串行队列（Serial Dispatch Queue）</p>\n<ul>\n<li>让任务一个接着一个执行（一个任务执行完毕后，在执行下一个任务）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GCD的队列组\"><a href=\"#GCD的队列组\" class=\"headerlink\" title=\"GCD的队列组\"></a>GCD的队列组</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建队列组</span></span><br><span class=\"line\">dispatch_group_t group = dispatch_group_create();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建并发队列</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_queue_create(<span class=\"string\">&quot;my_queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加异步任务</span></span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;任务1-%@&quot;</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dispatch_group_async(group, queue, ^&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;任务2-%@&quot;</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等前面的任务执行完毕后，会自动执行这个任务</span></span><br><span class=\"line\">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;任务3-%@&quot;</span>,[<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"多线程的安全隐患\"><a href=\"#多线程的安全隐患\" class=\"headerlink\" title=\"多线程的安全隐患\"></a>多线程的安全隐患</h2><ul>\n<li>资源共享<ul>\n<li>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源</li>\n<li>比如多个线程访问同一个对象，同一个变量，同一个文件</li>\n</ul>\n</li>\n<li>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题</li>\n</ul>\n<p>解决方案：使用线程同步技术（同步，就是协同步调，按预定的先后持续进行）</p>\n<ul>\n<li>常见的线程同步技术是：加锁，常见线程同步方案如下<ul>\n<li>OSSpinLock</li>\n<li>os_unfair_lock</li>\n<li>pthread_mutex</li>\n<li>dispatch_semaphore</li>\n<li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li>\n<li>NSLock</li>\n<li>NSRecursiveLock</li>\n<li>NSCondition</li>\n<li>NSConditionLock</li>\n<li>@synchronized</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"串行队列\"><a href=\"#串行队列\" class=\"headerlink\" title=\"串行队列\"></a>串行队列</h3><p>线程同步的最直接的方案就是串行队列，让多条线程按顺序执行</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dispatch_queue_t</span> queue = <span class=\"built_in\">dispatch_queue_create</span>(<span class=\"string\">&quot;queue&quot;</span>,DISPATCH_QUEUE_SERIAL);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(queue,^&#123;</span><br><span class=\"line\">    xxxx</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">dispatch_sync</span>(queue,^&#123;</span><br><span class=\"line\">    xxxx</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"OSSpinLock\"><a href=\"#OSSpinLock\" class=\"headerlink\" title=\"OSSpinLock\"></a>OSSpinLock</h3><blockquote>\n<p>这个锁在iOS 10之后被废弃了</p>\n</blockquote>\n<p>自旋锁，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源</p>\n<blockquote>\n<p>忙等：一边等待一边忙着做事情，相当于while(1){xxx}。自旋：自己一直在那里旋转</p>\n</blockquote>\n<blockquote>\n<p>需要导入头文件<code>&lt;libkern/OSAtomic.h&gt;</code></p>\n</blockquote>\n<p>初始化</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">OSSpinLock lock</span> = OS_SPINLOCK_INIT;</span><br></pre></td></tr></table></figure>\n\n<p>加锁</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"constructor\">OSSpinLockLock(&amp;<span class=\"params\">_lock</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>尝试加锁：如果需要等待就返回false，不加锁；如果不需要等待就返回true，加锁。</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">Bool</span> <span class=\"variable\"><span class=\"class\">result</span></span> = <span class=\"function\"><span class=\"title\">OSSpinLockTry</span>(&amp;<span class=\"variable\">_lock</span>)</span></span><br></pre></td></tr></table></figure>\n\n<p>解锁</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"constructor\">OSSpinLockUnlock(&amp;<span class=\"params\">_lock</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>自旋锁现在已经不再安全，可能会出现优先级反转问题</p>\n<p>如果等待锁的优先级线程较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁</p>\n<h3 id=\"os-unfair-lock\"><a href=\"#os-unfair-lock\" class=\"headerlink\" title=\"os_unfair_lock\"></a>os_unfair_lock</h3><ul>\n<li><code>os_unfair_lock</code>用于取代不安全的<code>OSSpinLock</code>，从iOS10开始才支持</li>\n<li>从底层调用看，等待<code>os_unfair_lock</code>锁的线程会处于休眠状态，并非忙等</li>\n<li>需要导入头文件<code>&lt;os/lock.h&gt;</code></li>\n</ul>\n<p>初始化</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">os_unfair_lock lock</span> = OS_UNFAIR_LOCK_INIT;</span><br></pre></td></tr></table></figure>\n\n<p>加锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">os_unfair_lock_lock(&amp;lock);</span><br></pre></td></tr></table></figure>\n\n<p>解锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">os_unfair_lock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"phread-mutex\"><a href=\"#phread-mutex\" class=\"headerlink\" title=\"phread_mutex\"></a>phread_mutex</h3><ul>\n<li><code>mutex</code>叫做互斥锁，等待锁的线程会处于休眠状态</li>\n<li>需要导入头文件<code>&lt;pthread.h&gt;</code></li>\n</ul>\n<p>初始化方法1</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">pthread_mutex_t mutex</span> = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>\n\n<p>初始化方法2</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread_mutexattr_t attr;</span><br><span class=\"line\">pthread<span class=\"constructor\">_mutexattr_init(&amp;<span class=\"params\">attr</span>)</span>;</span><br><span class=\"line\">pthread<span class=\"constructor\">_mutexattr_settype(&amp;<span class=\"params\">attr</span>, PTHREAD_MUTEX_DEFAULT)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 这里的第二个参数如果传NULL的话表示使用默认属性</span></span><br><span class=\"line\">pthread<span class=\"constructor\">_mutex_init(&amp;<span class=\"params\">_mutex</span>, &amp;<span class=\"params\">attr</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">pthread<span class=\"constructor\">_mutexattr_destory(&amp;<span class=\"params\">attr</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>尝试加锁</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread<span class=\"constructor\">_mutex_trylock(&amp;<span class=\"params\">mutex</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>加锁</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread<span class=\"constructor\">_mutex_lock(&amp;<span class=\"params\">mutex</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>解锁</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread<span class=\"constructor\">_mutex_unlock(&amp;<span class=\"params\">mutex</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"递归锁\"><a href=\"#递归锁\" class=\"headerlink\" title=\"递归锁\"></a>递归锁</h4><p>锁的属性可以改为递归锁，即允许<strong>同一个线程</strong>对一把锁进行重复加锁</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread<span class=\"constructor\">_mutexattr_settype(&amp;<span class=\"params\">attr</span>, PTHREAD_MUTEX_RECURSIVE)</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"条件锁\"><a href=\"#条件锁\" class=\"headerlink\" title=\"条件锁\"></a>条件锁</h4><p>初始化条件</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread_cond_t <span class=\"keyword\">condition</span>;</span><br><span class=\"line\">pthread_cond_init(<span class=\"operator\">&amp;</span><span class=\"keyword\">condition</span>, <span class=\"keyword\">NULL</span>);</span><br></pre></td></tr></table></figure>\n\n<p>等待条件（进入休眠，放开mutex锁；被唤醒后，会再次对mutex加锁）</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread<span class=\"constructor\">_cond_wait(&amp;<span class=\"params\">condition</span>, &amp;<span class=\"params\">mutex</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>激活<strong>一个</strong>等待该条件的线程（如果这时候有多个在等待，那么也只会激活最先等待的那个）</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread<span class=\"constructor\">_cond_signal(&amp;<span class=\"params\">condition</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>激活所有等待该条件的线程</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread<span class=\"constructor\">_cond_brodcast(&amp;<span class=\"params\">condition</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>销毁资源</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread<span class=\"constructor\">_mutex_destory(&amp;<span class=\"params\">mutex</span>)</span>;</span><br><span class=\"line\">pthread<span class=\"constructor\">_cond_destory(&amp;<span class=\"params\">condition</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NSLock\"><a href=\"#NSLock\" class=\"headerlink\" title=\"NSLock\"></a>NSLock</h3><ul>\n<li><code>NSLock</code>是对<code>mutex</code>普通锁的封装，即<code>pthread_mutex_init(&amp;_mutex, NULL);</code></li>\n</ul>\n<p>初始化</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSLock</span> *lock = [[<span class=\"built_in\">NSLock</span> alloc] init];</span><br></pre></td></tr></table></figure>\n\n<p>加锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)lock;</span><br></pre></td></tr></table></figure>\n\n<p>尝试加锁(调用的瞬间立马去判断当前能不能加锁，能加就加，然后返回YES，然后继续往下走，如果不能加就返回NO，然后继续往下走)</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)tryLock;</span><br></pre></td></tr></table></figure>\n\n<p>等待锁（调用的时候先阻塞，如果现在能加锁，就返回YES，加锁成功，继续往下走；如果不能加锁，就阻塞，如果在limit之前，锁被放开了，那么就加锁，返回YES，代码继续往下走；如果直到limit到了，锁还没被放开，那么就返回NO，加锁失败，代码继续往下走）</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)lockBeforeDate:(<span class=\"built_in\">NSDate</span> *)limit;</span><br></pre></td></tr></table></figure>\n\n<p>解锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)unlock;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NSRecursiveLock\"><a href=\"#NSRecursiveLock\" class=\"headerlink\" title=\"NSRecursiveLock\"></a>NSRecursiveLock</h3><ul>\n<li><code>NSRecurseiveLock</code>也是对<code>mutex</code>递归锁的封装，API跟<code>NSLock</code>基本一致</li>\n</ul>\n<h3 id=\"NSCondition\"><a href=\"#NSCondition\" class=\"headerlink\" title=\"NSCondition\"></a>NSCondition</h3><ul>\n<li><code>NSCondition</code>也是对<code>mutex</code>和<code>cont</code>的封装</li>\n</ul>\n<p>等待锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)wait;</span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)waitUtilDate:(<span class=\"built_in\">NSDate</span> *)limit;</span><br></pre></td></tr></table></figure>\n\n<p>激活锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)signal; <span class=\"comment\">// 激活单个</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)boardcast; <span class=\"comment\">// 激活多个</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NSConditionLock\"><a href=\"#NSConditionLock\" class=\"headerlink\" title=\"NSConditionLock\"></a>NSConditionLock</h3><ul>\n<li><code>NSConditionLock</code>是对<code>NSCondition</code>的进一步封装，可以设置具体的条件值</li>\n</ul>\n<p>初始化设定一个条件值，如果直接<code>init</code>的话那么默认值是0</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instance<span class=\"keyword\">type</span>)initWithCondition:(<span class=\"type\">NSInteger</span>)condition;</span><br></pre></td></tr></table></figure>\n\n<p>加锁并且设定条件值为<code>condition</code></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)lockWhenCondition:(<span class=\"built_in\">NSInteger</span>)condition;</span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)tryLockWhenCondition:(<span class=\"built_in\">NSInteger</span>)condition; <span class=\"comment\">// 尝试加锁</span></span><br><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)lockWhenCondition:(<span class=\"built_in\">NSInteger</span>)condition beforeDate:(<span class=\"built_in\">NSDate</span> *)limit; <span class=\"comment\">// 在指定时间到达之前等待条件成立加锁</span></span><br></pre></td></tr></table></figure>\n\n<p>如果直接使用<code>lock</code>方法，那么会无视条件值，直接加锁或者等待加锁</p>\n<p>解当前的锁并且设置条件值为<code>condition</code>，如果这时候有条件值为<code>condition</code>的锁在加着，那么就会释放</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)unlockWhenCondition:(<span class=\"built_in\">NSInteger</span>)condition;</span><br></pre></td></tr></table></figure>\n\n<p>如果直接使用<code>unlock</code>方法，那么那些带条件的<code>lockWhenCondition</code>不会解锁</p>\n<h3 id=\"dispatch-semaphore\"><a href=\"#dispatch-semaphore\" class=\"headerlink\" title=\"dispatch_semaphore\"></a>dispatch_semaphore</h3><ul>\n<li><code>semaphore</code>叫做信号量</li>\n<li>信号量的初始值，可以用来控制线程并发访问的最大数量</li>\n</ul>\n<p>初始化，传入一个允许的最大并发线程数<code>count</code></p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">dispatch_sempathore semaphore</span> = dispatch_semaphore_create(count);</span><br></pre></td></tr></table></figure>\n\n<p>如果信号量的值&lt;=0，当前线程就会进入休眠等待（直到信号量的值&gt;0）<br>如果信号量的值&gt;0，就减1，然后往下执行后面的代码</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch<span class=\"constructor\">_semaphore_wait(<span class=\"params\">semaphore</span>, DISPATCH_TIME_FOREVER)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>让信号量的值加1</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch<span class=\"constructor\">_semaphore_signal(<span class=\"params\">semaphore</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"@synchronized\"></a>@synchronized</h3><ul>\n<li><code>@synchronized</code>是对<code>mutex</code>递归锁的封装</li>\n</ul>\n<p>传入对象即可，用于标记是不是同个锁，一个对象标记一把锁 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@synchronized(xxx)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"线程同步方案性能比较\"><a href=\"#线程同步方案性能比较\" class=\"headerlink\" title=\"线程同步方案性能比较\"></a>线程同步方案性能比较</h3><ul>\n<li>性能从高到低排序<ul>\n<li>os_unfair_lock</li>\n<li>OSSpinLock</li>\n<li>dispatch_semaphore</li>\n<li>pthread_mutex</li>\n<li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li>\n<li>NSLock</li>\n<li>NSCondition</li>\n<li>pthread_mutex(recursive)</li>\n<li>NSRecursiveLock</li>\n<li>NSConditionLock</li>\n<li>@synchronized</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"自旋锁、互斥锁比较\"><a href=\"#自旋锁、互斥锁比较\" class=\"headerlink\" title=\"自旋锁、互斥锁比较\"></a>自旋锁、互斥锁比较</h2><blockquote>\n<p>iOS10之后已经不推荐使用自旋锁了</p>\n</blockquote>\n<ul>\n<li>什么情况使用自旋锁比较划算？<ul>\n<li>预计线程等待锁的时间很短</li>\n<li>加锁的代码（临界区）经常被调用，但竞争情况很少发生</li>\n<li>CPU资源不紧张</li>\n<li>多核处理器</li>\n</ul>\n</li>\n<li>什么情况使用互斥锁比较划算？<ul>\n<li>预计线程等待锁的时间较长</li>\n<li>单核处理器</li>\n<li>临界区有IO操作（因为比较占用CPU资源）</li>\n<li>临界区代码复杂或者循环量大</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"读写安全\"><a href=\"#读写安全\" class=\"headerlink\" title=\"读写安全\"></a>读写安全</h2><h3 id=\"atomic\"><a href=\"#atomic\" class=\"headerlink\" title=\"atomic\"></a>atomic</h3><p><code>nonatomic</code>和<code>atomic</code> ：给属性加上<code>atomic</code>修饰，可以保证属性的<code>setter</code>和<code>getter</code>都是原子性操作，也就是保证<code>setter</code>和<code>getter</code>内部是线程同步的</p>\n<p>参照runtime源码中 <code>objc-accessors.mm</code>的<code>objc_getProperty</code>和<code>reallySetProperty</code>方法，分别是get方法和set方法的内部实现</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">id</span> objc_getProperty(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, ptrdiff_t offset, <span class=\"built_in\">BOOL</span> atomic) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offset == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object_getClass(<span class=\"keyword\">self</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Retain release world</span></span><br><span class=\"line\">    <span class=\"keyword\">id</span> *slot = (<span class=\"keyword\">id</span>*) ((<span class=\"keyword\">char</span>*)<span class=\"keyword\">self</span> + offset);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!atomic) <span class=\"keyword\">return</span> *slot;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果是atomic的时候，会加上锁</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Atomic retain release world</span></span><br><span class=\"line\">    spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class=\"line\">    slotlock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">id</span> value = objc_retain(*slot);</span><br><span class=\"line\">    slotlock.unlock();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_autoreleaseReturnValue(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> reallySetProperty(<span class=\"keyword\">id</span> <span class=\"keyword\">self</span>, SEL _cmd, <span class=\"keyword\">id</span> newValue, ptrdiff_t offset, <span class=\"keyword\">bool</span> atomic, <span class=\"keyword\">bool</span> <span class=\"keyword\">copy</span>, <span class=\"keyword\">bool</span> mutableCopy)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (offset == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        object_setClass(<span class=\"keyword\">self</span>, newValue);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">id</span> oldValue;</span><br><span class=\"line\">    <span class=\"keyword\">id</span> *slot = (<span class=\"keyword\">id</span>*) ((<span class=\"keyword\">char</span>*)<span class=\"keyword\">self</span> + offset);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">copy</span>) &#123;</span><br><span class=\"line\">        newValue = [newValue copyWithZone:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (mutableCopy) &#123;</span><br><span class=\"line\">        newValue = [newValue mutableCopyWithZone:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*slot == newValue) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        newValue = objc_retain(newValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!atomic) &#123;</span><br><span class=\"line\">        oldValue = *slot;</span><br><span class=\"line\">        *slot = newValue;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">/// 这里可以看出如果是atomic的时候，是会加上锁的</span></span><br><span class=\"line\">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class=\"line\">        slotlock.lock();</span><br><span class=\"line\">        oldValue = *slot;</span><br><span class=\"line\">        *slot = newValue;        </span><br><span class=\"line\">        slotlock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    objc_release(oldValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>atmoic</code>是不能保证使用属性的过程中是线程安全的，即虽然他的setter和getter是线程安全的，但是用这个属性去调用其他方法的时候依旧不一定属性安全，比如<code>[self.array addObject:xxx]</code>，这里只能保证取出array属性的时候线程安全，但是添加对象进去的时候就有可能出现线程同步问题</p>\n<h3 id=\"读写安全方案\"><a href=\"#读写安全方案\" class=\"headerlink\" title=\"读写安全方案\"></a>读写安全方案</h3><h4 id=\"多读单写\"><a href=\"#多读单写\" class=\"headerlink\" title=\"多读单写\"></a>多读单写</h4><p>需求</p>\n<ul>\n<li>同一时间，只能有1条线程进行写的操作</li>\n<li>同一时间，允许有多条线程进行读的操作</li>\n<li>同一时间，不允许既有写的操作，又有读的操作</li>\n</ul>\n<p>解决方案</p>\n<ul>\n<li>pthread_rwlock：读写锁</li>\n<li>dispatch_barrier_async：异步栅栏调用</li>\n</ul>\n<h4 id=\"pthread-rwlock\"><a href=\"#pthread-rwlock\" class=\"headerlink\" title=\"pthread_rwlock\"></a>pthread_rwlock</h4><ul>\n<li>等待锁的线程会进入休眠</li>\n<li>需要引入头文件&lt;pthread.h&gt;</li>\n</ul>\n<p>初始化锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread_rwlock_t lock;</span><br><span class=\"line\">pthread_rwlock_init(&amp;lock,<span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></figure>\n\n<p>读-加锁/尝试加锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread_rwlock_rdlock(&amp;lock);</span><br><span class=\"line\">pthread_rwlock_tryrdlock(&amp;lock);</span><br></pre></td></tr></table></figure>\n\n<p>写-加锁/尝试加锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread_rwlock_wrlock(&amp;lock);</span><br><span class=\"line\">pthread_rwlock_trywrlock(&amp;lock);</span><br></pre></td></tr></table></figure>\n\n<p>解锁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread_rwlock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>\n\n<p>销毁</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pthread_rwlock_destory(&amp;lock);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"dispatch-barrier-async\"><a href=\"#dispatch-barrier-async\" class=\"headerlink\" title=\"dispatch_barrier_async\"></a>dispatch_barrier_async</h4><ul>\n<li>这个函数传入的并发队列必须是自己通过<code>dispatch_queue_create</code>创建的</li>\n<li>如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于<code>dispatch_async</code>函数的效果</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 初始化队列</span><br><span class=\"line\">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;rw_queue&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 读</span><br><span class=\"line\">dispatch_async(queue,^&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 写</span><br><span class=\"line\">dispatch_barrier_async(queue, ^&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ol>\n<li>子线程中，<code>performSelector:withObject:afterDelay:</code>不起作用的原因 <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">dispatch_async</span>(queue, ^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;1&quot;</span>);</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(test) withObject:<span class=\"literal\">nil</span> afterDelay:<span class=\"number\">.0</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;3&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>performSelector:withObject:afterDelay:</code> 的本质是往Runloop中添加定时器</li>\n<li>子线程中默认没有启动<code>Runloop</code></li>\n<li>补充代码启动Runloop即可  <figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">NSRunloop</span> currentRunloop] addPort:[[<span class=\"built_in\">NSPort</span> alloc] init] forMode:<span class=\"built_in\">NSDefaultRunloopMode</span>];</span><br><span class=\"line\">[[<span class=\"built_in\">NSRunloop</span> currentRunloop] runMode:<span class=\"built_in\">NSDefaultRunloopMode</span> beforeDate:[<span class=\"built_in\">NSDate</span> distantFeature]];</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>"},{"title":"Swift 5.5 async与 await","author":"Arclin","abbrlink":"75996dec","date":"2021-08-23T14:55:00.000Z","_content":"本文主要简述Swift 5.5新特性 async与await的常用方式\n\n<!-- more -->\n\n## 举个例子\n\n首先我们来做一个简单的下载图片的任务\n\n```swift\nstruct Download {\n    static func image(url: URL, completeHandler: @escaping (UIImage?, Error?) -> Void) {\n        let task = URLSession.shared.dataTask(with: url) { data, response, error in\n            if let error = error {\n                DispatchQueue.main.async {\n                    completeHandler(nil,error)\n                }\n                return\n            }\n            if let data = data, let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 {\n                let image = UIImage(data: data)\n                if image != nil {\n                    DispatchQueue.main.async {\n                        completeHandler(image, nil)\n                    }\n                } else {\n                    DispatchQueue.main.async {\n                        completeHandler(nil, NSError(domain: \"org.swift\", code: -2))\n                    }\n                }\n            } else {\n                DispatchQueue.main.async {\n                    completeHandler(nil, NSError(domain: \"org.swift\", code: -1))\n                }\n            }\n        }\n        task.resume()\n    }\n}\n```\n可以发现，这个简单的任务里面涉及到了block嵌套，子线程与主线程的切换等等上下文切换的逻辑。\n\n代码首先会执行第一行，然后就直接执行最后一行，再回到第二行执行，然后还得判断各种异常状态，最后才回到主线程刷新。可以发现这里面最深的嵌套达到了4层，而且上下文的切换也不利于代码阅读。可想而知要是逻辑稍微再多一点，就远远不止这种复杂度了。\n\n## 用 async 和 await 来拯救一下\n\n改造完之后，代码如下\n\n```swift\nstatic func image(url: URL) async throws -> UIImage {\n    let (data, response) = try await URLSession.shared.data(from: url)\n    guard (response as? HTTPURLResponse)?.statusCode == 200 else { throw NSError(domain: \"org,swift\", code: -1) }\n    guard let maybeImage = UIImage(data: data) else { throw NSError(domain: \"org,swift\", code: -1) }\n    return maybeImage\n}\n```\n\n调用方式如下（如果需要捕获异常的话就需要加上`do-catch`）\n\n```swift\nTask {\n   try self.imageView.image = await AsyncTest.image(url: URL(string: \"https://images.xiaozhuanlan.com/photo/2021/fb4d1bcda193cdfb5ccc380d1a008fe1.png\")!)\n}\n```\n\n可以看到我们的代码精简了许多，嵌套最深也就是判断到异常的时候抛出的1层，接下来我们来逐行讲解一下\n\n### 发起请求\n\n首先`URLSession.shared.data(from: url) `是iOS 15 新出的方法，用于发起网络请求，方法定义如下\n\n```swift\n/// Convenience method to load data using an URL, creates and resumes an URLSessionDataTask internally.\n///\n/// - Parameter url: The URL for which to load data.\n/// - Parameter delegate: Task-specific delegate.\n/// - Returns: Data and response.\npublic func data(from url: URL, delegate: URLSessionTaskDelegate? = nil) async throws -> (Data, URLResponse)\n```\n\n其中 `async` 表示这是一个异步方法，如同我们前面定义的方法一样`static func image(url: URL) async throws -> UIImage`，同样也有`async`这个关键字，只要方法里面有`await`关键字，那么方法名就得带上`async`关键字。带有`async`的方法就意味着需要使用`await`去调用，然后其返回值可以直接赋值给某个变量。举例如下:\n\n```swift\nfunc getName() async -> String {\n\t/// 发起网络请求获取名字，这时候线程会卡住，直到请求完成了，就会把这个请求方法的返回值直接赋值给name，然后就会继续往下执行，把拿到的name给返回出去\n\tlet name = await requestName()\n\treturn name\n}\n\n/// 同理，当代码执行到这里的时候，调用异步方法，线程会卡住，然后方法里面去调用网络请求获取名字，然后等待网络请求返回之后，name就会被赋上值\nlet name = await getName()\n```\n\n以上面的`URLSession`的`data(from:delegate:)`方法为例，返回的是一个元组，所以就是\n\n```swift\nlet (data, response) = try await URLSession.shared.data(from: url)\n```\n表示请求后，`data`和`response`变量都会被赋上值，分别是`Data`类型和`URLResponse`类型\n\n另外我们注意到，和通过block方式返回请求结果不同，这个新方法返回的元组中的`data`和`response`都不是可选类型，而是确切有值的，如果发生网络异常则会通过`throw`抛出异常，这样子的设计能够让我们节省加下来针对空值的判断，可以放心地使用返回值\n\n> 当然，不仅仅是网络请求可以用`await`，任意的异步行为（比如读取本地文件）都可以使用`await`\n\n目前在iOS 15 SDK的`URLSession`中，不仅仅提供了上述请求数据，返回元组的方法，还提供了其他上传，下载的方法，可供异步调用，这里简单列举一下\n\n```swift\n/// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.\n///\n/// - Parameter request: The URLRequest for which to upload data.\n/// - Parameter fileURL: File to upload.\n/// - Parameter delegate: Task-specific delegate.\n/// - Returns: Data and response.\npublic func upload(for request: URLRequest, fromFile fileURL: URL, delegate: URLSessionTaskDelegate? = nil) async throws -> (Data, URLResponse)\n\n/// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.\n///\n/// - Parameter request: The URLRequest for which to upload data.\n/// - Parameter bodyData: Data to upload.\n/// - Parameter delegate: Task-specific delegate.\n/// - Returns: Data and response.\npublic func upload(for request: URLRequest, from bodyData: Data, delegate: URLSessionTaskDelegate? = nil) async throws -> (Data, URLResponse)\n\n/// Convenience method to download using an URLRequest, creates and resumes an URLSessionDownloadTask internally.\n///\n/// - Parameter request: The URLRequest for which to download.\n/// - Parameter delegate: Task-specific delegate.\n/// - Returns: Downloaded file URL and response. The file will not be removed automatically.\npublic func download(for request: URLRequest, delegate: URLSessionTaskDelegate? = nil) async throws -> (URL, URLResponse)\n\n/// Convenience method to download using an URL, creates and resumes an URLSessionDownloadTask internally.\n///\n/// - Parameter url: The URL for which to download.\n/// - Parameter delegate: Task-specific delegate.\n/// - Returns: Downloaded file URL and response. The file will not be removed automatically.\npublic func download(from url: URL, delegate: URLSessionTaskDelegate? = nil) async throws -> (URL, URLResponse)\n\n/// Convenience method to resume download, creates and resumes an URLSessionDownloadTask internally.\n///\n/// - Parameter resumeData: Resume data from an incomplete download.\n/// - Parameter delegate: Task-specific delegate.\n/// - Returns: Downloaded file URL and response. The file will not be removed automatically.\npublic func download(resumeFrom resumeData: Data, delegate: URLSessionTaskDelegate? = nil) async throws -> (URL, URLResponse)\n```\n\n### 容错 & 转码\n\n```swift\nguard (response as? HTTPURLResponse)?.statusCode == 200 else { throw NSError(domain: \"org,swift\", code: -1) }\n```\n这一行用来处理响应体的异常情况，当`statusCode` 为 200的判断不成立时，就会抛出异常，则外部需要通过`do-catch`去捕获\n\n如果判断成立时，则程序继续往下走\n\n```swift\nguard let maybeImage = UIImage(data: data) else { throw NSError(domain: \"org,swift\", code: -1) }\n```\n\n这里将`data`转成了`UIImage`，由于该方法返回的是一个可选值，所以这里同样需要通过`guard`去判断转换失败的情况\n\n```swift\nreturn maybeImage\n```\n\n最后得到了确切的结果之后，我们就可以将转好的图片给发送出去了，并且外面使用这个返回值的时候也不用判空，可以放心地确定返回的图片是有值的。\n\n### 调用方法\n\n当我们的方法被标记为`async`的时候，我们就需要加上`await`进行调用，并且调用的环境是需要在异步环境内的，即如下所示\n\n```swift\nasync {\n\ttry let image = await AsyncTest.image(url: xxxx)\n}\n```\n\n在Xcode 13.0 bata 4 中这个`async {} `环境的建立代码被提示即将被废弃，所以改成了如下所示\n\n```swift\nTask(priority: .userInitiated) {\n    try let image = await AsyncTest.image(url: xxxx)\n}\n```\n\n这里的`userInitiated`表示线程优先级为`用户发起`，当然`priority`参数也可以不填，默认优先级是`Task.currentPriority`，返回值默认是`default`\n\n目前有六种优先级，这里从高到低进行排列如下：\n\n```swift\n/// 优先级最高\npublic static let high: TaskPriority\n\n/// 等同于default\npublic static var medium: TaskPriority { get }\n\npublic static let low: TaskPriority\n\npublic static let userInitiated: TaskPriority\n\npublic static let utility: TaskPriority\n\n/// 优先级最低\npublic static let background: TaskPriority\n```\n\n### 总结\n\n当你标记一个函数为`async`时，即表示该函数可以被挂起。在`async`函数内部，使用`await`关键词标记在哪里可以一次或多次挂起。当`async`函数挂起时，线程并未阻塞，系统会自由安排其他任务。有时后启动的任务，可能先被执行。即你的程序状态可能在挂起时发生显著变化。当`async`函数恢复执行时，其返回的结果会自然融入到`async`函数的调用者，并在先前挂起的地方接续执行。\n\n### 注意\n\n`await`关键字表示该异步（async）函数可能会被挂起，而不是畅通无阻地继续执行下去，甚至从挂起恢复回来时，函数可能已经跑到了另一个线程上去了，为了解决这个问题，我们可以用Swift的`actor`保护可变状态，这个我们后面再讲\n\n## Async序列\n\nAsync序列顾名思义就是异步的序列，比如读取一个很大的文件，我们希望一边下载一边展示读取的内容，这时候我们可以通过使用`for await-in` 来遍历一个异步的序列，如下\n\n```swift\nstatic func eatchquakes() async throws {\n    let endpointURL = URL(string: \"https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.csv\")!\n\n    // 跳过首行 因为是header描述不是地震数据\n    // 接着遍历提取强度、时间、经纬度信息\n    for try await event in endpointURL.lines.dropFirst() {\n        let values = event.split(separator: \",\")\n        let time = values[0]\n        let latitude = values[1]\n        let longtitude = values[2]\n        let magnitude = values[4]\n        print(\"Magnitude \\(magnitude) on \\(time) at \\(latitude) \\(longtitude)\")\n    }\n}\n```\n\n也就是说，异步序列就是对随着时间推移如何产生值或对象的一种描述方式。由于值的产生是异步的，所以可能会在读取的过程中出现异常，当异常发生的时候，遍历终止，并抛出异常。\n\n其中，`lines`方法是iOS 15 新增的一个`URL`的拓展属性，同时还有`resourceBytes`属性，完整定义如下\n\n```swift\nextension URL {\n    public struct AsyncBytes : AsyncSequence, AsyncIteratorProtocol {\n\n        public typealias AsyncIterator = URL.AsyncBytes\n        \n        public typealias Element = UInt8\n\n        /// Asynchronously advances to the next element and returns it, or ends the\n        /// sequence if there is no next element.\n        /// \n        /// - Returns: The next element, if it exists, or `nil` to signal the end of\n        ///   the sequence.\n        @inlinable public mutating func next() async throws -> UInt8?\n\n        /// Creates the asynchronous iterator that produces elements of this\n        /// asynchronous sequence.\n        ///\n        /// - Returns: An instance of the `AsyncIterator` type used to produce\n        /// elements of the asynchronous sequence.\n        public func makeAsyncIterator() -> URL.AsyncBytes\n    }\n    public var resourceBytes: URL.AsyncBytes { get }\n    public var lines: AsyncLineSequence<URL.AsyncBytes> { get }\n```\n\n因为异步序列的遍历是一个耗时操作，所以我们也可以在需要的时候中断遍历（取消请求）\n\n```swift\nlet task = Task(priority: .userInitiated) {\n    do {\n        try await AsyncTest.eatchquakes()\n    } catch {\n        print(error)\n    }\n}\n\n/// 取消\ntask.cancel()\n```\n\n除了`URL`新增的`lines`方法，iOS 15 还给`FileHandle`和`URLSession`添加了异步序列方法，比如`FileHandle`新增的`bytes`属性，能提供字节流的异步序列。配合异步序列的扩展能力（把字节流变成`lines`），我们就可以从文件中异步地获得逐行内容并进行处理了。\n\n```swift\n// 从FileHandle异步读取bytes\npublic var bytes: AsyncBytes\n\nfor try await line in FileHandle.standardInput.bytes.lines {\n\n}\n```\n\n不仅如此，现在通知也支持异步序列了\n\n```swift\n// 异步await通知\npublic func notifications(named: Notification.Name, object: AnyObject) -> notifications\n\nlet center = NotificationCenter.default\n\n/// 返回第一个userInfo的NSStoreUUIDKey值为storeUUID的通知\nlet notification = await center.notifications(named: .NSPersistentStoreRemoteChange).first {\n    $0.userInfo[NSStoreUUIDKey] == storeUUID\n}\n```\n\n## 将异步回调的闭包方法改造成async方法\n\n上面提到的都是基于系统提供的`async`方法，如果要改造我们原有的异步回调block方法，我们可以使用`withCheckedContinuation`或者`withCheckedThrowingContinuation`函数，区别在于前者用于确定不会抛出错误的场景，举例如下：\n\n- 三秒后返回Hello World\n\n```swift\nstatic func getItem(callback: @escaping (String)->(Void)) {\n    DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {\n        callback(\"Hello World\");\n    }\n}\n```\n\n改造后\n\n```swift\nstatic func getItem() async -> String {\n    return await withCheckedContinuation { continuation in\n        DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {\n            continuation.resume(returning: \"Hello World\");\n            /// 如果需要抛出错误，使用 continuation.resume(throwing: error)\n        }\n    }\n}\n```\n\ncontinuation 有个简单但是重要的原则，resume方法必须在每个路径上执行，有且只有一次。但是不用担心，如果在有的路径上没有执行resume方法，Swift runtime 会发出 warning 警告。\n\n但如果在某个路径上，resume执行了不止一次，这会是严重得多的问题。Swift runtime 会在第二次 resume 调用处触发 fatal error。\n\n如果使用的是`withTaskCancellationHandler`，那么可以在异步操作被取消的时候执行某些行为\n\n```swift\nstatic func getItem() async throws -> String {\n    return try await withTaskCancellationHandler {\n        print(\"Cancel\")\n    } operation: {\n        let result = try await withCheckedThrowingContinuation { continuation in\n            DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {\n                continuation.resume(returning: \"Hello World\")\n            }\n        }\n        return result\n    }\n}\n\n/// 调用\nlet task = Task {\n    do {\n        let item = try await AsyncTest.getItem()\n        print(item)\n    } catch {\n        print(\"Error\" + error.localizedDescription)\n    }\n}\n\n/// 调用取消的时候会打印`Cancel`\ntask.cancel()\n```\n\n## 只读属性使用async\n\n只读属性可以在其`get`方法中使用`async`标记是一个异步读取的属性，如下所示\n\n```swift\nstruct AsyncTest {\n  enum FileError : Error {\n      case missing, unreadable\n  }\n\n  var content : String {\n      get async throws {\n          guard let url = Bundle.main.url(forResource: \"Empty\", withExtension: \"md\") else { throw FileError.missing }\n          do {\n              return try String(contentsOf: url)\n          } catch {\n              throw FileError.unreadable\n          }\n      }\n  }\n\n  func readContent() async throws -> String {\n      let result = try await self.content\n      return result\n  }\n}\n```\n\n## 结构化并发\n\n假如我们有多个异步函数，比如`切菜`、`切洋葱`、`切肉`\n\n```swift\nstruct Cooking {\n    static func cutVegetable() async -> String {\n        await Task.sleep(10_000_000_000) // 暂停10秒的意思\n        return \"cut vegetable\"\n    }\n    \n    static func cutOnion() async -> String {\n        await Task.sleep(5_000_000_000)\n        return \"cut onion\"\n    }\n    \n    static func cutMeet() async -> String {\n        await Task.sleep(5_000_000_000)\n        return \"cut meet\"\n    }\n}\n```\n\n如果我们这么调用的话，那么整个过程将是串行的，一共会花费20秒左右\n\n```swift\nTask {\n    let step1 = await Cooking.cutVegetable()\n    let step2 = await Cooking.cutOnion()\n    let step3 = await Cooking.cutMeet()\n    \n    print([step1,step2,step3])\n}\n```\n\n但是实际三个步骤之间并没有依赖关系，是可以同时进行的，所以我们需要使用结构化并发，让他们并发执行\n\n```swift\nfunc cooking() async -> [String] {\n    return await withTaskGroup(of: String.self) { group in\n        group.addTask {\n            await Cooking.cutVegetable()\n        }\n        group.addTask {\n            await Cooking.cutOnion()\n        }\n        group.addTask {\n            await Cooking.cutMeet()\n        }\n        var steps : [String] = []\n        for await finishedStep in group {\n            steps.append(finishedStep)\n        }\n        return steps\n    }\n}\n```\n\n这样子只要10秒左右就可以完成任务了\n\n```swift\nTask {\n    let result = await cooking()\n    print(result)\n}\n```\n\n如果在执行子任务的过程中发生了异常，那么`cooking()`方法将会退出，任何尚未完成的子任务都将自动取消。\n\n## Actor\n\n由于我们现在已经多很多异步操作的场景，所以自然我们在设计类的时候，也要注意这个类要是被多个线程同时访问的时候引起的状态变化的问题。\n\nSwift 5.5引入了Actor，它在概念上类似于在并发环境中可以安全使用的类。Swift 确保在任何给定时间只能由单个线程访问 Actor 内的可变状态，这有助于在编译器级别消除各种严重的错误。\n\n比如以下代码在单线程情况下是安全的，但是如果是多线程访问的话`deck`属性会出现资源竞争的问题\n\n```swift\nclass RiskyCollector {\n    var deck: Set<String>\n    \n    init(deck: Set<String>) {\n        self.deck = deck\n    }\n    \n    func send(card selected: String, to person: RiskyCollector) -> Bool {\n        guard deck.contains(selected) else { return false }\n        deck.remove(selected)\n        person.transfer(card: selected)\n        return true\n    }\n    \n    func transfer(card: String) {\n        deck.insert(card)\n    }\n}\n```\n\n危险：\n\n```\nlet set = Set<String>([\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\"])\nlet risky = RiskyCollector(deck:set)\nfor i in 1...12 {\n    DispatchQueue.global().async {\n        _ = risky.send(card: \"\\(i)\", to: risky)\n        print(risky.deck)\n    }\n}\n```\n\nActor 通过引入 Actor 隔离解决了这个问题：除非异步执行，否则无法从 Actor 对象外部读取属性和方法，并且根本无法从 Actor 对象外部写入属性。 Swift 会自动将这些请求放入一个按顺序处理的队列中，以避免出现多线程竞争。\n\n我们可以使用Actor重新实现一个SafeCollector，如下:\n\n```swift\nactor SafeCollector {\n  var deck: Set<String>\n  init(deck: Set<String>) {\n      self.deck = deck\n  }\n\n  func send(card selected: String, to person: SafeCollector) async -> Bool {\n      guard deck.contains(selected) else { return false }\n      deck.remove(selected)\n      await person.transfer(card: selected)\n      return true\n  }\n\n  func transfer(card: String) {\n      deck.insert(card)\n  }\n}\n```\n\n安全：\n\n```swift\nlet set = Set<String>([\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\"])\nlet risky = SafeCollector(deck:set)\nfor i in 1...12 {\n    Task {\n        _ = await risky.send(card: \"\\(i)\", to: risky)\n        print(await risky.deck)\n    }\n}\n```\n\n在这个例子中有几件事情需要注意：\n\n- actor内对外暴露的方法都是异步方法，即使没有标记async，因为它会等到另一个 SafeCollector actor 能够处理请求。\n\n- actor 可以自由地、异步或以其他方式使用自己的属性和方法，但是当与不同的 actor 交互时，它必须始终异步完成。通过这些特性，Swift 可以确保永远不会同时访问所有与 actor 隔离的状态，更重要的是，这是在编译时完成的，以保证线程安全。\n\nActor 和 Class 有一些相似之处：\n\n- 两者都是引用类型，因此它们可用于共享状态。\n\n- 它们可以有方法、属性、初始值设定项和下标。\n\n- 它们可以实现协议。任何静态属性和方法在这两种类型中的行为都相同。\n\n除了 Actor 隔离之外，Actor 和 Class之间还有另外两个重要的区别：\n\n- Actor 目前不支持继承，这在未来可能会改变\n\n- 所有 Actor 都隐式遵守一个新的 Actor Protocol\n\n### Global Actor\n\nGlobal Actor 将 actor 隔离的概念扩展到了全局状态，即使状态和函数分散在许多不同的模块中，Global Actor 可以在并发程序中安全地使用全局变量，例如 Swift 提供的 `@MainActor` 限制属性和方法只能在主线程访问\n\n```swift\nclass ViewController {\n    @MainActor func refreshUI() {\n        print(\"updating ui…\")\n    }\n}\n\n@MainActor var globalTextSize: Int\n\n@MainActor func increaseTextSize() {\n  globalTextSize += 2   // okay:\n}\n\nfunc notOnTheMainActor() async {\n  globalTextSize = 12  // error: globalTextSize is isolated to MainActor\n  increaseTextSize()   // error: increaseTextSize is isolated to MainActor, cannot call synchronously\n  await increaseTextSize() // okay: asynchronous call hops over to the main thread and executes there\n}\n```","source":"_posts/Swift-5-5-新特性-async与-await.md","raw":"title: Swift 5.5 async与 await\nauthor: Arclin\nabbrlink: 75996dec\ntags:\n  - iOS\n  - Swift\ncategories:\n  - iOS\ndate: 2021-08-23 22:55:00\n---\n本文主要简述Swift 5.5新特性 async与await的常用方式\n\n<!-- more -->\n\n## 举个例子\n\n首先我们来做一个简单的下载图片的任务\n\n```swift\nstruct Download {\n    static func image(url: URL, completeHandler: @escaping (UIImage?, Error?) -> Void) {\n        let task = URLSession.shared.dataTask(with: url) { data, response, error in\n            if let error = error {\n                DispatchQueue.main.async {\n                    completeHandler(nil,error)\n                }\n                return\n            }\n            if let data = data, let httpResponse = response as? HTTPURLResponse, httpResponse.statusCode == 200 {\n                let image = UIImage(data: data)\n                if image != nil {\n                    DispatchQueue.main.async {\n                        completeHandler(image, nil)\n                    }\n                } else {\n                    DispatchQueue.main.async {\n                        completeHandler(nil, NSError(domain: \"org.swift\", code: -2))\n                    }\n                }\n            } else {\n                DispatchQueue.main.async {\n                    completeHandler(nil, NSError(domain: \"org.swift\", code: -1))\n                }\n            }\n        }\n        task.resume()\n    }\n}\n```\n可以发现，这个简单的任务里面涉及到了block嵌套，子线程与主线程的切换等等上下文切换的逻辑。\n\n代码首先会执行第一行，然后就直接执行最后一行，再回到第二行执行，然后还得判断各种异常状态，最后才回到主线程刷新。可以发现这里面最深的嵌套达到了4层，而且上下文的切换也不利于代码阅读。可想而知要是逻辑稍微再多一点，就远远不止这种复杂度了。\n\n## 用 async 和 await 来拯救一下\n\n改造完之后，代码如下\n\n```swift\nstatic func image(url: URL) async throws -> UIImage {\n    let (data, response) = try await URLSession.shared.data(from: url)\n    guard (response as? HTTPURLResponse)?.statusCode == 200 else { throw NSError(domain: \"org,swift\", code: -1) }\n    guard let maybeImage = UIImage(data: data) else { throw NSError(domain: \"org,swift\", code: -1) }\n    return maybeImage\n}\n```\n\n调用方式如下（如果需要捕获异常的话就需要加上`do-catch`）\n\n```swift\nTask {\n   try self.imageView.image = await AsyncTest.image(url: URL(string: \"https://images.xiaozhuanlan.com/photo/2021/fb4d1bcda193cdfb5ccc380d1a008fe1.png\")!)\n}\n```\n\n可以看到我们的代码精简了许多，嵌套最深也就是判断到异常的时候抛出的1层，接下来我们来逐行讲解一下\n\n### 发起请求\n\n首先`URLSession.shared.data(from: url) `是iOS 15 新出的方法，用于发起网络请求，方法定义如下\n\n```swift\n/// Convenience method to load data using an URL, creates and resumes an URLSessionDataTask internally.\n///\n/// - Parameter url: The URL for which to load data.\n/// - Parameter delegate: Task-specific delegate.\n/// - Returns: Data and response.\npublic func data(from url: URL, delegate: URLSessionTaskDelegate? = nil) async throws -> (Data, URLResponse)\n```\n\n其中 `async` 表示这是一个异步方法，如同我们前面定义的方法一样`static func image(url: URL) async throws -> UIImage`，同样也有`async`这个关键字，只要方法里面有`await`关键字，那么方法名就得带上`async`关键字。带有`async`的方法就意味着需要使用`await`去调用，然后其返回值可以直接赋值给某个变量。举例如下:\n\n```swift\nfunc getName() async -> String {\n\t/// 发起网络请求获取名字，这时候线程会卡住，直到请求完成了，就会把这个请求方法的返回值直接赋值给name，然后就会继续往下执行，把拿到的name给返回出去\n\tlet name = await requestName()\n\treturn name\n}\n\n/// 同理，当代码执行到这里的时候，调用异步方法，线程会卡住，然后方法里面去调用网络请求获取名字，然后等待网络请求返回之后，name就会被赋上值\nlet name = await getName()\n```\n\n以上面的`URLSession`的`data(from:delegate:)`方法为例，返回的是一个元组，所以就是\n\n```swift\nlet (data, response) = try await URLSession.shared.data(from: url)\n```\n表示请求后，`data`和`response`变量都会被赋上值，分别是`Data`类型和`URLResponse`类型\n\n另外我们注意到，和通过block方式返回请求结果不同，这个新方法返回的元组中的`data`和`response`都不是可选类型，而是确切有值的，如果发生网络异常则会通过`throw`抛出异常，这样子的设计能够让我们节省加下来针对空值的判断，可以放心地使用返回值\n\n> 当然，不仅仅是网络请求可以用`await`，任意的异步行为（比如读取本地文件）都可以使用`await`\n\n目前在iOS 15 SDK的`URLSession`中，不仅仅提供了上述请求数据，返回元组的方法，还提供了其他上传，下载的方法，可供异步调用，这里简单列举一下\n\n```swift\n/// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.\n///\n/// - Parameter request: The URLRequest for which to upload data.\n/// - Parameter fileURL: File to upload.\n/// - Parameter delegate: Task-specific delegate.\n/// - Returns: Data and response.\npublic func upload(for request: URLRequest, fromFile fileURL: URL, delegate: URLSessionTaskDelegate? = nil) async throws -> (Data, URLResponse)\n\n/// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.\n///\n/// - Parameter request: The URLRequest for which to upload data.\n/// - Parameter bodyData: Data to upload.\n/// - Parameter delegate: Task-specific delegate.\n/// - Returns: Data and response.\npublic func upload(for request: URLRequest, from bodyData: Data, delegate: URLSessionTaskDelegate? = nil) async throws -> (Data, URLResponse)\n\n/// Convenience method to download using an URLRequest, creates and resumes an URLSessionDownloadTask internally.\n///\n/// - Parameter request: The URLRequest for which to download.\n/// - Parameter delegate: Task-specific delegate.\n/// - Returns: Downloaded file URL and response. The file will not be removed automatically.\npublic func download(for request: URLRequest, delegate: URLSessionTaskDelegate? = nil) async throws -> (URL, URLResponse)\n\n/// Convenience method to download using an URL, creates and resumes an URLSessionDownloadTask internally.\n///\n/// - Parameter url: The URL for which to download.\n/// - Parameter delegate: Task-specific delegate.\n/// - Returns: Downloaded file URL and response. The file will not be removed automatically.\npublic func download(from url: URL, delegate: URLSessionTaskDelegate? = nil) async throws -> (URL, URLResponse)\n\n/// Convenience method to resume download, creates and resumes an URLSessionDownloadTask internally.\n///\n/// - Parameter resumeData: Resume data from an incomplete download.\n/// - Parameter delegate: Task-specific delegate.\n/// - Returns: Downloaded file URL and response. The file will not be removed automatically.\npublic func download(resumeFrom resumeData: Data, delegate: URLSessionTaskDelegate? = nil) async throws -> (URL, URLResponse)\n```\n\n### 容错 & 转码\n\n```swift\nguard (response as? HTTPURLResponse)?.statusCode == 200 else { throw NSError(domain: \"org,swift\", code: -1) }\n```\n这一行用来处理响应体的异常情况，当`statusCode` 为 200的判断不成立时，就会抛出异常，则外部需要通过`do-catch`去捕获\n\n如果判断成立时，则程序继续往下走\n\n```swift\nguard let maybeImage = UIImage(data: data) else { throw NSError(domain: \"org,swift\", code: -1) }\n```\n\n这里将`data`转成了`UIImage`，由于该方法返回的是一个可选值，所以这里同样需要通过`guard`去判断转换失败的情况\n\n```swift\nreturn maybeImage\n```\n\n最后得到了确切的结果之后，我们就可以将转好的图片给发送出去了，并且外面使用这个返回值的时候也不用判空，可以放心地确定返回的图片是有值的。\n\n### 调用方法\n\n当我们的方法被标记为`async`的时候，我们就需要加上`await`进行调用，并且调用的环境是需要在异步环境内的，即如下所示\n\n```swift\nasync {\n\ttry let image = await AsyncTest.image(url: xxxx)\n}\n```\n\n在Xcode 13.0 bata 4 中这个`async {} `环境的建立代码被提示即将被废弃，所以改成了如下所示\n\n```swift\nTask(priority: .userInitiated) {\n    try let image = await AsyncTest.image(url: xxxx)\n}\n```\n\n这里的`userInitiated`表示线程优先级为`用户发起`，当然`priority`参数也可以不填，默认优先级是`Task.currentPriority`，返回值默认是`default`\n\n目前有六种优先级，这里从高到低进行排列如下：\n\n```swift\n/// 优先级最高\npublic static let high: TaskPriority\n\n/// 等同于default\npublic static var medium: TaskPriority { get }\n\npublic static let low: TaskPriority\n\npublic static let userInitiated: TaskPriority\n\npublic static let utility: TaskPriority\n\n/// 优先级最低\npublic static let background: TaskPriority\n```\n\n### 总结\n\n当你标记一个函数为`async`时，即表示该函数可以被挂起。在`async`函数内部，使用`await`关键词标记在哪里可以一次或多次挂起。当`async`函数挂起时，线程并未阻塞，系统会自由安排其他任务。有时后启动的任务，可能先被执行。即你的程序状态可能在挂起时发生显著变化。当`async`函数恢复执行时，其返回的结果会自然融入到`async`函数的调用者，并在先前挂起的地方接续执行。\n\n### 注意\n\n`await`关键字表示该异步（async）函数可能会被挂起，而不是畅通无阻地继续执行下去，甚至从挂起恢复回来时，函数可能已经跑到了另一个线程上去了，为了解决这个问题，我们可以用Swift的`actor`保护可变状态，这个我们后面再讲\n\n## Async序列\n\nAsync序列顾名思义就是异步的序列，比如读取一个很大的文件，我们希望一边下载一边展示读取的内容，这时候我们可以通过使用`for await-in` 来遍历一个异步的序列，如下\n\n```swift\nstatic func eatchquakes() async throws {\n    let endpointURL = URL(string: \"https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.csv\")!\n\n    // 跳过首行 因为是header描述不是地震数据\n    // 接着遍历提取强度、时间、经纬度信息\n    for try await event in endpointURL.lines.dropFirst() {\n        let values = event.split(separator: \",\")\n        let time = values[0]\n        let latitude = values[1]\n        let longtitude = values[2]\n        let magnitude = values[4]\n        print(\"Magnitude \\(magnitude) on \\(time) at \\(latitude) \\(longtitude)\")\n    }\n}\n```\n\n也就是说，异步序列就是对随着时间推移如何产生值或对象的一种描述方式。由于值的产生是异步的，所以可能会在读取的过程中出现异常，当异常发生的时候，遍历终止，并抛出异常。\n\n其中，`lines`方法是iOS 15 新增的一个`URL`的拓展属性，同时还有`resourceBytes`属性，完整定义如下\n\n```swift\nextension URL {\n    public struct AsyncBytes : AsyncSequence, AsyncIteratorProtocol {\n\n        public typealias AsyncIterator = URL.AsyncBytes\n        \n        public typealias Element = UInt8\n\n        /// Asynchronously advances to the next element and returns it, or ends the\n        /// sequence if there is no next element.\n        /// \n        /// - Returns: The next element, if it exists, or `nil` to signal the end of\n        ///   the sequence.\n        @inlinable public mutating func next() async throws -> UInt8?\n\n        /// Creates the asynchronous iterator that produces elements of this\n        /// asynchronous sequence.\n        ///\n        /// - Returns: An instance of the `AsyncIterator` type used to produce\n        /// elements of the asynchronous sequence.\n        public func makeAsyncIterator() -> URL.AsyncBytes\n    }\n    public var resourceBytes: URL.AsyncBytes { get }\n    public var lines: AsyncLineSequence<URL.AsyncBytes> { get }\n```\n\n因为异步序列的遍历是一个耗时操作，所以我们也可以在需要的时候中断遍历（取消请求）\n\n```swift\nlet task = Task(priority: .userInitiated) {\n    do {\n        try await AsyncTest.eatchquakes()\n    } catch {\n        print(error)\n    }\n}\n\n/// 取消\ntask.cancel()\n```\n\n除了`URL`新增的`lines`方法，iOS 15 还给`FileHandle`和`URLSession`添加了异步序列方法，比如`FileHandle`新增的`bytes`属性，能提供字节流的异步序列。配合异步序列的扩展能力（把字节流变成`lines`），我们就可以从文件中异步地获得逐行内容并进行处理了。\n\n```swift\n// 从FileHandle异步读取bytes\npublic var bytes: AsyncBytes\n\nfor try await line in FileHandle.standardInput.bytes.lines {\n\n}\n```\n\n不仅如此，现在通知也支持异步序列了\n\n```swift\n// 异步await通知\npublic func notifications(named: Notification.Name, object: AnyObject) -> notifications\n\nlet center = NotificationCenter.default\n\n/// 返回第一个userInfo的NSStoreUUIDKey值为storeUUID的通知\nlet notification = await center.notifications(named: .NSPersistentStoreRemoteChange).first {\n    $0.userInfo[NSStoreUUIDKey] == storeUUID\n}\n```\n\n## 将异步回调的闭包方法改造成async方法\n\n上面提到的都是基于系统提供的`async`方法，如果要改造我们原有的异步回调block方法，我们可以使用`withCheckedContinuation`或者`withCheckedThrowingContinuation`函数，区别在于前者用于确定不会抛出错误的场景，举例如下：\n\n- 三秒后返回Hello World\n\n```swift\nstatic func getItem(callback: @escaping (String)->(Void)) {\n    DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {\n        callback(\"Hello World\");\n    }\n}\n```\n\n改造后\n\n```swift\nstatic func getItem() async -> String {\n    return await withCheckedContinuation { continuation in\n        DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {\n            continuation.resume(returning: \"Hello World\");\n            /// 如果需要抛出错误，使用 continuation.resume(throwing: error)\n        }\n    }\n}\n```\n\ncontinuation 有个简单但是重要的原则，resume方法必须在每个路径上执行，有且只有一次。但是不用担心，如果在有的路径上没有执行resume方法，Swift runtime 会发出 warning 警告。\n\n但如果在某个路径上，resume执行了不止一次，这会是严重得多的问题。Swift runtime 会在第二次 resume 调用处触发 fatal error。\n\n如果使用的是`withTaskCancellationHandler`，那么可以在异步操作被取消的时候执行某些行为\n\n```swift\nstatic func getItem() async throws -> String {\n    return try await withTaskCancellationHandler {\n        print(\"Cancel\")\n    } operation: {\n        let result = try await withCheckedThrowingContinuation { continuation in\n            DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {\n                continuation.resume(returning: \"Hello World\")\n            }\n        }\n        return result\n    }\n}\n\n/// 调用\nlet task = Task {\n    do {\n        let item = try await AsyncTest.getItem()\n        print(item)\n    } catch {\n        print(\"Error\" + error.localizedDescription)\n    }\n}\n\n/// 调用取消的时候会打印`Cancel`\ntask.cancel()\n```\n\n## 只读属性使用async\n\n只读属性可以在其`get`方法中使用`async`标记是一个异步读取的属性，如下所示\n\n```swift\nstruct AsyncTest {\n  enum FileError : Error {\n      case missing, unreadable\n  }\n\n  var content : String {\n      get async throws {\n          guard let url = Bundle.main.url(forResource: \"Empty\", withExtension: \"md\") else { throw FileError.missing }\n          do {\n              return try String(contentsOf: url)\n          } catch {\n              throw FileError.unreadable\n          }\n      }\n  }\n\n  func readContent() async throws -> String {\n      let result = try await self.content\n      return result\n  }\n}\n```\n\n## 结构化并发\n\n假如我们有多个异步函数，比如`切菜`、`切洋葱`、`切肉`\n\n```swift\nstruct Cooking {\n    static func cutVegetable() async -> String {\n        await Task.sleep(10_000_000_000) // 暂停10秒的意思\n        return \"cut vegetable\"\n    }\n    \n    static func cutOnion() async -> String {\n        await Task.sleep(5_000_000_000)\n        return \"cut onion\"\n    }\n    \n    static func cutMeet() async -> String {\n        await Task.sleep(5_000_000_000)\n        return \"cut meet\"\n    }\n}\n```\n\n如果我们这么调用的话，那么整个过程将是串行的，一共会花费20秒左右\n\n```swift\nTask {\n    let step1 = await Cooking.cutVegetable()\n    let step2 = await Cooking.cutOnion()\n    let step3 = await Cooking.cutMeet()\n    \n    print([step1,step2,step3])\n}\n```\n\n但是实际三个步骤之间并没有依赖关系，是可以同时进行的，所以我们需要使用结构化并发，让他们并发执行\n\n```swift\nfunc cooking() async -> [String] {\n    return await withTaskGroup(of: String.self) { group in\n        group.addTask {\n            await Cooking.cutVegetable()\n        }\n        group.addTask {\n            await Cooking.cutOnion()\n        }\n        group.addTask {\n            await Cooking.cutMeet()\n        }\n        var steps : [String] = []\n        for await finishedStep in group {\n            steps.append(finishedStep)\n        }\n        return steps\n    }\n}\n```\n\n这样子只要10秒左右就可以完成任务了\n\n```swift\nTask {\n    let result = await cooking()\n    print(result)\n}\n```\n\n如果在执行子任务的过程中发生了异常，那么`cooking()`方法将会退出，任何尚未完成的子任务都将自动取消。\n\n## Actor\n\n由于我们现在已经多很多异步操作的场景，所以自然我们在设计类的时候，也要注意这个类要是被多个线程同时访问的时候引起的状态变化的问题。\n\nSwift 5.5引入了Actor，它在概念上类似于在并发环境中可以安全使用的类。Swift 确保在任何给定时间只能由单个线程访问 Actor 内的可变状态，这有助于在编译器级别消除各种严重的错误。\n\n比如以下代码在单线程情况下是安全的，但是如果是多线程访问的话`deck`属性会出现资源竞争的问题\n\n```swift\nclass RiskyCollector {\n    var deck: Set<String>\n    \n    init(deck: Set<String>) {\n        self.deck = deck\n    }\n    \n    func send(card selected: String, to person: RiskyCollector) -> Bool {\n        guard deck.contains(selected) else { return false }\n        deck.remove(selected)\n        person.transfer(card: selected)\n        return true\n    }\n    \n    func transfer(card: String) {\n        deck.insert(card)\n    }\n}\n```\n\n危险：\n\n```\nlet set = Set<String>([\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\"])\nlet risky = RiskyCollector(deck:set)\nfor i in 1...12 {\n    DispatchQueue.global().async {\n        _ = risky.send(card: \"\\(i)\", to: risky)\n        print(risky.deck)\n    }\n}\n```\n\nActor 通过引入 Actor 隔离解决了这个问题：除非异步执行，否则无法从 Actor 对象外部读取属性和方法，并且根本无法从 Actor 对象外部写入属性。 Swift 会自动将这些请求放入一个按顺序处理的队列中，以避免出现多线程竞争。\n\n我们可以使用Actor重新实现一个SafeCollector，如下:\n\n```swift\nactor SafeCollector {\n  var deck: Set<String>\n  init(deck: Set<String>) {\n      self.deck = deck\n  }\n\n  func send(card selected: String, to person: SafeCollector) async -> Bool {\n      guard deck.contains(selected) else { return false }\n      deck.remove(selected)\n      await person.transfer(card: selected)\n      return true\n  }\n\n  func transfer(card: String) {\n      deck.insert(card)\n  }\n}\n```\n\n安全：\n\n```swift\nlet set = Set<String>([\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\"])\nlet risky = SafeCollector(deck:set)\nfor i in 1...12 {\n    Task {\n        _ = await risky.send(card: \"\\(i)\", to: risky)\n        print(await risky.deck)\n    }\n}\n```\n\n在这个例子中有几件事情需要注意：\n\n- actor内对外暴露的方法都是异步方法，即使没有标记async，因为它会等到另一个 SafeCollector actor 能够处理请求。\n\n- actor 可以自由地、异步或以其他方式使用自己的属性和方法，但是当与不同的 actor 交互时，它必须始终异步完成。通过这些特性，Swift 可以确保永远不会同时访问所有与 actor 隔离的状态，更重要的是，这是在编译时完成的，以保证线程安全。\n\nActor 和 Class 有一些相似之处：\n\n- 两者都是引用类型，因此它们可用于共享状态。\n\n- 它们可以有方法、属性、初始值设定项和下标。\n\n- 它们可以实现协议。任何静态属性和方法在这两种类型中的行为都相同。\n\n除了 Actor 隔离之外，Actor 和 Class之间还有另外两个重要的区别：\n\n- Actor 目前不支持继承，这在未来可能会改变\n\n- 所有 Actor 都隐式遵守一个新的 Actor Protocol\n\n### Global Actor\n\nGlobal Actor 将 actor 隔离的概念扩展到了全局状态，即使状态和函数分散在许多不同的模块中，Global Actor 可以在并发程序中安全地使用全局变量，例如 Swift 提供的 `@MainActor` 限制属性和方法只能在主线程访问\n\n```swift\nclass ViewController {\n    @MainActor func refreshUI() {\n        print(\"updating ui…\")\n    }\n}\n\n@MainActor var globalTextSize: Int\n\n@MainActor func increaseTextSize() {\n  globalTextSize += 2   // okay:\n}\n\nfunc notOnTheMainActor() async {\n  globalTextSize = 12  // error: globalTextSize is isolated to MainActor\n  increaseTextSize()   // error: increaseTextSize is isolated to MainActor, cannot call synchronously\n  await increaseTextSize() // okay: asynchronous call hops over to the main thread and executes there\n}\n```","slug":"Swift-5-5-新特性-async与-await","published":1,"updated":"2021-08-23T15:04:24.323Z","_id":"cksorgkyu0000zgn09atnckc8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文主要简述Swift 5.5新特性 async与await的常用方式</p>\n<span id=\"more\"></span>\n\n<h2 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h2><p>首先我们来做一个简单的下载图片的任务</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Download</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">image</span>(<span class=\"params\">url</span>: <span class=\"type\">URL</span>, <span class=\"params\">completeHandler</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">UIImage</span>?, <span class=\"type\">Error</span>?) -&gt; <span class=\"type\">Void</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> task <span class=\"operator\">=</span> <span class=\"type\">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error <span class=\"operator\">=</span> error &#123;</span><br><span class=\"line\">                <span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">                    completeHandler(<span class=\"literal\">nil</span>,error)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> data <span class=\"operator\">=</span> data, <span class=\"keyword\">let</span> httpResponse <span class=\"operator\">=</span> response <span class=\"keyword\">as?</span> <span class=\"type\">HTTPURLResponse</span>, httpResponse.statusCode <span class=\"operator\">==</span> <span class=\"number\">200</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> image <span class=\"operator\">=</span> <span class=\"type\">UIImage</span>(data: data)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> image <span class=\"operator\">!=</span> <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">                        completeHandler(image, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">                        completeHandler(<span class=\"literal\">nil</span>, <span class=\"type\">NSError</span>(domain: <span class=\"string\">&quot;org.swift&quot;</span>, code: <span class=\"operator\">-</span><span class=\"number\">2</span>))</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">                    completeHandler(<span class=\"literal\">nil</span>, <span class=\"type\">NSError</span>(domain: <span class=\"string\">&quot;org.swift&quot;</span>, code: <span class=\"operator\">-</span><span class=\"number\">1</span>))</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        task.resume()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以发现，这个简单的任务里面涉及到了block嵌套，子线程与主线程的切换等等上下文切换的逻辑。</p>\n<p>代码首先会执行第一行，然后就直接执行最后一行，再回到第二行执行，然后还得判断各种异常状态，最后才回到主线程刷新。可以发现这里面最深的嵌套达到了4层，而且上下文的切换也不利于代码阅读。可想而知要是逻辑稍微再多一点，就远远不止这种复杂度了。</p>\n<h2 id=\"用-async-和-await-来拯救一下\"><a href=\"#用-async-和-await-来拯救一下\" class=\"headerlink\" title=\"用 async 和 await 来拯救一下\"></a>用 async 和 await 来拯救一下</h2><p>改造完之后，代码如下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">image</span>(<span class=\"params\">url</span>: <span class=\"type\">URL</span>)</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">UIImage</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (data, response) <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> <span class=\"type\">URLSession</span>.shared.data(from: url)</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> (response <span class=\"keyword\">as?</span> <span class=\"type\">HTTPURLResponse</span>)<span class=\"operator\">?</span>.statusCode <span class=\"operator\">==</span> <span class=\"number\">200</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">throw</span> <span class=\"type\">NSError</span>(domain: <span class=\"string\">&quot;org,swift&quot;</span>, code: <span class=\"operator\">-</span><span class=\"number\">1</span>) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> maybeImage <span class=\"operator\">=</span> <span class=\"type\">UIImage</span>(data: data) <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">throw</span> <span class=\"type\">NSError</span>(domain: <span class=\"string\">&quot;org,swift&quot;</span>, code: <span class=\"operator\">-</span><span class=\"number\">1</span>) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maybeImage</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用方式如下（如果需要捕获异常的话就需要加上<code>do-catch</code>）</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Task</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">try</span> <span class=\"keyword\">self</span>.imageView.image <span class=\"operator\">=</span> <span class=\"keyword\">await</span> <span class=\"type\">AsyncTest</span>.image(url: <span class=\"type\">URL</span>(string: <span class=\"string\">&quot;https://images.xiaozhuanlan.com/photo/2021/fb4d1bcda193cdfb5ccc380d1a008fe1.png&quot;</span>)<span class=\"operator\">!</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到我们的代码精简了许多，嵌套最深也就是判断到异常的时候抛出的1层，接下来我们来逐行讲解一下</p>\n<h3 id=\"发起请求\"><a href=\"#发起请求\" class=\"headerlink\" title=\"发起请求\"></a>发起请求</h3><p>首先<code>URLSession.shared.data(from: url) </code>是iOS 15 新出的方法，用于发起网络请求，方法定义如下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Convenience method to load data using an URL, creates and resumes an URLSessionDataTask internally.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter url: The URL for which to load data.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Returns: Data and response.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">data</span>(<span class=\"params\">from</span> <span class=\"params\">url</span>: <span class=\"type\">URL</span>, <span class=\"params\">delegate</span>: <span class=\"type\">URLSessionTaskDelegate</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; (<span class=\"type\">Data</span>, <span class=\"type\">URLResponse</span>)</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>async</code> 表示这是一个异步方法，如同我们前面定义的方法一样<code>static func image(url: URL) async throws -&gt; UIImage</code>，同样也有<code>async</code>这个关键字，只要方法里面有<code>await</code>关键字，那么方法名就得带上<code>async</code>关键字。带有<code>async</code>的方法就意味着需要使用<code>await</code>去调用，然后其返回值可以直接赋值给某个变量。举例如下:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getName</span>()</span> <span class=\"keyword\">async</span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/// 发起网络请求获取名字，这时候线程会卡住，直到请求完成了，就会把这个请求方法的返回值直接赋值给name，然后就会继续往下执行，把拿到的name给返回出去</span></span><br><span class=\"line\">\t<span class=\"keyword\">let</span> name <span class=\"operator\">=</span> <span class=\"keyword\">await</span> requestName()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 同理，当代码执行到这里的时候，调用异步方法，线程会卡住，然后方法里面去调用网络请求获取名字，然后等待网络请求返回之后，name就会被赋上值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> name <span class=\"operator\">=</span> <span class=\"keyword\">await</span> getName()</span><br></pre></td></tr></table></figure>\n\n<p>以上面的<code>URLSession</code>的<code>data(from:delegate:)</code>方法为例，返回的是一个元组，所以就是</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> (data, response) <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> <span class=\"type\">URLSession</span>.shared.data(from: url)</span><br></pre></td></tr></table></figure>\n<p>表示请求后，<code>data</code>和<code>response</code>变量都会被赋上值，分别是<code>Data</code>类型和<code>URLResponse</code>类型</p>\n<p>另外我们注意到，和通过block方式返回请求结果不同，这个新方法返回的元组中的<code>data</code>和<code>response</code>都不是可选类型，而是确切有值的，如果发生网络异常则会通过<code>throw</code>抛出异常，这样子的设计能够让我们节省加下来针对空值的判断，可以放心地使用返回值</p>\n<blockquote>\n<p>当然，不仅仅是网络请求可以用<code>await</code>，任意的异步行为（比如读取本地文件）都可以使用<code>await</code></p>\n</blockquote>\n<p>目前在iOS 15 SDK的<code>URLSession</code>中，不仅仅提供了上述请求数据，返回元组的方法，还提供了其他上传，下载的方法，可供异步调用，这里简单列举一下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter request: The URLRequest for which to upload data.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter fileURL: File to upload.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Returns: Data and response.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">upload</span>(<span class=\"params\">for</span> <span class=\"params\">request</span>: <span class=\"type\">URLRequest</span>, <span class=\"params\">fromFile</span> <span class=\"params\">fileURL</span>: <span class=\"type\">URL</span>, <span class=\"params\">delegate</span>: <span class=\"type\">URLSessionTaskDelegate</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; (<span class=\"type\">Data</span>, <span class=\"type\">URLResponse</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter request: The URLRequest for which to upload data.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter bodyData: Data to upload.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Returns: Data and response.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">upload</span>(<span class=\"params\">for</span> <span class=\"params\">request</span>: <span class=\"type\">URLRequest</span>, <span class=\"params\">from</span> <span class=\"params\">bodyData</span>: <span class=\"type\">Data</span>, <span class=\"params\">delegate</span>: <span class=\"type\">URLSessionTaskDelegate</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; (<span class=\"type\">Data</span>, <span class=\"type\">URLResponse</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Convenience method to download using an URLRequest, creates and resumes an URLSessionDownloadTask internally.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter request: The URLRequest for which to download.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Returns: Downloaded file URL and response. The file will not be removed automatically.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">download</span>(<span class=\"params\">for</span> <span class=\"params\">request</span>: <span class=\"type\">URLRequest</span>, <span class=\"params\">delegate</span>: <span class=\"type\">URLSessionTaskDelegate</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; (<span class=\"type\">URL</span>, <span class=\"type\">URLResponse</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Convenience method to download using an URL, creates and resumes an URLSessionDownloadTask internally.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter url: The URL for which to download.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Returns: Downloaded file URL and response. The file will not be removed automatically.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">download</span>(<span class=\"params\">from</span> <span class=\"params\">url</span>: <span class=\"type\">URL</span>, <span class=\"params\">delegate</span>: <span class=\"type\">URLSessionTaskDelegate</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; (<span class=\"type\">URL</span>, <span class=\"type\">URLResponse</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Convenience method to resume download, creates and resumes an URLSessionDownloadTask internally.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter resumeData: Resume data from an incomplete download.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Returns: Downloaded file URL and response. The file will not be removed automatically.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">download</span>(<span class=\"params\">resumeFrom</span> <span class=\"params\">resumeData</span>: <span class=\"type\">Data</span>, <span class=\"params\">delegate</span>: <span class=\"type\">URLSessionTaskDelegate</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; (<span class=\"type\">URL</span>, <span class=\"type\">URLResponse</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"容错-amp-转码\"><a href=\"#容错-amp-转码\" class=\"headerlink\" title=\"容错 &amp; 转码\"></a>容错 &amp; 转码</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">guard</span> (response <span class=\"keyword\">as?</span> <span class=\"type\">HTTPURLResponse</span>)<span class=\"operator\">?</span>.statusCode <span class=\"operator\">==</span> <span class=\"number\">200</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">throw</span> <span class=\"type\">NSError</span>(domain: <span class=\"string\">&quot;org,swift&quot;</span>, code: <span class=\"operator\">-</span><span class=\"number\">1</span>) &#125;</span><br></pre></td></tr></table></figure>\n<p>这一行用来处理响应体的异常情况，当<code>statusCode</code> 为 200的判断不成立时，就会抛出异常，则外部需要通过<code>do-catch</code>去捕获</p>\n<p>如果判断成立时，则程序继续往下走</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> maybeImage <span class=\"operator\">=</span> <span class=\"type\">UIImage</span>(data: data) <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">throw</span> <span class=\"type\">NSError</span>(domain: <span class=\"string\">&quot;org,swift&quot;</span>, code: <span class=\"operator\">-</span><span class=\"number\">1</span>) &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里将<code>data</code>转成了<code>UIImage</code>，由于该方法返回的是一个可选值，所以这里同样需要通过<code>guard</code>去判断转换失败的情况</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> maybeImage</span><br></pre></td></tr></table></figure>\n\n<p>最后得到了确切的结果之后，我们就可以将转好的图片给发送出去了，并且外面使用这个返回值的时候也不用判空，可以放心地确定返回的图片是有值的。</p>\n<h3 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h3><p>当我们的方法被标记为<code>async</code>的时候，我们就需要加上<code>await</code>进行调用，并且调用的环境是需要在异步环境内的，即如下所示</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> <span class=\"keyword\">let</span> image <span class=\"operator\">=</span> <span class=\"keyword\">await</span> <span class=\"type\">AsyncTest</span>.image(url: xxxx)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在Xcode 13.0 bata 4 中这个<code>async &#123;&#125; </code>环境的建立代码被提示即将被废弃，所以改成了如下所示</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Task</span>(priority: .userInitiated) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> <span class=\"keyword\">let</span> image <span class=\"operator\">=</span> <span class=\"keyword\">await</span> <span class=\"type\">AsyncTest</span>.image(url: xxxx)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>userInitiated</code>表示线程优先级为<code>用户发起</code>，当然<code>priority</code>参数也可以不填，默认优先级是<code>Task.currentPriority</code>，返回值默认是<code>default</code></p>\n<p>目前有六种优先级，这里从高到低进行排列如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 优先级最高</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> high: <span class=\"type\">TaskPriority</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 等同于default</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> medium: <span class=\"type\">TaskPriority</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> low: <span class=\"type\">TaskPriority</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> userInitiated: <span class=\"type\">TaskPriority</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> utility: <span class=\"type\">TaskPriority</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 优先级最低</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> background: <span class=\"type\">TaskPriority</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>当你标记一个函数为<code>async</code>时，即表示该函数可以被挂起。在<code>async</code>函数内部，使用<code>await</code>关键词标记在哪里可以一次或多次挂起。当<code>async</code>函数挂起时，线程并未阻塞，系统会自由安排其他任务。有时后启动的任务，可能先被执行。即你的程序状态可能在挂起时发生显著变化。当<code>async</code>函数恢复执行时，其返回的结果会自然融入到<code>async</code>函数的调用者，并在先前挂起的地方接续执行。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p><code>await</code>关键字表示该异步（async）函数可能会被挂起，而不是畅通无阻地继续执行下去，甚至从挂起恢复回来时，函数可能已经跑到了另一个线程上去了，为了解决这个问题，我们可以用Swift的<code>actor</code>保护可变状态，这个我们后面再讲</p>\n<h2 id=\"Async序列\"><a href=\"#Async序列\" class=\"headerlink\" title=\"Async序列\"></a>Async序列</h2><p>Async序列顾名思义就是异步的序列，比如读取一个很大的文件，我们希望一边下载一边展示读取的内容，这时候我们可以通过使用<code>for await-in</code> 来遍历一个异步的序列，如下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">eatchquakes</span>()</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> endpointURL <span class=\"operator\">=</span> <span class=\"type\">URL</span>(string: <span class=\"string\">&quot;https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.csv&quot;</span>)<span class=\"operator\">!</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 跳过首行 因为是header描述不是地震数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 接着遍历提取强度、时间、经纬度信息</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> event <span class=\"keyword\">in</span> endpointURL.lines.dropFirst() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> values <span class=\"operator\">=</span> event.split(separator: <span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> time <span class=\"operator\">=</span> values[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> latitude <span class=\"operator\">=</span> values[<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> longtitude <span class=\"operator\">=</span> values[<span class=\"number\">2</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> magnitude <span class=\"operator\">=</span> values[<span class=\"number\">4</span>]</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Magnitude <span class=\"subst\">\\(magnitude)</span> on <span class=\"subst\">\\(time)</span> at <span class=\"subst\">\\(latitude)</span> <span class=\"subst\">\\(longtitude)</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，异步序列就是对随着时间推移如何产生值或对象的一种描述方式。由于值的产生是异步的，所以可能会在读取的过程中出现异常，当异常发生的时候，遍历终止，并抛出异常。</p>\n<p>其中，<code>lines</code>方法是iOS 15 新增的一个<code>URL</code>的拓展属性，同时还有<code>resourceBytes</code>属性，完整定义如下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">URL</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AsyncBytes</span> : <span class=\"title\">AsyncSequence</span>, <span class=\"title\">AsyncIteratorProtocol</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">AsyncIterator</span> <span class=\"operator\">=</span> <span class=\"type\">URL</span>.<span class=\"type\">AsyncBytes</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">Element</span> <span class=\"operator\">=</span> <span class=\"type\">UInt8</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/// Asynchronously advances to the next element and returns it, or ends the</span></span><br><span class=\"line\">        <span class=\"comment\">/// sequence if there is no next element.</span></span><br><span class=\"line\">        <span class=\"comment\">/// </span></span><br><span class=\"line\">        <span class=\"comment\">/// - Returns: The next element, if it exists, or `nil` to signal the end of</span></span><br><span class=\"line\">        <span class=\"comment\">///   the sequence.</span></span><br><span class=\"line\">        <span class=\"keyword\">@inlinable</span> <span class=\"keyword\">public</span> <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">next</span>()</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">UInt8</span>?</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/// Creates the asynchronous iterator that produces elements of this</span></span><br><span class=\"line\">        <span class=\"comment\">/// asynchronous sequence.</span></span><br><span class=\"line\">        <span class=\"comment\">///</span></span><br><span class=\"line\">        <span class=\"comment\">/// - Returns: An instance of the `AsyncIterator` type used to produce</span></span><br><span class=\"line\">        <span class=\"comment\">/// elements of the asynchronous sequence.</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeAsyncIterator</span>()</span> -&gt; <span class=\"type\">URL</span>.<span class=\"type\">AsyncBytes</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> resourceBytes: <span class=\"type\">URL</span>.<span class=\"type\">AsyncBytes</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> lines: <span class=\"type\">AsyncLineSequence</span>&lt;<span class=\"type\">URL</span>.<span class=\"type\">AsyncBytes</span>&gt; &#123; <span class=\"keyword\">get</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为异步序列的遍历是一个耗时操作，所以我们也可以在需要的时候中断遍历（取消请求）</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> task <span class=\"operator\">=</span> <span class=\"type\">Task</span>(priority: .userInitiated) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> <span class=\"type\">AsyncTest</span>.eatchquakes()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 取消</span></span><br><span class=\"line\">task.cancel()</span><br></pre></td></tr></table></figure>\n\n<p>除了<code>URL</code>新增的<code>lines</code>方法，iOS 15 还给<code>FileHandle</code>和<code>URLSession</code>添加了异步序列方法，比如<code>FileHandle</code>新增的<code>bytes</code>属性，能提供字节流的异步序列。配合异步序列的扩展能力（把字节流变成<code>lines</code>），我们就可以从文件中异步地获得逐行内容并进行处理了。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从FileHandle异步读取bytes</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> bytes: <span class=\"type\">AsyncBytes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> line <span class=\"keyword\">in</span> <span class=\"type\">FileHandle</span>.standardInput.bytes.lines &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不仅如此，现在通知也支持异步序列了</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 异步await通知</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">notifications</span>(<span class=\"params\">named</span>: <span class=\"type\">Notification</span>.<span class=\"type\">Name</span>, <span class=\"params\">object</span>: <span class=\"type\">AnyObject</span>)</span> -&gt; notifications</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> center <span class=\"operator\">=</span> <span class=\"type\">NotificationCenter</span>.default</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 返回第一个userInfo的NSStoreUUIDKey值为storeUUID的通知</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> notification <span class=\"operator\">=</span> <span class=\"keyword\">await</span> center.notifications(named: .<span class=\"type\">NSPersistentStoreRemoteChange</span>).first &#123;</span><br><span class=\"line\">    <span class=\"variable\">$0</span>.userInfo[<span class=\"type\">NSStoreUUIDKey</span>] <span class=\"operator\">==</span> storeUUID</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"将异步回调的闭包方法改造成async方法\"><a href=\"#将异步回调的闭包方法改造成async方法\" class=\"headerlink\" title=\"将异步回调的闭包方法改造成async方法\"></a>将异步回调的闭包方法改造成async方法</h2><p>上面提到的都是基于系统提供的<code>async</code>方法，如果要改造我们原有的异步回调block方法，我们可以使用<code>withCheckedContinuation</code>或者<code>withCheckedThrowingContinuation</code>函数，区别在于前者用于确定不会抛出错误的场景，举例如下：</p>\n<ul>\n<li>三秒后返回Hello World</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getItem</span>(<span class=\"params\">callback</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">String</span>)-&gt;(<span class=\"type\">Void</span>))</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class=\"operator\">+</span> <span class=\"number\">3.0</span>) &#123;</span><br><span class=\"line\">        callback(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>改造后</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getItem</span>()</span> <span class=\"keyword\">async</span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> withCheckedContinuation &#123; continuation <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"type\">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class=\"operator\">+</span> <span class=\"number\">3.0</span>) &#123;</span><br><span class=\"line\">            continuation.resume(returning: <span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">/// 如果需要抛出错误，使用 continuation.resume(throwing: error)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>continuation 有个简单但是重要的原则，resume方法必须在每个路径上执行，有且只有一次。但是不用担心，如果在有的路径上没有执行resume方法，Swift runtime 会发出 warning 警告。</p>\n<p>但如果在某个路径上，resume执行了不止一次，这会是严重得多的问题。Swift runtime 会在第二次 resume 调用处触发 fatal error。</p>\n<p>如果使用的是<code>withTaskCancellationHandler</code>，那么可以在异步操作被取消的时候执行某些行为</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getItem</span>()</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> withTaskCancellationHandler &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Cancel&quot;</span>)</span><br><span class=\"line\">    &#125; operation: &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> result <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> withCheckedThrowingContinuation &#123; continuation <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"type\">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class=\"operator\">+</span> <span class=\"number\">3.0</span>) &#123;</span><br><span class=\"line\">                continuation.resume(returning: <span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 调用</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> task <span class=\"operator\">=</span> <span class=\"type\">Task</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> item <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> <span class=\"type\">AsyncTest</span>.getItem()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(item)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Error&quot;</span> <span class=\"operator\">+</span> error.localizedDescription)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 调用取消的时候会打印`Cancel`</span></span><br><span class=\"line\">task.cancel()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"只读属性使用async\"><a href=\"#只读属性使用async\" class=\"headerlink\" title=\"只读属性使用async\"></a>只读属性使用async</h2><p>只读属性可以在其<code>get</code>方法中使用<code>async</code>标记是一个异步读取的属性，如下所示</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AsyncTest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">FileError</span> : <span class=\"title\">Error</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> missing, unreadable</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> content : <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">get</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> url <span class=\"operator\">=</span> <span class=\"type\">Bundle</span>.main.url(forResource: <span class=\"string\">&quot;Empty&quot;</span>, withExtension: <span class=\"string\">&quot;md&quot;</span>) <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">throw</span> <span class=\"type\">FileError</span>.missing &#125;</span><br><span class=\"line\">          <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> <span class=\"type\">String</span>(contentsOf: url)</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">throw</span> <span class=\"type\">FileError</span>.unreadable</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readContent</span>()</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> result <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> <span class=\"keyword\">self</span>.content</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结构化并发\"><a href=\"#结构化并发\" class=\"headerlink\" title=\"结构化并发\"></a>结构化并发</h2><p>假如我们有多个异步函数，比如<code>切菜</code>、<code>切洋葱</code>、<code>切肉</code></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cooking</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cutVegetable</span>()</span> <span class=\"keyword\">async</span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">await</span> <span class=\"type\">Task</span>.sleep(<span class=\"number\">10_000_000_000</span>) <span class=\"comment\">// 暂停10秒的意思</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;cut vegetable&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cutOnion</span>()</span> <span class=\"keyword\">async</span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">await</span> <span class=\"type\">Task</span>.sleep(<span class=\"number\">5_000_000_000</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;cut onion&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cutMeet</span>()</span> <span class=\"keyword\">async</span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">await</span> <span class=\"type\">Task</span>.sleep(<span class=\"number\">5_000_000_000</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;cut meet&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们这么调用的话，那么整个过程将是串行的，一共会花费20秒左右</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Task</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> step1 <span class=\"operator\">=</span> <span class=\"keyword\">await</span> <span class=\"type\">Cooking</span>.cutVegetable()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> step2 <span class=\"operator\">=</span> <span class=\"keyword\">await</span> <span class=\"type\">Cooking</span>.cutOnion()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> step3 <span class=\"operator\">=</span> <span class=\"keyword\">await</span> <span class=\"type\">Cooking</span>.cutMeet()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>([step1,step2,step3])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是实际三个步骤之间并没有依赖关系，是可以同时进行的，所以我们需要使用结构化并发，让他们并发执行</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cooking</span>()</span> <span class=\"keyword\">async</span> -&gt; [<span class=\"type\">String</span>] &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> withTaskGroup(of: <span class=\"type\">String</span>.<span class=\"keyword\">self</span>) &#123; group <span class=\"keyword\">in</span></span><br><span class=\"line\">        group.addTask &#123;</span><br><span class=\"line\">            <span class=\"keyword\">await</span> <span class=\"type\">Cooking</span>.cutVegetable()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        group.addTask &#123;</span><br><span class=\"line\">            <span class=\"keyword\">await</span> <span class=\"type\">Cooking</span>.cutOnion()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        group.addTask &#123;</span><br><span class=\"line\">            <span class=\"keyword\">await</span> <span class=\"type\">Cooking</span>.cutMeet()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> steps : [<span class=\"type\">String</span>] <span class=\"operator\">=</span> []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> finishedStep <span class=\"keyword\">in</span> group &#123;</span><br><span class=\"line\">            steps.append(finishedStep)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> steps</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样子只要10秒左右就可以完成任务了</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Task</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result <span class=\"operator\">=</span> <span class=\"keyword\">await</span> cooking()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(result)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果在执行子任务的过程中发生了异常，那么<code>cooking()</code>方法将会退出，任何尚未完成的子任务都将自动取消。</p>\n<h2 id=\"Actor\"><a href=\"#Actor\" class=\"headerlink\" title=\"Actor\"></a>Actor</h2><p>由于我们现在已经多很多异步操作的场景，所以自然我们在设计类的时候，也要注意这个类要是被多个线程同时访问的时候引起的状态变化的问题。</p>\n<p>Swift 5.5引入了Actor，它在概念上类似于在并发环境中可以安全使用的类。Swift 确保在任何给定时间只能由单个线程访问 Actor 内的可变状态，这有助于在编译器级别消除各种严重的错误。</p>\n<p>比如以下代码在单线程情况下是安全的，但是如果是多线程访问的话<code>deck</code>属性会出现资源竞争的问题</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RiskyCollector</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> deck: <span class=\"type\">Set</span>&lt;<span class=\"type\">String</span>&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">deck</span>: <span class=\"type\">Set</span>&lt;<span class=\"type\">String</span>&gt;)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.deck <span class=\"operator\">=</span> deck</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">send</span>(<span class=\"params\">card</span> <span class=\"params\">selected</span>: <span class=\"type\">String</span>, <span class=\"params\">to</span> <span class=\"params\">person</span>: <span class=\"type\">RiskyCollector</span>)</span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> deck.contains(selected) <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">        deck.remove(selected)</span><br><span class=\"line\">        person.transfer(card: selected)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">transfer</span>(<span class=\"params\">card</span>: <span class=\"type\">String</span>)</span> &#123;</span><br><span class=\"line\">        deck.insert(card)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>危险：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = Set<span class=\"symbol\">&lt;String&gt;</span>([<span class=\"string\">&quot;1&quot;</span>,<span class=\"string\">&quot;2&quot;</span>,<span class=\"string\">&quot;3&quot;</span>,<span class=\"string\">&quot;4&quot;</span>,<span class=\"string\">&quot;5&quot;</span>,<span class=\"string\">&quot;6&quot;</span>,<span class=\"string\">&quot;7&quot;</span>,<span class=\"string\">&quot;8&quot;</span>,<span class=\"string\">&quot;9&quot;</span>,<span class=\"string\">&quot;10&quot;</span>,<span class=\"string\">&quot;11&quot;</span>,<span class=\"string\">&quot;12&quot;</span>])</span><br><span class=\"line\"><span class=\"keyword\">let</span> risky = RiskyCollector(deck:<span class=\"keyword\">set</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i in <span class=\"number\">1</span>...<span class=\"number\">12</span> &#123;</span><br><span class=\"line\">    DispatchQueue.<span class=\"keyword\">global</span>().async &#123;</span><br><span class=\"line\">        _ = risky.send(card: <span class=\"string\">&quot;\\(i)&quot;</span>, <span class=\"keyword\">to</span>: risky)</span><br><span class=\"line\">        <span class=\"keyword\">print</span>(risky.deck)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Actor 通过引入 Actor 隔离解决了这个问题：除非异步执行，否则无法从 Actor 对象外部读取属性和方法，并且根本无法从 Actor 对象外部写入属性。 Swift 会自动将这些请求放入一个按顺序处理的队列中，以避免出现多线程竞争。</p>\n<p>我们可以使用Actor重新实现一个SafeCollector，如下:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actor <span class=\"type\">SafeCollector</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deck: <span class=\"type\">Set</span>&lt;<span class=\"type\">String</span>&gt;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">deck</span>: <span class=\"type\">Set</span>&lt;<span class=\"type\">String</span>&gt;)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">self</span>.deck <span class=\"operator\">=</span> deck</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">send</span>(<span class=\"params\">card</span> <span class=\"params\">selected</span>: <span class=\"type\">String</span>, <span class=\"params\">to</span> <span class=\"params\">person</span>: <span class=\"type\">SafeCollector</span>)</span> <span class=\"keyword\">async</span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">guard</span> deck.contains(selected) <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">      deck.remove(selected)</span><br><span class=\"line\">      <span class=\"keyword\">await</span> person.transfer(card: selected)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">transfer</span>(<span class=\"params\">card</span>: <span class=\"type\">String</span>)</span> &#123;</span><br><span class=\"line\">      deck.insert(card)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>安全：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> <span class=\"operator\">=</span> <span class=\"type\">Set</span>&lt;<span class=\"type\">String</span>&gt;([<span class=\"string\">&quot;1&quot;</span>,<span class=\"string\">&quot;2&quot;</span>,<span class=\"string\">&quot;3&quot;</span>,<span class=\"string\">&quot;4&quot;</span>,<span class=\"string\">&quot;5&quot;</span>,<span class=\"string\">&quot;6&quot;</span>,<span class=\"string\">&quot;7&quot;</span>,<span class=\"string\">&quot;8&quot;</span>,<span class=\"string\">&quot;9&quot;</span>,<span class=\"string\">&quot;10&quot;</span>,<span class=\"string\">&quot;11&quot;</span>,<span class=\"string\">&quot;12&quot;</span>])</span><br><span class=\"line\"><span class=\"keyword\">let</span> risky <span class=\"operator\">=</span> <span class=\"type\">SafeCollector</span>(deck:<span class=\"keyword\">set</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">12</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Task</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">_</span> <span class=\"operator\">=</span> <span class=\"keyword\">await</span> risky.send(card: <span class=\"string\">&quot;<span class=\"subst\">\\(i)</span>&quot;</span>, to: risky)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"keyword\">await</span> risky.deck)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中有几件事情需要注意：</p>\n<ul>\n<li><p>actor内对外暴露的方法都是异步方法，即使没有标记async，因为它会等到另一个 SafeCollector actor 能够处理请求。</p>\n</li>\n<li><p>actor 可以自由地、异步或以其他方式使用自己的属性和方法，但是当与不同的 actor 交互时，它必须始终异步完成。通过这些特性，Swift 可以确保永远不会同时访问所有与 actor 隔离的状态，更重要的是，这是在编译时完成的，以保证线程安全。</p>\n</li>\n</ul>\n<p>Actor 和 Class 有一些相似之处：</p>\n<ul>\n<li><p>两者都是引用类型，因此它们可用于共享状态。</p>\n</li>\n<li><p>它们可以有方法、属性、初始值设定项和下标。</p>\n</li>\n<li><p>它们可以实现协议。任何静态属性和方法在这两种类型中的行为都相同。</p>\n</li>\n</ul>\n<p>除了 Actor 隔离之外，Actor 和 Class之间还有另外两个重要的区别：</p>\n<ul>\n<li><p>Actor 目前不支持继承，这在未来可能会改变</p>\n</li>\n<li><p>所有 Actor 都隐式遵守一个新的 Actor Protocol</p>\n</li>\n</ul>\n<h3 id=\"Global-Actor\"><a href=\"#Global-Actor\" class=\"headerlink\" title=\"Global Actor\"></a>Global Actor</h3><p>Global Actor 将 actor 隔离的概念扩展到了全局状态，即使状态和函数分散在许多不同的模块中，Global Actor 可以在并发程序中安全地使用全局变量，例如 Swift 提供的 <code>@MainActor</code> 限制属性和方法只能在主线程访问</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@MainActor</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">refreshUI</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;updating ui…&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainActor</span> <span class=\"keyword\">var</span> globalTextSize: <span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainActor</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">increaseTextSize</span>()</span> &#123;</span><br><span class=\"line\">  globalTextSize <span class=\"operator\">+=</span> <span class=\"number\">2</span>   <span class=\"comment\">// okay:</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">notOnTheMainActor</span>()</span> <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  globalTextSize <span class=\"operator\">=</span> <span class=\"number\">12</span>  <span class=\"comment\">// error: globalTextSize is isolated to MainActor</span></span><br><span class=\"line\">  increaseTextSize()   <span class=\"comment\">// error: increaseTextSize is isolated to MainActor, cannot call synchronously</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> increaseTextSize() <span class=\"comment\">// okay: asynchronous call hops over to the main thread and executes there</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>本文主要简述Swift 5.5新特性 async与await的常用方式</p>","more":"<h2 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h2><p>首先我们来做一个简单的下载图片的任务</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Download</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">image</span>(<span class=\"params\">url</span>: <span class=\"type\">URL</span>, <span class=\"params\">completeHandler</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">UIImage</span>?, <span class=\"type\">Error</span>?) -&gt; <span class=\"type\">Void</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> task <span class=\"operator\">=</span> <span class=\"type\">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error <span class=\"operator\">=</span> error &#123;</span><br><span class=\"line\">                <span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">                    completeHandler(<span class=\"literal\">nil</span>,error)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> data <span class=\"operator\">=</span> data, <span class=\"keyword\">let</span> httpResponse <span class=\"operator\">=</span> response <span class=\"keyword\">as?</span> <span class=\"type\">HTTPURLResponse</span>, httpResponse.statusCode <span class=\"operator\">==</span> <span class=\"number\">200</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> image <span class=\"operator\">=</span> <span class=\"type\">UIImage</span>(data: data)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> image <span class=\"operator\">!=</span> <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">                        completeHandler(image, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">                        completeHandler(<span class=\"literal\">nil</span>, <span class=\"type\">NSError</span>(domain: <span class=\"string\">&quot;org.swift&quot;</span>, code: <span class=\"operator\">-</span><span class=\"number\">2</span>))</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">                    completeHandler(<span class=\"literal\">nil</span>, <span class=\"type\">NSError</span>(domain: <span class=\"string\">&quot;org.swift&quot;</span>, code: <span class=\"operator\">-</span><span class=\"number\">1</span>))</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        task.resume()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以发现，这个简单的任务里面涉及到了block嵌套，子线程与主线程的切换等等上下文切换的逻辑。</p>\n<p>代码首先会执行第一行，然后就直接执行最后一行，再回到第二行执行，然后还得判断各种异常状态，最后才回到主线程刷新。可以发现这里面最深的嵌套达到了4层，而且上下文的切换也不利于代码阅读。可想而知要是逻辑稍微再多一点，就远远不止这种复杂度了。</p>\n<h2 id=\"用-async-和-await-来拯救一下\"><a href=\"#用-async-和-await-来拯救一下\" class=\"headerlink\" title=\"用 async 和 await 来拯救一下\"></a>用 async 和 await 来拯救一下</h2><p>改造完之后，代码如下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">image</span>(<span class=\"params\">url</span>: <span class=\"type\">URL</span>)</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">UIImage</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> (data, response) <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> <span class=\"type\">URLSession</span>.shared.data(from: url)</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> (response <span class=\"keyword\">as?</span> <span class=\"type\">HTTPURLResponse</span>)<span class=\"operator\">?</span>.statusCode <span class=\"operator\">==</span> <span class=\"number\">200</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">throw</span> <span class=\"type\">NSError</span>(domain: <span class=\"string\">&quot;org,swift&quot;</span>, code: <span class=\"operator\">-</span><span class=\"number\">1</span>) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> maybeImage <span class=\"operator\">=</span> <span class=\"type\">UIImage</span>(data: data) <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">throw</span> <span class=\"type\">NSError</span>(domain: <span class=\"string\">&quot;org,swift&quot;</span>, code: <span class=\"operator\">-</span><span class=\"number\">1</span>) &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> maybeImage</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用方式如下（如果需要捕获异常的话就需要加上<code>do-catch</code>）</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Task</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">try</span> <span class=\"keyword\">self</span>.imageView.image <span class=\"operator\">=</span> <span class=\"keyword\">await</span> <span class=\"type\">AsyncTest</span>.image(url: <span class=\"type\">URL</span>(string: <span class=\"string\">&quot;https://images.xiaozhuanlan.com/photo/2021/fb4d1bcda193cdfb5ccc380d1a008fe1.png&quot;</span>)<span class=\"operator\">!</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到我们的代码精简了许多，嵌套最深也就是判断到异常的时候抛出的1层，接下来我们来逐行讲解一下</p>\n<h3 id=\"发起请求\"><a href=\"#发起请求\" class=\"headerlink\" title=\"发起请求\"></a>发起请求</h3><p>首先<code>URLSession.shared.data(from: url) </code>是iOS 15 新出的方法，用于发起网络请求，方法定义如下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Convenience method to load data using an URL, creates and resumes an URLSessionDataTask internally.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter url: The URL for which to load data.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Returns: Data and response.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">data</span>(<span class=\"params\">from</span> <span class=\"params\">url</span>: <span class=\"type\">URL</span>, <span class=\"params\">delegate</span>: <span class=\"type\">URLSessionTaskDelegate</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; (<span class=\"type\">Data</span>, <span class=\"type\">URLResponse</span>)</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>async</code> 表示这是一个异步方法，如同我们前面定义的方法一样<code>static func image(url: URL) async throws -&gt; UIImage</code>，同样也有<code>async</code>这个关键字，只要方法里面有<code>await</code>关键字，那么方法名就得带上<code>async</code>关键字。带有<code>async</code>的方法就意味着需要使用<code>await</code>去调用，然后其返回值可以直接赋值给某个变量。举例如下:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getName</span>()</span> <span class=\"keyword\">async</span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/// 发起网络请求获取名字，这时候线程会卡住，直到请求完成了，就会把这个请求方法的返回值直接赋值给name，然后就会继续往下执行，把拿到的name给返回出去</span></span><br><span class=\"line\">\t<span class=\"keyword\">let</span> name <span class=\"operator\">=</span> <span class=\"keyword\">await</span> requestName()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 同理，当代码执行到这里的时候，调用异步方法，线程会卡住，然后方法里面去调用网络请求获取名字，然后等待网络请求返回之后，name就会被赋上值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> name <span class=\"operator\">=</span> <span class=\"keyword\">await</span> getName()</span><br></pre></td></tr></table></figure>\n\n<p>以上面的<code>URLSession</code>的<code>data(from:delegate:)</code>方法为例，返回的是一个元组，所以就是</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> (data, response) <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> <span class=\"type\">URLSession</span>.shared.data(from: url)</span><br></pre></td></tr></table></figure>\n<p>表示请求后，<code>data</code>和<code>response</code>变量都会被赋上值，分别是<code>Data</code>类型和<code>URLResponse</code>类型</p>\n<p>另外我们注意到，和通过block方式返回请求结果不同，这个新方法返回的元组中的<code>data</code>和<code>response</code>都不是可选类型，而是确切有值的，如果发生网络异常则会通过<code>throw</code>抛出异常，这样子的设计能够让我们节省加下来针对空值的判断，可以放心地使用返回值</p>\n<blockquote>\n<p>当然，不仅仅是网络请求可以用<code>await</code>，任意的异步行为（比如读取本地文件）都可以使用<code>await</code></p>\n</blockquote>\n<p>目前在iOS 15 SDK的<code>URLSession</code>中，不仅仅提供了上述请求数据，返回元组的方法，还提供了其他上传，下载的方法，可供异步调用，这里简单列举一下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter request: The URLRequest for which to upload data.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter fileURL: File to upload.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Returns: Data and response.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">upload</span>(<span class=\"params\">for</span> <span class=\"params\">request</span>: <span class=\"type\">URLRequest</span>, <span class=\"params\">fromFile</span> <span class=\"params\">fileURL</span>: <span class=\"type\">URL</span>, <span class=\"params\">delegate</span>: <span class=\"type\">URLSessionTaskDelegate</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; (<span class=\"type\">Data</span>, <span class=\"type\">URLResponse</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter request: The URLRequest for which to upload data.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter bodyData: Data to upload.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Returns: Data and response.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">upload</span>(<span class=\"params\">for</span> <span class=\"params\">request</span>: <span class=\"type\">URLRequest</span>, <span class=\"params\">from</span> <span class=\"params\">bodyData</span>: <span class=\"type\">Data</span>, <span class=\"params\">delegate</span>: <span class=\"type\">URLSessionTaskDelegate</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; (<span class=\"type\">Data</span>, <span class=\"type\">URLResponse</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Convenience method to download using an URLRequest, creates and resumes an URLSessionDownloadTask internally.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter request: The URLRequest for which to download.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Returns: Downloaded file URL and response. The file will not be removed automatically.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">download</span>(<span class=\"params\">for</span> <span class=\"params\">request</span>: <span class=\"type\">URLRequest</span>, <span class=\"params\">delegate</span>: <span class=\"type\">URLSessionTaskDelegate</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; (<span class=\"type\">URL</span>, <span class=\"type\">URLResponse</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Convenience method to download using an URL, creates and resumes an URLSessionDownloadTask internally.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter url: The URL for which to download.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Returns: Downloaded file URL and response. The file will not be removed automatically.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">download</span>(<span class=\"params\">from</span> <span class=\"params\">url</span>: <span class=\"type\">URL</span>, <span class=\"params\">delegate</span>: <span class=\"type\">URLSessionTaskDelegate</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; (<span class=\"type\">URL</span>, <span class=\"type\">URLResponse</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// Convenience method to resume download, creates and resumes an URLSessionDownloadTask internally.</span></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter resumeData: Resume data from an incomplete download.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class=\"line\"><span class=\"comment\">/// - Returns: Downloaded file URL and response. The file will not be removed automatically.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">download</span>(<span class=\"params\">resumeFrom</span> <span class=\"params\">resumeData</span>: <span class=\"type\">Data</span>, <span class=\"params\">delegate</span>: <span class=\"type\">URLSessionTaskDelegate</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span>)</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; (<span class=\"type\">URL</span>, <span class=\"type\">URLResponse</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"容错-amp-转码\"><a href=\"#容错-amp-转码\" class=\"headerlink\" title=\"容错 &amp; 转码\"></a>容错 &amp; 转码</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">guard</span> (response <span class=\"keyword\">as?</span> <span class=\"type\">HTTPURLResponse</span>)<span class=\"operator\">?</span>.statusCode <span class=\"operator\">==</span> <span class=\"number\">200</span> <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">throw</span> <span class=\"type\">NSError</span>(domain: <span class=\"string\">&quot;org,swift&quot;</span>, code: <span class=\"operator\">-</span><span class=\"number\">1</span>) &#125;</span><br></pre></td></tr></table></figure>\n<p>这一行用来处理响应体的异常情况，当<code>statusCode</code> 为 200的判断不成立时，就会抛出异常，则外部需要通过<code>do-catch</code>去捕获</p>\n<p>如果判断成立时，则程序继续往下走</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> maybeImage <span class=\"operator\">=</span> <span class=\"type\">UIImage</span>(data: data) <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">throw</span> <span class=\"type\">NSError</span>(domain: <span class=\"string\">&quot;org,swift&quot;</span>, code: <span class=\"operator\">-</span><span class=\"number\">1</span>) &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里将<code>data</code>转成了<code>UIImage</code>，由于该方法返回的是一个可选值，所以这里同样需要通过<code>guard</code>去判断转换失败的情况</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> maybeImage</span><br></pre></td></tr></table></figure>\n\n<p>最后得到了确切的结果之后，我们就可以将转好的图片给发送出去了，并且外面使用这个返回值的时候也不用判空，可以放心地确定返回的图片是有值的。</p>\n<h3 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h3><p>当我们的方法被标记为<code>async</code>的时候，我们就需要加上<code>await</code>进行调用，并且调用的环境是需要在异步环境内的，即如下所示</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> <span class=\"keyword\">let</span> image <span class=\"operator\">=</span> <span class=\"keyword\">await</span> <span class=\"type\">AsyncTest</span>.image(url: xxxx)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在Xcode 13.0 bata 4 中这个<code>async &#123;&#125; </code>环境的建立代码被提示即将被废弃，所以改成了如下所示</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Task</span>(priority: .userInitiated) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> <span class=\"keyword\">let</span> image <span class=\"operator\">=</span> <span class=\"keyword\">await</span> <span class=\"type\">AsyncTest</span>.image(url: xxxx)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>userInitiated</code>表示线程优先级为<code>用户发起</code>，当然<code>priority</code>参数也可以不填，默认优先级是<code>Task.currentPriority</code>，返回值默认是<code>default</code></p>\n<p>目前有六种优先级，这里从高到低进行排列如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 优先级最高</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> high: <span class=\"type\">TaskPriority</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 等同于default</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> medium: <span class=\"type\">TaskPriority</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> low: <span class=\"type\">TaskPriority</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> userInitiated: <span class=\"type\">TaskPriority</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> utility: <span class=\"type\">TaskPriority</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 优先级最低</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> background: <span class=\"type\">TaskPriority</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>当你标记一个函数为<code>async</code>时，即表示该函数可以被挂起。在<code>async</code>函数内部，使用<code>await</code>关键词标记在哪里可以一次或多次挂起。当<code>async</code>函数挂起时，线程并未阻塞，系统会自由安排其他任务。有时后启动的任务，可能先被执行。即你的程序状态可能在挂起时发生显著变化。当<code>async</code>函数恢复执行时，其返回的结果会自然融入到<code>async</code>函数的调用者，并在先前挂起的地方接续执行。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p><code>await</code>关键字表示该异步（async）函数可能会被挂起，而不是畅通无阻地继续执行下去，甚至从挂起恢复回来时，函数可能已经跑到了另一个线程上去了，为了解决这个问题，我们可以用Swift的<code>actor</code>保护可变状态，这个我们后面再讲</p>\n<h2 id=\"Async序列\"><a href=\"#Async序列\" class=\"headerlink\" title=\"Async序列\"></a>Async序列</h2><p>Async序列顾名思义就是异步的序列，比如读取一个很大的文件，我们希望一边下载一边展示读取的内容，这时候我们可以通过使用<code>for await-in</code> 来遍历一个异步的序列，如下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">eatchquakes</span>()</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> endpointURL <span class=\"operator\">=</span> <span class=\"type\">URL</span>(string: <span class=\"string\">&quot;https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.csv&quot;</span>)<span class=\"operator\">!</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 跳过首行 因为是header描述不是地震数据</span></span><br><span class=\"line\">    <span class=\"comment\">// 接着遍历提取强度、时间、经纬度信息</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> event <span class=\"keyword\">in</span> endpointURL.lines.dropFirst() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> values <span class=\"operator\">=</span> event.split(separator: <span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> time <span class=\"operator\">=</span> values[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> latitude <span class=\"operator\">=</span> values[<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> longtitude <span class=\"operator\">=</span> values[<span class=\"number\">2</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> magnitude <span class=\"operator\">=</span> values[<span class=\"number\">4</span>]</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Magnitude <span class=\"subst\">\\(magnitude)</span> on <span class=\"subst\">\\(time)</span> at <span class=\"subst\">\\(latitude)</span> <span class=\"subst\">\\(longtitude)</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，异步序列就是对随着时间推移如何产生值或对象的一种描述方式。由于值的产生是异步的，所以可能会在读取的过程中出现异常，当异常发生的时候，遍历终止，并抛出异常。</p>\n<p>其中，<code>lines</code>方法是iOS 15 新增的一个<code>URL</code>的拓展属性，同时还有<code>resourceBytes</code>属性，完整定义如下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">URL</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AsyncBytes</span> : <span class=\"title\">AsyncSequence</span>, <span class=\"title\">AsyncIteratorProtocol</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">AsyncIterator</span> <span class=\"operator\">=</span> <span class=\"type\">URL</span>.<span class=\"type\">AsyncBytes</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">typealias</span> <span class=\"type\">Element</span> <span class=\"operator\">=</span> <span class=\"type\">UInt8</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/// Asynchronously advances to the next element and returns it, or ends the</span></span><br><span class=\"line\">        <span class=\"comment\">/// sequence if there is no next element.</span></span><br><span class=\"line\">        <span class=\"comment\">/// </span></span><br><span class=\"line\">        <span class=\"comment\">/// - Returns: The next element, if it exists, or `nil` to signal the end of</span></span><br><span class=\"line\">        <span class=\"comment\">///   the sequence.</span></span><br><span class=\"line\">        <span class=\"keyword\">@inlinable</span> <span class=\"keyword\">public</span> <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">next</span>()</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">UInt8</span>?</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/// Creates the asynchronous iterator that produces elements of this</span></span><br><span class=\"line\">        <span class=\"comment\">/// asynchronous sequence.</span></span><br><span class=\"line\">        <span class=\"comment\">///</span></span><br><span class=\"line\">        <span class=\"comment\">/// - Returns: An instance of the `AsyncIterator` type used to produce</span></span><br><span class=\"line\">        <span class=\"comment\">/// elements of the asynchronous sequence.</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeAsyncIterator</span>()</span> -&gt; <span class=\"type\">URL</span>.<span class=\"type\">AsyncBytes</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> resourceBytes: <span class=\"type\">URL</span>.<span class=\"type\">AsyncBytes</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> lines: <span class=\"type\">AsyncLineSequence</span>&lt;<span class=\"type\">URL</span>.<span class=\"type\">AsyncBytes</span>&gt; &#123; <span class=\"keyword\">get</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为异步序列的遍历是一个耗时操作，所以我们也可以在需要的时候中断遍历（取消请求）</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> task <span class=\"operator\">=</span> <span class=\"type\">Task</span>(priority: .userInitiated) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> <span class=\"type\">AsyncTest</span>.eatchquakes()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 取消</span></span><br><span class=\"line\">task.cancel()</span><br></pre></td></tr></table></figure>\n\n<p>除了<code>URL</code>新增的<code>lines</code>方法，iOS 15 还给<code>FileHandle</code>和<code>URLSession</code>添加了异步序列方法，比如<code>FileHandle</code>新增的<code>bytes</code>属性，能提供字节流的异步序列。配合异步序列的扩展能力（把字节流变成<code>lines</code>），我们就可以从文件中异步地获得逐行内容并进行处理了。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从FileHandle异步读取bytes</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> bytes: <span class=\"type\">AsyncBytes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> line <span class=\"keyword\">in</span> <span class=\"type\">FileHandle</span>.standardInput.bytes.lines &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不仅如此，现在通知也支持异步序列了</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 异步await通知</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">notifications</span>(<span class=\"params\">named</span>: <span class=\"type\">Notification</span>.<span class=\"type\">Name</span>, <span class=\"params\">object</span>: <span class=\"type\">AnyObject</span>)</span> -&gt; notifications</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> center <span class=\"operator\">=</span> <span class=\"type\">NotificationCenter</span>.default</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 返回第一个userInfo的NSStoreUUIDKey值为storeUUID的通知</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> notification <span class=\"operator\">=</span> <span class=\"keyword\">await</span> center.notifications(named: .<span class=\"type\">NSPersistentStoreRemoteChange</span>).first &#123;</span><br><span class=\"line\">    <span class=\"variable\">$0</span>.userInfo[<span class=\"type\">NSStoreUUIDKey</span>] <span class=\"operator\">==</span> storeUUID</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"将异步回调的闭包方法改造成async方法\"><a href=\"#将异步回调的闭包方法改造成async方法\" class=\"headerlink\" title=\"将异步回调的闭包方法改造成async方法\"></a>将异步回调的闭包方法改造成async方法</h2><p>上面提到的都是基于系统提供的<code>async</code>方法，如果要改造我们原有的异步回调block方法，我们可以使用<code>withCheckedContinuation</code>或者<code>withCheckedThrowingContinuation</code>函数，区别在于前者用于确定不会抛出错误的场景，举例如下：</p>\n<ul>\n<li>三秒后返回Hello World</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getItem</span>(<span class=\"params\">callback</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">String</span>)-&gt;(<span class=\"type\">Void</span>))</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class=\"operator\">+</span> <span class=\"number\">3.0</span>) &#123;</span><br><span class=\"line\">        callback(<span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>改造后</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getItem</span>()</span> <span class=\"keyword\">async</span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> withCheckedContinuation &#123; continuation <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"type\">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class=\"operator\">+</span> <span class=\"number\">3.0</span>) &#123;</span><br><span class=\"line\">            continuation.resume(returning: <span class=\"string\">&quot;Hello World&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">/// 如果需要抛出错误，使用 continuation.resume(throwing: error)</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>continuation 有个简单但是重要的原则，resume方法必须在每个路径上执行，有且只有一次。但是不用担心，如果在有的路径上没有执行resume方法，Swift runtime 会发出 warning 警告。</p>\n<p>但如果在某个路径上，resume执行了不止一次，这会是严重得多的问题。Swift runtime 会在第二次 resume 调用处触发 fatal error。</p>\n<p>如果使用的是<code>withTaskCancellationHandler</code>，那么可以在异步操作被取消的时候执行某些行为</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getItem</span>()</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> withTaskCancellationHandler &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Cancel&quot;</span>)</span><br><span class=\"line\">    &#125; operation: &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> result <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> withCheckedThrowingContinuation &#123; continuation <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"type\">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class=\"operator\">+</span> <span class=\"number\">3.0</span>) &#123;</span><br><span class=\"line\">                continuation.resume(returning: <span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 调用</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> task <span class=\"operator\">=</span> <span class=\"type\">Task</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> item <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> <span class=\"type\">AsyncTest</span>.getItem()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(item)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Error&quot;</span> <span class=\"operator\">+</span> error.localizedDescription)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 调用取消的时候会打印`Cancel`</span></span><br><span class=\"line\">task.cancel()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"只读属性使用async\"><a href=\"#只读属性使用async\" class=\"headerlink\" title=\"只读属性使用async\"></a>只读属性使用async</h2><p>只读属性可以在其<code>get</code>方法中使用<code>async</code>标记是一个异步读取的属性，如下所示</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AsyncTest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">FileError</span> : <span class=\"title\">Error</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> missing, unreadable</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> content : <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">get</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> url <span class=\"operator\">=</span> <span class=\"type\">Bundle</span>.main.url(forResource: <span class=\"string\">&quot;Empty&quot;</span>, withExtension: <span class=\"string\">&quot;md&quot;</span>) <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">throw</span> <span class=\"type\">FileError</span>.missing &#125;</span><br><span class=\"line\">          <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> <span class=\"type\">String</span>(contentsOf: url)</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">throw</span> <span class=\"type\">FileError</span>.unreadable</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">readContent</span>()</span> <span class=\"keyword\">async</span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> result <span class=\"operator\">=</span> <span class=\"keyword\">try</span> <span class=\"keyword\">await</span> <span class=\"keyword\">self</span>.content</span><br><span class=\"line\">      <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结构化并发\"><a href=\"#结构化并发\" class=\"headerlink\" title=\"结构化并发\"></a>结构化并发</h2><p>假如我们有多个异步函数，比如<code>切菜</code>、<code>切洋葱</code>、<code>切肉</code></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cooking</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cutVegetable</span>()</span> <span class=\"keyword\">async</span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">await</span> <span class=\"type\">Task</span>.sleep(<span class=\"number\">10_000_000_000</span>) <span class=\"comment\">// 暂停10秒的意思</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;cut vegetable&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cutOnion</span>()</span> <span class=\"keyword\">async</span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">await</span> <span class=\"type\">Task</span>.sleep(<span class=\"number\">5_000_000_000</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;cut onion&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cutMeet</span>()</span> <span class=\"keyword\">async</span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">await</span> <span class=\"type\">Task</span>.sleep(<span class=\"number\">5_000_000_000</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;cut meet&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们这么调用的话，那么整个过程将是串行的，一共会花费20秒左右</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Task</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> step1 <span class=\"operator\">=</span> <span class=\"keyword\">await</span> <span class=\"type\">Cooking</span>.cutVegetable()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> step2 <span class=\"operator\">=</span> <span class=\"keyword\">await</span> <span class=\"type\">Cooking</span>.cutOnion()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> step3 <span class=\"operator\">=</span> <span class=\"keyword\">await</span> <span class=\"type\">Cooking</span>.cutMeet()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">print</span>([step1,step2,step3])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是实际三个步骤之间并没有依赖关系，是可以同时进行的，所以我们需要使用结构化并发，让他们并发执行</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cooking</span>()</span> <span class=\"keyword\">async</span> -&gt; [<span class=\"type\">String</span>] &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> withTaskGroup(of: <span class=\"type\">String</span>.<span class=\"keyword\">self</span>) &#123; group <span class=\"keyword\">in</span></span><br><span class=\"line\">        group.addTask &#123;</span><br><span class=\"line\">            <span class=\"keyword\">await</span> <span class=\"type\">Cooking</span>.cutVegetable()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        group.addTask &#123;</span><br><span class=\"line\">            <span class=\"keyword\">await</span> <span class=\"type\">Cooking</span>.cutOnion()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        group.addTask &#123;</span><br><span class=\"line\">            <span class=\"keyword\">await</span> <span class=\"type\">Cooking</span>.cutMeet()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> steps : [<span class=\"type\">String</span>] <span class=\"operator\">=</span> []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> finishedStep <span class=\"keyword\">in</span> group &#123;</span><br><span class=\"line\">            steps.append(finishedStep)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> steps</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样子只要10秒左右就可以完成任务了</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Task</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result <span class=\"operator\">=</span> <span class=\"keyword\">await</span> cooking()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(result)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果在执行子任务的过程中发生了异常，那么<code>cooking()</code>方法将会退出，任何尚未完成的子任务都将自动取消。</p>\n<h2 id=\"Actor\"><a href=\"#Actor\" class=\"headerlink\" title=\"Actor\"></a>Actor</h2><p>由于我们现在已经多很多异步操作的场景，所以自然我们在设计类的时候，也要注意这个类要是被多个线程同时访问的时候引起的状态变化的问题。</p>\n<p>Swift 5.5引入了Actor，它在概念上类似于在并发环境中可以安全使用的类。Swift 确保在任何给定时间只能由单个线程访问 Actor 内的可变状态，这有助于在编译器级别消除各种严重的错误。</p>\n<p>比如以下代码在单线程情况下是安全的，但是如果是多线程访问的话<code>deck</code>属性会出现资源竞争的问题</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RiskyCollector</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> deck: <span class=\"type\">Set</span>&lt;<span class=\"type\">String</span>&gt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">deck</span>: <span class=\"type\">Set</span>&lt;<span class=\"type\">String</span>&gt;)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.deck <span class=\"operator\">=</span> deck</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">send</span>(<span class=\"params\">card</span> <span class=\"params\">selected</span>: <span class=\"type\">String</span>, <span class=\"params\">to</span> <span class=\"params\">person</span>: <span class=\"type\">RiskyCollector</span>)</span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> deck.contains(selected) <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">        deck.remove(selected)</span><br><span class=\"line\">        person.transfer(card: selected)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">transfer</span>(<span class=\"params\">card</span>: <span class=\"type\">String</span>)</span> &#123;</span><br><span class=\"line\">        deck.insert(card)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>危险：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> = Set<span class=\"symbol\">&lt;String&gt;</span>([<span class=\"string\">&quot;1&quot;</span>,<span class=\"string\">&quot;2&quot;</span>,<span class=\"string\">&quot;3&quot;</span>,<span class=\"string\">&quot;4&quot;</span>,<span class=\"string\">&quot;5&quot;</span>,<span class=\"string\">&quot;6&quot;</span>,<span class=\"string\">&quot;7&quot;</span>,<span class=\"string\">&quot;8&quot;</span>,<span class=\"string\">&quot;9&quot;</span>,<span class=\"string\">&quot;10&quot;</span>,<span class=\"string\">&quot;11&quot;</span>,<span class=\"string\">&quot;12&quot;</span>])</span><br><span class=\"line\"><span class=\"keyword\">let</span> risky = RiskyCollector(deck:<span class=\"keyword\">set</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i in <span class=\"number\">1</span>...<span class=\"number\">12</span> &#123;</span><br><span class=\"line\">    DispatchQueue.<span class=\"keyword\">global</span>().async &#123;</span><br><span class=\"line\">        _ = risky.send(card: <span class=\"string\">&quot;\\(i)&quot;</span>, <span class=\"keyword\">to</span>: risky)</span><br><span class=\"line\">        <span class=\"keyword\">print</span>(risky.deck)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Actor 通过引入 Actor 隔离解决了这个问题：除非异步执行，否则无法从 Actor 对象外部读取属性和方法，并且根本无法从 Actor 对象外部写入属性。 Swift 会自动将这些请求放入一个按顺序处理的队列中，以避免出现多线程竞争。</p>\n<p>我们可以使用Actor重新实现一个SafeCollector，如下:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actor <span class=\"type\">SafeCollector</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deck: <span class=\"type\">Set</span>&lt;<span class=\"type\">String</span>&gt;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">init</span>(<span class=\"params\">deck</span>: <span class=\"type\">Set</span>&lt;<span class=\"type\">String</span>&gt;)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">self</span>.deck <span class=\"operator\">=</span> deck</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">send</span>(<span class=\"params\">card</span> <span class=\"params\">selected</span>: <span class=\"type\">String</span>, <span class=\"params\">to</span> <span class=\"params\">person</span>: <span class=\"type\">SafeCollector</span>)</span> <span class=\"keyword\">async</span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">guard</span> deck.contains(selected) <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">      deck.remove(selected)</span><br><span class=\"line\">      <span class=\"keyword\">await</span> person.transfer(card: selected)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">transfer</span>(<span class=\"params\">card</span>: <span class=\"type\">String</span>)</span> &#123;</span><br><span class=\"line\">      deck.insert(card)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>安全：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"keyword\">set</span> <span class=\"operator\">=</span> <span class=\"type\">Set</span>&lt;<span class=\"type\">String</span>&gt;([<span class=\"string\">&quot;1&quot;</span>,<span class=\"string\">&quot;2&quot;</span>,<span class=\"string\">&quot;3&quot;</span>,<span class=\"string\">&quot;4&quot;</span>,<span class=\"string\">&quot;5&quot;</span>,<span class=\"string\">&quot;6&quot;</span>,<span class=\"string\">&quot;7&quot;</span>,<span class=\"string\">&quot;8&quot;</span>,<span class=\"string\">&quot;9&quot;</span>,<span class=\"string\">&quot;10&quot;</span>,<span class=\"string\">&quot;11&quot;</span>,<span class=\"string\">&quot;12&quot;</span>])</span><br><span class=\"line\"><span class=\"keyword\">let</span> risky <span class=\"operator\">=</span> <span class=\"type\">SafeCollector</span>(deck:<span class=\"keyword\">set</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">12</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Task</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">_</span> <span class=\"operator\">=</span> <span class=\"keyword\">await</span> risky.send(card: <span class=\"string\">&quot;<span class=\"subst\">\\(i)</span>&quot;</span>, to: risky)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"keyword\">await</span> risky.deck)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中有几件事情需要注意：</p>\n<ul>\n<li><p>actor内对外暴露的方法都是异步方法，即使没有标记async，因为它会等到另一个 SafeCollector actor 能够处理请求。</p>\n</li>\n<li><p>actor 可以自由地、异步或以其他方式使用自己的属性和方法，但是当与不同的 actor 交互时，它必须始终异步完成。通过这些特性，Swift 可以确保永远不会同时访问所有与 actor 隔离的状态，更重要的是，这是在编译时完成的，以保证线程安全。</p>\n</li>\n</ul>\n<p>Actor 和 Class 有一些相似之处：</p>\n<ul>\n<li><p>两者都是引用类型，因此它们可用于共享状态。</p>\n</li>\n<li><p>它们可以有方法、属性、初始值设定项和下标。</p>\n</li>\n<li><p>它们可以实现协议。任何静态属性和方法在这两种类型中的行为都相同。</p>\n</li>\n</ul>\n<p>除了 Actor 隔离之外，Actor 和 Class之间还有另外两个重要的区别：</p>\n<ul>\n<li><p>Actor 目前不支持继承，这在未来可能会改变</p>\n</li>\n<li><p>所有 Actor 都隐式遵守一个新的 Actor Protocol</p>\n</li>\n</ul>\n<h3 id=\"Global-Actor\"><a href=\"#Global-Actor\" class=\"headerlink\" title=\"Global Actor\"></a>Global Actor</h3><p>Global Actor 将 actor 隔离的概念扩展到了全局状态，即使状态和函数分散在许多不同的模块中，Global Actor 可以在并发程序中安全地使用全局变量，例如 Swift 提供的 <code>@MainActor</code> 限制属性和方法只能在主线程访问</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@MainActor</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">refreshUI</span>()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;updating ui…&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainActor</span> <span class=\"keyword\">var</span> globalTextSize: <span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@MainActor</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">increaseTextSize</span>()</span> &#123;</span><br><span class=\"line\">  globalTextSize <span class=\"operator\">+=</span> <span class=\"number\">2</span>   <span class=\"comment\">// okay:</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">notOnTheMainActor</span>()</span> <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  globalTextSize <span class=\"operator\">=</span> <span class=\"number\">12</span>  <span class=\"comment\">// error: globalTextSize is isolated to MainActor</span></span><br><span class=\"line\">  increaseTextSize()   <span class=\"comment\">// error: increaseTextSize is isolated to MainActor, cannot call synchronously</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> increaseTextSize() <span class=\"comment\">// okay: asynchronous call hops over to the main thread and executes there</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"iOS 底层原理 --- 内存管理","author":"Arclin","abbrlink":"56d1bd42","date":"2021-09-03T09:26:00.000Z","_content":"本文主要介绍iOS中内存管理的一些事情\n\n<!--more-->\n\n## 定时器\n\n### CADisplayLink、NSTimer\n\n`CADisplayLink`、`NSTimer`会对`target`产生强引用，如果`target`又对它们产生强引用，那么就会引发循环引用\n\n比如：\n\n```\n@property (strong) NSTimer *timer;\nself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTimer) userInfo:nil repeats:YES];\n```\n\n在这里，`self`强持有了`timer`，`timer`强持有了`self`，造成了循环引用\n\n#### 利用block解决\n\n针对`NSTimer`我们可以有另外的解决办法：\n\n```objectivec\n__weak typeof(self) weakself = self;\nself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {\n    [weakself timerTest];\n]};\n```\n\n让`timer`强持有block，block弱持有`self`，这样子`self`就是间接被弱持有，打破了循环引用。\n\n#### 利用NSProxy解决\n\n新建一个类继承自`NSProxy`\n\n```objectivec\n@interface MyProxy : NSProxy\n\n+ (instancetype)proxyWithTarget:(id)target;\n\n@end\n\n```\n\n```objectivec\n@interface MyProxy()\n\n@property (nonatomic, weak) id target;\n\n@end\n\n@implementation MyProxy\n\n+ (instancetype)proxyWithTarget:(id)target {\n    // NSProxy对象不需要调用init，因为它没有init方法\n    MyProxy *proxy = [MyProxy alloc];\n    proxy.target = target;\n    return proxy;\n}\n\n/// 实现消息转发的两个方法，一定要实现，不然会报方法找不到的错误\n\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel {\n    return [self.target methodSignatureForSelector:sel];\n}\n\n- (void)forwardInvocation:(NSInvocation *)invocation {\n    [invocation invokeWithTarget:self.target];\n}\n\n@end\n```\n\n使用\n\n```objectivec\nself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[MyProxy proxyWithTarget:self] selector:@selector(test) userInfo:nil repeats:YES];\n\n```\n\n原理很简单，就是把`self`让`proxy`弱持有，`timer`强持有`proxy`，这样子就能够做到间接弱持有`self`，打破循环引用\n\n为了让`timer`调用`selector`的时候能调回到`self`的方法，在`proxy`内部我们使用消息转发机制，把消息转发到`target`（也就是`self`）中，实现调用。\n\n至于消息转发机制的另一个方法`-forwardingTargetForSelector:`之所以不能使用，是因为`NSProxy`不提供。\n\n实际上我们如果不继承自`NSProxy`，直接继承自`NSObject`也是能完成上述操作的，但是使用`NSProxy`的话可以跳过消息发送和动态方法解析阶段，直接进入消息转发阶段，效率比较高\n\n> 注意： `NSProxy`对象如果调用`isKindOfClass:`或其他方法，那么由于它直接进入了消息转发阶段，所以会直接拿`target`属性去调用方法，所以都跟`NSProxy`对象本身没有关系\n\n\n### GCD定时器\n\n- `NSTimer`依赖`RunLoop`，如果`Runloop`的任务过于繁重，可能会导致`NSTimer`不准时\n\t- 因为Runloop每次循环的时间是不定的，所以下次循环的时候到达处理定时器那个环节，不一定跟上次刚好相差我们所指定时间，所以就会不准\n    \n- GCD的定时器会更加准时\n\n```objectivec\n// 队列\ndispatch_queue_t queue = dispatch_get_main_queue();\n\n// 创建定时器\ndispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n\n// 设置时间\nNSTimeInterval start = 2.0; // 2秒后开始执行\nNSTimeInterval interval = 1.0; // 每1秒执行一次\ndispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * NSEC_PER_SEC), interval * NSEC_PER_SEC, 0);\n\n// 设置回调\ndispatch_source_set_event_handler(timer, ^{\n    NSLog(@\"11111\");\n});\n\n// 启动定时器\ndispatch_resume(timer);\n\n// 取消定时器\n// dispatch_source_cancel(timer);\n\nself.timer = timer;\n```\n\n由于GCD的定时器跟`Runloop`没有关系，所以滚动视图也不会影响GCD定时器的执行\n\n除了使用block回调，我们也可以写一个C函数作为回调函数\n\n```c\ndispatch_source_set_event_handler_f(timer, timerFire);\n```\n\n```c\nvoid timerFire(void *param) {\n    NSLog(@\"%@ %@\",param,[NSThread currentThread]);\n}\n```\n\n## 内存布局\n\n- 内存布局从低地址到高地址排序如下\n  1. 保留\n  2. 代码段（__TEXT）\n  3. 数据段（__DATA）：字符串常量， 已初始化数据，未初始化数据\n  4. 堆（heap）\n  5. 栈（stack）\n  6. 内核区\n  \n- 代码段：编译之后的代码\n- 数据段：\n\t- 字符串常量\n    - 已初始化数据：已初始化的全局变量、静态变量等\n    - 未初始化数据：未初始化的全局变量、静态变量等\n- 堆：通过alloc、malloc、calloc的那个动态分配的空间，分配的内存空间地址越来越大\n- 栈：函数调用开销，比如局部变量，分配的内存空间地址越来越小\n\n\n## Tagged Pointer\n\n- 从64bit开始，iOS引入了Tagged Pointer技术，用于优化`NSNumber`,`NSDate`，`NSString`等小对象的存储\n\n- 在没有使用Tagged Pointer之前，`NSNumber`等对象需要动态分配内存，维护引用计数的等，`NSNumber`指针存储的是堆中`NSNumber`对象的地址值.\n\n- 使用`Tagged Pointer`之后，`NSNumber`指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中。\n\n- 在Mac环境下当对象指针的二进制最低有效位是1，则该指针为`Tagged Pointer`（如果是0那么就是OC对象，因为OC对象分配内存是按照16个字节对齐的，所以最后一位肯定是0）,可以编写如下函数来判断是否是`Tagged Pointer`\n\n\t- 跟1进行与运算，取出最低位判断是不是1即可\n\n  ```c\n  BOOL isTaggedPointer(id pointer) {\n      return (long)(__bridge void *)pointer & 1;\n  }\n  ```\n  - 如果是iOS环境下，则判断的是最高有效位(第64位)是否是1，即`(long)(__bridge void *)pointer & 1UL<<63`\n\n- 当指针不够存储数据时，才会使用动态分配内存来存储数据（比如NSNumber的存储的数字太大了，指针8个十六进制位都装不下）\n\n- `objc_msgSend`能识别`Tagged Pointer`，比如`NSNumber`的intValue方法，直接从指针提取数据，节省了以前的调用开销\n\n### 字符串\n\n```\n@property(copy, nonatomic) NSString *name;\n```\n\n这个属性的set方法实际为\n\n```\n- (void)setName:(NSString *)name {\n    if(_name != name) {\n        [_name release];\n        _name = [name retain];\n    }\n}\n```\n\n假如我们这么给`name`赋值`self.name = [NSString stringWithForamt:@\"abcdefghijkl\"]`，因为这个太大了，转不成`tagged pointer`，那么在多线程环境下，有可能会因为多次执行了`[_name release]`导致坏内存访问而崩溃\n\n字符串其实还有其他样子，总的来说，除了`__NSCFString`，其他类型的字符串都不会调用`release`方法\n\n- __NSCFConstantString\n\n\t字符串常量，是一种编译时常量，它的 retainCount 值很大，是 4294967295，在控制台打印出的数值则是 18446744073709551615==2^64-1，测试证明，即便对其进行 release 操作，retainCount 也不会产生任何变化。是创建之后便是放不掉的对象。**相同内容的 __NSCFConstantString 对象的地址相同，也就是说常量字符串对象是一种单例**。\n\n\t这种对象一般通过字面值 `@\"...\"`、`CFSTR(\"...\")` 或者 `stringWithString`: 方法（需要说明的是，这个方法在 iOS6 SDK 中已经被称为redundant，使用这个方法会产生一条编译器警告。这个方法等同于字面值创建的方法）产生。\n\n\t这种对象存储在字符串常量区。\n\n- __NSCFString\n\n\t和 `__NSCFConstantString` 不同， `__NSCFString`对象是在运行时创建的一种 `NSString`子类，他并不是一种字符串常量。所以和其他的对象一样在被创建时获得了 1 的引用计数。\n\n\t通过 NSString 的 stringWithFormat 等方法创建的 NSString 对象一般都是这种类型。\n\n\t这种对象被存储在堆上。\n\n- NSTaggedPointerString\n\n\t理解这个类型，需要明白什么是`TaggedPointer`，这是苹果在 64 位环境下对 NSString,NSNumber 等对象做的一些优化。简单来讲可以理解为把指针指向的内容直接放在了指针变量的内存地址中，因为在 64 位环境下指针变量的大小达到了 8 位足以容纳一些长度较小的内容。于是使用了标签指针这种方式来优化数据的存储方式。从他的引用计数可以看出，这货也是一个释放不掉的单例常量对象。在运行时根据实际情况创建。\n\n\t对于 `NSString` 对象来讲，当非字面值常量的数字，英文字母字符串的长度小于等于 9 的时候会自动成为 `NSTaggedPointerString` 类型，如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为 ）`__NSCFString` 类型。\n\n\t这种对象被直接存储在指针的内容中，可以当作一种伪对象。\n    \n    当字符串的长度为10个以内时，字符串的类型都是`NSTaggedPointerString`类型，当超过10个时，字符串的类型才是`__NSCFString`\n    \n- 从`NSTaggedPointerString`中读取出字符串的值\n\n```c\n#   define _OBJC_TAG_MASK (1UL<<63)\n#   define _OBJC_TAG_INDEX_SHIFT 0\n#   define _OBJC_TAG_SLOT_SHIFT 0\n#   define _OBJC_TAG_PAYLOAD_LSHIFT 1\n#   define _OBJC_TAG_PAYLOAD_RSHIFT 4\n#   define _OBJC_TAG_EXT_INDEX_SHIFT 55\n#   define _OBJC_TAG_EXT_SLOT_SHIFT 55\n#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 9\n#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12\n\nstatic inline bool _objc_isTaggedPointer(const void * _Nullable ptr)\n{\n    return ((uintptr_t)ptr & _OBJC_TAG_MASK) == _OBJC_TAG_MASK;\n}\n\nstatic inline uintptr_t _objc_decodeTaggedPointer(const void * _Nullable ptr)\n{\n    return (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator;\n}\n\nstatic inline uintptr_t _objc_getTaggedPointerValue(const void * _Nullable ptr) \n{\n    // assert(_objc_isTaggedPointer(ptr));\n    uintptr_t value = _objc_decodeTaggedPointer(ptr);\n    uintptr_t basicTag = (value >> _OBJC_TAG_INDEX_SHIFT) & _OBJC_TAG_INDEX_MASK;\n    if (basicTag == _OBJC_TAG_INDEX_MASK) {\n        return (value << _OBJC_TAG_EXT_PAYLOAD_LSHIFT) >> _OBJC_TAG_EXT_PAYLOAD_RSHIFT;\n    } else {\n        return (value << _OBJC_TAG_PAYLOAD_LSHIFT) >> _OBJC_TAG_PAYLOAD_RSHIFT;\n    }\n}\n\nstatic inline intptr_t _objc_getTaggedPointerSignedValue(const void * _Nullable ptr) \n{\n    // assert(_objc_isTaggedPointer(ptr));\n    uintptr_t value = _objc_decodeTaggedPointer(ptr);\n    uintptr_t basicTag = (value >> _OBJC_TAG_INDEX_SHIFT) & _OBJC_TAG_INDEX_MASK;\n    if (basicTag == _OBJC_TAG_INDEX_MASK) {\n        return ((intptr_t)value << _OBJC_TAG_EXT_PAYLOAD_LSHIFT) >> _OBJC_TAG_EXT_PAYLOAD_RSHIFT;\n    } else {\n        return ((intptr_t)value << _OBJC_TAG_PAYLOAD_LSHIFT) >> _OBJC_TAG_PAYLOAD_RSHIFT;\n    }\n}\n```\n\n### NSNumber\n\n```objectivec\nNSNumber *number1 = @(0x1);\nNSNumber *number2 = @(0x20);\nNSNumber *number3 = @(0x3F);\nNSNumber *numberFFFF = @(0xFFFFFFFFFFEFE);\nNSNumber *maxNum = @(MAXFLOAT);\nNSLog(@\"number1 pointer is %p class is %@\", number1, number1.class);\nNSLog(@\"number2 pointer is %p class is %@\", number2, number2.class);\nNSLog(@\"number3 pointer is %p class is %@\", number3, number3.class);\nNSLog(@\"numberffff pointer is %p class is %@\", numberFFFF, numberFFFF.class);\nNSLog(@\"maxNum pointer is %p class is %@\", maxNum, maxNum.class);\n\n```\n\n```objectivec\nTaggedPointerDemo[59218:2167895] number1 pointer is 0xf7cb914ffb51479a class is __NSCFNumber\nTaggedPointerDemo[59218:2167895] number2 pointer is 0xf7cb914ffb51458a class is __NSCFNumber\nTaggedPointerDemo[59218:2167895] number3 pointer is 0xf7cb914ffb51447a class is __NSCFNumber\nTaggedPointerDemo[59218:2167895] numberffff pointer is 0xf7346eb004aea86b class is __NSCFNumber\nTaggedPointerDemo[59218:2167895] maxNum pointer is 0x28172a0c0 class is __NSCFNumber\n```\n\n我们发现对于`NSNumber`，我们打印出来的数据类型均为`__NSCFNumber`,但是我们发现对于MAXFLOAT打印出的地址显然与其他几项不符，上面几个`NSNumber`的地址以0xf开头，根据字符串地址的经验我们可以看出`f = 1111`,首位标记位为1，表示这个数据类型属于`TaggedPointer`。而`MAXFLOAT`不是。\n\n    \n## MRC\n\n- 在iOS中，使用`引用计数`来管理OC对象的内存\n- 一个新创建的OC对象的引用计数默认是1，当引用计数减为0，OC对象就会销毁，释放其占用的内存空间\n- 调用retain会让OC对象的引用计数+1，调用release会让OC对象的引用计数-1\n\n- 内存管理的经验总结：\n\t- 当调用`alloc`、`new`、`copy`、`mutableCopy`方法返回了一个对象，在不需要这个对象时，要调用`release`或者`autorelease`释放它\n    - 想拥有某个对象，就让它的引用计数+1;不想再拥有某个对象，就让它的引用计数-1\n    \n- 可以通过以下私有函数来查看自动释放池的情况\n\n\t`extern void _objc_autoreleasePoolPrint(void); `\n\n在ARC中声明`@property(nonatomic,assign) int age;` 其set方法相当于MRC中的\n\n```objectivec\n- (void)setAge:(int)age {\n    _age = age;\n}\n```\n\n在ARC中声明`@property(nonatomic,strong) NSObject *age;` 其set方法相当于MRC中的\n\n```objectivec\n- (void)setAge:(NSObject *)age {\n    if (_age != age) { // 防止同个对象释放后引用计数变成0，就不能再retain了\n        [_age release]; // 防止新对象进来之后，旧对象的引用计数多出了1导致释放不掉\n        _age = [age reatin]; // 引用计数+1，防止被外部一不小心释放了\n    }\n}\n```\n\n- 关于Autorelease\n\n  ```\t\n  self.data = [NSMutableArray array]; // 自动进行了autorelease\n  ```\n  等同于\n  ```\n  self.data = [[[NSMutableArray alloc] init] autorelease];\n  ```\n  等同于\n  ```\n  self.data = [[NSMutableArray alloc] init];\n  [self.data release];\n  ```\n  等同于\n  ```\n  NSMutableArray *data = [[NSMutableArray alloc] init];\n  self.data = data;\n  [data release];\n  ```\n  \n## 引用计数的存储\n\n在64bit中，引用计数可以直接存储在优化过的isa指针中，如果isa指针不够存的话就存储在`SiteTable`类中（最终的引用计数是两个存储的地方都会取出来值，然后求和）\n\n```c\nstruct SideTable {\n    spinlock_t slock;\n    RefcountMap refcnts;\n    weak_table_t weak_table;\n};\n```\n\n- refcnts是一个存放着对象引用计数的散列表\n\n在SiteTable中获取到`retainCount`的核心代码如下\n\n```c\nsize_t objc_object::sidetable_getExtraRC_nolock()\n{\n    ASSERT(isa.nonpointer);\n    SideTable& table = SideTables()[this];\n    RefcountMap::iterator it = table.refcnts.find(this); \n    if (it == table.refcnts.end()) return 0; // 遍历refcnts\n    else return it->second >> SIDE_TABLE_RC_SHIFT; // 进行位运算取出retainCount\n}\n```\n  \n## Weak\n\n weak指针能够在对象释放的时候把指针清空，具体是怎么做到的。我们需要看一下对象`dealloc`的过程\n \n ```c\ninline void objc_object::rootDealloc()\n{\n    if (isTaggedPointer()) return;  // fixme necessary?\n\n    if (fastpath(isa.nonpointer                     && // 0代表普通的指针，1代表优化过的指针，使用位域存储信息\n                 !isa.weakly_referenced             && // 是否有弱引用指针\n                 !isa.has_assoc                     && // 是否有设置关联对象\n                 !isa.has_cxx_dtor                  && // 是否有C++即构函数\n                 !isa.has_sidetable_rc))\t\t\t   // 引用计数器是不是过大而无法存放在isa中，如果为1，那引用计数会存储在SideTable的类的属性中\n    {\n        assert(!sidetable_present());\n        free(this);\n    } \n    else {\n        object_dispose((id)this); // 显然弱引用指针指向的对象会进入这里\n    }\n}\n ```\n \n ```c\nid  object_dispose(id obj) {\n    if (!obj) return nil;\n\n    objc_destructInstance(obj); // 释放前做一些事情\n    free(obj); // 这里才释放\n\n    return nil;\n }\n ```\n \n ```c\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        // Read all of the flags at once for performance.\n        bool cxx = obj->hasCxxDtor();\n        bool assoc = obj->hasAssociatedObjects();\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj); // 清除成员变量\n        if (assoc) _object_remove_assocations(obj, /*deallocating*/true); // 移除关联对象\n        obj->clearDeallocating(); // 将指向当前对象的弱指针置为nil\n    }\n\n    return obj;\n}\n ```\n \n ```c\ninline void objc_object::clearDeallocating()\n{\n    if (slowpath(!isa.nonpointer)) {\n        // Slow path for raw pointer isa.\n        sidetable_clearDeallocating();\n    }\n    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) {\n        // Slow path for non-pointer isa with weak refs and/or side table data.\n        clearDeallocating_slow(); // 再进入这里\n    }\n    assert(!sidetable_present());\n}\n ```\n \n \n ```c\n NEVER_INLINE void objc_object::clearDeallocating_slow()\n{\n    ASSERT(isa.nonpointer  &&  (isa.weakly_referenced || isa.has_sidetable_rc));\n\n    SideTable& table = SideTables()[this]; // 拿出SiteTables数组，然后取出对应的SiteTable对象\n    table.lock();\n    if (isa.weakly_referenced) {\n        weak_clear_no_lock(&table.weak_table, (id)this); // 清除弱引用指针 \n    }\n    if (isa.has_sidetable_rc) {\n        table.refcnts.erase(this); // 清除引用计数表\n    }\n    table.unlock();\n}\n```\n\n```c\nvoid  weak_clear_no_lock(weak_table_t *weak_table, id referent_id) \n{\n    objc_object *referent = (objc_object *)referent_id;\n\n\t/// 把SiteTable里面的weakTable和指针传进去\n    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);\n    if (entry == nil) {\n        /// XXX shouldn't happen, but does with mismatched CF/objc\n        //printf(\"XXX no entry for clear deallocating %p\\n\", referent);\n        return;\n    }\n\n    // zero out references\n    weak_referrer_t *referrers;\n    size_t count;\n    \n    if (entry->out_of_line()) {\n        referrers = entry->referrers;\n        count = TABLE_SIZE(entry);\n    } \n    else {\n        referrers = entry->inline_referrers;\n        count = WEAK_INLINE_COUNT;\n    }\n    \n    for (size_t i = 0; i < count; ++i) {\n        objc_object **referrer = referrers[i];\n        if (referrer) {\n            if (*referrer == referent) {\n                *referrer = nil;\n            }\n            else if (*referrer) {\n                _objc_inform(\"__weak variable at %p holds %p instead of %p. \"\n                             \"This is probably incorrect use of \"\n                             \"objc_storeWeak() and objc_loadWeak(). \"\n                             \"Break on objc_weak_error to debug.\\n\", \n                             referrer, (void*)*referrer, (void*)referent);\n                objc_weak_error();\n            }\n        }\n    }\n    \n    weak_entry_remove(weak_table, entry);\n}\n```\n\n```c\nstatic inline uintptr_t hash_pointer(objc_object *key) {\n    return ptr_hash((uintptr_t)key);\n}\n\nstatic weak_entry_t * weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)\n{\n    ASSERT(referent);\n\n    weak_entry_t *weak_entries = weak_table->weak_entries;\n\n    if (!weak_entries) return nil;\n\n\t/// 通过与运算得到索引\n    size_t begin = hash_pointer(referent) & weak_table->mask;\n    size_t index = begin;\n    size_t hash_displacement = 0;\n    while (weak_table->weak_entries[index].referent != referent) {\n        index = (index+1) & weak_table->mask;\n        if (index == begin) bad_weak_table(weak_table->weak_entries);\n        hash_displacement++;\n        if (hash_displacement > weak_table->max_hash_displacement) {\n            return nil;\n        }\n    }\n    \n    return &weak_table->weak_entries[index];\n}\n```\n\n总结：\n\nWeak指针指向的对象释放流程如下\n\n1. 清除成员变量，移除关联对象\n2. 拿到对象对应的SiteTable，再取出里面的weak_table\n3. 通过hash后的对象的指针和weak_table进行一次与运算，得到索引，在weak_table中通过索引取出弱引用指针\n4. 置空取出的所有的弱引用指针\n5. 清除引用计数表\n6. 释放对象\n\n## Copy和MutableCopy\n\n拷贝的目的：产生一个副本对象，跟源对象互不影响\n修改了源对象，不会影响副本对象\n修改了副本对象，不会影响源对象\n\niOS提供了2个拷贝方法\n1. copy ，不可变拷贝，产生不可变副本。\n2. mutableCopy，可变拷贝，产生可变副本。\n3. 浅拷贝：指针拷贝，没有产生新的对象。（不可变对象copy）\n4. 深拷贝：内容拷贝，产生新的对象。(可变、不可变对象调用mutableCopy或者可变对象调用copy)\n\n```objectivec\nNSString *str1 = [NSString stringWithFormat:@\"test\"];\nNSString *str2 = [str1 copy]; // 返回的是NSString\nNSMutableString *str3 = [str1 mutableCopy]; // 返回的是NSMutableString\n```\n\n当`copy`方法被不可变对象调用的话，不会发生什么变化，直接还是返回原来的对象，但是这时候引用计数会加1，相当于`retain`了一下，所以上面的代码要释放对象的时候，除了调用`[str1 release];`，那么还得调用`[str2 release]；`\n\n在ARC中声明`@property(nonatomic,copy) NSString *age;` 其set方法相当于MRC中的\n\n```objectivec\n- (void)setAge:(NSString *)age {\n    if (_age != age) {\n        [_age release];\n        _age = [age copy];\n    }\n}\n```\n\n## AutoRelease\n\n```objectivec\n@autoreleasepool {\n    Student *student = [[[Student alloc] init] autorelease];\n}\n```\n\n```c\nstruct __AtAutoreleasePool {\n  __AtAutoreleasePool() { // 构造函数\n      atautoreleasepoolobj = objc_autoreleasePoolPush();\n  }\n  ~__AtAutoreleasePool() { // 析构函数\n      objc_autoreleasePoolPop(atautoreleasepoolobj);\n  }\n  void * atautoreleasepoolobj;\n};\n```\n\n```c\n{ \n    __AtAutoreleasePool __autoreleasepool; // 创建一个结构体变量\n    Student *student = objc_msgSend(objc_msgSend(objc_msgSend(objc_getClass(\"Student\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")), sel_registerName(\"autorelease\"));\n}\n```\n\n相当于\n\n\n```objectivec\n{ \n    atautoreleasepoolobj = objc_autoreleasePoolPush();\n    Student *student = objc_msgSend(objc_msgSend(objc_msgSend(objc_getClass(\"Student\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")), sel_registerName(\"autorelease\"));\n    objc_autoreleasePoolPop(atautoreleasepoolobj);\n}\n```\n\n自动释放池的主要底层数据结构是: `__AtAutoreleasePool`、`AutoreleasePoolPage`\n\n调用了`autorelease`的对象最终都是通过`AutoreleasePoolPage`对象来管的\n\n\n源码分析\n\t- clang重写@autoreleasepool\n    - objc4源码：NSobject.mm\n\n## AutoreleasePoolPage的结构\n\n```c\nclass AutoreleasePage\n{\n    magic_t const magic;\n    id *next;\n    pthread_t const thread;\n    AutoreleasePoolPage *const parent;\n    AutoreleasePoolPage *const child;\n    uint32_t depth;\n    uint32_t hiwat;\n}\n```\n\n- 每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放`autorelease`对象的地址\n- 所有的`AutoreleasePoolPage`对象通过双向链表的形式连接在一起\n\n- 调用push方法会将一个POOL_BOUNDARY入栈，并且返回其存放的内存地址\n- 调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送release对象，直到遇到这个POOL_BOUNDARY\n\n- `id *next`指向了下一个能存放`autorelease`对象地址的区域\n\n```c\nstatic inline void *push()  {\n    id *dest;\n    if (slowpath(DebugPoolAllocation)) {\n        // Each autorelease pool starts on a new pool page.\n        dest = autoreleaseNewPage(POOL_BOUNDARY);\n    } else {\n        dest = autoreleaseFast(POOL_BOUNDARY);\n    }\n    ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);\n    return dest;\n}\n```\n\n```c\nstatic inline void pop(void *token) {\n    AutoreleasePoolPage *page;\n    id *stop;\n    if (token == (void*)EMPTY_POOL_PLACEHOLDER) {\n        // Popping the top-level placeholder pool.\n        page = hotPage();\n        if (!page) {\n            // Pool was never used. Clear the placeholder.\n            return setHotPage(nil);\n        }\n        // Pool was used. Pop its contents normally.\n        // Pool pages remain allocated for re-use as usual.\n        page = coldPage();\n        token = page->begin();\n    } else {\n        page = pageForPointer(token);\n    }\n\n    stop = (id *)token;\n    if (*stop != POOL_BOUNDARY) {\n        if (stop == page->begin()  &&  !page->parent) {\n            // Start of coldest page may correctly not be POOL_BOUNDARY:\n            // 1. top-level pool is popped, leaving the cold page in place\n            // 2. an object is autoreleased with no pool\n        } else {\n            // Error. For bincompat purposes this is not \n            // fatal in executables built with old SDKs.\n            return badPop(token);\n        }\n    }\n\n    if (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) {\n        return popPageDebug(token, page, stop);\n    }\n\n    return popPage<false>(token, page, stop);\n}\n```\n\n### Runloop和Autorelease\n\n- iOS在主线程的Runloop中注册了两个Observer\n- 第1个Observer监听了`kCFRunLoopEntry`事件，会调用`objc_autoreleasePoolPush()`\n- 第2个Observer\n\t- 监听了`kCFRunLoopBeforeWaiting`会调用`objc_autoreleasePoolPop()`、`objc_autoreleasePoolPush()`\n\t- 监听了`kCFRunloopBeforeExit`事件，会调用`objc_autoreleasePoolPop()`","source":"_posts/iOS-底层原理-内存管理.md","raw":"title: iOS 底层原理 --- 内存管理\nauthor: Arclin\ntags:\n  - iOS\n  - 底层原理\ncategories:\n  - iOS\nabbrlink: 56d1bd42\ndate: 2021-09-03 17:26:00\n---\n本文主要介绍iOS中内存管理的一些事情\n\n<!--more-->\n\n## 定时器\n\n### CADisplayLink、NSTimer\n\n`CADisplayLink`、`NSTimer`会对`target`产生强引用，如果`target`又对它们产生强引用，那么就会引发循环引用\n\n比如：\n\n```\n@property (strong) NSTimer *timer;\nself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTimer) userInfo:nil repeats:YES];\n```\n\n在这里，`self`强持有了`timer`，`timer`强持有了`self`，造成了循环引用\n\n#### 利用block解决\n\n针对`NSTimer`我们可以有另外的解决办法：\n\n```objectivec\n__weak typeof(self) weakself = self;\nself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) {\n    [weakself timerTest];\n]};\n```\n\n让`timer`强持有block，block弱持有`self`，这样子`self`就是间接被弱持有，打破了循环引用。\n\n#### 利用NSProxy解决\n\n新建一个类继承自`NSProxy`\n\n```objectivec\n@interface MyProxy : NSProxy\n\n+ (instancetype)proxyWithTarget:(id)target;\n\n@end\n\n```\n\n```objectivec\n@interface MyProxy()\n\n@property (nonatomic, weak) id target;\n\n@end\n\n@implementation MyProxy\n\n+ (instancetype)proxyWithTarget:(id)target {\n    // NSProxy对象不需要调用init，因为它没有init方法\n    MyProxy *proxy = [MyProxy alloc];\n    proxy.target = target;\n    return proxy;\n}\n\n/// 实现消息转发的两个方法，一定要实现，不然会报方法找不到的错误\n\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel {\n    return [self.target methodSignatureForSelector:sel];\n}\n\n- (void)forwardInvocation:(NSInvocation *)invocation {\n    [invocation invokeWithTarget:self.target];\n}\n\n@end\n```\n\n使用\n\n```objectivec\nself.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[MyProxy proxyWithTarget:self] selector:@selector(test) userInfo:nil repeats:YES];\n\n```\n\n原理很简单，就是把`self`让`proxy`弱持有，`timer`强持有`proxy`，这样子就能够做到间接弱持有`self`，打破循环引用\n\n为了让`timer`调用`selector`的时候能调回到`self`的方法，在`proxy`内部我们使用消息转发机制，把消息转发到`target`（也就是`self`）中，实现调用。\n\n至于消息转发机制的另一个方法`-forwardingTargetForSelector:`之所以不能使用，是因为`NSProxy`不提供。\n\n实际上我们如果不继承自`NSProxy`，直接继承自`NSObject`也是能完成上述操作的，但是使用`NSProxy`的话可以跳过消息发送和动态方法解析阶段，直接进入消息转发阶段，效率比较高\n\n> 注意： `NSProxy`对象如果调用`isKindOfClass:`或其他方法，那么由于它直接进入了消息转发阶段，所以会直接拿`target`属性去调用方法，所以都跟`NSProxy`对象本身没有关系\n\n\n### GCD定时器\n\n- `NSTimer`依赖`RunLoop`，如果`Runloop`的任务过于繁重，可能会导致`NSTimer`不准时\n\t- 因为Runloop每次循环的时间是不定的，所以下次循环的时候到达处理定时器那个环节，不一定跟上次刚好相差我们所指定时间，所以就会不准\n    \n- GCD的定时器会更加准时\n\n```objectivec\n// 队列\ndispatch_queue_t queue = dispatch_get_main_queue();\n\n// 创建定时器\ndispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n\n// 设置时间\nNSTimeInterval start = 2.0; // 2秒后开始执行\nNSTimeInterval interval = 1.0; // 每1秒执行一次\ndispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * NSEC_PER_SEC), interval * NSEC_PER_SEC, 0);\n\n// 设置回调\ndispatch_source_set_event_handler(timer, ^{\n    NSLog(@\"11111\");\n});\n\n// 启动定时器\ndispatch_resume(timer);\n\n// 取消定时器\n// dispatch_source_cancel(timer);\n\nself.timer = timer;\n```\n\n由于GCD的定时器跟`Runloop`没有关系，所以滚动视图也不会影响GCD定时器的执行\n\n除了使用block回调，我们也可以写一个C函数作为回调函数\n\n```c\ndispatch_source_set_event_handler_f(timer, timerFire);\n```\n\n```c\nvoid timerFire(void *param) {\n    NSLog(@\"%@ %@\",param,[NSThread currentThread]);\n}\n```\n\n## 内存布局\n\n- 内存布局从低地址到高地址排序如下\n  1. 保留\n  2. 代码段（__TEXT）\n  3. 数据段（__DATA）：字符串常量， 已初始化数据，未初始化数据\n  4. 堆（heap）\n  5. 栈（stack）\n  6. 内核区\n  \n- 代码段：编译之后的代码\n- 数据段：\n\t- 字符串常量\n    - 已初始化数据：已初始化的全局变量、静态变量等\n    - 未初始化数据：未初始化的全局变量、静态变量等\n- 堆：通过alloc、malloc、calloc的那个动态分配的空间，分配的内存空间地址越来越大\n- 栈：函数调用开销，比如局部变量，分配的内存空间地址越来越小\n\n\n## Tagged Pointer\n\n- 从64bit开始，iOS引入了Tagged Pointer技术，用于优化`NSNumber`,`NSDate`，`NSString`等小对象的存储\n\n- 在没有使用Tagged Pointer之前，`NSNumber`等对象需要动态分配内存，维护引用计数的等，`NSNumber`指针存储的是堆中`NSNumber`对象的地址值.\n\n- 使用`Tagged Pointer`之后，`NSNumber`指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中。\n\n- 在Mac环境下当对象指针的二进制最低有效位是1，则该指针为`Tagged Pointer`（如果是0那么就是OC对象，因为OC对象分配内存是按照16个字节对齐的，所以最后一位肯定是0）,可以编写如下函数来判断是否是`Tagged Pointer`\n\n\t- 跟1进行与运算，取出最低位判断是不是1即可\n\n  ```c\n  BOOL isTaggedPointer(id pointer) {\n      return (long)(__bridge void *)pointer & 1;\n  }\n  ```\n  - 如果是iOS环境下，则判断的是最高有效位(第64位)是否是1，即`(long)(__bridge void *)pointer & 1UL<<63`\n\n- 当指针不够存储数据时，才会使用动态分配内存来存储数据（比如NSNumber的存储的数字太大了，指针8个十六进制位都装不下）\n\n- `objc_msgSend`能识别`Tagged Pointer`，比如`NSNumber`的intValue方法，直接从指针提取数据，节省了以前的调用开销\n\n### 字符串\n\n```\n@property(copy, nonatomic) NSString *name;\n```\n\n这个属性的set方法实际为\n\n```\n- (void)setName:(NSString *)name {\n    if(_name != name) {\n        [_name release];\n        _name = [name retain];\n    }\n}\n```\n\n假如我们这么给`name`赋值`self.name = [NSString stringWithForamt:@\"abcdefghijkl\"]`，因为这个太大了，转不成`tagged pointer`，那么在多线程环境下，有可能会因为多次执行了`[_name release]`导致坏内存访问而崩溃\n\n字符串其实还有其他样子，总的来说，除了`__NSCFString`，其他类型的字符串都不会调用`release`方法\n\n- __NSCFConstantString\n\n\t字符串常量，是一种编译时常量，它的 retainCount 值很大，是 4294967295，在控制台打印出的数值则是 18446744073709551615==2^64-1，测试证明，即便对其进行 release 操作，retainCount 也不会产生任何变化。是创建之后便是放不掉的对象。**相同内容的 __NSCFConstantString 对象的地址相同，也就是说常量字符串对象是一种单例**。\n\n\t这种对象一般通过字面值 `@\"...\"`、`CFSTR(\"...\")` 或者 `stringWithString`: 方法（需要说明的是，这个方法在 iOS6 SDK 中已经被称为redundant，使用这个方法会产生一条编译器警告。这个方法等同于字面值创建的方法）产生。\n\n\t这种对象存储在字符串常量区。\n\n- __NSCFString\n\n\t和 `__NSCFConstantString` 不同， `__NSCFString`对象是在运行时创建的一种 `NSString`子类，他并不是一种字符串常量。所以和其他的对象一样在被创建时获得了 1 的引用计数。\n\n\t通过 NSString 的 stringWithFormat 等方法创建的 NSString 对象一般都是这种类型。\n\n\t这种对象被存储在堆上。\n\n- NSTaggedPointerString\n\n\t理解这个类型，需要明白什么是`TaggedPointer`，这是苹果在 64 位环境下对 NSString,NSNumber 等对象做的一些优化。简单来讲可以理解为把指针指向的内容直接放在了指针变量的内存地址中，因为在 64 位环境下指针变量的大小达到了 8 位足以容纳一些长度较小的内容。于是使用了标签指针这种方式来优化数据的存储方式。从他的引用计数可以看出，这货也是一个释放不掉的单例常量对象。在运行时根据实际情况创建。\n\n\t对于 `NSString` 对象来讲，当非字面值常量的数字，英文字母字符串的长度小于等于 9 的时候会自动成为 `NSTaggedPointerString` 类型，如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为 ）`__NSCFString` 类型。\n\n\t这种对象被直接存储在指针的内容中，可以当作一种伪对象。\n    \n    当字符串的长度为10个以内时，字符串的类型都是`NSTaggedPointerString`类型，当超过10个时，字符串的类型才是`__NSCFString`\n    \n- 从`NSTaggedPointerString`中读取出字符串的值\n\n```c\n#   define _OBJC_TAG_MASK (1UL<<63)\n#   define _OBJC_TAG_INDEX_SHIFT 0\n#   define _OBJC_TAG_SLOT_SHIFT 0\n#   define _OBJC_TAG_PAYLOAD_LSHIFT 1\n#   define _OBJC_TAG_PAYLOAD_RSHIFT 4\n#   define _OBJC_TAG_EXT_INDEX_SHIFT 55\n#   define _OBJC_TAG_EXT_SLOT_SHIFT 55\n#   define _OBJC_TAG_EXT_PAYLOAD_LSHIFT 9\n#   define _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12\n\nstatic inline bool _objc_isTaggedPointer(const void * _Nullable ptr)\n{\n    return ((uintptr_t)ptr & _OBJC_TAG_MASK) == _OBJC_TAG_MASK;\n}\n\nstatic inline uintptr_t _objc_decodeTaggedPointer(const void * _Nullable ptr)\n{\n    return (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator;\n}\n\nstatic inline uintptr_t _objc_getTaggedPointerValue(const void * _Nullable ptr) \n{\n    // assert(_objc_isTaggedPointer(ptr));\n    uintptr_t value = _objc_decodeTaggedPointer(ptr);\n    uintptr_t basicTag = (value >> _OBJC_TAG_INDEX_SHIFT) & _OBJC_TAG_INDEX_MASK;\n    if (basicTag == _OBJC_TAG_INDEX_MASK) {\n        return (value << _OBJC_TAG_EXT_PAYLOAD_LSHIFT) >> _OBJC_TAG_EXT_PAYLOAD_RSHIFT;\n    } else {\n        return (value << _OBJC_TAG_PAYLOAD_LSHIFT) >> _OBJC_TAG_PAYLOAD_RSHIFT;\n    }\n}\n\nstatic inline intptr_t _objc_getTaggedPointerSignedValue(const void * _Nullable ptr) \n{\n    // assert(_objc_isTaggedPointer(ptr));\n    uintptr_t value = _objc_decodeTaggedPointer(ptr);\n    uintptr_t basicTag = (value >> _OBJC_TAG_INDEX_SHIFT) & _OBJC_TAG_INDEX_MASK;\n    if (basicTag == _OBJC_TAG_INDEX_MASK) {\n        return ((intptr_t)value << _OBJC_TAG_EXT_PAYLOAD_LSHIFT) >> _OBJC_TAG_EXT_PAYLOAD_RSHIFT;\n    } else {\n        return ((intptr_t)value << _OBJC_TAG_PAYLOAD_LSHIFT) >> _OBJC_TAG_PAYLOAD_RSHIFT;\n    }\n}\n```\n\n### NSNumber\n\n```objectivec\nNSNumber *number1 = @(0x1);\nNSNumber *number2 = @(0x20);\nNSNumber *number3 = @(0x3F);\nNSNumber *numberFFFF = @(0xFFFFFFFFFFEFE);\nNSNumber *maxNum = @(MAXFLOAT);\nNSLog(@\"number1 pointer is %p class is %@\", number1, number1.class);\nNSLog(@\"number2 pointer is %p class is %@\", number2, number2.class);\nNSLog(@\"number3 pointer is %p class is %@\", number3, number3.class);\nNSLog(@\"numberffff pointer is %p class is %@\", numberFFFF, numberFFFF.class);\nNSLog(@\"maxNum pointer is %p class is %@\", maxNum, maxNum.class);\n\n```\n\n```objectivec\nTaggedPointerDemo[59218:2167895] number1 pointer is 0xf7cb914ffb51479a class is __NSCFNumber\nTaggedPointerDemo[59218:2167895] number2 pointer is 0xf7cb914ffb51458a class is __NSCFNumber\nTaggedPointerDemo[59218:2167895] number3 pointer is 0xf7cb914ffb51447a class is __NSCFNumber\nTaggedPointerDemo[59218:2167895] numberffff pointer is 0xf7346eb004aea86b class is __NSCFNumber\nTaggedPointerDemo[59218:2167895] maxNum pointer is 0x28172a0c0 class is __NSCFNumber\n```\n\n我们发现对于`NSNumber`，我们打印出来的数据类型均为`__NSCFNumber`,但是我们发现对于MAXFLOAT打印出的地址显然与其他几项不符，上面几个`NSNumber`的地址以0xf开头，根据字符串地址的经验我们可以看出`f = 1111`,首位标记位为1，表示这个数据类型属于`TaggedPointer`。而`MAXFLOAT`不是。\n\n    \n## MRC\n\n- 在iOS中，使用`引用计数`来管理OC对象的内存\n- 一个新创建的OC对象的引用计数默认是1，当引用计数减为0，OC对象就会销毁，释放其占用的内存空间\n- 调用retain会让OC对象的引用计数+1，调用release会让OC对象的引用计数-1\n\n- 内存管理的经验总结：\n\t- 当调用`alloc`、`new`、`copy`、`mutableCopy`方法返回了一个对象，在不需要这个对象时，要调用`release`或者`autorelease`释放它\n    - 想拥有某个对象，就让它的引用计数+1;不想再拥有某个对象，就让它的引用计数-1\n    \n- 可以通过以下私有函数来查看自动释放池的情况\n\n\t`extern void _objc_autoreleasePoolPrint(void); `\n\n在ARC中声明`@property(nonatomic,assign) int age;` 其set方法相当于MRC中的\n\n```objectivec\n- (void)setAge:(int)age {\n    _age = age;\n}\n```\n\n在ARC中声明`@property(nonatomic,strong) NSObject *age;` 其set方法相当于MRC中的\n\n```objectivec\n- (void)setAge:(NSObject *)age {\n    if (_age != age) { // 防止同个对象释放后引用计数变成0，就不能再retain了\n        [_age release]; // 防止新对象进来之后，旧对象的引用计数多出了1导致释放不掉\n        _age = [age reatin]; // 引用计数+1，防止被外部一不小心释放了\n    }\n}\n```\n\n- 关于Autorelease\n\n  ```\t\n  self.data = [NSMutableArray array]; // 自动进行了autorelease\n  ```\n  等同于\n  ```\n  self.data = [[[NSMutableArray alloc] init] autorelease];\n  ```\n  等同于\n  ```\n  self.data = [[NSMutableArray alloc] init];\n  [self.data release];\n  ```\n  等同于\n  ```\n  NSMutableArray *data = [[NSMutableArray alloc] init];\n  self.data = data;\n  [data release];\n  ```\n  \n## 引用计数的存储\n\n在64bit中，引用计数可以直接存储在优化过的isa指针中，如果isa指针不够存的话就存储在`SiteTable`类中（最终的引用计数是两个存储的地方都会取出来值，然后求和）\n\n```c\nstruct SideTable {\n    spinlock_t slock;\n    RefcountMap refcnts;\n    weak_table_t weak_table;\n};\n```\n\n- refcnts是一个存放着对象引用计数的散列表\n\n在SiteTable中获取到`retainCount`的核心代码如下\n\n```c\nsize_t objc_object::sidetable_getExtraRC_nolock()\n{\n    ASSERT(isa.nonpointer);\n    SideTable& table = SideTables()[this];\n    RefcountMap::iterator it = table.refcnts.find(this); \n    if (it == table.refcnts.end()) return 0; // 遍历refcnts\n    else return it->second >> SIDE_TABLE_RC_SHIFT; // 进行位运算取出retainCount\n}\n```\n  \n## Weak\n\n weak指针能够在对象释放的时候把指针清空，具体是怎么做到的。我们需要看一下对象`dealloc`的过程\n \n ```c\ninline void objc_object::rootDealloc()\n{\n    if (isTaggedPointer()) return;  // fixme necessary?\n\n    if (fastpath(isa.nonpointer                     && // 0代表普通的指针，1代表优化过的指针，使用位域存储信息\n                 !isa.weakly_referenced             && // 是否有弱引用指针\n                 !isa.has_assoc                     && // 是否有设置关联对象\n                 !isa.has_cxx_dtor                  && // 是否有C++即构函数\n                 !isa.has_sidetable_rc))\t\t\t   // 引用计数器是不是过大而无法存放在isa中，如果为1，那引用计数会存储在SideTable的类的属性中\n    {\n        assert(!sidetable_present());\n        free(this);\n    } \n    else {\n        object_dispose((id)this); // 显然弱引用指针指向的对象会进入这里\n    }\n}\n ```\n \n ```c\nid  object_dispose(id obj) {\n    if (!obj) return nil;\n\n    objc_destructInstance(obj); // 释放前做一些事情\n    free(obj); // 这里才释放\n\n    return nil;\n }\n ```\n \n ```c\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        // Read all of the flags at once for performance.\n        bool cxx = obj->hasCxxDtor();\n        bool assoc = obj->hasAssociatedObjects();\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj); // 清除成员变量\n        if (assoc) _object_remove_assocations(obj, /*deallocating*/true); // 移除关联对象\n        obj->clearDeallocating(); // 将指向当前对象的弱指针置为nil\n    }\n\n    return obj;\n}\n ```\n \n ```c\ninline void objc_object::clearDeallocating()\n{\n    if (slowpath(!isa.nonpointer)) {\n        // Slow path for raw pointer isa.\n        sidetable_clearDeallocating();\n    }\n    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) {\n        // Slow path for non-pointer isa with weak refs and/or side table data.\n        clearDeallocating_slow(); // 再进入这里\n    }\n    assert(!sidetable_present());\n}\n ```\n \n \n ```c\n NEVER_INLINE void objc_object::clearDeallocating_slow()\n{\n    ASSERT(isa.nonpointer  &&  (isa.weakly_referenced || isa.has_sidetable_rc));\n\n    SideTable& table = SideTables()[this]; // 拿出SiteTables数组，然后取出对应的SiteTable对象\n    table.lock();\n    if (isa.weakly_referenced) {\n        weak_clear_no_lock(&table.weak_table, (id)this); // 清除弱引用指针 \n    }\n    if (isa.has_sidetable_rc) {\n        table.refcnts.erase(this); // 清除引用计数表\n    }\n    table.unlock();\n}\n```\n\n```c\nvoid  weak_clear_no_lock(weak_table_t *weak_table, id referent_id) \n{\n    objc_object *referent = (objc_object *)referent_id;\n\n\t/// 把SiteTable里面的weakTable和指针传进去\n    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);\n    if (entry == nil) {\n        /// XXX shouldn't happen, but does with mismatched CF/objc\n        //printf(\"XXX no entry for clear deallocating %p\\n\", referent);\n        return;\n    }\n\n    // zero out references\n    weak_referrer_t *referrers;\n    size_t count;\n    \n    if (entry->out_of_line()) {\n        referrers = entry->referrers;\n        count = TABLE_SIZE(entry);\n    } \n    else {\n        referrers = entry->inline_referrers;\n        count = WEAK_INLINE_COUNT;\n    }\n    \n    for (size_t i = 0; i < count; ++i) {\n        objc_object **referrer = referrers[i];\n        if (referrer) {\n            if (*referrer == referent) {\n                *referrer = nil;\n            }\n            else if (*referrer) {\n                _objc_inform(\"__weak variable at %p holds %p instead of %p. \"\n                             \"This is probably incorrect use of \"\n                             \"objc_storeWeak() and objc_loadWeak(). \"\n                             \"Break on objc_weak_error to debug.\\n\", \n                             referrer, (void*)*referrer, (void*)referent);\n                objc_weak_error();\n            }\n        }\n    }\n    \n    weak_entry_remove(weak_table, entry);\n}\n```\n\n```c\nstatic inline uintptr_t hash_pointer(objc_object *key) {\n    return ptr_hash((uintptr_t)key);\n}\n\nstatic weak_entry_t * weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)\n{\n    ASSERT(referent);\n\n    weak_entry_t *weak_entries = weak_table->weak_entries;\n\n    if (!weak_entries) return nil;\n\n\t/// 通过与运算得到索引\n    size_t begin = hash_pointer(referent) & weak_table->mask;\n    size_t index = begin;\n    size_t hash_displacement = 0;\n    while (weak_table->weak_entries[index].referent != referent) {\n        index = (index+1) & weak_table->mask;\n        if (index == begin) bad_weak_table(weak_table->weak_entries);\n        hash_displacement++;\n        if (hash_displacement > weak_table->max_hash_displacement) {\n            return nil;\n        }\n    }\n    \n    return &weak_table->weak_entries[index];\n}\n```\n\n总结：\n\nWeak指针指向的对象释放流程如下\n\n1. 清除成员变量，移除关联对象\n2. 拿到对象对应的SiteTable，再取出里面的weak_table\n3. 通过hash后的对象的指针和weak_table进行一次与运算，得到索引，在weak_table中通过索引取出弱引用指针\n4. 置空取出的所有的弱引用指针\n5. 清除引用计数表\n6. 释放对象\n\n## Copy和MutableCopy\n\n拷贝的目的：产生一个副本对象，跟源对象互不影响\n修改了源对象，不会影响副本对象\n修改了副本对象，不会影响源对象\n\niOS提供了2个拷贝方法\n1. copy ，不可变拷贝，产生不可变副本。\n2. mutableCopy，可变拷贝，产生可变副本。\n3. 浅拷贝：指针拷贝，没有产生新的对象。（不可变对象copy）\n4. 深拷贝：内容拷贝，产生新的对象。(可变、不可变对象调用mutableCopy或者可变对象调用copy)\n\n```objectivec\nNSString *str1 = [NSString stringWithFormat:@\"test\"];\nNSString *str2 = [str1 copy]; // 返回的是NSString\nNSMutableString *str3 = [str1 mutableCopy]; // 返回的是NSMutableString\n```\n\n当`copy`方法被不可变对象调用的话，不会发生什么变化，直接还是返回原来的对象，但是这时候引用计数会加1，相当于`retain`了一下，所以上面的代码要释放对象的时候，除了调用`[str1 release];`，那么还得调用`[str2 release]；`\n\n在ARC中声明`@property(nonatomic,copy) NSString *age;` 其set方法相当于MRC中的\n\n```objectivec\n- (void)setAge:(NSString *)age {\n    if (_age != age) {\n        [_age release];\n        _age = [age copy];\n    }\n}\n```\n\n## AutoRelease\n\n```objectivec\n@autoreleasepool {\n    Student *student = [[[Student alloc] init] autorelease];\n}\n```\n\n```c\nstruct __AtAutoreleasePool {\n  __AtAutoreleasePool() { // 构造函数\n      atautoreleasepoolobj = objc_autoreleasePoolPush();\n  }\n  ~__AtAutoreleasePool() { // 析构函数\n      objc_autoreleasePoolPop(atautoreleasepoolobj);\n  }\n  void * atautoreleasepoolobj;\n};\n```\n\n```c\n{ \n    __AtAutoreleasePool __autoreleasepool; // 创建一个结构体变量\n    Student *student = objc_msgSend(objc_msgSend(objc_msgSend(objc_getClass(\"Student\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")), sel_registerName(\"autorelease\"));\n}\n```\n\n相当于\n\n\n```objectivec\n{ \n    atautoreleasepoolobj = objc_autoreleasePoolPush();\n    Student *student = objc_msgSend(objc_msgSend(objc_msgSend(objc_getClass(\"Student\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")), sel_registerName(\"autorelease\"));\n    objc_autoreleasePoolPop(atautoreleasepoolobj);\n}\n```\n\n自动释放池的主要底层数据结构是: `__AtAutoreleasePool`、`AutoreleasePoolPage`\n\n调用了`autorelease`的对象最终都是通过`AutoreleasePoolPage`对象来管的\n\n\n源码分析\n\t- clang重写@autoreleasepool\n    - objc4源码：NSobject.mm\n\n## AutoreleasePoolPage的结构\n\n```c\nclass AutoreleasePage\n{\n    magic_t const magic;\n    id *next;\n    pthread_t const thread;\n    AutoreleasePoolPage *const parent;\n    AutoreleasePoolPage *const child;\n    uint32_t depth;\n    uint32_t hiwat;\n}\n```\n\n- 每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放`autorelease`对象的地址\n- 所有的`AutoreleasePoolPage`对象通过双向链表的形式连接在一起\n\n- 调用push方法会将一个POOL_BOUNDARY入栈，并且返回其存放的内存地址\n- 调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送release对象，直到遇到这个POOL_BOUNDARY\n\n- `id *next`指向了下一个能存放`autorelease`对象地址的区域\n\n```c\nstatic inline void *push()  {\n    id *dest;\n    if (slowpath(DebugPoolAllocation)) {\n        // Each autorelease pool starts on a new pool page.\n        dest = autoreleaseNewPage(POOL_BOUNDARY);\n    } else {\n        dest = autoreleaseFast(POOL_BOUNDARY);\n    }\n    ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);\n    return dest;\n}\n```\n\n```c\nstatic inline void pop(void *token) {\n    AutoreleasePoolPage *page;\n    id *stop;\n    if (token == (void*)EMPTY_POOL_PLACEHOLDER) {\n        // Popping the top-level placeholder pool.\n        page = hotPage();\n        if (!page) {\n            // Pool was never used. Clear the placeholder.\n            return setHotPage(nil);\n        }\n        // Pool was used. Pop its contents normally.\n        // Pool pages remain allocated for re-use as usual.\n        page = coldPage();\n        token = page->begin();\n    } else {\n        page = pageForPointer(token);\n    }\n\n    stop = (id *)token;\n    if (*stop != POOL_BOUNDARY) {\n        if (stop == page->begin()  &&  !page->parent) {\n            // Start of coldest page may correctly not be POOL_BOUNDARY:\n            // 1. top-level pool is popped, leaving the cold page in place\n            // 2. an object is autoreleased with no pool\n        } else {\n            // Error. For bincompat purposes this is not \n            // fatal in executables built with old SDKs.\n            return badPop(token);\n        }\n    }\n\n    if (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) {\n        return popPageDebug(token, page, stop);\n    }\n\n    return popPage<false>(token, page, stop);\n}\n```\n\n### Runloop和Autorelease\n\n- iOS在主线程的Runloop中注册了两个Observer\n- 第1个Observer监听了`kCFRunLoopEntry`事件，会调用`objc_autoreleasePoolPush()`\n- 第2个Observer\n\t- 监听了`kCFRunLoopBeforeWaiting`会调用`objc_autoreleasePoolPop()`、`objc_autoreleasePoolPush()`\n\t- 监听了`kCFRunloopBeforeExit`事件，会调用`objc_autoreleasePoolPop()`","slug":"iOS-底层原理-内存管理","published":1,"updated":"2021-09-04T05:43:27.921Z","_id":"cksxcg3ou0001h7n076w99zcd","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文主要介绍iOS中内存管理的一些事情</p>\n<span id=\"more\"></span>\n\n<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h2><h3 id=\"CADisplayLink、NSTimer\"><a href=\"#CADisplayLink、NSTimer\" class=\"headerlink\" title=\"CADisplayLink、NSTimer\"></a>CADisplayLink、NSTimer</h3><p><code>CADisplayLink</code>、<code>NSTimer</code>会对<code>target</code>产生强引用，如果<code>target</code>又对它们产生强引用，那么就会引发循环引用</p>\n<p>比如：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>) <span class=\"built_in\">NSTimer</span> *timer;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(timerTimer) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<code>self</code>强持有了<code>timer</code>，<code>timer</code>强持有了<code>self</code>，造成了循环引用</p>\n<h4 id=\"利用block解决\"><a href=\"#利用block解决\" class=\"headerlink\" title=\"利用block解决\"></a>利用block解决</h4><p>针对<code>NSTimer</code>我们可以有另外的解决办法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakself = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">    [weakself timerTest];</span><br><span class=\"line\">]&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>让<code>timer</code>强持有block，block弱持有<code>self</code>，这样子<code>self</code>就是间接被弱持有，打破了循环引用。</p>\n<h4 id=\"利用NSProxy解决\"><a href=\"#利用NSProxy解决\" class=\"headerlink\" title=\"利用NSProxy解决\"></a>利用NSProxy解决</h4><p>新建一个类继承自<code>NSProxy</code></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyProxy</span> : <span class=\"title\">NSProxy</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"keyword\">id</span>)target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyProxy</span>()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">id</span> target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyProxy</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"keyword\">id</span>)target &#123;</span><br><span class=\"line\">    <span class=\"comment\">// NSProxy对象不需要调用init，因为它没有init方法</span></span><br><span class=\"line\">    MyProxy *proxy = [MyProxy alloc];</span><br><span class=\"line\">    proxy.target = target;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 实现消息转发的两个方法，一定要实现，不然会报方法找不到的错误</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.target methodSignatureForSelector:sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)invocation &#123;</span><br><span class=\"line\">    [invocation invokeWithTarget:<span class=\"keyword\">self</span>.target];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> target:[MyProxy proxyWithTarget:<span class=\"keyword\">self</span>] selector:<span class=\"keyword\">@selector</span>(test) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>原理很简单，就是把<code>self</code>让<code>proxy</code>弱持有，<code>timer</code>强持有<code>proxy</code>，这样子就能够做到间接弱持有<code>self</code>，打破循环引用</p>\n<p>为了让<code>timer</code>调用<code>selector</code>的时候能调回到<code>self</code>的方法，在<code>proxy</code>内部我们使用消息转发机制，把消息转发到<code>target</code>（也就是<code>self</code>）中，实现调用。</p>\n<p>至于消息转发机制的另一个方法<code>-forwardingTargetForSelector:</code>之所以不能使用，是因为<code>NSProxy</code>不提供。</p>\n<p>实际上我们如果不继承自<code>NSProxy</code>，直接继承自<code>NSObject</code>也是能完成上述操作的，但是使用<code>NSProxy</code>的话可以跳过消息发送和动态方法解析阶段，直接进入消息转发阶段，效率比较高</p>\n<blockquote>\n<p>注意： <code>NSProxy</code>对象如果调用<code>isKindOfClass:</code>或其他方法，那么由于它直接进入了消息转发阶段，所以会直接拿<code>target</code>属性去调用方法，所以都跟<code>NSProxy</code>对象本身没有关系</p>\n</blockquote>\n<h3 id=\"GCD定时器\"><a href=\"#GCD定时器\" class=\"headerlink\" title=\"GCD定时器\"></a>GCD定时器</h3><ul>\n<li><code>NSTimer</code>依赖<code>RunLoop</code>，如果<code>Runloop</code>的任务过于繁重，可能会导致<code>NSTimer</code>不准时<ul>\n<li>因为Runloop每次循环的时间是不定的，所以下次循环的时候到达处理定时器那个环节，不一定跟上次刚好相差我们所指定时间，所以就会不准</li>\n</ul>\n</li>\n<li>GCD的定时器会更加准时</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 队列</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建定时器</span></span><br><span class=\"line\">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class=\"number\">0</span>, <span class=\"number\">0</span>, queue);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置时间</span></span><br><span class=\"line\"><span class=\"built_in\">NSTimeInterval</span> start = <span class=\"number\">2.0</span>; <span class=\"comment\">// 2秒后开始执行</span></span><br><span class=\"line\"><span class=\"built_in\">NSTimeInterval</span> interval = <span class=\"number\">1.0</span>; <span class=\"comment\">// 每1秒执行一次</span></span><br><span class=\"line\">dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * <span class=\"built_in\">NSEC_PER_SEC</span>), interval * <span class=\"built_in\">NSEC_PER_SEC</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置回调</span></span><br><span class=\"line\">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;11111&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动定时器</span></span><br><span class=\"line\">dispatch_resume(timer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取消定时器</span></span><br><span class=\"line\"><span class=\"comment\">// dispatch_source_cancel(timer);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = timer;</span><br></pre></td></tr></table></figure>\n\n<p>由于GCD的定时器跟<code>Runloop</code>没有关系，所以滚动视图也不会影响GCD定时器的执行</p>\n<p>除了使用block回调，我们也可以写一个C函数作为回调函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_source_set_event_handler_f(timer, timerFire);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">timerFire</span><span class=\"params\">(<span class=\"keyword\">void</span> *param)</span> </span>&#123;</span><br><span class=\"line\">    NSLog(@<span class=\"string\">&quot;%@ %@&quot;</span>,param,[NSThread currentThread]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"内存布局\"><a href=\"#内存布局\" class=\"headerlink\" title=\"内存布局\"></a>内存布局</h2><ul>\n<li>内存布局从低地址到高地址排序如下<ol>\n<li>保留</li>\n<li>代码段（__TEXT）</li>\n<li>数据段（__DATA）：字符串常量， 已初始化数据，未初始化数据</li>\n<li>堆（heap）</li>\n<li>栈（stack）</li>\n<li>内核区</li>\n</ol>\n</li>\n<li>代码段：编译之后的代码</li>\n<li>数据段：<ul>\n<li>字符串常量</li>\n<li>已初始化数据：已初始化的全局变量、静态变量等</li>\n<li>未初始化数据：未初始化的全局变量、静态变量等</li>\n</ul>\n</li>\n<li>堆：通过alloc、malloc、calloc的那个动态分配的空间，分配的内存空间地址越来越大</li>\n<li>栈：函数调用开销，比如局部变量，分配的内存空间地址越来越小</li>\n</ul>\n<h2 id=\"Tagged-Pointer\"><a href=\"#Tagged-Pointer\" class=\"headerlink\" title=\"Tagged Pointer\"></a>Tagged Pointer</h2><ul>\n<li><p>从64bit开始，iOS引入了Tagged Pointer技术，用于优化<code>NSNumber</code>,<code>NSDate</code>，<code>NSString</code>等小对象的存储</p>\n</li>\n<li><p>在没有使用Tagged Pointer之前，<code>NSNumber</code>等对象需要动态分配内存，维护引用计数的等，<code>NSNumber</code>指针存储的是堆中<code>NSNumber</code>对象的地址值.</p>\n</li>\n<li><p>使用<code>Tagged Pointer</code>之后，<code>NSNumber</code>指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中。</p>\n</li>\n<li><p>在Mac环境下当对象指针的二进制最低有效位是1，则该指针为<code>Tagged Pointer</code>（如果是0那么就是OC对象，因为OC对象分配内存是按照16个字节对齐的，所以最后一位肯定是0）,可以编写如下函数来判断是否是<code>Tagged Pointer</code></p>\n<ul>\n<li>跟1进行与运算，取出最低位判断是不是1即可</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">isTaggedPointer</span><span class=\"params\">(id pointer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">long</span>)(__bridge <span class=\"keyword\">void</span> *)pointer &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果是iOS环境下，则判断的是最高有效位(第64位)是否是1，即<code>(long)(__bridge void *)pointer &amp; 1UL&lt;&lt;63</code></li>\n</ul>\n</li>\n<li><p>当指针不够存储数据时，才会使用动态分配内存来存储数据（比如NSNumber的存储的数字太大了，指针8个十六进制位都装不下）</p>\n</li>\n<li><p><code>objc_msgSend</code>能识别<code>Tagged Pointer</code>，比如<code>NSNumber</code>的intValue方法，直接从指针提取数据，节省了以前的调用开销</p>\n</li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">copy</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSString</span> *name;</span><br></pre></td></tr></table></figure>\n\n<p>这个属性的set方法实际为</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)<span class=\"built_in\">setName</span>:(NSString *)<span class=\"built_in\">name</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"variable\">_name</span> != <span class=\"built_in\">name</span>) &#123;</span><br><span class=\"line\">        [<span class=\"variable\">_name</span> release];</span><br><span class=\"line\">        <span class=\"variable\">_name</span> = [<span class=\"built_in\">name</span> retain];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假如我们这么给<code>name</code>赋值<code>self.name = [NSString stringWithForamt:@&quot;abcdefghijkl&quot;]</code>，因为这个太大了，转不成<code>tagged pointer</code>，那么在多线程环境下，有可能会因为多次执行了<code>[_name release]</code>导致坏内存访问而崩溃</p>\n<p>字符串其实还有其他样子，总的来说，除了<code>__NSCFString</code>，其他类型的字符串都不会调用<code>release</code>方法</p>\n<ul>\n<li><p>__NSCFConstantString</p>\n<p>  字符串常量，是一种编译时常量，它的 retainCount 值很大，是 4294967295，在控制台打印出的数值则是 18446744073709551615==2^64-1，测试证明，即便对其进行 release 操作，retainCount 也不会产生任何变化。是创建之后便是放不掉的对象。<strong>相同内容的 __NSCFConstantString 对象的地址相同，也就是说常量字符串对象是一种单例</strong>。</p>\n<p>  这种对象一般通过字面值 <code>@&quot;...&quot;</code>、<code>CFSTR(&quot;...&quot;)</code> 或者 <code>stringWithString</code>: 方法（需要说明的是，这个方法在 iOS6 SDK 中已经被称为redundant，使用这个方法会产生一条编译器警告。这个方法等同于字面值创建的方法）产生。</p>\n<p>  这种对象存储在字符串常量区。</p>\n</li>\n<li><p>__NSCFString</p>\n<p>  和 <code>__NSCFConstantString</code> 不同， <code>__NSCFString</code>对象是在运行时创建的一种 <code>NSString</code>子类，他并不是一种字符串常量。所以和其他的对象一样在被创建时获得了 1 的引用计数。</p>\n<p>  通过 NSString 的 stringWithFormat 等方法创建的 NSString 对象一般都是这种类型。</p>\n<p>  这种对象被存储在堆上。</p>\n</li>\n<li><p>NSTaggedPointerString</p>\n<p>  理解这个类型，需要明白什么是<code>TaggedPointer</code>，这是苹果在 64 位环境下对 NSString,NSNumber 等对象做的一些优化。简单来讲可以理解为把指针指向的内容直接放在了指针变量的内存地址中，因为在 64 位环境下指针变量的大小达到了 8 位足以容纳一些长度较小的内容。于是使用了标签指针这种方式来优化数据的存储方式。从他的引用计数可以看出，这货也是一个释放不掉的单例常量对象。在运行时根据实际情况创建。</p>\n<p>  对于 <code>NSString</code> 对象来讲，当非字面值常量的数字，英文字母字符串的长度小于等于 9 的时候会自动成为 <code>NSTaggedPointerString</code> 类型，如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为 ）<code>__NSCFString</code> 类型。</p>\n<p>  这种对象被直接存储在指针的内容中，可以当作一种伪对象。</p>\n<p>  当字符串的长度为10个以内时，字符串的类型都是<code>NSTaggedPointerString</code>类型，当超过10个时，字符串的类型才是<code>__NSCFString</code></p>\n</li>\n<li><p>从<code>NSTaggedPointerString</code>中读取出字符串的值</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_MASK (1UL&lt;&lt;63)</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_INDEX_SHIFT 0</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_SLOT_SHIFT 0</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_PAYLOAD_LSHIFT 1</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_PAYLOAD_RSHIFT 4</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_EXT_INDEX_SHIFT 55</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_EXT_SLOT_SHIFT 55</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_EXT_PAYLOAD_LSHIFT 9</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> _objc_isTaggedPointer(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> * _Nullable ptr)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((<span class=\"keyword\">uintptr_t</span>)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">uintptr_t</span> _objc_decodeTaggedPointer(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> * _Nullable ptr)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">uintptr_t</span>)ptr ^ objc_debug_taggedpointer_obfuscator;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">uintptr_t</span> _objc_getTaggedPointerValue(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> * _Nullable ptr) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> value = _objc_decodeTaggedPointer(ptr);</span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> basicTag = (value &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (value &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_RSHIFT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">intptr_t</span> _objc_getTaggedPointerSignedValue(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> * _Nullable ptr) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> value = _objc_decodeTaggedPointer(ptr);</span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> basicTag = (value &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((<span class=\"keyword\">intptr_t</span>)value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((<span class=\"keyword\">intptr_t</span>)value &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_RSHIFT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NSNumber\"><a href=\"#NSNumber\" class=\"headerlink\" title=\"NSNumber\"></a>NSNumber</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSNumber</span> *number1 = @(<span class=\"number\">0x1</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *number2 = @(<span class=\"number\">0x20</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *number3 = @(<span class=\"number\">0x3F</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *numberFFFF = @(<span class=\"number\">0xFFFFFFFFFFEFE</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *maxNum = @(MAXFLOAT);</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;number1 pointer is %p class is %@&quot;</span>, number1, number1.class);</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;number2 pointer is %p class is %@&quot;</span>, number2, number2.class);</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;number3 pointer is %p class is %@&quot;</span>, number3, number3.class);</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;numberffff pointer is %p class is %@&quot;</span>, numberFFFF, numberFFFF.class);</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;maxNum pointer is %p class is %@&quot;</span>, maxNum, maxNum.class);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TaggedPointerDemo[<span class=\"number\">59218</span>:<span class=\"number\">2167895</span>] number1 pointer is <span class=\"number\">0xf7cb914ffb51479a</span> <span class=\"keyword\">class</span> is __NSCFNumber</span><br><span class=\"line\">TaggedPointerDemo[<span class=\"number\">59218</span>:<span class=\"number\">2167895</span>] number2 pointer is <span class=\"number\">0xf7cb914ffb51458a</span> <span class=\"keyword\">class</span> is __NSCFNumber</span><br><span class=\"line\">TaggedPointerDemo[<span class=\"number\">59218</span>:<span class=\"number\">2167895</span>] number3 pointer is <span class=\"number\">0xf7cb914ffb51447a</span> <span class=\"keyword\">class</span> is __NSCFNumber</span><br><span class=\"line\">TaggedPointerDemo[<span class=\"number\">59218</span>:<span class=\"number\">2167895</span>] numberffff pointer is <span class=\"number\">0xf7346eb004aea86b</span> <span class=\"keyword\">class</span> is __NSCFNumber</span><br><span class=\"line\">TaggedPointerDemo[<span class=\"number\">59218</span>:<span class=\"number\">2167895</span>] maxNum pointer is <span class=\"number\">0x28172a0c0</span> <span class=\"keyword\">class</span> is __NSCFNumber</span><br></pre></td></tr></table></figure>\n\n<p>我们发现对于<code>NSNumber</code>，我们打印出来的数据类型均为<code>__NSCFNumber</code>,但是我们发现对于MAXFLOAT打印出的地址显然与其他几项不符，上面几个<code>NSNumber</code>的地址以0xf开头，根据字符串地址的经验我们可以看出<code>f = 1111</code>,首位标记位为1，表示这个数据类型属于<code>TaggedPointer</code>。而<code>MAXFLOAT</code>不是。</p>\n<h2 id=\"MRC\"><a href=\"#MRC\" class=\"headerlink\" title=\"MRC\"></a>MRC</h2><ul>\n<li><p>在iOS中，使用<code>引用计数</code>来管理OC对象的内存</p>\n</li>\n<li><p>一个新创建的OC对象的引用计数默认是1，当引用计数减为0，OC对象就会销毁，释放其占用的内存空间</p>\n</li>\n<li><p>调用retain会让OC对象的引用计数+1，调用release会让OC对象的引用计数-1</p>\n</li>\n<li><p>内存管理的经验总结：</p>\n<ul>\n<li>当调用<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>方法返回了一个对象，在不需要这个对象时，要调用<code>release</code>或者<code>autorelease</code>释放它</li>\n<li>想拥有某个对象，就让它的引用计数+1;不想再拥有某个对象，就让它的引用计数-1</li>\n</ul>\n</li>\n<li><p>可以通过以下私有函数来查看自动释放池的情况</p>\n<p>  <code>extern void _objc_autoreleasePoolPrint(void); </code></p>\n</li>\n</ul>\n<p>在ARC中声明<code>@property(nonatomic,assign) int age;</code> 其set方法相当于MRC中的</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setAge:(<span class=\"keyword\">int</span>)age &#123;</span><br><span class=\"line\">    _age = age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在ARC中声明<code>@property(nonatomic,strong) NSObject *age;</code> 其set方法相当于MRC中的</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setAge:(<span class=\"built_in\">NSObject</span> *)age &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_age != age) &#123; <span class=\"comment\">// 防止同个对象释放后引用计数变成0，就不能再retain了</span></span><br><span class=\"line\">        [_age release]; <span class=\"comment\">// 防止新对象进来之后，旧对象的引用计数多出了1导致释放不掉</span></span><br><span class=\"line\">        _age = [age reatin]; <span class=\"comment\">// 引用计数+1，防止被外部一不小心释放了</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>关于Autorelease</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">self.data</span> = [NSMutableArray array]<span class=\"comment\">; // 自动进行了autorelease</span></span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.data = <span class=\"comment\">[<span class=\"comment\">[<span class=\"comment\">[NSMutableArray alloc]</span> init]</span> autorelease]</span>;</span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">self.data</span> = [[NSMutableArray alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"section\">[self.data release]</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NSMutableArray</span> *<span class=\"class\"><span class=\"keyword\">data</span> = [[<span class=\"type\">NSMutableArray</span> alloc] init];</span></span><br><span class=\"line\"><span class=\"title\">self</span>.<span class=\"class\"><span class=\"keyword\">data</span> = <span class=\"keyword\">data</span>;</span></span><br><span class=\"line\">[<span class=\"class\"><span class=\"keyword\">data</span> release];</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"引用计数的存储\"><a href=\"#引用计数的存储\" class=\"headerlink\" title=\"引用计数的存储\"></a>引用计数的存储</h2><p>在64bit中，引用计数可以直接存储在优化过的isa指针中，如果isa指针不够存的话就存储在<code>SiteTable</code>类中（最终的引用计数是两个存储的地方都会取出来值，然后求和）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SideTable</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">spinlock_t</span> slock;</span><br><span class=\"line\">    RefcountMap refcnts;</span><br><span class=\"line\">    <span class=\"keyword\">weak_table_t</span> weak_table;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>refcnts是一个存放着对象引用计数的散列表</li>\n</ul>\n<p>在SiteTable中获取到<code>retainCount</code>的核心代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">objc_object::sidetable_getExtraRC_nolock</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ASSERT(isa.nonpointer);</span><br><span class=\"line\">    SideTable&amp; table = SideTables()[<span class=\"keyword\">this</span>];</span><br><span class=\"line\">    RefcountMap::iterator it = table.refcnts.find(<span class=\"keyword\">this</span>); </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (it == table.refcnts.end()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// 遍历refcnts</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT; <span class=\"comment\">// 进行位运算取出retainCount</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Weak\"><a href=\"#Weak\" class=\"headerlink\" title=\"Weak\"></a>Weak</h2><p> weak指针能够在对象释放的时候把指针清空，具体是怎么做到的。我们需要看一下对象<code>dealloc</code>的过程</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">objc_object::rootDealloc</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isTaggedPointer()) <span class=\"keyword\">return</span>;  <span class=\"comment\">// fixme necessary?</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fastpath(isa.nonpointer                     &amp;&amp; <span class=\"comment\">// 0代表普通的指针，1代表优化过的指针，使用位域存储信息</span></span><br><span class=\"line\">                 !isa.weakly_referenced             &amp;&amp; <span class=\"comment\">// 是否有弱引用指针</span></span><br><span class=\"line\">                 !isa.has_assoc                     &amp;&amp; <span class=\"comment\">// 是否有设置关联对象</span></span><br><span class=\"line\">                 !isa.has_cxx_dtor                  &amp;&amp; <span class=\"comment\">// 是否有C++即构函数</span></span><br><span class=\"line\">                 !isa.has_sidetable_rc))\t\t\t   <span class=\"comment\">// 引用计数器是不是过大而无法存放在isa中，如果为1，那引用计数会存储在SideTable的类的属性中</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        assert(!sidetable_present());</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        object_dispose((id)<span class=\"keyword\">this</span>); <span class=\"comment\">// 显然弱引用指针指向的对象会进入这里</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">id  <span class=\"title\">object_dispose</span><span class=\"params\">(id obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!obj) <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    objc_destructInstance(obj); <span class=\"comment\">// 释放前做一些事情</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(obj); <span class=\"comment\">// 这里才释放</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">objc_destructInstance</span><span class=\"params\">(id obj)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Read all of the flags at once for performance.</span></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// This order is important.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cxx) object_cxxDestruct(obj); <span class=\"comment\">// 清除成员变量</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (assoc) _object_remove_assocations(obj, <span class=\"comment\">/*deallocating*/</span><span class=\"literal\">true</span>); <span class=\"comment\">// 移除关联对象</span></span><br><span class=\"line\">        obj-&gt;clearDeallocating(); <span class=\"comment\">// 将指向当前对象的弱指针置为nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">objc_object::clearDeallocating</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Slow path for raw pointer isa.</span></span><br><span class=\"line\">        sidetable_clearDeallocating();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class=\"line\">        clearDeallocating_slow(); <span class=\"comment\">// 再进入这里</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    assert(!sidetable_present());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\">NEVER_INLINE <span class=\"keyword\">void</span> <span class=\"title\">objc_object::clearDeallocating_slow</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ASSERT(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class=\"line\"></span><br><span class=\"line\">    SideTable&amp; table = SideTables()[<span class=\"keyword\">this</span>]; <span class=\"comment\">// 拿出SiteTables数组，然后取出对应的SiteTable对象</span></span><br><span class=\"line\">    table.lock();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isa.weakly_referenced) &#123;</span><br><span class=\"line\">        weak_clear_no_lock(&amp;table.weak_table, (id)<span class=\"keyword\">this</span>); <span class=\"comment\">// 清除弱引用指针 </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class=\"line\">        table.refcnts.erase(<span class=\"keyword\">this</span>); <span class=\"comment\">// 清除引用计数表</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    table.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>  <span class=\"title\">weak_clear_no_lock</span><span class=\"params\">(<span class=\"keyword\">weak_table_t</span> *weak_table, id referent_id)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    objc_object *referent = (objc_object *)referent_id;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/// 把SiteTable里面的weakTable和指针传进去</span></span><br><span class=\"line\">    <span class=\"keyword\">weak_entry_t</span> *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (entry == nil) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// XXX shouldn&#x27;t happen, but does with mismatched CF/objc</span></span><br><span class=\"line\">        <span class=\"comment\">//printf(&quot;XXX no entry for clear deallocating %p\\n&quot;, referent);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// zero out references</span></span><br><span class=\"line\">    <span class=\"keyword\">weak_referrer_t</span> *referrers;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> count;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class=\"line\">        referrers = entry-&gt;referrers;</span><br><span class=\"line\">        count = TABLE_SIZE(entry);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        referrers = entry-&gt;inline_referrers;</span><br><span class=\"line\">        count = WEAK_INLINE_COUNT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; count; ++i) &#123;</span><br><span class=\"line\">        objc_object **referrer = referrers[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (referrer) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (*referrer == referent) &#123;</span><br><span class=\"line\">                *referrer = nil;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (*referrer) &#123;</span><br><span class=\"line\">                _objc_inform(<span class=\"string\">&quot;__weak variable at %p holds %p instead of %p. &quot;</span></span><br><span class=\"line\">                             <span class=\"string\">&quot;This is probably incorrect use of &quot;</span></span><br><span class=\"line\">                             <span class=\"string\">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class=\"line\">                             <span class=\"string\">&quot;Break on objc_weak_error to debug.\\n&quot;</span>, </span><br><span class=\"line\">                             referrer, (<span class=\"keyword\">void</span>*)*referrer, (<span class=\"keyword\">void</span>*)referent);</span><br><span class=\"line\">                objc_weak_error();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    weak_entry_remove(weak_table, entry);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">uintptr_t</span> <span class=\"title\">hash_pointer</span><span class=\"params\">(objc_object *key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ptr_hash((<span class=\"keyword\">uintptr_t</span>)key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">weak_entry_t</span> * <span class=\"title\">weak_entry_for_referent</span><span class=\"params\">(<span class=\"keyword\">weak_table_t</span> *weak_table, objc_object *referent)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ASSERT(referent);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">weak_entry_t</span> *weak_entries = weak_table-&gt;weak_entries;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!weak_entries) <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/// 通过与运算得到索引</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> begin = hash_pointer(referent) &amp; weak_table-&gt;mask;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> index = begin;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> hash_displacement = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (weak_table-&gt;weak_entries[index].referent != referent) &#123;</span><br><span class=\"line\">        index = (index+<span class=\"number\">1</span>) &amp; weak_table-&gt;mask;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == begin) bad_weak_table(weak_table-&gt;weak_entries);</span><br><span class=\"line\">        hash_displacement++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;weak_table-&gt;weak_entries[index];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结：</p>\n<p>Weak指针指向的对象释放流程如下</p>\n<ol>\n<li>清除成员变量，移除关联对象</li>\n<li>拿到对象对应的SiteTable，再取出里面的weak_table</li>\n<li>通过hash后的对象的指针和weak_table进行一次与运算，得到索引，在weak_table中通过索引取出弱引用指针</li>\n<li>置空取出的所有的弱引用指针</li>\n<li>清除引用计数表</li>\n<li>释放对象</li>\n</ol>\n<h2 id=\"Copy和MutableCopy\"><a href=\"#Copy和MutableCopy\" class=\"headerlink\" title=\"Copy和MutableCopy\"></a>Copy和MutableCopy</h2><p>拷贝的目的：产生一个副本对象，跟源对象互不影响<br>修改了源对象，不会影响副本对象<br>修改了副本对象，不会影响源对象</p>\n<p>iOS提供了2个拷贝方法</p>\n<ol>\n<li>copy ，不可变拷贝，产生不可变副本。</li>\n<li>mutableCopy，可变拷贝，产生可变副本。</li>\n<li>浅拷贝：指针拷贝，没有产生新的对象。（不可变对象copy）</li>\n<li>深拷贝：内容拷贝，产生新的对象。(可变、不可变对象调用mutableCopy或者可变对象调用copy)</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *str1 = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@&quot;test&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *str2 = [str1 <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 返回的是NSString</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableString</span> *str3 = [str1 mutableCopy]; <span class=\"comment\">// 返回的是NSMutableString</span></span><br></pre></td></tr></table></figure>\n\n<p>当<code>copy</code>方法被不可变对象调用的话，不会发生什么变化，直接还是返回原来的对象，但是这时候引用计数会加1，相当于<code>retain</code>了一下，所以上面的代码要释放对象的时候，除了调用<code>[str1 release];</code>，那么还得调用<code>[str2 release]；</code></p>\n<p>在ARC中声明<code>@property(nonatomic,copy) NSString *age;</code> 其set方法相当于MRC中的</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setAge:(<span class=\"built_in\">NSString</span> *)age &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_age != age) &#123;</span><br><span class=\"line\">        [_age release];</span><br><span class=\"line\">        _age = [age <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"AutoRelease\"><a href=\"#AutoRelease\" class=\"headerlink\" title=\"AutoRelease\"></a>AutoRelease</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">    Student *student = [[[Student alloc] init] autorelease];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">AtAutoreleasePool</span> &#123;</span></span><br><span class=\"line\">  __AtAutoreleasePool() &#123; <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">      atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ~__AtAutoreleasePool() &#123; <span class=\"comment\">// 析构函数</span></span><br><span class=\"line\">      objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> * atautoreleasepoolobj;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    __AtAutoreleasePool __autoreleasepool; <span class=\"comment\">// 创建一个结构体变量</span></span><br><span class=\"line\">    Student *student = objc_msgSend(objc_msgSend(objc_msgSend(objc_getClass(<span class=\"string\">&quot;Student&quot;</span>), sel_registerName(<span class=\"string\">&quot;alloc&quot;</span>)), sel_registerName(<span class=\"string\">&quot;init&quot;</span>)), sel_registerName(<span class=\"string\">&quot;autorelease&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相当于</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class=\"line\">    Student *student = objc_msgSend(objc_msgSend(objc_msgSend(objc_getClass(<span class=\"string\">&quot;Student&quot;</span>), sel_registerName(<span class=\"string\">&quot;alloc&quot;</span>)), sel_registerName(<span class=\"string\">&quot;init&quot;</span>)), sel_registerName(<span class=\"string\">&quot;autorelease&quot;</span>));</span><br><span class=\"line\">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自动释放池的主要底层数据结构是: <code>__AtAutoreleasePool</code>、<code>AutoreleasePoolPage</code></p>\n<p>调用了<code>autorelease</code>的对象最终都是通过<code>AutoreleasePoolPage</code>对象来管的</p>\n<p>源码分析<br>    - clang重写@autoreleasepool<br>    - objc4源码：NSobject.mm</p>\n<h2 id=\"AutoreleasePoolPage的结构\"><a href=\"#AutoreleasePoolPage的结构\" class=\"headerlink\" title=\"AutoreleasePoolPage的结构\"></a>AutoreleasePoolPage的结构</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoreleasePage</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">magic_t</span> <span class=\"keyword\">const</span> magic;</span><br><span class=\"line\">    id *next;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> <span class=\"keyword\">const</span> thread;</span><br><span class=\"line\">    AutoreleasePoolPage *<span class=\"keyword\">const</span> parent;</span><br><span class=\"line\">    AutoreleasePoolPage *<span class=\"keyword\">const</span> child;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> depth;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> hiwat;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放<code>autorelease</code>对象的地址</p>\n</li>\n<li><p>所有的<code>AutoreleasePoolPage</code>对象通过双向链表的形式连接在一起</p>\n</li>\n<li><p>调用push方法会将一个POOL_BOUNDARY入栈，并且返回其存放的内存地址</p>\n</li>\n<li><p>调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送release对象，直到遇到这个POOL_BOUNDARY</p>\n</li>\n<li><p><code>id *next</code>指向了下一个能存放<code>autorelease</code>对象地址的区域</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> *<span class=\"title\">push</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">    id *dest;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(DebugPoolAllocation)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Each autorelease pool starts on a new pool page.</span></span><br><span class=\"line\">        dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">(<span class=\"keyword\">void</span> *token)</span> </span>&#123;</span><br><span class=\"line\">    AutoreleasePoolPage *page;</span><br><span class=\"line\">    id *stop;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (token == (<span class=\"keyword\">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Popping the top-level placeholder pool.</span></span><br><span class=\"line\">        page = hotPage();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!page) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Pool was never used. Clear the placeholder.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> setHotPage(nil);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Pool was used. Pop its contents normally.</span></span><br><span class=\"line\">        <span class=\"comment\">// Pool pages remain allocated for re-use as usual.</span></span><br><span class=\"line\">        page = coldPage();</span><br><span class=\"line\">        token = page-&gt;begin();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        page = pageForPointer(token);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    stop = (id *)token;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*stop != POOL_BOUNDARY) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Start of coldest page may correctly not be POOL_BOUNDARY:</span></span><br><span class=\"line\">            <span class=\"comment\">// 1. top-level pool is popped, leaving the cold page in place</span></span><br><span class=\"line\">            <span class=\"comment\">// 2. an object is autoreleased with no pool</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Error. For bincompat purposes this is not </span></span><br><span class=\"line\">            <span class=\"comment\">// fatal in executables built with old SDKs.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> badPop(token);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> popPageDebug(token, page, stop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> popPage&lt;<span class=\"literal\">false</span>&gt;(token, page, stop);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Runloop和Autorelease\"><a href=\"#Runloop和Autorelease\" class=\"headerlink\" title=\"Runloop和Autorelease\"></a>Runloop和Autorelease</h3><ul>\n<li>iOS在主线程的Runloop中注册了两个Observer</li>\n<li>第1个Observer监听了<code>kCFRunLoopEntry</code>事件，会调用<code>objc_autoreleasePoolPush()</code></li>\n<li>第2个Observer<ul>\n<li>监听了<code>kCFRunLoopBeforeWaiting</code>会调用<code>objc_autoreleasePoolPop()</code>、<code>objc_autoreleasePoolPush()</code></li>\n<li>监听了<code>kCFRunloopBeforeExit</code>事件，会调用<code>objc_autoreleasePoolPop()</code></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文主要介绍iOS中内存管理的一些事情</p>","more":"<h2 id=\"定时器\"><a href=\"#定时器\" class=\"headerlink\" title=\"定时器\"></a>定时器</h2><h3 id=\"CADisplayLink、NSTimer\"><a href=\"#CADisplayLink、NSTimer\" class=\"headerlink\" title=\"CADisplayLink、NSTimer\"></a>CADisplayLink、NSTimer</h3><p><code>CADisplayLink</code>、<code>NSTimer</code>会对<code>target</code>产生强引用，如果<code>target</code>又对它们产生强引用，那么就会引发循环引用</p>\n<p>比如：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">strong</span>) <span class=\"built_in\">NSTimer</span> *timer;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(timerTimer) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br></pre></td></tr></table></figure>\n\n<p>在这里，<code>self</code>强持有了<code>timer</code>，<code>timer</code>强持有了<code>self</code>，造成了循环引用</p>\n<h4 id=\"利用block解决\"><a href=\"#利用block解决\" class=\"headerlink\" title=\"利用block解决\"></a>利用block解决</h4><p>针对<code>NSTimer</code>我们可以有另外的解决办法：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakself = <span class=\"keyword\">self</span>;</span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">    [weakself timerTest];</span><br><span class=\"line\">]&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>让<code>timer</code>强持有block，block弱持有<code>self</code>，这样子<code>self</code>就是间接被弱持有，打破了循环引用。</p>\n<h4 id=\"利用NSProxy解决\"><a href=\"#利用NSProxy解决\" class=\"headerlink\" title=\"利用NSProxy解决\"></a>利用NSProxy解决</h4><p>新建一个类继承自<code>NSProxy</code></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyProxy</span> : <span class=\"title\">NSProxy</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"keyword\">id</span>)target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">MyProxy</span>()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"keyword\">id</span> target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">MyProxy</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"keyword\">id</span>)target &#123;</span><br><span class=\"line\">    <span class=\"comment\">// NSProxy对象不需要调用init，因为它没有init方法</span></span><br><span class=\"line\">    MyProxy *proxy = [MyProxy alloc];</span><br><span class=\"line\">    proxy.target = target;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 实现消息转发的两个方法，一定要实现，不然会报方法找不到的错误</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.target methodSignatureForSelector:sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)invocation &#123;</span><br><span class=\"line\">    [invocation invokeWithTarget:<span class=\"keyword\">self</span>.target];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1.0</span> target:[MyProxy proxyWithTarget:<span class=\"keyword\">self</span>] selector:<span class=\"keyword\">@selector</span>(test) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>原理很简单，就是把<code>self</code>让<code>proxy</code>弱持有，<code>timer</code>强持有<code>proxy</code>，这样子就能够做到间接弱持有<code>self</code>，打破循环引用</p>\n<p>为了让<code>timer</code>调用<code>selector</code>的时候能调回到<code>self</code>的方法，在<code>proxy</code>内部我们使用消息转发机制，把消息转发到<code>target</code>（也就是<code>self</code>）中，实现调用。</p>\n<p>至于消息转发机制的另一个方法<code>-forwardingTargetForSelector:</code>之所以不能使用，是因为<code>NSProxy</code>不提供。</p>\n<p>实际上我们如果不继承自<code>NSProxy</code>，直接继承自<code>NSObject</code>也是能完成上述操作的，但是使用<code>NSProxy</code>的话可以跳过消息发送和动态方法解析阶段，直接进入消息转发阶段，效率比较高</p>\n<blockquote>\n<p>注意： <code>NSProxy</code>对象如果调用<code>isKindOfClass:</code>或其他方法，那么由于它直接进入了消息转发阶段，所以会直接拿<code>target</code>属性去调用方法，所以都跟<code>NSProxy</code>对象本身没有关系</p>\n</blockquote>\n<h3 id=\"GCD定时器\"><a href=\"#GCD定时器\" class=\"headerlink\" title=\"GCD定时器\"></a>GCD定时器</h3><ul>\n<li><code>NSTimer</code>依赖<code>RunLoop</code>，如果<code>Runloop</code>的任务过于繁重，可能会导致<code>NSTimer</code>不准时<ul>\n<li>因为Runloop每次循环的时间是不定的，所以下次循环的时候到达处理定时器那个环节，不一定跟上次刚好相差我们所指定时间，所以就会不准</li>\n</ul>\n</li>\n<li>GCD的定时器会更加准时</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 队列</span></span><br><span class=\"line\"><span class=\"built_in\">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建定时器</span></span><br><span class=\"line\">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class=\"number\">0</span>, <span class=\"number\">0</span>, queue);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置时间</span></span><br><span class=\"line\"><span class=\"built_in\">NSTimeInterval</span> start = <span class=\"number\">2.0</span>; <span class=\"comment\">// 2秒后开始执行</span></span><br><span class=\"line\"><span class=\"built_in\">NSTimeInterval</span> interval = <span class=\"number\">1.0</span>; <span class=\"comment\">// 每1秒执行一次</span></span><br><span class=\"line\">dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * <span class=\"built_in\">NSEC_PER_SEC</span>), interval * <span class=\"built_in\">NSEC_PER_SEC</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置回调</span></span><br><span class=\"line\">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;11111&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动定时器</span></span><br><span class=\"line\">dispatch_resume(timer);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取消定时器</span></span><br><span class=\"line\"><span class=\"comment\">// dispatch_source_cancel(timer);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">self</span>.timer = timer;</span><br></pre></td></tr></table></figure>\n\n<p>由于GCD的定时器跟<code>Runloop</code>没有关系，所以滚动视图也不会影响GCD定时器的执行</p>\n<p>除了使用block回调，我们也可以写一个C函数作为回调函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_source_set_event_handler_f(timer, timerFire);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">timerFire</span><span class=\"params\">(<span class=\"keyword\">void</span> *param)</span> </span>&#123;</span><br><span class=\"line\">    NSLog(@<span class=\"string\">&quot;%@ %@&quot;</span>,param,[NSThread currentThread]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"内存布局\"><a href=\"#内存布局\" class=\"headerlink\" title=\"内存布局\"></a>内存布局</h2><ul>\n<li>内存布局从低地址到高地址排序如下<ol>\n<li>保留</li>\n<li>代码段（__TEXT）</li>\n<li>数据段（__DATA）：字符串常量， 已初始化数据，未初始化数据</li>\n<li>堆（heap）</li>\n<li>栈（stack）</li>\n<li>内核区</li>\n</ol>\n</li>\n<li>代码段：编译之后的代码</li>\n<li>数据段：<ul>\n<li>字符串常量</li>\n<li>已初始化数据：已初始化的全局变量、静态变量等</li>\n<li>未初始化数据：未初始化的全局变量、静态变量等</li>\n</ul>\n</li>\n<li>堆：通过alloc、malloc、calloc的那个动态分配的空间，分配的内存空间地址越来越大</li>\n<li>栈：函数调用开销，比如局部变量，分配的内存空间地址越来越小</li>\n</ul>\n<h2 id=\"Tagged-Pointer\"><a href=\"#Tagged-Pointer\" class=\"headerlink\" title=\"Tagged Pointer\"></a>Tagged Pointer</h2><ul>\n<li><p>从64bit开始，iOS引入了Tagged Pointer技术，用于优化<code>NSNumber</code>,<code>NSDate</code>，<code>NSString</code>等小对象的存储</p>\n</li>\n<li><p>在没有使用Tagged Pointer之前，<code>NSNumber</code>等对象需要动态分配内存，维护引用计数的等，<code>NSNumber</code>指针存储的是堆中<code>NSNumber</code>对象的地址值.</p>\n</li>\n<li><p>使用<code>Tagged Pointer</code>之后，<code>NSNumber</code>指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中。</p>\n</li>\n<li><p>在Mac环境下当对象指针的二进制最低有效位是1，则该指针为<code>Tagged Pointer</code>（如果是0那么就是OC对象，因为OC对象分配内存是按照16个字节对齐的，所以最后一位肯定是0）,可以编写如下函数来判断是否是<code>Tagged Pointer</code></p>\n<ul>\n<li>跟1进行与运算，取出最低位判断是不是1即可</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">BOOL <span class=\"title\">isTaggedPointer</span><span class=\"params\">(id pointer)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">long</span>)(__bridge <span class=\"keyword\">void</span> *)pointer &amp; <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果是iOS环境下，则判断的是最高有效位(第64位)是否是1，即<code>(long)(__bridge void *)pointer &amp; 1UL&lt;&lt;63</code></li>\n</ul>\n</li>\n<li><p>当指针不够存储数据时，才会使用动态分配内存来存储数据（比如NSNumber的存储的数字太大了，指针8个十六进制位都装不下）</p>\n</li>\n<li><p><code>objc_msgSend</code>能识别<code>Tagged Pointer</code>，比如<code>NSNumber</code>的intValue方法，直接从指针提取数据，节省了以前的调用开销</p>\n</li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span>(<span class=\"keyword\">copy</span>, <span class=\"keyword\">nonatomic</span>) <span class=\"built_in\">NSString</span> *name;</span><br></pre></td></tr></table></figure>\n\n<p>这个属性的set方法实际为</p>\n<figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)<span class=\"built_in\">setName</span>:(NSString *)<span class=\"built_in\">name</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"variable\">_name</span> != <span class=\"built_in\">name</span>) &#123;</span><br><span class=\"line\">        [<span class=\"variable\">_name</span> release];</span><br><span class=\"line\">        <span class=\"variable\">_name</span> = [<span class=\"built_in\">name</span> retain];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>假如我们这么给<code>name</code>赋值<code>self.name = [NSString stringWithForamt:@&quot;abcdefghijkl&quot;]</code>，因为这个太大了，转不成<code>tagged pointer</code>，那么在多线程环境下，有可能会因为多次执行了<code>[_name release]</code>导致坏内存访问而崩溃</p>\n<p>字符串其实还有其他样子，总的来说，除了<code>__NSCFString</code>，其他类型的字符串都不会调用<code>release</code>方法</p>\n<ul>\n<li><p>__NSCFConstantString</p>\n<p>  字符串常量，是一种编译时常量，它的 retainCount 值很大，是 4294967295，在控制台打印出的数值则是 18446744073709551615==2^64-1，测试证明，即便对其进行 release 操作，retainCount 也不会产生任何变化。是创建之后便是放不掉的对象。<strong>相同内容的 __NSCFConstantString 对象的地址相同，也就是说常量字符串对象是一种单例</strong>。</p>\n<p>  这种对象一般通过字面值 <code>@&quot;...&quot;</code>、<code>CFSTR(&quot;...&quot;)</code> 或者 <code>stringWithString</code>: 方法（需要说明的是，这个方法在 iOS6 SDK 中已经被称为redundant，使用这个方法会产生一条编译器警告。这个方法等同于字面值创建的方法）产生。</p>\n<p>  这种对象存储在字符串常量区。</p>\n</li>\n<li><p>__NSCFString</p>\n<p>  和 <code>__NSCFConstantString</code> 不同， <code>__NSCFString</code>对象是在运行时创建的一种 <code>NSString</code>子类，他并不是一种字符串常量。所以和其他的对象一样在被创建时获得了 1 的引用计数。</p>\n<p>  通过 NSString 的 stringWithFormat 等方法创建的 NSString 对象一般都是这种类型。</p>\n<p>  这种对象被存储在堆上。</p>\n</li>\n<li><p>NSTaggedPointerString</p>\n<p>  理解这个类型，需要明白什么是<code>TaggedPointer</code>，这是苹果在 64 位环境下对 NSString,NSNumber 等对象做的一些优化。简单来讲可以理解为把指针指向的内容直接放在了指针变量的内存地址中，因为在 64 位环境下指针变量的大小达到了 8 位足以容纳一些长度较小的内容。于是使用了标签指针这种方式来优化数据的存储方式。从他的引用计数可以看出，这货也是一个释放不掉的单例常量对象。在运行时根据实际情况创建。</p>\n<p>  对于 <code>NSString</code> 对象来讲，当非字面值常量的数字，英文字母字符串的长度小于等于 9 的时候会自动成为 <code>NSTaggedPointerString</code> 类型，如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为 ）<code>__NSCFString</code> 类型。</p>\n<p>  这种对象被直接存储在指针的内容中，可以当作一种伪对象。</p>\n<p>  当字符串的长度为10个以内时，字符串的类型都是<code>NSTaggedPointerString</code>类型，当超过10个时，字符串的类型才是<code>__NSCFString</code></p>\n</li>\n<li><p>从<code>NSTaggedPointerString</code>中读取出字符串的值</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_MASK (1UL&lt;&lt;63)</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_INDEX_SHIFT 0</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_SLOT_SHIFT 0</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_PAYLOAD_LSHIFT 1</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_PAYLOAD_RSHIFT 4</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_EXT_INDEX_SHIFT 55</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_EXT_SLOT_SHIFT 55</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_EXT_PAYLOAD_LSHIFT 9</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"meta-keyword\">define</span> _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> _objc_isTaggedPointer(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> * _Nullable ptr)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((<span class=\"keyword\">uintptr_t</span>)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">uintptr_t</span> _objc_decodeTaggedPointer(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> * _Nullable ptr)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">uintptr_t</span>)ptr ^ objc_debug_taggedpointer_obfuscator;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">uintptr_t</span> _objc_getTaggedPointerValue(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> * _Nullable ptr) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> value = _objc_decodeTaggedPointer(ptr);</span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> basicTag = (value &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (value &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_RSHIFT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">intptr_t</span> _objc_getTaggedPointerSignedValue(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span> * _Nullable ptr) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> value = _objc_decodeTaggedPointer(ptr);</span><br><span class=\"line\">    <span class=\"keyword\">uintptr_t</span> basicTag = (value &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((<span class=\"keyword\">intptr_t</span>)value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ((<span class=\"keyword\">intptr_t</span>)value &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_RSHIFT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NSNumber\"><a href=\"#NSNumber\" class=\"headerlink\" title=\"NSNumber\"></a>NSNumber</h3><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSNumber</span> *number1 = @(<span class=\"number\">0x1</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *number2 = @(<span class=\"number\">0x20</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *number3 = @(<span class=\"number\">0x3F</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *numberFFFF = @(<span class=\"number\">0xFFFFFFFFFFEFE</span>);</span><br><span class=\"line\"><span class=\"built_in\">NSNumber</span> *maxNum = @(MAXFLOAT);</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;number1 pointer is %p class is %@&quot;</span>, number1, number1.class);</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;number2 pointer is %p class is %@&quot;</span>, number2, number2.class);</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;number3 pointer is %p class is %@&quot;</span>, number3, number3.class);</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;numberffff pointer is %p class is %@&quot;</span>, numberFFFF, numberFFFF.class);</span><br><span class=\"line\"><span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;maxNum pointer is %p class is %@&quot;</span>, maxNum, maxNum.class);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TaggedPointerDemo[<span class=\"number\">59218</span>:<span class=\"number\">2167895</span>] number1 pointer is <span class=\"number\">0xf7cb914ffb51479a</span> <span class=\"keyword\">class</span> is __NSCFNumber</span><br><span class=\"line\">TaggedPointerDemo[<span class=\"number\">59218</span>:<span class=\"number\">2167895</span>] number2 pointer is <span class=\"number\">0xf7cb914ffb51458a</span> <span class=\"keyword\">class</span> is __NSCFNumber</span><br><span class=\"line\">TaggedPointerDemo[<span class=\"number\">59218</span>:<span class=\"number\">2167895</span>] number3 pointer is <span class=\"number\">0xf7cb914ffb51447a</span> <span class=\"keyword\">class</span> is __NSCFNumber</span><br><span class=\"line\">TaggedPointerDemo[<span class=\"number\">59218</span>:<span class=\"number\">2167895</span>] numberffff pointer is <span class=\"number\">0xf7346eb004aea86b</span> <span class=\"keyword\">class</span> is __NSCFNumber</span><br><span class=\"line\">TaggedPointerDemo[<span class=\"number\">59218</span>:<span class=\"number\">2167895</span>] maxNum pointer is <span class=\"number\">0x28172a0c0</span> <span class=\"keyword\">class</span> is __NSCFNumber</span><br></pre></td></tr></table></figure>\n\n<p>我们发现对于<code>NSNumber</code>，我们打印出来的数据类型均为<code>__NSCFNumber</code>,但是我们发现对于MAXFLOAT打印出的地址显然与其他几项不符，上面几个<code>NSNumber</code>的地址以0xf开头，根据字符串地址的经验我们可以看出<code>f = 1111</code>,首位标记位为1，表示这个数据类型属于<code>TaggedPointer</code>。而<code>MAXFLOAT</code>不是。</p>\n<h2 id=\"MRC\"><a href=\"#MRC\" class=\"headerlink\" title=\"MRC\"></a>MRC</h2><ul>\n<li><p>在iOS中，使用<code>引用计数</code>来管理OC对象的内存</p>\n</li>\n<li><p>一个新创建的OC对象的引用计数默认是1，当引用计数减为0，OC对象就会销毁，释放其占用的内存空间</p>\n</li>\n<li><p>调用retain会让OC对象的引用计数+1，调用release会让OC对象的引用计数-1</p>\n</li>\n<li><p>内存管理的经验总结：</p>\n<ul>\n<li>当调用<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>方法返回了一个对象，在不需要这个对象时，要调用<code>release</code>或者<code>autorelease</code>释放它</li>\n<li>想拥有某个对象，就让它的引用计数+1;不想再拥有某个对象，就让它的引用计数-1</li>\n</ul>\n</li>\n<li><p>可以通过以下私有函数来查看自动释放池的情况</p>\n<p>  <code>extern void _objc_autoreleasePoolPrint(void); </code></p>\n</li>\n</ul>\n<p>在ARC中声明<code>@property(nonatomic,assign) int age;</code> 其set方法相当于MRC中的</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setAge:(<span class=\"keyword\">int</span>)age &#123;</span><br><span class=\"line\">    _age = age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在ARC中声明<code>@property(nonatomic,strong) NSObject *age;</code> 其set方法相当于MRC中的</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setAge:(<span class=\"built_in\">NSObject</span> *)age &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_age != age) &#123; <span class=\"comment\">// 防止同个对象释放后引用计数变成0，就不能再retain了</span></span><br><span class=\"line\">        [_age release]; <span class=\"comment\">// 防止新对象进来之后，旧对象的引用计数多出了1导致释放不掉</span></span><br><span class=\"line\">        _age = [age reatin]; <span class=\"comment\">// 引用计数+1，防止被外部一不小心释放了</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>关于Autorelease</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">self.data</span> = [NSMutableArray array]<span class=\"comment\">; // 自动进行了autorelease</span></span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.data = <span class=\"comment\">[<span class=\"comment\">[<span class=\"comment\">[NSMutableArray alloc]</span> init]</span> autorelease]</span>;</span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">self.data</span> = [[NSMutableArray alloc] init]<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"section\">[self.data release]</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NSMutableArray</span> *<span class=\"class\"><span class=\"keyword\">data</span> = [[<span class=\"type\">NSMutableArray</span> alloc] init];</span></span><br><span class=\"line\"><span class=\"title\">self</span>.<span class=\"class\"><span class=\"keyword\">data</span> = <span class=\"keyword\">data</span>;</span></span><br><span class=\"line\">[<span class=\"class\"><span class=\"keyword\">data</span> release];</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"引用计数的存储\"><a href=\"#引用计数的存储\" class=\"headerlink\" title=\"引用计数的存储\"></a>引用计数的存储</h2><p>在64bit中，引用计数可以直接存储在优化过的isa指针中，如果isa指针不够存的话就存储在<code>SiteTable</code>类中（最终的引用计数是两个存储的地方都会取出来值，然后求和）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SideTable</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">spinlock_t</span> slock;</span><br><span class=\"line\">    RefcountMap refcnts;</span><br><span class=\"line\">    <span class=\"keyword\">weak_table_t</span> weak_table;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>refcnts是一个存放着对象引用计数的散列表</li>\n</ul>\n<p>在SiteTable中获取到<code>retainCount</code>的核心代码如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">objc_object::sidetable_getExtraRC_nolock</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ASSERT(isa.nonpointer);</span><br><span class=\"line\">    SideTable&amp; table = SideTables()[<span class=\"keyword\">this</span>];</span><br><span class=\"line\">    RefcountMap::iterator it = table.refcnts.find(<span class=\"keyword\">this</span>); </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (it == table.refcnts.end()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">// 遍历refcnts</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT; <span class=\"comment\">// 进行位运算取出retainCount</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Weak\"><a href=\"#Weak\" class=\"headerlink\" title=\"Weak\"></a>Weak</h2><p> weak指针能够在对象释放的时候把指针清空，具体是怎么做到的。我们需要看一下对象<code>dealloc</code>的过程</p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">objc_object::rootDealloc</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isTaggedPointer()) <span class=\"keyword\">return</span>;  <span class=\"comment\">// fixme necessary?</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fastpath(isa.nonpointer                     &amp;&amp; <span class=\"comment\">// 0代表普通的指针，1代表优化过的指针，使用位域存储信息</span></span><br><span class=\"line\">                 !isa.weakly_referenced             &amp;&amp; <span class=\"comment\">// 是否有弱引用指针</span></span><br><span class=\"line\">                 !isa.has_assoc                     &amp;&amp; <span class=\"comment\">// 是否有设置关联对象</span></span><br><span class=\"line\">                 !isa.has_cxx_dtor                  &amp;&amp; <span class=\"comment\">// 是否有C++即构函数</span></span><br><span class=\"line\">                 !isa.has_sidetable_rc))\t\t\t   <span class=\"comment\">// 引用计数器是不是过大而无法存放在isa中，如果为1，那引用计数会存储在SideTable的类的属性中</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        assert(!sidetable_present());</span><br><span class=\"line\">        <span class=\"built_in\">free</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        object_dispose((id)<span class=\"keyword\">this</span>); <span class=\"comment\">// 显然弱引用指针指向的对象会进入这里</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">id  <span class=\"title\">object_dispose</span><span class=\"params\">(id obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!obj) <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    objc_destructInstance(obj); <span class=\"comment\">// 释放前做一些事情</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(obj); <span class=\"comment\">// 这里才释放</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *<span class=\"title\">objc_destructInstance</span><span class=\"params\">(id obj)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Read all of the flags at once for performance.</span></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// This order is important.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cxx) object_cxxDestruct(obj); <span class=\"comment\">// 清除成员变量</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (assoc) _object_remove_assocations(obj, <span class=\"comment\">/*deallocating*/</span><span class=\"literal\">true</span>); <span class=\"comment\">// 移除关联对象</span></span><br><span class=\"line\">        obj-&gt;clearDeallocating(); <span class=\"comment\">// 将指向当前对象的弱指针置为nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">objc_object::clearDeallocating</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Slow path for raw pointer isa.</span></span><br><span class=\"line\">        sidetable_clearDeallocating();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class=\"line\">        clearDeallocating_slow(); <span class=\"comment\">// 再进入这里</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    assert(!sidetable_present());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\">NEVER_INLINE <span class=\"keyword\">void</span> <span class=\"title\">objc_object::clearDeallocating_slow</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ASSERT(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class=\"line\"></span><br><span class=\"line\">    SideTable&amp; table = SideTables()[<span class=\"keyword\">this</span>]; <span class=\"comment\">// 拿出SiteTables数组，然后取出对应的SiteTable对象</span></span><br><span class=\"line\">    table.lock();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isa.weakly_referenced) &#123;</span><br><span class=\"line\">        weak_clear_no_lock(&amp;table.weak_table, (id)<span class=\"keyword\">this</span>); <span class=\"comment\">// 清除弱引用指针 </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class=\"line\">        table.refcnts.erase(<span class=\"keyword\">this</span>); <span class=\"comment\">// 清除引用计数表</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    table.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>  <span class=\"title\">weak_clear_no_lock</span><span class=\"params\">(<span class=\"keyword\">weak_table_t</span> *weak_table, id referent_id)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    objc_object *referent = (objc_object *)referent_id;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/// 把SiteTable里面的weakTable和指针传进去</span></span><br><span class=\"line\">    <span class=\"keyword\">weak_entry_t</span> *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (entry == nil) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/// XXX shouldn&#x27;t happen, but does with mismatched CF/objc</span></span><br><span class=\"line\">        <span class=\"comment\">//printf(&quot;XXX no entry for clear deallocating %p\\n&quot;, referent);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// zero out references</span></span><br><span class=\"line\">    <span class=\"keyword\">weak_referrer_t</span> *referrers;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> count;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class=\"line\">        referrers = entry-&gt;referrers;</span><br><span class=\"line\">        count = TABLE_SIZE(entry);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        referrers = entry-&gt;inline_referrers;</span><br><span class=\"line\">        count = WEAK_INLINE_COUNT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; count; ++i) &#123;</span><br><span class=\"line\">        objc_object **referrer = referrers[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (referrer) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (*referrer == referent) &#123;</span><br><span class=\"line\">                *referrer = nil;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (*referrer) &#123;</span><br><span class=\"line\">                _objc_inform(<span class=\"string\">&quot;__weak variable at %p holds %p instead of %p. &quot;</span></span><br><span class=\"line\">                             <span class=\"string\">&quot;This is probably incorrect use of &quot;</span></span><br><span class=\"line\">                             <span class=\"string\">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class=\"line\">                             <span class=\"string\">&quot;Break on objc_weak_error to debug.\\n&quot;</span>, </span><br><span class=\"line\">                             referrer, (<span class=\"keyword\">void</span>*)*referrer, (<span class=\"keyword\">void</span>*)referent);</span><br><span class=\"line\">                objc_weak_error();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    weak_entry_remove(weak_table, entry);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">uintptr_t</span> <span class=\"title\">hash_pointer</span><span class=\"params\">(objc_object *key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ptr_hash((<span class=\"keyword\">uintptr_t</span>)key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">weak_entry_t</span> * <span class=\"title\">weak_entry_for_referent</span><span class=\"params\">(<span class=\"keyword\">weak_table_t</span> *weak_table, objc_object *referent)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ASSERT(referent);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">weak_entry_t</span> *weak_entries = weak_table-&gt;weak_entries;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!weak_entries) <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/// 通过与运算得到索引</span></span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> begin = hash_pointer(referent) &amp; weak_table-&gt;mask;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> index = begin;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> hash_displacement = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (weak_table-&gt;weak_entries[index].referent != referent) &#123;</span><br><span class=\"line\">        index = (index+<span class=\"number\">1</span>) &amp; weak_table-&gt;mask;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index == begin) bad_weak_table(weak_table-&gt;weak_entries);</span><br><span class=\"line\">        hash_displacement++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;weak_table-&gt;weak_entries[index];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结：</p>\n<p>Weak指针指向的对象释放流程如下</p>\n<ol>\n<li>清除成员变量，移除关联对象</li>\n<li>拿到对象对应的SiteTable，再取出里面的weak_table</li>\n<li>通过hash后的对象的指针和weak_table进行一次与运算，得到索引，在weak_table中通过索引取出弱引用指针</li>\n<li>置空取出的所有的弱引用指针</li>\n<li>清除引用计数表</li>\n<li>释放对象</li>\n</ol>\n<h2 id=\"Copy和MutableCopy\"><a href=\"#Copy和MutableCopy\" class=\"headerlink\" title=\"Copy和MutableCopy\"></a>Copy和MutableCopy</h2><p>拷贝的目的：产生一个副本对象，跟源对象互不影响<br>修改了源对象，不会影响副本对象<br>修改了副本对象，不会影响源对象</p>\n<p>iOS提供了2个拷贝方法</p>\n<ol>\n<li>copy ，不可变拷贝，产生不可变副本。</li>\n<li>mutableCopy，可变拷贝，产生可变副本。</li>\n<li>浅拷贝：指针拷贝，没有产生新的对象。（不可变对象copy）</li>\n<li>深拷贝：内容拷贝，产生新的对象。(可变、不可变对象调用mutableCopy或者可变对象调用copy)</li>\n</ol>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *str1 = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@&quot;test&quot;</span>];</span><br><span class=\"line\"><span class=\"built_in\">NSString</span> *str2 = [str1 <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 返回的是NSString</span></span><br><span class=\"line\"><span class=\"built_in\">NSMutableString</span> *str3 = [str1 mutableCopy]; <span class=\"comment\">// 返回的是NSMutableString</span></span><br></pre></td></tr></table></figure>\n\n<p>当<code>copy</code>方法被不可变对象调用的话，不会发生什么变化，直接还是返回原来的对象，但是这时候引用计数会加1，相当于<code>retain</code>了一下，所以上面的代码要释放对象的时候，除了调用<code>[str1 release];</code>，那么还得调用<code>[str2 release]；</code></p>\n<p>在ARC中声明<code>@property(nonatomic,copy) NSString *age;</code> 其set方法相当于MRC中的</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)setAge:(<span class=\"built_in\">NSString</span> *)age &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_age != age) &#123;</span><br><span class=\"line\">        [_age release];</span><br><span class=\"line\">        _age = [age <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"AutoRelease\"><a href=\"#AutoRelease\" class=\"headerlink\" title=\"AutoRelease\"></a>AutoRelease</h2><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">    Student *student = [[[Student alloc] init] autorelease];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> __<span class=\"title\">AtAutoreleasePool</span> &#123;</span></span><br><span class=\"line\">  __AtAutoreleasePool() &#123; <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">      atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ~__AtAutoreleasePool() &#123; <span class=\"comment\">// 析构函数</span></span><br><span class=\"line\">      objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> * atautoreleasepoolobj;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    __AtAutoreleasePool __autoreleasepool; <span class=\"comment\">// 创建一个结构体变量</span></span><br><span class=\"line\">    Student *student = objc_msgSend(objc_msgSend(objc_msgSend(objc_getClass(<span class=\"string\">&quot;Student&quot;</span>), sel_registerName(<span class=\"string\">&quot;alloc&quot;</span>)), sel_registerName(<span class=\"string\">&quot;init&quot;</span>)), sel_registerName(<span class=\"string\">&quot;autorelease&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相当于</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class=\"line\">    Student *student = objc_msgSend(objc_msgSend(objc_msgSend(objc_getClass(<span class=\"string\">&quot;Student&quot;</span>), sel_registerName(<span class=\"string\">&quot;alloc&quot;</span>)), sel_registerName(<span class=\"string\">&quot;init&quot;</span>)), sel_registerName(<span class=\"string\">&quot;autorelease&quot;</span>));</span><br><span class=\"line\">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自动释放池的主要底层数据结构是: <code>__AtAutoreleasePool</code>、<code>AutoreleasePoolPage</code></p>\n<p>调用了<code>autorelease</code>的对象最终都是通过<code>AutoreleasePoolPage</code>对象来管的</p>\n<p>源码分析<br>    - clang重写@autoreleasepool<br>    - objc4源码：NSobject.mm</p>\n<h2 id=\"AutoreleasePoolPage的结构\"><a href=\"#AutoreleasePoolPage的结构\" class=\"headerlink\" title=\"AutoreleasePoolPage的结构\"></a>AutoreleasePoolPage的结构</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutoreleasePage</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">magic_t</span> <span class=\"keyword\">const</span> magic;</span><br><span class=\"line\">    id *next;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> <span class=\"keyword\">const</span> thread;</span><br><span class=\"line\">    AutoreleasePoolPage *<span class=\"keyword\">const</span> parent;</span><br><span class=\"line\">    AutoreleasePoolPage *<span class=\"keyword\">const</span> child;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> depth;</span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> hiwat;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放<code>autorelease</code>对象的地址</p>\n</li>\n<li><p>所有的<code>AutoreleasePoolPage</code>对象通过双向链表的形式连接在一起</p>\n</li>\n<li><p>调用push方法会将一个POOL_BOUNDARY入栈，并且返回其存放的内存地址</p>\n</li>\n<li><p>调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送release对象，直到遇到这个POOL_BOUNDARY</p>\n</li>\n<li><p><code>id *next</code>指向了下一个能存放<code>autorelease</code>对象地址的区域</p>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> *<span class=\"title\">push</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">    id *dest;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(DebugPoolAllocation)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Each autorelease pool starts on a new pool page.</span></span><br><span class=\"line\">        dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dest;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">(<span class=\"keyword\">void</span> *token)</span> </span>&#123;</span><br><span class=\"line\">    AutoreleasePoolPage *page;</span><br><span class=\"line\">    id *stop;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (token == (<span class=\"keyword\">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Popping the top-level placeholder pool.</span></span><br><span class=\"line\">        page = hotPage();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!page) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Pool was never used. Clear the placeholder.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> setHotPage(nil);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Pool was used. Pop its contents normally.</span></span><br><span class=\"line\">        <span class=\"comment\">// Pool pages remain allocated for re-use as usual.</span></span><br><span class=\"line\">        page = coldPage();</span><br><span class=\"line\">        token = page-&gt;begin();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        page = pageForPointer(token);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    stop = (id *)token;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (*stop != POOL_BOUNDARY) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Start of coldest page may correctly not be POOL_BOUNDARY:</span></span><br><span class=\"line\">            <span class=\"comment\">// 1. top-level pool is popped, leaving the cold page in place</span></span><br><span class=\"line\">            <span class=\"comment\">// 2. an object is autoreleased with no pool</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Error. For bincompat purposes this is not </span></span><br><span class=\"line\">            <span class=\"comment\">// fatal in executables built with old SDKs.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> badPop(token);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> popPageDebug(token, page, stop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> popPage&lt;<span class=\"literal\">false</span>&gt;(token, page, stop);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Runloop和Autorelease\"><a href=\"#Runloop和Autorelease\" class=\"headerlink\" title=\"Runloop和Autorelease\"></a>Runloop和Autorelease</h3><ul>\n<li>iOS在主线程的Runloop中注册了两个Observer</li>\n<li>第1个Observer监听了<code>kCFRunLoopEntry</code>事件，会调用<code>objc_autoreleasePoolPush()</code></li>\n<li>第2个Observer<ul>\n<li>监听了<code>kCFRunLoopBeforeWaiting</code>会调用<code>objc_autoreleasePoolPop()</code>、<code>objc_autoreleasePoolPush()</code></li>\n<li>监听了<code>kCFRunloopBeforeExit</code>事件，会调用<code>objc_autoreleasePoolPop()</code></li>\n</ul>\n</li>\n</ul>"},{"title":"最近看了一本书...","author":"Arclin","abbrlink":"a4ffdee","date":"2021-08-29T14:59:00.000Z","_content":"最近看了一本 《代码整洁之道》\n\n基本跟我们平时的编码代码规范有点类似吧。里面的一些设计思想是挺好的。这里记录一下一些个人感觉好像挺有用的点。\n\n> 部分内容可能存在争议，请不要在意，以自己团队规范为准。\n\n<!--more-->\n\n## 常量\n\n用命名常量替代魔术数（泛指任何不能自我描述的符号）\n\n命名采用描述性名称，确认名称具有描述性\n\n## 语句\n\n封装条件要抽离解释了条件意图函数，比如 shouldBeDelete(timer) 要优于  (timer.hasExpired && !timer.isRecurrent())\n\n避免否定条件  if（shouldDo） 要好于 if (!shouldNotDo)\n\n## 函数\n\n为较大作用范围选用较长名称\n\n名称应该说明函数、变量或类的一切信息，不要用名称掩蔽副作用。\n\n每个函数只做一件事情\n\n函数参数应该越少越好\n\n不要把输入的参数拿来输出\n\n布尔值参数宣告函数做了不止一件事情，违反了单一职责原则，应该消灭掉\n\n用布尔、枚举、整数等参数用于判断流程来决定函数行为是不好的，使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\n\n使用异常替代返回错误码\n\n抽离Try/Catch代码块\n\n把重复代码抽离出来\n\n通常应该倾向于选用非静态方法。如果的确需要静态函数，确保没机会打算让他有多态行为。\n\n函数名称应该表达其行为\n\n如果多个函数的调用有时序性，比如必须先调用A才能调用B，要显式声明时序性，比如调用B函数的时候把A函数作为参数传进去，这样子就保证别人不会误把B函数放在A函数前调用\n\n\n## 格式\n\n顶部给出高层次概念和算法。细节应该往下渐次展开，直至找到原文件中最底层的函数和细节\n\n如果某个函数调用了另外一个，就应该把它们放在一起，而且调用者应该尽可能放在被调用者上面，\n\n概念相关的代码应该放到一起，相关性越强，彼此之间的距离就该越短\n\n## 对象\n\n过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数\n面向对象代码便于在不改动既有函数的前提下添加新类\n\n过程式代码难以添加新数据结构，因为必须修改所有函数。\n面向对象代码难以添加新函数，因为必须修改所有类。\n\n迪米特法则：模块不应了解它所操作对象的内部情形。\n隐藏结构：`let a = b.c().e().f()`\n拆分成\n\n```\nlet c = b.c()\nlet e = c.e()\nlet a = e.f()\n```\n\n应该改成\n`let a = b.func()`\n\n在方法中，不应该调用其他对象的方法\n\n```\nfunc test(let obj) {\n    let item = obj.func()\n    item.func() // 不可以\n}\n```\n\n类C的方法f只能调用以下对象的方法\n\n- C\n- 由f创建的对象\n- 作为参数传递给f的对象\n- 由C的实体变量持有的对象\n\n用多态替代if/else 或 switch/case\n\n## 错误处理\n\n不要使用错误码，用try-catch代替\n\n不要返回null值，用空对象替代，或者抛出异常\n\n不要传入null值作为参数，除非API要求你这么做\n\n## 边界\n\n使用泛型限制输入\n\n单元测试\n\n单元测试应当简单、精悍、足具表达力。\n\n测试代码和生产代码一样重要\n\nTDD三定律：\n1. 在编写不能通过的单元测试前，不可编写生产代码\n2. 只可编写刚好无法通过的单元测试，不能编译也不算通过\n3. 只可编写刚好足以通过当前失败测试的生产代码\n\n每一个测试一个断言\n- 每一个测试一个概念\n- 一个概念可以多个断言\n\n简洁的测试应该遵循5条规则\n（FIRST: FAST、Independent、Repeatable、Self-Validating、Timely）\n1. 快速：测试应该够快\n2. 独立：测试应该互相独立，某个测试不应为下一个测试设定条件\n3. 可重复：测试应当可在任何环境中重复通过\n4. 自足验证：测试应该有布尔值输出\n5. 及时：测试应及时编写\n\n## 类\n\n类应该短小，遵循单一职责原则（类或模块应有且只有一条加以修改的理由）\n\n类应该只有少量实体变量\n\n当类丧失了内聚性，就拆分它\n\n类的方法只应对其所属类中的变量和函数感兴趣，不应该垂青其他类中的变量和函数\n","source":"_posts/最近看了一本书.md","raw":"title: 最近看了一本书...\nauthor: Arclin\nabbrlink: a4ffdee\ntags:\n  - 技巧\n  - 架构\ncategories:\n  - 杂谈\ndate: 2021-08-29 22:59:00\n---\n最近看了一本 《代码整洁之道》\n\n基本跟我们平时的编码代码规范有点类似吧。里面的一些设计思想是挺好的。这里记录一下一些个人感觉好像挺有用的点。\n\n> 部分内容可能存在争议，请不要在意，以自己团队规范为准。\n\n<!--more-->\n\n## 常量\n\n用命名常量替代魔术数（泛指任何不能自我描述的符号）\n\n命名采用描述性名称，确认名称具有描述性\n\n## 语句\n\n封装条件要抽离解释了条件意图函数，比如 shouldBeDelete(timer) 要优于  (timer.hasExpired && !timer.isRecurrent())\n\n避免否定条件  if（shouldDo） 要好于 if (!shouldNotDo)\n\n## 函数\n\n为较大作用范围选用较长名称\n\n名称应该说明函数、变量或类的一切信息，不要用名称掩蔽副作用。\n\n每个函数只做一件事情\n\n函数参数应该越少越好\n\n不要把输入的参数拿来输出\n\n布尔值参数宣告函数做了不止一件事情，违反了单一职责原则，应该消灭掉\n\n用布尔、枚举、整数等参数用于判断流程来决定函数行为是不好的，使用多个函数，通常优于向单个函数传递某些代码来选择函数行为\n\n使用异常替代返回错误码\n\n抽离Try/Catch代码块\n\n把重复代码抽离出来\n\n通常应该倾向于选用非静态方法。如果的确需要静态函数，确保没机会打算让他有多态行为。\n\n函数名称应该表达其行为\n\n如果多个函数的调用有时序性，比如必须先调用A才能调用B，要显式声明时序性，比如调用B函数的时候把A函数作为参数传进去，这样子就保证别人不会误把B函数放在A函数前调用\n\n\n## 格式\n\n顶部给出高层次概念和算法。细节应该往下渐次展开，直至找到原文件中最底层的函数和细节\n\n如果某个函数调用了另外一个，就应该把它们放在一起，而且调用者应该尽可能放在被调用者上面，\n\n概念相关的代码应该放到一起，相关性越强，彼此之间的距离就该越短\n\n## 对象\n\n过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数\n面向对象代码便于在不改动既有函数的前提下添加新类\n\n过程式代码难以添加新数据结构，因为必须修改所有函数。\n面向对象代码难以添加新函数，因为必须修改所有类。\n\n迪米特法则：模块不应了解它所操作对象的内部情形。\n隐藏结构：`let a = b.c().e().f()`\n拆分成\n\n```\nlet c = b.c()\nlet e = c.e()\nlet a = e.f()\n```\n\n应该改成\n`let a = b.func()`\n\n在方法中，不应该调用其他对象的方法\n\n```\nfunc test(let obj) {\n    let item = obj.func()\n    item.func() // 不可以\n}\n```\n\n类C的方法f只能调用以下对象的方法\n\n- C\n- 由f创建的对象\n- 作为参数传递给f的对象\n- 由C的实体变量持有的对象\n\n用多态替代if/else 或 switch/case\n\n## 错误处理\n\n不要使用错误码，用try-catch代替\n\n不要返回null值，用空对象替代，或者抛出异常\n\n不要传入null值作为参数，除非API要求你这么做\n\n## 边界\n\n使用泛型限制输入\n\n单元测试\n\n单元测试应当简单、精悍、足具表达力。\n\n测试代码和生产代码一样重要\n\nTDD三定律：\n1. 在编写不能通过的单元测试前，不可编写生产代码\n2. 只可编写刚好无法通过的单元测试，不能编译也不算通过\n3. 只可编写刚好足以通过当前失败测试的生产代码\n\n每一个测试一个断言\n- 每一个测试一个概念\n- 一个概念可以多个断言\n\n简洁的测试应该遵循5条规则\n（FIRST: FAST、Independent、Repeatable、Self-Validating、Timely）\n1. 快速：测试应该够快\n2. 独立：测试应该互相独立，某个测试不应为下一个测试设定条件\n3. 可重复：测试应当可在任何环境中重复通过\n4. 自足验证：测试应该有布尔值输出\n5. 及时：测试应及时编写\n\n## 类\n\n类应该短小，遵循单一职责原则（类或模块应有且只有一条加以修改的理由）\n\n类应该只有少量实体变量\n\n当类丧失了内聚性，就拆分它\n\n类的方法只应对其所属类中的变量和函数感兴趣，不应该垂青其他类中的变量和函数\n","slug":"最近看了一本书","published":1,"updated":"2021-08-29T15:04:10.654Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksxcg3ow0002h7n0006mhqfz","content":"<p>最近看了一本 《代码整洁之道》</p>\n<p>基本跟我们平时的编码代码规范有点类似吧。里面的一些设计思想是挺好的。这里记录一下一些个人感觉好像挺有用的点。</p>\n<blockquote>\n<p>部分内容可能存在争议，请不要在意，以自己团队规范为准。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h2><p>用命名常量替代魔术数（泛指任何不能自我描述的符号）</p>\n<p>命名采用描述性名称，确认名称具有描述性</p>\n<h2 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h2><p>封装条件要抽离解释了条件意图函数，比如 shouldBeDelete(timer) 要优于  (timer.hasExpired &amp;&amp; !timer.isRecurrent())</p>\n<p>避免否定条件  if（shouldDo） 要好于 if (!shouldNotDo)</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>为较大作用范围选用较长名称</p>\n<p>名称应该说明函数、变量或类的一切信息，不要用名称掩蔽副作用。</p>\n<p>每个函数只做一件事情</p>\n<p>函数参数应该越少越好</p>\n<p>不要把输入的参数拿来输出</p>\n<p>布尔值参数宣告函数做了不止一件事情，违反了单一职责原则，应该消灭掉</p>\n<p>用布尔、枚举、整数等参数用于判断流程来决定函数行为是不好的，使用多个函数，通常优于向单个函数传递某些代码来选择函数行为</p>\n<p>使用异常替代返回错误码</p>\n<p>抽离Try/Catch代码块</p>\n<p>把重复代码抽离出来</p>\n<p>通常应该倾向于选用非静态方法。如果的确需要静态函数，确保没机会打算让他有多态行为。</p>\n<p>函数名称应该表达其行为</p>\n<p>如果多个函数的调用有时序性，比如必须先调用A才能调用B，要显式声明时序性，比如调用B函数的时候把A函数作为参数传进去，这样子就保证别人不会误把B函数放在A函数前调用</p>\n<h2 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h2><p>顶部给出高层次概念和算法。细节应该往下渐次展开，直至找到原文件中最底层的函数和细节</p>\n<p>如果某个函数调用了另外一个，就应该把它们放在一起，而且调用者应该尽可能放在被调用者上面，</p>\n<p>概念相关的代码应该放到一起，相关性越强，彼此之间的距离就该越短</p>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><p>过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数<br>面向对象代码便于在不改动既有函数的前提下添加新类</p>\n<p>过程式代码难以添加新数据结构，因为必须修改所有函数。<br>面向对象代码难以添加新函数，因为必须修改所有类。</p>\n<p>迪米特法则：模块不应了解它所操作对象的内部情形。<br>隐藏结构：<code>let a = b.c().e().f()</code><br>拆分成</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">c</span> = b.c()</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">e</span> = c.e()</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">a</span> = e.f()</span><br></pre></td></tr></table></figure>\n\n<p>应该改成<br><code>let a = b.func()</code></p>\n<p>在方法中，不应该调用其他对象的方法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test</span>(<span class=\"keyword\">let</span> obj)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> item <span class=\"operator\">=</span> obj.func()</span><br><span class=\"line\">    item.func() <span class=\"comment\">// 不可以</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类C的方法f只能调用以下对象的方法</p>\n<ul>\n<li>C</li>\n<li>由f创建的对象</li>\n<li>作为参数传递给f的对象</li>\n<li>由C的实体变量持有的对象</li>\n</ul>\n<p>用多态替代if/else 或 switch/case</p>\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><p>不要使用错误码，用try-catch代替</p>\n<p>不要返回null值，用空对象替代，或者抛出异常</p>\n<p>不要传入null值作为参数，除非API要求你这么做</p>\n<h2 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h2><p>使用泛型限制输入</p>\n<p>单元测试</p>\n<p>单元测试应当简单、精悍、足具表达力。</p>\n<p>测试代码和生产代码一样重要</p>\n<p>TDD三定律：</p>\n<ol>\n<li>在编写不能通过的单元测试前，不可编写生产代码</li>\n<li>只可编写刚好无法通过的单元测试，不能编译也不算通过</li>\n<li>只可编写刚好足以通过当前失败测试的生产代码</li>\n</ol>\n<p>每一个测试一个断言</p>\n<ul>\n<li>每一个测试一个概念</li>\n<li>一个概念可以多个断言</li>\n</ul>\n<p>简洁的测试应该遵循5条规则<br>（FIRST: FAST、Independent、Repeatable、Self-Validating、Timely）</p>\n<ol>\n<li>快速：测试应该够快</li>\n<li>独立：测试应该互相独立，某个测试不应为下一个测试设定条件</li>\n<li>可重复：测试应当可在任何环境中重复通过</li>\n<li>自足验证：测试应该有布尔值输出</li>\n<li>及时：测试应及时编写</li>\n</ol>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><p>类应该短小，遵循单一职责原则（类或模块应有且只有一条加以修改的理由）</p>\n<p>类应该只有少量实体变量</p>\n<p>当类丧失了内聚性，就拆分它</p>\n<p>类的方法只应对其所属类中的变量和函数感兴趣，不应该垂青其他类中的变量和函数</p>\n","site":{"data":{}},"excerpt":"<p>最近看了一本 《代码整洁之道》</p>\n<p>基本跟我们平时的编码代码规范有点类似吧。里面的一些设计思想是挺好的。这里记录一下一些个人感觉好像挺有用的点。</p>\n<blockquote>\n<p>部分内容可能存在争议，请不要在意，以自己团队规范为准。</p>\n</blockquote>","more":"<h2 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h2><p>用命名常量替代魔术数（泛指任何不能自我描述的符号）</p>\n<p>命名采用描述性名称，确认名称具有描述性</p>\n<h2 id=\"语句\"><a href=\"#语句\" class=\"headerlink\" title=\"语句\"></a>语句</h2><p>封装条件要抽离解释了条件意图函数，比如 shouldBeDelete(timer) 要优于  (timer.hasExpired &amp;&amp; !timer.isRecurrent())</p>\n<p>避免否定条件  if（shouldDo） 要好于 if (!shouldNotDo)</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>为较大作用范围选用较长名称</p>\n<p>名称应该说明函数、变量或类的一切信息，不要用名称掩蔽副作用。</p>\n<p>每个函数只做一件事情</p>\n<p>函数参数应该越少越好</p>\n<p>不要把输入的参数拿来输出</p>\n<p>布尔值参数宣告函数做了不止一件事情，违反了单一职责原则，应该消灭掉</p>\n<p>用布尔、枚举、整数等参数用于判断流程来决定函数行为是不好的，使用多个函数，通常优于向单个函数传递某些代码来选择函数行为</p>\n<p>使用异常替代返回错误码</p>\n<p>抽离Try/Catch代码块</p>\n<p>把重复代码抽离出来</p>\n<p>通常应该倾向于选用非静态方法。如果的确需要静态函数，确保没机会打算让他有多态行为。</p>\n<p>函数名称应该表达其行为</p>\n<p>如果多个函数的调用有时序性，比如必须先调用A才能调用B，要显式声明时序性，比如调用B函数的时候把A函数作为参数传进去，这样子就保证别人不会误把B函数放在A函数前调用</p>\n<h2 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h2><p>顶部给出高层次概念和算法。细节应该往下渐次展开，直至找到原文件中最底层的函数和细节</p>\n<p>如果某个函数调用了另外一个，就应该把它们放在一起，而且调用者应该尽可能放在被调用者上面，</p>\n<p>概念相关的代码应该放到一起，相关性越强，彼此之间的距离就该越短</p>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><p>过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数<br>面向对象代码便于在不改动既有函数的前提下添加新类</p>\n<p>过程式代码难以添加新数据结构，因为必须修改所有函数。<br>面向对象代码难以添加新函数，因为必须修改所有类。</p>\n<p>迪米特法则：模块不应了解它所操作对象的内部情形。<br>隐藏结构：<code>let a = b.c().e().f()</code><br>拆分成</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">c</span> = b.c()</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">e</span> = c.e()</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">a</span> = e.f()</span><br></pre></td></tr></table></figure>\n\n<p>应该改成<br><code>let a = b.func()</code></p>\n<p>在方法中，不应该调用其他对象的方法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test</span>(<span class=\"keyword\">let</span> obj)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> item <span class=\"operator\">=</span> obj.func()</span><br><span class=\"line\">    item.func() <span class=\"comment\">// 不可以</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类C的方法f只能调用以下对象的方法</p>\n<ul>\n<li>C</li>\n<li>由f创建的对象</li>\n<li>作为参数传递给f的对象</li>\n<li>由C的实体变量持有的对象</li>\n</ul>\n<p>用多态替代if/else 或 switch/case</p>\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><p>不要使用错误码，用try-catch代替</p>\n<p>不要返回null值，用空对象替代，或者抛出异常</p>\n<p>不要传入null值作为参数，除非API要求你这么做</p>\n<h2 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h2><p>使用泛型限制输入</p>\n<p>单元测试</p>\n<p>单元测试应当简单、精悍、足具表达力。</p>\n<p>测试代码和生产代码一样重要</p>\n<p>TDD三定律：</p>\n<ol>\n<li>在编写不能通过的单元测试前，不可编写生产代码</li>\n<li>只可编写刚好无法通过的单元测试，不能编译也不算通过</li>\n<li>只可编写刚好足以通过当前失败测试的生产代码</li>\n</ol>\n<p>每一个测试一个断言</p>\n<ul>\n<li>每一个测试一个概念</li>\n<li>一个概念可以多个断言</li>\n</ul>\n<p>简洁的测试应该遵循5条规则<br>（FIRST: FAST、Independent、Repeatable、Self-Validating、Timely）</p>\n<ol>\n<li>快速：测试应该够快</li>\n<li>独立：测试应该互相独立，某个测试不应为下一个测试设定条件</li>\n<li>可重复：测试应当可在任何环境中重复通过</li>\n<li>自足验证：测试应该有布尔值输出</li>\n<li>及时：测试应及时编写</li>\n</ol>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><p>类应该短小，遵循单一职责原则（类或模块应有且只有一条加以修改的理由）</p>\n<p>类应该只有少量实体变量</p>\n<p>当类丧失了内聚性，就拆分它</p>\n<p>类的方法只应对其所属类中的变量和函数感兴趣，不应该垂青其他类中的变量和函数</p>"},{"title":"iOS --- 性能优化","author":"Arclin","abbrlink":"a2ff8280","date":"2021-08-31T13:42:00.000Z","_content":"本文主要介绍iOS内常用的性能优化方案\n\n<!-- more -->\n\n## CPU和GPU\n\n- 在屏幕成像的过程中，CPU和GPU起着至关重要的作用\n\t- CPU \n\t\t- 对象的创建和销毁，对象属性的调整、布局计算、文本的计算和排版、图片格式转换和解码、图像的绘制 \n\t- GPU\n\t\t- 纹理的渲染\n\n- 在iOS中是双缓冲机制，有前帧缓存、后帧缓存（）\n\t\t\n```\nCPU->计算->GPU->渲染->帧缓存->读取->视频控制器->显示->屏幕   \n```\n\n## 屏幕成像原理\n\n首先先发出一个垂直同步信号（VSync），然后再一行行发出水平同步信号（HSync），直到最后一行HSync发出之后，一帧就渲染完成，然后再次发出一个VSync，渲染下一帧。\n\n<img src=\"https://i.loli.net/2021/08/31/hWqVypmfbtga4eK.png\" >\n\n## 卡顿\n\n### 卡顿产生的原因\n\n![1682758-5be402cc0ab5dc56.png](https://i.loli.net/2021/08/31/ZTNhbeyRiq8UgmV.png)\n\n1. 首先第一个VSync进入，CPU开始计算处理，然后交给GPU渲染，然后显示到屏幕上\n2. 然后第二个VSync进入，这时候CPU处理的时间比较长，交给GPU后， GPU还没处理完，第三个VSync就进来了，但是因为GPU没处理完。第二帧还不能显示，所以这时候直接取上一帧数据显示，造成第一帧长时间停留\n3. 然后过了一段时间GPU终于处理完了，但是第四个VSync还没来，所以就等，等到第四个VSync进来了，就开始拿刚才生成好的那一帧去显示，然后开始继续第三帧的计算\n\n- 解决卡顿的主要思路\n\t- 尽可能减少CPU、GPU资源损耗\n- 按照60fps的刷新率，每个16ms就会有一次VSync信号 \n\n### 卡顿检测\n\n- 平时所说的__卡顿__主要是因为在主线程执行了比较耗时的操作\n- 可以添加`Observer`到主线程`Runloop`中，通过监听`Runloop`状态切换的耗时，以达到监控卡顿的目的\n\n> 参考：[LXDAppFluecyMonitor](https://github.com/UIControl/LXDAppFluecyMonitor/blob/master/LXDAppFluecyMonitor/LXDAppFluecyMonitor/LXDAppFluecyMonitor.m)\n\n```objectivec\nstatic void lxdRunLoopObserverCallback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void * info) {\n     /// 更新当前Runloop状态\n    SHAREDMONITOR.currentActivity = activity;\n    dispatch_semaphore_signal(SHAREDMONITOR.semphore);\n};\n\n- (void)startMonitoring {\n    if (_isMonitoring) { return; }\n    _isMonitoring = YES;\n    CFRunLoopObserverContext context = {\n        0,\n        (__bridge void *)self,\n        NULL,\n        NULL\n    };\n    /// 创建监听对象\n    _observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &lxdRunLoopObserverCallback, &context);\n    /// 在CommonModes添加监听者\n    CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);\n    \n    /// 子线程异步串行队列中添加死循环\n    dispatch_async(lxd_event_monitor_queue(), ^{\n        while (SHAREDMONITOR.isMonitoring) {\n        \t/// 如果当前状态是BeforeWaiting（即将进入休眠）的话\n            if (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeWaiting) {\n                __block BOOL timeOut = YES;\n                dispatch_async(dispatch_get_main_queue(), ^{\n                    timeOut = NO; // 即将休眠的时候回到主线程超时状态改为NO\n                    dispatch_semaphore_signal(SHAREDMONITOR.eventSemphore); //解锁\n                });\n                [NSThread sleepForTimeInterval: lxd_time_out_interval]; // 子线程休眠一秒\n                if (timeOut) {\n                    [LXDBacktraceLogger lxd_logMain]; // 打印堆栈\n                }\n                dispatch_wait(SHAREDMONITOR.eventSemphore, DISPATCH_TIME_FOREVER); // 加锁\n            }\n        }\n    });\n    \n    dispatch_async(lxd_fluecy_monitor_queue(), ^{\n        while (SHAREDMONITOR.isMonitoring) {\n            long waitTime = dispatch_semaphore_wait(self.semphore, dispatch_time(DISPATCH_TIME_NOW, lxd_wait_interval)); // 等待200纳秒，看是否能拿到锁\n            if (waitTime != LXD_SEMPHORE_SUCCESS) { // 拿不到锁\n                if (!SHAREDMONITOR.observer) {\n                    SHAREDMONITOR.timeOut = 0;\n                    [SHAREDMONITOR stopMonitoring];\n                    continue;\n                }\n                /// Runloop 即将处理Source或者刚从休眠中唤醒\n                if (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeSources || SHAREDMONITOR.currentActivity == kCFRunLoopAfterWaiting) {\n                    if (++SHAREDMONITOR.timeOut < 5) { // 超时次数+1，然后如果超时次数大于5次就打印堆栈\n                        continue;\n                    }\n                    [LXDBacktraceLogger lxd_logMain];\n                    [NSThread sleepForTimeInterval: lxd_restore_interval];\n                }\n            }\n            SHAREDMONITOR.timeOut = 0;\n        }\n    });\n}\n```\n\n### 卡顿优化 - CPU\n\n- 尽量使用轻量级的对象，比如用不到事件处理的地方，可以考虑使用`CALayer`（只是拿来渲染）取代`UIView`（渲染+处理点击事件等）\n- 不要频繁地调用`UIView`的相关属性，比如`frame`、`bounds`、`transform`等属性，尽量减少不必要的修改\n- 尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性\n- Autolayout会比直接设置frame消耗更多的CPU资源\n- 图片的Size最好跟UIImageView的size保持一致\n- 控制一下线程的最大并发数量\n- 尽量把耗时操作放到子线程\n\t- 文本处理（尺寸计算、绘制）\n\t- 图片处理（解码、绘制）\n\n图片子线程解码举例\n\n```objectivec\n- (void)renderImage {\n    \n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        /// get CGImage\n        CGImageRef cgImage = [UIImage imageWithData:[NSData dataWithContentsOfURL:xxx]].CGImage;\n        \n        size_t width = CGImageGetWidth(cgImage);\n        size_t height = CGImageGetHeight(cgImage);\n        if (width == 0 || height == 0) return;\n        \n        CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(cgImage);\n        BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||\n                          alphaInfo == kCGImageAlphaNoneSkipFirst ||\n                          alphaInfo == kCGImageAlphaNoneSkipLast);\n\n        \n        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;\n        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;\n        CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, CGColorSpaceCreateDeviceRGB(), bitmapInfo);\n        if (!context) {\n            return;\n        }\n        \n        // Apply transform\n        CGAffineTransform transform = CGAffineTransformIdentity;\n        CGContextConcatCTM(context, transform);\n        CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgImage); // The rect is bounding box of CGImage, don't swap width & height\n        CGImageRef newImageRef = CGBitmapContextCreateImage(context);\n        CGContextRelease(context);\n        \n        // back to the main thread\n        dispatch_async(dispatch_get_main_queue(), ^{\n            self.imageView.image = [[UIImage alloc] initWithCGImage:newImageRef];\n            CGImageRelease(newImageRef);\n        });\n    });\n}\n```\n\n### 卡顿优化 - GPU\n\n- 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示\n- GPU能处理的最大纹理尺寸是**4096*4096**，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸\n- 尽量减少视图数量和层次\n- 减少透明的视图（alpha < 1），不透明的就设置`opaque`为`YES`\n- 尽量避免出现离屏渲染\n\n#### 离屏渲染\n\n- 在OpenGL中，GPU有2种渲染方式\n\t- On-Screen Rendering：当前离屏渲染，在当前用于显示屏幕缓冲区进行渲染操作\n\t- Off-Screen Rendering: 离屏渲染，在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作 \n\n- 离屏渲染消耗性能的原因\n\t- 需要创建新的缓冲区\n\t- 离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）;等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕上。\n\n- 哪些操作会触发离屏渲染\n\t- 光栅化，`layer.shouldRasterize = YES`\n\t- 遮罩 `layer.mask`\n\t- 圆角，同时设置 `layouer.maskToBounds = YES`, `layer.cornerRadius`大于0\n\t\t- 考虑通过`CoreGraphics`绘制裁剪圆角，或者叫美工提供圆角图片\n\t- 阴影，`layer.shadowXXX`\n\t\t- 如果设置了`layer.shadowPath`就不会产生离屏渲染\n\n## 耗电优化\n\n### 主要来源\n\n- CPU处理，Processing\n- 网络，Networking\n- 定位，Location\n- 图像，Graphics\n\n### 优化\n\n- 尽可能降低CPU、GPU功耗\n- 少用定时器\n- 优化I/O操作\n\t- 尽量不要频繁写入小数据，最好批量一次性写入 \n\t- 读写大量重要数据时，考虑使用`dispatch_io`，其提供了基于GCD的异步操作文件的I/O的API.用`dispatch_io`系统会优化磁盘访问\n\t- 数据量比较大的，建议使用数据库(SQLite、CoreData)\n\n- 网络优化\n\t- 减少、压缩网络数据\n\t- 如果多次请求结果是相同的，尽量使用缓存\n\t- 使用断点续传，否则网络不稳定时可能多次传输相同的内容\n\t- 网络不可用时，不要尝试执行网络请求\n\t- 让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间\n\t- 批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载，如果下载广告，一次性多下载一些，然后再慢慢展示，如果下载电子邮件，一次下载多封，不要一封一封地下载\n\n- 定位优化\n\t- 如果只是需要快速确定用户当前位置，最好用`CLLocationManager`的`requestLocation`方法，定位完成后，会自动让定位硬件断电\n\t- 如果不是导航应用， 尽量不要实时更新位置，定位关闭就关掉定位服务\n\t- 尽量降低定位精度，比如尽量不要使用精度最高的`kCLLocationAccuracyBest`\n\t- 需要后台定位时，尽量设置`pausesLocationUpdatesAutomatically`为YES，如果用户不太可能移动的时候，系统会自动暂停位置更新\n\t- 尽量不要使用`startMonitoringSignificantLocationChanges`，优先考虑`startMonitoringForRegion:`\n\n- 硬件检测优化\n\t- 用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件。\n\n## App启动优化\n\n- App的启动可以分为2种\n\t- 冷启动（Code Launch）：从零开始启动App\n\t- 热启动（Warm Launch）：App已经在内存中，在后台存活着，再次点击图标\n\n- App启动时间的优化，主要是针对冷启动进行优化\n- 通过添加环境变量可以打印出App的启动时间分析（Edit Scheme -> Run -> Arguments）\n\t- `DYLD_PRINT_STATISTICS`设置为1 或者 `DYLD_PRINT_STATISTICS_DETAILS` （更加详细 ）\n \t\n- App的冷启动可以概括为3大阶段\n\t- dyld\n\t- runtime\n\t- main\n\t<img src=\"https://i.loli.net/2021/08/31/ldg1cjZCUPe5Gk6.png\" >\n\t\n\n  - dyld（dynamic link editor），Apple的动态链接器，可以用来装在Mach-O文件（可执行文件、动态库等 ）\n  - 启动App时，dyld所做的事情有\n      - 装载App的可执行文件，同时会递归加载所有依赖的动态库\n      - 当dyld把可执行文件、动态库都装载到内存完毕后，会通知Runtime进行下一步的处理\n  - 启动App时，runtime所做的事情有\n      - 调用`map_images`进行可执行文件内容的解析和处理\n      - 在`load_images`中调用`call_load_methods`,调用所有`Class`和`Category`的`+load`方法\n      - 进行各种objc结构的初始化（注册Objc类，初始化类对象等等）\n      - 调用C++静态初始化器和`__attribute((constructor))`修饰的函数\n  - 到此为止，可执行文件和动态库中所有的符号（Class、Protocol、Selector、IMP、...）都已经按格式成功加载到内存中，被`runtime`所管理\n  -  总结\n      - App的启动由dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库\n      - 并由runtime负责加载成objc定义的结构\n      - 所有初始化工作结束后，dyld就会调用main函数\n      - 接下来就是`UIApplicationMain`函数，AppDelegate的`application:didFinishLaunchingWithOptions:`方法\n\n### 优化方案\n\n- 按照不同的阶段\n\t- dyld \n\t\t- 减少动态库，合并一些动态库（定期清理不必要的动态库）\n\t\t- 减少Objc类，分类的数量，减少selector的数量（定期清理不必要的类，分类）\n\t\t- 减少C++虚函数数量\n\t\t- Swift尽量使用struct\n\t- runtime\n\t\t- 用`+initialize`和`dispatch_once`取代所有的`__attribute((constructor))`、C++静态构造器 、ObjC的`+load`\n\t- main\n\t\t- 在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在`finishLaunch`方法中\n\t\t- 按需加载 \n\n## 安装包瘦身\n\n- 安装包（IPA）主要由可执行文件、资源组成\n\n- 资源（图片、视频、音频等）\n\t- 采取无损压缩\n\t- 去除没有用到的资源(github :LSUnusedResources）\n\n- 可执行文件瘦身\n\t- 编译器优化 \n\t\t- Strip Linked Product 、 Make Strings Read-Only、 Symbols Hidden By Defaults设置为YES\n\t\t- 去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions 设置为NO，Other C Flags  添加 -fno-exceptions\n\t- 利用AppCode([https://www.jetbrains.com/objc](https://www.jetbrains.com/objc))检测未使用的代码：菜单栏 -> Code -> Inspect Code\n\t- 编写LLVM插件检测出重复代码，未被调用的代码\n\t- 生成Link Map文件，可以查看可执行文件的具体组成（在Build Setting->Write Link Map File 改为true，就可以在Path to link map file 看到这个文件）\n\t- 可以借助第三方工具解析LinkMap文件：[https://github.com/huanxsd/LinkMap](https://github.com/huanxsd/LinkMap)","source":"_posts/iOS-性能优化.md","raw":"title: iOS --- 性能优化\nauthor: Arclin\ntags:\n  - iOS\n  - 底层原理\ncategories:\n  - iOS\nabbrlink: a2ff8280\ndate: 2021-08-31 21:42:00\n---\n本文主要介绍iOS内常用的性能优化方案\n\n<!-- more -->\n\n## CPU和GPU\n\n- 在屏幕成像的过程中，CPU和GPU起着至关重要的作用\n\t- CPU \n\t\t- 对象的创建和销毁，对象属性的调整、布局计算、文本的计算和排版、图片格式转换和解码、图像的绘制 \n\t- GPU\n\t\t- 纹理的渲染\n\n- 在iOS中是双缓冲机制，有前帧缓存、后帧缓存（）\n\t\t\n```\nCPU->计算->GPU->渲染->帧缓存->读取->视频控制器->显示->屏幕   \n```\n\n## 屏幕成像原理\n\n首先先发出一个垂直同步信号（VSync），然后再一行行发出水平同步信号（HSync），直到最后一行HSync发出之后，一帧就渲染完成，然后再次发出一个VSync，渲染下一帧。\n\n<img src=\"https://i.loli.net/2021/08/31/hWqVypmfbtga4eK.png\" >\n\n## 卡顿\n\n### 卡顿产生的原因\n\n![1682758-5be402cc0ab5dc56.png](https://i.loli.net/2021/08/31/ZTNhbeyRiq8UgmV.png)\n\n1. 首先第一个VSync进入，CPU开始计算处理，然后交给GPU渲染，然后显示到屏幕上\n2. 然后第二个VSync进入，这时候CPU处理的时间比较长，交给GPU后， GPU还没处理完，第三个VSync就进来了，但是因为GPU没处理完。第二帧还不能显示，所以这时候直接取上一帧数据显示，造成第一帧长时间停留\n3. 然后过了一段时间GPU终于处理完了，但是第四个VSync还没来，所以就等，等到第四个VSync进来了，就开始拿刚才生成好的那一帧去显示，然后开始继续第三帧的计算\n\n- 解决卡顿的主要思路\n\t- 尽可能减少CPU、GPU资源损耗\n- 按照60fps的刷新率，每个16ms就会有一次VSync信号 \n\n### 卡顿检测\n\n- 平时所说的__卡顿__主要是因为在主线程执行了比较耗时的操作\n- 可以添加`Observer`到主线程`Runloop`中，通过监听`Runloop`状态切换的耗时，以达到监控卡顿的目的\n\n> 参考：[LXDAppFluecyMonitor](https://github.com/UIControl/LXDAppFluecyMonitor/blob/master/LXDAppFluecyMonitor/LXDAppFluecyMonitor/LXDAppFluecyMonitor.m)\n\n```objectivec\nstatic void lxdRunLoopObserverCallback(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void * info) {\n     /// 更新当前Runloop状态\n    SHAREDMONITOR.currentActivity = activity;\n    dispatch_semaphore_signal(SHAREDMONITOR.semphore);\n};\n\n- (void)startMonitoring {\n    if (_isMonitoring) { return; }\n    _isMonitoring = YES;\n    CFRunLoopObserverContext context = {\n        0,\n        (__bridge void *)self,\n        NULL,\n        NULL\n    };\n    /// 创建监听对象\n    _observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &lxdRunLoopObserverCallback, &context);\n    /// 在CommonModes添加监听者\n    CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes);\n    \n    /// 子线程异步串行队列中添加死循环\n    dispatch_async(lxd_event_monitor_queue(), ^{\n        while (SHAREDMONITOR.isMonitoring) {\n        \t/// 如果当前状态是BeforeWaiting（即将进入休眠）的话\n            if (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeWaiting) {\n                __block BOOL timeOut = YES;\n                dispatch_async(dispatch_get_main_queue(), ^{\n                    timeOut = NO; // 即将休眠的时候回到主线程超时状态改为NO\n                    dispatch_semaphore_signal(SHAREDMONITOR.eventSemphore); //解锁\n                });\n                [NSThread sleepForTimeInterval: lxd_time_out_interval]; // 子线程休眠一秒\n                if (timeOut) {\n                    [LXDBacktraceLogger lxd_logMain]; // 打印堆栈\n                }\n                dispatch_wait(SHAREDMONITOR.eventSemphore, DISPATCH_TIME_FOREVER); // 加锁\n            }\n        }\n    });\n    \n    dispatch_async(lxd_fluecy_monitor_queue(), ^{\n        while (SHAREDMONITOR.isMonitoring) {\n            long waitTime = dispatch_semaphore_wait(self.semphore, dispatch_time(DISPATCH_TIME_NOW, lxd_wait_interval)); // 等待200纳秒，看是否能拿到锁\n            if (waitTime != LXD_SEMPHORE_SUCCESS) { // 拿不到锁\n                if (!SHAREDMONITOR.observer) {\n                    SHAREDMONITOR.timeOut = 0;\n                    [SHAREDMONITOR stopMonitoring];\n                    continue;\n                }\n                /// Runloop 即将处理Source或者刚从休眠中唤醒\n                if (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeSources || SHAREDMONITOR.currentActivity == kCFRunLoopAfterWaiting) {\n                    if (++SHAREDMONITOR.timeOut < 5) { // 超时次数+1，然后如果超时次数大于5次就打印堆栈\n                        continue;\n                    }\n                    [LXDBacktraceLogger lxd_logMain];\n                    [NSThread sleepForTimeInterval: lxd_restore_interval];\n                }\n            }\n            SHAREDMONITOR.timeOut = 0;\n        }\n    });\n}\n```\n\n### 卡顿优化 - CPU\n\n- 尽量使用轻量级的对象，比如用不到事件处理的地方，可以考虑使用`CALayer`（只是拿来渲染）取代`UIView`（渲染+处理点击事件等）\n- 不要频繁地调用`UIView`的相关属性，比如`frame`、`bounds`、`transform`等属性，尽量减少不必要的修改\n- 尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性\n- Autolayout会比直接设置frame消耗更多的CPU资源\n- 图片的Size最好跟UIImageView的size保持一致\n- 控制一下线程的最大并发数量\n- 尽量把耗时操作放到子线程\n\t- 文本处理（尺寸计算、绘制）\n\t- 图片处理（解码、绘制）\n\n图片子线程解码举例\n\n```objectivec\n- (void)renderImage {\n    \n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        /// get CGImage\n        CGImageRef cgImage = [UIImage imageWithData:[NSData dataWithContentsOfURL:xxx]].CGImage;\n        \n        size_t width = CGImageGetWidth(cgImage);\n        size_t height = CGImageGetHeight(cgImage);\n        if (width == 0 || height == 0) return;\n        \n        CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(cgImage);\n        BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||\n                          alphaInfo == kCGImageAlphaNoneSkipFirst ||\n                          alphaInfo == kCGImageAlphaNoneSkipLast);\n\n        \n        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;\n        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;\n        CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, CGColorSpaceCreateDeviceRGB(), bitmapInfo);\n        if (!context) {\n            return;\n        }\n        \n        // Apply transform\n        CGAffineTransform transform = CGAffineTransformIdentity;\n        CGContextConcatCTM(context, transform);\n        CGContextDrawImage(context, CGRectMake(0, 0, width, height), cgImage); // The rect is bounding box of CGImage, don't swap width & height\n        CGImageRef newImageRef = CGBitmapContextCreateImage(context);\n        CGContextRelease(context);\n        \n        // back to the main thread\n        dispatch_async(dispatch_get_main_queue(), ^{\n            self.imageView.image = [[UIImage alloc] initWithCGImage:newImageRef];\n            CGImageRelease(newImageRef);\n        });\n    });\n}\n```\n\n### 卡顿优化 - GPU\n\n- 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示\n- GPU能处理的最大纹理尺寸是**4096*4096**，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸\n- 尽量减少视图数量和层次\n- 减少透明的视图（alpha < 1），不透明的就设置`opaque`为`YES`\n- 尽量避免出现离屏渲染\n\n#### 离屏渲染\n\n- 在OpenGL中，GPU有2种渲染方式\n\t- On-Screen Rendering：当前离屏渲染，在当前用于显示屏幕缓冲区进行渲染操作\n\t- Off-Screen Rendering: 离屏渲染，在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作 \n\n- 离屏渲染消耗性能的原因\n\t- 需要创建新的缓冲区\n\t- 离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）;等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕上。\n\n- 哪些操作会触发离屏渲染\n\t- 光栅化，`layer.shouldRasterize = YES`\n\t- 遮罩 `layer.mask`\n\t- 圆角，同时设置 `layouer.maskToBounds = YES`, `layer.cornerRadius`大于0\n\t\t- 考虑通过`CoreGraphics`绘制裁剪圆角，或者叫美工提供圆角图片\n\t- 阴影，`layer.shadowXXX`\n\t\t- 如果设置了`layer.shadowPath`就不会产生离屏渲染\n\n## 耗电优化\n\n### 主要来源\n\n- CPU处理，Processing\n- 网络，Networking\n- 定位，Location\n- 图像，Graphics\n\n### 优化\n\n- 尽可能降低CPU、GPU功耗\n- 少用定时器\n- 优化I/O操作\n\t- 尽量不要频繁写入小数据，最好批量一次性写入 \n\t- 读写大量重要数据时，考虑使用`dispatch_io`，其提供了基于GCD的异步操作文件的I/O的API.用`dispatch_io`系统会优化磁盘访问\n\t- 数据量比较大的，建议使用数据库(SQLite、CoreData)\n\n- 网络优化\n\t- 减少、压缩网络数据\n\t- 如果多次请求结果是相同的，尽量使用缓存\n\t- 使用断点续传，否则网络不稳定时可能多次传输相同的内容\n\t- 网络不可用时，不要尝试执行网络请求\n\t- 让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间\n\t- 批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载，如果下载广告，一次性多下载一些，然后再慢慢展示，如果下载电子邮件，一次下载多封，不要一封一封地下载\n\n- 定位优化\n\t- 如果只是需要快速确定用户当前位置，最好用`CLLocationManager`的`requestLocation`方法，定位完成后，会自动让定位硬件断电\n\t- 如果不是导航应用， 尽量不要实时更新位置，定位关闭就关掉定位服务\n\t- 尽量降低定位精度，比如尽量不要使用精度最高的`kCLLocationAccuracyBest`\n\t- 需要后台定位时，尽量设置`pausesLocationUpdatesAutomatically`为YES，如果用户不太可能移动的时候，系统会自动暂停位置更新\n\t- 尽量不要使用`startMonitoringSignificantLocationChanges`，优先考虑`startMonitoringForRegion:`\n\n- 硬件检测优化\n\t- 用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件。\n\n## App启动优化\n\n- App的启动可以分为2种\n\t- 冷启动（Code Launch）：从零开始启动App\n\t- 热启动（Warm Launch）：App已经在内存中，在后台存活着，再次点击图标\n\n- App启动时间的优化，主要是针对冷启动进行优化\n- 通过添加环境变量可以打印出App的启动时间分析（Edit Scheme -> Run -> Arguments）\n\t- `DYLD_PRINT_STATISTICS`设置为1 或者 `DYLD_PRINT_STATISTICS_DETAILS` （更加详细 ）\n \t\n- App的冷启动可以概括为3大阶段\n\t- dyld\n\t- runtime\n\t- main\n\t<img src=\"https://i.loli.net/2021/08/31/ldg1cjZCUPe5Gk6.png\" >\n\t\n\n  - dyld（dynamic link editor），Apple的动态链接器，可以用来装在Mach-O文件（可执行文件、动态库等 ）\n  - 启动App时，dyld所做的事情有\n      - 装载App的可执行文件，同时会递归加载所有依赖的动态库\n      - 当dyld把可执行文件、动态库都装载到内存完毕后，会通知Runtime进行下一步的处理\n  - 启动App时，runtime所做的事情有\n      - 调用`map_images`进行可执行文件内容的解析和处理\n      - 在`load_images`中调用`call_load_methods`,调用所有`Class`和`Category`的`+load`方法\n      - 进行各种objc结构的初始化（注册Objc类，初始化类对象等等）\n      - 调用C++静态初始化器和`__attribute((constructor))`修饰的函数\n  - 到此为止，可执行文件和动态库中所有的符号（Class、Protocol、Selector、IMP、...）都已经按格式成功加载到内存中，被`runtime`所管理\n  -  总结\n      - App的启动由dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库\n      - 并由runtime负责加载成objc定义的结构\n      - 所有初始化工作结束后，dyld就会调用main函数\n      - 接下来就是`UIApplicationMain`函数，AppDelegate的`application:didFinishLaunchingWithOptions:`方法\n\n### 优化方案\n\n- 按照不同的阶段\n\t- dyld \n\t\t- 减少动态库，合并一些动态库（定期清理不必要的动态库）\n\t\t- 减少Objc类，分类的数量，减少selector的数量（定期清理不必要的类，分类）\n\t\t- 减少C++虚函数数量\n\t\t- Swift尽量使用struct\n\t- runtime\n\t\t- 用`+initialize`和`dispatch_once`取代所有的`__attribute((constructor))`、C++静态构造器 、ObjC的`+load`\n\t- main\n\t\t- 在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在`finishLaunch`方法中\n\t\t- 按需加载 \n\n## 安装包瘦身\n\n- 安装包（IPA）主要由可执行文件、资源组成\n\n- 资源（图片、视频、音频等）\n\t- 采取无损压缩\n\t- 去除没有用到的资源(github :LSUnusedResources）\n\n- 可执行文件瘦身\n\t- 编译器优化 \n\t\t- Strip Linked Product 、 Make Strings Read-Only、 Symbols Hidden By Defaults设置为YES\n\t\t- 去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions 设置为NO，Other C Flags  添加 -fno-exceptions\n\t- 利用AppCode([https://www.jetbrains.com/objc](https://www.jetbrains.com/objc))检测未使用的代码：菜单栏 -> Code -> Inspect Code\n\t- 编写LLVM插件检测出重复代码，未被调用的代码\n\t- 生成Link Map文件，可以查看可执行文件的具体组成（在Build Setting->Write Link Map File 改为true，就可以在Path to link map file 看到这个文件）\n\t- 可以借助第三方工具解析LinkMap文件：[https://github.com/huanxsd/LinkMap](https://github.com/huanxsd/LinkMap)","slug":"iOS-性能优化","published":1,"updated":"2021-08-31T13:47:12.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckt0amz050000xon0a1gfciqu","content":"<p>本文主要介绍iOS内常用的性能优化方案</p>\n<span id=\"more\"></span>\n\n<h2 id=\"CPU和GPU\"><a href=\"#CPU和GPU\" class=\"headerlink\" title=\"CPU和GPU\"></a>CPU和GPU</h2><ul>\n<li><p>在屏幕成像的过程中，CPU和GPU起着至关重要的作用</p>\n<ul>\n<li>CPU <ul>\n<li>对象的创建和销毁，对象属性的调整、布局计算、文本的计算和排版、图片格式转换和解码、图像的绘制 </li>\n</ul>\n</li>\n<li>GPU<ul>\n<li>纹理的渲染</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>在iOS中是双缓冲机制，有前帧缓存、后帧缓存（）</p>\n</li>\n</ul>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CPU-&gt;计算-&gt;GPU-&gt;渲染-&gt;帧缓存-&gt;读取-&gt;视频控制器-&gt;显示-&gt;屏幕   </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"屏幕成像原理\"><a href=\"#屏幕成像原理\" class=\"headerlink\" title=\"屏幕成像原理\"></a>屏幕成像原理</h2><p>首先先发出一个垂直同步信号（VSync），然后再一行行发出水平同步信号（HSync），直到最后一行HSync发出之后，一帧就渲染完成，然后再次发出一个VSync，渲染下一帧。</p>\n<img src=\"https://i.loli.net/2021/08/31/hWqVypmfbtga4eK.png\" >\n\n<h2 id=\"卡顿\"><a href=\"#卡顿\" class=\"headerlink\" title=\"卡顿\"></a>卡顿</h2><h3 id=\"卡顿产生的原因\"><a href=\"#卡顿产生的原因\" class=\"headerlink\" title=\"卡顿产生的原因\"></a>卡顿产生的原因</h3><p><img src=\"https://i.loli.net/2021/08/31/ZTNhbeyRiq8UgmV.png\" alt=\"1682758-5be402cc0ab5dc56.png\"></p>\n<ol>\n<li>首先第一个VSync进入，CPU开始计算处理，然后交给GPU渲染，然后显示到屏幕上</li>\n<li>然后第二个VSync进入，这时候CPU处理的时间比较长，交给GPU后， GPU还没处理完，第三个VSync就进来了，但是因为GPU没处理完。第二帧还不能显示，所以这时候直接取上一帧数据显示，造成第一帧长时间停留</li>\n<li>然后过了一段时间GPU终于处理完了，但是第四个VSync还没来，所以就等，等到第四个VSync进来了，就开始拿刚才生成好的那一帧去显示，然后开始继续第三帧的计算</li>\n</ol>\n<ul>\n<li>解决卡顿的主要思路<ul>\n<li>尽可能减少CPU、GPU资源损耗</li>\n</ul>\n</li>\n<li>按照60fps的刷新率，每个16ms就会有一次VSync信号 </li>\n</ul>\n<h3 id=\"卡顿检测\"><a href=\"#卡顿检测\" class=\"headerlink\" title=\"卡顿检测\"></a>卡顿检测</h3><ul>\n<li>平时所说的__卡顿__主要是因为在主线程执行了比较耗时的操作</li>\n<li>可以添加<code>Observer</code>到主线程<code>Runloop</code>中，通过监听<code>Runloop</code>状态切换的耗时，以达到监控卡顿的目的</li>\n</ul>\n<blockquote>\n<p>参考：<a href=\"https://github.com/UIControl/LXDAppFluecyMonitor/blob/master/LXDAppFluecyMonitor/LXDAppFluecyMonitor/LXDAppFluecyMonitor.m\">LXDAppFluecyMonitor</a></p>\n</blockquote>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> lxdRunLoopObserverCallback(<span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFRunLoopActivity</span> activity, <span class=\"keyword\">void</span> * info) &#123;</span><br><span class=\"line\">     <span class=\"comment\">/// 更新当前Runloop状态</span></span><br><span class=\"line\">    SHAREDMONITOR.currentActivity = activity;</span><br><span class=\"line\">    dispatch_semaphore_signal(SHAREDMONITOR.semphore);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)startMonitoring &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_isMonitoring) &#123; <span class=\"keyword\">return</span>; &#125;</span><br><span class=\"line\">    _isMonitoring = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopObserverContext</span> context = &#123;</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        (__bridge <span class=\"keyword\">void</span> *)<span class=\"keyword\">self</span>,</span><br><span class=\"line\">        <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">        <span class=\"literal\">NULL</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">/// 创建监听对象</span></span><br><span class=\"line\">    _observer = <span class=\"built_in\">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class=\"literal\">YES</span>, <span class=\"number\">0</span>, &amp;lxdRunLoopObserverCallback, &amp;context);</span><br><span class=\"line\">    <span class=\"comment\">/// 在CommonModes添加监听者</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopAddObserver</span>(<span class=\"built_in\">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 子线程异步串行队列中添加死循环</span></span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(lxd_event_monitor_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (SHAREDMONITOR.isMonitoring) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">/// 如果当前状态是BeforeWaiting（即将进入休眠）的话</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeWaiting) &#123;</span><br><span class=\"line\">                __block <span class=\"built_in\">BOOL</span> timeOut = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">                <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">                    timeOut = <span class=\"literal\">NO</span>; <span class=\"comment\">// 即将休眠的时候回到主线程超时状态改为NO</span></span><br><span class=\"line\">                    dispatch_semaphore_signal(SHAREDMONITOR.eventSemphore); <span class=\"comment\">//解锁</span></span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                [<span class=\"built_in\">NSThread</span> sleepForTimeInterval: lxd_time_out_interval]; <span class=\"comment\">// 子线程休眠一秒</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (timeOut) &#123;</span><br><span class=\"line\">                    [LXDBacktraceLogger lxd_logMain]; <span class=\"comment\">// 打印堆栈</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dispatch_wait(SHAREDMONITOR.eventSemphore, DISPATCH_TIME_FOREVER); <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(lxd_fluecy_monitor_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (SHAREDMONITOR.isMonitoring) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> waitTime = dispatch_semaphore_wait(<span class=\"keyword\">self</span>.semphore, dispatch_time(DISPATCH_TIME_NOW, lxd_wait_interval)); <span class=\"comment\">// 等待200纳秒，看是否能拿到锁</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitTime != LXD_SEMPHORE_SUCCESS) &#123; <span class=\"comment\">// 拿不到锁</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!SHAREDMONITOR.observer) &#123;</span><br><span class=\"line\">                    SHAREDMONITOR.timeOut = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    [SHAREDMONITOR stopMonitoring];</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/// Runloop 即将处理Source或者刚从休眠中唤醒</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeSources || SHAREDMONITOR.currentActivity == kCFRunLoopAfterWaiting) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (++SHAREDMONITOR.timeOut &lt; <span class=\"number\">5</span>) &#123; <span class=\"comment\">// 超时次数+1，然后如果超时次数大于5次就打印堆栈</span></span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    [LXDBacktraceLogger lxd_logMain];</span><br><span class=\"line\">                    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval: lxd_restore_interval];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            SHAREDMONITOR.timeOut = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"卡顿优化-CPU\"><a href=\"#卡顿优化-CPU\" class=\"headerlink\" title=\"卡顿优化 - CPU\"></a>卡顿优化 - CPU</h3><ul>\n<li>尽量使用轻量级的对象，比如用不到事件处理的地方，可以考虑使用<code>CALayer</code>（只是拿来渲染）取代<code>UIView</code>（渲染+处理点击事件等）</li>\n<li>不要频繁地调用<code>UIView</code>的相关属性，比如<code>frame</code>、<code>bounds</code>、<code>transform</code>等属性，尽量减少不必要的修改</li>\n<li>尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</li>\n<li>Autolayout会比直接设置frame消耗更多的CPU资源</li>\n<li>图片的Size最好跟UIImageView的size保持一致</li>\n<li>控制一下线程的最大并发数量</li>\n<li>尽量把耗时操作放到子线程<ul>\n<li>文本处理（尺寸计算、绘制）</li>\n<li>图片处理（解码、绘制）</li>\n</ul>\n</li>\n</ul>\n<p>图片子线程解码举例</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)renderImage &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        <span class=\"comment\">/// get CGImage</span></span><br><span class=\"line\">        <span class=\"built_in\">CGImageRef</span> cgImage = [<span class=\"built_in\">UIImage</span> imageWithData:[<span class=\"built_in\">NSData</span> dataWithContentsOfURL:xxx]].CGImage;</span><br><span class=\"line\">        </span><br><span class=\"line\">        size_t width = <span class=\"built_in\">CGImageGetWidth</span>(cgImage);</span><br><span class=\"line\">        size_t height = <span class=\"built_in\">CGImageGetHeight</span>(cgImage);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (width == <span class=\"number\">0</span> || height == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">CGImageAlphaInfo</span> alphaInfo = <span class=\"built_in\">CGImageGetAlphaInfo</span>(cgImage);</span><br><span class=\"line\">        <span class=\"built_in\">BOOL</span> hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</span><br><span class=\"line\">                          alphaInfo == kCGImageAlphaNoneSkipFirst ||</span><br><span class=\"line\">                          alphaInfo == kCGImageAlphaNoneSkipLast);</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class=\"line\">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class=\"line\">        <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">CGBitmapContextCreate</span>(<span class=\"literal\">NULL</span>, width, height, <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>(), bitmapInfo);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!context) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Apply transform</span></span><br><span class=\"line\">        <span class=\"built_in\">CGAffineTransform</span> transform = <span class=\"built_in\">CGAffineTransformIdentity</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CGContextConcatCTM</span>(context, transform);</span><br><span class=\"line\">        <span class=\"built_in\">CGContextDrawImage</span>(context, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, width, height), cgImage); <span class=\"comment\">// The rect is bounding box of CGImage, don&#x27;t swap width &amp; height</span></span><br><span class=\"line\">        <span class=\"built_in\">CGImageRef</span> newImageRef = <span class=\"built_in\">CGBitmapContextCreateImage</span>(context);</span><br><span class=\"line\">        <span class=\"built_in\">CGContextRelease</span>(context);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// back to the main thread</span></span><br><span class=\"line\">        <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.imageView.image = [[<span class=\"built_in\">UIImage</span> alloc] initWithCGImage:newImageRef];</span><br><span class=\"line\">            <span class=\"built_in\">CGImageRelease</span>(newImageRef);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"卡顿优化-GPU\"><a href=\"#卡顿优化-GPU\" class=\"headerlink\" title=\"卡顿优化 - GPU\"></a>卡顿优化 - GPU</h3><ul>\n<li>尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</li>\n<li>GPU能处理的最大纹理尺寸是<strong>4096*4096</strong>，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸</li>\n<li>尽量减少视图数量和层次</li>\n<li>减少透明的视图（alpha &lt; 1），不透明的就设置<code>opaque</code>为<code>YES</code></li>\n<li>尽量避免出现离屏渲染</li>\n</ul>\n<h4 id=\"离屏渲染\"><a href=\"#离屏渲染\" class=\"headerlink\" title=\"离屏渲染\"></a>离屏渲染</h4><ul>\n<li><p>在OpenGL中，GPU有2种渲染方式</p>\n<ul>\n<li>On-Screen Rendering：当前离屏渲染，在当前用于显示屏幕缓冲区进行渲染操作</li>\n<li>Off-Screen Rendering: 离屏渲染，在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作 </li>\n</ul>\n</li>\n<li><p>离屏渲染消耗性能的原因</p>\n<ul>\n<li>需要创建新的缓冲区</li>\n<li>离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）;等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕上。</li>\n</ul>\n</li>\n<li><p>哪些操作会触发离屏渲染</p>\n<ul>\n<li>光栅化，<code>layer.shouldRasterize = YES</code></li>\n<li>遮罩 <code>layer.mask</code></li>\n<li>圆角，同时设置 <code>layouer.maskToBounds = YES</code>, <code>layer.cornerRadius</code>大于0<ul>\n<li>考虑通过<code>CoreGraphics</code>绘制裁剪圆角，或者叫美工提供圆角图片</li>\n</ul>\n</li>\n<li>阴影，<code>layer.shadowXXX</code><ul>\n<li>如果设置了<code>layer.shadowPath</code>就不会产生离屏渲染</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"耗电优化\"><a href=\"#耗电优化\" class=\"headerlink\" title=\"耗电优化\"></a>耗电优化</h2><h3 id=\"主要来源\"><a href=\"#主要来源\" class=\"headerlink\" title=\"主要来源\"></a>主要来源</h3><ul>\n<li>CPU处理，Processing</li>\n<li>网络，Networking</li>\n<li>定位，Location</li>\n<li>图像，Graphics</li>\n</ul>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><ul>\n<li><p>尽可能降低CPU、GPU功耗</p>\n</li>\n<li><p>少用定时器</p>\n</li>\n<li><p>优化I/O操作</p>\n<ul>\n<li>尽量不要频繁写入小数据，最好批量一次性写入 </li>\n<li>读写大量重要数据时，考虑使用<code>dispatch_io</code>，其提供了基于GCD的异步操作文件的I/O的API.用<code>dispatch_io</code>系统会优化磁盘访问</li>\n<li>数据量比较大的，建议使用数据库(SQLite、CoreData)</li>\n</ul>\n</li>\n<li><p>网络优化</p>\n<ul>\n<li>减少、压缩网络数据</li>\n<li>如果多次请求结果是相同的，尽量使用缓存</li>\n<li>使用断点续传，否则网络不稳定时可能多次传输相同的内容</li>\n<li>网络不可用时，不要尝试执行网络请求</li>\n<li>让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间</li>\n<li>批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载，如果下载广告，一次性多下载一些，然后再慢慢展示，如果下载电子邮件，一次下载多封，不要一封一封地下载</li>\n</ul>\n</li>\n<li><p>定位优化</p>\n<ul>\n<li>如果只是需要快速确定用户当前位置，最好用<code>CLLocationManager</code>的<code>requestLocation</code>方法，定位完成后，会自动让定位硬件断电</li>\n<li>如果不是导航应用， 尽量不要实时更新位置，定位关闭就关掉定位服务</li>\n<li>尽量降低定位精度，比如尽量不要使用精度最高的<code>kCLLocationAccuracyBest</code></li>\n<li>需要后台定位时，尽量设置<code>pausesLocationUpdatesAutomatically</code>为YES，如果用户不太可能移动的时候，系统会自动暂停位置更新</li>\n<li>尽量不要使用<code>startMonitoringSignificantLocationChanges</code>，优先考虑<code>startMonitoringForRegion:</code></li>\n</ul>\n</li>\n<li><p>硬件检测优化</p>\n<ul>\n<li>用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"App启动优化\"><a href=\"#App启动优化\" class=\"headerlink\" title=\"App启动优化\"></a>App启动优化</h2><ul>\n<li><p>App的启动可以分为2种</p>\n<ul>\n<li>冷启动（Code Launch）：从零开始启动App</li>\n<li>热启动（Warm Launch）：App已经在内存中，在后台存活着，再次点击图标</li>\n</ul>\n</li>\n<li><p>App启动时间的优化，主要是针对冷启动进行优化</p>\n</li>\n<li><p>通过添加环境变量可以打印出App的启动时间分析（Edit Scheme -&gt; Run -&gt; Arguments）</p>\n<ul>\n<li><code>DYLD_PRINT_STATISTICS</code>设置为1 或者 <code>DYLD_PRINT_STATISTICS_DETAILS</code> （更加详细 ）</li>\n</ul>\n</li>\n<li><p>App的冷启动可以概括为3大阶段</p>\n<ul>\n<li><p>dyld</p>\n</li>\n<li><p>runtime</p>\n</li>\n<li><p>main</p>\n<img src=\"https://i.loli.net/2021/08/31/ldg1cjZCUPe5Gk6.png\" ></li>\n<li><p>dyld（dynamic link editor），Apple的动态链接器，可以用来装在Mach-O文件（可执行文件、动态库等 ）</p>\n</li>\n<li><p>启动App时，dyld所做的事情有</p>\n<ul>\n<li>装载App的可执行文件，同时会递归加载所有依赖的动态库</li>\n<li>当dyld把可执行文件、动态库都装载到内存完毕后，会通知Runtime进行下一步的处理</li>\n</ul>\n</li>\n<li><p>启动App时，runtime所做的事情有</p>\n<ul>\n<li>调用<code>map_images</code>进行可执行文件内容的解析和处理</li>\n<li>在<code>load_images</code>中调用<code>call_load_methods</code>,调用所有<code>Class</code>和<code>Category</code>的<code>+load</code>方法</li>\n<li>进行各种objc结构的初始化（注册Objc类，初始化类对象等等）</li>\n<li>调用C++静态初始化器和<code>__attribute((constructor))</code>修饰的函数</li>\n</ul>\n</li>\n<li><p>到此为止，可执行文件和动态库中所有的符号（Class、Protocol、Selector、IMP、…）都已经按格式成功加载到内存中，被<code>runtime</code>所管理</p>\n</li>\n<li><p>总结</p>\n<ul>\n<li>App的启动由dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库</li>\n<li>并由runtime负责加载成objc定义的结构</li>\n<li>所有初始化工作结束后，dyld就会调用main函数</li>\n<li>接下来就是<code>UIApplicationMain</code>函数，AppDelegate的<code>application:didFinishLaunchingWithOptions:</code>方法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"优化方案\"><a href=\"#优化方案\" class=\"headerlink\" title=\"优化方案\"></a>优化方案</h3><ul>\n<li>按照不同的阶段<ul>\n<li>dyld <ul>\n<li>减少动态库，合并一些动态库（定期清理不必要的动态库）</li>\n<li>减少Objc类，分类的数量，减少selector的数量（定期清理不必要的类，分类）</li>\n<li>减少C++虚函数数量</li>\n<li>Swift尽量使用struct</li>\n</ul>\n</li>\n<li>runtime<ul>\n<li>用<code>+initialize</code>和<code>dispatch_once</code>取代所有的<code>__attribute((constructor))</code>、C++静态构造器 、ObjC的<code>+load</code></li>\n</ul>\n</li>\n<li>main<ul>\n<li>在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在<code>finishLaunch</code>方法中</li>\n<li>按需加载 </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"安装包瘦身\"><a href=\"#安装包瘦身\" class=\"headerlink\" title=\"安装包瘦身\"></a>安装包瘦身</h2><ul>\n<li><p>安装包（IPA）主要由可执行文件、资源组成</p>\n</li>\n<li><p>资源（图片、视频、音频等）</p>\n<ul>\n<li>采取无损压缩</li>\n<li>去除没有用到的资源(github :LSUnusedResources）</li>\n</ul>\n</li>\n<li><p>可执行文件瘦身</p>\n<ul>\n<li>编译器优化 <ul>\n<li>Strip Linked Product 、 Make Strings Read-Only、 Symbols Hidden By Defaults设置为YES</li>\n<li>去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions 设置为NO，Other C Flags  添加 -fno-exceptions</li>\n</ul>\n</li>\n<li>利用AppCode(<a href=\"https://www.jetbrains.com/objc\">https://www.jetbrains.com/objc</a>)检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code</li>\n<li>编写LLVM插件检测出重复代码，未被调用的代码</li>\n<li>生成Link Map文件，可以查看可执行文件的具体组成（在Build Setting-&gt;Write Link Map File 改为true，就可以在Path to link map file 看到这个文件）</li>\n<li>可以借助第三方工具解析LinkMap文件：<a href=\"https://github.com/huanxsd/LinkMap\">https://github.com/huanxsd/LinkMap</a></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>本文主要介绍iOS内常用的性能优化方案</p>","more":"<h2 id=\"CPU和GPU\"><a href=\"#CPU和GPU\" class=\"headerlink\" title=\"CPU和GPU\"></a>CPU和GPU</h2><ul>\n<li><p>在屏幕成像的过程中，CPU和GPU起着至关重要的作用</p>\n<ul>\n<li>CPU <ul>\n<li>对象的创建和销毁，对象属性的调整、布局计算、文本的计算和排版、图片格式转换和解码、图像的绘制 </li>\n</ul>\n</li>\n<li>GPU<ul>\n<li>纹理的渲染</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>在iOS中是双缓冲机制，有前帧缓存、后帧缓存（）</p>\n</li>\n</ul>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CPU-&gt;计算-&gt;GPU-&gt;渲染-&gt;帧缓存-&gt;读取-&gt;视频控制器-&gt;显示-&gt;屏幕   </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"屏幕成像原理\"><a href=\"#屏幕成像原理\" class=\"headerlink\" title=\"屏幕成像原理\"></a>屏幕成像原理</h2><p>首先先发出一个垂直同步信号（VSync），然后再一行行发出水平同步信号（HSync），直到最后一行HSync发出之后，一帧就渲染完成，然后再次发出一个VSync，渲染下一帧。</p>\n<img src=\"https://i.loli.net/2021/08/31/hWqVypmfbtga4eK.png\" >\n\n<h2 id=\"卡顿\"><a href=\"#卡顿\" class=\"headerlink\" title=\"卡顿\"></a>卡顿</h2><h3 id=\"卡顿产生的原因\"><a href=\"#卡顿产生的原因\" class=\"headerlink\" title=\"卡顿产生的原因\"></a>卡顿产生的原因</h3><p><img src=\"https://i.loli.net/2021/08/31/ZTNhbeyRiq8UgmV.png\" alt=\"1682758-5be402cc0ab5dc56.png\"></p>\n<ol>\n<li>首先第一个VSync进入，CPU开始计算处理，然后交给GPU渲染，然后显示到屏幕上</li>\n<li>然后第二个VSync进入，这时候CPU处理的时间比较长，交给GPU后， GPU还没处理完，第三个VSync就进来了，但是因为GPU没处理完。第二帧还不能显示，所以这时候直接取上一帧数据显示，造成第一帧长时间停留</li>\n<li>然后过了一段时间GPU终于处理完了，但是第四个VSync还没来，所以就等，等到第四个VSync进来了，就开始拿刚才生成好的那一帧去显示，然后开始继续第三帧的计算</li>\n</ol>\n<ul>\n<li>解决卡顿的主要思路<ul>\n<li>尽可能减少CPU、GPU资源损耗</li>\n</ul>\n</li>\n<li>按照60fps的刷新率，每个16ms就会有一次VSync信号 </li>\n</ul>\n<h3 id=\"卡顿检测\"><a href=\"#卡顿检测\" class=\"headerlink\" title=\"卡顿检测\"></a>卡顿检测</h3><ul>\n<li>平时所说的__卡顿__主要是因为在主线程执行了比较耗时的操作</li>\n<li>可以添加<code>Observer</code>到主线程<code>Runloop</code>中，通过监听<code>Runloop</code>状态切换的耗时，以达到监控卡顿的目的</li>\n</ul>\n<blockquote>\n<p>参考：<a href=\"https://github.com/UIControl/LXDAppFluecyMonitor/blob/master/LXDAppFluecyMonitor/LXDAppFluecyMonitor/LXDAppFluecyMonitor.m\">LXDAppFluecyMonitor</a></p>\n</blockquote>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> lxdRunLoopObserverCallback(<span class=\"built_in\">CFRunLoopObserverRef</span> observer, <span class=\"built_in\">CFRunLoopActivity</span> activity, <span class=\"keyword\">void</span> * info) &#123;</span><br><span class=\"line\">     <span class=\"comment\">/// 更新当前Runloop状态</span></span><br><span class=\"line\">    SHAREDMONITOR.currentActivity = activity;</span><br><span class=\"line\">    dispatch_semaphore_signal(SHAREDMONITOR.semphore);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)startMonitoring &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_isMonitoring) &#123; <span class=\"keyword\">return</span>; &#125;</span><br><span class=\"line\">    _isMonitoring = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopObserverContext</span> context = &#123;</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        (__bridge <span class=\"keyword\">void</span> *)<span class=\"keyword\">self</span>,</span><br><span class=\"line\">        <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">        <span class=\"literal\">NULL</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">/// 创建监听对象</span></span><br><span class=\"line\">    _observer = <span class=\"built_in\">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class=\"literal\">YES</span>, <span class=\"number\">0</span>, &amp;lxdRunLoopObserverCallback, &amp;context);</span><br><span class=\"line\">    <span class=\"comment\">/// 在CommonModes添加监听者</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopAddObserver</span>(<span class=\"built_in\">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/// 子线程异步串行队列中添加死循环</span></span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(lxd_event_monitor_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (SHAREDMONITOR.isMonitoring) &#123;</span><br><span class=\"line\">        \t<span class=\"comment\">/// 如果当前状态是BeforeWaiting（即将进入休眠）的话</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeWaiting) &#123;</span><br><span class=\"line\">                __block <span class=\"built_in\">BOOL</span> timeOut = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">                <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">                    timeOut = <span class=\"literal\">NO</span>; <span class=\"comment\">// 即将休眠的时候回到主线程超时状态改为NO</span></span><br><span class=\"line\">                    dispatch_semaphore_signal(SHAREDMONITOR.eventSemphore); <span class=\"comment\">//解锁</span></span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                [<span class=\"built_in\">NSThread</span> sleepForTimeInterval: lxd_time_out_interval]; <span class=\"comment\">// 子线程休眠一秒</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (timeOut) &#123;</span><br><span class=\"line\">                    [LXDBacktraceLogger lxd_logMain]; <span class=\"comment\">// 打印堆栈</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dispatch_wait(SHAREDMONITOR.eventSemphore, DISPATCH_TIME_FOREVER); <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(lxd_fluecy_monitor_queue(), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (SHAREDMONITOR.isMonitoring) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> waitTime = dispatch_semaphore_wait(<span class=\"keyword\">self</span>.semphore, dispatch_time(DISPATCH_TIME_NOW, lxd_wait_interval)); <span class=\"comment\">// 等待200纳秒，看是否能拿到锁</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (waitTime != LXD_SEMPHORE_SUCCESS) &#123; <span class=\"comment\">// 拿不到锁</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!SHAREDMONITOR.observer) &#123;</span><br><span class=\"line\">                    SHAREDMONITOR.timeOut = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    [SHAREDMONITOR stopMonitoring];</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">/// Runloop 即将处理Source或者刚从休眠中唤醒</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeSources || SHAREDMONITOR.currentActivity == kCFRunLoopAfterWaiting) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (++SHAREDMONITOR.timeOut &lt; <span class=\"number\">5</span>) &#123; <span class=\"comment\">// 超时次数+1，然后如果超时次数大于5次就打印堆栈</span></span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    [LXDBacktraceLogger lxd_logMain];</span><br><span class=\"line\">                    [<span class=\"built_in\">NSThread</span> sleepForTimeInterval: lxd_restore_interval];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            SHAREDMONITOR.timeOut = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"卡顿优化-CPU\"><a href=\"#卡顿优化-CPU\" class=\"headerlink\" title=\"卡顿优化 - CPU\"></a>卡顿优化 - CPU</h3><ul>\n<li>尽量使用轻量级的对象，比如用不到事件处理的地方，可以考虑使用<code>CALayer</code>（只是拿来渲染）取代<code>UIView</code>（渲染+处理点击事件等）</li>\n<li>不要频繁地调用<code>UIView</code>的相关属性，比如<code>frame</code>、<code>bounds</code>、<code>transform</code>等属性，尽量减少不必要的修改</li>\n<li>尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</li>\n<li>Autolayout会比直接设置frame消耗更多的CPU资源</li>\n<li>图片的Size最好跟UIImageView的size保持一致</li>\n<li>控制一下线程的最大并发数量</li>\n<li>尽量把耗时操作放到子线程<ul>\n<li>文本处理（尺寸计算、绘制）</li>\n<li>图片处理（解码、绘制）</li>\n</ul>\n</li>\n</ul>\n<p>图片子线程解码举例</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)renderImage &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        <span class=\"comment\">/// get CGImage</span></span><br><span class=\"line\">        <span class=\"built_in\">CGImageRef</span> cgImage = [<span class=\"built_in\">UIImage</span> imageWithData:[<span class=\"built_in\">NSData</span> dataWithContentsOfURL:xxx]].CGImage;</span><br><span class=\"line\">        </span><br><span class=\"line\">        size_t width = <span class=\"built_in\">CGImageGetWidth</span>(cgImage);</span><br><span class=\"line\">        size_t height = <span class=\"built_in\">CGImageGetHeight</span>(cgImage);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (width == <span class=\"number\">0</span> || height == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">CGImageAlphaInfo</span> alphaInfo = <span class=\"built_in\">CGImageGetAlphaInfo</span>(cgImage);</span><br><span class=\"line\">        <span class=\"built_in\">BOOL</span> hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</span><br><span class=\"line\">                          alphaInfo == kCGImageAlphaNoneSkipFirst ||</span><br><span class=\"line\">                          alphaInfo == kCGImageAlphaNoneSkipLast);</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class=\"line\">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class=\"line\">        <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">CGBitmapContextCreate</span>(<span class=\"literal\">NULL</span>, width, height, <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>(), bitmapInfo);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!context) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// Apply transform</span></span><br><span class=\"line\">        <span class=\"built_in\">CGAffineTransform</span> transform = <span class=\"built_in\">CGAffineTransformIdentity</span>;</span><br><span class=\"line\">        <span class=\"built_in\">CGContextConcatCTM</span>(context, transform);</span><br><span class=\"line\">        <span class=\"built_in\">CGContextDrawImage</span>(context, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, width, height), cgImage); <span class=\"comment\">// The rect is bounding box of CGImage, don&#x27;t swap width &amp; height</span></span><br><span class=\"line\">        <span class=\"built_in\">CGImageRef</span> newImageRef = <span class=\"built_in\">CGBitmapContextCreateImage</span>(context);</span><br><span class=\"line\">        <span class=\"built_in\">CGContextRelease</span>(context);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// back to the main thread</span></span><br><span class=\"line\">        <span class=\"built_in\">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.imageView.image = [[<span class=\"built_in\">UIImage</span> alloc] initWithCGImage:newImageRef];</span><br><span class=\"line\">            <span class=\"built_in\">CGImageRelease</span>(newImageRef);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"卡顿优化-GPU\"><a href=\"#卡顿优化-GPU\" class=\"headerlink\" title=\"卡顿优化 - GPU\"></a>卡顿优化 - GPU</h3><ul>\n<li>尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</li>\n<li>GPU能处理的最大纹理尺寸是<strong>4096*4096</strong>，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸</li>\n<li>尽量减少视图数量和层次</li>\n<li>减少透明的视图（alpha &lt; 1），不透明的就设置<code>opaque</code>为<code>YES</code></li>\n<li>尽量避免出现离屏渲染</li>\n</ul>\n<h4 id=\"离屏渲染\"><a href=\"#离屏渲染\" class=\"headerlink\" title=\"离屏渲染\"></a>离屏渲染</h4><ul>\n<li><p>在OpenGL中，GPU有2种渲染方式</p>\n<ul>\n<li>On-Screen Rendering：当前离屏渲染，在当前用于显示屏幕缓冲区进行渲染操作</li>\n<li>Off-Screen Rendering: 离屏渲染，在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作 </li>\n</ul>\n</li>\n<li><p>离屏渲染消耗性能的原因</p>\n<ul>\n<li>需要创建新的缓冲区</li>\n<li>离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）;等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕上。</li>\n</ul>\n</li>\n<li><p>哪些操作会触发离屏渲染</p>\n<ul>\n<li>光栅化，<code>layer.shouldRasterize = YES</code></li>\n<li>遮罩 <code>layer.mask</code></li>\n<li>圆角，同时设置 <code>layouer.maskToBounds = YES</code>, <code>layer.cornerRadius</code>大于0<ul>\n<li>考虑通过<code>CoreGraphics</code>绘制裁剪圆角，或者叫美工提供圆角图片</li>\n</ul>\n</li>\n<li>阴影，<code>layer.shadowXXX</code><ul>\n<li>如果设置了<code>layer.shadowPath</code>就不会产生离屏渲染</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"耗电优化\"><a href=\"#耗电优化\" class=\"headerlink\" title=\"耗电优化\"></a>耗电优化</h2><h3 id=\"主要来源\"><a href=\"#主要来源\" class=\"headerlink\" title=\"主要来源\"></a>主要来源</h3><ul>\n<li>CPU处理，Processing</li>\n<li>网络，Networking</li>\n<li>定位，Location</li>\n<li>图像，Graphics</li>\n</ul>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><ul>\n<li><p>尽可能降低CPU、GPU功耗</p>\n</li>\n<li><p>少用定时器</p>\n</li>\n<li><p>优化I/O操作</p>\n<ul>\n<li>尽量不要频繁写入小数据，最好批量一次性写入 </li>\n<li>读写大量重要数据时，考虑使用<code>dispatch_io</code>，其提供了基于GCD的异步操作文件的I/O的API.用<code>dispatch_io</code>系统会优化磁盘访问</li>\n<li>数据量比较大的，建议使用数据库(SQLite、CoreData)</li>\n</ul>\n</li>\n<li><p>网络优化</p>\n<ul>\n<li>减少、压缩网络数据</li>\n<li>如果多次请求结果是相同的，尽量使用缓存</li>\n<li>使用断点续传，否则网络不稳定时可能多次传输相同的内容</li>\n<li>网络不可用时，不要尝试执行网络请求</li>\n<li>让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间</li>\n<li>批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载，如果下载广告，一次性多下载一些，然后再慢慢展示，如果下载电子邮件，一次下载多封，不要一封一封地下载</li>\n</ul>\n</li>\n<li><p>定位优化</p>\n<ul>\n<li>如果只是需要快速确定用户当前位置，最好用<code>CLLocationManager</code>的<code>requestLocation</code>方法，定位完成后，会自动让定位硬件断电</li>\n<li>如果不是导航应用， 尽量不要实时更新位置，定位关闭就关掉定位服务</li>\n<li>尽量降低定位精度，比如尽量不要使用精度最高的<code>kCLLocationAccuracyBest</code></li>\n<li>需要后台定位时，尽量设置<code>pausesLocationUpdatesAutomatically</code>为YES，如果用户不太可能移动的时候，系统会自动暂停位置更新</li>\n<li>尽量不要使用<code>startMonitoringSignificantLocationChanges</code>，优先考虑<code>startMonitoringForRegion:</code></li>\n</ul>\n</li>\n<li><p>硬件检测优化</p>\n<ul>\n<li>用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"App启动优化\"><a href=\"#App启动优化\" class=\"headerlink\" title=\"App启动优化\"></a>App启动优化</h2><ul>\n<li><p>App的启动可以分为2种</p>\n<ul>\n<li>冷启动（Code Launch）：从零开始启动App</li>\n<li>热启动（Warm Launch）：App已经在内存中，在后台存活着，再次点击图标</li>\n</ul>\n</li>\n<li><p>App启动时间的优化，主要是针对冷启动进行优化</p>\n</li>\n<li><p>通过添加环境变量可以打印出App的启动时间分析（Edit Scheme -&gt; Run -&gt; Arguments）</p>\n<ul>\n<li><code>DYLD_PRINT_STATISTICS</code>设置为1 或者 <code>DYLD_PRINT_STATISTICS_DETAILS</code> （更加详细 ）</li>\n</ul>\n</li>\n<li><p>App的冷启动可以概括为3大阶段</p>\n<ul>\n<li><p>dyld</p>\n</li>\n<li><p>runtime</p>\n</li>\n<li><p>main</p>\n<img src=\"https://i.loli.net/2021/08/31/ldg1cjZCUPe5Gk6.png\" ></li>\n<li><p>dyld（dynamic link editor），Apple的动态链接器，可以用来装在Mach-O文件（可执行文件、动态库等 ）</p>\n</li>\n<li><p>启动App时，dyld所做的事情有</p>\n<ul>\n<li>装载App的可执行文件，同时会递归加载所有依赖的动态库</li>\n<li>当dyld把可执行文件、动态库都装载到内存完毕后，会通知Runtime进行下一步的处理</li>\n</ul>\n</li>\n<li><p>启动App时，runtime所做的事情有</p>\n<ul>\n<li>调用<code>map_images</code>进行可执行文件内容的解析和处理</li>\n<li>在<code>load_images</code>中调用<code>call_load_methods</code>,调用所有<code>Class</code>和<code>Category</code>的<code>+load</code>方法</li>\n<li>进行各种objc结构的初始化（注册Objc类，初始化类对象等等）</li>\n<li>调用C++静态初始化器和<code>__attribute((constructor))</code>修饰的函数</li>\n</ul>\n</li>\n<li><p>到此为止，可执行文件和动态库中所有的符号（Class、Protocol、Selector、IMP、…）都已经按格式成功加载到内存中，被<code>runtime</code>所管理</p>\n</li>\n<li><p>总结</p>\n<ul>\n<li>App的启动由dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库</li>\n<li>并由runtime负责加载成objc定义的结构</li>\n<li>所有初始化工作结束后，dyld就会调用main函数</li>\n<li>接下来就是<code>UIApplicationMain</code>函数，AppDelegate的<code>application:didFinishLaunchingWithOptions:</code>方法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"优化方案\"><a href=\"#优化方案\" class=\"headerlink\" title=\"优化方案\"></a>优化方案</h3><ul>\n<li>按照不同的阶段<ul>\n<li>dyld <ul>\n<li>减少动态库，合并一些动态库（定期清理不必要的动态库）</li>\n<li>减少Objc类，分类的数量，减少selector的数量（定期清理不必要的类，分类）</li>\n<li>减少C++虚函数数量</li>\n<li>Swift尽量使用struct</li>\n</ul>\n</li>\n<li>runtime<ul>\n<li>用<code>+initialize</code>和<code>dispatch_once</code>取代所有的<code>__attribute((constructor))</code>、C++静态构造器 、ObjC的<code>+load</code></li>\n</ul>\n</li>\n<li>main<ul>\n<li>在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在<code>finishLaunch</code>方法中</li>\n<li>按需加载 </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"安装包瘦身\"><a href=\"#安装包瘦身\" class=\"headerlink\" title=\"安装包瘦身\"></a>安装包瘦身</h2><ul>\n<li><p>安装包（IPA）主要由可执行文件、资源组成</p>\n</li>\n<li><p>资源（图片、视频、音频等）</p>\n<ul>\n<li>采取无损压缩</li>\n<li>去除没有用到的资源(github :LSUnusedResources）</li>\n</ul>\n</li>\n<li><p>可执行文件瘦身</p>\n<ul>\n<li>编译器优化 <ul>\n<li>Strip Linked Product 、 Make Strings Read-Only、 Symbols Hidden By Defaults设置为YES</li>\n<li>去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions 设置为NO，Other C Flags  添加 -fno-exceptions</li>\n</ul>\n</li>\n<li>利用AppCode(<a href=\"https://www.jetbrains.com/objc\">https://www.jetbrains.com/objc</a>)检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code</li>\n<li>编写LLVM插件检测出重复代码，未被调用的代码</li>\n<li>生成Link Map文件，可以查看可执行文件的具体组成（在Build Setting-&gt;Write Link Map File 改为true，就可以在Path to link map file 看到这个文件）</li>\n<li>可以借助第三方工具解析LinkMap文件：<a href=\"https://github.com/huanxsd/LinkMap\">https://github.com/huanxsd/LinkMap</a></li>\n</ul>\n</li>\n</ul>"},{"title":"LLVM","author":"Arclin","abbrlink":"6d8a8bc2","date":"2021-09-12T03:11:00.000Z","_content":"本文主要简述LLVM的概念与Clang插件开发\n\n<!-- more -->\n\n## LLVM\n\n- 官网：[https://llvm.org](https://llvm.org)\n- LLVM项目是模块化、可重用的`编译器`以及`工具链`技术的集合\n- ”LLVM“这个名称不是缩写，是项目全称\n\n## 传统的编译器架构\n\n![4ppCOx.png](https://z3.ax1x.com/2021/09/12/4ppCOx.png)\n\n- Frontend：前端\n\t- 词法分析、语法分析、语义分析、生成中间代码\n \n- Optimizer：优化器\n\t- 中间代码优化\n   \n- Backend：后端\n\t- 生成机器码\n    \n## LLVM架构\n\n![4pEhkt.png](https://z3.ax1x.com/2021/09/12/4pEhkt.png)\n\n- 不同的前端后端使用统一的中间代码`LLVM Intermediate Representation(LLVM IR)`\n- 如果需要支持一种新的编程语言，那么只需要实现一个新的前端\n- 如果需要支持一种新的硬件设备，那么只需要实现一个新的后端\n- 优化阶段是一个通用的阶段，他针对的是统一的`LLVM IR`，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做需修改\n- 相比之下，GCC的前端和后端没分得太开，前端后端耦合在了一起。所以GCC为了支持一门新的语言，或者为了支持一个新的目标平台，就变得相当困难\n- LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构（GCC家族，Java,.Net,Python,Ruby,Scheme,Haskell,D等）\n\n### Clang\n\n- Clang是LLVM的一个子项目\n- 基于LLVM架构的C/C++/Objective-C编译器前端\n- 官网：http://clang.llvm.org/\n\n- 相比于GCC，Clang具有如下优点\n\t- 编译速度快：在某些平台上，Clang的编译速度显著地快过GCC(Debug模式下编译OC速度比GCC快3倍)\n    - 占用内存小：Clang生成的AST所占用的内存是GCC的五分之一左右\n    - 模块化设计：Clang采用基于库的模块化设计，易于IDE集成及其他用途的重用\n    - 诊断信息可读性强：在编译过程中，Clang创建并保留了大量详细的元数据（metadata），有利于调试和错误报告\n    - 设计清晰简单，容易理解，易于扩展增强 \n    \n### Clang与LLVM\n\n ![WX20210912-142017.png](https://i.loli.net/2021/09/12/P7Z2sTB6ifOt4XM.png)\n\n ![WX20210912-142026.png](https://i.loli.net/2021/09/12/EZ9hnywmdQAX3LK.png)\n \n IR：中间代码\n \n \n## OC源文件的编译过程\n \n - 命令行查看编译的过程：`$ clang -ccc-print-phases main.m`\n \n ```\narclin@ArcdeMacBook-Pro TestObjC % clang -ccc-print-phases main.m \n               +- 0: input, \"main.m\", objective-c\n            +- 1: preprocessor, {0}, objective-c-cpp-output\n         +- 2: compiler, {1}, ir\n      +- 3: backend, {2}, assembler\n   +- 4: assembler, {3}, object\n+- 5: linker, {4}, image\n6: bind-arch, \"x86_64\", {5}, image\n ```\n \n  preprocessor: 预处理器，处理宏定义，展开引入的头文件内容等\n\n  complier: 编译，编译成ir中间代码\n\n  backend: 后端，转成汇编代码\n\n  assemler: 汇编，转成目标代码\n\n  linker: 链接，链接动态库、静态库等\n\n  bind-arch: 绑定当前处理器架构\n  \n- 查看preprocesser(预处理)的结果：`$ clang -E main.m`\n\n- 词法分析，生成Token：`$ clang -fmodules -E -Xlang -dump-tokens main.m`\n\n- 语法分析，生成语法树（AST，Abstract Syntax Tree）：`$ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m`\n\n## 词法分析、语法树\n\n词法分析，生成Token： `$ clang -fmodules -E -Xclang -dump-tokens main.m`\n\n[![483bNR.png](https://z3.ax1x.com/2021/09/19/483bNR.png)](https://imgtu.com/i/483bNR)\n\n语法分析，生成语法树（AST，Abstract Syntax Tree）： `$ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m`\n\n[![483d9P.png](https://z3.ax1x.com/2021/09/19/483d9P.png)](https://imgtu.com/i/483d9P)\n\n## LLVM IR\n\nLLVM IR 有三种表现形式\n\n- text：便于阅读的文本格式，类似于汇编语言，拓展名`.ll`，`$ clang -S -emit-llvm main.m`\n\n- memory：内存格式\n\n- bitcode：二进制格式，拓展名`.bc`，`$ clang -c -emit-llvm main.m`\n\nIR基本语法\n\n- 注释以分号开头\n- 全局标识以@开头，局部标识符以%开头\n- alloca, 在当前函数栈帧中分配内存\n- i32，32bit，4个字节的意思\n- align，内存对齐\n- store，写入数据\n- load，读取数据\n\n官方语法参考\n\n[https://llvm.org/docs/LangRef.html](https://llvm.org/docs/LangRef.html)\n\n\n## Clang插件开发\n\n我们可以通过开发Clang插件来对我们的代码进行静态分析，大概步骤是我们先把LLVM源码和clang源码下载到本地，然后进行编译，编译完之后我们就可以得到我们自己的编译器，然后把我们的clang插件放入指定目录，然后在Xcode里面把Xcode原来的编译器配置为我们自己的编译器，然后就可以使用我们的Clang插件了。\n\n举个例子，通过Clang我们可以对类名命名进行一些约束，比如NSString不用copy修饰的时候就警告一下。\n\n[![48lKER.png](https://z3.ax1x.com/2021/09/19/48lKER.png)](https://imgtu.com/i/48lKER)\n\n接下来我们讲解一下配置和开发步骤\n\n### 下载LLVM源码\n\n可以直接在github上面下载到源码，目前最新版本号为12.0.1，直接点击页面的`Source Code`下载，[github地址](https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.1)\n\n### 下载Clang源码\n\n同样也是[这个地址](https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.1)，目前的最新版本是12.0.1，点击`clang-12.0.1.src.tar.xz`下载\n\n下载后解压，文件夹命名为clang，把文件夹置入LLVM源码目录`llvm`文件夹的`tools`文件夹中\n\n### 安装cmake和ninja（先安装brew，https://brew.sh）\n\n使用cmake和ninja工具是为了让编译速度更快\n\n`$ brew install cmake`\n`$ brew install ninja`\n\nninja如果安装失败，可以直接从[github]( https://github.com/ninja-build/ninja/releases)获取release版（ninja-mac.zip）放入`/usr/local/bin`中\n\n\n### 编译\n\n#### 使用ninja模板进行编译\n\n在llvm源码目录内新建一个文件夹命名为`llvm_build`目录备用，用来放置ninja模板，然后在新建一个`llvm_release`文件夹，用来放置编译后的成品\n\n```\n$ cd llvm_build\n$ cmake -G Ninja ../llvm -DCMAKE_INSTALL_PREFIX=../llvm_release\n```\n\n命令执行完成后就`cd llvm_build`进入模板文件夹，然后依次执行以下命令\n\n```\n$ ninja\n$ ninja release\n```\n\n之后就可以在`llvm_release`内看到编译成品了\n\n\n#### 使用Xcode进行编译\n\n也可以生成Xcode项目再进行编译，但是速度很慢（可能需要1个多小时）\n\n在llvm源码目录内新建一个文件夹命名为`llvm_xcode`目录备用\n\n```\n$ cd llvm_xcode\n$ cmake -G Xcode ../llvm\n```\n\n生成完之后打开`llvm_xcode`内的`LLVM.xcodeproj`\n\n选择自动生成Scheme\n\n[![430RxA.png](https://z3.ax1x.com/2021/09/19/430RxA.png)](https://imgtu.com/i/430RxA)\n\n选择`ALL_BUILD` Scheme 然后就可以Cmd+R开始编译了\n\n[![43022d.png](https://z3.ax1x.com/2021/09/19/43022d.png)](https://imgtu.com/i/43022d)\n\n编译后的成品在`llvm_xcode/Debug/bin`中\n\n### 创建Clang插件\n\n在llvm源码的`/llvm/tools/clang/tools`文件夹内，新建一个文件夹，命名为`my-plugin`(举例名字)\n\n在同目录下打开文件`CMakeLists.txt`，在最后一行写入`add_clang_subdirectory(my-plugin)`后保存\n\n在`my-plugin`文件夹内新建一个文件命名为`MyPlugin.cpp`，再新建一个`CMakeLists.txt`文件到该文件夹内\n\n编辑`CMakeLists.txt`文件，写入\n\n```\nadd_llvm_library(MyPlugin MODULE BUILDTREE_ONLY MyPlugin.cpp)\n```\n\n表示可加载模块\n\n如果有很多cpp文件的话，那么也可以这么写\n```\nadd_llvm_library( MyPlugin MODULE BUILDTREE_ONLY \nMyPlugin.cpp\nMyPlugin2.cpp\nMyPlugin3.cpp\nMyPlugin4.cpp\n)\n```\n\n### 编写Clang插件\n\n因为在文本编辑器中编辑c++代码很麻烦，所以我们一般会生成一个Xcode模板（也就是上面提到那个`使用Xcode进行编译`的Xcode模板）帮我们辅助编写C++代码\n\n所以我们在llvm源码目录的`llvm_xcode`文件夹内执行一下`cmake -G Xcode ../llvm`命令，就可以得到一个Xcode模板，打开工程之后，就可以看到我们的插件目录\n\n[![4369gg.png](https://z3.ax1x.com/2021/09/19/4369gg.png)](https://imgtu.com/i/4369gg)\n\n#### 基本结构\n\n```\n/// 必要的头文件，主要用来解析语法树\n#include <iostream>\n#include \"clang/AST/AST.h\"\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/ASTMatchers/ASTMatchers.h\"\n#include \"clang/ASTMatchers/ASTMatchFinder.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Frontend/FrontendPluginRegistry.h\"\n\nusing namespace clang;\nusing namespace std;\nusing namespace llvm;\nusing namespace clang::ast_matchers;\n\nnamespace MyPlugin {\n\n    class MyASTConsumer : public ASTConsumer {\n    public:\n        /// 每当生成一棵语法树就会调用这个方法\n        void HandleTranslationUnit(ASTContext &Ctx) {\n            cout << \"MyPlugin-HandleTranslationUnit\" << endl;\n        }\n    };\n\n    class MyAction : public PluginASTAction {\n    public:\n        /// 一定要重写的两个父类方法，指定Consumer\n        unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &ci, StringRef InFile) {\n            return unique_ptr<MyASTConsumer> (new MyASTConsumer);\n        }\n        \n        bool ParseArgs(const CompilerInstance &CI, const std::vector<std::string> &arg) {\n            return true;\n        }\n    };\n}\n\n/// 注册插件\nstatic FrontendPluginRegistry::Add<MyPlugin::MyAction>\nX(\"MyPlugin\", \"The MyPlugin is my first clang-plugin.\");\n```\n\n编译`MyPlugin` Scheme\n\n[![481kdA.png](https://z3.ax1x.com/2021/09/19/481kdA.png)](https://imgtu.com/i/481kdA)\n\n\n最后得到成品`MyPlugin.dylib`\n\n[![481eRf.png](https://z3.ax1x.com/2021/09/19/481eRf.png)](https://imgtu.com/i/481eRf)\n\n### 使用Clang插件\n\n`Show in finder`取出`MyPlugin.dylib`之后，我们新建一个测试工程\n\n在新建的Xcode项目中指定加载插件：`Build Settings > OTHER_CFLAGS`，双击输入框后输入\n\n`-Xclang -load -Xclang 动态库路径 -Xclang -add-plugin -Xclang 插件名称`，回车\n\n[![43XojJ.png](https://z3.ax1x.com/2021/09/19/43XojJ.png)](https://imgtu.com/i/43XojJ)\n\n因为Xcode自带的编译器不允许加载插件，所以我们使用刚才自己编译好的编译器\n\n\n首先下载[Xcode破解插件](https://github.com/weizhangCoder/XcodeHacking)\n\n进入目录`XcodeHacking/HackedClang.xcplugin/Contents/Resources`\n\n修改`HackedClang.xcspec`\n\n```\nExecPath = \"/opt/llvm/llvm_build/bin/clang\";\n```\n\n改为我们刚才编译好的clang的全路径\n\n```\nExecPath = \"/Users/arclin/Downloads/llvm-project-llvmorg-12.0.1/llvm-release/bin/clang\";\n```\n\n然后在XcodeHacking目录下进行命令行，\n\n将XcodeHacking的内容剪切到Xcode内部\n\n```\n$ sudo mv HackedClang.xcplugin `xcode-select -p`/../PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer/Library/Xcode/Plug-ins\n$ sudo mv HackedBuildSystem.xcspec `xcode-select -p`/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications\n```\n\n这时候Xcode就应该有多一个编译器可选项，我们选择`Clang LLVM Trunk`\n\n[![48lXI1.png](https://z3.ax1x.com/2021/09/19/48lXI1.png)](https://imgtu.com/i/48lXI1)\n\n\n然后就可以Clean一下后编译进行测试。\n\n自己在测试的时候发生了一些报错的问题（可能我是用的M1笔记本的原因），可以修改`Build System`的值为`Legacy Build System`解决\n\n[![48lsxS.png](https://z3.ax1x.com/2021/09/19/48lsxS.png)](https://imgtu.com/i/48lsxS)\n\n如果发生了`CADisplayLink' is unavailable: not available on macOS`的问题，那尝试新建一个Mac项目\n\n\n最后贴出完整的插件代码仅供参考\n\n```\n#include <iostream>\n#include \"clang/AST/AST.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/ASTMatchers/ASTMatchers.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/ASTMatchers/ASTMatchFinder.h\"\n#include \"clang/Frontend/FrontendPluginRegistry.h\"\n\n// 声明使用命名空间\nusing namespace clang;\nusing namespace std;\nusing namespace llvm;\nusing namespace clang::ast_matchers;\n\n// 插件命名空间\nnamespace MyPlugin {\n\n    // 第三步：扫描完毕回调\n    // 4、自定义回调类，继承自MatchCallback\n    class MyMatchCallback : public MatchFinder::MatchCallback {\n\n    private:\n        // CI传递路径：MyASTAction类中的CreateASTConsumer方法参数 -> MyASTConsumer的构造函数 -> MyMatchCallback的私有属性，通过构造函数从MyASTConsumer构造函数中获取\n        CompilerInstance &CI;\n\n        // 判断是否是自己的文件\n        bool isUserSourceCode(const string fileName) {\n            // 文件名不为空\n            if (fileName.empty()) return false;\n            // 非Xcode中的代码都认为是用户的\n            if (0 == fileName.find(\"/Applications/Xcode.app/\")) return false;\n            return true;\n        }\n\n        // 判断是否应该用copy修饰\n        bool isShouldUseCopy(const string typeStr) {\n            // 判断类型是否是 NSString / NSArray / NSDictionary\n            if (typeStr.find(\"NSString\") != string::npos ||\n                typeStr.find(\"NSArray\") != string::npos ||\n                typeStr.find(\"NSDictionary\") != string::npos) {\n                return true;\n            }\n            return false;\n        }\n\n    public:\n        // 构造方法\n        MyMatchCallback(CompilerInstance &CI):CI(CI) {}\n\n        // 重载run方法\n        void run(const MatchFinder::MatchResult &Result) {\n            // 通过Result获取节点对象，根据节点id(\"objcPropertyDecl\")获取(此id需要与MyASTConsumer构造方法中bind的id一致)\n            const ObjCPropertyDecl *propertyDecl = Result.Nodes.getNodeAs<ObjCPropertyDecl>(\"objcPropertyDecl\");\n            // 获取文件名称（包含路径）\n            string fileName = CI.getSourceManager().getFilename(propertyDecl->getSourceRange().getBegin()).str();\n            // 如果节点有值 && 是用户文件\n            if (propertyDecl && isUserSourceCode(fileName)) {\n                // 获取节点的类型，并转成字符串\n                string typeStr = propertyDecl->getType().getAsString();\n                // 节点的描述信息\n                ObjCPropertyAttribute::Kind attrKind = propertyDecl->getPropertyAttributes();\n                // 应该使用copy，但是没有使用copy\n                if (isShouldUseCopy(typeStr) && !(attrKind & ObjCPropertyAttribute::kind_copy)) {\n                    // 通过CI获取诊断引擎\n                    DiagnosticsEngine &diag = CI.getDiagnostics();\n                    // Report 报告\n                    /**\n                     错误位置：getLocation 节点位置\n                     错误：getCustomDiagID（等级，提示）\n                     DiagnosticsEngine::Warning 警告\n                     DiagnosticsEngine::Error 错误\n                     */\n                    diag.Report(propertyDecl->getLocation(), diag.getCustomDiagID(DiagnosticsEngine::Warning, \"%0 - 推荐使用copy修饰该属性\"))<< typeStr;\n                }\n            }\n        }\n    };\n\n    // 第二步：扫描配置完毕\n    // 3、自定义MyASTConsumer，继承自抽象类 ASTConsumer，用于监听AST节点的信息 -- 过滤器\n    class MyASTConsumer : public ASTConsumer {\n    private:\n        // AST 节点查找器（过滤器）\n        MatchFinder matcher;\n        // 回调对象\n        MyMatchCallback callback;\n\n    public:\n        // 构造方法中创建MatchFinder对象\n        MyASTConsumer(CompilerInstance &CI):callback(CI) { // 构造即将CI传递给callback\n            // 添加一个MatchFinder，每个objcPropertyDecl节点绑定一个objcPropertyDecl标识（去匹配objcPropertyDecl节点）\n            // 回调callback，其实是在CJLMatchCallback里面重写run方法（真正回调的是回调run方法）\nmatcher.addMatcher(objcPropertyDecl().bind(\"objcPropertyDecl\"), &callback);\n        }\n\n        // 重载两个方法 HandleTopLevelDecl 和 HandleTranslationUnit\n\n        // 解析完毕一个顶级的声明就回调一次（顶级节点，即全局变量，属性，函数等）\n        bool HandleTopLevelDecl(DeclGroupRef D) {\n//            cout<<\"正在解析...\"<<endl;\n            return true;\n        }\n\n        // 当整个文件都解析完毕后回调\n        void HandleTranslationUnit(ASTContext &Ctx) {\n//            cout<<\"文件解析完毕！！！\"<<endl;\n            // 将文件解析完毕后的上下文context（即AST语法树） 给 matcher\n            matcher.matchAST(Ctx);\n        }\n    };\n\n    //2、继承PluginASTAction，实现我们自定义的MyASTAction，即自定义AST语法树行为\n    class MyASTAction : public PluginASTAction {\n    public:\n\n        // 重载ParseArgs 和 CreateASTConsumer方法\n\n        /*\n         解析给定的插件命令行参数\n         - param CI 编译器实例，用于报告诊断。\n         - return 如果解析成功，则为true；否则，插件将被销毁，并且不执行任何操作。该插件负责使用CompilerInstance的Diagnostic对象报告错误。\n         */\n        bool ParseArgs(const CompilerInstance &CI, const std::vector<std::string> &arg) {\n            return true;\n        }\n\n        // 返回自定义的MyASTConsumer对象，抽象类ASTConsumer的子类\n        unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI, StringRef InFile) {\n            /**\n             传递CI\n             CI用于：\n             - 判断文件是否是用户的\n             - 抛出警告\n             */\n            return unique_ptr<MyASTConsumer>(new MyASTConsumer(CI));\n        }\n    };\n}\n\n// 第一步：注册插件，并自定义MyASTAction类\n// 1、注册插件\nstatic FrontendPluginRegistry::Add<MyPlugin::MyASTAction> X(\"MyPlugin\", \"this is MyPlugin\");\n```\n\n\n> 参考：https://juejin.cn/post/7004633055012864031","source":"_posts/LLVM.md","raw":"title: LLVM\nauthor: Arclin\ntags:\n  - iOS\n  - 底层原理\ncategories:\n  - iOS\nabbrlink: 6d8a8bc2\ndate: 2021-09-12 11:11:00\n---\n本文主要简述LLVM的概念与Clang插件开发\n\n<!-- more -->\n\n## LLVM\n\n- 官网：[https://llvm.org](https://llvm.org)\n- LLVM项目是模块化、可重用的`编译器`以及`工具链`技术的集合\n- ”LLVM“这个名称不是缩写，是项目全称\n\n## 传统的编译器架构\n\n![4ppCOx.png](https://z3.ax1x.com/2021/09/12/4ppCOx.png)\n\n- Frontend：前端\n\t- 词法分析、语法分析、语义分析、生成中间代码\n \n- Optimizer：优化器\n\t- 中间代码优化\n   \n- Backend：后端\n\t- 生成机器码\n    \n## LLVM架构\n\n![4pEhkt.png](https://z3.ax1x.com/2021/09/12/4pEhkt.png)\n\n- 不同的前端后端使用统一的中间代码`LLVM Intermediate Representation(LLVM IR)`\n- 如果需要支持一种新的编程语言，那么只需要实现一个新的前端\n- 如果需要支持一种新的硬件设备，那么只需要实现一个新的后端\n- 优化阶段是一个通用的阶段，他针对的是统一的`LLVM IR`，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做需修改\n- 相比之下，GCC的前端和后端没分得太开，前端后端耦合在了一起。所以GCC为了支持一门新的语言，或者为了支持一个新的目标平台，就变得相当困难\n- LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构（GCC家族，Java,.Net,Python,Ruby,Scheme,Haskell,D等）\n\n### Clang\n\n- Clang是LLVM的一个子项目\n- 基于LLVM架构的C/C++/Objective-C编译器前端\n- 官网：http://clang.llvm.org/\n\n- 相比于GCC，Clang具有如下优点\n\t- 编译速度快：在某些平台上，Clang的编译速度显著地快过GCC(Debug模式下编译OC速度比GCC快3倍)\n    - 占用内存小：Clang生成的AST所占用的内存是GCC的五分之一左右\n    - 模块化设计：Clang采用基于库的模块化设计，易于IDE集成及其他用途的重用\n    - 诊断信息可读性强：在编译过程中，Clang创建并保留了大量详细的元数据（metadata），有利于调试和错误报告\n    - 设计清晰简单，容易理解，易于扩展增强 \n    \n### Clang与LLVM\n\n ![WX20210912-142017.png](https://i.loli.net/2021/09/12/P7Z2sTB6ifOt4XM.png)\n\n ![WX20210912-142026.png](https://i.loli.net/2021/09/12/EZ9hnywmdQAX3LK.png)\n \n IR：中间代码\n \n \n## OC源文件的编译过程\n \n - 命令行查看编译的过程：`$ clang -ccc-print-phases main.m`\n \n ```\narclin@ArcdeMacBook-Pro TestObjC % clang -ccc-print-phases main.m \n               +- 0: input, \"main.m\", objective-c\n            +- 1: preprocessor, {0}, objective-c-cpp-output\n         +- 2: compiler, {1}, ir\n      +- 3: backend, {2}, assembler\n   +- 4: assembler, {3}, object\n+- 5: linker, {4}, image\n6: bind-arch, \"x86_64\", {5}, image\n ```\n \n  preprocessor: 预处理器，处理宏定义，展开引入的头文件内容等\n\n  complier: 编译，编译成ir中间代码\n\n  backend: 后端，转成汇编代码\n\n  assemler: 汇编，转成目标代码\n\n  linker: 链接，链接动态库、静态库等\n\n  bind-arch: 绑定当前处理器架构\n  \n- 查看preprocesser(预处理)的结果：`$ clang -E main.m`\n\n- 词法分析，生成Token：`$ clang -fmodules -E -Xlang -dump-tokens main.m`\n\n- 语法分析，生成语法树（AST，Abstract Syntax Tree）：`$ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m`\n\n## 词法分析、语法树\n\n词法分析，生成Token： `$ clang -fmodules -E -Xclang -dump-tokens main.m`\n\n[![483bNR.png](https://z3.ax1x.com/2021/09/19/483bNR.png)](https://imgtu.com/i/483bNR)\n\n语法分析，生成语法树（AST，Abstract Syntax Tree）： `$ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m`\n\n[![483d9P.png](https://z3.ax1x.com/2021/09/19/483d9P.png)](https://imgtu.com/i/483d9P)\n\n## LLVM IR\n\nLLVM IR 有三种表现形式\n\n- text：便于阅读的文本格式，类似于汇编语言，拓展名`.ll`，`$ clang -S -emit-llvm main.m`\n\n- memory：内存格式\n\n- bitcode：二进制格式，拓展名`.bc`，`$ clang -c -emit-llvm main.m`\n\nIR基本语法\n\n- 注释以分号开头\n- 全局标识以@开头，局部标识符以%开头\n- alloca, 在当前函数栈帧中分配内存\n- i32，32bit，4个字节的意思\n- align，内存对齐\n- store，写入数据\n- load，读取数据\n\n官方语法参考\n\n[https://llvm.org/docs/LangRef.html](https://llvm.org/docs/LangRef.html)\n\n\n## Clang插件开发\n\n我们可以通过开发Clang插件来对我们的代码进行静态分析，大概步骤是我们先把LLVM源码和clang源码下载到本地，然后进行编译，编译完之后我们就可以得到我们自己的编译器，然后把我们的clang插件放入指定目录，然后在Xcode里面把Xcode原来的编译器配置为我们自己的编译器，然后就可以使用我们的Clang插件了。\n\n举个例子，通过Clang我们可以对类名命名进行一些约束，比如NSString不用copy修饰的时候就警告一下。\n\n[![48lKER.png](https://z3.ax1x.com/2021/09/19/48lKER.png)](https://imgtu.com/i/48lKER)\n\n接下来我们讲解一下配置和开发步骤\n\n### 下载LLVM源码\n\n可以直接在github上面下载到源码，目前最新版本号为12.0.1，直接点击页面的`Source Code`下载，[github地址](https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.1)\n\n### 下载Clang源码\n\n同样也是[这个地址](https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.1)，目前的最新版本是12.0.1，点击`clang-12.0.1.src.tar.xz`下载\n\n下载后解压，文件夹命名为clang，把文件夹置入LLVM源码目录`llvm`文件夹的`tools`文件夹中\n\n### 安装cmake和ninja（先安装brew，https://brew.sh）\n\n使用cmake和ninja工具是为了让编译速度更快\n\n`$ brew install cmake`\n`$ brew install ninja`\n\nninja如果安装失败，可以直接从[github]( https://github.com/ninja-build/ninja/releases)获取release版（ninja-mac.zip）放入`/usr/local/bin`中\n\n\n### 编译\n\n#### 使用ninja模板进行编译\n\n在llvm源码目录内新建一个文件夹命名为`llvm_build`目录备用，用来放置ninja模板，然后在新建一个`llvm_release`文件夹，用来放置编译后的成品\n\n```\n$ cd llvm_build\n$ cmake -G Ninja ../llvm -DCMAKE_INSTALL_PREFIX=../llvm_release\n```\n\n命令执行完成后就`cd llvm_build`进入模板文件夹，然后依次执行以下命令\n\n```\n$ ninja\n$ ninja release\n```\n\n之后就可以在`llvm_release`内看到编译成品了\n\n\n#### 使用Xcode进行编译\n\n也可以生成Xcode项目再进行编译，但是速度很慢（可能需要1个多小时）\n\n在llvm源码目录内新建一个文件夹命名为`llvm_xcode`目录备用\n\n```\n$ cd llvm_xcode\n$ cmake -G Xcode ../llvm\n```\n\n生成完之后打开`llvm_xcode`内的`LLVM.xcodeproj`\n\n选择自动生成Scheme\n\n[![430RxA.png](https://z3.ax1x.com/2021/09/19/430RxA.png)](https://imgtu.com/i/430RxA)\n\n选择`ALL_BUILD` Scheme 然后就可以Cmd+R开始编译了\n\n[![43022d.png](https://z3.ax1x.com/2021/09/19/43022d.png)](https://imgtu.com/i/43022d)\n\n编译后的成品在`llvm_xcode/Debug/bin`中\n\n### 创建Clang插件\n\n在llvm源码的`/llvm/tools/clang/tools`文件夹内，新建一个文件夹，命名为`my-plugin`(举例名字)\n\n在同目录下打开文件`CMakeLists.txt`，在最后一行写入`add_clang_subdirectory(my-plugin)`后保存\n\n在`my-plugin`文件夹内新建一个文件命名为`MyPlugin.cpp`，再新建一个`CMakeLists.txt`文件到该文件夹内\n\n编辑`CMakeLists.txt`文件，写入\n\n```\nadd_llvm_library(MyPlugin MODULE BUILDTREE_ONLY MyPlugin.cpp)\n```\n\n表示可加载模块\n\n如果有很多cpp文件的话，那么也可以这么写\n```\nadd_llvm_library( MyPlugin MODULE BUILDTREE_ONLY \nMyPlugin.cpp\nMyPlugin2.cpp\nMyPlugin3.cpp\nMyPlugin4.cpp\n)\n```\n\n### 编写Clang插件\n\n因为在文本编辑器中编辑c++代码很麻烦，所以我们一般会生成一个Xcode模板（也就是上面提到那个`使用Xcode进行编译`的Xcode模板）帮我们辅助编写C++代码\n\n所以我们在llvm源码目录的`llvm_xcode`文件夹内执行一下`cmake -G Xcode ../llvm`命令，就可以得到一个Xcode模板，打开工程之后，就可以看到我们的插件目录\n\n[![4369gg.png](https://z3.ax1x.com/2021/09/19/4369gg.png)](https://imgtu.com/i/4369gg)\n\n#### 基本结构\n\n```\n/// 必要的头文件，主要用来解析语法树\n#include <iostream>\n#include \"clang/AST/AST.h\"\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/ASTMatchers/ASTMatchers.h\"\n#include \"clang/ASTMatchers/ASTMatchFinder.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/Frontend/FrontendPluginRegistry.h\"\n\nusing namespace clang;\nusing namespace std;\nusing namespace llvm;\nusing namespace clang::ast_matchers;\n\nnamespace MyPlugin {\n\n    class MyASTConsumer : public ASTConsumer {\n    public:\n        /// 每当生成一棵语法树就会调用这个方法\n        void HandleTranslationUnit(ASTContext &Ctx) {\n            cout << \"MyPlugin-HandleTranslationUnit\" << endl;\n        }\n    };\n\n    class MyAction : public PluginASTAction {\n    public:\n        /// 一定要重写的两个父类方法，指定Consumer\n        unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &ci, StringRef InFile) {\n            return unique_ptr<MyASTConsumer> (new MyASTConsumer);\n        }\n        \n        bool ParseArgs(const CompilerInstance &CI, const std::vector<std::string> &arg) {\n            return true;\n        }\n    };\n}\n\n/// 注册插件\nstatic FrontendPluginRegistry::Add<MyPlugin::MyAction>\nX(\"MyPlugin\", \"The MyPlugin is my first clang-plugin.\");\n```\n\n编译`MyPlugin` Scheme\n\n[![481kdA.png](https://z3.ax1x.com/2021/09/19/481kdA.png)](https://imgtu.com/i/481kdA)\n\n\n最后得到成品`MyPlugin.dylib`\n\n[![481eRf.png](https://z3.ax1x.com/2021/09/19/481eRf.png)](https://imgtu.com/i/481eRf)\n\n### 使用Clang插件\n\n`Show in finder`取出`MyPlugin.dylib`之后，我们新建一个测试工程\n\n在新建的Xcode项目中指定加载插件：`Build Settings > OTHER_CFLAGS`，双击输入框后输入\n\n`-Xclang -load -Xclang 动态库路径 -Xclang -add-plugin -Xclang 插件名称`，回车\n\n[![43XojJ.png](https://z3.ax1x.com/2021/09/19/43XojJ.png)](https://imgtu.com/i/43XojJ)\n\n因为Xcode自带的编译器不允许加载插件，所以我们使用刚才自己编译好的编译器\n\n\n首先下载[Xcode破解插件](https://github.com/weizhangCoder/XcodeHacking)\n\n进入目录`XcodeHacking/HackedClang.xcplugin/Contents/Resources`\n\n修改`HackedClang.xcspec`\n\n```\nExecPath = \"/opt/llvm/llvm_build/bin/clang\";\n```\n\n改为我们刚才编译好的clang的全路径\n\n```\nExecPath = \"/Users/arclin/Downloads/llvm-project-llvmorg-12.0.1/llvm-release/bin/clang\";\n```\n\n然后在XcodeHacking目录下进行命令行，\n\n将XcodeHacking的内容剪切到Xcode内部\n\n```\n$ sudo mv HackedClang.xcplugin `xcode-select -p`/../PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer/Library/Xcode/Plug-ins\n$ sudo mv HackedBuildSystem.xcspec `xcode-select -p`/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications\n```\n\n这时候Xcode就应该有多一个编译器可选项，我们选择`Clang LLVM Trunk`\n\n[![48lXI1.png](https://z3.ax1x.com/2021/09/19/48lXI1.png)](https://imgtu.com/i/48lXI1)\n\n\n然后就可以Clean一下后编译进行测试。\n\n自己在测试的时候发生了一些报错的问题（可能我是用的M1笔记本的原因），可以修改`Build System`的值为`Legacy Build System`解决\n\n[![48lsxS.png](https://z3.ax1x.com/2021/09/19/48lsxS.png)](https://imgtu.com/i/48lsxS)\n\n如果发生了`CADisplayLink' is unavailable: not available on macOS`的问题，那尝试新建一个Mac项目\n\n\n最后贴出完整的插件代码仅供参考\n\n```\n#include <iostream>\n#include \"clang/AST/AST.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/ASTConsumer.h\"\n#include \"clang/ASTMatchers/ASTMatchers.h\"\n#include \"clang/Frontend/CompilerInstance.h\"\n#include \"clang/ASTMatchers/ASTMatchFinder.h\"\n#include \"clang/Frontend/FrontendPluginRegistry.h\"\n\n// 声明使用命名空间\nusing namespace clang;\nusing namespace std;\nusing namespace llvm;\nusing namespace clang::ast_matchers;\n\n// 插件命名空间\nnamespace MyPlugin {\n\n    // 第三步：扫描完毕回调\n    // 4、自定义回调类，继承自MatchCallback\n    class MyMatchCallback : public MatchFinder::MatchCallback {\n\n    private:\n        // CI传递路径：MyASTAction类中的CreateASTConsumer方法参数 -> MyASTConsumer的构造函数 -> MyMatchCallback的私有属性，通过构造函数从MyASTConsumer构造函数中获取\n        CompilerInstance &CI;\n\n        // 判断是否是自己的文件\n        bool isUserSourceCode(const string fileName) {\n            // 文件名不为空\n            if (fileName.empty()) return false;\n            // 非Xcode中的代码都认为是用户的\n            if (0 == fileName.find(\"/Applications/Xcode.app/\")) return false;\n            return true;\n        }\n\n        // 判断是否应该用copy修饰\n        bool isShouldUseCopy(const string typeStr) {\n            // 判断类型是否是 NSString / NSArray / NSDictionary\n            if (typeStr.find(\"NSString\") != string::npos ||\n                typeStr.find(\"NSArray\") != string::npos ||\n                typeStr.find(\"NSDictionary\") != string::npos) {\n                return true;\n            }\n            return false;\n        }\n\n    public:\n        // 构造方法\n        MyMatchCallback(CompilerInstance &CI):CI(CI) {}\n\n        // 重载run方法\n        void run(const MatchFinder::MatchResult &Result) {\n            // 通过Result获取节点对象，根据节点id(\"objcPropertyDecl\")获取(此id需要与MyASTConsumer构造方法中bind的id一致)\n            const ObjCPropertyDecl *propertyDecl = Result.Nodes.getNodeAs<ObjCPropertyDecl>(\"objcPropertyDecl\");\n            // 获取文件名称（包含路径）\n            string fileName = CI.getSourceManager().getFilename(propertyDecl->getSourceRange().getBegin()).str();\n            // 如果节点有值 && 是用户文件\n            if (propertyDecl && isUserSourceCode(fileName)) {\n                // 获取节点的类型，并转成字符串\n                string typeStr = propertyDecl->getType().getAsString();\n                // 节点的描述信息\n                ObjCPropertyAttribute::Kind attrKind = propertyDecl->getPropertyAttributes();\n                // 应该使用copy，但是没有使用copy\n                if (isShouldUseCopy(typeStr) && !(attrKind & ObjCPropertyAttribute::kind_copy)) {\n                    // 通过CI获取诊断引擎\n                    DiagnosticsEngine &diag = CI.getDiagnostics();\n                    // Report 报告\n                    /**\n                     错误位置：getLocation 节点位置\n                     错误：getCustomDiagID（等级，提示）\n                     DiagnosticsEngine::Warning 警告\n                     DiagnosticsEngine::Error 错误\n                     */\n                    diag.Report(propertyDecl->getLocation(), diag.getCustomDiagID(DiagnosticsEngine::Warning, \"%0 - 推荐使用copy修饰该属性\"))<< typeStr;\n                }\n            }\n        }\n    };\n\n    // 第二步：扫描配置完毕\n    // 3、自定义MyASTConsumer，继承自抽象类 ASTConsumer，用于监听AST节点的信息 -- 过滤器\n    class MyASTConsumer : public ASTConsumer {\n    private:\n        // AST 节点查找器（过滤器）\n        MatchFinder matcher;\n        // 回调对象\n        MyMatchCallback callback;\n\n    public:\n        // 构造方法中创建MatchFinder对象\n        MyASTConsumer(CompilerInstance &CI):callback(CI) { // 构造即将CI传递给callback\n            // 添加一个MatchFinder，每个objcPropertyDecl节点绑定一个objcPropertyDecl标识（去匹配objcPropertyDecl节点）\n            // 回调callback，其实是在CJLMatchCallback里面重写run方法（真正回调的是回调run方法）\nmatcher.addMatcher(objcPropertyDecl().bind(\"objcPropertyDecl\"), &callback);\n        }\n\n        // 重载两个方法 HandleTopLevelDecl 和 HandleTranslationUnit\n\n        // 解析完毕一个顶级的声明就回调一次（顶级节点，即全局变量，属性，函数等）\n        bool HandleTopLevelDecl(DeclGroupRef D) {\n//            cout<<\"正在解析...\"<<endl;\n            return true;\n        }\n\n        // 当整个文件都解析完毕后回调\n        void HandleTranslationUnit(ASTContext &Ctx) {\n//            cout<<\"文件解析完毕！！！\"<<endl;\n            // 将文件解析完毕后的上下文context（即AST语法树） 给 matcher\n            matcher.matchAST(Ctx);\n        }\n    };\n\n    //2、继承PluginASTAction，实现我们自定义的MyASTAction，即自定义AST语法树行为\n    class MyASTAction : public PluginASTAction {\n    public:\n\n        // 重载ParseArgs 和 CreateASTConsumer方法\n\n        /*\n         解析给定的插件命令行参数\n         - param CI 编译器实例，用于报告诊断。\n         - return 如果解析成功，则为true；否则，插件将被销毁，并且不执行任何操作。该插件负责使用CompilerInstance的Diagnostic对象报告错误。\n         */\n        bool ParseArgs(const CompilerInstance &CI, const std::vector<std::string> &arg) {\n            return true;\n        }\n\n        // 返回自定义的MyASTConsumer对象，抽象类ASTConsumer的子类\n        unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI, StringRef InFile) {\n            /**\n             传递CI\n             CI用于：\n             - 判断文件是否是用户的\n             - 抛出警告\n             */\n            return unique_ptr<MyASTConsumer>(new MyASTConsumer(CI));\n        }\n    };\n}\n\n// 第一步：注册插件，并自定义MyASTAction类\n// 1、注册插件\nstatic FrontendPluginRegistry::Add<MyPlugin::MyASTAction> X(\"MyPlugin\", \"this is MyPlugin\");\n```\n\n\n> 参考：https://juejin.cn/post/7004633055012864031","slug":"LLVM","published":1,"updated":"2021-09-19T13:16:22.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cktr8vw9c000042n0f23cgp8c","content":"<p>本文主要简述LLVM的概念与Clang插件开发</p>\n<span id=\"more\"></span>\n\n<h2 id=\"LLVM\"><a href=\"#LLVM\" class=\"headerlink\" title=\"LLVM\"></a>LLVM</h2><ul>\n<li>官网：<a href=\"https://llvm.org/\">https://llvm.org</a></li>\n<li>LLVM项目是模块化、可重用的<code>编译器</code>以及<code>工具链</code>技术的集合</li>\n<li>”LLVM“这个名称不是缩写，是项目全称</li>\n</ul>\n<h2 id=\"传统的编译器架构\"><a href=\"#传统的编译器架构\" class=\"headerlink\" title=\"传统的编译器架构\"></a>传统的编译器架构</h2><p><img src=\"https://z3.ax1x.com/2021/09/12/4ppCOx.png\" alt=\"4ppCOx.png\"></p>\n<ul>\n<li>Frontend：前端<ul>\n<li>词法分析、语法分析、语义分析、生成中间代码</li>\n</ul>\n</li>\n<li>Optimizer：优化器<ul>\n<li>中间代码优化</li>\n</ul>\n</li>\n<li>Backend：后端<ul>\n<li>生成机器码</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"LLVM架构\"><a href=\"#LLVM架构\" class=\"headerlink\" title=\"LLVM架构\"></a>LLVM架构</h2><p><img src=\"https://z3.ax1x.com/2021/09/12/4pEhkt.png\" alt=\"4pEhkt.png\"></p>\n<ul>\n<li>不同的前端后端使用统一的中间代码<code>LLVM Intermediate Representation(LLVM IR)</code></li>\n<li>如果需要支持一种新的编程语言，那么只需要实现一个新的前端</li>\n<li>如果需要支持一种新的硬件设备，那么只需要实现一个新的后端</li>\n<li>优化阶段是一个通用的阶段，他针对的是统一的<code>LLVM IR</code>，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做需修改</li>\n<li>相比之下，GCC的前端和后端没分得太开，前端后端耦合在了一起。所以GCC为了支持一门新的语言，或者为了支持一个新的目标平台，就变得相当困难</li>\n<li>LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构（GCC家族，Java,.Net,Python,Ruby,Scheme,Haskell,D等）</li>\n</ul>\n<h3 id=\"Clang\"><a href=\"#Clang\" class=\"headerlink\" title=\"Clang\"></a>Clang</h3><ul>\n<li><p>Clang是LLVM的一个子项目</p>\n</li>\n<li><p>基于LLVM架构的C/C++/Objective-C编译器前端</p>\n</li>\n<li><p>官网：<a href=\"http://clang.llvm.org/\">http://clang.llvm.org/</a></p>\n</li>\n<li><p>相比于GCC，Clang具有如下优点</p>\n<ul>\n<li>编译速度快：在某些平台上，Clang的编译速度显著地快过GCC(Debug模式下编译OC速度比GCC快3倍)</li>\n<li>占用内存小：Clang生成的AST所占用的内存是GCC的五分之一左右</li>\n<li>模块化设计：Clang采用基于库的模块化设计，易于IDE集成及其他用途的重用</li>\n<li>诊断信息可读性强：在编译过程中，Clang创建并保留了大量详细的元数据（metadata），有利于调试和错误报告</li>\n<li>设计清晰简单，容易理解，易于扩展增强 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Clang与LLVM\"><a href=\"#Clang与LLVM\" class=\"headerlink\" title=\"Clang与LLVM\"></a>Clang与LLVM</h3><p> <img src=\"https://i.loli.net/2021/09/12/P7Z2sTB6ifOt4XM.png\" alt=\"WX20210912-142017.png\"></p>\n<p> <img src=\"https://i.loli.net/2021/09/12/EZ9hnywmdQAX3LK.png\" alt=\"WX20210912-142026.png\"></p>\n<p> IR：中间代码</p>\n<h2 id=\"OC源文件的编译过程\"><a href=\"#OC源文件的编译过程\" class=\"headerlink\" title=\"OC源文件的编译过程\"></a>OC源文件的编译过程</h2><ul>\n<li>命令行查看编译的过程：<code>$ clang -ccc-print-phases main.m</code></li>\n</ul>\n <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arclin<span class=\"keyword\">@ArcdeMacBook-Pro</span> TestObjC % clang -ccc-print-phases main.m </span><br><span class=\"line\">               +- <span class=\"number\">0</span>: input, <span class=\"string\">&quot;main.m&quot;</span>, objective-c</span><br><span class=\"line\">            +- <span class=\"number\">1</span>: preprocessor, &#123;<span class=\"number\">0</span>&#125;, objective-c-cpp-output</span><br><span class=\"line\">         +- <span class=\"number\">2</span>: compiler, &#123;<span class=\"number\">1</span>&#125;, ir</span><br><span class=\"line\">      +- <span class=\"number\">3</span>: backend, &#123;<span class=\"number\">2</span>&#125;, assembler</span><br><span class=\"line\">   +- <span class=\"number\">4</span>: assembler, &#123;<span class=\"number\">3</span>&#125;, <span class=\"selector-tag\">object</span></span><br><span class=\"line\">+- <span class=\"number\">5</span>: linker, &#123;<span class=\"number\">4</span>&#125;, image</span><br><span class=\"line\"><span class=\"number\">6</span>: bind-arch, <span class=\"string\">&quot;x86_64&quot;</span>, &#123;<span class=\"number\">5</span>&#125;, image</span><br></pre></td></tr></table></figure>\n<p>  preprocessor: 预处理器，处理宏定义，展开引入的头文件内容等</p>\n<p>  complier: 编译，编译成ir中间代码</p>\n<p>  backend: 后端，转成汇编代码</p>\n<p>  assemler: 汇编，转成目标代码</p>\n<p>  linker: 链接，链接动态库、静态库等</p>\n<p>  bind-arch: 绑定当前处理器架构</p>\n<ul>\n<li><p>查看preprocesser(预处理)的结果：<code>$ clang -E main.m</code></p>\n</li>\n<li><p>词法分析，生成Token：<code>$ clang -fmodules -E -Xlang -dump-tokens main.m</code></p>\n</li>\n<li><p>语法分析，生成语法树（AST，Abstract Syntax Tree）：<code>$ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</code></p>\n</li>\n</ul>\n<h2 id=\"词法分析、语法树\"><a href=\"#词法分析、语法树\" class=\"headerlink\" title=\"词法分析、语法树\"></a>词法分析、语法树</h2><p>词法分析，生成Token： <code>$ clang -fmodules -E -Xclang -dump-tokens main.m</code></p>\n<p><a href=\"https://imgtu.com/i/483bNR\"><img src=\"https://z3.ax1x.com/2021/09/19/483bNR.png\" alt=\"483bNR.png\"></a></p>\n<p>语法分析，生成语法树（AST，Abstract Syntax Tree）： <code>$ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</code></p>\n<p><a href=\"https://imgtu.com/i/483d9P\"><img src=\"https://z3.ax1x.com/2021/09/19/483d9P.png\" alt=\"483d9P.png\"></a></p>\n<h2 id=\"LLVM-IR\"><a href=\"#LLVM-IR\" class=\"headerlink\" title=\"LLVM IR\"></a>LLVM IR</h2><p>LLVM IR 有三种表现形式</p>\n<ul>\n<li><p>text：便于阅读的文本格式，类似于汇编语言，拓展名<code>.ll</code>，<code>$ clang -S -emit-llvm main.m</code></p>\n</li>\n<li><p>memory：内存格式</p>\n</li>\n<li><p>bitcode：二进制格式，拓展名<code>.bc</code>，<code>$ clang -c -emit-llvm main.m</code></p>\n</li>\n</ul>\n<p>IR基本语法</p>\n<ul>\n<li>注释以分号开头</li>\n<li>全局标识以@开头，局部标识符以%开头</li>\n<li>alloca, 在当前函数栈帧中分配内存</li>\n<li>i32，32bit，4个字节的意思</li>\n<li>align，内存对齐</li>\n<li>store，写入数据</li>\n<li>load，读取数据</li>\n</ul>\n<p>官方语法参考</p>\n<p><a href=\"https://llvm.org/docs/LangRef.html\">https://llvm.org/docs/LangRef.html</a></p>\n<h2 id=\"Clang插件开发\"><a href=\"#Clang插件开发\" class=\"headerlink\" title=\"Clang插件开发\"></a>Clang插件开发</h2><p>我们可以通过开发Clang插件来对我们的代码进行静态分析，大概步骤是我们先把LLVM源码和clang源码下载到本地，然后进行编译，编译完之后我们就可以得到我们自己的编译器，然后把我们的clang插件放入指定目录，然后在Xcode里面把Xcode原来的编译器配置为我们自己的编译器，然后就可以使用我们的Clang插件了。</p>\n<p>举个例子，通过Clang我们可以对类名命名进行一些约束，比如NSString不用copy修饰的时候就警告一下。</p>\n<p><a href=\"https://imgtu.com/i/48lKER\"><img src=\"https://z3.ax1x.com/2021/09/19/48lKER.png\" alt=\"48lKER.png\"></a></p>\n<p>接下来我们讲解一下配置和开发步骤</p>\n<h3 id=\"下载LLVM源码\"><a href=\"#下载LLVM源码\" class=\"headerlink\" title=\"下载LLVM源码\"></a>下载LLVM源码</h3><p>可以直接在github上面下载到源码，目前最新版本号为12.0.1，直接点击页面的<code>Source Code</code>下载，<a href=\"https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.1\">github地址</a></p>\n<h3 id=\"下载Clang源码\"><a href=\"#下载Clang源码\" class=\"headerlink\" title=\"下载Clang源码\"></a>下载Clang源码</h3><p>同样也是<a href=\"https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.1\">这个地址</a>，目前的最新版本是12.0.1，点击<code>clang-12.0.1.src.tar.xz</code>下载</p>\n<p>下载后解压，文件夹命名为clang，把文件夹置入LLVM源码目录<code>llvm</code>文件夹的<code>tools</code>文件夹中</p>\n<h3 id=\"安装cmake和ninja（先安装brew，https-brew-sh）\"><a href=\"#安装cmake和ninja（先安装brew，https-brew-sh）\" class=\"headerlink\" title=\"安装cmake和ninja（先安装brew，https://brew.sh）\"></a>安装cmake和ninja（先安装brew，<a href=\"https://brew.sh)/\">https://brew.sh）</a></h3><p>使用cmake和ninja工具是为了让编译速度更快</p>\n<p><code>$ brew install cmake</code><br><code>$ brew install ninja</code></p>\n<p>ninja如果安装失败，可以直接从<a href=\"https://github.com/ninja-build/ninja/releases\">github</a>获取release版（ninja-mac.zip）放入<code>/usr/local/bin</code>中</p>\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><h4 id=\"使用ninja模板进行编译\"><a href=\"#使用ninja模板进行编译\" class=\"headerlink\" title=\"使用ninja模板进行编译\"></a>使用ninja模板进行编译</h4><p>在llvm源码目录内新建一个文件夹命名为<code>llvm_build</code>目录备用，用来放置ninja模板，然后在新建一个<code>llvm_release</code>文件夹，用来放置编译后的成品</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">cd</span> llvm_build</span><br><span class=\"line\">$ cmake -G Ninja <span class=\"string\">../llvm</span> -DCMAKE_INSTALL_PREFIX=<span class=\"string\">../llvm_release</span></span><br></pre></td></tr></table></figure>\n\n<p>命令执行完成后就<code>cd llvm_build</code>进入模板文件夹，然后依次执行以下命令</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>ninja</span><br><span class=\"line\"><span class=\"variable\">$ </span>ninja release</span><br></pre></td></tr></table></figure>\n\n<p>之后就可以在<code>llvm_release</code>内看到编译成品了</p>\n<h4 id=\"使用Xcode进行编译\"><a href=\"#使用Xcode进行编译\" class=\"headerlink\" title=\"使用Xcode进行编译\"></a>使用Xcode进行编译</h4><p>也可以生成Xcode项目再进行编译，但是速度很慢（可能需要1个多小时）</p>\n<p>在llvm源码目录内新建一个文件夹命名为<code>llvm_xcode</code>目录备用</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$</span> <span class=\"built_in\">cd</span> llvm_xcode</span><br><span class=\"line\"><span class=\"variable\">$</span> cmake <span class=\"literal\">-G</span> Xcode ../llvm</span><br></pre></td></tr></table></figure>\n\n<p>生成完之后打开<code>llvm_xcode</code>内的<code>LLVM.xcodeproj</code></p>\n<p>选择自动生成Scheme</p>\n<p><a href=\"https://imgtu.com/i/430RxA\"><img src=\"https://z3.ax1x.com/2021/09/19/430RxA.png\" alt=\"430RxA.png\"></a></p>\n<p>选择<code>ALL_BUILD</code> Scheme 然后就可以Cmd+R开始编译了</p>\n<p><a href=\"https://imgtu.com/i/43022d\"><img src=\"https://z3.ax1x.com/2021/09/19/43022d.png\" alt=\"43022d.png\"></a></p>\n<p>编译后的成品在<code>llvm_xcode/Debug/bin</code>中</p>\n<h3 id=\"创建Clang插件\"><a href=\"#创建Clang插件\" class=\"headerlink\" title=\"创建Clang插件\"></a>创建Clang插件</h3><p>在llvm源码的<code>/llvm/tools/clang/tools</code>文件夹内，新建一个文件夹，命名为<code>my-plugin</code>(举例名字)</p>\n<p>在同目录下打开文件<code>CMakeLists.txt</code>，在最后一行写入<code>add_clang_subdirectory(my-plugin)</code>后保存</p>\n<p>在<code>my-plugin</code>文件夹内新建一个文件命名为<code>MyPlugin.cpp</code>，再新建一个<code>CMakeLists.txt</code>文件到该文件夹内</p>\n<p>编辑<code>CMakeLists.txt</code>文件，写入</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">add_llvm_library</span><span class=\"params\">(MyPlugin MODULE BUILDTREE_ONLY MyPlugin.cpp)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>表示可加载模块</p>\n<p>如果有很多cpp文件的话，那么也可以这么写</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add_llvm_library( MyPlugin MODULE BUILDTREE_ONLY </span><br><span class=\"line\">MyPlugin.cpp</span><br><span class=\"line\">MyPlugin2.cpp</span><br><span class=\"line\">MyPlugin3.cpp</span><br><span class=\"line\">MyPlugin4.cpp</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"编写Clang插件\"><a href=\"#编写Clang插件\" class=\"headerlink\" title=\"编写Clang插件\"></a>编写Clang插件</h3><p>因为在文本编辑器中编辑c++代码很麻烦，所以我们一般会生成一个Xcode模板（也就是上面提到那个<code>使用Xcode进行编译</code>的Xcode模板）帮我们辅助编写C++代码</p>\n<p>所以我们在llvm源码目录的<code>llvm_xcode</code>文件夹内执行一下<code>cmake -G Xcode ../llvm</code>命令，就可以得到一个Xcode模板，打开工程之后，就可以看到我们的插件目录</p>\n<p><a href=\"https://imgtu.com/i/4369gg\"><img src=\"https://z3.ax1x.com/2021/09/19/4369gg.png\" alt=\"4369gg.png\"></a></p>\n<h4 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 必要的头文件，主要用来解析语法树</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/AST/AST.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/AST/ASTConsumer.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/Frontend/FrontendPluginRegistry.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> clang;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> llvm;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> clang::ast_matchers;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> MyPlugin &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyASTConsumer</span> :</span> <span class=\"keyword\">public</span> ASTConsumer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"comment\">/// 每当生成一棵语法树就会调用这个方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HandleTranslationUnit</span><span class=\"params\">(ASTContext &amp;Ctx)</span> </span>&#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;MyPlugin-HandleTranslationUnit&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAction</span> :</span> <span class=\"keyword\">public</span> PluginASTAction &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"comment\">/// 一定要重写的两个父类方法，指定Consumer</span></span><br><span class=\"line\">        <span class=\"function\">unique_ptr&lt;ASTConsumer&gt; <span class=\"title\">CreateASTConsumer</span><span class=\"params\">(CompilerInstance &amp;ci, StringRef InFile)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> unique_ptr&lt;MyASTConsumer&gt; (<span class=\"keyword\">new</span> MyASTConsumer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ParseArgs</span><span class=\"params\">(<span class=\"keyword\">const</span> CompilerInstance &amp;CI, <span class=\"keyword\">const</span> std::vector&lt;std::string&gt; &amp;arg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 注册插件</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> FrontendPluginRegistry::Add&lt;MyPlugin::MyAction&gt;</span><br><span class=\"line\"><span class=\"built_in\">X</span>(<span class=\"string\">&quot;MyPlugin&quot;</span>, <span class=\"string\">&quot;The MyPlugin is my first clang-plugin.&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>编译<code>MyPlugin</code> Scheme</p>\n<p><a href=\"https://imgtu.com/i/481kdA\"><img src=\"https://z3.ax1x.com/2021/09/19/481kdA.png\" alt=\"481kdA.png\"></a></p>\n<p>最后得到成品<code>MyPlugin.dylib</code></p>\n<p><a href=\"https://imgtu.com/i/481eRf\"><img src=\"https://z3.ax1x.com/2021/09/19/481eRf.png\" alt=\"481eRf.png\"></a></p>\n<h3 id=\"使用Clang插件\"><a href=\"#使用Clang插件\" class=\"headerlink\" title=\"使用Clang插件\"></a>使用Clang插件</h3><p><code>Show in finder</code>取出<code>MyPlugin.dylib</code>之后，我们新建一个测试工程</p>\n<p>在新建的Xcode项目中指定加载插件：<code>Build Settings &gt; OTHER_CFLAGS</code>，双击输入框后输入</p>\n<p><code>-Xclang -load -Xclang 动态库路径 -Xclang -add-plugin -Xclang 插件名称</code>，回车</p>\n<p><a href=\"https://imgtu.com/i/43XojJ\"><img src=\"https://z3.ax1x.com/2021/09/19/43XojJ.png\" alt=\"43XojJ.png\"></a></p>\n<p>因为Xcode自带的编译器不允许加载插件，所以我们使用刚才自己编译好的编译器</p>\n<p>首先下载<a href=\"https://github.com/weizhangCoder/XcodeHacking\">Xcode破解插件</a></p>\n<p>进入目录<code>XcodeHacking/HackedClang.xcplugin/Contents/Resources</code></p>\n<p>修改<code>HackedClang.xcspec</code></p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">ExecPath</span> = <span class=\"string\">&quot;/opt/llvm/llvm_build/bin/clang&quot;</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>改为我们刚才编译好的clang的全路径</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">ExecPath</span> = <span class=\"string\">&quot;/Users/arclin/Downloads/llvm-project-llvmorg-12.0.1/llvm-release/bin/clang&quot;</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后在XcodeHacking目录下进行命令行，</p>\n<p>将XcodeHacking的内容剪切到Xcode内部</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo mv HackedClang.xcplugin `xcode-select -p`<span class=\"regexp\">/../</span>PlugIns<span class=\"regexp\">/Xcode3Core.ideplugin/</span>Contents<span class=\"regexp\">/SharedSupport/</span>Developer<span class=\"regexp\">/Library/</span>Xcode/Plug-ins</span><br><span class=\"line\">$ sudo mv HackedBuildSystem.xcspec `xcode-select -p`<span class=\"regexp\">/Platforms/i</span>PhoneSimulator.platform<span class=\"regexp\">/Developer/</span>Library<span class=\"regexp\">/Xcode/</span>Specifications</span><br></pre></td></tr></table></figure>\n\n<p>这时候Xcode就应该有多一个编译器可选项，我们选择<code>Clang LLVM Trunk</code></p>\n<p><a href=\"https://imgtu.com/i/48lXI1\"><img src=\"https://z3.ax1x.com/2021/09/19/48lXI1.png\" alt=\"48lXI1.png\"></a></p>\n<p>然后就可以Clean一下后编译进行测试。</p>\n<p>自己在测试的时候发生了一些报错的问题（可能我是用的M1笔记本的原因），可以修改<code>Build System</code>的值为<code>Legacy Build System</code>解决</p>\n<p><a href=\"https://imgtu.com/i/48lsxS\"><img src=\"https://z3.ax1x.com/2021/09/19/48lsxS.png\" alt=\"48lsxS.png\"></a></p>\n<p>如果发生了<code>CADisplayLink&#39; is unavailable: not available on macOS</code>的问题，那尝试新建一个Mac项目</p>\n<p>最后贴出完整的插件代码仅供参考</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/AST/AST.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/AST/DeclObjC.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/AST/ASTConsumer.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/Frontend/FrontendPluginRegistry.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明使用命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> clang;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> llvm;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> clang::ast_matchers;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插件命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> MyPlugin &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 第三步：扫描完毕回调</span></span><br><span class=\"line\">    <span class=\"comment\">// 4、自定义回调类，继承自MatchCallback</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyMatchCallback</span> :</span> <span class=\"keyword\">public</span> MatchFinder::MatchCallback &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"comment\">// CI传递路径：MyASTAction类中的CreateASTConsumer方法参数 -&gt; MyASTConsumer的构造函数 -&gt; MyMatchCallback的私有属性，通过构造函数从MyASTConsumer构造函数中获取</span></span><br><span class=\"line\">        CompilerInstance &amp;CI;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否是自己的文件</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isUserSourceCode</span><span class=\"params\">(<span class=\"keyword\">const</span> string fileName)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 文件名不为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fileName.<span class=\"built_in\">empty</span>()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 非Xcode中的代码都认为是用户的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == fileName.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;/Applications/Xcode.app/&quot;</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否应该用copy修饰</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isShouldUseCopy</span><span class=\"params\">(<span class=\"keyword\">const</span> string typeStr)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断类型是否是 NSString / NSArray / NSDictionary</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (typeStr.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;NSString&quot;</span>) != string::npos ||</span><br><span class=\"line\">                typeStr.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;NSArray&quot;</span>) != string::npos ||</span><br><span class=\"line\">                typeStr.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;NSDictionary&quot;</span>) != string::npos) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"comment\">// 构造方法</span></span><br><span class=\"line\">        <span class=\"built_in\">MyMatchCallback</span>(CompilerInstance &amp;CI):<span class=\"built_in\">CI</span>(CI) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 重载run方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(<span class=\"keyword\">const</span> MatchFinder::MatchResult &amp;Result)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通过Result获取节点对象，根据节点id(&quot;objcPropertyDecl&quot;)获取(此id需要与MyASTConsumer构造方法中bind的id一致)</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> ObjCPropertyDecl *propertyDecl = Result.Nodes.getNodeAs&lt;ObjCPropertyDecl&gt;(<span class=\"string\">&quot;objcPropertyDecl&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 获取文件名称（包含路径）</span></span><br><span class=\"line\">            string fileName = CI.<span class=\"built_in\">getSourceManager</span>().<span class=\"built_in\">getFilename</span>(propertyDecl-&gt;<span class=\"built_in\">getSourceRange</span>().<span class=\"built_in\">getBegin</span>()).<span class=\"built_in\">str</span>();</span><br><span class=\"line\">            <span class=\"comment\">// 如果节点有值 &amp;&amp; 是用户文件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (propertyDecl &amp;&amp; <span class=\"built_in\">isUserSourceCode</span>(fileName)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取节点的类型，并转成字符串</span></span><br><span class=\"line\">                string typeStr = propertyDecl-&gt;<span class=\"built_in\">getType</span>().<span class=\"built_in\">getAsString</span>();</span><br><span class=\"line\">                <span class=\"comment\">// 节点的描述信息</span></span><br><span class=\"line\">                ObjCPropertyAttribute::Kind attrKind = propertyDecl-&gt;<span class=\"built_in\">getPropertyAttributes</span>();</span><br><span class=\"line\">                <span class=\"comment\">// 应该使用copy，但是没有使用copy</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">isShouldUseCopy</span>(typeStr) &amp;&amp; !(attrKind &amp; ObjCPropertyAttribute::kind_copy)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 通过CI获取诊断引擎</span></span><br><span class=\"line\">                    DiagnosticsEngine &amp;diag = CI.<span class=\"built_in\">getDiagnostics</span>();</span><br><span class=\"line\">                    <span class=\"comment\">// Report 报告</span></span><br><span class=\"line\">                    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                     错误位置：getLocation 节点位置</span></span><br><span class=\"line\"><span class=\"comment\">                     错误：getCustomDiagID（等级，提示）</span></span><br><span class=\"line\"><span class=\"comment\">                     DiagnosticsEngine::Warning 警告</span></span><br><span class=\"line\"><span class=\"comment\">                     DiagnosticsEngine::Error 错误</span></span><br><span class=\"line\"><span class=\"comment\">                     */</span></span><br><span class=\"line\">                    diag.<span class=\"built_in\">Report</span>(propertyDecl-&gt;<span class=\"built_in\">getLocation</span>(), diag.<span class=\"built_in\">getCustomDiagID</span>(DiagnosticsEngine::Warning, <span class=\"string\">&quot;%0 - 推荐使用copy修饰该属性&quot;</span>))&lt;&lt; typeStr;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 第二步：扫描配置完毕</span></span><br><span class=\"line\">    <span class=\"comment\">// 3、自定义MyASTConsumer，继承自抽象类 ASTConsumer，用于监听AST节点的信息 -- 过滤器</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyASTConsumer</span> :</span> <span class=\"keyword\">public</span> ASTConsumer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"comment\">// AST 节点查找器（过滤器）</span></span><br><span class=\"line\">        MatchFinder matcher;</span><br><span class=\"line\">        <span class=\"comment\">// 回调对象</span></span><br><span class=\"line\">        MyMatchCallback callback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"comment\">// 构造方法中创建MatchFinder对象</span></span><br><span class=\"line\">        <span class=\"built_in\">MyASTConsumer</span>(CompilerInstance &amp;CI):<span class=\"built_in\">callback</span>(CI) &#123; <span class=\"comment\">// 构造即将CI传递给callback</span></span><br><span class=\"line\">            <span class=\"comment\">// 添加一个MatchFinder，每个objcPropertyDecl节点绑定一个objcPropertyDecl标识（去匹配objcPropertyDecl节点）</span></span><br><span class=\"line\">            <span class=\"comment\">// 回调callback，其实是在CJLMatchCallback里面重写run方法（真正回调的是回调run方法）</span></span><br><span class=\"line\">matcher.<span class=\"built_in\">addMatcher</span>(<span class=\"built_in\">objcPropertyDecl</span>().<span class=\"built_in\">bind</span>(<span class=\"string\">&quot;objcPropertyDecl&quot;</span>), &amp;callback);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 重载两个方法 HandleTopLevelDecl 和 HandleTranslationUnit</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 解析完毕一个顶级的声明就回调一次（顶级节点，即全局变量，属性，函数等）</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">HandleTopLevelDecl</span><span class=\"params\">(DeclGroupRef D)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//            cout&lt;&lt;&quot;正在解析...&quot;&lt;&lt;endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 当整个文件都解析完毕后回调</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HandleTranslationUnit</span><span class=\"params\">(ASTContext &amp;Ctx)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//            cout&lt;&lt;&quot;文件解析完毕！！！&quot;&lt;&lt;endl;</span></span><br><span class=\"line\">            <span class=\"comment\">// 将文件解析完毕后的上下文context（即AST语法树） 给 matcher</span></span><br><span class=\"line\">            matcher.<span class=\"built_in\">matchAST</span>(Ctx);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2、继承PluginASTAction，实现我们自定义的MyASTAction，即自定义AST语法树行为</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyASTAction</span> :</span> <span class=\"keyword\">public</span> PluginASTAction &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 重载ParseArgs 和 CreateASTConsumer方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         解析给定的插件命令行参数</span></span><br><span class=\"line\"><span class=\"comment\">         - param CI 编译器实例，用于报告诊断。</span></span><br><span class=\"line\"><span class=\"comment\">         - return 如果解析成功，则为true；否则，插件将被销毁，并且不执行任何操作。该插件负责使用CompilerInstance的Diagnostic对象报告错误。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ParseArgs</span><span class=\"params\">(<span class=\"keyword\">const</span> CompilerInstance &amp;CI, <span class=\"keyword\">const</span> std::vector&lt;std::string&gt; &amp;arg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 返回自定义的MyASTConsumer对象，抽象类ASTConsumer的子类</span></span><br><span class=\"line\">        <span class=\"function\">unique_ptr&lt;ASTConsumer&gt; <span class=\"title\">CreateASTConsumer</span><span class=\"params\">(CompilerInstance &amp;CI, StringRef InFile)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             传递CI</span></span><br><span class=\"line\"><span class=\"comment\">             CI用于：</span></span><br><span class=\"line\"><span class=\"comment\">             - 判断文件是否是用户的</span></span><br><span class=\"line\"><span class=\"comment\">             - 抛出警告</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> unique_ptr&lt;MyASTConsumer&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">MyASTConsumer</span>(CI));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一步：注册插件，并自定义MyASTAction类</span></span><br><span class=\"line\"><span class=\"comment\">// 1、注册插件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> FrontendPluginRegistry::Add&lt;MyPlugin::MyASTAction&gt; <span class=\"title\">X</span><span class=\"params\">(<span class=\"string\">&quot;MyPlugin&quot;</span>, <span class=\"string\">&quot;this is MyPlugin&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>参考：<a href=\"https://juejin.cn/post/7004633055012864031\">https://juejin.cn/post/7004633055012864031</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>本文主要简述LLVM的概念与Clang插件开发</p>","more":"<h2 id=\"LLVM\"><a href=\"#LLVM\" class=\"headerlink\" title=\"LLVM\"></a>LLVM</h2><ul>\n<li>官网：<a href=\"https://llvm.org/\">https://llvm.org</a></li>\n<li>LLVM项目是模块化、可重用的<code>编译器</code>以及<code>工具链</code>技术的集合</li>\n<li>”LLVM“这个名称不是缩写，是项目全称</li>\n</ul>\n<h2 id=\"传统的编译器架构\"><a href=\"#传统的编译器架构\" class=\"headerlink\" title=\"传统的编译器架构\"></a>传统的编译器架构</h2><p><img src=\"https://z3.ax1x.com/2021/09/12/4ppCOx.png\" alt=\"4ppCOx.png\"></p>\n<ul>\n<li>Frontend：前端<ul>\n<li>词法分析、语法分析、语义分析、生成中间代码</li>\n</ul>\n</li>\n<li>Optimizer：优化器<ul>\n<li>中间代码优化</li>\n</ul>\n</li>\n<li>Backend：后端<ul>\n<li>生成机器码</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"LLVM架构\"><a href=\"#LLVM架构\" class=\"headerlink\" title=\"LLVM架构\"></a>LLVM架构</h2><p><img src=\"https://z3.ax1x.com/2021/09/12/4pEhkt.png\" alt=\"4pEhkt.png\"></p>\n<ul>\n<li>不同的前端后端使用统一的中间代码<code>LLVM Intermediate Representation(LLVM IR)</code></li>\n<li>如果需要支持一种新的编程语言，那么只需要实现一个新的前端</li>\n<li>如果需要支持一种新的硬件设备，那么只需要实现一个新的后端</li>\n<li>优化阶段是一个通用的阶段，他针对的是统一的<code>LLVM IR</code>，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做需修改</li>\n<li>相比之下，GCC的前端和后端没分得太开，前端后端耦合在了一起。所以GCC为了支持一门新的语言，或者为了支持一个新的目标平台，就变得相当困难</li>\n<li>LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构（GCC家族，Java,.Net,Python,Ruby,Scheme,Haskell,D等）</li>\n</ul>\n<h3 id=\"Clang\"><a href=\"#Clang\" class=\"headerlink\" title=\"Clang\"></a>Clang</h3><ul>\n<li><p>Clang是LLVM的一个子项目</p>\n</li>\n<li><p>基于LLVM架构的C/C++/Objective-C编译器前端</p>\n</li>\n<li><p>官网：<a href=\"http://clang.llvm.org/\">http://clang.llvm.org/</a></p>\n</li>\n<li><p>相比于GCC，Clang具有如下优点</p>\n<ul>\n<li>编译速度快：在某些平台上，Clang的编译速度显著地快过GCC(Debug模式下编译OC速度比GCC快3倍)</li>\n<li>占用内存小：Clang生成的AST所占用的内存是GCC的五分之一左右</li>\n<li>模块化设计：Clang采用基于库的模块化设计，易于IDE集成及其他用途的重用</li>\n<li>诊断信息可读性强：在编译过程中，Clang创建并保留了大量详细的元数据（metadata），有利于调试和错误报告</li>\n<li>设计清晰简单，容易理解，易于扩展增强 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Clang与LLVM\"><a href=\"#Clang与LLVM\" class=\"headerlink\" title=\"Clang与LLVM\"></a>Clang与LLVM</h3><p> <img src=\"https://i.loli.net/2021/09/12/P7Z2sTB6ifOt4XM.png\" alt=\"WX20210912-142017.png\"></p>\n<p> <img src=\"https://i.loli.net/2021/09/12/EZ9hnywmdQAX3LK.png\" alt=\"WX20210912-142026.png\"></p>\n<p> IR：中间代码</p>\n<h2 id=\"OC源文件的编译过程\"><a href=\"#OC源文件的编译过程\" class=\"headerlink\" title=\"OC源文件的编译过程\"></a>OC源文件的编译过程</h2><ul>\n<li>命令行查看编译的过程：<code>$ clang -ccc-print-phases main.m</code></li>\n</ul>\n <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arclin<span class=\"keyword\">@ArcdeMacBook-Pro</span> TestObjC % clang -ccc-print-phases main.m </span><br><span class=\"line\">               +- <span class=\"number\">0</span>: input, <span class=\"string\">&quot;main.m&quot;</span>, objective-c</span><br><span class=\"line\">            +- <span class=\"number\">1</span>: preprocessor, &#123;<span class=\"number\">0</span>&#125;, objective-c-cpp-output</span><br><span class=\"line\">         +- <span class=\"number\">2</span>: compiler, &#123;<span class=\"number\">1</span>&#125;, ir</span><br><span class=\"line\">      +- <span class=\"number\">3</span>: backend, &#123;<span class=\"number\">2</span>&#125;, assembler</span><br><span class=\"line\">   +- <span class=\"number\">4</span>: assembler, &#123;<span class=\"number\">3</span>&#125;, <span class=\"selector-tag\">object</span></span><br><span class=\"line\">+- <span class=\"number\">5</span>: linker, &#123;<span class=\"number\">4</span>&#125;, image</span><br><span class=\"line\"><span class=\"number\">6</span>: bind-arch, <span class=\"string\">&quot;x86_64&quot;</span>, &#123;<span class=\"number\">5</span>&#125;, image</span><br></pre></td></tr></table></figure>\n<p>  preprocessor: 预处理器，处理宏定义，展开引入的头文件内容等</p>\n<p>  complier: 编译，编译成ir中间代码</p>\n<p>  backend: 后端，转成汇编代码</p>\n<p>  assemler: 汇编，转成目标代码</p>\n<p>  linker: 链接，链接动态库、静态库等</p>\n<p>  bind-arch: 绑定当前处理器架构</p>\n<ul>\n<li><p>查看preprocesser(预处理)的结果：<code>$ clang -E main.m</code></p>\n</li>\n<li><p>词法分析，生成Token：<code>$ clang -fmodules -E -Xlang -dump-tokens main.m</code></p>\n</li>\n<li><p>语法分析，生成语法树（AST，Abstract Syntax Tree）：<code>$ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</code></p>\n</li>\n</ul>\n<h2 id=\"词法分析、语法树\"><a href=\"#词法分析、语法树\" class=\"headerlink\" title=\"词法分析、语法树\"></a>词法分析、语法树</h2><p>词法分析，生成Token： <code>$ clang -fmodules -E -Xclang -dump-tokens main.m</code></p>\n<p><a href=\"https://imgtu.com/i/483bNR\"><img src=\"https://z3.ax1x.com/2021/09/19/483bNR.png\" alt=\"483bNR.png\"></a></p>\n<p>语法分析，生成语法树（AST，Abstract Syntax Tree）： <code>$ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</code></p>\n<p><a href=\"https://imgtu.com/i/483d9P\"><img src=\"https://z3.ax1x.com/2021/09/19/483d9P.png\" alt=\"483d9P.png\"></a></p>\n<h2 id=\"LLVM-IR\"><a href=\"#LLVM-IR\" class=\"headerlink\" title=\"LLVM IR\"></a>LLVM IR</h2><p>LLVM IR 有三种表现形式</p>\n<ul>\n<li><p>text：便于阅读的文本格式，类似于汇编语言，拓展名<code>.ll</code>，<code>$ clang -S -emit-llvm main.m</code></p>\n</li>\n<li><p>memory：内存格式</p>\n</li>\n<li><p>bitcode：二进制格式，拓展名<code>.bc</code>，<code>$ clang -c -emit-llvm main.m</code></p>\n</li>\n</ul>\n<p>IR基本语法</p>\n<ul>\n<li>注释以分号开头</li>\n<li>全局标识以@开头，局部标识符以%开头</li>\n<li>alloca, 在当前函数栈帧中分配内存</li>\n<li>i32，32bit，4个字节的意思</li>\n<li>align，内存对齐</li>\n<li>store，写入数据</li>\n<li>load，读取数据</li>\n</ul>\n<p>官方语法参考</p>\n<p><a href=\"https://llvm.org/docs/LangRef.html\">https://llvm.org/docs/LangRef.html</a></p>\n<h2 id=\"Clang插件开发\"><a href=\"#Clang插件开发\" class=\"headerlink\" title=\"Clang插件开发\"></a>Clang插件开发</h2><p>我们可以通过开发Clang插件来对我们的代码进行静态分析，大概步骤是我们先把LLVM源码和clang源码下载到本地，然后进行编译，编译完之后我们就可以得到我们自己的编译器，然后把我们的clang插件放入指定目录，然后在Xcode里面把Xcode原来的编译器配置为我们自己的编译器，然后就可以使用我们的Clang插件了。</p>\n<p>举个例子，通过Clang我们可以对类名命名进行一些约束，比如NSString不用copy修饰的时候就警告一下。</p>\n<p><a href=\"https://imgtu.com/i/48lKER\"><img src=\"https://z3.ax1x.com/2021/09/19/48lKER.png\" alt=\"48lKER.png\"></a></p>\n<p>接下来我们讲解一下配置和开发步骤</p>\n<h3 id=\"下载LLVM源码\"><a href=\"#下载LLVM源码\" class=\"headerlink\" title=\"下载LLVM源码\"></a>下载LLVM源码</h3><p>可以直接在github上面下载到源码，目前最新版本号为12.0.1，直接点击页面的<code>Source Code</code>下载，<a href=\"https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.1\">github地址</a></p>\n<h3 id=\"下载Clang源码\"><a href=\"#下载Clang源码\" class=\"headerlink\" title=\"下载Clang源码\"></a>下载Clang源码</h3><p>同样也是<a href=\"https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.1\">这个地址</a>，目前的最新版本是12.0.1，点击<code>clang-12.0.1.src.tar.xz</code>下载</p>\n<p>下载后解压，文件夹命名为clang，把文件夹置入LLVM源码目录<code>llvm</code>文件夹的<code>tools</code>文件夹中</p>\n<h3 id=\"安装cmake和ninja（先安装brew，https-brew-sh）\"><a href=\"#安装cmake和ninja（先安装brew，https-brew-sh）\" class=\"headerlink\" title=\"安装cmake和ninja（先安装brew，https://brew.sh）\"></a>安装cmake和ninja（先安装brew，<a href=\"https://brew.sh)/\">https://brew.sh）</a></h3><p>使用cmake和ninja工具是为了让编译速度更快</p>\n<p><code>$ brew install cmake</code><br><code>$ brew install ninja</code></p>\n<p>ninja如果安装失败，可以直接从<a href=\"https://github.com/ninja-build/ninja/releases\">github</a>获取release版（ninja-mac.zip）放入<code>/usr/local/bin</code>中</p>\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><h4 id=\"使用ninja模板进行编译\"><a href=\"#使用ninja模板进行编译\" class=\"headerlink\" title=\"使用ninja模板进行编译\"></a>使用ninja模板进行编译</h4><p>在llvm源码目录内新建一个文件夹命名为<code>llvm_build</code>目录备用，用来放置ninja模板，然后在新建一个<code>llvm_release</code>文件夹，用来放置编译后的成品</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">cd</span> llvm_build</span><br><span class=\"line\">$ cmake -G Ninja <span class=\"string\">../llvm</span> -DCMAKE_INSTALL_PREFIX=<span class=\"string\">../llvm_release</span></span><br></pre></td></tr></table></figure>\n\n<p>命令执行完成后就<code>cd llvm_build</code>进入模板文件夹，然后依次执行以下命令</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ </span>ninja</span><br><span class=\"line\"><span class=\"variable\">$ </span>ninja release</span><br></pre></td></tr></table></figure>\n\n<p>之后就可以在<code>llvm_release</code>内看到编译成品了</p>\n<h4 id=\"使用Xcode进行编译\"><a href=\"#使用Xcode进行编译\" class=\"headerlink\" title=\"使用Xcode进行编译\"></a>使用Xcode进行编译</h4><p>也可以生成Xcode项目再进行编译，但是速度很慢（可能需要1个多小时）</p>\n<p>在llvm源码目录内新建一个文件夹命名为<code>llvm_xcode</code>目录备用</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$</span> <span class=\"built_in\">cd</span> llvm_xcode</span><br><span class=\"line\"><span class=\"variable\">$</span> cmake <span class=\"literal\">-G</span> Xcode ../llvm</span><br></pre></td></tr></table></figure>\n\n<p>生成完之后打开<code>llvm_xcode</code>内的<code>LLVM.xcodeproj</code></p>\n<p>选择自动生成Scheme</p>\n<p><a href=\"https://imgtu.com/i/430RxA\"><img src=\"https://z3.ax1x.com/2021/09/19/430RxA.png\" alt=\"430RxA.png\"></a></p>\n<p>选择<code>ALL_BUILD</code> Scheme 然后就可以Cmd+R开始编译了</p>\n<p><a href=\"https://imgtu.com/i/43022d\"><img src=\"https://z3.ax1x.com/2021/09/19/43022d.png\" alt=\"43022d.png\"></a></p>\n<p>编译后的成品在<code>llvm_xcode/Debug/bin</code>中</p>\n<h3 id=\"创建Clang插件\"><a href=\"#创建Clang插件\" class=\"headerlink\" title=\"创建Clang插件\"></a>创建Clang插件</h3><p>在llvm源码的<code>/llvm/tools/clang/tools</code>文件夹内，新建一个文件夹，命名为<code>my-plugin</code>(举例名字)</p>\n<p>在同目录下打开文件<code>CMakeLists.txt</code>，在最后一行写入<code>add_clang_subdirectory(my-plugin)</code>后保存</p>\n<p>在<code>my-plugin</code>文件夹内新建一个文件命名为<code>MyPlugin.cpp</code>，再新建一个<code>CMakeLists.txt</code>文件到该文件夹内</p>\n<p>编辑<code>CMakeLists.txt</code>文件，写入</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">add_llvm_library</span><span class=\"params\">(MyPlugin MODULE BUILDTREE_ONLY MyPlugin.cpp)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>表示可加载模块</p>\n<p>如果有很多cpp文件的话，那么也可以这么写</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add_llvm_library( MyPlugin MODULE BUILDTREE_ONLY </span><br><span class=\"line\">MyPlugin.cpp</span><br><span class=\"line\">MyPlugin2.cpp</span><br><span class=\"line\">MyPlugin3.cpp</span><br><span class=\"line\">MyPlugin4.cpp</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"编写Clang插件\"><a href=\"#编写Clang插件\" class=\"headerlink\" title=\"编写Clang插件\"></a>编写Clang插件</h3><p>因为在文本编辑器中编辑c++代码很麻烦，所以我们一般会生成一个Xcode模板（也就是上面提到那个<code>使用Xcode进行编译</code>的Xcode模板）帮我们辅助编写C++代码</p>\n<p>所以我们在llvm源码目录的<code>llvm_xcode</code>文件夹内执行一下<code>cmake -G Xcode ../llvm</code>命令，就可以得到一个Xcode模板，打开工程之后，就可以看到我们的插件目录</p>\n<p><a href=\"https://imgtu.com/i/4369gg\"><img src=\"https://z3.ax1x.com/2021/09/19/4369gg.png\" alt=\"4369gg.png\"></a></p>\n<h4 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 必要的头文件，主要用来解析语法树</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/AST/AST.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/AST/ASTConsumer.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/Frontend/FrontendPluginRegistry.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> clang;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> llvm;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> clang::ast_matchers;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> MyPlugin &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyASTConsumer</span> :</span> <span class=\"keyword\">public</span> ASTConsumer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"comment\">/// 每当生成一棵语法树就会调用这个方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HandleTranslationUnit</span><span class=\"params\">(ASTContext &amp;Ctx)</span> </span>&#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;MyPlugin-HandleTranslationUnit&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAction</span> :</span> <span class=\"keyword\">public</span> PluginASTAction &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"comment\">/// 一定要重写的两个父类方法，指定Consumer</span></span><br><span class=\"line\">        <span class=\"function\">unique_ptr&lt;ASTConsumer&gt; <span class=\"title\">CreateASTConsumer</span><span class=\"params\">(CompilerInstance &amp;ci, StringRef InFile)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> unique_ptr&lt;MyASTConsumer&gt; (<span class=\"keyword\">new</span> MyASTConsumer);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ParseArgs</span><span class=\"params\">(<span class=\"keyword\">const</span> CompilerInstance &amp;CI, <span class=\"keyword\">const</span> std::vector&lt;std::string&gt; &amp;arg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 注册插件</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> FrontendPluginRegistry::Add&lt;MyPlugin::MyAction&gt;</span><br><span class=\"line\"><span class=\"built_in\">X</span>(<span class=\"string\">&quot;MyPlugin&quot;</span>, <span class=\"string\">&quot;The MyPlugin is my first clang-plugin.&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>编译<code>MyPlugin</code> Scheme</p>\n<p><a href=\"https://imgtu.com/i/481kdA\"><img src=\"https://z3.ax1x.com/2021/09/19/481kdA.png\" alt=\"481kdA.png\"></a></p>\n<p>最后得到成品<code>MyPlugin.dylib</code></p>\n<p><a href=\"https://imgtu.com/i/481eRf\"><img src=\"https://z3.ax1x.com/2021/09/19/481eRf.png\" alt=\"481eRf.png\"></a></p>\n<h3 id=\"使用Clang插件\"><a href=\"#使用Clang插件\" class=\"headerlink\" title=\"使用Clang插件\"></a>使用Clang插件</h3><p><code>Show in finder</code>取出<code>MyPlugin.dylib</code>之后，我们新建一个测试工程</p>\n<p>在新建的Xcode项目中指定加载插件：<code>Build Settings &gt; OTHER_CFLAGS</code>，双击输入框后输入</p>\n<p><code>-Xclang -load -Xclang 动态库路径 -Xclang -add-plugin -Xclang 插件名称</code>，回车</p>\n<p><a href=\"https://imgtu.com/i/43XojJ\"><img src=\"https://z3.ax1x.com/2021/09/19/43XojJ.png\" alt=\"43XojJ.png\"></a></p>\n<p>因为Xcode自带的编译器不允许加载插件，所以我们使用刚才自己编译好的编译器</p>\n<p>首先下载<a href=\"https://github.com/weizhangCoder/XcodeHacking\">Xcode破解插件</a></p>\n<p>进入目录<code>XcodeHacking/HackedClang.xcplugin/Contents/Resources</code></p>\n<p>修改<code>HackedClang.xcspec</code></p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">ExecPath</span> = <span class=\"string\">&quot;/opt/llvm/llvm_build/bin/clang&quot;</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>改为我们刚才编译好的clang的全路径</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">ExecPath</span> = <span class=\"string\">&quot;/Users/arclin/Downloads/llvm-project-llvmorg-12.0.1/llvm-release/bin/clang&quot;</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后在XcodeHacking目录下进行命令行，</p>\n<p>将XcodeHacking的内容剪切到Xcode内部</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo mv HackedClang.xcplugin `xcode-select -p`<span class=\"regexp\">/../</span>PlugIns<span class=\"regexp\">/Xcode3Core.ideplugin/</span>Contents<span class=\"regexp\">/SharedSupport/</span>Developer<span class=\"regexp\">/Library/</span>Xcode/Plug-ins</span><br><span class=\"line\">$ sudo mv HackedBuildSystem.xcspec `xcode-select -p`<span class=\"regexp\">/Platforms/i</span>PhoneSimulator.platform<span class=\"regexp\">/Developer/</span>Library<span class=\"regexp\">/Xcode/</span>Specifications</span><br></pre></td></tr></table></figure>\n\n<p>这时候Xcode就应该有多一个编译器可选项，我们选择<code>Clang LLVM Trunk</code></p>\n<p><a href=\"https://imgtu.com/i/48lXI1\"><img src=\"https://z3.ax1x.com/2021/09/19/48lXI1.png\" alt=\"48lXI1.png\"></a></p>\n<p>然后就可以Clean一下后编译进行测试。</p>\n<p>自己在测试的时候发生了一些报错的问题（可能我是用的M1笔记本的原因），可以修改<code>Build System</code>的值为<code>Legacy Build System</code>解决</p>\n<p><a href=\"https://imgtu.com/i/48lsxS\"><img src=\"https://z3.ax1x.com/2021/09/19/48lsxS.png\" alt=\"48lsxS.png\"></a></p>\n<p>如果发生了<code>CADisplayLink&#39; is unavailable: not available on macOS</code>的问题，那尝试新建一个Mac项目</p>\n<p>最后贴出完整的插件代码仅供参考</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/AST/AST.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/AST/DeclObjC.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/AST/ASTConsumer.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;clang/Frontend/FrontendPluginRegistry.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明使用命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> clang;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> llvm;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> clang::ast_matchers;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插件命名空间</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> MyPlugin &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 第三步：扫描完毕回调</span></span><br><span class=\"line\">    <span class=\"comment\">// 4、自定义回调类，继承自MatchCallback</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyMatchCallback</span> :</span> <span class=\"keyword\">public</span> MatchFinder::MatchCallback &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"comment\">// CI传递路径：MyASTAction类中的CreateASTConsumer方法参数 -&gt; MyASTConsumer的构造函数 -&gt; MyMatchCallback的私有属性，通过构造函数从MyASTConsumer构造函数中获取</span></span><br><span class=\"line\">        CompilerInstance &amp;CI;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否是自己的文件</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isUserSourceCode</span><span class=\"params\">(<span class=\"keyword\">const</span> string fileName)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 文件名不为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fileName.<span class=\"built_in\">empty</span>()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 非Xcode中的代码都认为是用户的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"number\">0</span> == fileName.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;/Applications/Xcode.app/&quot;</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否应该用copy修饰</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isShouldUseCopy</span><span class=\"params\">(<span class=\"keyword\">const</span> string typeStr)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断类型是否是 NSString / NSArray / NSDictionary</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (typeStr.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;NSString&quot;</span>) != string::npos ||</span><br><span class=\"line\">                typeStr.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;NSArray&quot;</span>) != string::npos ||</span><br><span class=\"line\">                typeStr.<span class=\"built_in\">find</span>(<span class=\"string\">&quot;NSDictionary&quot;</span>) != string::npos) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"comment\">// 构造方法</span></span><br><span class=\"line\">        <span class=\"built_in\">MyMatchCallback</span>(CompilerInstance &amp;CI):<span class=\"built_in\">CI</span>(CI) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 重载run方法</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(<span class=\"keyword\">const</span> MatchFinder::MatchResult &amp;Result)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 通过Result获取节点对象，根据节点id(&quot;objcPropertyDecl&quot;)获取(此id需要与MyASTConsumer构造方法中bind的id一致)</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> ObjCPropertyDecl *propertyDecl = Result.Nodes.getNodeAs&lt;ObjCPropertyDecl&gt;(<span class=\"string\">&quot;objcPropertyDecl&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 获取文件名称（包含路径）</span></span><br><span class=\"line\">            string fileName = CI.<span class=\"built_in\">getSourceManager</span>().<span class=\"built_in\">getFilename</span>(propertyDecl-&gt;<span class=\"built_in\">getSourceRange</span>().<span class=\"built_in\">getBegin</span>()).<span class=\"built_in\">str</span>();</span><br><span class=\"line\">            <span class=\"comment\">// 如果节点有值 &amp;&amp; 是用户文件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (propertyDecl &amp;&amp; <span class=\"built_in\">isUserSourceCode</span>(fileName)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获取节点的类型，并转成字符串</span></span><br><span class=\"line\">                string typeStr = propertyDecl-&gt;<span class=\"built_in\">getType</span>().<span class=\"built_in\">getAsString</span>();</span><br><span class=\"line\">                <span class=\"comment\">// 节点的描述信息</span></span><br><span class=\"line\">                ObjCPropertyAttribute::Kind attrKind = propertyDecl-&gt;<span class=\"built_in\">getPropertyAttributes</span>();</span><br><span class=\"line\">                <span class=\"comment\">// 应该使用copy，但是没有使用copy</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">isShouldUseCopy</span>(typeStr) &amp;&amp; !(attrKind &amp; ObjCPropertyAttribute::kind_copy)) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 通过CI获取诊断引擎</span></span><br><span class=\"line\">                    DiagnosticsEngine &amp;diag = CI.<span class=\"built_in\">getDiagnostics</span>();</span><br><span class=\"line\">                    <span class=\"comment\">// Report 报告</span></span><br><span class=\"line\">                    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">                     错误位置：getLocation 节点位置</span></span><br><span class=\"line\"><span class=\"comment\">                     错误：getCustomDiagID（等级，提示）</span></span><br><span class=\"line\"><span class=\"comment\">                     DiagnosticsEngine::Warning 警告</span></span><br><span class=\"line\"><span class=\"comment\">                     DiagnosticsEngine::Error 错误</span></span><br><span class=\"line\"><span class=\"comment\">                     */</span></span><br><span class=\"line\">                    diag.<span class=\"built_in\">Report</span>(propertyDecl-&gt;<span class=\"built_in\">getLocation</span>(), diag.<span class=\"built_in\">getCustomDiagID</span>(DiagnosticsEngine::Warning, <span class=\"string\">&quot;%0 - 推荐使用copy修饰该属性&quot;</span>))&lt;&lt; typeStr;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 第二步：扫描配置完毕</span></span><br><span class=\"line\">    <span class=\"comment\">// 3、自定义MyASTConsumer，继承自抽象类 ASTConsumer，用于监听AST节点的信息 -- 过滤器</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyASTConsumer</span> :</span> <span class=\"keyword\">public</span> ASTConsumer &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"comment\">// AST 节点查找器（过滤器）</span></span><br><span class=\"line\">        MatchFinder matcher;</span><br><span class=\"line\">        <span class=\"comment\">// 回调对象</span></span><br><span class=\"line\">        MyMatchCallback callback;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"comment\">// 构造方法中创建MatchFinder对象</span></span><br><span class=\"line\">        <span class=\"built_in\">MyASTConsumer</span>(CompilerInstance &amp;CI):<span class=\"built_in\">callback</span>(CI) &#123; <span class=\"comment\">// 构造即将CI传递给callback</span></span><br><span class=\"line\">            <span class=\"comment\">// 添加一个MatchFinder，每个objcPropertyDecl节点绑定一个objcPropertyDecl标识（去匹配objcPropertyDecl节点）</span></span><br><span class=\"line\">            <span class=\"comment\">// 回调callback，其实是在CJLMatchCallback里面重写run方法（真正回调的是回调run方法）</span></span><br><span class=\"line\">matcher.<span class=\"built_in\">addMatcher</span>(<span class=\"built_in\">objcPropertyDecl</span>().<span class=\"built_in\">bind</span>(<span class=\"string\">&quot;objcPropertyDecl&quot;</span>), &amp;callback);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 重载两个方法 HandleTopLevelDecl 和 HandleTranslationUnit</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 解析完毕一个顶级的声明就回调一次（顶级节点，即全局变量，属性，函数等）</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">HandleTopLevelDecl</span><span class=\"params\">(DeclGroupRef D)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//            cout&lt;&lt;&quot;正在解析...&quot;&lt;&lt;endl;</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 当整个文件都解析完毕后回调</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">HandleTranslationUnit</span><span class=\"params\">(ASTContext &amp;Ctx)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//            cout&lt;&lt;&quot;文件解析完毕！！！&quot;&lt;&lt;endl;</span></span><br><span class=\"line\">            <span class=\"comment\">// 将文件解析完毕后的上下文context（即AST语法树） 给 matcher</span></span><br><span class=\"line\">            matcher.<span class=\"built_in\">matchAST</span>(Ctx);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//2、继承PluginASTAction，实现我们自定义的MyASTAction，即自定义AST语法树行为</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyASTAction</span> :</span> <span class=\"keyword\">public</span> PluginASTAction &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 重载ParseArgs 和 CreateASTConsumer方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         解析给定的插件命令行参数</span></span><br><span class=\"line\"><span class=\"comment\">         - param CI 编译器实例，用于报告诊断。</span></span><br><span class=\"line\"><span class=\"comment\">         - return 如果解析成功，则为true；否则，插件将被销毁，并且不执行任何操作。该插件负责使用CompilerInstance的Diagnostic对象报告错误。</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ParseArgs</span><span class=\"params\">(<span class=\"keyword\">const</span> CompilerInstance &amp;CI, <span class=\"keyword\">const</span> std::vector&lt;std::string&gt; &amp;arg)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 返回自定义的MyASTConsumer对象，抽象类ASTConsumer的子类</span></span><br><span class=\"line\">        <span class=\"function\">unique_ptr&lt;ASTConsumer&gt; <span class=\"title\">CreateASTConsumer</span><span class=\"params\">(CompilerInstance &amp;CI, StringRef InFile)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">             传递CI</span></span><br><span class=\"line\"><span class=\"comment\">             CI用于：</span></span><br><span class=\"line\"><span class=\"comment\">             - 判断文件是否是用户的</span></span><br><span class=\"line\"><span class=\"comment\">             - 抛出警告</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> unique_ptr&lt;MyASTConsumer&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">MyASTConsumer</span>(CI));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一步：注册插件，并自定义MyASTAction类</span></span><br><span class=\"line\"><span class=\"comment\">// 1、注册插件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> FrontendPluginRegistry::Add&lt;MyPlugin::MyASTAction&gt; <span class=\"title\">X</span><span class=\"params\">(<span class=\"string\">&quot;MyPlugin&quot;</span>, <span class=\"string\">&quot;this is MyPlugin&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>参考：<a href=\"https://juejin.cn/post/7004633055012864031\">https://juejin.cn/post/7004633055012864031</a></p>\n</blockquote>"},{"title":"汇编分析Swift inout与函数内联优化","author":"Arclin","date":"2021-09-21T03:24:16.000Z","_content":"本文主要讲述通过汇编分析展示Swift inout的实现原理与Swift针对函数的内联优化原理\n\n<!-- more -->\n\n","source":"_drafts/汇编分析Swift-inout与函数内联优化.md","raw":"title: 汇编分析Swift inout与函数内联优化\nauthor: Arclin\ndate: 2021-09-21 11:24:16\ntags:\n---\n本文主要讲述通过汇编分析展示Swift inout的实现原理与Swift针对函数的内联优化原理\n\n<!-- more -->\n\n","slug":"汇编分析Swift-inout与函数内联优化","published":0,"updated":"2021-09-21T05:33:07.725Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku2zb0gb0000xdn09ipegh7l","content":"<p>本文主要讲述通过汇编分析展示Swift inout的实现原理与Swift针对函数的内联优化原理</p>\n<span id=\"more\"></span>\n\n","site":{"data":{}},"excerpt":"<p>本文主要讲述通过汇编分析展示Swift inout的实现原理与Swift针对函数的内联优化原理</p>","more":""},{"title":"函数式Swift --- 透镜","author":"Arclin","abbrlink":"c5814bfc","date":"2021-09-25T15:29:29.000Z","_content":"Swift是实现函数式思想的一门好语言，这里简要讲述一下函数式中透镜的Swift实现\n\n<!-- more -->\n\n## 举个例子\n\n首先我们先创建一个结构体\n\n```swift\nstruct Point {\n    let x : CGFloat\n    let y : CGFloat\n}\n\nvar point = Point(x: 1, y: 2)\npoint.x = 2\n```\n\n一般情况下这时候会报错`Cannot assign to property: 'x' is a 'let' constant`，因为`x`是一个常量，所以无法修改\n\n那么有时候我们如果需要改变一个不可变的属性的值，那么一般我们会选择再创建一个对象去覆盖\n\n```swift\nstruct Point {\n    let x : CGFloat\n    let y : CGFloat\n}\n\nvar point = Point(x: 1, y: 2)\nlet tempPoint = Point(x: 2, y: point.y)\npoint = tempPoint\n```\n\n但是这样子做未免显得有点麻烦，假如你觉得这样子还能接受，那么我再举个例子\n\n```swift\nstruct Point {\n    let x : CGFloat\n    let y : CGFloat\n}\n\nstruct Line {\n    let start : Point\n    let end : Point\n}\n\nstruct Square {\n    let line : Line // 通过线段我们可以计算出正方形的边长\n    let origin : Point\n}\n\nlet start = Point(x: 1, y: 1)\nlet end = Point(x: 10, y: 10)\n\nlet line = Line(start: start, end: end)\n\nlet origin = Point(x: 5, y: 5)\nlet square = Square(line: line, origin: origin)\n\nsquare.line.start.x = 20 // Error : Cannot assign to property: 'x' is a 'let' constant\n```\n\n假如这时候我们希望把`square.line.start.x`设置为20，那么按照常规的写法就显得很麻烦了，更何况实际开发中可能还存在着更深的嵌套\n\n## 方案\n\n我们可以使用函数式的方案去解决上面的问题，首先我们先把问题简化，先考虑如何把`Point`的`x`属性优雅地去进行更改\n\n### 基本原理\n\n首先我们定义一个函数签名，取名为`Lens`(透镜)\n\n```swift\ntypealias Lens<Subpart,Whole> = (@escaping (Subpart) -> Subpart) -> (Whole) -> Whole\n```\n\n其中`Subpart`表示要修改的属性的值，`Whole`表示被修改的这个对象\n\n整个定义的含义是\n1. 传入闭包表达式，这个闭包表达式会带入参数，参数值为被修改的属性的当前值，比如`x`的当前值1，然后闭包表达式修改这个值之后再次返回出去。\n2. 返回一个对象的闭包，这个闭包会带入参数，参数值为当前被修改的对象，闭包表达式返回一个新的对象，比如`Point`\n\n为了方便构建一个透镜，我们再添加一个方法用于初始化一个透镜\n\n```swift\nfunc lens<Subpart,Whole>(view: @escaping (Whole) -> Subpart, set: @escaping (Subpart,Whole) -> Whole) -> Lens<Subpart,Whole> {\n    /// 缩减写法\n    return { mapper in { set(mapper(view($0)), $0) } }\n}\n```\n\n这个方法传入两个参数\n\n1. 闭包表达式`view`表示传入一个对象，返回这个对象要被修改的那个属性当前值，比如我们上面提到的`x`，相当于一个`get`操作\n2. 闭包表达式`set`表示传入要被修改属性的新值和要被修改的对象，然后返回包含新值的属性的新对象，相当于一个`set`操作\n\n最后把闭包表达式返回出去就是我们所要的透镜，也可以理解为一个修改器。这个修改器内定好了哪个属性要被修改成哪个值，然后这个修改器最后返回一个闭包表达式，传入一个旧对象，返回一个带有新值的新对象\n\n如果觉得上面的缩减写法有点晦涩，那我们展开来描述\n\n```swift\nreturn { mapper in // mapper是用于修改属性值的一个闭包表达式\n    return {\n        let subpart = view($0) // 拿到某个属性当前的值\n        let newSubpart = mapper(subpart) // 处理成新值\n        return set(newSubpart, $0) // 返回一个新对象\n    }\n}\n```\n\n### 使用\n\n接下来我们就可以用上面定义好的方法来构件我们的`x`属性透镜和`y`属性透镜\n\n```swift\nextension Point {\n    static let xL : Lens<CGFloat,Point> = lens(\n        view: { $0.x },\n        set: { Point(x: $0, y: $1.y) }\n    )\n    \n    static let yL : Lens<CGFloat,Point> = lens(\n        view: { $0.y },\t// 即将要被修改的值是y\n        set: { Point(x: $1.x, y: $0) } // 新值为$0，旧值\nx依旧还是从原来对象里面取    \n    )\n}\n\n// 定义一个能把x改成10的透镜\nlet xLens = Point.xL { _ in 10 }\n\nvar point1 = Point(x: 1, y: 1)\nvar point2 = Point(x: 2, y: 2)\n\npoint1 = xLens(point1)\npoint2 = xLens(point2)\n\nprint(point1) // Point(x: 10.0, y: 1.0)\nprint(point2) // Point(x: 10.0, y: 2.0)\n```\n\n### 改进\n\n但是这样子的使用方法还是不够方便，所以我们定义多两个方法封装一下\n\n```swift\nfunc over<Subpart,Whole>(mapper: @escaping (Subpart) -> Subpart, lens: Lens<Subpart,Whole>) -> (Whole) -> Whole {\n    return lens(mapper)\n}\n\nfunc set<Subpart,Whole>(value: Subpart,lens: Lens<Subpart,Whole>) -> (Whole) -> Whole {\n    return over( mapper: { _ in value }, lens: lens)\n}\n```\n\n`over`方法传入一个闭包表达式和一个透镜，闭包表达式参数是用来修改属性值，跟透镜结合使用，返回新对象\n\n`set`方法传入一个新值和一个透镜，新值是用于构建修改属性的闭包，跟传入的透镜结合，调用`over`方法\n\n有了这两个方法，我们就可以把之前的写法进行修改\n\n```swift\nlet xLens = set(value: 10, lens: Point.xL) // 等价于下面的写法\n// let xLens = Point.xL { _ in 10 } \n```\n\n这么一看貌似只是简单地把闭包表达式变成了函数调用，也就是花括号变成了括号而已\n\n但实际上变成了函数调用的方式之后我们就可以做更多的事情了\n\n比如说：\n\n```\ninfix operator %~\ninfix operator .~\n\nfunc %~ <Subpart, Whole>(lhs: Lens<Subpart, Whole>, rhs: @escaping (Subpart) -> Subpart) -> (Whole) -> Whole {\n    return over(mapper: rhs, lens: lhs)\n}\n\nfunc .~ <Subpart, Whole>(lhs: Lens<Subpart, Whole>, rhs: Subpart) -> (Whole) -> Whole {\n    return set(value: rhs, lens: lhs)\n}\n```\n\n这时候我们的调用方式就变成了\n\n```swift\nlet xLens = Point.xL .~ 10\n```\n\n还不够，再加一个定义，我们把对象的修改方式给改了\n\n```swift\nprecedencegroup LensPrecedence {\n    higherThan : AdditionPrecedence\n}\n\ninfix operator .~ : LensPrecedence\ninfix operator %~ : LensPrecedence\ninfix operator |> : AdditionPrecedence\n\n\nfunc %~ <Subpart, Whole>(lhs: Lens<Subpart, Whole>, rhs: @escaping (Subpart) -> Subpart) -> (Whole) -> Whole {\n    return over(mapper: rhs, lens: lhs)\n}\n\nfunc .~ <Subpart, Whole>(lhs: Lens<Subpart, Whole>, rhs: Subpart) -> (Whole) -> Whole {\n    return set(value: rhs, lens: lhs)\n}\n\nfunc |> <A, B> (lhs: A, rhs: (A) -> B) -> B {\n    return rhs(lhs)\n}\n```\n\n这样子当我们想要修改一个点的x值和y值的时候，就可以这么写了\n\n```swift\nvar point = Point(x: 1, y: 1)\n\npoint = point\n    |> Point.xL .~ 10\n    |> Point.yL .~ 20\n    |> Point.xL %~ { $0 - 5 }\n```\n\n看起来就简洁许多\n\n### 复杂的情况\n\n那么刚才我们提及的复杂的情况，除了点之外，还出现了线和面，那应该怎么做呢\n\n同理可得，我们给线和面也添加透镜\n\n```swift\nextension Line {\n    static let startL : Lens<Point,Line> = lens(\n        view: { $0.start },\n        set: { Line(start: $0, end: $1.end ) }\n    )\n    \n    static let endL : Lens<Point,Line> = lens(\n        view: { $0.end },\n        set: { Line(start: $1.start, end: $0) }\n    )\n}\n\nextension Square {\n    static let lineL : Lens<Line,Square> = lens(\n        view: { $0.line },\n        set: { Square(line: $0, origin: $1.origin) }\n    )\n    static let originL : Lens<Point,Square> = lens(\n        view: { $0.origin },\n        set: { Square(line: $1.line, origin: $0) }\n    )\n}\n```\n\n新增一个运算符`<<<`表示左结合，把右参数（闭包表达式）作为左参数（闭包表达式）的参数，并修改一下运算符之间的优先级\n\n```swift\nprecedencegroup CombinePrecedence {\n    associativity : left\n    higherThan : LensPrecedence\n}\n\nprecedencegroup LensPrecedence {\n    associativity: right\n    higherThan : AdditionPrecedence\n}\n\ninfix operator <<< : CombinePrecedence\n\nfunc <<< <A, B, C> (lhs: @escaping (B) -> C, rhs: @escaping (A) -> B) -> (A) -> C {\n    return { lhs(rhs($0)) }\n}\n```\n\n最终调用方式如下\n\n```swift\n/// 线段的起始点设置为20，原点的y值设置为30\nsquare = square\n    |> Square.lineL <<< Line.startL <<< Point.xL .~ 20\n    |> Square.originL <<< Point.yL .~ 30\n```\n\n看起来也是十分简洁\n\n### 完整代码\n\n仅供参考\n\n```swift\nimport UIKit\n\nstruct Point {\n    let x : CGFloat\n    let y : CGFloat\n}\n\nstruct Line {\n    let start : Point\n    let end : Point\n}\n\nstruct Square {\n    let line : Line\n    let origin : Point\n}\n\ntypealias Lens<Subpart,Whole> = (@escaping (Subpart) -> Subpart) -> (Whole) -> Whole\n\nfunc lens<Subpart,Whole>(view: @escaping (Whole) -> Subpart, set: @escaping (Subpart,Whole) -> Whole) -> Lens<Subpart,Whole> {\n//    return { mapper in\n//        return {\n//            let subpart = view($0)\n//            let newSubpart = mapper(subpart)\n//            return set(newSubpart, $0)\n//        }\n//    }\n    /// 可以缩减为这种写法\n    return { mapper in { set(mapper(view($0)), $0) } }\n}\n\nfunc over<Subpart,Whole>(mapper: @escaping (Subpart) -> Subpart, lens: Lens<Subpart,Whole>) -> (Whole) -> Whole {\n    return lens(mapper)\n}\n\nfunc set<Subpart,Whole>(value: Subpart,lens: Lens<Subpart,Whole>) -> (Whole) -> Whole {\n    return over( mapper: { _ in value }, lens: lens)\n}\n\nprecedencegroup CombinePrecedence {\n    associativity : left\n    higherThan : LensPrecedence\n}\n\nprecedencegroup LensPrecedence {\n    associativity: right\n    higherThan : AdditionPrecedence\n}\n\ninfix operator %~  : LensPrecedence\ninfix operator .~  : LensPrecedence\ninfix operator |>  : AdditionPrecedence\ninfix operator <<< : CombinePrecedence\n\nfunc %~ <Subpart, Whole>(lhs: Lens<Subpart, Whole>, rhs: @escaping (Subpart) -> Subpart) -> (Whole) -> Whole {\n    return over(mapper: rhs, lens: lhs)\n}\n\nfunc .~ <Subpart, Whole>(lhs: Lens<Subpart, Whole>, rhs: Subpart) -> (Whole) -> Whole {\n    return set(value: rhs, lens: lhs)\n}\n\nfunc |> <A, B> (lhs: A, rhs: (A) -> B) -> B {\n    return rhs(lhs)\n}\n\nfunc <<< <A, B, C> (lhs: @escaping (B) -> C, rhs: @escaping (A) -> B) -> (A) -> C {\n    return { lhs(rhs($0)) }\n}\n\nextension Point {\n    static let xL : Lens<CGFloat,Point> = lens(\n        view: { $0.x },\n        set: { Point(x: $0, y: $1.y) }\n    )\n    \n    static let yL : Lens<CGFloat,Point> = lens(\n        view: { $0.y },\n        set: { Point(x: $1.x, y: $0) }\n    )\n}\n\nextension Line {\n    static let startL : Lens<Point,Line> = lens(\n        view: { $0.start },\n        set: { Line(start: $0, end: $1.end ) }\n    )\n    \n    static let endL : Lens<Point,Line> = lens(\n        view: { $0.end },\n        set: { Line(start: $1.start, end: $0) }\n    )\n}\n\nextension Square {\n    static let lineL : Lens<Line,Square> = lens(\n        view: { $0.line },\n        set: { Square(line: $0, origin: $1.origin) }\n    )\n    static let originL : Lens<Point,Square> = lens(\n        view: { $0.origin },\n        set: { Square(line: $1.line, origin: $0) }\n    )\n}\n\n//let xLens = Point.xL { _ in 10 }\n//let xLens = set(value: 10, lens: Point.xL)\n//let xLens = Point.xL .~ 10\nvar point1 = Point(x: 1, y: 1)\n\npoint1 = point1\n    |> Point.xL .~ 10\n    |> Point.yL .~ 20\n    |> Point.xL %~ { $0 - 5 }\n\nlet origin = Point(x: 5, y: 5)\nvar line = Line(start: origin, end: point1)\nvar square = Square(line: line, origin: origin)\n\nprint(\"修改前\\(square)\")\n\n/// 线段的起始点设置为20，原点的y值设置为30\nsquare = square\n    |> Square.lineL <<< Line.startL <<< Point.xL .~ 20\n    |> Square.originL <<< Point.yL .~ 30\n\nprint(\"修改后\\(square)\")\n```\n","source":"_posts/函数式Swift-透镜.md","raw":"title: 函数式Swift --- 透镜\nauthor: Arclin\nabbrlink: c5814bfc\ndate: 2021-09-25 23:29:29\ntags:\n---\nSwift是实现函数式思想的一门好语言，这里简要讲述一下函数式中透镜的Swift实现\n\n<!-- more -->\n\n## 举个例子\n\n首先我们先创建一个结构体\n\n```swift\nstruct Point {\n    let x : CGFloat\n    let y : CGFloat\n}\n\nvar point = Point(x: 1, y: 2)\npoint.x = 2\n```\n\n一般情况下这时候会报错`Cannot assign to property: 'x' is a 'let' constant`，因为`x`是一个常量，所以无法修改\n\n那么有时候我们如果需要改变一个不可变的属性的值，那么一般我们会选择再创建一个对象去覆盖\n\n```swift\nstruct Point {\n    let x : CGFloat\n    let y : CGFloat\n}\n\nvar point = Point(x: 1, y: 2)\nlet tempPoint = Point(x: 2, y: point.y)\npoint = tempPoint\n```\n\n但是这样子做未免显得有点麻烦，假如你觉得这样子还能接受，那么我再举个例子\n\n```swift\nstruct Point {\n    let x : CGFloat\n    let y : CGFloat\n}\n\nstruct Line {\n    let start : Point\n    let end : Point\n}\n\nstruct Square {\n    let line : Line // 通过线段我们可以计算出正方形的边长\n    let origin : Point\n}\n\nlet start = Point(x: 1, y: 1)\nlet end = Point(x: 10, y: 10)\n\nlet line = Line(start: start, end: end)\n\nlet origin = Point(x: 5, y: 5)\nlet square = Square(line: line, origin: origin)\n\nsquare.line.start.x = 20 // Error : Cannot assign to property: 'x' is a 'let' constant\n```\n\n假如这时候我们希望把`square.line.start.x`设置为20，那么按照常规的写法就显得很麻烦了，更何况实际开发中可能还存在着更深的嵌套\n\n## 方案\n\n我们可以使用函数式的方案去解决上面的问题，首先我们先把问题简化，先考虑如何把`Point`的`x`属性优雅地去进行更改\n\n### 基本原理\n\n首先我们定义一个函数签名，取名为`Lens`(透镜)\n\n```swift\ntypealias Lens<Subpart,Whole> = (@escaping (Subpart) -> Subpart) -> (Whole) -> Whole\n```\n\n其中`Subpart`表示要修改的属性的值，`Whole`表示被修改的这个对象\n\n整个定义的含义是\n1. 传入闭包表达式，这个闭包表达式会带入参数，参数值为被修改的属性的当前值，比如`x`的当前值1，然后闭包表达式修改这个值之后再次返回出去。\n2. 返回一个对象的闭包，这个闭包会带入参数，参数值为当前被修改的对象，闭包表达式返回一个新的对象，比如`Point`\n\n为了方便构建一个透镜，我们再添加一个方法用于初始化一个透镜\n\n```swift\nfunc lens<Subpart,Whole>(view: @escaping (Whole) -> Subpart, set: @escaping (Subpart,Whole) -> Whole) -> Lens<Subpart,Whole> {\n    /// 缩减写法\n    return { mapper in { set(mapper(view($0)), $0) } }\n}\n```\n\n这个方法传入两个参数\n\n1. 闭包表达式`view`表示传入一个对象，返回这个对象要被修改的那个属性当前值，比如我们上面提到的`x`，相当于一个`get`操作\n2. 闭包表达式`set`表示传入要被修改属性的新值和要被修改的对象，然后返回包含新值的属性的新对象，相当于一个`set`操作\n\n最后把闭包表达式返回出去就是我们所要的透镜，也可以理解为一个修改器。这个修改器内定好了哪个属性要被修改成哪个值，然后这个修改器最后返回一个闭包表达式，传入一个旧对象，返回一个带有新值的新对象\n\n如果觉得上面的缩减写法有点晦涩，那我们展开来描述\n\n```swift\nreturn { mapper in // mapper是用于修改属性值的一个闭包表达式\n    return {\n        let subpart = view($0) // 拿到某个属性当前的值\n        let newSubpart = mapper(subpart) // 处理成新值\n        return set(newSubpart, $0) // 返回一个新对象\n    }\n}\n```\n\n### 使用\n\n接下来我们就可以用上面定义好的方法来构件我们的`x`属性透镜和`y`属性透镜\n\n```swift\nextension Point {\n    static let xL : Lens<CGFloat,Point> = lens(\n        view: { $0.x },\n        set: { Point(x: $0, y: $1.y) }\n    )\n    \n    static let yL : Lens<CGFloat,Point> = lens(\n        view: { $0.y },\t// 即将要被修改的值是y\n        set: { Point(x: $1.x, y: $0) } // 新值为$0，旧值\nx依旧还是从原来对象里面取    \n    )\n}\n\n// 定义一个能把x改成10的透镜\nlet xLens = Point.xL { _ in 10 }\n\nvar point1 = Point(x: 1, y: 1)\nvar point2 = Point(x: 2, y: 2)\n\npoint1 = xLens(point1)\npoint2 = xLens(point2)\n\nprint(point1) // Point(x: 10.0, y: 1.0)\nprint(point2) // Point(x: 10.0, y: 2.0)\n```\n\n### 改进\n\n但是这样子的使用方法还是不够方便，所以我们定义多两个方法封装一下\n\n```swift\nfunc over<Subpart,Whole>(mapper: @escaping (Subpart) -> Subpart, lens: Lens<Subpart,Whole>) -> (Whole) -> Whole {\n    return lens(mapper)\n}\n\nfunc set<Subpart,Whole>(value: Subpart,lens: Lens<Subpart,Whole>) -> (Whole) -> Whole {\n    return over( mapper: { _ in value }, lens: lens)\n}\n```\n\n`over`方法传入一个闭包表达式和一个透镜，闭包表达式参数是用来修改属性值，跟透镜结合使用，返回新对象\n\n`set`方法传入一个新值和一个透镜，新值是用于构建修改属性的闭包，跟传入的透镜结合，调用`over`方法\n\n有了这两个方法，我们就可以把之前的写法进行修改\n\n```swift\nlet xLens = set(value: 10, lens: Point.xL) // 等价于下面的写法\n// let xLens = Point.xL { _ in 10 } \n```\n\n这么一看貌似只是简单地把闭包表达式变成了函数调用，也就是花括号变成了括号而已\n\n但实际上变成了函数调用的方式之后我们就可以做更多的事情了\n\n比如说：\n\n```\ninfix operator %~\ninfix operator .~\n\nfunc %~ <Subpart, Whole>(lhs: Lens<Subpart, Whole>, rhs: @escaping (Subpart) -> Subpart) -> (Whole) -> Whole {\n    return over(mapper: rhs, lens: lhs)\n}\n\nfunc .~ <Subpart, Whole>(lhs: Lens<Subpart, Whole>, rhs: Subpart) -> (Whole) -> Whole {\n    return set(value: rhs, lens: lhs)\n}\n```\n\n这时候我们的调用方式就变成了\n\n```swift\nlet xLens = Point.xL .~ 10\n```\n\n还不够，再加一个定义，我们把对象的修改方式给改了\n\n```swift\nprecedencegroup LensPrecedence {\n    higherThan : AdditionPrecedence\n}\n\ninfix operator .~ : LensPrecedence\ninfix operator %~ : LensPrecedence\ninfix operator |> : AdditionPrecedence\n\n\nfunc %~ <Subpart, Whole>(lhs: Lens<Subpart, Whole>, rhs: @escaping (Subpart) -> Subpart) -> (Whole) -> Whole {\n    return over(mapper: rhs, lens: lhs)\n}\n\nfunc .~ <Subpart, Whole>(lhs: Lens<Subpart, Whole>, rhs: Subpart) -> (Whole) -> Whole {\n    return set(value: rhs, lens: lhs)\n}\n\nfunc |> <A, B> (lhs: A, rhs: (A) -> B) -> B {\n    return rhs(lhs)\n}\n```\n\n这样子当我们想要修改一个点的x值和y值的时候，就可以这么写了\n\n```swift\nvar point = Point(x: 1, y: 1)\n\npoint = point\n    |> Point.xL .~ 10\n    |> Point.yL .~ 20\n    |> Point.xL %~ { $0 - 5 }\n```\n\n看起来就简洁许多\n\n### 复杂的情况\n\n那么刚才我们提及的复杂的情况，除了点之外，还出现了线和面，那应该怎么做呢\n\n同理可得，我们给线和面也添加透镜\n\n```swift\nextension Line {\n    static let startL : Lens<Point,Line> = lens(\n        view: { $0.start },\n        set: { Line(start: $0, end: $1.end ) }\n    )\n    \n    static let endL : Lens<Point,Line> = lens(\n        view: { $0.end },\n        set: { Line(start: $1.start, end: $0) }\n    )\n}\n\nextension Square {\n    static let lineL : Lens<Line,Square> = lens(\n        view: { $0.line },\n        set: { Square(line: $0, origin: $1.origin) }\n    )\n    static let originL : Lens<Point,Square> = lens(\n        view: { $0.origin },\n        set: { Square(line: $1.line, origin: $0) }\n    )\n}\n```\n\n新增一个运算符`<<<`表示左结合，把右参数（闭包表达式）作为左参数（闭包表达式）的参数，并修改一下运算符之间的优先级\n\n```swift\nprecedencegroup CombinePrecedence {\n    associativity : left\n    higherThan : LensPrecedence\n}\n\nprecedencegroup LensPrecedence {\n    associativity: right\n    higherThan : AdditionPrecedence\n}\n\ninfix operator <<< : CombinePrecedence\n\nfunc <<< <A, B, C> (lhs: @escaping (B) -> C, rhs: @escaping (A) -> B) -> (A) -> C {\n    return { lhs(rhs($0)) }\n}\n```\n\n最终调用方式如下\n\n```swift\n/// 线段的起始点设置为20，原点的y值设置为30\nsquare = square\n    |> Square.lineL <<< Line.startL <<< Point.xL .~ 20\n    |> Square.originL <<< Point.yL .~ 30\n```\n\n看起来也是十分简洁\n\n### 完整代码\n\n仅供参考\n\n```swift\nimport UIKit\n\nstruct Point {\n    let x : CGFloat\n    let y : CGFloat\n}\n\nstruct Line {\n    let start : Point\n    let end : Point\n}\n\nstruct Square {\n    let line : Line\n    let origin : Point\n}\n\ntypealias Lens<Subpart,Whole> = (@escaping (Subpart) -> Subpart) -> (Whole) -> Whole\n\nfunc lens<Subpart,Whole>(view: @escaping (Whole) -> Subpart, set: @escaping (Subpart,Whole) -> Whole) -> Lens<Subpart,Whole> {\n//    return { mapper in\n//        return {\n//            let subpart = view($0)\n//            let newSubpart = mapper(subpart)\n//            return set(newSubpart, $0)\n//        }\n//    }\n    /// 可以缩减为这种写法\n    return { mapper in { set(mapper(view($0)), $0) } }\n}\n\nfunc over<Subpart,Whole>(mapper: @escaping (Subpart) -> Subpart, lens: Lens<Subpart,Whole>) -> (Whole) -> Whole {\n    return lens(mapper)\n}\n\nfunc set<Subpart,Whole>(value: Subpart,lens: Lens<Subpart,Whole>) -> (Whole) -> Whole {\n    return over( mapper: { _ in value }, lens: lens)\n}\n\nprecedencegroup CombinePrecedence {\n    associativity : left\n    higherThan : LensPrecedence\n}\n\nprecedencegroup LensPrecedence {\n    associativity: right\n    higherThan : AdditionPrecedence\n}\n\ninfix operator %~  : LensPrecedence\ninfix operator .~  : LensPrecedence\ninfix operator |>  : AdditionPrecedence\ninfix operator <<< : CombinePrecedence\n\nfunc %~ <Subpart, Whole>(lhs: Lens<Subpart, Whole>, rhs: @escaping (Subpart) -> Subpart) -> (Whole) -> Whole {\n    return over(mapper: rhs, lens: lhs)\n}\n\nfunc .~ <Subpart, Whole>(lhs: Lens<Subpart, Whole>, rhs: Subpart) -> (Whole) -> Whole {\n    return set(value: rhs, lens: lhs)\n}\n\nfunc |> <A, B> (lhs: A, rhs: (A) -> B) -> B {\n    return rhs(lhs)\n}\n\nfunc <<< <A, B, C> (lhs: @escaping (B) -> C, rhs: @escaping (A) -> B) -> (A) -> C {\n    return { lhs(rhs($0)) }\n}\n\nextension Point {\n    static let xL : Lens<CGFloat,Point> = lens(\n        view: { $0.x },\n        set: { Point(x: $0, y: $1.y) }\n    )\n    \n    static let yL : Lens<CGFloat,Point> = lens(\n        view: { $0.y },\n        set: { Point(x: $1.x, y: $0) }\n    )\n}\n\nextension Line {\n    static let startL : Lens<Point,Line> = lens(\n        view: { $0.start },\n        set: { Line(start: $0, end: $1.end ) }\n    )\n    \n    static let endL : Lens<Point,Line> = lens(\n        view: { $0.end },\n        set: { Line(start: $1.start, end: $0) }\n    )\n}\n\nextension Square {\n    static let lineL : Lens<Line,Square> = lens(\n        view: { $0.line },\n        set: { Square(line: $0, origin: $1.origin) }\n    )\n    static let originL : Lens<Point,Square> = lens(\n        view: { $0.origin },\n        set: { Square(line: $1.line, origin: $0) }\n    )\n}\n\n//let xLens = Point.xL { _ in 10 }\n//let xLens = set(value: 10, lens: Point.xL)\n//let xLens = Point.xL .~ 10\nvar point1 = Point(x: 1, y: 1)\n\npoint1 = point1\n    |> Point.xL .~ 10\n    |> Point.yL .~ 20\n    |> Point.xL %~ { $0 - 5 }\n\nlet origin = Point(x: 5, y: 5)\nvar line = Line(start: origin, end: point1)\nvar square = Square(line: line, origin: origin)\n\nprint(\"修改前\\(square)\")\n\n/// 线段的起始点设置为20，原点的y值设置为30\nsquare = square\n    |> Square.lineL <<< Line.startL <<< Point.xL .~ 20\n    |> Square.originL <<< Point.yL .~ 30\n\nprint(\"修改后\\(square)\")\n```\n","slug":"函数式Swift-透镜","published":1,"updated":"2021-09-27T18:22:39.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku2zb0gi0001xdn0h1j24h16","content":"<p>Swift是实现函数式思想的一门好语言，这里简要讲述一下函数式中透镜的Swift实现</p>\n<span id=\"more\"></span>\n\n<h2 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h2><p>首先我们先创建一个结构体</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x : <span class=\"type\">CGFloat</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> y : <span class=\"type\">CGFloat</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> point <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">2</span>)</span><br><span class=\"line\">point.x <span class=\"operator\">=</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>一般情况下这时候会报错<code>Cannot assign to property: &#39;x&#39; is a &#39;let&#39; constant</code>，因为<code>x</code>是一个常量，所以无法修改</p>\n<p>那么有时候我们如果需要改变一个不可变的属性的值，那么一般我们会选择再创建一个对象去覆盖</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x : <span class=\"type\">CGFloat</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> y : <span class=\"type\">CGFloat</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> point <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempPoint <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">2</span>, y: point.y)</span><br><span class=\"line\">point <span class=\"operator\">=</span> tempPoint</span><br></pre></td></tr></table></figure>\n\n<p>但是这样子做未免显得有点麻烦，假如你觉得这样子还能接受，那么我再举个例子</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x : <span class=\"type\">CGFloat</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> y : <span class=\"type\">CGFloat</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Line</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> start : <span class=\"type\">Point</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> end : <span class=\"type\">Point</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> line : <span class=\"type\">Line</span> <span class=\"comment\">// 通过线段我们可以计算出正方形的边长</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> origin : <span class=\"type\">Point</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> start <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> end <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">10</span>, y: <span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> line <span class=\"operator\">=</span> <span class=\"type\">Line</span>(start: start, end: end)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> origin <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">5</span>, y: <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> square <span class=\"operator\">=</span> <span class=\"type\">Square</span>(line: line, origin: origin)</span><br><span class=\"line\"></span><br><span class=\"line\">square.line.start.x <span class=\"operator\">=</span> <span class=\"number\">20</span> <span class=\"comment\">// Error : Cannot assign to property: &#x27;x&#x27; is a &#x27;let&#x27; constant</span></span><br></pre></td></tr></table></figure>\n\n<p>假如这时候我们希望把<code>square.line.start.x</code>设置为20，那么按照常规的写法就显得很麻烦了，更何况实际开发中可能还存在着更深的嵌套</p>\n<h2 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h2><p>我们可以使用函数式的方案去解决上面的问题，首先我们先把问题简化，先考虑如何把<code>Point</code>的<code>x</code>属性优雅地去进行更改</p>\n<h3 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h3><p>首先我们定义一个函数签名，取名为<code>Lens</code>(透镜)</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typealias</span> <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt; <span class=\"operator\">=</span> (<span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>) -&gt; <span class=\"type\">Subpart</span>) -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span></span><br></pre></td></tr></table></figure>\n\n<p>其中<code>Subpart</code>表示要修改的属性的值，<code>Whole</code>表示被修改的这个对象</p>\n<p>整个定义的含义是</p>\n<ol>\n<li>传入闭包表达式，这个闭包表达式会带入参数，参数值为被修改的属性的当前值，比如<code>x</code>的当前值1，然后闭包表达式修改这个值之后再次返回出去。</li>\n<li>返回一个对象的闭包，这个闭包会带入参数，参数值为当前被修改的对象，闭包表达式返回一个新的对象，比如<code>Point</code></li>\n</ol>\n<p>为了方便构建一个透镜，我们再添加一个方法用于初始化一个透镜</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;(<span class=\"params\">view</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Subpart</span>, <span class=\"params\">set</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span>)</span> -&gt; <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// 缩减写法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; mapper <span class=\"keyword\">in</span> &#123; <span class=\"keyword\">set</span>(mapper(view(<span class=\"variable\">$0</span>)), <span class=\"variable\">$0</span>) &#125; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法传入两个参数</p>\n<ol>\n<li>闭包表达式<code>view</code>表示传入一个对象，返回这个对象要被修改的那个属性当前值，比如我们上面提到的<code>x</code>，相当于一个<code>get</code>操作</li>\n<li>闭包表达式<code>set</code>表示传入要被修改属性的新值和要被修改的对象，然后返回包含新值的属性的新对象，相当于一个<code>set</code>操作</li>\n</ol>\n<p>最后把闭包表达式返回出去就是我们所要的透镜，也可以理解为一个修改器。这个修改器内定好了哪个属性要被修改成哪个值，然后这个修改器最后返回一个闭包表达式，传入一个旧对象，返回一个带有新值的新对象</p>\n<p>如果觉得上面的缩减写法有点晦涩，那我们展开来描述</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> &#123; mapper <span class=\"keyword\">in</span> <span class=\"comment\">// mapper是用于修改属性值的一个闭包表达式</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> subpart <span class=\"operator\">=</span> view(<span class=\"variable\">$0</span>) <span class=\"comment\">// 拿到某个属性当前的值</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> newSubpart <span class=\"operator\">=</span> mapper(subpart) <span class=\"comment\">// 处理成新值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">set</span>(newSubpart, <span class=\"variable\">$0</span>) <span class=\"comment\">// 返回一个新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>接下来我们就可以用上面定义好的方法来构件我们的<code>x</code>属性透镜和<code>y</code>属性透镜</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> xL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">CGFloat</span>,<span class=\"type\">Point</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.x &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Point</span>(x: <span class=\"variable\">$0</span>, y: <span class=\"variable\">$1</span>.y) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> yL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">CGFloat</span>,<span class=\"type\">Point</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.y &#125;,\t<span class=\"comment\">// 即将要被修改的值是y</span></span><br><span class=\"line\">        set: &#123; <span class=\"type\">Point</span>(x: <span class=\"variable\">$1</span>.x, y: <span class=\"variable\">$0</span>) &#125; <span class=\"comment\">// 新值为$0，旧值</span></span><br><span class=\"line\">x依旧还是从原来对象里面取    </span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个能把x改成10的透镜</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> xLens <span class=\"operator\">=</span> <span class=\"type\">Point</span>.xL &#123; <span class=\"keyword\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">10</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> point1 <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> point2 <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">2</span>, y: <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">point1 <span class=\"operator\">=</span> xLens(point1)</span><br><span class=\"line\">point2 <span class=\"operator\">=</span> xLens(point2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(point1) <span class=\"comment\">// Point(x: 10.0, y: 1.0)</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(point2) <span class=\"comment\">// Point(x: 10.0, y: 2.0)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>但是这样子的使用方法还是不够方便，所以我们定义多两个方法封装一下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">over</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;(<span class=\"params\">mapper</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>) -&gt; <span class=\"type\">Subpart</span>, <span class=\"params\">lens</span>: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;)</span> -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lens(mapper)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">set</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;(<span class=\"params\">value</span>: <span class=\"type\">Subpart</span>,<span class=\"params\">lens</span>: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;)</span> -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> over( mapper: &#123; <span class=\"keyword\">_</span> <span class=\"keyword\">in</span> value &#125;, lens: lens)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>over</code>方法传入一个闭包表达式和一个透镜，闭包表达式参数是用来修改属性值，跟透镜结合使用，返回新对象</p>\n<p><code>set</code>方法传入一个新值和一个透镜，新值是用于构建修改属性的闭包，跟传入的透镜结合，调用<code>over</code>方法</p>\n<p>有了这两个方法，我们就可以把之前的写法进行修改</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> xLens <span class=\"operator\">=</span> <span class=\"keyword\">set</span>(value: <span class=\"number\">10</span>, lens: <span class=\"type\">Point</span>.xL) <span class=\"comment\">// 等价于下面的写法</span></span><br><span class=\"line\"><span class=\"comment\">// let xLens = Point.xL &#123; _ in 10 &#125; </span></span><br></pre></td></tr></table></figure>\n\n<p>这么一看貌似只是简单地把闭包表达式变成了函数调用，也就是花括号变成了括号而已</p>\n<p>但实际上变成了函数调用的方式之后我们就可以做更多的事情了</p>\n<p>比如说：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> <span class=\"title\">%~</span></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> .<span class=\"title\">~</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">%~</span> &lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;(<span class=\"params\">lhs</span>: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;, <span class=\"params\">rhs</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>) -&gt; <span class=\"type\">Subpart</span>)</span> -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> over(mapper: rhs, lens: lhs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> </span><span class=\"operator\">.~</span> <span class=\"operator\">&lt;</span><span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span><span class=\"operator\">&gt;</span>(lhs: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;, rhs: <span class=\"type\">Subpart</span>) -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">set</span>(value: rhs, lens: lhs)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时候我们的调用方式就变成了</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> xLens <span class=\"operator\">=</span> <span class=\"type\">Point</span>.xL <span class=\"operator\">.~</span> <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<p>还不够，再加一个定义，我们把对象的修改方式给改了</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">precedencegroup</span> <span class=\"title\">LensPrecedence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">higherThan</span> : <span class=\"type\">AdditionPrecedence</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> .<span class=\"title\">~</span> : <span class=\"type\">LensPrecedence</span></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> <span class=\"title\">%~</span> : <span class=\"type\">LensPrecedence</span></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> <span class=\"title\">|&gt;</span> : <span class=\"type\">AdditionPrecedence</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">%~</span> &lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;(<span class=\"params\">lhs</span>: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;, <span class=\"params\">rhs</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>) -&gt; <span class=\"type\">Subpart</span>)</span> -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> over(mapper: rhs, lens: lhs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> </span><span class=\"operator\">.~</span> <span class=\"operator\">&lt;</span><span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span><span class=\"operator\">&gt;</span>(lhs: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;, rhs: <span class=\"type\">Subpart</span>) -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">set</span>(value: rhs, lens: lhs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">|&gt;</span> &lt;<span class=\"type\">A</span>, <span class=\"type\">B</span>&gt; (<span class=\"params\">lhs</span>: <span class=\"type\">A</span>, <span class=\"params\">rhs</span>: (<span class=\"type\">A</span>) -&gt; <span class=\"type\">B</span>)</span> -&gt; <span class=\"type\">B</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rhs(lhs)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样子当我们想要修改一个点的x值和y值的时候，就可以这么写了</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> point <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">point <span class=\"operator\">=</span> point</span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Point</span>.xL <span class=\"operator\">.~</span> <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Point</span>.yL <span class=\"operator\">.~</span> <span class=\"number\">20</span></span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Point</span>.xL <span class=\"operator\">%~</span> &#123; <span class=\"variable\">$0</span> <span class=\"operator\">-</span> <span class=\"number\">5</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来就简洁许多</p>\n<h3 id=\"复杂的情况\"><a href=\"#复杂的情况\" class=\"headerlink\" title=\"复杂的情况\"></a>复杂的情况</h3><p>那么刚才我们提及的复杂的情况，除了点之外，还出现了线和面，那应该怎么做呢</p>\n<p>同理可得，我们给线和面也添加透镜</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Line</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> startL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">Point</span>,<span class=\"type\">Line</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.start &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Line</span>(start: <span class=\"variable\">$0</span>, end: <span class=\"variable\">$1</span>.end ) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> endL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">Point</span>,<span class=\"type\">Line</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.end &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Line</span>(start: <span class=\"variable\">$1</span>.start, end: <span class=\"variable\">$0</span>) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> lineL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">Line</span>,<span class=\"type\">Square</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.line &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Square</span>(line: <span class=\"variable\">$0</span>, origin: <span class=\"variable\">$1</span>.origin) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> originL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">Point</span>,<span class=\"type\">Square</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.origin &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Square</span>(line: <span class=\"variable\">$1</span>.line, origin: <span class=\"variable\">$0</span>) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新增一个运算符<code>&lt;&lt;&lt;</code>表示左结合，把右参数（闭包表达式）作为左参数（闭包表达式）的参数，并修改一下运算符之间的优先级</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">precedencegroup</span> <span class=\"title\">CombinePrecedence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">associativity</span> : <span class=\"keyword\">left</span></span><br><span class=\"line\">    <span class=\"keyword\">higherThan</span> : <span class=\"type\">LensPrecedence</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">precedencegroup</span> <span class=\"title\">LensPrecedence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">associativity</span>: <span class=\"keyword\">right</span></span><br><span class=\"line\">    <span class=\"keyword\">higherThan</span> : <span class=\"type\">AdditionPrecedence</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> <span class=\"title\">&lt;&lt;&lt;</span> : <span class=\"type\">CombinePrecedence</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">&lt;&lt;&lt;</span> &lt;<span class=\"type\">A</span>, <span class=\"type\">B</span>, <span class=\"type\">C</span>&gt; (<span class=\"params\">lhs</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">B</span>) -&gt; <span class=\"type\">C</span>, <span class=\"params\">rhs</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">A</span>) -&gt; <span class=\"type\">B</span>)</span> -&gt; (<span class=\"type\">A</span>) -&gt; <span class=\"type\">C</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; lhs(rhs(<span class=\"variable\">$0</span>)) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终调用方式如下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 线段的起始点设置为20，原点的y值设置为30</span></span><br><span class=\"line\">square <span class=\"operator\">=</span> square</span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Square</span>.lineL <span class=\"operator\">&lt;&lt;&lt;</span> <span class=\"type\">Line</span>.startL <span class=\"operator\">&lt;&lt;&lt;</span> <span class=\"type\">Point</span>.xL <span class=\"operator\">.~</span> <span class=\"number\">20</span></span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Square</span>.originL <span class=\"operator\">&lt;&lt;&lt;</span> <span class=\"type\">Point</span>.yL <span class=\"operator\">.~</span> <span class=\"number\">30</span></span><br></pre></td></tr></table></figure>\n\n<p>看起来也是十分简洁</p>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><p>仅供参考</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x : <span class=\"type\">CGFloat</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> y : <span class=\"type\">CGFloat</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Line</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> start : <span class=\"type\">Point</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> end : <span class=\"type\">Point</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> line : <span class=\"type\">Line</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> origin : <span class=\"type\">Point</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typealias</span> <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt; <span class=\"operator\">=</span> (<span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>) -&gt; <span class=\"type\">Subpart</span>) -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;(<span class=\"params\">view</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Subpart</span>, <span class=\"params\">set</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span>)</span> -&gt; <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt; &#123;</span><br><span class=\"line\"><span class=\"comment\">//    return &#123; mapper in</span></span><br><span class=\"line\"><span class=\"comment\">//        return &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            let subpart = view($0)</span></span><br><span class=\"line\"><span class=\"comment\">//            let newSubpart = mapper(subpart)</span></span><br><span class=\"line\"><span class=\"comment\">//            return set(newSubpart, $0)</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">/// 可以缩减为这种写法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; mapper <span class=\"keyword\">in</span> &#123; <span class=\"keyword\">set</span>(mapper(view(<span class=\"variable\">$0</span>)), <span class=\"variable\">$0</span>) &#125; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">over</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;(<span class=\"params\">mapper</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>) -&gt; <span class=\"type\">Subpart</span>, <span class=\"params\">lens</span>: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;)</span> -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lens(mapper)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">set</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;(<span class=\"params\">value</span>: <span class=\"type\">Subpart</span>,<span class=\"params\">lens</span>: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;)</span> -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> over( mapper: &#123; <span class=\"keyword\">_</span> <span class=\"keyword\">in</span> value &#125;, lens: lens)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">precedencegroup</span> <span class=\"title\">CombinePrecedence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">associativity</span> : <span class=\"keyword\">left</span></span><br><span class=\"line\">    <span class=\"keyword\">higherThan</span> : <span class=\"type\">LensPrecedence</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">precedencegroup</span> <span class=\"title\">LensPrecedence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">associativity</span>: <span class=\"keyword\">right</span></span><br><span class=\"line\">    <span class=\"keyword\">higherThan</span> : <span class=\"type\">AdditionPrecedence</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> <span class=\"title\">%~</span>  : <span class=\"type\">LensPrecedence</span></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> .<span class=\"title\">~</span>  : <span class=\"type\">LensPrecedence</span></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> <span class=\"title\">|&gt;</span>  : <span class=\"type\">AdditionPrecedence</span></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> <span class=\"title\">&lt;&lt;&lt;</span> : <span class=\"type\">CombinePrecedence</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">%~</span> &lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;(<span class=\"params\">lhs</span>: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;, <span class=\"params\">rhs</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>) -&gt; <span class=\"type\">Subpart</span>)</span> -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> over(mapper: rhs, lens: lhs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> </span><span class=\"operator\">.~</span> <span class=\"operator\">&lt;</span><span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span><span class=\"operator\">&gt;</span>(lhs: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;, rhs: <span class=\"type\">Subpart</span>) -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">set</span>(value: rhs, lens: lhs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">|&gt;</span> &lt;<span class=\"type\">A</span>, <span class=\"type\">B</span>&gt; (<span class=\"params\">lhs</span>: <span class=\"type\">A</span>, <span class=\"params\">rhs</span>: (<span class=\"type\">A</span>) -&gt; <span class=\"type\">B</span>)</span> -&gt; <span class=\"type\">B</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rhs(lhs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">&lt;&lt;&lt;</span> &lt;<span class=\"type\">A</span>, <span class=\"type\">B</span>, <span class=\"type\">C</span>&gt; (<span class=\"params\">lhs</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">B</span>) -&gt; <span class=\"type\">C</span>, <span class=\"params\">rhs</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">A</span>) -&gt; <span class=\"type\">B</span>)</span> -&gt; (<span class=\"type\">A</span>) -&gt; <span class=\"type\">C</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; lhs(rhs(<span class=\"variable\">$0</span>)) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> xL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">CGFloat</span>,<span class=\"type\">Point</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.x &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Point</span>(x: <span class=\"variable\">$0</span>, y: <span class=\"variable\">$1</span>.y) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> yL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">CGFloat</span>,<span class=\"type\">Point</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.y &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Point</span>(x: <span class=\"variable\">$1</span>.x, y: <span class=\"variable\">$0</span>) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Line</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> startL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">Point</span>,<span class=\"type\">Line</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.start &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Line</span>(start: <span class=\"variable\">$0</span>, end: <span class=\"variable\">$1</span>.end ) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> endL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">Point</span>,<span class=\"type\">Line</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.end &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Line</span>(start: <span class=\"variable\">$1</span>.start, end: <span class=\"variable\">$0</span>) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> lineL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">Line</span>,<span class=\"type\">Square</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.line &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Square</span>(line: <span class=\"variable\">$0</span>, origin: <span class=\"variable\">$1</span>.origin) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> originL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">Point</span>,<span class=\"type\">Square</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.origin &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Square</span>(line: <span class=\"variable\">$1</span>.line, origin: <span class=\"variable\">$0</span>) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//let xLens = Point.xL &#123; _ in 10 &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//let xLens = set(value: 10, lens: Point.xL)</span></span><br><span class=\"line\"><span class=\"comment\">//let xLens = Point.xL .~ 10</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point1 <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">point1 <span class=\"operator\">=</span> point1</span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Point</span>.xL <span class=\"operator\">.~</span> <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Point</span>.yL <span class=\"operator\">.~</span> <span class=\"number\">20</span></span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Point</span>.xL <span class=\"operator\">%~</span> &#123; <span class=\"variable\">$0</span> <span class=\"operator\">-</span> <span class=\"number\">5</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> origin <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">5</span>, y: <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> line <span class=\"operator\">=</span> <span class=\"type\">Line</span>(start: origin, end: point1)</span><br><span class=\"line\"><span class=\"keyword\">var</span> square <span class=\"operator\">=</span> <span class=\"type\">Square</span>(line: line, origin: origin)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;修改前<span class=\"subst\">\\(square)</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 线段的起始点设置为20，原点的y值设置为30</span></span><br><span class=\"line\">square <span class=\"operator\">=</span> square</span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Square</span>.lineL <span class=\"operator\">&lt;&lt;&lt;</span> <span class=\"type\">Line</span>.startL <span class=\"operator\">&lt;&lt;&lt;</span> <span class=\"type\">Point</span>.xL <span class=\"operator\">.~</span> <span class=\"number\">20</span></span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Square</span>.originL <span class=\"operator\">&lt;&lt;&lt;</span> <span class=\"type\">Point</span>.yL <span class=\"operator\">.~</span> <span class=\"number\">30</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;修改后<span class=\"subst\">\\(square)</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>Swift是实现函数式思想的一门好语言，这里简要讲述一下函数式中透镜的Swift实现</p>","more":"<h2 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h2><p>首先我们先创建一个结构体</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x : <span class=\"type\">CGFloat</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> y : <span class=\"type\">CGFloat</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> point <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">2</span>)</span><br><span class=\"line\">point.x <span class=\"operator\">=</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>一般情况下这时候会报错<code>Cannot assign to property: &#39;x&#39; is a &#39;let&#39; constant</code>，因为<code>x</code>是一个常量，所以无法修改</p>\n<p>那么有时候我们如果需要改变一个不可变的属性的值，那么一般我们会选择再创建一个对象去覆盖</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x : <span class=\"type\">CGFloat</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> y : <span class=\"type\">CGFloat</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> point <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> tempPoint <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">2</span>, y: point.y)</span><br><span class=\"line\">point <span class=\"operator\">=</span> tempPoint</span><br></pre></td></tr></table></figure>\n\n<p>但是这样子做未免显得有点麻烦，假如你觉得这样子还能接受，那么我再举个例子</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x : <span class=\"type\">CGFloat</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> y : <span class=\"type\">CGFloat</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Line</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> start : <span class=\"type\">Point</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> end : <span class=\"type\">Point</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> line : <span class=\"type\">Line</span> <span class=\"comment\">// 通过线段我们可以计算出正方形的边长</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> origin : <span class=\"type\">Point</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> start <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> end <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">10</span>, y: <span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> line <span class=\"operator\">=</span> <span class=\"type\">Line</span>(start: start, end: end)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> origin <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">5</span>, y: <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> square <span class=\"operator\">=</span> <span class=\"type\">Square</span>(line: line, origin: origin)</span><br><span class=\"line\"></span><br><span class=\"line\">square.line.start.x <span class=\"operator\">=</span> <span class=\"number\">20</span> <span class=\"comment\">// Error : Cannot assign to property: &#x27;x&#x27; is a &#x27;let&#x27; constant</span></span><br></pre></td></tr></table></figure>\n\n<p>假如这时候我们希望把<code>square.line.start.x</code>设置为20，那么按照常规的写法就显得很麻烦了，更何况实际开发中可能还存在着更深的嵌套</p>\n<h2 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h2><p>我们可以使用函数式的方案去解决上面的问题，首先我们先把问题简化，先考虑如何把<code>Point</code>的<code>x</code>属性优雅地去进行更改</p>\n<h3 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h3><p>首先我们定义一个函数签名，取名为<code>Lens</code>(透镜)</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typealias</span> <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt; <span class=\"operator\">=</span> (<span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>) -&gt; <span class=\"type\">Subpart</span>) -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span></span><br></pre></td></tr></table></figure>\n\n<p>其中<code>Subpart</code>表示要修改的属性的值，<code>Whole</code>表示被修改的这个对象</p>\n<p>整个定义的含义是</p>\n<ol>\n<li>传入闭包表达式，这个闭包表达式会带入参数，参数值为被修改的属性的当前值，比如<code>x</code>的当前值1，然后闭包表达式修改这个值之后再次返回出去。</li>\n<li>返回一个对象的闭包，这个闭包会带入参数，参数值为当前被修改的对象，闭包表达式返回一个新的对象，比如<code>Point</code></li>\n</ol>\n<p>为了方便构建一个透镜，我们再添加一个方法用于初始化一个透镜</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;(<span class=\"params\">view</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Subpart</span>, <span class=\"params\">set</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span>)</span> -&gt; <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">/// 缩减写法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; mapper <span class=\"keyword\">in</span> &#123; <span class=\"keyword\">set</span>(mapper(view(<span class=\"variable\">$0</span>)), <span class=\"variable\">$0</span>) &#125; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法传入两个参数</p>\n<ol>\n<li>闭包表达式<code>view</code>表示传入一个对象，返回这个对象要被修改的那个属性当前值，比如我们上面提到的<code>x</code>，相当于一个<code>get</code>操作</li>\n<li>闭包表达式<code>set</code>表示传入要被修改属性的新值和要被修改的对象，然后返回包含新值的属性的新对象，相当于一个<code>set</code>操作</li>\n</ol>\n<p>最后把闭包表达式返回出去就是我们所要的透镜，也可以理解为一个修改器。这个修改器内定好了哪个属性要被修改成哪个值，然后这个修改器最后返回一个闭包表达式，传入一个旧对象，返回一个带有新值的新对象</p>\n<p>如果觉得上面的缩减写法有点晦涩，那我们展开来描述</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> &#123; mapper <span class=\"keyword\">in</span> <span class=\"comment\">// mapper是用于修改属性值的一个闭包表达式</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> subpart <span class=\"operator\">=</span> view(<span class=\"variable\">$0</span>) <span class=\"comment\">// 拿到某个属性当前的值</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> newSubpart <span class=\"operator\">=</span> mapper(subpart) <span class=\"comment\">// 处理成新值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">set</span>(newSubpart, <span class=\"variable\">$0</span>) <span class=\"comment\">// 返回一个新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>接下来我们就可以用上面定义好的方法来构件我们的<code>x</code>属性透镜和<code>y</code>属性透镜</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> xL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">CGFloat</span>,<span class=\"type\">Point</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.x &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Point</span>(x: <span class=\"variable\">$0</span>, y: <span class=\"variable\">$1</span>.y) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> yL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">CGFloat</span>,<span class=\"type\">Point</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.y &#125;,\t<span class=\"comment\">// 即将要被修改的值是y</span></span><br><span class=\"line\">        set: &#123; <span class=\"type\">Point</span>(x: <span class=\"variable\">$1</span>.x, y: <span class=\"variable\">$0</span>) &#125; <span class=\"comment\">// 新值为$0，旧值</span></span><br><span class=\"line\">x依旧还是从原来对象里面取    </span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个能把x改成10的透镜</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> xLens <span class=\"operator\">=</span> <span class=\"type\">Point</span>.xL &#123; <span class=\"keyword\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">10</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> point1 <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> point2 <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">2</span>, y: <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">point1 <span class=\"operator\">=</span> xLens(point1)</span><br><span class=\"line\">point2 <span class=\"operator\">=</span> xLens(point2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(point1) <span class=\"comment\">// Point(x: 10.0, y: 1.0)</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(point2) <span class=\"comment\">// Point(x: 10.0, y: 2.0)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h3><p>但是这样子的使用方法还是不够方便，所以我们定义多两个方法封装一下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">over</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;(<span class=\"params\">mapper</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>) -&gt; <span class=\"type\">Subpart</span>, <span class=\"params\">lens</span>: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;)</span> -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lens(mapper)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">set</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;(<span class=\"params\">value</span>: <span class=\"type\">Subpart</span>,<span class=\"params\">lens</span>: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;)</span> -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> over( mapper: &#123; <span class=\"keyword\">_</span> <span class=\"keyword\">in</span> value &#125;, lens: lens)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>over</code>方法传入一个闭包表达式和一个透镜，闭包表达式参数是用来修改属性值，跟透镜结合使用，返回新对象</p>\n<p><code>set</code>方法传入一个新值和一个透镜，新值是用于构建修改属性的闭包，跟传入的透镜结合，调用<code>over</code>方法</p>\n<p>有了这两个方法，我们就可以把之前的写法进行修改</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> xLens <span class=\"operator\">=</span> <span class=\"keyword\">set</span>(value: <span class=\"number\">10</span>, lens: <span class=\"type\">Point</span>.xL) <span class=\"comment\">// 等价于下面的写法</span></span><br><span class=\"line\"><span class=\"comment\">// let xLens = Point.xL &#123; _ in 10 &#125; </span></span><br></pre></td></tr></table></figure>\n\n<p>这么一看貌似只是简单地把闭包表达式变成了函数调用，也就是花括号变成了括号而已</p>\n<p>但实际上变成了函数调用的方式之后我们就可以做更多的事情了</p>\n<p>比如说：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> <span class=\"title\">%~</span></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> .<span class=\"title\">~</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">%~</span> &lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;(<span class=\"params\">lhs</span>: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;, <span class=\"params\">rhs</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>) -&gt; <span class=\"type\">Subpart</span>)</span> -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> over(mapper: rhs, lens: lhs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> </span><span class=\"operator\">.~</span> <span class=\"operator\">&lt;</span><span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span><span class=\"operator\">&gt;</span>(lhs: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;, rhs: <span class=\"type\">Subpart</span>) -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">set</span>(value: rhs, lens: lhs)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时候我们的调用方式就变成了</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> xLens <span class=\"operator\">=</span> <span class=\"type\">Point</span>.xL <span class=\"operator\">.~</span> <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<p>还不够，再加一个定义，我们把对象的修改方式给改了</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">precedencegroup</span> <span class=\"title\">LensPrecedence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">higherThan</span> : <span class=\"type\">AdditionPrecedence</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> .<span class=\"title\">~</span> : <span class=\"type\">LensPrecedence</span></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> <span class=\"title\">%~</span> : <span class=\"type\">LensPrecedence</span></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> <span class=\"title\">|&gt;</span> : <span class=\"type\">AdditionPrecedence</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">%~</span> &lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;(<span class=\"params\">lhs</span>: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;, <span class=\"params\">rhs</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>) -&gt; <span class=\"type\">Subpart</span>)</span> -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> over(mapper: rhs, lens: lhs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> </span><span class=\"operator\">.~</span> <span class=\"operator\">&lt;</span><span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span><span class=\"operator\">&gt;</span>(lhs: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;, rhs: <span class=\"type\">Subpart</span>) -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">set</span>(value: rhs, lens: lhs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">|&gt;</span> &lt;<span class=\"type\">A</span>, <span class=\"type\">B</span>&gt; (<span class=\"params\">lhs</span>: <span class=\"type\">A</span>, <span class=\"params\">rhs</span>: (<span class=\"type\">A</span>) -&gt; <span class=\"type\">B</span>)</span> -&gt; <span class=\"type\">B</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rhs(lhs)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样子当我们想要修改一个点的x值和y值的时候，就可以这么写了</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> point <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">point <span class=\"operator\">=</span> point</span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Point</span>.xL <span class=\"operator\">.~</span> <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Point</span>.yL <span class=\"operator\">.~</span> <span class=\"number\">20</span></span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Point</span>.xL <span class=\"operator\">%~</span> &#123; <span class=\"variable\">$0</span> <span class=\"operator\">-</span> <span class=\"number\">5</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>看起来就简洁许多</p>\n<h3 id=\"复杂的情况\"><a href=\"#复杂的情况\" class=\"headerlink\" title=\"复杂的情况\"></a>复杂的情况</h3><p>那么刚才我们提及的复杂的情况，除了点之外，还出现了线和面，那应该怎么做呢</p>\n<p>同理可得，我们给线和面也添加透镜</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Line</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> startL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">Point</span>,<span class=\"type\">Line</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.start &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Line</span>(start: <span class=\"variable\">$0</span>, end: <span class=\"variable\">$1</span>.end ) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> endL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">Point</span>,<span class=\"type\">Line</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.end &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Line</span>(start: <span class=\"variable\">$1</span>.start, end: <span class=\"variable\">$0</span>) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> lineL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">Line</span>,<span class=\"type\">Square</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.line &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Square</span>(line: <span class=\"variable\">$0</span>, origin: <span class=\"variable\">$1</span>.origin) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> originL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">Point</span>,<span class=\"type\">Square</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.origin &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Square</span>(line: <span class=\"variable\">$1</span>.line, origin: <span class=\"variable\">$0</span>) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>新增一个运算符<code>&lt;&lt;&lt;</code>表示左结合，把右参数（闭包表达式）作为左参数（闭包表达式）的参数，并修改一下运算符之间的优先级</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">precedencegroup</span> <span class=\"title\">CombinePrecedence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">associativity</span> : <span class=\"keyword\">left</span></span><br><span class=\"line\">    <span class=\"keyword\">higherThan</span> : <span class=\"type\">LensPrecedence</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">precedencegroup</span> <span class=\"title\">LensPrecedence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">associativity</span>: <span class=\"keyword\">right</span></span><br><span class=\"line\">    <span class=\"keyword\">higherThan</span> : <span class=\"type\">AdditionPrecedence</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> <span class=\"title\">&lt;&lt;&lt;</span> : <span class=\"type\">CombinePrecedence</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">&lt;&lt;&lt;</span> &lt;<span class=\"type\">A</span>, <span class=\"type\">B</span>, <span class=\"type\">C</span>&gt; (<span class=\"params\">lhs</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">B</span>) -&gt; <span class=\"type\">C</span>, <span class=\"params\">rhs</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">A</span>) -&gt; <span class=\"type\">B</span>)</span> -&gt; (<span class=\"type\">A</span>) -&gt; <span class=\"type\">C</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; lhs(rhs(<span class=\"variable\">$0</span>)) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最终调用方式如下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// 线段的起始点设置为20，原点的y值设置为30</span></span><br><span class=\"line\">square <span class=\"operator\">=</span> square</span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Square</span>.lineL <span class=\"operator\">&lt;&lt;&lt;</span> <span class=\"type\">Line</span>.startL <span class=\"operator\">&lt;&lt;&lt;</span> <span class=\"type\">Point</span>.xL <span class=\"operator\">.~</span> <span class=\"number\">20</span></span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Square</span>.originL <span class=\"operator\">&lt;&lt;&lt;</span> <span class=\"type\">Point</span>.yL <span class=\"operator\">.~</span> <span class=\"number\">30</span></span><br></pre></td></tr></table></figure>\n\n<p>看起来也是十分简洁</p>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><p>仅供参考</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x : <span class=\"type\">CGFloat</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> y : <span class=\"type\">CGFloat</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Line</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> start : <span class=\"type\">Point</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> end : <span class=\"type\">Point</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> line : <span class=\"type\">Line</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> origin : <span class=\"type\">Point</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typealias</span> <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt; <span class=\"operator\">=</span> (<span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>) -&gt; <span class=\"type\">Subpart</span>) -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;(<span class=\"params\">view</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Subpart</span>, <span class=\"params\">set</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span>)</span> -&gt; <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt; &#123;</span><br><span class=\"line\"><span class=\"comment\">//    return &#123; mapper in</span></span><br><span class=\"line\"><span class=\"comment\">//        return &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            let subpart = view($0)</span></span><br><span class=\"line\"><span class=\"comment\">//            let newSubpart = mapper(subpart)</span></span><br><span class=\"line\"><span class=\"comment\">//            return set(newSubpart, $0)</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">/// 可以缩减为这种写法</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; mapper <span class=\"keyword\">in</span> &#123; <span class=\"keyword\">set</span>(mapper(view(<span class=\"variable\">$0</span>)), <span class=\"variable\">$0</span>) &#125; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">over</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;(<span class=\"params\">mapper</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>) -&gt; <span class=\"type\">Subpart</span>, <span class=\"params\">lens</span>: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;)</span> -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lens(mapper)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">set</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;(<span class=\"params\">value</span>: <span class=\"type\">Subpart</span>,<span class=\"params\">lens</span>: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>,<span class=\"type\">Whole</span>&gt;)</span> -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> over( mapper: &#123; <span class=\"keyword\">_</span> <span class=\"keyword\">in</span> value &#125;, lens: lens)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">precedencegroup</span> <span class=\"title\">CombinePrecedence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">associativity</span> : <span class=\"keyword\">left</span></span><br><span class=\"line\">    <span class=\"keyword\">higherThan</span> : <span class=\"type\">LensPrecedence</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">precedencegroup</span> <span class=\"title\">LensPrecedence</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">associativity</span>: <span class=\"keyword\">right</span></span><br><span class=\"line\">    <span class=\"keyword\">higherThan</span> : <span class=\"type\">AdditionPrecedence</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> <span class=\"title\">%~</span>  : <span class=\"type\">LensPrecedence</span></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> .<span class=\"title\">~</span>  : <span class=\"type\">LensPrecedence</span></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> <span class=\"title\">|&gt;</span>  : <span class=\"type\">AdditionPrecedence</span></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> <span class=\"title\">&lt;&lt;&lt;</span> : <span class=\"type\">CombinePrecedence</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">%~</span> &lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;(<span class=\"params\">lhs</span>: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;, <span class=\"params\">rhs</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">Subpart</span>) -&gt; <span class=\"type\">Subpart</span>)</span> -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> over(mapper: rhs, lens: lhs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> </span><span class=\"operator\">.~</span> <span class=\"operator\">&lt;</span><span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span><span class=\"operator\">&gt;</span>(lhs: <span class=\"type\">Lens</span>&lt;<span class=\"type\">Subpart</span>, <span class=\"type\">Whole</span>&gt;, rhs: <span class=\"type\">Subpart</span>) -&gt; (<span class=\"type\">Whole</span>) -&gt; <span class=\"type\">Whole</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">set</span>(value: rhs, lens: lhs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">|&gt;</span> &lt;<span class=\"type\">A</span>, <span class=\"type\">B</span>&gt; (<span class=\"params\">lhs</span>: <span class=\"type\">A</span>, <span class=\"params\">rhs</span>: (<span class=\"type\">A</span>) -&gt; <span class=\"type\">B</span>)</span> -&gt; <span class=\"type\">B</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rhs(lhs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">&lt;&lt;&lt;</span> &lt;<span class=\"type\">A</span>, <span class=\"type\">B</span>, <span class=\"type\">C</span>&gt; (<span class=\"params\">lhs</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">B</span>) -&gt; <span class=\"type\">C</span>, <span class=\"params\">rhs</span>: <span class=\"keyword\">@escaping</span> (<span class=\"type\">A</span>) -&gt; <span class=\"type\">B</span>)</span> -&gt; (<span class=\"type\">A</span>) -&gt; <span class=\"type\">C</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; lhs(rhs(<span class=\"variable\">$0</span>)) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> xL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">CGFloat</span>,<span class=\"type\">Point</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.x &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Point</span>(x: <span class=\"variable\">$0</span>, y: <span class=\"variable\">$1</span>.y) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> yL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">CGFloat</span>,<span class=\"type\">Point</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.y &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Point</span>(x: <span class=\"variable\">$1</span>.x, y: <span class=\"variable\">$0</span>) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Line</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> startL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">Point</span>,<span class=\"type\">Line</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.start &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Line</span>(start: <span class=\"variable\">$0</span>, end: <span class=\"variable\">$1</span>.end ) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> endL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">Point</span>,<span class=\"type\">Line</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.end &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Line</span>(start: <span class=\"variable\">$1</span>.start, end: <span class=\"variable\">$0</span>) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> lineL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">Line</span>,<span class=\"type\">Square</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.line &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Square</span>(line: <span class=\"variable\">$0</span>, origin: <span class=\"variable\">$1</span>.origin) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> originL : <span class=\"type\">Lens</span>&lt;<span class=\"type\">Point</span>,<span class=\"type\">Square</span>&gt; <span class=\"operator\">=</span> lens(</span><br><span class=\"line\">        view: &#123; <span class=\"variable\">$0</span>.origin &#125;,</span><br><span class=\"line\">        set: &#123; <span class=\"type\">Square</span>(line: <span class=\"variable\">$1</span>.line, origin: <span class=\"variable\">$0</span>) &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//let xLens = Point.xL &#123; _ in 10 &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//let xLens = set(value: 10, lens: Point.xL)</span></span><br><span class=\"line\"><span class=\"comment\">//let xLens = Point.xL .~ 10</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> point1 <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">point1 <span class=\"operator\">=</span> point1</span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Point</span>.xL <span class=\"operator\">.~</span> <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Point</span>.yL <span class=\"operator\">.~</span> <span class=\"number\">20</span></span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Point</span>.xL <span class=\"operator\">%~</span> &#123; <span class=\"variable\">$0</span> <span class=\"operator\">-</span> <span class=\"number\">5</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> origin <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x: <span class=\"number\">5</span>, y: <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> line <span class=\"operator\">=</span> <span class=\"type\">Line</span>(start: origin, end: point1)</span><br><span class=\"line\"><span class=\"keyword\">var</span> square <span class=\"operator\">=</span> <span class=\"type\">Square</span>(line: line, origin: origin)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;修改前<span class=\"subst\">\\(square)</span>&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 线段的起始点设置为20，原点的y值设置为30</span></span><br><span class=\"line\">square <span class=\"operator\">=</span> square</span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Square</span>.lineL <span class=\"operator\">&lt;&lt;&lt;</span> <span class=\"type\">Line</span>.startL <span class=\"operator\">&lt;&lt;&lt;</span> <span class=\"type\">Point</span>.xL <span class=\"operator\">.~</span> <span class=\"number\">20</span></span><br><span class=\"line\">    <span class=\"operator\">|&gt;</span> <span class=\"type\">Square</span>.originL <span class=\"operator\">&lt;&lt;&lt;</span> <span class=\"type\">Point</span>.yL <span class=\"operator\">.~</span> <span class=\"number\">30</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;修改后<span class=\"subst\">\\(square)</span>&quot;</span>)</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckqqxyogf0001tnn0b2nv418n","category_id":"ckqqxyogl0004tnn034kk191r","_id":"ckqqxyogr000ftnn0dyfz9gm3"},{"post_id":"ckqqxyogq000dtnn0c0ktgjqv","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyogt000ltnn07f7b90xi"},{"post_id":"ckqqxyogj0003tnn06gp563wn","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyogv000qtnn0g365drrg"},{"post_id":"ckqqxyogr000etnn0f9a7a4js","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyogw000ttnn028hu9bdt"},{"post_id":"ckqqxyogs000itnn00hpn8zx4","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyogw000ytnn07bmubwga"},{"post_id":"ckqqxyogn0007tnn0acse7ubp","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyogx0011tnn06gzqas72"},{"post_id":"ckqqxyogu000ptnn07wf4akn8","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyogy0015tnn0av73421b"},{"post_id":"ckqqxyogn0008tnn0c8w3flnp","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoh00018tnn08olz4oc2"},{"post_id":"ckqqxyogv000stnn00vno3fu6","category_id":"ckqqxyogl0004tnn034kk191r","_id":"ckqqxyoh1001dtnn08j1z2jgj"},{"post_id":"ckqqxyogo0009tnn07mrg5b7g","category_id":"ckqqxyogw000utnn07d4vff0u","_id":"ckqqxyoh2001gtnn0bk4bay34"},{"post_id":"ckqqxyogx0010tnn0gt084ulv","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoh2001itnn04lq7b2bd"},{"post_id":"ckqqxyogt000ktnn0h187f7yp","category_id":"ckqqxyogx0012tnn0hwhghjqd","_id":"ckqqxyoh3001ntnn03ewdg03w"},{"post_id":"ckqqxyogy0017tnn015rwbcnc","category_id":"ckqqxyogx0012tnn0hwhghjqd","_id":"ckqqxyoh4001qtnn0cwpj73bf"},{"post_id":"ckqqxyoh1001ctnn008bs0f2m","category_id":"ckqqxyogl0004tnn034kk191r","_id":"ckqqxyoh4001utnn06bo789pq"},{"post_id":"ckqqxyoh2001ftnn0gbeyag74","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoh5001wtnn0ao99gk5s"},{"post_id":"ckqqxyogw000xtnn0f8852l16","category_id":"ckqqxyoh0001atnn0h1b988r8","_id":"ckqqxyoh70020tnn04w8q2sfr"},{"post_id":"ckqqxyogy0014tnn07vm3cipf","category_id":"ckqqxyoh2001jtnn0177g9wjl","_id":"ckqqxyoh80023tnn0cxbvf07d"},{"post_id":"ckqqxyoh5001vtnn0g4uwelg1","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohb0028tnn0f41g42yi"},{"post_id":"ckqqxyoh3001mtnn095qq76x2","category_id":"ckqqxyoh4001stnn0hjk53tpy","_id":"ckqqxyohc002btnn00a6v6q94"},{"post_id":"ckqqxyoh5001ytnn01da2bid7","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohc002etnn05wwi9n2j"},{"post_id":"ckqqxyoh70022tnn0cmyef2fa","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohg002itnn05br8g2ss"},{"post_id":"ckqqxyoh3001ptnn0attgf3gr","category_id":"ckqqxyoh4001stnn0hjk53tpy","_id":"ckqqxyohh002ltnn04mmu1j6o"},{"post_id":"ckqqxyoh90026tnn07ussagl8","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohi002ptnn07bd40nzr"},{"post_id":"ckqqxyoh4001ttnn0d3f746sh","category_id":"ckqqxyoh4001stnn0hjk53tpy","_id":"ckqqxyohk002rtnn0h51e5jti"},{"post_id":"ckqqxyohc002dtnn0ay2v2fdh","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohl002utnn0586hcw1x"},{"post_id":"ckqqxyohd002htnn04dmh8pc7","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohm002ytnn051jhdcj0"},{"post_id":"ckqqxyohg002ktnn0d2aueal2","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohm0032tnn026srghxs"},{"post_id":"ckqqxyohh002otnn0hpaweqvy","category_id":"ckqqxyogl0004tnn034kk191r","_id":"ckqqxyohn0035tnn0hwa3c1tl"},{"post_id":"ckqqxyohl002ttnn063cnbrsz","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohn0038tnn00geh8lgd"},{"post_id":"ckqqxyohl002xtnn06z939abq","category_id":"ckqqxyogl0004tnn034kk191r","_id":"ckqqxyoho003ctnn00nau8jzn"},{"post_id":"ckqqxyohm0031tnn02d03708i","category_id":"ckqqxyogl0004tnn034kk191r","_id":"ckqqxyoho003ftnn0cpscezoq"},{"post_id":"ckqqxyohi002qtnn039qp2io0","category_id":"ckqqxyohl002wtnn08onpakbq","_id":"ckqqxyohp003jtnn0eza3236x"},{"post_id":"ckqqxyohn0034tnn014k5728x","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohq003ntnn0fth7g54v"},{"post_id":"ckqqxyohn0037tnn03f6jbgkd","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohq003qtnn0bzdqf22s"},{"post_id":"ckqqxyoho003btnn0fboba6qb","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohr003ttnn00559dmob"},{"post_id":"ckqqxyohp003itnn043c0ggci","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohu003wtnn0dibqau09"},{"post_id":"ckqqxyohp003mtnn049tf7vsv","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohv003ztnn0hxqido7e"},{"post_id":"ckqqxyohq003ptnn05aeb7vlm","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohw0042tnn03wcxc9r8"},{"post_id":"ckqqxyoho003etnn0hmtpd2k5","category_id":"ckqqxyohp003ktnn073xcbrc6","_id":"ckqqxyohw0045tnn0frhs9jug"},{"post_id":"ckqqxyohr003stnn0f6k97aek","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohx0048tnn00d6hh0l8"},{"post_id":"ckqqxyohr003vtnn05kkt015b","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohx004btnn058rq1dq1"},{"post_id":"ckqqxyohv003ytnn042xy5bof","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohy004etnn02i6r05l8"},{"post_id":"ckqqxyohv0041tnn0hdvo7pwg","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohy004itnn0fscgehp4"},{"post_id":"ckqqxyohw0044tnn00bv39b3e","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohz004ltnn0dgq7cpue"},{"post_id":"ckqqxyohw0047tnn0gakldndt","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyohz004ptnn0h6rrhfdt"},{"post_id":"ckqqxyohx004atnn038dg54nn","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoi0004stnn076ik20u8"},{"post_id":"ckqqxyohx004dtnn02b52h5x3","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoi1004wtnn0c0o22k4t"},{"post_id":"ckqqxyohy004htnn0b7ai38ue","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoi3004ztnn0d8l48phw"},{"post_id":"ckqqxyohz004ktnn0ajxq3ctq","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoi60053tnn0e03d40uu"},{"post_id":"ckqqxyohz004otnn07dej3062","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoi60056tnn0flv2f4eq"},{"post_id":"ckqqxyoi0004rtnn0blie7dp2","category_id":"ckqqxyogl0004tnn034kk191r","_id":"ckqqxyoi7005atnn073t60df4"},{"post_id":"ckqqxyoi1004vtnn02m1w5tla","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoi7005dtnn099u09lir"},{"post_id":"ckqqxyoi1004ytnn0eb5sbe7a","category_id":"ckqqxyogl0004tnn034kk191r","_id":"ckqqxyoi9005htnn08u4hagj2"},{"post_id":"ckqqxyoi40052tnn019fwcgbn","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoid005ktnn01f1kdab3"},{"post_id":"ckqqxyoi60055tnn0a8khelqm","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoig005otnn0c4763p7d"},{"post_id":"ckqqxyoi60059tnn0ds11glbj","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoig005rtnn02s292pbm"},{"post_id":"ckqqxyoi7005ctnn07sg47uee","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoih005vtnn0be8q4lfx"},{"post_id":"ckqqxyoi8005gtnn021fhfiy8","category_id":"ckqqxyohp003ktnn073xcbrc6","_id":"ckqqxyoih005ytnn0200z5436"},{"post_id":"ckqqxyoia005jtnn0bypy3hkb","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoii0062tnn072u9axwf"},{"post_id":"ckqqxyoif005ntnn0fldog9fi","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoim0066tnn068bkfp3j"},{"post_id":"ckqqxyoig005qtnn08hrfcqjl","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoin0069tnn0elye0qr5"},{"post_id":"ckqqxyoih005utnn03h5ectep","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoin006dtnn0dsehe1hh"},{"post_id":"ckqqxyoii0061tnn0ctnu9e47","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoio006gtnn0etmegsbf"},{"post_id":"ckqqxyoil0065tnn020pwci50","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoio006ktnn0h313aqjq"},{"post_id":"ckqqxyoim0068tnn085it1xbg","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoip006ntnn02tclfb8m"},{"post_id":"ckqqxyoih005xtnn098ld86ow","category_id":"ckqqxyoii0064tnn0dssn33kw","_id":"ckqqxyoip006rtnn01r341bh0"},{"post_id":"ckqqxyoin006ctnn05io48e0z","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoiq006utnn00esl84us"},{"post_id":"ckqqxyoio006ftnn0dixn8l2f","category_id":"ckqqxyoii0064tnn0dssn33kw","_id":"ckqqxyoir006ztnn04dyn51c8"},{"post_id":"ckqqxyoio006jtnn0gj6p776i","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoir0072tnn0ctd5c61x"},{"post_id":"ckqqxyoip006mtnn0c7shamh4","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoiv0076tnn06g0h383h"},{"post_id":"ckqqxyoiq006ttnn0cbtpen41","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoiv0079tnn07ip3fo9s"},{"post_id":"ckqqxyoiq006ytnn06gwz8qs3","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoiw007ctnn0bcx9d8kw"},{"post_id":"ckqqxyoir0071tnn0fyq74sb2","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoix007gtnn01cfbfzfd"},{"post_id":"ckqqxyoip006qtnn022cth5j0","category_id":"ckqqxyoiq006xtnn05ihlamjg","_id":"ckqqxyoiy007jtnn0ai8wetvs"},{"post_id":"ckqqxyoiu0075tnn07j1ga5y5","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoj2007ntnn0dwo7fm78"},{"post_id":"ckqqxyoiv0078tnn0a33wc7dt","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoj3007qtnn02rh38z69"},{"post_id":"ckqqxyoiw007btnn088p33ub3","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyoja007utnn075r7cio0"},{"post_id":"ckqqxyoix007ftnn068fh91te","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyojf007xtnn0bpcpdfej"},{"post_id":"ckqqxyoix007itnn03v0d14ba","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyojg0082tnn02xan2ogp"},{"post_id":"ckqqxyoiy007mtnn0c5o46pee","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyojg0085tnn0f3us4tpe"},{"post_id":"ckqqxyoj3007ptnn046j6hvdg","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyojh0088tnn01zuq2ckl"},{"post_id":"ckqqxyoja007wtnn0ccv7g11t","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyojh008atnn03oa4g943"},{"post_id":"ckqqxyojg0084tnn0a6mzffu5","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckqqxyojh008dtnn085h6dvsa"},{"post_id":"ckqqxyoj6007ttnn0hqkncvze","category_id":"ckqqxyojf0080tnn0hf5jf86p","_id":"ckqqxyojh008ftnn0frii52lk"},{"post_id":"ckr7wtb4d00004an03rmc3pfa","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckr7wtjyz00034an01cdmfeo7"},{"post_id":"ckr8kf53y000066n0gqc05jiv","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckr8kfe2h000366n043cy665v"},{"post_id":"ckrdjtzhk00009dn0akhp1lol","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckrjbxf6a0002a1n0b7e2dnmt"},{"post_id":"ckrp49yyd0000men04pnq2trc","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckrp4aqd60003men0fwby0ml8"},{"post_id":"ckrqejbaa0000i0n043mvdn10","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckrqejlzb0003i0n0gz847l1j"},{"post_id":"cksorgkyu0000zgn09atnckc8","category_id":"ckqqxyogo000atnn07g1s383m","_id":"cksorhkqw0002zgn08z7qb1wp"},{"post_id":"cksxcg3ow0002h7n0006mhqfz","category_id":"ckqqxyoii0064tnn0dssn33kw","_id":"cksxcg3oz0005h7n0f3b494wg"},{"post_id":"ckt0amz050000xon0a1gfciqu","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckt0amz0e0003xon065v2gytw"},{"post_id":"cksxcg3ou0001h7n076w99zcd","category_id":"ckqqxyogo000atnn07g1s383m","_id":"ckt0amz0e0005xon025p2eamc"},{"post_id":"cktr8vw9c000042n0f23cgp8c","category_id":"ckqqxyogo000atnn07g1s383m","_id":"cktr8vw9i000342n06omlc7ym"}],"PostTag":[{"post_id":"ckqqxyogf0001tnn0b2nv418n","tag_id":"ckqqxyogm0005tnn0547h6exs","_id":"ckqqxyogq000ctnn05czq1asc"},{"post_id":"ckqqxyogr000etnn0f9a7a4js","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyogt000jtnn07kwdg2ij"},{"post_id":"ckqqxyogs000itnn00hpn8zx4","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyogu000otnn09jmubg9t"},{"post_id":"ckqqxyogj0003tnn06gp563wn","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyogv000rtnn02pla744c"},{"post_id":"ckqqxyogj0003tnn06gp563wn","tag_id":"ckqqxyogr000htnn01mxc32eu","_id":"ckqqxyogw000wtnn0f01z7aq4"},{"post_id":"ckqqxyogn0007tnn0acse7ubp","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyogx000ztnn0hvkea17p"},{"post_id":"ckqqxyogn0008tnn0c8w3flnp","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyogy0016tnn0bdlw06go"},{"post_id":"ckqqxyogx0010tnn0gt084ulv","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoh00019tnn0cu6o2qo1"},{"post_id":"ckqqxyogo0009tnn07mrg5b7g","tag_id":"ckqqxyogx0013tnn09qa3avlv","_id":"ckqqxyoh1001etnn09btsfnx8"},{"post_id":"ckqqxyogq000dtnn0c0ktgjqv","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoh3001ltnn06d625hjq"},{"post_id":"ckqqxyogq000dtnn0c0ktgjqv","tag_id":"ckqqxyoh0001btnn06fl1c5m9","_id":"ckqqxyoh3001otnn09j6k3quh"},{"post_id":"ckqqxyogt000ktnn0h187f7yp","tag_id":"ckqqxyoh3001ktnn0agvpgixa","_id":"ckqqxyoh70021tnn0ht0h96xh"},{"post_id":"ckqqxyogt000ktnn0h187f7yp","tag_id":"ckqqxyoh4001rtnn06och8kss","_id":"ckqqxyoh80024tnn0ggky3ebr"},{"post_id":"ckqqxyoh5001vtnn0g4uwelg1","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyohb0029tnn0efp5ggt8"},{"post_id":"ckqqxyoh5001ytnn01da2bid7","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyohc002ctnn07zksdnx2"},{"post_id":"ckqqxyoh90026tnn07ussagl8","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyohd002gtnn0gqtjfgii"},{"post_id":"ckqqxyohc002dtnn0ay2v2fdh","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyohg002jtnn09yt0g9zb"},{"post_id":"ckqqxyohd002htnn04dmh8pc7","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyohh002ntnn06mp82ls5"},{"post_id":"ckqqxyogu000ptnn07wf4akn8","tag_id":"ckqqxyoh5001xtnn03s36cmsq","_id":"ckqqxyohl002vtnn02zkj2l1r"},{"post_id":"ckqqxyogu000ptnn07wf4akn8","tag_id":"ckqqxyoh80025tnn07nim36k6","_id":"ckqqxyohm002ztnn07stz2n66"},{"post_id":"ckqqxyogu000ptnn07wf4akn8","tag_id":"ckqqxyohd002ftnn04dejb48g","_id":"ckqqxyohn0033tnn05k7rbucp"},{"post_id":"ckqqxyogu000ptnn07wf4akn8","tag_id":"ckqqxyohh002mtnn0hcjvb6wg","_id":"ckqqxyohn0036tnn0hsui25ql"},{"post_id":"ckqqxyogv000stnn00vno3fu6","tag_id":"ckqqxyohk002stnn0dobg6wh0","_id":"ckqqxyoho003atnn06n5i73c4"},{"post_id":"ckqqxyogv000stnn00vno3fu6","tag_id":"ckqqxyohm0030tnn02m5p5uil","_id":"ckqqxyoho003dtnn0hy4rg5mp"},{"post_id":"ckqqxyohn0037tnn03f6jbgkd","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyohp003htnn0bakkf2vk"},{"post_id":"ckqqxyogw000xtnn0f8852l16","tag_id":"ckqqxyohn0039tnn0aia6acot","_id":"ckqqxyohp003ltnn09kiv08ow"},{"post_id":"ckqqxyogy0014tnn07vm3cipf","tag_id":"ckqqxyoh5001xtnn03s36cmsq","_id":"ckqqxyohq003rtnn09c81cyo0"},{"post_id":"ckqqxyogy0017tnn015rwbcnc","tag_id":"ckqqxyoh3001ktnn0agvpgixa","_id":"ckqqxyohu003xtnn04mcf69x9"},{"post_id":"ckqqxyoh1001ctnn008bs0f2m","tag_id":"ckqqxyohr003utnn0d26ue0qm","_id":"ckqqxyohw0043tnn05jdo9klg"},{"post_id":"ckqqxyoh2001ftnn0gbeyag74","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyohx0049tnn046dp5iny"},{"post_id":"ckqqxyoh2001ftnn0gbeyag74","tag_id":"ckqqxyohv0040tnn0ci9aal6u","_id":"ckqqxyohx004ctnn02vqv6815"},{"post_id":"ckqqxyohw0044tnn00bv39b3e","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyohy004gtnn0bdsi06n1"},{"post_id":"ckqqxyohw0047tnn0gakldndt","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyohy004jtnn0f4fw7j8p"},{"post_id":"ckqqxyoh2001htnn05bkq68fa","tag_id":"ckqqxyohw0046tnn06ahwdslv","_id":"ckqqxyohz004ntnn0e5wr9gdl"},{"post_id":"ckqqxyohy004htnn0b7ai38ue","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoi0004qtnn0g1be45aq"},{"post_id":"ckqqxyoh3001mtnn095qq76x2","tag_id":"ckqqxyohw0046tnn06ahwdslv","_id":"ckqqxyoi0004utnn0er5y8h9c"},{"post_id":"ckqqxyoh3001mtnn095qq76x2","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoi1004xtnn0cdbtdgqn"},{"post_id":"ckqqxyohz004ktnn0ajxq3ctq","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoi40051tnn0fesw858g"},{"post_id":"ckqqxyoh3001ptnn0attgf3gr","tag_id":"ckqqxyohw0046tnn06ahwdslv","_id":"ckqqxyoi60054tnn01o3hb6vg"},{"post_id":"ckqqxyoi0004rtnn0blie7dp2","tag_id":"ckqqxyohr003utnn0d26ue0qm","_id":"ckqqxyoi60058tnn0a3hzfwll"},{"post_id":"ckqqxyoi1004vtnn02m1w5tla","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoi7005btnn0dqqtd1gg"},{"post_id":"ckqqxyoh4001ttnn0d3f746sh","tag_id":"ckqqxyohw0046tnn06ahwdslv","_id":"ckqqxyoi8005ftnn0hzp71mlw"},{"post_id":"ckqqxyoh70022tnn0cmyef2fa","tag_id":"ckqqxyoi40050tnn04krjdbi5","_id":"ckqqxyoia005itnn08no7b55o"},{"post_id":"ckqqxyoi60055tnn0a8khelqm","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoif005mtnn09vtt6ih8"},{"post_id":"ckqqxyohg002ktnn0d2aueal2","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoig005ptnn05hplgyqg"},{"post_id":"ckqqxyohg002ktnn0d2aueal2","tag_id":"ckqqxyohv0040tnn0ci9aal6u","_id":"ckqqxyoig005ttnn0dgw66k22"},{"post_id":"ckqqxyoi7005ctnn07sg47uee","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoih005wtnn0afmy4z7v"},{"post_id":"ckqqxyohh002otnn0hpaweqvy","tag_id":"ckqqxyohm0030tnn02m5p5uil","_id":"ckqqxyoih005ztnn0cumj39v3"},{"post_id":"ckqqxyoia005jtnn0bypy3hkb","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoii0063tnn022mqc99v"},{"post_id":"ckqqxyoif005ntnn0fldog9fi","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoim0067tnn0futrckv7"},{"post_id":"ckqqxyoif005ntnn0fldog9fi","tag_id":"ckqqxyohv0040tnn0ci9aal6u","_id":"ckqqxyoin006btnn09glv5cgs"},{"post_id":"ckqqxyohi002qtnn039qp2io0","tag_id":"ckqqxyoid005ltnn02hckdx0d","_id":"ckqqxyoio006etnn06pz9fwge"},{"post_id":"ckqqxyoig005qtnn08hrfcqjl","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoio006itnn01arn5267"},{"post_id":"ckqqxyoig005qtnn08hrfcqjl","tag_id":"ckqqxyoh0001btnn06fl1c5m9","_id":"ckqqxyoip006ltnn0gh9ehw38"},{"post_id":"ckqqxyoih005utnn03h5ectep","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoip006ptnn09yatd2bs"},{"post_id":"ckqqxyoih005utnn03h5ectep","tag_id":"ckqqxyogr000htnn01mxc32eu","_id":"ckqqxyoiq006stnn07xghhvgu"},{"post_id":"ckqqxyohl002ttnn063cnbrsz","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoiq006wtnn09y2p33c8"},{"post_id":"ckqqxyohl002ttnn063cnbrsz","tag_id":"ckqqxyoig005stnn0762abdpw","_id":"ckqqxyoir0070tnn07pa549od"},{"post_id":"ckqqxyoii0061tnn0ctnu9e47","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyois0073tnn0hnw002hv"},{"post_id":"ckqqxyoil0065tnn020pwci50","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoiv0077tnn06wwd01e3"},{"post_id":"ckqqxyohl002xtnn06z939abq","tag_id":"ckqqxyoih0060tnn0h21l44es","_id":"ckqqxyoiw007atnn0ddcocyo0"},{"post_id":"ckqqxyoim0068tnn085it1xbg","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoix007etnn09xy93k5q"},{"post_id":"ckqqxyoin006ctnn05io48e0z","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoix007htnn0e0k4g7je"},{"post_id":"ckqqxyohm0031tnn02d03708i","tag_id":"ckqqxyoin006atnn01qt8asx7","_id":"ckqqxyoiy007ltnn081i00f17"},{"post_id":"ckqqxyoio006jtnn0gj6p776i","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoj2007otnn0cyvyd2vm"},{"post_id":"ckqqxyohn0034tnn014k5728x","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoj6007stnn0bvoles4u"},{"post_id":"ckqqxyohn0034tnn014k5728x","tag_id":"ckqqxyoio006htnn0hehl44ce","_id":"ckqqxyoja007vtnn02i1e7c43"},{"post_id":"ckqqxyoip006mtnn0c7shamh4","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojf007ztnn07k8j6yq8"},{"post_id":"ckqqxyoip006mtnn0c7shamh4","tag_id":"ckqqxyogr000htnn01mxc32eu","_id":"ckqqxyojg0083tnn03c2zdoob"},{"post_id":"ckqqxyoho003btnn0fboba6qb","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojh0087tnn0g6au5gte"},{"post_id":"ckqqxyoho003btnn0fboba6qb","tag_id":"ckqqxyoio006htnn0hehl44ce","_id":"ckqqxyojh0089tnn06rpgavf2"},{"post_id":"ckqqxyoiq006ytnn06gwz8qs3","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojh008ctnn0cbraeg48"},{"post_id":"ckqqxyoir0071tnn0fyq74sb2","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojh008etnn06f2i6hdl"},{"post_id":"ckqqxyoir0071tnn0fyq74sb2","tag_id":"ckqqxyoh0001btnn06fl1c5m9","_id":"ckqqxyojh008htnn0acbg15gt"},{"post_id":"ckqqxyoiu0075tnn07j1ga5y5","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojh008itnn0hbrd6l0x"},{"post_id":"ckqqxyoiv0078tnn0a33wc7dt","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoji008ktnn0emou46t4"},{"post_id":"ckqqxyoho003etnn0hmtpd2k5","tag_id":"ckqqxyoiq006vtnn0ha3cb98y","_id":"ckqqxyoji008ltnn0h50a433o"},{"post_id":"ckqqxyoho003etnn0hmtpd2k5","tag_id":"ckqqxyoit0074tnn00qms0tzr","_id":"ckqqxyoji008ntnn07b0p8zn9"},{"post_id":"ckqqxyoiw007btnn088p33ub3","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoji008otnn0b9ejagps"},{"post_id":"ckqqxyoix007ftnn068fh91te","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyoji008qtnn0bsow5hqi"},{"post_id":"ckqqxyohp003itnn043c0ggci","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojj008rtnn0c2vigsk7"},{"post_id":"ckqqxyohp003itnn043c0ggci","tag_id":"ckqqxyoio006htnn0hehl44ce","_id":"ckqqxyojj008ttnn01l8a1guu"},{"post_id":"ckqqxyoix007itnn03v0d14ba","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojj008utnn08qnhg55f"},{"post_id":"ckqqxyoiy007mtnn0c5o46pee","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojj008vtnn01qdl4dxh"},{"post_id":"ckqqxyohp003mtnn049tf7vsv","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojn008xtnn0bfb23ju7"},{"post_id":"ckqqxyohp003mtnn049tf7vsv","tag_id":"ckqqxyoio006htnn0hehl44ce","_id":"ckqqxyojn008ytnn078gn3in7"},{"post_id":"ckqqxyoj3007ptnn046j6hvdg","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojn0090tnn0b4cta7jc"},{"post_id":"ckqqxyohq003ptnn05aeb7vlm","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojn0091tnn0azni805d"},{"post_id":"ckqqxyohq003ptnn05aeb7vlm","tag_id":"ckqqxyoio006htnn0hehl44ce","_id":"ckqqxyojo0093tnn01v6og778"},{"post_id":"ckqqxyoja007wtnn0ccv7g11t","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojo0094tnn0863gc2lw"},{"post_id":"ckqqxyojg0081tnn0bxxt93zl","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojo0096tnn01qe9b7ts"},{"post_id":"ckqqxyohr003stnn0f6k97aek","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojo0097tnn0gs0ed5bg"},{"post_id":"ckqqxyohr003stnn0f6k97aek","tag_id":"ckqqxyoio006htnn0hehl44ce","_id":"ckqqxyojo0098tnn0gb5edxei"},{"post_id":"ckqqxyojg0084tnn0a6mzffu5","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojo009atnn0dr5v5zg9"},{"post_id":"ckqqxyohr003vtnn05kkt015b","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojo009btnn0eg359cvm"},{"post_id":"ckqqxyohr003vtnn05kkt015b","tag_id":"ckqqxyoio006htnn0hehl44ce","_id":"ckqqxyojo009dtnn0525ocxve"},{"post_id":"ckqqxyohv003ytnn042xy5bof","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojo009etnn05axuhng7"},{"post_id":"ckqqxyohv003ytnn042xy5bof","tag_id":"ckqqxyojh008btnn00awd482g","_id":"ckqqxyojo009gtnn04txq1zqc"},{"post_id":"ckqqxyohv0041tnn0hdvo7pwg","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojo009htnn01h9o3fhz"},{"post_id":"ckqqxyohv0041tnn0hdvo7pwg","tag_id":"ckqqxyojh008btnn00awd482g","_id":"ckqqxyojo009jtnn0hmundzea"},{"post_id":"ckqqxyohx004atnn038dg54nn","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojo009ktnn0957tbmur"},{"post_id":"ckqqxyohx004atnn038dg54nn","tag_id":"ckqqxyojh008btnn00awd482g","_id":"ckqqxyojo009ltnn0gz4ndbz1"},{"post_id":"ckqqxyohx004dtnn02b52h5x3","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojp009ntnn01eab22ig"},{"post_id":"ckqqxyohx004dtnn02b52h5x3","tag_id":"ckqqxyoji008mtnn087541skj","_id":"ckqqxyojp009otnn02s86a2i1"},{"post_id":"ckqqxyohz004otnn07dej3062","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojp009qtnn00aul9ue5"},{"post_id":"ckqqxyohz004otnn07dej3062","tag_id":"ckqqxyoio006htnn0hehl44ce","_id":"ckqqxyojp009rtnn0advs41ms"},{"post_id":"ckqqxyoi1004ytnn0eb5sbe7a","tag_id":"ckqqxyojj008stnn0f5657gbe","_id":"ckqqxyojp009ttnn0aikn16m4"},{"post_id":"ckqqxyoi40052tnn019fwcgbn","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojp009utnn09tj7br1d"},{"post_id":"ckqqxyoi40052tnn019fwcgbn","tag_id":"ckqqxyohd002ftnn04dejb48g","_id":"ckqqxyojp009vtnn066lbfkv1"},{"post_id":"ckqqxyoi40052tnn019fwcgbn","tag_id":"ckqqxyojl008wtnn0ebc2ezja","_id":"ckqqxyojp009wtnn03ctmfnge"},{"post_id":"ckqqxyoi60059tnn0ds11glbj","tag_id":"ckqqxyohh002mtnn0hcjvb6wg","_id":"ckqqxyojq009xtnn0fihsdtd7"},{"post_id":"ckqqxyoi60059tnn0ds11glbj","tag_id":"ckqqxyojn008ztnn027lb1uua","_id":"ckqqxyojq009ytnn066qgerw1"},{"post_id":"ckqqxyoi8005gtnn021fhfiy8","tag_id":"ckqqxyojn0092tnn02g51bsal","_id":"ckqqxyojq009ztnn00pmb04yc"},{"post_id":"ckqqxyoi8005gtnn021fhfiy8","tag_id":"ckqqxyojo0095tnn03ma294iv","_id":"ckqqxyojq00a0tnn0gweqcxor"},{"post_id":"ckqqxyoih005xtnn098ld86ow","tag_id":"ckqqxyohw0046tnn06ahwdslv","_id":"ckqqxyojq00a1tnn0gnzib2x9"},{"post_id":"ckqqxyoih005xtnn098ld86ow","tag_id":"ckqqxyojo0099tnn05plpdbqz","_id":"ckqqxyojq00a2tnn01tkr32hk"},{"post_id":"ckqqxyoih005xtnn098ld86ow","tag_id":"ckqqxyojo009ctnn0dpoy97xg","_id":"ckqqxyojq00a3tnn070zzeyd2"},{"post_id":"ckqqxyoih005xtnn098ld86ow","tag_id":"ckqqxyojo009ftnn08ia2h9pq","_id":"ckqqxyojq00a4tnn0e92k9jyo"},{"post_id":"ckqqxyoih005xtnn098ld86ow","tag_id":"ckqqxyojo009itnn0a7zl360y","_id":"ckqqxyojq00a5tnn00n606exq"},{"post_id":"ckqqxyoip006qtnn022cth5j0","tag_id":"ckqqxyojp009mtnn0b3ix32a7","_id":"ckqqxyojq00a6tnn02jpnenz2"},{"post_id":"ckqqxyoiq006ttnn0cbtpen41","tag_id":"ckqqxyojp009ptnn00txcd14v","_id":"ckqqxyojq00a7tnn02v6th03u"},{"post_id":"ckqqxyoiq006ttnn0cbtpen41","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckqqxyojq00a8tnn00pp54ehi"},{"post_id":"ckqqxyoj6007ttnn0hqkncvze","tag_id":"ckqqxyojl008wtnn0ebc2ezja","_id":"ckqqxyojq00a9tnn065az77i3"},{"post_id":"ckqqxyoj6007ttnn0hqkncvze","tag_id":"ckqqxyoh80025tnn07nim36k6","_id":"ckqqxyojq00aatnn0g73jd140"},{"post_id":"ckr7wtb4d00004an03rmc3pfa","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckr7wtjyv00014an03wv386a3"},{"post_id":"ckr7wtb4d00004an03rmc3pfa","tag_id":"ckqqxyoio006htnn0hehl44ce","_id":"ckr7wtjyz00024an08pqo05e5"},{"post_id":"ckr8kf53y000066n0gqc05jiv","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckr8kfe2e000166n0gvx2aezx"},{"post_id":"ckr8kf53y000066n0gqc05jiv","tag_id":"ckqqxyojp009mtnn0b3ix32a7","_id":"ckr8kfe2h000266n0360q1it4"},{"post_id":"ckrdjtzhk00009dn0akhp1lol","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckrjbxf5z0000a1n06ppv32l5"},{"post_id":"ckrdjtzhk00009dn0akhp1lol","tag_id":"ckqqxyoio006htnn0hehl44ce","_id":"ckrjbxf680001a1n0cpwt3mdg"},{"post_id":"ckrp49yyd0000men04pnq2trc","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckrp4aqd50001men0egq04b52"},{"post_id":"ckrp49yyd0000men04pnq2trc","tag_id":"ckqqxyojp009mtnn0b3ix32a7","_id":"ckrp4aqd60002men0aeluhg2g"},{"post_id":"ckrqejbaa0000i0n043mvdn10","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckrqejlz90001i0n029ugfni6"},{"post_id":"ckrqejbaa0000i0n043mvdn10","tag_id":"ckqqxyoio006htnn0hehl44ce","_id":"ckrqejlzb0002i0n0gdbcc0sh"},{"post_id":"cksorgkyu0000zgn09atnckc8","tag_id":"ckqqxyojp009mtnn0b3ix32a7","_id":"cksorhkqx0003zgn03592ba3f"},{"post_id":"cksorgkyu0000zgn09atnckc8","tag_id":"ckqqxyogp000btnn089a33lna","_id":"cksorhkqx0004zgn09ag8cvc0"},{"post_id":"cksxcg3ow0002h7n0006mhqfz","tag_id":"ckqqxyojl008wtnn0ebc2ezja","_id":"cksxcg3oy0003h7n053yhczk9"},{"post_id":"cksxcg3ow0002h7n0006mhqfz","tag_id":"ckqqxyoh0001btnn06fl1c5m9","_id":"cksxcg3oz0004h7n02jademc3"},{"post_id":"ckt0amz050000xon0a1gfciqu","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckt0amz0d0001xon076e31crm"},{"post_id":"ckt0amz050000xon0a1gfciqu","tag_id":"ckqqxyoio006htnn0hehl44ce","_id":"ckt0amz0e0002xon0doq0aql9"},{"post_id":"cksxcg3ou0001h7n076w99zcd","tag_id":"ckqqxyogp000btnn089a33lna","_id":"ckt0amz0e0004xon05wynfzu7"},{"post_id":"cksxcg3ou0001h7n076w99zcd","tag_id":"ckqqxyoio006htnn0hehl44ce","_id":"ckt0amz0e0006xon06wrmc3h5"},{"post_id":"cktr8vw9c000042n0f23cgp8c","tag_id":"ckqqxyogp000btnn089a33lna","_id":"cktr8vw9i000142n000nqg9at"},{"post_id":"cktr8vw9c000042n0f23cgp8c","tag_id":"ckqqxyoio006htnn0hehl44ce","_id":"cktr8vw9i000242n01ll31yyt"}],"Tag":[{"name":"Shadowsocks","_id":"ckqqxyogm0005tnn0547h6exs"},{"name":"iOS","_id":"ckqqxyogp000btnn089a33lna"},{"name":"杂谈","_id":"ckqqxyogr000htnn01mxc32eu"},{"name":"C++","_id":"ckqqxyogx0013tnn09qa3avlv"},{"name":"架构","_id":"ckqqxyoh0001btnn06fl1c5m9"},{"name":"Node.js","_id":"ckqqxyoh3001ktnn0agvpgixa"},{"name":"Express","_id":"ckqqxyoh4001rtnn06och8kss"},{"name":"Jenkins","_id":"ckqqxyoh5001xtnn03s36cmsq"},{"name":"Git","_id":"ckqqxyoh80025tnn07nim36k6"},{"name":"Cocoapods","_id":"ckqqxyohd002ftnn04dejb48g"},{"name":"Fir","_id":"ckqqxyohh002mtnn0hcjvb6wg"},{"name":"Let's Encrypt","_id":"ckqqxyohk002stnn0dobg6wh0"},{"name":"https","_id":"ckqqxyohm0030tnn02m5p5uil"},{"name":"MongoDB","_id":"ckqqxyohn0039tnn0aia6acot"},{"name":"nginx","_id":"ckqqxyohr003utnn0d26ue0qm"},{"name":"Reactive Cocoa","_id":"ckqqxyohv0040tnn0ci9aal6u"},{"name":"React Native","_id":"ckqqxyohw0046tnn06ahwdslv"},{"name":"Salesforce","_id":"ckqqxyoi40050tnn04krjdbi5"},{"name":"Vue.js","_id":"ckqqxyoid005ltnn02hckdx0d"},{"name":"Xcode","_id":"ckqqxyoig005stnn0762abdpw"},{"name":"frp","_id":"ckqqxyoih0060tnn0h21l44es"},{"name":"docker","_id":"ckqqxyoin006atnn01qt8asx7"},{"name":"底层原理","_id":"ckqqxyoio006htnn0hehl44ce"},{"name":"PHP","_id":"ckqqxyoiq006vtnn0ha3cb98y"},{"name":"WordPress","_id":"ckqqxyoit0074tnn00qms0tzr"},{"name":"feature","_id":"ckqqxyojh008btnn00awd482g"},{"name":"Scene Kit","_id":"ckqqxyoji008mtnn087541skj"},{"name":"ngrok","_id":"ckqqxyojj008stnn0f5657gbe"},{"name":"技巧","_id":"ckqqxyojl008wtnn0ebc2ezja"},{"name":"shell","_id":"ckqqxyojn008ztnn027lb1uua"},{"name":"php","_id":"ckqqxyojn0092tnn02g51bsal"},{"name":"webhook","_id":"ckqqxyojo0095tnn03ma294iv"},{"name":"Cordova","_id":"ckqqxyojo0099tnn05plpdbqz"},{"name":"AppCan","_id":"ckqqxyojo009ctnn0dpoy97xg"},{"name":"Weex","_id":"ckqqxyojo009ftnn08ia2h9pq"},{"name":"HTML5+","_id":"ckqqxyojo009itnn0a7zl360y"},{"name":"Swift","_id":"ckqqxyojp009mtnn0b3ix32a7"},{"name":"Flow.ci","_id":"ckqqxyojp009ptnn00txcd14v"},{"name":"Feature","_id":"cksorhkqp0001zgn00lxm5nva"}]}}