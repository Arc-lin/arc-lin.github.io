{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/images/pasted-0.png","path":"images/pasted-0.png","modified":0,"renderable":0},{"_id":"source/images/pasted-1.png","path":"images/pasted-1.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"source/about/index.md","hash":"81b514c5ccb0032705e9ab33300262f1390c9b8c","modified":1618207624047},{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1618798792875},{"_id":"source/_drafts/关于iOS组件化的思考.md","hash":"1e804a3b34c04216ed89e3844e8b30ff4cece187","modified":1618207624035},{"_id":"source/_drafts/Jenkins分布式构建笔记.md","hash":"35b0e3e6c23c2db5e0b22c3b5f18b8bbd0fdf5b2","modified":1618207624035},{"_id":"source/categories/index.md","hash":"f3d4332e7a31fa7bccda8cdf7d0fc74843a8ede4","modified":1618207624047},{"_id":"source/_posts/AVFoundation录制视频没声音.md","hash":"79343974faad0a61f46b840f368e6356f284e734","modified":1618207624036},{"_id":"source/_posts/DKLogger-iOS日志管理框架.md","hash":"10dad822e3a657745ad28b052750985977f7abab","modified":1618207624036},{"_id":"source/_posts/ALAsset-Type-Unknown的问题.md","hash":"2d22c0fc59e322e4b7c61959616e24a50266f03c","modified":1618207624035},{"_id":"source/_posts/2016-Dankal-iOS-MySummary.md","hash":"75ab37eeb8ff69dc4bed281580e7c4838eff3758","modified":1618207624035},{"_id":"source/_posts/C-基础.md","hash":"cd4559ae3818a19e565eeb4829626104f5bb5efd","modified":1618207624036},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1618684334316},{"_id":"source/_posts/Dankal-iOS崩溃信息提交.md","hash":"d428024480bfc09bc435d59f821dd6c10096c8b6","modified":1618207624036},{"_id":"source/_posts/Jenkins-Git-CocoaPods-Fir-im实现iOS应用持续集成.md","hash":"3ef15c67b8013ee9b388eafd8477bc7ef975fe90","modified":1618798544349},{"_id":"source/_posts/Express学习笔记.md","hash":"06e424af2a5a1679130592f4784ac49154be127b","modified":1618207624036},{"_id":"source/_posts/Jenkins上蒲公英插件中update-description-无法自动写入commit-message问题解决.md","hash":"2a0ab273cb5ce92ce4e01cfcdec0553374fbd445","modified":1618207624036},{"_id":"source/_posts/MongoDB笔记.md","hash":"b8fd5e0d872241175d2a279226205a2bde46e50d","modified":1618207624036},{"_id":"source/_posts/Let’s-Encrypt-免费https.md","hash":"dbae669477a06be1d37a7134dbdda9033098f658","modified":1618207624036},{"_id":"source/_posts/Node-js学习笔记.md","hash":"21dd21350c3b5367464dc2e490a415f8284450b8","modified":1618207624037},{"_id":"source/_posts/RACCommand使用注意.md","hash":"95799e327104f37efeb93d9da02ca950cec42d09","modified":1618207624037},{"_id":"source/_posts/React-Native真机运行.md","hash":"7cd8073b7622e120587e4e6480438834f66a25e1","modified":1618207624037},{"_id":"source/_posts/RAC关于cell上的按钮点击后会重复发送信号的问题.md","hash":"acb143b5e3d835d44b9877d443393273cd23acd5","modified":1618207624037},{"_id":"source/_posts/ReactNative-ListView-flexWrap不起作用解决办法.md","hash":"71c9f7d3af3af00d7089a1fb20f7dad65f7638a5","modified":1618207624037},{"_id":"source/_posts/ReactNative网络请求.md","hash":"42868f6c90de499bb4aff52f35ee7e1031b976a6","modified":1618207624037},{"_id":"source/_posts/ReactiveCocoa解决异步串行任务执行中多层嵌套-递归的问题.md","hash":"b200cccaff18936face39e769448b406d9f34c38","modified":1618207624037},{"_id":"source/_posts/Salesforce-SDK-Bug.md","hash":"b6ec91d313d513d433f78ea87f93f72fc3bcfb2b","modified":1618207624037},{"_id":"source/_posts/NavigationController的RootViewController和子ViewController的状态栏颜色不一样或者状态栏显示异常.md","hash":"7ff835e3c50f03bec0ca1b1c75233eae17b6a6b6","modified":1618207624036},{"_id":"source/_posts/ReactNative与iOS原生代码之间传值.md","hash":"ee7c8fcf5468f2542469471d55c5ec8c6569dbae","modified":1618207624037},{"_id":"source/_posts/Shell-笔记.md","hash":"d4877e5e63fc2128d9b241ca86c69ead52214f5c","modified":1618207624037},{"_id":"source/_posts/Nginx-内容替换模块-http-substitutions-filter-module.md","hash":"a34b6839c77c6a5720818a36921e23df0460f2ea","modified":1618207624036},{"_id":"source/_posts/Sign-in-with-Apple接入指南.md","hash":"a51b1ae7bcde5aa93b98fc78979bcfd2b70c4471","modified":1618207624038},{"_id":"source/_posts/Untitled.md","hash":"a1d8f74f8b28b54e4288669678afa985c93df782","modified":1618207624038},{"_id":"source/_posts/URLWithString返回空.md","hash":"c9f1c52dc4823b1c9374e0d09db1292c01cd13e2","modified":1618207624038},{"_id":"source/_posts/UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃的问题.md","hash":"a0fa34339e183190932a5c7e97311f7811f656dd","modified":1618207624038},{"_id":"source/_posts/Vue学习笔记.md","hash":"75c82eb38d03cfdbeebabf86873734b0800cdfeb","modified":1618207624038},{"_id":"source/_posts/WordPress常用函数.md","hash":"6069516f30189235e5c06427ba6cd3ac42813ea1","modified":1618207624038},{"_id":"source/_posts/docker笔记.md","hash":"f305188879320e84f106f7327bb91ef9bc14536f","modified":1618207624038},{"_id":"source/_posts/XCode-添加Target.md","hash":"b0c02a7d7d2c7ff2ede199cb8c7172de006f536b","modified":1618207624038},{"_id":"source/_posts/frp-内网穿透.md","hash":"d5c5268aac4d7145c2c17faac9ff16877d5e7875","modified":1618207624038},{"_id":"source/_posts/iOS13新API.md","hash":"caa8317f8abf5c55f0dcc115e368b6c062988c3d","modified":1618798298064},{"_id":"source/_posts/ipad和iphone使用UIAlertViewController.md","hash":"1c598d0f714d40461c4db83c761ec60602afbcd2","modified":1618207624039},{"_id":"source/_posts/iOS基于Navigation-Base-on-ViewModel的路由搭建——HOOK方式实现.md","hash":"dde899491d68cbc04c8810aaaaa636201c8880c9","modified":1618207624039},{"_id":"source/_posts/iOS-定位总结.md","hash":"ac8eb40d883ec13e10b1a8e6ae4ec7ca085bdc1f","modified":1618207624039},{"_id":"source/_posts/iOS12-新玩具ShortCut-捷径-使用.md","hash":"0e75111ae668f02731e66a9eac2448b968d495aa","modified":1618207624039},{"_id":"source/_posts/nginx-镜像谷歌.md","hash":"ece28461166dcf251037c8f0b521968f85ca595c","modified":1618207624039},{"_id":"source/_posts/iOS从服务器下载DAE文件并动态加载到SCNScene.md","hash":"285f46e93d86417636ed94567079861887a1945c","modified":1618207624039},{"_id":"source/_posts/ngrok-内网穿透使用.md","hash":"d2a1bf006ab18427c44f49fb8b60eab875faaa8c","modified":1618207624039},{"_id":"source/_posts/什么时候用weakSelf什么时候用strongSelf.md","hash":"0768a0e2a0ff84a66e75768006cb7c55c824af55","modified":1618207624039},{"_id":"source/_posts/使用DKHTTPTool时的异常处理.md","hash":"72c639bed85a13cf54415d6fff2532bccace6b6a","modified":1618207624039},{"_id":"source/_posts/pop后强制竖屏.md","hash":"ee03f2db0e4251ab119e8cf9ebb084fc4ae36841","modified":1618207624039},{"_id":"source/_posts/pan手势判断方向.md","hash":"172c310993f3edbd4f34e76e5afff82cdc9d8006","modified":1618207624039},{"_id":"source/_posts/一句ipack命令解决iOS编译打包上传fir流程.md","hash":"3cd917e60e8b5fdc1a97b42866dd6f67680183fd","modified":1618207624039},{"_id":"source/_posts/关于App混合开发的介绍.md","hash":"c9fd05d5f77d12ec5ea84345bf95a632a5ba1619","modified":1618207624040},{"_id":"source/_posts/使用RAC-DKHTTPTool实践.md","hash":"708abd5f5421f2a371ee12e9303df19e8929eb04","modified":1618207624039},{"_id":"source/_posts/发现一个api.md","hash":"bb146d0151224cf8ced6a0bb9c8d8c8af0b6087c","modified":1618207624040},{"_id":"source/_posts/利用MJExtension取出模型数组中的某个属性组成数组.md","hash":"5875e519af86b5105c359e4ee2af779d02296007","modified":1618207624040},{"_id":"source/_posts/关于第三方单元测试框架的简单说明.md","hash":"595b746d29c647ec21869b807d35215affa8006d","modified":1618207624040},{"_id":"source/_posts/在-iCloud-Drive中显示-App的iCloud文件夹.md","hash":"01436a01adf15adea7d9e7982a2bbf968e63d0c6","modified":1618207624040},{"_id":"source/_posts/关于案场管家的技术点总结.md","hash":"95acceb6f6d9b4461fe42dda92e52557fa229b1b","modified":1618207624040},{"_id":"source/_posts/基于DKHTTPTool的业务层设计-尝试版.md","hash":"51da67fe25ace8eab907c9b710cc0e97e1c1cf81","modified":1618207624040},{"_id":"source/_posts/安装shadowsocks服务端.md","hash":"6ef4d7b80461ea14be4fbf44d6df82fc82be5fed","modified":1618207624040},{"_id":"source/_posts/建造者模式.md","hash":"00c6c143728aad71fd4f4fd568477912b5611ee8","modified":1618207624040},{"_id":"source/_posts/用Swift的框架Vapor写服务端初体验.md","hash":"2b594080c7ecf6ea53fb0cf78111fe4e1b5dcd62","modified":1618207624041},{"_id":"source/_posts/用flow-ci做iOS的持续化集成.md","hash":"440898f620a1187b23df4d7278325154b2430622","modified":1618207624041},{"_id":"source/_posts/使用php的exec方法进行webhook的注意点.md","hash":"22fdd40872f17d19a126550c054416dba3db8834","modified":1618207624040},{"_id":"source/_posts/组合模式.md","hash":"d9cd6b2ca459ba116b9b900d7c6cc2421ee6ef0c","modified":1618207624041},{"_id":"source/_posts/简易架构设计.md","hash":"66fe37c72788ecfd70ee43669ee3e871ebeeb4f6","modified":1618207624041},{"_id":"source/_posts/网络层方法封装3.md","hash":"93d00064ea7d255e55706af1e86981a37c584de8","modified":1618207624042},{"_id":"source/_posts/网络层方法封装.md","hash":"66621328b6d64ee0923848bb736265ea240601a0","modified":1618207624042},{"_id":"source/_posts/网络层方法封装5.md","hash":"51ac773d6d2d4e1419f03dfe1dc08e67425798e3","modified":1618207624042},{"_id":"source/_posts/解决git-status中文问题.md","hash":"9df314c6b7cd636feeb738a388720a7953f4b3de","modified":1618798764821},{"_id":"source/_posts/给-APP添加外部文件导入功能.md","hash":"20774a424accf066ae53ac43bd13be9fa348f880","modified":1618207624042},{"_id":"source/_posts/网络层方法封装4.md","hash":"ef125b7fea230ccaaae48ca0245b9375e8684583","modified":1618207624042},{"_id":"source/_posts/记录一些关于iOS的一些小技巧.md","hash":"23bc3db95251ebf5c9a7360165ec132899866948","modified":1618207624046},{"_id":"source/_posts/通过代理上传方案.md","hash":"5a8e8f2b859e532ba877ae708280bbd4944b9d13","modified":1618207624047},{"_id":"source/_posts/项目里面的库和框架里面的库冲突问题.md","hash":"dc2ff33ba538a49b08723568ddf1559568a2ad6a","modified":1618207624047},{"_id":"source/_posts/网络层方法封装2.md","hash":"f7e7bad21f617d69c5faa89edb05817d2255d8ac","modified":1618207624042},{"_id":"source/images/pasted-0.png","hash":"c0918553b8c5976f49ee8776962b2e6337dd9210","modified":1618207624047},{"_id":"source/_posts/如何开发-管理一个项目.md","hash":"e1ee2fcdfa80a761ba77b5f74bb719d58ab756c0","modified":1618765736221},{"_id":"source/tags/index.md","hash":"205f3ebdfd3a3012836cf8f1fc70a8c5979d9387","modified":1618207624048},{"_id":"source/images/pasted-1.png","hash":"9b5536674cfae526b4328c97531dbb81feeb4fae","modified":1618207624048},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1618682094110},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1618682094110},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1618682094111},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1618682094112},{"_id":"themes/next/_config.yml","hash":"9bb16ddbcb760dc84973c7fb5e0ff331f6d398c7","modified":1618764367254},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1618682094121},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1618682094112},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1618682094114},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1618682094111},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1618682094112},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1618682094110},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1618682094110},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1618682094111},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1618682094111},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1618682094111},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1618682094111},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1618682094111},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1618682094110},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1618682094112},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1618682094111},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1618682094111},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1618682094112},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1618682094111},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1618682094111},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1618682094112},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1618682094113},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1618682094113},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1618682094113},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1618682094114},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1618682094113},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1618682094114},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1618682094114},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1618682094114},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1618682094115},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1618682094112},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1618682094115},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1618682094115},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1618682094114},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1618682094115},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1618682094115},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1618682094115},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1618682094112},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1618682094115},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1618682094115},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1618682094115},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1618682094115},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1618682094115},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1618682094116},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1618682094116},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1618682094115},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1618682094115},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1618682094114},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1618682094113},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1618682094116},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1618682094120},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1618682094120},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1618682094120},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1618682094120},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1618682094120},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1618682094122},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1618682094120},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1618682094116},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1618682094111},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1618682094111},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1618682094111},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1618682094110},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1618682094113},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1618682094113},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1618682094113},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1618682094113},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1618682094113},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1618682094113},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1618682094114},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1618682094114},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1618682094114},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1618682094114},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1618682094118},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1618682094118},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1618682094118},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1618682094118},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1618682094118},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1618682094119},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1618682094119},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1618682094119},{"_id":"themes/next/layout/_third-party/.DS_Store","hash":"eefc31c04146e6b15fe9d89408c3793be0f44d23","modified":1618757488238},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1618682094116},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1618682094116},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1618682094119},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4369b313cbbeae742cb35f86d23d99d4285f7359","modified":1618758777437},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1618682094116},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1618682094117},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1618682094117},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1618682094118},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1618682094121},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1618682094121},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1618682094122},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1618682094116},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1618682094122},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1618682094122},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1618682094122},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1618682094121},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1618682094122},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1618682094122},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1618682094122},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1618682094122},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1618682094122},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1618682094122},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1618682094122},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1618682094122},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1618682094122},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1618682094122},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1618682094122},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1618682094122},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1618682094122},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1618682094114},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1618682094114},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1618682094133},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1618682094133},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1618682094133},{"_id":"themes/next/source/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1618682094134},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1618682094114},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1618682094133},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1618682094132},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1618682094133},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1618682094132},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1618682094132},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1618682094133},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1618682094132},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1618682094132},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1618682094133},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1618682094133},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1618682094133},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1618682094134},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1618682094133},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1618682094123},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1618682094129},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1618682094132},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1618682094118},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1618682094118},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1618682094118},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1618682094118},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1618682094119},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1618682094119},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1618682094133},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1618682094118},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1618682094133},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1618682094118},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1618682094119},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1618682094133},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1618682094119},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1618682094119},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1618682094119},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1618682094118},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1618682094119},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1618682094119},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1618682094119},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1618682094119},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1618682094119},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1618682094120},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"06766874391f5cb5c4fc67fdf69a7f8e705a3510","modified":1618759692946},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1618682094120},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1618682094119},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1618682094119},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1618682094120},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1618682094120},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1618682094120},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1618682094120},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1618682094120},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1618682094116},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1618682094120},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1618682094117},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1618682094120},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1618682094117},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1618682094116},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1618682094120},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1618682094116},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1618682094117},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1618682094117},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1618682094117},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1618682094117},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1618682094117},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1618682094117},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1618682094118},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1618682094118},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1618682094117},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1618682094117},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1618682094117},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1618682094117},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1618682094121},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1618682094121},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1618682094117},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1618682094121},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1618682094121},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1618682094121},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1618682094121},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1618682094121},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1618682094121},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1618682094121},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1618682094121},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1618682094121},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1618682094134},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1618682094135},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1618682094134},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1618682094135},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1618682094131},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1618682094131},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1618682094131},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1618682094132},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1618682094132},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1618682094134},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1618682094134},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1618682094126},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1618682094123},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1618682094126},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1618682094123},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1618682094127},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1618682094127},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1618682094128},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1618682094128},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1618682094128},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1618682094128},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1618682094123},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1618682094128},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1618682094125},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1618682094130},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1618682094129},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1618682094130},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1618682094130},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1618682094130},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1618682094131},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1618682094129},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1618682094130},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1618682094130},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1618682094130},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1618682094131},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1618682094131},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1618682094131},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1618682094130},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1618682094131},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1618682094130},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1618682094131},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1618682094131},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1618682094126},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1618682094125},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1618682094125},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1618682094130},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1618682094126},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1618682094126},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1618682094126},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1618682094126},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1618682094126},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1618682094126},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1618682094127},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1618682094127},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1618682094126},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1618682094127},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1618682094127},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1618682094127},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1618682094127},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1618682094127},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1618682094123},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1618682094127},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1618682094123},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1618682094123},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1618682094123},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1618682094123},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1618682094124},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1618682094124},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1618682094124},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1618682094123},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1618682094124},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1618682094124},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1618682094124},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1618682094124},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1618682094124},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1618682094124},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1618682094124},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1618682094125},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1618682094125},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1618682094125},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1618682094124},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1618682094128},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1618682094125},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1618682094125},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1618682094128},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1618682094128},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1618682094128},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1618682094129},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1618682094129},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1618682094125},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1618682094129},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1618682094129},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1618682094129},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1618682094129},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1618682094129},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1618682094135},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1618682094134},{"_id":"public/atom.xml","hash":"4a51329885575d6ab7f5101cab28b0a0be732c5a","modified":1618799247102},{"_id":"public/search.xml","hash":"ed10f6d076dc7234f0a7bfc0ffb3ccc2aad0e021","modified":1618799247102},{"_id":"public/sitemap.xml","hash":"27b1264b2d30731050cfe2a01376c44a70194291","modified":1618799247102},{"_id":"public/about/index.html","hash":"2cd7a326aa895776b0a0dbb2b3e62f00ee5109e2","modified":1618798973058},{"_id":"public/categories/index.html","hash":"4dc26eb37c0b5add91812bf70399637a00a546e3","modified":1618798973058},{"_id":"public/tags/index.html","hash":"4d812d99c8de351cc85c757aa3f219bf346cb88c","modified":1618798973058},{"_id":"public/post/f8291fcc.html","hash":"47ed4d2d1f3e72552294f89a1116fe1730a092ed","modified":1618798973058},{"_id":"public/post/e88dc875.html","hash":"93f3f213c07ad4465b7c4bd3150a79149e24e6be","modified":1618798973058},{"_id":"public/post/93da1b70.html","hash":"2aa353dc86bf9c721cbbb42db41189d339ca5489","modified":1618798973058},{"_id":"public/post/11785d19.html","hash":"441169bb56bf65d6383cb0ceedeb1ef04291b657","modified":1618798973058},{"_id":"public/post/b072216a.html","hash":"0be0a5450170263f2035936c175bb4b22a56ea3d","modified":1618798973058},{"_id":"public/post/34db2dbc.html","hash":"49ff36a7b4e891b32b7b85ba0059e0297eb112a4","modified":1618798973058},{"_id":"public/archives/page/8/index.html","hash":"2e984e0fd79c5f40aeb14ba964580112630845bc","modified":1618798973058},{"_id":"public/archives/2016/06/index.html","hash":"6ab1db6f57b1b5851e8683795bfc09ac4a5bd1d7","modified":1618798973058},{"_id":"public/archives/2016/10/page/2/index.html","hash":"25f38e01494e218510a63a06d8002ca0355aff76","modified":1618798973058},{"_id":"public/archives/2016/11/index.html","hash":"81623eb46308713215175edc85331faf7ad8a306","modified":1618798973058},{"_id":"public/archives/2016/12/index.html","hash":"8b8427d78d9176095fbed9ce10c17f160bcdbb59","modified":1618798973058},{"_id":"public/archives/2017/page/3/index.html","hash":"aa8bcc61780fd6c472b9c53d70284ff4184f03f9","modified":1618798973058},{"_id":"public/archives/2017/01/index.html","hash":"11e38d8e9383fd780b1957a7181c1dc408e2e9c6","modified":1618798973058},{"_id":"public/archives/2017/02/index.html","hash":"51ad5d8ca2e6e388977e5db9de550cbc0674affa","modified":1618798973058},{"_id":"public/archives/2017/08/index.html","hash":"2bd6ddd541f5b3c11800e8b16f6a7036f49c6805","modified":1618798973058},{"_id":"public/archives/2018/page/2/index.html","hash":"7c004538f7f1cf27c114ef8c836038ba5d7e1e24","modified":1618798973058},{"_id":"public/archives/2018/02/page/2/index.html","hash":"11c3c9901aaebfabb3ec7a18681d125d39678cc6","modified":1618798973058},{"_id":"public/archives/2018/05/index.html","hash":"561551ce79b7df14bec2de70dbbf7b151d225f3c","modified":1618798973058},{"_id":"public/archives/2018/08/index.html","hash":"8e1d32e819670e2e3f076eaaea20f6f452353711","modified":1618798973058},{"_id":"public/archives/2018/09/index.html","hash":"62fd3077ace9afa9feee47ad859135f51a34d7c0","modified":1618798973058},{"_id":"public/archives/2019/index.html","hash":"c7b19c9b1d0e9f9e8c6f259d55111af716c6412f","modified":1618798973058},{"_id":"public/archives/2019/10/index.html","hash":"bbddcabec327ee2fe6aeb5c319cd580477956308","modified":1618798973058},{"_id":"public/archives/2019/11/index.html","hash":"6783f7cc21202505be7b3ea50a41b9c39b68b881","modified":1618798973058},{"_id":"public/page/8/index.html","hash":"34ce58f122833b49870183c70ee90a7556faa69c","modified":1618798973058},{"_id":"public/tags/Jenkins/index.html","hash":"244404d445c5a40bdcbec3de6694e5968346dd77","modified":1618798973058},{"_id":"public/tags/iOS/page/5/index.html","hash":"788115639d03c6247de3577ae55622947446a624","modified":1618798973058},{"_id":"public/tags/C/index.html","hash":"0b8a0148e24475b935eb63ae7abb58887c5a2f08","modified":1618798973058},{"_id":"public/tags/杂谈/index.html","hash":"c69bc1634780a0474238260d5ab27f8d6b882070","modified":1618798973058},{"_id":"public/tags/Node-js/index.html","hash":"bdbd4444477783d006a0954a41f121eca8a84e58","modified":1618798973058},{"_id":"public/tags/Express/index.html","hash":"0b1e856cb792a878241ecfff69ee3aaa706c8c05","modified":1618798973058},{"_id":"public/tags/Let-s-Encrypt/index.html","hash":"02db9635fb4367df4801cb4e8cceb7f1cf2283fa","modified":1618798973058},{"_id":"public/tags/nginx/index.html","hash":"889fc38c5a18b65fd1564bc5a2106594daff8cc0","modified":1618798973058},{"_id":"public/tags/https/index.html","hash":"73304ed029d86b21cfdb8b1b0d43561e32e567e6","modified":1618798973058},{"_id":"public/tags/Reactive-Cocoa/index.html","hash":"987ce2102d244d1921d105f963495e43f4bac20c","modified":1618798973058},{"_id":"public/tags/MongoDB/index.html","hash":"f1df1eed5d854bcb58b0dbf45b2046d0ac116120","modified":1618798973058},{"_id":"public/tags/Salesforce/index.html","hash":"26444e43075ef2433f866608c5e8a7e3d57a988b","modified":1618798973058},{"_id":"public/tags/Vue-js/index.html","hash":"f8080e137ca4697732bc6ad4b171f96a38a7f1ab","modified":1618798973058},{"_id":"public/tags/PHP/index.html","hash":"1af270a9441a352cbe856f50ac814813521d824f","modified":1618798973058},{"_id":"public/tags/React-Native/index.html","hash":"519b62cf6b40eea2868af0342190efd9e17ca677","modified":1618798973058},{"_id":"public/tags/WordPress/index.html","hash":"1a9197d54d9ac52ac19aa9899f1562f153169bc5","modified":1618798973058},{"_id":"public/tags/docker/index.html","hash":"b8da207232b44398e52c1bda6e3d414c7f2afdd5","modified":1618798973058},{"_id":"public/tags/frp/index.html","hash":"c97b4737aca29835cf4c1568fb76e7dfdfe85bf3","modified":1618798973058},{"_id":"public/tags/XCode/index.html","hash":"584cb98cd2290de2dfea17d5214369d047eb105c","modified":1618798973058},{"_id":"public/tags/Scene-Kit/index.html","hash":"8fa473e060a1fe7ecf4eeeb8530b3442632bb03d","modified":1618798973058},{"_id":"public/tags/Fir/index.html","hash":"ebec34e180dc3e6dbd1cfdb46e8dbcad1bebcc26","modified":1618798973058},{"_id":"public/tags/ngrok/index.html","hash":"388a18c244c33b6145c1378e70d38451f33c4206","modified":1618798973058},{"_id":"public/tags/CocoaPods/index.html","hash":"811ca27e5ebc85042fcbf996d25d289137f039da","modified":1618798208886},{"_id":"public/tags/Cordova/index.html","hash":"460e0400f489612316630a6bab1dab5bfd9bed39","modified":1618798973058},{"_id":"public/tags/shell/index.html","hash":"32e79f1553a8a272d21215ac692b35fab323f0c7","modified":1618798973058},{"_id":"public/tags/Git/index.html","hash":"1d082ce2de6e0787cd7ff0983365e8d107e85797","modified":1618799620427},{"_id":"public/tags/AppCan/index.html","hash":"0904b44cd3aabae983f84087a41bb1ec2bb1804e","modified":1618798973058},{"_id":"public/tags/Weex/index.html","hash":"e90a9ddfc7f941382b5bcac611d0c191e47b626b","modified":1618798973058},{"_id":"public/tags/HTML5/index.html","hash":"b51c3402bf927cb04ae88b455b09cc9b3c75ec10","modified":1618798973058},{"_id":"public/tags/php/index.html","hash":"db6155d30a41685f4a20de47f997ddff8b901074","modified":1618798973058},{"_id":"public/tags/webhook/index.html","hash":"90fd5f2c78ac46d0f543d1ab10f6b2fea6f517a1","modified":1618798973058},{"_id":"public/tags/Shadowsocks/index.html","hash":"8d44b0513d73466b63766e9bf234ddad75c3c1fa","modified":1618798973058},{"_id":"public/tags/Flow-ci/index.html","hash":"d8b511d1fb6dec62a2c6782da73b4b3abf392f30","modified":1618798973058},{"_id":"public/tags/Swift/index.html","hash":"58a97128f8362d25e452041f5ed874bbba5079c3","modified":1618798973058},{"_id":"public/tags/git/index.html","hash":"abf4d7c52d8fcb07a128b74ddd113be5286b1950","modified":1618798208886},{"_id":"public/tags/技巧/index.html","hash":"f661fdd23627cdc96a8a80462c000cc4183545ed","modified":1618799247102},{"_id":"public/categories/Jenkins/index.html","hash":"ed231298586dd764c2ff215b06f0465faf32eac7","modified":1618798973058},{"_id":"public/categories/iOS/page/5/index.html","hash":"1186d45541755a8d5e577480cc97ed415c661f79","modified":1618798973058},{"_id":"public/categories/C/index.html","hash":"54dd612f4a054fbda50ae76f6c62ff84937738db","modified":1618798973058},{"_id":"public/categories/MongoDB/index.html","hash":"9cf1119c4058ce28527cdc9069bf9a9d7a60a5e7","modified":1618798973058},{"_id":"public/categories/React-Native/index.html","hash":"9a3a7ddfee4746020978fc1bce061a65523b499f","modified":1618798973058},{"_id":"public/categories/前端/index.html","hash":"c932303631e87cb1736bc7a3db98870b79acb3e4","modified":1618798973058},{"_id":"public/categories/Linux/index.html","hash":"a6af14ea289aa791c2b54b8aa23facfc5e8c1325","modified":1618798973058},{"_id":"public/categories/Node-js/index.html","hash":"d7a1cc473f75ae7d8230560bff5d2ab34324e486","modified":1618798973058},{"_id":"public/categories/PHP/index.html","hash":"7ff310bd55ecb972e667652780ce5fddd54e649a","modified":1618798973058},{"_id":"public/categories/杂谈/index.html","hash":"edce83103bb0bb463074a15d40035592feea154b","modified":1618798973058},{"_id":"public/categories/Swift/index.html","hash":"a9519944bd687ccb897f70dda070e435316bc1a7","modified":1618798973058},{"_id":"public/categories/Git/index.html","hash":"d291d077e7945c8490b1848d90b026338dd7284d","modified":1618798973058},{"_id":"public/post/f356f3c1.html","hash":"1b410ceca20ce259abaaf3bc0e5181c3daf1ce3e","modified":1618798973058},{"_id":"public/post/3c7b026b.html","hash":"a301baf9748d66dd5d117359d430a40d565eaf3e","modified":1618798973058},{"_id":"public/post/ac0a85bd.html","hash":"0e61360b459551a82632cee905fcef4890ef4308","modified":1618798973058},{"_id":"public/post/f9a964a9.html","hash":"012f31662ba11b12b694e0b04fcc934231b233dc","modified":1618798973058},{"_id":"public/post/0.html","hash":"9614213bc023878fababa2ba907354c90293e491","modified":1618798973058},{"_id":"public/post/undefined.html","hash":"c36529457788dc05326c27d1bafc4ff8411f0f65","modified":1618798973058},{"_id":"public/post/7daa41d8.html","hash":"a051db519bf0da88aa08542335a68e0e4e77ee58","modified":1618798973058},{"_id":"public/post/cfe784af.html","hash":"e4a96ae7631238a89312ae32abe402eeb3abce53","modified":1618798973058},{"_id":"public/post/5fcbb764.html","hash":"38a79f280748d7b82fe6e6ec8dfb2ae00c6ae5c3","modified":1618798973058},{"_id":"public/post/4417b09c.html","hash":"1eae77b609a257707c89c57f2993c61fc675472e","modified":1618798973058},{"_id":"public/post/e35ccdb6.html","hash":"489849a0af75efe24f3d495fcf7bcc957595555e","modified":1618798973058},{"_id":"public/post/eb81866c.html","hash":"5f4557724571ddfb26858bb6156a6239a0d48733","modified":1618798973058},{"_id":"public/post/a6a89073.html","hash":"dc63dd77d5439e20727f0c14b920f21bf304549e","modified":1618798973058},{"_id":"public/post/8cafabb2.html","hash":"81af6cc99dcec6cd469b8e72a5d759f681255721","modified":1618798973058},{"_id":"public/post/b72542c2.html","hash":"e010b70fa03f7c9bc704247c967c25b84fa4de06","modified":1618798973058},{"_id":"public/post/dda122f4.html","hash":"f8a8e6bd3ed53fcafff797a9ae084753a7f1467e","modified":1618798973058},{"_id":"public/post/b3b38c86.html","hash":"a8ea6d3faadef715758dcbc7dbe550ce5dd8b8bd","modified":1618798973058},{"_id":"public/post/f6ce3122.html","hash":"45966c9e9df67519b3cca0484bd3ad567f7b4071","modified":1618798973058},{"_id":"public/post/feddc8a5.html","hash":"5d1d55eda7918aa388d2c7e03f24d493d12a0bd2","modified":1618798973058},{"_id":"public/post/71513ccb.html","hash":"c77cd7ed1f83ea6a0441ee0fcfea0d33f58c1557","modified":1618798973058},{"_id":"public/post/5f5664e4.html","hash":"7facfc2efc30dda25455e38c8c6af1a33d21b921","modified":1618798973058},{"_id":"public/post/73291e5a.html","hash":"28107e63cd9e90565d258924c74e6856c824cc70","modified":1618798973058},{"_id":"public/post/b6bd206a.html","hash":"1e0c23be3fbed7b532f0668ba17ea21f1236da76","modified":1618798973058},{"_id":"public/post/b179ff40.html","hash":"4d63c1a4a7a1ca83e1e2e7f3e2de1bfda628bc95","modified":1618798973058},{"_id":"public/post/7724d1af.html","hash":"8ad051390afc13a95277c21fdef542b5b4144313","modified":1618798973058},{"_id":"public/post/dcb90c85.html","hash":"6efbcc5261651f30c37222e3e73a9a33494966c4","modified":1618798973058},{"_id":"public/post/1aafa723.html","hash":"2b919d7683f2c8c3b728e33fcf8b068ec830fffe","modified":1618798973058},{"_id":"public/post/efd905d7.html","hash":"1dec448f9f4ffa1b71495de7621d10711dc4682b","modified":1618798973058},{"_id":"public/post/3fd5c9ca.html","hash":"5b4408643d54a75843c4291a31d62ff1b8b007a5","modified":1618798973058},{"_id":"public/post/a8a5ff12.html","hash":"24145d7aa8b772d406ae70f9fcb5be50806e700a","modified":1618798973058},{"_id":"public/post/2281692e.html","hash":"37b7d44a82172c92290bedf3b6c7b59c1ac8301c","modified":1618798973058},{"_id":"public/post/abce56f1.html","hash":"0bea1bbc644d37ddcd3b37bd383c9f425579545c","modified":1618798973058},{"_id":"public/post/8c9c88ab.html","hash":"3a05da3a95638ace304c02a50fc86a3312fbb745","modified":1618798973058},{"_id":"public/post/4edc914d.html","hash":"7744555fa90e515487f70878e3e5c304bd5fe151","modified":1618798973058},{"_id":"public/post/13ecfb47.html","hash":"ee290d6f81f69816d3696e5cb5a3ecd6c0f8a8ec","modified":1618798973058},{"_id":"public/post/61929cc2.html","hash":"2d143a74b39bbc69c6f027c0139f2f8d069addce","modified":1618798973058},{"_id":"public/post/b111382b.html","hash":"583745463ca9a9749f578317d09af079484a4135","modified":1618798973058},{"_id":"public/post/7daccd39.html","hash":"75c78754e93c27c1e4ab8a212f81bcd2382f5234","modified":1618798973058},{"_id":"public/post/8d52056b.html","hash":"926f5886393e4162691a0d1a0740de9857e916b2","modified":1618798973058},{"_id":"public/post/178548dd.html","hash":"107f6762992bfa3d3cf0ba89863870941e9f96b5","modified":1618798973058},{"_id":"public/post/6082784b.html","hash":"13e355d745135e48a11eb12ab299f4da1cc84d95","modified":1618798973058},{"_id":"public/post/838ddddd.html","hash":"06b9c299cae78d7bbe8a68648a423670efdb8510","modified":1618798973058},{"_id":"public/post/fee6ede8.html","hash":"ae391466a35bf49a08fd462b15ff5faf0c0295da","modified":1618798973058},{"_id":"public/post/1787ee1c.html","hash":"47099d19e4a65191274075ffd9ee0551aa7e9d90","modified":1618798973058},{"_id":"public/post/89e1dd7e.html","hash":"a34c2554f14f0ed0239c084671eed887bfd86553","modified":1618798973058},{"_id":"public/post/afeed214.html","hash":"7b0ed460a43c9d00bce0a41d166ed0ebd28c3726","modified":1618798973058},{"_id":"public/post/df879792.html","hash":"c2a55748dffb393a75ccac8ca81f00e59d47bf85","modified":1618798973058},{"_id":"public/post/fe816c3c.html","hash":"d4e02c35503c4f1a22602527ae3d2e4adfa29d1c","modified":1618798973058},{"_id":"public/post/d2301e87.html","hash":"eb358f6297f719d0528c75dc210e034d9ef28902","modified":1618798973058},{"_id":"public/post/2684222a.html","hash":"7cd1ef068ad5c79df0158da2357f26c461ea61e7","modified":1618798973058},{"_id":"public/post/3eb7dc04.html","hash":"42fe95f36a3fab4ced05063bb84281edac1b0da5","modified":1618798973058},{"_id":"public/post/3d9cee8d.html","hash":"5a21774ce8ff2e90fcec34f1b5db171f90518a18","modified":1618798973058},{"_id":"public/post/4948514e.html","hash":"743d92a739380c5c56aa19dbb6d58dbd157314b8","modified":1618798973058},{"_id":"public/post/a8ea2211.html","hash":"e14ef0c61c0e0a127a9591d1aa52465f45ecb90a","modified":1618798973058},{"_id":"public/post/452efb32.html","hash":"5cf7e5960187c28c61d8f20d2eb76fd2c7a844c3","modified":1618798973058},{"_id":"public/post/79533f9e.html","hash":"fc9c029819f07e2fa2660d543be4aad08b79a118","modified":1618798973058},{"_id":"public/post/cacc49a3.html","hash":"9ba37c2a09aed2c728ab9ef17d3316e64bd7bdff","modified":1618798973058},{"_id":"public/post/890a3088.html","hash":"f42c0481f58e8ba0d02bb69e015124f0b067dfac","modified":1618798973058},{"_id":"public/post/f0080c3e.html","hash":"05042a8544af223ba6a0a2a8176875276f19848b","modified":1618798973058},{"_id":"public/post/50c5f6e6.html","hash":"bc0ae91d0666e8900f3215e1e8cdce40a9107934","modified":1618798973058},{"_id":"public/post/f9b1d95c.html","hash":"f5ea4b5a4411c38c5f6b8a69757386a2e0f4de6b","modified":1618798973058},{"_id":"public/post/54b26395.html","hash":"80f26f4736f56bfe814f46488ac4510a8532564c","modified":1618798973058},{"_id":"public/post/8e2ebfdf.html","hash":"c9235ff3bf7ce7f3a7a34bf679a2b8a8e43faba5","modified":1618798973058},{"_id":"public/post/1b8f24c7.html","hash":"251e71c0c53f9b12eae2bfc0da909f704656a3be","modified":1618798973058},{"_id":"public/post/8ff6aa28.html","hash":"fa0f80608335ca1c23ae66b398c4c86d76ec94d8","modified":1618798973058},{"_id":"public/archives/index.html","hash":"584e87c33c15c5806976d3e726232446274584c2","modified":1618799247102},{"_id":"public/archives/page/2/index.html","hash":"459b1f8dea45cc84333c47179cba7a83fab6f3e5","modified":1618798973058},{"_id":"public/archives/page/3/index.html","hash":"6595e07fcc308b40f2167b22cb5d98dbcbb29cfb","modified":1618798973058},{"_id":"public/archives/page/4/index.html","hash":"c5227c7931805b0fb0513b33dd48db0107da150c","modified":1618798973058},{"_id":"public/archives/page/5/index.html","hash":"1aee49d990753be0feed557f730307418fd4c6a2","modified":1618798973058},{"_id":"public/archives/page/6/index.html","hash":"7c9ea5d4be5b0b181932e61ecc4fcd24d052a6a8","modified":1618798973058},{"_id":"public/archives/page/7/index.html","hash":"65b291fa296e3190e3876a35694633adaaf4b6d4","modified":1618798973058},{"_id":"public/archives/2016/index.html","hash":"26dc1abb264f4b9a353d5def0148efe3cb52a81d","modified":1618798973058},{"_id":"public/archives/2016/page/2/index.html","hash":"e26c776cb4cdaf632c1320ee3e44bdef975125bb","modified":1618798973058},{"_id":"public/archives/2016/page/3/index.html","hash":"5cc5d7f0c4be214ab4707777c3b2441428bdf3aa","modified":1618798973058},{"_id":"public/archives/2016/10/index.html","hash":"4d8e8306ffb29272c5484452a313e652744db960","modified":1618798973058},{"_id":"public/archives/2017/index.html","hash":"3464d29103f2ec4a159ea38e279cc837870bdddf","modified":1618798973058},{"_id":"public/archives/2017/page/2/index.html","hash":"44786b9457dab6a5f78d65ec2b718dba7e9b9128","modified":1618798973058},{"_id":"public/archives/2017/03/index.html","hash":"d6eb6259651375a444d968d1f01d1e3220d19720","modified":1618798973058},{"_id":"public/archives/2018/index.html","hash":"008fd448418307edbf610d87210177d737954383","modified":1618798973058},{"_id":"public/archives/2018/02/index.html","hash":"0774ac0d7983b6761bbfac579b3adadbacf25ced","modified":1618798973058},{"_id":"public/page/2/index.html","hash":"86a17afd03213f903f00c0424f12fe366acbe442","modified":1618798973058},{"_id":"public/page/3/index.html","hash":"302c70be9bd71771ac78cc14f3ddf8af3dabaeef","modified":1618798973058},{"_id":"public/page/4/index.html","hash":"9eb09572b708ab21904c584046ed7e42cc175c4f","modified":1618798973058},{"_id":"public/page/5/index.html","hash":"6162a64fc9c60c3dd702231ea24eb42bfd9decce","modified":1618798973058},{"_id":"public/index.html","hash":"16818b2c0bc94a933ec54901db731259a02d4560","modified":1618799247102},{"_id":"public/page/6/index.html","hash":"0bd5890198da1037f928b3e2a5f1153a9d47d82c","modified":1618798973058},{"_id":"public/page/7/index.html","hash":"b7049de4d21838b5c4a898a4dbcee19144aae33a","modified":1618798973058},{"_id":"public/tags/iOS/page/3/index.html","hash":"31009ea49ca6f0a7c474c05c632b43229f75c54c","modified":1618798973058},{"_id":"public/tags/iOS/index.html","hash":"550b4dfdac72d8d4a91bc0c77d5b75046d84cd36","modified":1618799247102},{"_id":"public/tags/iOS/page/4/index.html","hash":"5fae7ca5b7a1b5cf3ff340e55fbdfc8b0eb03f2d","modified":1618798973058},{"_id":"public/tags/iOS/page/2/index.html","hash":"44c90250502976f0ef1c31383b13863a7f88e2ba","modified":1618798973058},{"_id":"public/categories/iOS/page/2/index.html","hash":"7f608bc0042a82d98974a54000d3c451009e0e8f","modified":1618798973058},{"_id":"public/categories/iOS/index.html","hash":"0612cdc7dd70510233eb8097f10f4d7eab18087b","modified":1618799247102},{"_id":"public/categories/iOS/page/3/index.html","hash":"1f4e9b59e7cd8ead9695afb7155530102fa3f1b6","modified":1618798973058},{"_id":"public/categories/iOS/page/4/index.html","hash":"c7996eec4d3959db621054d14dca04d929ecc2ab","modified":1618798973058},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1618762972798},{"_id":"public/images/pasted-0.png","hash":"c0918553b8c5976f49ee8776962b2e6337dd9210","modified":1618762972798},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1618762972798},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1618762972798},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1618762972798},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1618762972798},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1618762972798},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1618762972798},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1618762972798},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1618762972798},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1618762972798},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1618762972798},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1618762972798},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1618762972798},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1618762972798},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"284416885e4e80e27fa4eae6fc305f4de15b914c","modified":1618762972798},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1618762972798},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1618762972798},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"e56ad6b82caf69066de545201014291fc961635e","modified":1618762972798},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"a3b131a9a47ccc16f4dd8988fabb6d306548db2f","modified":1618762972798},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1618762972798},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1618762972798},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1618762972798},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1618762972798},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1618762972798},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1618762972798},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1618762972798},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1618762972798},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1618762972798},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1618762972798},{"_id":"public/css/main.css","hash":"016d20fcded3e5a9eafb6a3538e486d623ddcc9e","modified":1618762972798},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1618762972798},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1618762972798},{"_id":"public/images/pasted-1.png","hash":"9b5536674cfae526b4328c97531dbb81feeb4fae","modified":1618762972798},{"_id":"public/assets/algolia/algoliasearch.js","hash":"6948fcdf071e4983e784e8c458cf201536f77792","modified":1618762972798},{"_id":"source/_posts/iOS14新API.md","hash":"caf9c5a3bf72652a375500af2cb8e579e9ff6357","modified":1618798670694},{"_id":"source/_posts/iOS14-App-Clips.md","hash":"35bb2428861dac9648ee4906660dd27f44606d9c","modified":1618799136312},{"_id":"public/post/36f1cd4f.html","hash":"2406333f9c2396f25b517cf939843835a91e48e7","modified":1618799247102},{"_id":"public/post/a44df9c3.html","hash":"35f968090bb264b01bf74f84cf06f467cc5fdb0c","modified":1618799247102},{"_id":"public/archives/2021/index.html","hash":"98d3dd629e86c7c70956fdd307687f6f68a63e5f","modified":1618798973058},{"_id":"public/archives/2021/04/index.html","hash":"e034e5dfa8d85e6042c9489c67077188fc6b610d","modified":1618798973058},{"_id":"source/_posts/pod-install速度慢的终极解决方案.md","hash":"c21edb07d6a2180cdfe670400ce1d202ec6bd979","modified":1618799235302},{"_id":"source/_posts/SwiftUI指南.md","hash":"a2161d106051ef1e03e90050146834433d788a55","modified":1618798975354},{"_id":"public/archives/2020/index.html","hash":"50fa37ab04ae3f66803260f1bcbc2eb735a47fda","modified":1618799247102},{"_id":"public/archives/2020/06/index.html","hash":"79e8d3cd4b43d4d217cafcfb78d4e1d19e7d6f96","modified":1618798973058},{"_id":"public/archives/2020/11/index.html","hash":"8d81149fd9054fa11c0843db25a07261b504a33a","modified":1618799247102},{"_id":"public/archives/2019/12/index.html","hash":"a0fe6a56fa7a4c148544249413e981def5dbe51c","modified":1618798973058},{"_id":"public/tags/feature/index.html","hash":"3e6878d3cb8b5c8a412f69ac6597b49d729ed1ad","modified":1618799247102},{"_id":"public/tags/Cocoapods/index.html","hash":"61fd86eb07e1570dd10a0958bf2ad27dd94d7419","modified":1618799620427},{"_id":"public/post/826fbbdd.html","hash":"d577b985a19df293b2079b93dd2ac40b02cfd2d0","modified":1618799247102},{"_id":"public/post/f6762f39.html","hash":"1a36a857f819cc040bc637e89e2c3c3753549a00","modified":1618799247102},{"_id":"public/archives/2020/04/index.html","hash":"70873cdfcb76c52ee259a4ec30e5d32747810b02","modified":1618799247102}],"Category":[{"name":"Jenkins","_id":"cknndog4o000645n00hu05p7e"},{"name":"iOS","_id":"cknndog4q000b45n08zq497ag"},{"name":"C++","_id":"cknndog4w000n45n0b8691ct9"},{"name":"Node.js","_id":"cknndog50001445n0go9lbf8b"},{"name":"Linux","_id":"cknndog53001a45n01z9nbxqw"},{"name":"MongoDB","_id":"cknndog57001x45n039ze8xih"},{"name":"React Native","_id":"cknndog59002445n0boqz04d4"},{"name":"前端","_id":"cknndog5d002s45n022da3a45"},{"name":"PHP","_id":"cknndog5g003145n09lyl1wdw"},{"name":"杂谈","_id":"cknndog60004o45n0evvr9s68"},{"name":"Swift","_id":"cknndog6l005u45n09bi2g39r"},{"name":"Git","_id":"cknndog6t006n45n029r79fzg"}],"Data":[],"Page":[{"title":"关于","type":"about","date":"2018-02-16T14:05:46.000Z","_content":"如果你想联系我，发邮件到`arclin325@gmail.com`，有时间我一定会回复你：）","source":"about/index.md","raw":"title: 关于\ntype: about\ndate: 2018-02-16 22:05:46\n---\n如果你想联系我，发邮件到`arclin325@gmail.com`，有时间我一定会回复你：）","updated":"2021-04-12T06:07:04.047Z","path":"about/index.html","comments":1,"layout":"page","_id":"cknndog4d000045n08b6h0z34","content":"<p>如果你想联系我，发邮件到<code>arclin325@gmail.com</code>，有时间我一定会回复你：）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>如果你想联系我，发邮件到<code>arclin325@gmail.com</code>，有时间我一定会回复你：）</p>\n"},{"title":"分类","date":"2018-02-16T14:05:11.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-02-16 22:05:11\ntype: categories\ncomments: false\n---\n","updated":"2021-04-12T06:07:04.047Z","path":"categories/index.html","layout":"page","_id":"cknndog4j000245n0gonb2ca1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-02-16T14:05:25.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-02-16 22:05:25\ntype: tags\ncomments: false\n---\n","updated":"2021-04-12T06:07:04.048Z","path":"tags/index.html","layout":"page","_id":"cknndog4m000445n01oblha4u","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"关于iOS组件化的思考","author":"Arclin","abbrlink":"51f93d53","date":"2018-05-11T07:02:35.000Z","_content":"最近公司要对以往App进行组件化处理，本人有幸收到任务，故运用了以往学到的架构思想对进行规划。\n<!--more-->\n\n### 需求分析\n\n1. 公司的业务线非常地多，基本上每个业务都会有一个专门的APP去推广，然后公司还有些平台版APP，用于集合多条业务线，所以说每个业务都需要进行封装，去重复利用，这是需求一。\n2. 每个业务模块是需要有一定的定制性的，毕竟如果几个APP都用到了通过模块，然后UI长得都一样，那这样子就很可能过不了审核，苹果会认为你只是套个马甲发多个几APP，所以说组件设计的时候要分离UI和数据层，中间不要形成依赖，这是需求二。\n3. 组件间不能直接通信，要通过中间层去请求，要做到组件A删除后组件B能照样编译成功，除非说他们之间的耦合成为了产品需求，否则他们不应该直接通信，这是需求三。\n4. 组件需要做好log处理，还要添加埋点，在哪里做切点，这是很重要的需要仔细考虑的事情，是组件内置埋点还是给暴露给主工程去注册埋点，优缺利弊是需要权衡的，这是需求四。\n\n### 已有的组件化\n\n\t之前公司已经有cocoapods的组件化方案了，cocoapods是很好的组件化实践，一个pod install就可以引入组件","source":"_drafts/关于iOS组件化的思考.md","raw":"title: 关于iOS组件化的思考\nauthor: Arclin\nabbrlink: 51f93d53\ndate: 2018-05-11 15:02:35\ntags:\n---\n最近公司要对以往App进行组件化处理，本人有幸收到任务，故运用了以往学到的架构思想对进行规划。\n<!--more-->\n\n### 需求分析\n\n1. 公司的业务线非常地多，基本上每个业务都会有一个专门的APP去推广，然后公司还有些平台版APP，用于集合多条业务线，所以说每个业务都需要进行封装，去重复利用，这是需求一。\n2. 每个业务模块是需要有一定的定制性的，毕竟如果几个APP都用到了通过模块，然后UI长得都一样，那这样子就很可能过不了审核，苹果会认为你只是套个马甲发多个几APP，所以说组件设计的时候要分离UI和数据层，中间不要形成依赖，这是需求二。\n3. 组件间不能直接通信，要通过中间层去请求，要做到组件A删除后组件B能照样编译成功，除非说他们之间的耦合成为了产品需求，否则他们不应该直接通信，这是需求三。\n4. 组件需要做好log处理，还要添加埋点，在哪里做切点，这是很重要的需要仔细考虑的事情，是组件内置埋点还是给暴露给主工程去注册埋点，优缺利弊是需要权衡的，这是需求四。\n\n### 已有的组件化\n\n\t之前公司已经有cocoapods的组件化方案了，cocoapods是很好的组件化实践，一个pod install就可以引入组件","slug":"关于iOS组件化的思考","published":0,"updated":"2021-04-12T06:07:04.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog4g000145n0ca0a59qa","content":"<p>最近公司要对以往App进行组件化处理，本人有幸收到任务，故运用了以往学到的架构思想对进行规划。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h3><ol>\n<li>公司的业务线非常地多，基本上每个业务都会有一个专门的APP去推广，然后公司还有些平台版APP，用于集合多条业务线，所以说每个业务都需要进行封装，去重复利用，这是需求一。</li>\n<li>每个业务模块是需要有一定的定制性的，毕竟如果几个APP都用到了通过模块，然后UI长得都一样，那这样子就很可能过不了审核，苹果会认为你只是套个马甲发多个几APP，所以说组件设计的时候要分离UI和数据层，中间不要形成依赖，这是需求二。</li>\n<li>组件间不能直接通信，要通过中间层去请求，要做到组件A删除后组件B能照样编译成功，除非说他们之间的耦合成为了产品需求，否则他们不应该直接通信，这是需求三。</li>\n<li>组件需要做好log处理，还要添加埋点，在哪里做切点，这是很重要的需要仔细考虑的事情，是组件内置埋点还是给暴露给主工程去注册埋点，优缺利弊是需要权衡的，这是需求四。</li>\n</ol>\n<h3 id=\"已有的组件化\"><a href=\"#已有的组件化\" class=\"headerlink\" title=\"已有的组件化\"></a>已有的组件化</h3><pre><code>之前公司已经有cocoapods的组件化方案了，cocoapods是很好的组件化实践，一个pod install就可以引入组件\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>最近公司要对以往App进行组件化处理，本人有幸收到任务，故运用了以往学到的架构思想对进行规划。</p>","more":"<h3 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h3><ol>\n<li>公司的业务线非常地多，基本上每个业务都会有一个专门的APP去推广，然后公司还有些平台版APP，用于集合多条业务线，所以说每个业务都需要进行封装，去重复利用，这是需求一。</li>\n<li>每个业务模块是需要有一定的定制性的，毕竟如果几个APP都用到了通过模块，然后UI长得都一样，那这样子就很可能过不了审核，苹果会认为你只是套个马甲发多个几APP，所以说组件设计的时候要分离UI和数据层，中间不要形成依赖，这是需求二。</li>\n<li>组件间不能直接通信，要通过中间层去请求，要做到组件A删除后组件B能照样编译成功，除非说他们之间的耦合成为了产品需求，否则他们不应该直接通信，这是需求三。</li>\n<li>组件需要做好log处理，还要添加埋点，在哪里做切点，这是很重要的需要仔细考虑的事情，是组件内置埋点还是给暴露给主工程去注册埋点，优缺利弊是需要权衡的，这是需求四。</li>\n</ol>\n<h3 id=\"已有的组件化\"><a href=\"#已有的组件化\" class=\"headerlink\" title=\"已有的组件化\"></a>已有的组件化</h3><pre><code>之前公司已经有cocoapods的组件化方案了，cocoapods是很好的组件化实践，一个pod install就可以引入组件\n</code></pre>"},{"title":"Jenkins分布式构建笔记","author":"Arclin","abbrlink":"34e5df37","date":"2018-06-11T04:00:00.000Z","_content":"","source":"_drafts/Jenkins分布式构建笔记.md","raw":"title: Jenkins分布式构建笔记\nauthor: Arclin\nabbrlink: 34e5df37\ntags:\n  - Jenkins\ncategories:\n  - Jenkins\ndate: 2018-06-11 12:00:00\n---\n","slug":"Jenkins分布式构建笔记","published":0,"updated":"2021-04-12T06:07:04.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog4k000345n0ero73zn8","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"ALAsset-Type:Unknown的问题","author":"Arclin","abbrlink":"a8ea2211","date":"2016-10-16T16:00:00.000Z","_content":"- 利用ALAssetsLibrary时候，将得到的`ALAsset`存到数组里，会出现`ALAsset - Type:Unknown, URLs:(null)`的问题\n\n解决方案：初始化ALAssetsLibrary的时候，不要用alloc-init，用一个单例，如下：\n\n```\n+ (ALAssetsLibrary *)defaultAssetsLibrary\n{\n    static dispatch_once_t pred = 0;\n    static ALAssetsLibrary *library = nil;\n    dispatch_once(&pred,\n                  ^{\n                      library = [[ALAssetsLibrary alloc] init];\n                  });\n    return library;\n}\n```","source":"_posts/ALAsset-Type-Unknown的问题.md","raw":"---\ntitle: 'ALAsset-Type:Unknown的问题'\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: a8ea2211\ndate: 2016-10-17 00:00:00\n---\n- 利用ALAssetsLibrary时候，将得到的`ALAsset`存到数组里，会出现`ALAsset - Type:Unknown, URLs:(null)`的问题\n\n解决方案：初始化ALAssetsLibrary的时候，不要用alloc-init，用一个单例，如下：\n\n```\n+ (ALAssetsLibrary *)defaultAssetsLibrary\n{\n    static dispatch_once_t pred = 0;\n    static ALAssetsLibrary *library = nil;\n    dispatch_once(&pred,\n                  ^{\n                      library = [[ALAssetsLibrary alloc] init];\n                  });\n    return library;\n}\n```","slug":"ALAsset-Type-Unknown的问题","published":1,"updated":"2021-04-12T06:07:04.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog4n000545n02tw0ano0","content":"<ul>\n<li>利用ALAssetsLibrary时候，将得到的<code>ALAsset</code>存到数组里，会出现<code>ALAsset - Type:Unknown, URLs:(null)</code>的问题</li>\n</ul>\n<p>解决方案：初始化ALAssetsLibrary的时候，不要用alloc-init，用一个单例，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (ALAssetsLibrary *)defaultAssetsLibrary</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static dispatch_once_t pred &#x3D; 0;</span><br><span class=\"line\">    static ALAssetsLibrary *library &#x3D; nil;</span><br><span class=\"line\">    dispatch_once(&amp;pred,</span><br><span class=\"line\">                  ^&#123;</span><br><span class=\"line\">                      library &#x3D; [[ALAssetsLibrary alloc] init];</span><br><span class=\"line\">                  &#125;);</span><br><span class=\"line\">    return library;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>利用ALAssetsLibrary时候，将得到的<code>ALAsset</code>存到数组里，会出现<code>ALAsset - Type:Unknown, URLs:(null)</code>的问题</li>\n</ul>\n<p>解决方案：初始化ALAssetsLibrary的时候，不要用alloc-init，用一个单例，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (ALAssetsLibrary *)defaultAssetsLibrary</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static dispatch_once_t pred &#x3D; 0;</span><br><span class=\"line\">    static ALAssetsLibrary *library &#x3D; nil;</span><br><span class=\"line\">    dispatch_once(&amp;pred,</span><br><span class=\"line\">                  ^&#123;</span><br><span class=\"line\">                      library &#x3D; [[ALAssetsLibrary alloc] init];</span><br><span class=\"line\">                  &#125;);</span><br><span class=\"line\">    return library;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"AVFoundation录制视频没声音?","author":"Arclin","abbrlink":"efd905d7","date":"2017-03-03T16:00:00.000Z","_content":"先说结论 , 加一行代码 \n\n```\n_captureMovieFileOutput.movieFragmentInterval = kCMTimeInvalid\n```\n\n<!-- more -->\n\n看看`movieFragmentInterval` 属性的说明\n\n```\n/*!\n @property movieFragmentInterval\n @abstract\n    Specifies the frequency with which movie fragments should be written.\n\n @discussion\n    When movie fragments are used, a partially written QuickTime movie file whose writing is unexpectedly interrupted can be successfully opened and played up to multiples of the specified time interval. A value of kCMTimeInvalid indicates that movie fragments should not be used, but that only a movie atom describing all of the media in the file should be written. The default value of this property is ten seconds.\n\n    Changing the value of this property will not affect the movie fragment interval of the file currently being written, if there is one.\n */\n@property(nonatomic) CMTime movieFragmentInterval;\n```\n\n用拙略的英语水平翻译一下就是,`movieFragmentInterval`这东西代表一个时间间隔,每隔x秒就会把视频片段写入内存,这是为了保证当意外中断视频文件写入的时候还可以有一个可以播放的视频片段,默认是十秒,如果你给他赋了这个值`kCMTimeInvalid`,就表示要一直写入直到调用某个方法结束视频录制,之后他就会给视频文件加上文件尾部,所以如果没有设置这个值的话,十秒到二十秒的视频中间就会出现没声音的状况.\n","source":"_posts/AVFoundation录制视频没声音.md","raw":"---\ntitle: AVFoundation录制视频没声音?\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: efd905d7\ndate: 2017-03-04 00:00:00\n---\n先说结论 , 加一行代码 \n\n```\n_captureMovieFileOutput.movieFragmentInterval = kCMTimeInvalid\n```\n\n<!-- more -->\n\n看看`movieFragmentInterval` 属性的说明\n\n```\n/*!\n @property movieFragmentInterval\n @abstract\n    Specifies the frequency with which movie fragments should be written.\n\n @discussion\n    When movie fragments are used, a partially written QuickTime movie file whose writing is unexpectedly interrupted can be successfully opened and played up to multiples of the specified time interval. A value of kCMTimeInvalid indicates that movie fragments should not be used, but that only a movie atom describing all of the media in the file should be written. The default value of this property is ten seconds.\n\n    Changing the value of this property will not affect the movie fragment interval of the file currently being written, if there is one.\n */\n@property(nonatomic) CMTime movieFragmentInterval;\n```\n\n用拙略的英语水平翻译一下就是,`movieFragmentInterval`这东西代表一个时间间隔,每隔x秒就会把视频片段写入内存,这是为了保证当意外中断视频文件写入的时候还可以有一个可以播放的视频片段,默认是十秒,如果你给他赋了这个值`kCMTimeInvalid`,就表示要一直写入直到调用某个方法结束视频录制,之后他就会给视频文件加上文件尾部,所以如果没有设置这个值的话,十秒到二十秒的视频中间就会出现没声音的状况.\n","slug":"AVFoundation录制视频没声音","published":1,"updated":"2021-04-12T06:07:04.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog4p000845n084u349di","content":"<p>先说结论 , 加一行代码 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_captureMovieFileOutput.movieFragmentInterval &#x3D; kCMTimeInvalid</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<p>看看<code>movieFragmentInterval</code> 属性的说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*!</span><br><span class=\"line\"> @property movieFragmentInterval</span><br><span class=\"line\"> @abstract</span><br><span class=\"line\">    Specifies the frequency with which movie fragments should be written.</span><br><span class=\"line\"></span><br><span class=\"line\"> @discussion</span><br><span class=\"line\">    When movie fragments are used, a partially written QuickTime movie file whose writing is unexpectedly interrupted can be successfully opened and played up to multiples of the specified time interval. A value of kCMTimeInvalid indicates that movie fragments should not be used, but that only a movie atom describing all of the media in the file should be written. The default value of this property is ten seconds.</span><br><span class=\"line\"></span><br><span class=\"line\">    Changing the value of this property will not affect the movie fragment interval of the file currently being written, if there is one.</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">@property(nonatomic) CMTime movieFragmentInterval;</span><br></pre></td></tr></table></figure>\n\n<p>用拙略的英语水平翻译一下就是,<code>movieFragmentInterval</code>这东西代表一个时间间隔,每隔x秒就会把视频片段写入内存,这是为了保证当意外中断视频文件写入的时候还可以有一个可以播放的视频片段,默认是十秒,如果你给他赋了这个值<code>kCMTimeInvalid</code>,就表示要一直写入直到调用某个方法结束视频录制,之后他就会给视频文件加上文件尾部,所以如果没有设置这个值的话,十秒到二十秒的视频中间就会出现没声音的状况.</p>\n","site":{"data":{}},"excerpt":"<p>先说结论 , 加一行代码 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_captureMovieFileOutput.movieFragmentInterval &#x3D; kCMTimeInvalid</span><br></pre></td></tr></table></figure>","more":"<p>看看<code>movieFragmentInterval</code> 属性的说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;*!</span><br><span class=\"line\"> @property movieFragmentInterval</span><br><span class=\"line\"> @abstract</span><br><span class=\"line\">    Specifies the frequency with which movie fragments should be written.</span><br><span class=\"line\"></span><br><span class=\"line\"> @discussion</span><br><span class=\"line\">    When movie fragments are used, a partially written QuickTime movie file whose writing is unexpectedly interrupted can be successfully opened and played up to multiples of the specified time interval. A value of kCMTimeInvalid indicates that movie fragments should not be used, but that only a movie atom describing all of the media in the file should be written. The default value of this property is ten seconds.</span><br><span class=\"line\"></span><br><span class=\"line\">    Changing the value of this property will not affect the movie fragment interval of the file currently being written, if there is one.</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">@property(nonatomic) CMTime movieFragmentInterval;</span><br></pre></td></tr></table></figure>\n\n<p>用拙略的英语水平翻译一下就是,<code>movieFragmentInterval</code>这东西代表一个时间间隔,每隔x秒就会把视频片段写入内存,这是为了保证当意外中断视频文件写入的时候还可以有一个可以播放的视频片段,默认是十秒,如果你给他赋了这个值<code>kCMTimeInvalid</code>,就表示要一直写入直到调用某个方法结束视频录制,之后他就会给视频文件加上文件尾部,所以如果没有设置这个值的话,十秒到二十秒的视频中间就会出现没声音的状况.</p>"},{"title":"C++基础","author":"Arclin","abbrlink":"f9a964a9","date":"2019-10-15T05:17:00.000Z","_content":"在iOS开发过程中，有时候会用到一些C++的库，为了避免大家用到这种库的时候一脸懵逼，这里总结一些基础知识，不写C++没关系，起码当库出了什么问题的时候至少能看懂逻辑（或许吧）。\n\n这里全部都是基础语法知识，没事的时候可以看看熟悉一下。\n\n<!-- more -->\n\n## 指针和引用\n\n略\n\n还是简单说一下：`.`是对象访问属性的操作符，`->`是指针访问指针属性的操作符，\n`(*a).b`=>`a->b`\n\n## 权限访问\n\npublic:   可以被任意实体访问\n\nprotected:只允许子类及本类的成员函数访问\n\nprivate:只允许本类的成员函数访问\n\n## 函数\n\n### 默认参数\n\n跟Swift差不多\n\n```\nint func (int a , int b = 10, int c = 10); // 声明中有默认参数，实现中不能有默认参数，比如下面这么写就会报错\n// 声明和实现只能其中一个有默认参数\nint func (int a , int b = 10, int c = 10) { // 形参默认值，当b有默认值的时候，后面的参数都需要有默认值，不能b有c没有，但是可以c有b没有\n\t return a + b + c;\n}\n```\n\n### 占位参数（没啥用）\n\n```\nvoid func(int a,int = 0) { // 占位参数可以有默认参数，也可以没有\n\tcout << a << endl;\n}\n\nfunc(1,2);\n```\n\n其实主要是用与兼容C语言的不规范写法，因为在C语言中，传参个数可以比函数声明的参数个数还多，比如`func(1,2,3,4,5)`,会警告但是不会报错，但是C++这么写就会报错，所以为了兼容C语言的调用方式，就用占位参数，占个位但是不用它，这样子就不会报错。\n\n### 函数重载\n\n同一个作用域，函数名相同，参数个数不同/类型不同/顺序不同\n\n**函数的返回值不可以作为函数重载的条件**\n\n#### 语法\n\n```\nvoid func() {}\nvoid func(int a) {}\nvoid func(double a) {}\nvoid func(int a, double b) {}\nvoid func(double a, int b) {}\nint func() {} // 这个会报错\n```\n\n#### 特殊情况\n\n```\n// 引用作为重载的条件\nvoid func(int &a) { // 方法1\n\tcout << \"func(int &a)\" << endl;\n}\nvoid func(cont int &a) {  // 方法2\n\tcout << \"func(cont int &a)\" << endl;\n}\n\nint a = 10;\nfunc(a); // 方法1\n\nfunc(10); // 方法2 因为 const int &a = 10; 合法，int &a = 10; 不合法\n\n// 函数重载碰到默认参数\nvoid func2(int a) {\n\tcout << \"func2(int a)\" << endl;\n}\n\nvoid func2(int a,int b = 10) {\n\tcout << \"func2(int a, int b)\" << endl;\n}\n\nfunc2(10); // 出现歧义（二义性），两个方法都能走，报错，所以建议函数重载的时候不要带默认参数\n```\n\n## struct 和 class 的区别\n\n`struct`默认权限为`public`\n`class`默认权限为`private`\n\n## 构造函数和析构函数\n\n```\n#include <iostream>\nclass Person\n{\npublic:\n\tPerson() {\n       cout << \"默认构造函数：系统会默认生成\" << endl;\n    }\n\t\n\tPerson(int age) {\n\t\tcout << \"带参数构造函数，写了这个系统就不生成无参构造函数\" << endl;\n\t\tthis->_age = age;\n\t}\n\t\n\tPerson(int age) : _height(15) {\n\t\tcout << \"初始化部分参数的构造函数\" << endl;\n\t\tthis->_age = age;\n\t}\n\t\n\tPerson(int age, int height) : _height(height) {\n\t\tcout << \"初始化部分参数的构造函数,并且顺便赋值了_height属性\" << endl;\n\t\tthis->_age = age;\n\t}\n\t\n\tPerson(const Person &person) {\n\t\tcout << \"浅拷贝函数：系统会默认生成\" << endl;\n\t\t// 如果要深拷贝的话自己手动生成、赋值对象属性。\n\t\t//如果自己写拷贝构造函数的话，系统不提供其他普通构造函数（有/无参）\n\t}\n\t\n\t~Person() {\n       cout<<\"析构函数：系统默认生成\"<<endl;\n    }\n\t\n\t//int age; // 不建议使用跟形参同名的成员变量\n\tint _age; // 带个下划线吧\n\tint _height;\n\tSomeClass property; // 别的类的属性：构造时会优先进入该类构造函数，析构时会优先进入Person的析构函数，再走这个类的析构函数\n};\n\n\nint main() {\n\tPerson p1; // 这样子就实例化了\n\tPerson p2(11); // age = 11\n\tPerson p3(11,160); // age = 11 height = 160\n\treturn 0;\n}\n```\n\n## 链式调用函数\n\n在上面的Person类内加多这么一个方法\n```\nPerson& addAge(Person &p) {\n\tthis->_age += p._Age;\n\treturn *this; // 返回当前对象指针！！！\n}\n\n\nPerson pp(20);\nPerson pp2(10);\npp.addAge(pp2).addAge(pp2).addAge(pp2); // 爽快地链式调用\n```\n\n## 静态方法\n\n```\nclass Person {\npublic:\n\tstatic void func() {\n\t\tcout << \"静态方法只能访问静态常量\" << test << endl;\n\t}\n\t\n\tstatic int test;\n};\n\nint main() {\n\tPerson p;\n\tp.func(); // 可以这么调\n\tPerson::func(); // 也可以通过类名直接调\n\treturn 0;\n}\n```\n\n## 常函数和常对象\n\n```\n#include <string>\nclass Person {\npublic:\n\tvoid funcA() const {\n//\t\tthis->_name = \"test\";  常函数不可以访问普通成员属性\n\t\tthis->_age = 1; //常函数可以访问被mutable修饰的成员属性\n\t}\n\tstring _name;\n\tmutable int _age;\n\t\n\tvoid funcB() {\n\t\t\n\t}\n}\n\nint main() {\n\tconst Person p;\n//\tp.funcB(); // 常对象不能访问普通函数\n\tp.funcA(); // 常对象只能访问常函数\n\treutrn 0;\n}\n```\n\n## 在类外部实现函数\n\n```\nclass Person {\npublic: // 需要是public函数才可以这么玩\n\tPerson(); // 要在外部实现的都得事先声明\n\tvoid test();\n};\n\nPerson::Person() {\n\n}\n\nvoid Person::test() {\n\n}\n```\n\n## 友元函数\n\n友元函数可以访问被`private`修饰的属性\n\n\n### 全局函数做友元\n```\n\nclass Building {\n    // 友元函数 可以访问私有属性\n    friend void visitor(Building &building);\npublic:\n    Building() {\n        m_SittingRoom = \"客厅\";\n        m_Bedroom = \"卧室\";\n    }\n    string m_SittingRoom;\nprivate:\n    string m_Bedroom;\n};\n\nvoid visitor(Building &building) {\n\tcout << \"全局函数\" << building.m_SittingRoom << endl;\n    cout << \"全局函数\" << building.m_Bedroom << endl;\n}\n```\n\n> 顺带一提：如果入参是引用的话（`&building`）,那么可以直接通过点语法访问成员属性，如果入参是指针的话（`*building`），那么就通过`->`访问，如（building->m_Bedroom）\n\n> 顺带再提，两种函数声明和调用方式的不同\n\n```\nvoid visitor(Building &building) {\n    cout << \"全局函数\" << building.m_SittingRoom << endl;\n}\n\nvoid visitor2(Building *building) {\n    cout << \"全局函数\" << building->m_SittingRoom << endl;\n}\n\nint main() {\n    \n    Building building;  // 生成对象\n    visitor(building);  // 直接传对象\n    visitor2(&building); // 传对象地址\n}\n\n```\n\n### 友元类\n\n```\nclass Building {\n    friend class Visitor; // 这个类下的所有函数都可以访问它的私有属性\npublic:\n    Building() {\n        m_Bedroom = \"卧室\";\n    }\nprivate:\n    string m_Bedroom;\n};\n\nclass Visitor\n{\npublic:\n\tVisitor() {\n\t\tbuilding = new Building;\n\t}\n\tvoid visit();\n\tBuilding *building;\n};\n\nvoid Visitor::visit() {\n\tcout << building->m_Bedroom << endl;\n}\n\nint main() {\n\tVisitor v;\n\tv.visit();\n\treturn 0;\n}\n\n```\n\n### 成员函数做友元函数\n\n```\nclass Building;\nclass Visitor\n{\npublic:\n    Visitor();\n    void visit();\n    Building *building;\n};\n\nclass Building {\n    friend void Visitor::visit(); // 指定Visitor的visit成员函数可以访问私有属性\npublic:\n    Building() {\n        m_Bedroom = \"卧室\";\n    }\nprivate:\n    string m_Bedroom;\n};\n\n// 为什么这个构造函数要写外面，不能写里面？\n// 因为Visitor需要在Building上面定义，不然不给定义Visitor上的友元函数，然后因为Visitor内有Building的属性，所以要声明一下class Building; 但是因为只是声明没有实现，所以就不能new Building;了，那就只能把这个通过类外实现的方式写在Building定义的下面。\nVisitor::Visitor() {  \n    building = new Building;\n}\n\nvoid Visitor::visit() {\n    cout << building->m_Bedroom << endl;\n}\n\nint main() {\n    Visitor v;\n    v.visit();\n    return 0;\n}\n\n```\n\n## 运算符重载\n\n跟Swift差不多\n\n### 成员函数的运算符重载\n\n```\nclass Animal {\npublic:\n    Animal operator + (Animal &a) {\n        Animal temp;\n        temp.m_A = this -> m_A + a.m_A;\n        return temp;\n    }\n    int m_A;\n};\n\nAnimal a;\na.m_A = 1;\nAnimal b;\nb.m_A = 2;\nAnimal c = a + b;\ncout << c.m_A << endl; // 输出 3\n```\n\n本质：`Animal c = a.operator+(b);`\n\n### 全局函数的运算符重载\n\n```\nAnimal operator - (Animal &a, Animal &b) {\n    Animal temp;\n    temp.m_A = a.m_A - b.m_A;\n    return temp;\n}\n\nAnimal a;\na.m_A = 1;\nAnimal b;\nb.m_A = 2;\nAnimal c = a - b;\ncout << c.m_A << endl; // 输出 -1\n```\n\n本质：`Animal c = operator-(a,b);`\n\n### 运算符重载也可以发生函数重载\n\n```\nAnimal operator + (int a, Animal &b) {\n    Animal temp;\n    temp.m_A = a + b.m_A;\n    return temp;\n}\nAnimal a;\na.m_A = 1;\nAnimal d = 10 + a;\ncout << d.m_A << endl; // 输出 11\n```\n\n本质：`Animal d = operator+(10,a);`\n\n\n### 左移运算符重载（比较常见输出对象细节）\n\n```\nclass MyInteger {\n    friend ostream& operator<<(ostream& cout,MyInteger myInt);\npublic:\n    MyInteger() {\n        this->my_int = 0;\n    }\nprivate:\n    int my_int;\n};\n\n// 必须是全局函数重载 ostream是cout的类型，为了能链式调用所以返回引用ostream&\nostream& operator<<(ostream& cout,MyInteger myInt) {\n    cout << myInt.my_int; // 返回对象细节\n    return cout;\n}\n\nint main() {\n    MyInteger myInt;\n    cout << myInt << endl; // 输出 my_int 的值 0\n\treturn 0;\n}\n```\n\n### 关系运算符重载\n\nSwift经常使用，参见`Equable`，`Comparable`协议\n\n```\nclass Person\n{\npublic:\n    bool operator==(Person &p) {\n        if (this->m_Name == p.m_Name) {\n            return true;\n        }\n        return false;\n    }\n    bool operator!=(Person &p) {\n        if (this->m_Name != p.m_Name) {\n            return true;\n        }\n        return false;\n    }\n\tstring m_Name;\n};\n\nint main() {\n\tPerson p1; p1.m_Name = \"A\";\n    Person p2; p2.m_Name = \"A\";\n    if (p1 == p2) {\n        cout << \"Equal\" << endl; // 输出\n    } else {\n        cout << \"Different\" << endl;\n    }\n\n    if (p1 != p2) {\n        cout << \"Different\" << endl;\n    } else {\n        cout << \"Equal\" << endl; // 输出\n    }\n\treturn 0;\n}\n```\n\n### 函数调用运算符的重载（骚操作）\n\n因为用起来很像函数，所以又叫做仿函数，STL里相当多这种骚操作\n\n```\nclass MyInteger {\n\tint operator()(int a,int b) {\n        return a + b;\n    }\n};\n\nint main() {\n    // MyInteger() ：匿名对象\n    int result = MyInteger()(1,2);\n\n    MyInteger i;\n    int result2 = i(5,2);\n\n    cout << result << endl;  // 5\n    cout << result2 << endl; // 7\n}\n\n```\n\n## 继承\n\nC++有多继承，灰常厉害\n\n### 继承方式\n\n三种继承方式`public`,`protected`,`private`，决定着继承下来的属性和方法以什么形式修饰，`class`默认`private`,`struct`默认`public`（没错，C++中结构体可以被继承）\n父类的所有非静态属性会被继承，包括`private`类型的，但是`private`类型的默认隐藏，子类无法访问。\n\n继承语法：\n\n```\nclass SubClass : public SuperClass {\n\n};\n```\n\n### 构造和析构\n\n父类先构造，子类先析构\n\n```\nsuperClass()\nsubClass()\n~subClass()\n~superClass()\n```\n\n### 同名属性/函数/静态属性/静态函数的访问\n\n假如子类和父类拥有相同的名字的属性/函数/静态属性/静态函数，则直接调用子类对象的话都是访问子类的，如果要访问父类的话要添加作用域。\n\n```\nclass Base {\npublic:\n    int _a = 1;\n    static int _b;\n    static void staticFunc() {\n        cout << \"Base staticFunc()\" << endl;\n    }\n    void Func() {\n        cout << \"Base Func()\" << endl;\n    }\n};\nint Base::_b = 10; // 静态成员变量要在外面赋值\n\nclass Sub1 : public Base {\npublic:\n    int _a = 2;\n    static int _b;\n    static void staticFunc() {\n        cout << \"SubClass staticFunc()\" << endl;\n    }\n    void Func() {\n        cout << \"SucClass Func()\" << endl;\n    }\n};\nint Sub1::_b = 20;\n\nint main() {\n\n    Sub1 s;\n    // 直接调用\n    cout << s._a << endl;\n    // 调用父类的\n    cout << s.Base::_a << endl;\n\n    // 静态直接调用\n    cout << s._b << endl;\n    // 静态调用父类的\n    cout << s.Base::_b << endl;\n\n    // 静态直接调用\n    cout << Sub1::_b << endl;\n    // 静态调用父类的\n    cout << Sub1::Base::_b << endl;\n\n    // 直接调用\n    s.Func();\n    // 调用父类的\n    s.Base::Func();\n\n    // 静态直接调用\n    s.staticFunc();\n    // 静态调用父类的\n    s.Base::staticFunc();\n\n    // 静态直接调用\n    Sub1::staticFunc();\n    // 静态调用父类的\n    Sub1::Base::staticFunc();\n\n    return 0;\n}\n```\n\n### 多继承\n\n不建议使用，因为麻烦事多\n\n语法：(参照上面的代码)\n```\nclass Other {\npublic:\n    void Func() {\n        cout << \"Ohter Func()\" << endl;\n    }\n};\n//...略\nclass Sub1 : public Base , public Other {\n//...略\n}\n```\n\n当多个父类中出现同名属性/方法时，需要加作用域指定父类`s.Base::Func(); / s.Other::Func();`\n\n### 菱形继承（钻石继承）\n\n两个子类继承同一个基类，\n又有某个类同时继承着两个子类\n\n举例\n```\nclass Base { int age };\n\nclass Sub1: public Base {};\nclass Sub2: public Base {};\n\nclass SubSub: public Sub1, public Sub2 {};\n```\n\n这时候SubSub会有两个父类，有两份 age 属性，造成资源浪费\n\n这时候用虚继承(`virtual`)解决问题\n\n```\nclass Base { public: int age }; // 这时候成为虚基类\n\nclass Sub1: virtual public Base {};\nclass Sub2: virtual public Base {};\n\nclass SubSub: public Sub1, public Sub2 {};\n```\n这时候age属性成为共享属性，最后谁改了就是谁的值\n\n```\nSubSub s;\ns.Sub1::age = 1;\ns.Sub2::age = 10;\ncout << s.Sub1::age << endl; // 10\ncout << s.Sub2::age << endl; // 10\ncout << s.age << endl; // 10\n```\n\n## 多态\n\nC++中，多态分两类\n\n静态多态：函数重载和运算符重载属于静态多态，复用函数名\n动态多态：子类和虚函数实现运行时多态\n\n区别：\n\n静态多态的函数地址早绑定，编译阶段确定函数地址\n动态多态的函数地址晚绑定，运行阶段确定函数地址\n\n动态多态满足条件：\n1. 有继承关系\n2. 子类重写父类虚函数\n\n动态多态使用\n父类的指针或者引用指向子类对象\n\n\n静态多态举例：\n```\nclass Animal {\npublic:\n    void speak() {\n        cout << \"Animal Speak\" << endl;\n    }\n};\nclass Cat: public Animal\n{\npublic:\n    void speak() {\n        cout << \"Cat Speak\" << endl;\n    }\n};\nvoid SomeoneSpeak(Animal &animal) {\n    animal.speak();\n}\n\nint main() {\n    Cat c;\n    SomeoneSpeak(c); // 由于SomeoneSpeak(Animal &animal)，编译期间已经确定入参类型，所以输出 Animal Speak\n```\n\n如果想输出`Cat Speak`，只需进行如下修改\n\n```\nclass Animal {\npublic:\n    virtual void speak() { // 虚函数，可以告知由于SomeoneSpeak(Animal &animal)运行时再确定入参类型\n        cout << \"Animal Speak\" << endl;\n    }\n};\n```\n\n经常地，这种情况下也是动态多态，最后会输出`Cat Speak`\n```\nAnimal *a = new Cat;\na->speak();\n```\n\n### 纯虚函数和抽象类\n\n父类的虚函数的实现没什么意义，所以上面的虚函数代码改写为`纯虚函数`\n\n```\nvirtual void speak() = 0;\n```\n\n当类中有了纯虚函数，则这个类称为`抽象类`\n\n抽象类**无法实例化对象**，并且**子类必须重写父类的纯虚函数**，否则也成为`抽象类`\n\n### 虚析构和纯虚析构\n\n当子类在堆区创建数据的时候，需要手动释放，父类需要添加虚析构或者纯虚析构函数，否则子类可能不走析构函数\n\n比如上面的`Animate`父类，我们补充一下\n\n```\nclass Animal {\npublic:\n    virtual ~Animal() = 0; // 纯虚析构\n};\n\nAnimal::~Animal() { // 析构实现\n    cout << \"Animal is Delete\" << endl;\n}\n```\n\n## 文件操作\n\n文件打开方式\n\n`ios::in`:读文件\n`ios::out`:写文件\n`ios::ate`:初始位置，文件尾\n`ios:app`:追加写文件\n`ios:trunc`:如果文件存在先删除，再创建\n`ios:binary`:二进制方式\n\n同时两种方式则使用`|`的方式，比如`ios::in|ios:binary`\n\n### 写文件\n\n```\nofstream stream;\n\nstream.open(\"Test.txt\",ios::out);\n\nstream << \"Line 1\" << endl;\nstream << \"Line 2\" << endl;\nstream << \"Line 3\" << endl;\n\nstream.close();\n\n```\n\n### 读文件\n\n```\nifstream ifs;\nifs.open(\"Test.txt\",ios::out);\n\nif(!ifs.is_open()) {\n\tcout << \"打开文件失败\" << endl;\n\treturn 0;\n}\n\nstring buf;\nwhile (getline(ifs, buf)) { // 一行行读取\n\tcout << buf << endl;\n}\n\nifs.close();\n```\n\n## 类模板\n\n### 构建类模板与类模板做参数\n\n```\ntemplate<class NameType,class AgeType>\n\nclass Person {\npublic:\n    Person(NameType name, AgeType age) {\n        this->_age = age;\n        this->_name = name;\n    }\n    AgeType _age;\n    NameType _name;\n};\n\nint main() {\n\n\t// 不会自动类型推导，需要自己显式声明类型\n    Person<string,int> p(\"Haha\",123);\n\n    cout << p._name << \" \" << p._age << endl;\n\n    return 0;\n}\n\n```\n\n可以给类模板添加默认类型\n\n`template<class NameType,class AgeType = int>`\n\n这样子调用的时候就可以不全声明类型了\n\n`Person<string> p(\"Haha\",123);`\n\n类模板做参数\n```\n// 指定类型的类模板做参数\nvoid print(Person<string,int> &p) {\n    p.showPerson();\n}\n\n// 模板化参数的类模板做参数\ntemplate<class T1,class T2>\nvoid print2(Person<T1, T2> &p) {\n    p.showPerson();\n}\n\n// 模板化类做参数\ntemplate<class T>\nvoid print3(T &p) {\n    p.showPerson();\n}\n\nint main() {\n    Person<string,int> p(\"Haha\",123);\n    print(p);\n    print2(p);\n    print3(p);\n    return 0;\n}\n```\n\n### 类模板与继承\n\n继承时需要指定类型\n\n```\ntemplate<class T>\nclass Base\n{\npublic:\n    T m;\n};\n\nclass SubClass: public Base<int> { // 指定T的类型\npublic:\n    void print() {\n        cout << m << endl;\n    }\n};\n```\n\n如果不想指定类型，那么可以模板化子类\n\n```\n\ntemplate<class T>\nclass Base\n{\npublic:\n    T m;\n};\n\ntemplate<class T1,class T2>\nclass SubClass: public Base<T1> {\npublic:\n    SubClass(T1 a, T2 b) {\n\n    }\n    T2 k;\n};\n\nint main() {\n\tSubClass<string, int> c(\"String\",1);\n\treturn 0;\n}\n```\n\n\n## STL 之 Vector容器\n\n```\nvector<int> v1; // 初始化指定容器内元素类型\nv1.assign(10, 1); // 插入10个1，也可以传入其他vector,比如v1.assign(v0.begin,v0.end); 或者直接 v1 = v0; 只要保证是同种类型就好\nfor (vector<int>::iterator i = v1.begin(); i != v1.end() ; i++) {\n\tcout << *i << endl;\n} // 打印10个1\ncout << \"Size = \" << v1.size() << endl; // 长度 10\ncout << \"isEmpty = \" << v1.empty() << endl; // 判空 0\ncout << \"capacity = \" << v1.capacity() << endl; // 容量 10\nv1.resize(20,20); // 调整容量为20，多出来的位置用20填充，这里的20可以不传，默认0\ncout << \"capacity = \" << v1.capacity() << endl; // 现在容量变成20\n\nv1.pop_back(); // 删除最后一个元素\n\ncout << \"Size = \" << v1.size() << endl; // 长度 19\ncout << \"capacity = \" << v1.capacity() << endl; // 容量不变 20\n\nv1.insert(v1.begin() + 1, 199); // 下标为1的位置插入元素199\nv1.insert(v1.begin() + 1, 2, 199); // 下标为1的位置插入两个元素199\nv1.erase(v1.begin() + 2); // 删除第二个元素\nv1.erase(v1.begin() + 2 , v1.begin() + 3); // 删除第二个到第三个元素\nv1.clear(); // 清空容器\n\ncout << \"第二个元素是\" << v1.at(1) << endl;\ncout << \"第三个元素是\" << v1[2] << endl;\ncout << \"第一个元素\" << v1.front() << endl;\ncout << \"最后一个元素\" << v1.back() << endl;\n\nv1.reverse(100000); // 预留空间，减少以后动态拓展的次数\n\nv1.swap(v0); // 交换元素，假如v1的预留空间很大，可以通过交换一个小预留空间的容器达到压缩内存的效果\n\n```","source":"_posts/C-基础.md","raw":"title: C++基础\nauthor: Arclin\nabbrlink: f9a964a9\ntags:\n  - C++\ncategories:\n  - C++\ndate: 2019-10-15 13:17:00\n---\n在iOS开发过程中，有时候会用到一些C++的库，为了避免大家用到这种库的时候一脸懵逼，这里总结一些基础知识，不写C++没关系，起码当库出了什么问题的时候至少能看懂逻辑（或许吧）。\n\n这里全部都是基础语法知识，没事的时候可以看看熟悉一下。\n\n<!-- more -->\n\n## 指针和引用\n\n略\n\n还是简单说一下：`.`是对象访问属性的操作符，`->`是指针访问指针属性的操作符，\n`(*a).b`=>`a->b`\n\n## 权限访问\n\npublic:   可以被任意实体访问\n\nprotected:只允许子类及本类的成员函数访问\n\nprivate:只允许本类的成员函数访问\n\n## 函数\n\n### 默认参数\n\n跟Swift差不多\n\n```\nint func (int a , int b = 10, int c = 10); // 声明中有默认参数，实现中不能有默认参数，比如下面这么写就会报错\n// 声明和实现只能其中一个有默认参数\nint func (int a , int b = 10, int c = 10) { // 形参默认值，当b有默认值的时候，后面的参数都需要有默认值，不能b有c没有，但是可以c有b没有\n\t return a + b + c;\n}\n```\n\n### 占位参数（没啥用）\n\n```\nvoid func(int a,int = 0) { // 占位参数可以有默认参数，也可以没有\n\tcout << a << endl;\n}\n\nfunc(1,2);\n```\n\n其实主要是用与兼容C语言的不规范写法，因为在C语言中，传参个数可以比函数声明的参数个数还多，比如`func(1,2,3,4,5)`,会警告但是不会报错，但是C++这么写就会报错，所以为了兼容C语言的调用方式，就用占位参数，占个位但是不用它，这样子就不会报错。\n\n### 函数重载\n\n同一个作用域，函数名相同，参数个数不同/类型不同/顺序不同\n\n**函数的返回值不可以作为函数重载的条件**\n\n#### 语法\n\n```\nvoid func() {}\nvoid func(int a) {}\nvoid func(double a) {}\nvoid func(int a, double b) {}\nvoid func(double a, int b) {}\nint func() {} // 这个会报错\n```\n\n#### 特殊情况\n\n```\n// 引用作为重载的条件\nvoid func(int &a) { // 方法1\n\tcout << \"func(int &a)\" << endl;\n}\nvoid func(cont int &a) {  // 方法2\n\tcout << \"func(cont int &a)\" << endl;\n}\n\nint a = 10;\nfunc(a); // 方法1\n\nfunc(10); // 方法2 因为 const int &a = 10; 合法，int &a = 10; 不合法\n\n// 函数重载碰到默认参数\nvoid func2(int a) {\n\tcout << \"func2(int a)\" << endl;\n}\n\nvoid func2(int a,int b = 10) {\n\tcout << \"func2(int a, int b)\" << endl;\n}\n\nfunc2(10); // 出现歧义（二义性），两个方法都能走，报错，所以建议函数重载的时候不要带默认参数\n```\n\n## struct 和 class 的区别\n\n`struct`默认权限为`public`\n`class`默认权限为`private`\n\n## 构造函数和析构函数\n\n```\n#include <iostream>\nclass Person\n{\npublic:\n\tPerson() {\n       cout << \"默认构造函数：系统会默认生成\" << endl;\n    }\n\t\n\tPerson(int age) {\n\t\tcout << \"带参数构造函数，写了这个系统就不生成无参构造函数\" << endl;\n\t\tthis->_age = age;\n\t}\n\t\n\tPerson(int age) : _height(15) {\n\t\tcout << \"初始化部分参数的构造函数\" << endl;\n\t\tthis->_age = age;\n\t}\n\t\n\tPerson(int age, int height) : _height(height) {\n\t\tcout << \"初始化部分参数的构造函数,并且顺便赋值了_height属性\" << endl;\n\t\tthis->_age = age;\n\t}\n\t\n\tPerson(const Person &person) {\n\t\tcout << \"浅拷贝函数：系统会默认生成\" << endl;\n\t\t// 如果要深拷贝的话自己手动生成、赋值对象属性。\n\t\t//如果自己写拷贝构造函数的话，系统不提供其他普通构造函数（有/无参）\n\t}\n\t\n\t~Person() {\n       cout<<\"析构函数：系统默认生成\"<<endl;\n    }\n\t\n\t//int age; // 不建议使用跟形参同名的成员变量\n\tint _age; // 带个下划线吧\n\tint _height;\n\tSomeClass property; // 别的类的属性：构造时会优先进入该类构造函数，析构时会优先进入Person的析构函数，再走这个类的析构函数\n};\n\n\nint main() {\n\tPerson p1; // 这样子就实例化了\n\tPerson p2(11); // age = 11\n\tPerson p3(11,160); // age = 11 height = 160\n\treturn 0;\n}\n```\n\n## 链式调用函数\n\n在上面的Person类内加多这么一个方法\n```\nPerson& addAge(Person &p) {\n\tthis->_age += p._Age;\n\treturn *this; // 返回当前对象指针！！！\n}\n\n\nPerson pp(20);\nPerson pp2(10);\npp.addAge(pp2).addAge(pp2).addAge(pp2); // 爽快地链式调用\n```\n\n## 静态方法\n\n```\nclass Person {\npublic:\n\tstatic void func() {\n\t\tcout << \"静态方法只能访问静态常量\" << test << endl;\n\t}\n\t\n\tstatic int test;\n};\n\nint main() {\n\tPerson p;\n\tp.func(); // 可以这么调\n\tPerson::func(); // 也可以通过类名直接调\n\treturn 0;\n}\n```\n\n## 常函数和常对象\n\n```\n#include <string>\nclass Person {\npublic:\n\tvoid funcA() const {\n//\t\tthis->_name = \"test\";  常函数不可以访问普通成员属性\n\t\tthis->_age = 1; //常函数可以访问被mutable修饰的成员属性\n\t}\n\tstring _name;\n\tmutable int _age;\n\t\n\tvoid funcB() {\n\t\t\n\t}\n}\n\nint main() {\n\tconst Person p;\n//\tp.funcB(); // 常对象不能访问普通函数\n\tp.funcA(); // 常对象只能访问常函数\n\treutrn 0;\n}\n```\n\n## 在类外部实现函数\n\n```\nclass Person {\npublic: // 需要是public函数才可以这么玩\n\tPerson(); // 要在外部实现的都得事先声明\n\tvoid test();\n};\n\nPerson::Person() {\n\n}\n\nvoid Person::test() {\n\n}\n```\n\n## 友元函数\n\n友元函数可以访问被`private`修饰的属性\n\n\n### 全局函数做友元\n```\n\nclass Building {\n    // 友元函数 可以访问私有属性\n    friend void visitor(Building &building);\npublic:\n    Building() {\n        m_SittingRoom = \"客厅\";\n        m_Bedroom = \"卧室\";\n    }\n    string m_SittingRoom;\nprivate:\n    string m_Bedroom;\n};\n\nvoid visitor(Building &building) {\n\tcout << \"全局函数\" << building.m_SittingRoom << endl;\n    cout << \"全局函数\" << building.m_Bedroom << endl;\n}\n```\n\n> 顺带一提：如果入参是引用的话（`&building`）,那么可以直接通过点语法访问成员属性，如果入参是指针的话（`*building`），那么就通过`->`访问，如（building->m_Bedroom）\n\n> 顺带再提，两种函数声明和调用方式的不同\n\n```\nvoid visitor(Building &building) {\n    cout << \"全局函数\" << building.m_SittingRoom << endl;\n}\n\nvoid visitor2(Building *building) {\n    cout << \"全局函数\" << building->m_SittingRoom << endl;\n}\n\nint main() {\n    \n    Building building;  // 生成对象\n    visitor(building);  // 直接传对象\n    visitor2(&building); // 传对象地址\n}\n\n```\n\n### 友元类\n\n```\nclass Building {\n    friend class Visitor; // 这个类下的所有函数都可以访问它的私有属性\npublic:\n    Building() {\n        m_Bedroom = \"卧室\";\n    }\nprivate:\n    string m_Bedroom;\n};\n\nclass Visitor\n{\npublic:\n\tVisitor() {\n\t\tbuilding = new Building;\n\t}\n\tvoid visit();\n\tBuilding *building;\n};\n\nvoid Visitor::visit() {\n\tcout << building->m_Bedroom << endl;\n}\n\nint main() {\n\tVisitor v;\n\tv.visit();\n\treturn 0;\n}\n\n```\n\n### 成员函数做友元函数\n\n```\nclass Building;\nclass Visitor\n{\npublic:\n    Visitor();\n    void visit();\n    Building *building;\n};\n\nclass Building {\n    friend void Visitor::visit(); // 指定Visitor的visit成员函数可以访问私有属性\npublic:\n    Building() {\n        m_Bedroom = \"卧室\";\n    }\nprivate:\n    string m_Bedroom;\n};\n\n// 为什么这个构造函数要写外面，不能写里面？\n// 因为Visitor需要在Building上面定义，不然不给定义Visitor上的友元函数，然后因为Visitor内有Building的属性，所以要声明一下class Building; 但是因为只是声明没有实现，所以就不能new Building;了，那就只能把这个通过类外实现的方式写在Building定义的下面。\nVisitor::Visitor() {  \n    building = new Building;\n}\n\nvoid Visitor::visit() {\n    cout << building->m_Bedroom << endl;\n}\n\nint main() {\n    Visitor v;\n    v.visit();\n    return 0;\n}\n\n```\n\n## 运算符重载\n\n跟Swift差不多\n\n### 成员函数的运算符重载\n\n```\nclass Animal {\npublic:\n    Animal operator + (Animal &a) {\n        Animal temp;\n        temp.m_A = this -> m_A + a.m_A;\n        return temp;\n    }\n    int m_A;\n};\n\nAnimal a;\na.m_A = 1;\nAnimal b;\nb.m_A = 2;\nAnimal c = a + b;\ncout << c.m_A << endl; // 输出 3\n```\n\n本质：`Animal c = a.operator+(b);`\n\n### 全局函数的运算符重载\n\n```\nAnimal operator - (Animal &a, Animal &b) {\n    Animal temp;\n    temp.m_A = a.m_A - b.m_A;\n    return temp;\n}\n\nAnimal a;\na.m_A = 1;\nAnimal b;\nb.m_A = 2;\nAnimal c = a - b;\ncout << c.m_A << endl; // 输出 -1\n```\n\n本质：`Animal c = operator-(a,b);`\n\n### 运算符重载也可以发生函数重载\n\n```\nAnimal operator + (int a, Animal &b) {\n    Animal temp;\n    temp.m_A = a + b.m_A;\n    return temp;\n}\nAnimal a;\na.m_A = 1;\nAnimal d = 10 + a;\ncout << d.m_A << endl; // 输出 11\n```\n\n本质：`Animal d = operator+(10,a);`\n\n\n### 左移运算符重载（比较常见输出对象细节）\n\n```\nclass MyInteger {\n    friend ostream& operator<<(ostream& cout,MyInteger myInt);\npublic:\n    MyInteger() {\n        this->my_int = 0;\n    }\nprivate:\n    int my_int;\n};\n\n// 必须是全局函数重载 ostream是cout的类型，为了能链式调用所以返回引用ostream&\nostream& operator<<(ostream& cout,MyInteger myInt) {\n    cout << myInt.my_int; // 返回对象细节\n    return cout;\n}\n\nint main() {\n    MyInteger myInt;\n    cout << myInt << endl; // 输出 my_int 的值 0\n\treturn 0;\n}\n```\n\n### 关系运算符重载\n\nSwift经常使用，参见`Equable`，`Comparable`协议\n\n```\nclass Person\n{\npublic:\n    bool operator==(Person &p) {\n        if (this->m_Name == p.m_Name) {\n            return true;\n        }\n        return false;\n    }\n    bool operator!=(Person &p) {\n        if (this->m_Name != p.m_Name) {\n            return true;\n        }\n        return false;\n    }\n\tstring m_Name;\n};\n\nint main() {\n\tPerson p1; p1.m_Name = \"A\";\n    Person p2; p2.m_Name = \"A\";\n    if (p1 == p2) {\n        cout << \"Equal\" << endl; // 输出\n    } else {\n        cout << \"Different\" << endl;\n    }\n\n    if (p1 != p2) {\n        cout << \"Different\" << endl;\n    } else {\n        cout << \"Equal\" << endl; // 输出\n    }\n\treturn 0;\n}\n```\n\n### 函数调用运算符的重载（骚操作）\n\n因为用起来很像函数，所以又叫做仿函数，STL里相当多这种骚操作\n\n```\nclass MyInteger {\n\tint operator()(int a,int b) {\n        return a + b;\n    }\n};\n\nint main() {\n    // MyInteger() ：匿名对象\n    int result = MyInteger()(1,2);\n\n    MyInteger i;\n    int result2 = i(5,2);\n\n    cout << result << endl;  // 5\n    cout << result2 << endl; // 7\n}\n\n```\n\n## 继承\n\nC++有多继承，灰常厉害\n\n### 继承方式\n\n三种继承方式`public`,`protected`,`private`，决定着继承下来的属性和方法以什么形式修饰，`class`默认`private`,`struct`默认`public`（没错，C++中结构体可以被继承）\n父类的所有非静态属性会被继承，包括`private`类型的，但是`private`类型的默认隐藏，子类无法访问。\n\n继承语法：\n\n```\nclass SubClass : public SuperClass {\n\n};\n```\n\n### 构造和析构\n\n父类先构造，子类先析构\n\n```\nsuperClass()\nsubClass()\n~subClass()\n~superClass()\n```\n\n### 同名属性/函数/静态属性/静态函数的访问\n\n假如子类和父类拥有相同的名字的属性/函数/静态属性/静态函数，则直接调用子类对象的话都是访问子类的，如果要访问父类的话要添加作用域。\n\n```\nclass Base {\npublic:\n    int _a = 1;\n    static int _b;\n    static void staticFunc() {\n        cout << \"Base staticFunc()\" << endl;\n    }\n    void Func() {\n        cout << \"Base Func()\" << endl;\n    }\n};\nint Base::_b = 10; // 静态成员变量要在外面赋值\n\nclass Sub1 : public Base {\npublic:\n    int _a = 2;\n    static int _b;\n    static void staticFunc() {\n        cout << \"SubClass staticFunc()\" << endl;\n    }\n    void Func() {\n        cout << \"SucClass Func()\" << endl;\n    }\n};\nint Sub1::_b = 20;\n\nint main() {\n\n    Sub1 s;\n    // 直接调用\n    cout << s._a << endl;\n    // 调用父类的\n    cout << s.Base::_a << endl;\n\n    // 静态直接调用\n    cout << s._b << endl;\n    // 静态调用父类的\n    cout << s.Base::_b << endl;\n\n    // 静态直接调用\n    cout << Sub1::_b << endl;\n    // 静态调用父类的\n    cout << Sub1::Base::_b << endl;\n\n    // 直接调用\n    s.Func();\n    // 调用父类的\n    s.Base::Func();\n\n    // 静态直接调用\n    s.staticFunc();\n    // 静态调用父类的\n    s.Base::staticFunc();\n\n    // 静态直接调用\n    Sub1::staticFunc();\n    // 静态调用父类的\n    Sub1::Base::staticFunc();\n\n    return 0;\n}\n```\n\n### 多继承\n\n不建议使用，因为麻烦事多\n\n语法：(参照上面的代码)\n```\nclass Other {\npublic:\n    void Func() {\n        cout << \"Ohter Func()\" << endl;\n    }\n};\n//...略\nclass Sub1 : public Base , public Other {\n//...略\n}\n```\n\n当多个父类中出现同名属性/方法时，需要加作用域指定父类`s.Base::Func(); / s.Other::Func();`\n\n### 菱形继承（钻石继承）\n\n两个子类继承同一个基类，\n又有某个类同时继承着两个子类\n\n举例\n```\nclass Base { int age };\n\nclass Sub1: public Base {};\nclass Sub2: public Base {};\n\nclass SubSub: public Sub1, public Sub2 {};\n```\n\n这时候SubSub会有两个父类，有两份 age 属性，造成资源浪费\n\n这时候用虚继承(`virtual`)解决问题\n\n```\nclass Base { public: int age }; // 这时候成为虚基类\n\nclass Sub1: virtual public Base {};\nclass Sub2: virtual public Base {};\n\nclass SubSub: public Sub1, public Sub2 {};\n```\n这时候age属性成为共享属性，最后谁改了就是谁的值\n\n```\nSubSub s;\ns.Sub1::age = 1;\ns.Sub2::age = 10;\ncout << s.Sub1::age << endl; // 10\ncout << s.Sub2::age << endl; // 10\ncout << s.age << endl; // 10\n```\n\n## 多态\n\nC++中，多态分两类\n\n静态多态：函数重载和运算符重载属于静态多态，复用函数名\n动态多态：子类和虚函数实现运行时多态\n\n区别：\n\n静态多态的函数地址早绑定，编译阶段确定函数地址\n动态多态的函数地址晚绑定，运行阶段确定函数地址\n\n动态多态满足条件：\n1. 有继承关系\n2. 子类重写父类虚函数\n\n动态多态使用\n父类的指针或者引用指向子类对象\n\n\n静态多态举例：\n```\nclass Animal {\npublic:\n    void speak() {\n        cout << \"Animal Speak\" << endl;\n    }\n};\nclass Cat: public Animal\n{\npublic:\n    void speak() {\n        cout << \"Cat Speak\" << endl;\n    }\n};\nvoid SomeoneSpeak(Animal &animal) {\n    animal.speak();\n}\n\nint main() {\n    Cat c;\n    SomeoneSpeak(c); // 由于SomeoneSpeak(Animal &animal)，编译期间已经确定入参类型，所以输出 Animal Speak\n```\n\n如果想输出`Cat Speak`，只需进行如下修改\n\n```\nclass Animal {\npublic:\n    virtual void speak() { // 虚函数，可以告知由于SomeoneSpeak(Animal &animal)运行时再确定入参类型\n        cout << \"Animal Speak\" << endl;\n    }\n};\n```\n\n经常地，这种情况下也是动态多态，最后会输出`Cat Speak`\n```\nAnimal *a = new Cat;\na->speak();\n```\n\n### 纯虚函数和抽象类\n\n父类的虚函数的实现没什么意义，所以上面的虚函数代码改写为`纯虚函数`\n\n```\nvirtual void speak() = 0;\n```\n\n当类中有了纯虚函数，则这个类称为`抽象类`\n\n抽象类**无法实例化对象**，并且**子类必须重写父类的纯虚函数**，否则也成为`抽象类`\n\n### 虚析构和纯虚析构\n\n当子类在堆区创建数据的时候，需要手动释放，父类需要添加虚析构或者纯虚析构函数，否则子类可能不走析构函数\n\n比如上面的`Animate`父类，我们补充一下\n\n```\nclass Animal {\npublic:\n    virtual ~Animal() = 0; // 纯虚析构\n};\n\nAnimal::~Animal() { // 析构实现\n    cout << \"Animal is Delete\" << endl;\n}\n```\n\n## 文件操作\n\n文件打开方式\n\n`ios::in`:读文件\n`ios::out`:写文件\n`ios::ate`:初始位置，文件尾\n`ios:app`:追加写文件\n`ios:trunc`:如果文件存在先删除，再创建\n`ios:binary`:二进制方式\n\n同时两种方式则使用`|`的方式，比如`ios::in|ios:binary`\n\n### 写文件\n\n```\nofstream stream;\n\nstream.open(\"Test.txt\",ios::out);\n\nstream << \"Line 1\" << endl;\nstream << \"Line 2\" << endl;\nstream << \"Line 3\" << endl;\n\nstream.close();\n\n```\n\n### 读文件\n\n```\nifstream ifs;\nifs.open(\"Test.txt\",ios::out);\n\nif(!ifs.is_open()) {\n\tcout << \"打开文件失败\" << endl;\n\treturn 0;\n}\n\nstring buf;\nwhile (getline(ifs, buf)) { // 一行行读取\n\tcout << buf << endl;\n}\n\nifs.close();\n```\n\n## 类模板\n\n### 构建类模板与类模板做参数\n\n```\ntemplate<class NameType,class AgeType>\n\nclass Person {\npublic:\n    Person(NameType name, AgeType age) {\n        this->_age = age;\n        this->_name = name;\n    }\n    AgeType _age;\n    NameType _name;\n};\n\nint main() {\n\n\t// 不会自动类型推导，需要自己显式声明类型\n    Person<string,int> p(\"Haha\",123);\n\n    cout << p._name << \" \" << p._age << endl;\n\n    return 0;\n}\n\n```\n\n可以给类模板添加默认类型\n\n`template<class NameType,class AgeType = int>`\n\n这样子调用的时候就可以不全声明类型了\n\n`Person<string> p(\"Haha\",123);`\n\n类模板做参数\n```\n// 指定类型的类模板做参数\nvoid print(Person<string,int> &p) {\n    p.showPerson();\n}\n\n// 模板化参数的类模板做参数\ntemplate<class T1,class T2>\nvoid print2(Person<T1, T2> &p) {\n    p.showPerson();\n}\n\n// 模板化类做参数\ntemplate<class T>\nvoid print3(T &p) {\n    p.showPerson();\n}\n\nint main() {\n    Person<string,int> p(\"Haha\",123);\n    print(p);\n    print2(p);\n    print3(p);\n    return 0;\n}\n```\n\n### 类模板与继承\n\n继承时需要指定类型\n\n```\ntemplate<class T>\nclass Base\n{\npublic:\n    T m;\n};\n\nclass SubClass: public Base<int> { // 指定T的类型\npublic:\n    void print() {\n        cout << m << endl;\n    }\n};\n```\n\n如果不想指定类型，那么可以模板化子类\n\n```\n\ntemplate<class T>\nclass Base\n{\npublic:\n    T m;\n};\n\ntemplate<class T1,class T2>\nclass SubClass: public Base<T1> {\npublic:\n    SubClass(T1 a, T2 b) {\n\n    }\n    T2 k;\n};\n\nint main() {\n\tSubClass<string, int> c(\"String\",1);\n\treturn 0;\n}\n```\n\n\n## STL 之 Vector容器\n\n```\nvector<int> v1; // 初始化指定容器内元素类型\nv1.assign(10, 1); // 插入10个1，也可以传入其他vector,比如v1.assign(v0.begin,v0.end); 或者直接 v1 = v0; 只要保证是同种类型就好\nfor (vector<int>::iterator i = v1.begin(); i != v1.end() ; i++) {\n\tcout << *i << endl;\n} // 打印10个1\ncout << \"Size = \" << v1.size() << endl; // 长度 10\ncout << \"isEmpty = \" << v1.empty() << endl; // 判空 0\ncout << \"capacity = \" << v1.capacity() << endl; // 容量 10\nv1.resize(20,20); // 调整容量为20，多出来的位置用20填充，这里的20可以不传，默认0\ncout << \"capacity = \" << v1.capacity() << endl; // 现在容量变成20\n\nv1.pop_back(); // 删除最后一个元素\n\ncout << \"Size = \" << v1.size() << endl; // 长度 19\ncout << \"capacity = \" << v1.capacity() << endl; // 容量不变 20\n\nv1.insert(v1.begin() + 1, 199); // 下标为1的位置插入元素199\nv1.insert(v1.begin() + 1, 2, 199); // 下标为1的位置插入两个元素199\nv1.erase(v1.begin() + 2); // 删除第二个元素\nv1.erase(v1.begin() + 2 , v1.begin() + 3); // 删除第二个到第三个元素\nv1.clear(); // 清空容器\n\ncout << \"第二个元素是\" << v1.at(1) << endl;\ncout << \"第三个元素是\" << v1[2] << endl;\ncout << \"第一个元素\" << v1.front() << endl;\ncout << \"最后一个元素\" << v1.back() << endl;\n\nv1.reverse(100000); // 预留空间，减少以后动态拓展的次数\n\nv1.swap(v0); // 交换元素，假如v1的预留空间很大，可以通过交换一个小预留空间的容器达到压缩内存的效果\n\n```","slug":"C-基础","published":1,"updated":"2021-04-12T06:07:04.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog4p000945n07qtz8j79","content":"<p>在iOS开发过程中，有时候会用到一些C++的库，为了避免大家用到这种库的时候一脸懵逼，这里总结一些基础知识，不写C++没关系，起码当库出了什么问题的时候至少能看懂逻辑（或许吧）。</p>\n<p>这里全部都是基础语法知识，没事的时候可以看看熟悉一下。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"指针和引用\"><a href=\"#指针和引用\" class=\"headerlink\" title=\"指针和引用\"></a>指针和引用</h2><p>略</p>\n<p>还是简单说一下：<code>.</code>是对象访问属性的操作符，<code>-&gt;</code>是指针访问指针属性的操作符，<br><code>(*a).b</code>=&gt;<code>a-&gt;b</code></p>\n<h2 id=\"权限访问\"><a href=\"#权限访问\" class=\"headerlink\" title=\"权限访问\"></a>权限访问</h2><p>public:   可以被任意实体访问</p>\n<p>protected:只允许子类及本类的成员函数访问</p>\n<p>private:只允许本类的成员函数访问</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><p>跟Swift差不多</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int func (int a , int b &#x3D; 10, int c &#x3D; 10); &#x2F;&#x2F; 声明中有默认参数，实现中不能有默认参数，比如下面这么写就会报错</span><br><span class=\"line\">&#x2F;&#x2F; 声明和实现只能其中一个有默认参数</span><br><span class=\"line\">int func (int a , int b &#x3D; 10, int c &#x3D; 10) &#123; &#x2F;&#x2F; 形参默认值，当b有默认值的时候，后面的参数都需要有默认值，不能b有c没有，但是可以c有b没有</span><br><span class=\"line\">\t return a + b + c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"占位参数（没啥用）\"><a href=\"#占位参数（没啥用）\" class=\"headerlink\" title=\"占位参数（没啥用）\"></a>占位参数（没啥用）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void func(int a,int &#x3D; 0) &#123; &#x2F;&#x2F; 占位参数可以有默认参数，也可以没有</span><br><span class=\"line\">\tcout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func(1,2);</span><br></pre></td></tr></table></figure>\n\n<p>其实主要是用与兼容C语言的不规范写法，因为在C语言中，传参个数可以比函数声明的参数个数还多，比如<code>func(1,2,3,4,5)</code>,会警告但是不会报错，但是C++这么写就会报错，所以为了兼容C语言的调用方式，就用占位参数，占个位但是不用它，这样子就不会报错。</p>\n<h3 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h3><p>同一个作用域，函数名相同，参数个数不同/类型不同/顺序不同</p>\n<p><strong>函数的返回值不可以作为函数重载的条件</strong></p>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void func() &#123;&#125;</span><br><span class=\"line\">void func(int a) &#123;&#125;</span><br><span class=\"line\">void func(double a) &#123;&#125;</span><br><span class=\"line\">void func(int a, double b) &#123;&#125;</span><br><span class=\"line\">void func(double a, int b) &#123;&#125;</span><br><span class=\"line\">int func() &#123;&#125; &#x2F;&#x2F; 这个会报错</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"特殊情况\"><a href=\"#特殊情况\" class=\"headerlink\" title=\"特殊情况\"></a>特殊情况</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 引用作为重载的条件</span><br><span class=\"line\">void func(int &amp;a) &#123; &#x2F;&#x2F; 方法1</span><br><span class=\"line\">\tcout &lt;&lt; &quot;func(int &amp;a)&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void func(cont int &amp;a) &#123;  &#x2F;&#x2F; 方法2</span><br><span class=\"line\">\tcout &lt;&lt; &quot;func(cont int &amp;a)&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int a &#x3D; 10;</span><br><span class=\"line\">func(a); &#x2F;&#x2F; 方法1</span><br><span class=\"line\"></span><br><span class=\"line\">func(10); &#x2F;&#x2F; 方法2 因为 const int &amp;a &#x3D; 10; 合法，int &amp;a &#x3D; 10; 不合法</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 函数重载碰到默认参数</span><br><span class=\"line\">void func2(int a) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;func2(int a)&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void func2(int a,int b &#x3D; 10) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;func2(int a, int b)&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func2(10); &#x2F;&#x2F; 出现歧义（二义性），两个方法都能走，报错，所以建议函数重载的时候不要带默认参数</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"struct-和-class-的区别\"><a href=\"#struct-和-class-的区别\" class=\"headerlink\" title=\"struct 和 class 的区别\"></a>struct 和 class 的区别</h2><p><code>struct</code>默认权限为<code>public</code><br><code>class</code>默认权限为<code>private</code></p>\n<h2 id=\"构造函数和析构函数\"><a href=\"#构造函数和析构函数\" class=\"headerlink\" title=\"构造函数和析构函数\"></a>构造函数和析构函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tPerson() &#123;</span><br><span class=\"line\">       cout &lt;&lt; &quot;默认构造函数：系统会默认生成&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPerson(int age) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;带参数构造函数，写了这个系统就不生成无参构造函数&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tthis-&gt;_age &#x3D; age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPerson(int age) : _height(15) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;初始化部分参数的构造函数&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tthis-&gt;_age &#x3D; age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPerson(int age, int height) : _height(height) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;初始化部分参数的构造函数,并且顺便赋值了_height属性&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tthis-&gt;_age &#x3D; age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPerson(const Person &amp;person) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;浅拷贝函数：系统会默认生成&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 如果要深拷贝的话自己手动生成、赋值对象属性。</span><br><span class=\"line\">\t\t&#x2F;&#x2F;如果自己写拷贝构造函数的话，系统不提供其他普通构造函数（有&#x2F;无参）</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t~Person() &#123;</span><br><span class=\"line\">       cout&lt;&lt;&quot;析构函数：系统默认生成&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;int age; &#x2F;&#x2F; 不建议使用跟形参同名的成员变量</span><br><span class=\"line\">\tint _age; &#x2F;&#x2F; 带个下划线吧</span><br><span class=\"line\">\tint _height;</span><br><span class=\"line\">\tSomeClass property; &#x2F;&#x2F; 别的类的属性：构造时会优先进入该类构造函数，析构时会优先进入Person的析构函数，再走这个类的析构函数</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tPerson p1; &#x2F;&#x2F; 这样子就实例化了</span><br><span class=\"line\">\tPerson p2(11); &#x2F;&#x2F; age &#x3D; 11</span><br><span class=\"line\">\tPerson p3(11,160); &#x2F;&#x2F; age &#x3D; 11 height &#x3D; 160</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"链式调用函数\"><a href=\"#链式调用函数\" class=\"headerlink\" title=\"链式调用函数\"></a>链式调用函数</h2><p>在上面的Person类内加多这么一个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person&amp; addAge(Person &amp;p) &#123;</span><br><span class=\"line\">\tthis-&gt;_age +&#x3D; p._Age;</span><br><span class=\"line\">\treturn *this; &#x2F;&#x2F; 返回当前对象指针！！！</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Person pp(20);</span><br><span class=\"line\">Person pp2(10);</span><br><span class=\"line\">pp.addAge(pp2).addAge(pp2).addAge(pp2); &#x2F;&#x2F; 爽快地链式调用</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tstatic void func() &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;静态方法只能访问静态常量&quot; &lt;&lt; test &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tstatic int test;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tPerson p;</span><br><span class=\"line\">\tp.func(); &#x2F;&#x2F; 可以这么调</span><br><span class=\"line\">\tPerson::func(); &#x2F;&#x2F; 也可以通过类名直接调</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常函数和常对象\"><a href=\"#常函数和常对象\" class=\"headerlink\" title=\"常函数和常对象\"></a>常函数和常对象</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid funcA() const &#123;</span><br><span class=\"line\">&#x2F;&#x2F;\t\tthis-&gt;_name &#x3D; &quot;test&quot;;  常函数不可以访问普通成员属性</span><br><span class=\"line\">\t\tthis-&gt;_age &#x3D; 1; &#x2F;&#x2F;常函数可以访问被mutable修饰的成员属性</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstring _name;</span><br><span class=\"line\">\tmutable int _age;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tvoid funcB() &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tconst Person p;</span><br><span class=\"line\">&#x2F;&#x2F;\tp.funcB(); &#x2F;&#x2F; 常对象不能访问普通函数</span><br><span class=\"line\">\tp.funcA(); &#x2F;&#x2F; 常对象只能访问常函数</span><br><span class=\"line\">\treutrn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在类外部实现函数\"><a href=\"#在类外部实现函数\" class=\"headerlink\" title=\"在类外部实现函数\"></a>在类外部实现函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public: &#x2F;&#x2F; 需要是public函数才可以这么玩</span><br><span class=\"line\">\tPerson(); &#x2F;&#x2F; 要在外部实现的都得事先声明</span><br><span class=\"line\">\tvoid test();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person::Person() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Person::test() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"友元函数\"><a href=\"#友元函数\" class=\"headerlink\" title=\"友元函数\"></a>友元函数</h2><p>友元函数可以访问被<code>private</code>修饰的属性</p>\n<h3 id=\"全局函数做友元\"><a href=\"#全局函数做友元\" class=\"headerlink\" title=\"全局函数做友元\"></a>全局函数做友元</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">class Building &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 友元函数 可以访问私有属性</span><br><span class=\"line\">    friend void visitor(Building &amp;building);</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Building() &#123;</span><br><span class=\"line\">        m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class=\"line\">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    string m_SittingRoom;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    string m_Bedroom;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void visitor(Building &amp;building) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_SittingRoom &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_Bedroom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>顺带一提：如果入参是引用的话（<code>&amp;building</code>）,那么可以直接通过点语法访问成员属性，如果入参是指针的话（<code>*building</code>），那么就通过<code>-&gt;</code>访问，如（building-&gt;m_Bedroom）</p>\n</blockquote>\n<blockquote>\n<p>顺带再提，两种函数声明和调用方式的不同</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void visitor(Building &amp;building) &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_SittingRoom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void visitor2(Building *building) &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Building building;  &#x2F;&#x2F; 生成对象</span><br><span class=\"line\">    visitor(building);  &#x2F;&#x2F; 直接传对象</span><br><span class=\"line\">    visitor2(&amp;building); &#x2F;&#x2F; 传对象地址</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"友元类\"><a href=\"#友元类\" class=\"headerlink\" title=\"友元类\"></a>友元类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Building &#123;</span><br><span class=\"line\">    friend class Visitor; &#x2F;&#x2F; 这个类下的所有函数都可以访问它的私有属性</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Building() &#123;</span><br><span class=\"line\">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    string m_Bedroom;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Visitor</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tVisitor() &#123;</span><br><span class=\"line\">\t\tbuilding &#x3D; new Building;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid visit();</span><br><span class=\"line\">\tBuilding *building;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void Visitor::visit() &#123;</span><br><span class=\"line\">\tcout &lt;&lt; building-&gt;m_Bedroom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tVisitor v;</span><br><span class=\"line\">\tv.visit();</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"成员函数做友元函数\"><a href=\"#成员函数做友元函数\" class=\"headerlink\" title=\"成员函数做友元函数\"></a>成员函数做友元函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Building;</span><br><span class=\"line\">class Visitor</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Visitor();</span><br><span class=\"line\">    void visit();</span><br><span class=\"line\">    Building *building;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Building &#123;</span><br><span class=\"line\">    friend void Visitor::visit(); &#x2F;&#x2F; 指定Visitor的visit成员函数可以访问私有属性</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Building() &#123;</span><br><span class=\"line\">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    string m_Bedroom;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 为什么这个构造函数要写外面，不能写里面？</span><br><span class=\"line\">&#x2F;&#x2F; 因为Visitor需要在Building上面定义，不然不给定义Visitor上的友元函数，然后因为Visitor内有Building的属性，所以要声明一下class Building; 但是因为只是声明没有实现，所以就不能new Building;了，那就只能把这个通过类外实现的方式写在Building定义的下面。</span><br><span class=\"line\">Visitor::Visitor() &#123;  </span><br><span class=\"line\">    building &#x3D; new Building;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Visitor::visit() &#123;</span><br><span class=\"line\">    cout &lt;&lt; building-&gt;m_Bedroom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Visitor v;</span><br><span class=\"line\">    v.visit();</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运算符重载\"><a href=\"#运算符重载\" class=\"headerlink\" title=\"运算符重载\"></a>运算符重载</h2><p>跟Swift差不多</p>\n<h3 id=\"成员函数的运算符重载\"><a href=\"#成员函数的运算符重载\" class=\"headerlink\" title=\"成员函数的运算符重载\"></a>成员函数的运算符重载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Animal operator + (Animal &amp;a) &#123;</span><br><span class=\"line\">        Animal temp;</span><br><span class=\"line\">        temp.m_A &#x3D; this -&gt; m_A + a.m_A;</span><br><span class=\"line\">        return temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int m_A;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal a;</span><br><span class=\"line\">a.m_A &#x3D; 1;</span><br><span class=\"line\">Animal b;</span><br><span class=\"line\">b.m_A &#x3D; 2;</span><br><span class=\"line\">Animal c &#x3D; a + b;</span><br><span class=\"line\">cout &lt;&lt; c.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 3</span><br></pre></td></tr></table></figure>\n\n<p>本质：<code>Animal c = a.operator+(b);</code></p>\n<h3 id=\"全局函数的运算符重载\"><a href=\"#全局函数的运算符重载\" class=\"headerlink\" title=\"全局函数的运算符重载\"></a>全局函数的运算符重载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal operator - (Animal &amp;a, Animal &amp;b) &#123;</span><br><span class=\"line\">    Animal temp;</span><br><span class=\"line\">    temp.m_A &#x3D; a.m_A - b.m_A;</span><br><span class=\"line\">    return temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal a;</span><br><span class=\"line\">a.m_A &#x3D; 1;</span><br><span class=\"line\">Animal b;</span><br><span class=\"line\">b.m_A &#x3D; 2;</span><br><span class=\"line\">Animal c &#x3D; a - b;</span><br><span class=\"line\">cout &lt;&lt; c.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 -1</span><br></pre></td></tr></table></figure>\n\n<p>本质：<code>Animal c = operator-(a,b);</code></p>\n<h3 id=\"运算符重载也可以发生函数重载\"><a href=\"#运算符重载也可以发生函数重载\" class=\"headerlink\" title=\"运算符重载也可以发生函数重载\"></a>运算符重载也可以发生函数重载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal operator + (int a, Animal &amp;b) &#123;</span><br><span class=\"line\">    Animal temp;</span><br><span class=\"line\">    temp.m_A &#x3D; a + b.m_A;</span><br><span class=\"line\">    return temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal a;</span><br><span class=\"line\">a.m_A &#x3D; 1;</span><br><span class=\"line\">Animal d &#x3D; 10 + a;</span><br><span class=\"line\">cout &lt;&lt; d.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 11</span><br></pre></td></tr></table></figure>\n\n<p>本质：<code>Animal d = operator+(10,a);</code></p>\n<h3 id=\"左移运算符重载（比较常见输出对象细节）\"><a href=\"#左移运算符重载（比较常见输出对象细节）\" class=\"headerlink\" title=\"左移运算符重载（比较常见输出对象细节）\"></a>左移运算符重载（比较常见输出对象细节）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyInteger &#123;</span><br><span class=\"line\">    friend ostream&amp; operator&lt;&lt;(ostream&amp; cout,MyInteger myInt);</span><br><span class=\"line\">public:</span><br><span class=\"line\">    MyInteger() &#123;</span><br><span class=\"line\">        this-&gt;my_int &#x3D; 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    int my_int;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 必须是全局函数重载 ostream是cout的类型，为了能链式调用所以返回引用ostream&amp;</span><br><span class=\"line\">ostream&amp; operator&lt;&lt;(ostream&amp; cout,MyInteger myInt) &#123;</span><br><span class=\"line\">    cout &lt;&lt; myInt.my_int; &#x2F;&#x2F; 返回对象细节</span><br><span class=\"line\">    return cout;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    MyInteger myInt;</span><br><span class=\"line\">    cout &lt;&lt; myInt &lt;&lt; endl; &#x2F;&#x2F; 输出 my_int 的值 0</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关系运算符重载\"><a href=\"#关系运算符重载\" class=\"headerlink\" title=\"关系运算符重载\"></a>关系运算符重载</h3><p>Swift经常使用，参见<code>Equable</code>，<code>Comparable</code>协议</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool operator&#x3D;&#x3D;(Person &amp;p) &#123;</span><br><span class=\"line\">        if (this-&gt;m_Name &#x3D;&#x3D; p.m_Name) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bool operator!&#x3D;(Person &amp;p) &#123;</span><br><span class=\"line\">        if (this-&gt;m_Name !&#x3D; p.m_Name) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\tstring m_Name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tPerson p1; p1.m_Name &#x3D; &quot;A&quot;;</span><br><span class=\"line\">    Person p2; p2.m_Name &#x3D; &quot;A&quot;;</span><br><span class=\"line\">    if (p1 &#x3D;&#x3D; p2) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Equal&quot; &lt;&lt; endl; &#x2F;&#x2F; 输出</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Different&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (p1 !&#x3D; p2) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Different&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Equal&quot; &lt;&lt; endl; &#x2F;&#x2F; 输出</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数调用运算符的重载（骚操作）\"><a href=\"#函数调用运算符的重载（骚操作）\" class=\"headerlink\" title=\"函数调用运算符的重载（骚操作）\"></a>函数调用运算符的重载（骚操作）</h3><p>因为用起来很像函数，所以又叫做仿函数，STL里相当多这种骚操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyInteger &#123;</span><br><span class=\"line\">\tint operator()(int a,int b) &#123;</span><br><span class=\"line\">        return a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; MyInteger() ：匿名对象</span><br><span class=\"line\">    int result &#x3D; MyInteger()(1,2);</span><br><span class=\"line\"></span><br><span class=\"line\">    MyInteger i;</span><br><span class=\"line\">    int result2 &#x3D; i(5,2);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; result &lt;&lt; endl;  &#x2F;&#x2F; 5</span><br><span class=\"line\">    cout &lt;&lt; result2 &lt;&lt; endl; &#x2F;&#x2F; 7</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>C++有多继承，灰常厉害</p>\n<h3 id=\"继承方式\"><a href=\"#继承方式\" class=\"headerlink\" title=\"继承方式\"></a>继承方式</h3><p>三种继承方式<code>public</code>,<code>protected</code>,<code>private</code>，决定着继承下来的属性和方法以什么形式修饰，<code>class</code>默认<code>private</code>,<code>struct</code>默认<code>public</code>（没错，C++中结构体可以被继承）<br>父类的所有非静态属性会被继承，包括<code>private</code>类型的，但是<code>private</code>类型的默认隐藏，子类无法访问。</p>\n<p>继承语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class SubClass : public SuperClass &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构造和析构\"><a href=\"#构造和析构\" class=\"headerlink\" title=\"构造和析构\"></a>构造和析构</h3><p>父类先构造，子类先析构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">superClass()</span><br><span class=\"line\">subClass()</span><br><span class=\"line\">~subClass()</span><br><span class=\"line\">~superClass()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"同名属性-函数-静态属性-静态函数的访问\"><a href=\"#同名属性-函数-静态属性-静态函数的访问\" class=\"headerlink\" title=\"同名属性/函数/静态属性/静态函数的访问\"></a>同名属性/函数/静态属性/静态函数的访问</h3><p>假如子类和父类拥有相同的名字的属性/函数/静态属性/静态函数，则直接调用子类对象的话都是访问子类的，如果要访问父类的话要添加作用域。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int _a &#x3D; 1;</span><br><span class=\"line\">    static int _b;</span><br><span class=\"line\">    static void staticFunc() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Base staticFunc()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void Func() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Base Func()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int Base::_b &#x3D; 10; &#x2F;&#x2F; 静态成员变量要在外面赋值</span><br><span class=\"line\"></span><br><span class=\"line\">class Sub1 : public Base &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int _a &#x3D; 2;</span><br><span class=\"line\">    static int _b;</span><br><span class=\"line\">    static void staticFunc() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;SubClass staticFunc()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void Func() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;SucClass Func()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int Sub1::_b &#x3D; 20;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Sub1 s;</span><br><span class=\"line\">    &#x2F;&#x2F; 直接调用</span><br><span class=\"line\">    cout &lt;&lt; s._a &lt;&lt; endl;</span><br><span class=\"line\">    &#x2F;&#x2F; 调用父类的</span><br><span class=\"line\">    cout &lt;&lt; s.Base::_a &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 静态直接调用</span><br><span class=\"line\">    cout &lt;&lt; s._b &lt;&lt; endl;</span><br><span class=\"line\">    &#x2F;&#x2F; 静态调用父类的</span><br><span class=\"line\">    cout &lt;&lt; s.Base::_b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 静态直接调用</span><br><span class=\"line\">    cout &lt;&lt; Sub1::_b &lt;&lt; endl;</span><br><span class=\"line\">    &#x2F;&#x2F; 静态调用父类的</span><br><span class=\"line\">    cout &lt;&lt; Sub1::Base::_b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 直接调用</span><br><span class=\"line\">    s.Func();</span><br><span class=\"line\">    &#x2F;&#x2F; 调用父类的</span><br><span class=\"line\">    s.Base::Func();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 静态直接调用</span><br><span class=\"line\">    s.staticFunc();</span><br><span class=\"line\">    &#x2F;&#x2F; 静态调用父类的</span><br><span class=\"line\">    s.Base::staticFunc();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 静态直接调用</span><br><span class=\"line\">    Sub1::staticFunc();</span><br><span class=\"line\">    &#x2F;&#x2F; 静态调用父类的</span><br><span class=\"line\">    Sub1::Base::staticFunc();</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h3><p>不建议使用，因为麻烦事多</p>\n<p>语法：(参照上面的代码)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Other &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void Func() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Ohter Func()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#x2F;&#x2F;...略</span><br><span class=\"line\">class Sub1 : public Base , public Other &#123;</span><br><span class=\"line\">&#x2F;&#x2F;...略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当多个父类中出现同名属性/方法时，需要加作用域指定父类<code>s.Base::Func(); / s.Other::Func();</code></p>\n<h3 id=\"菱形继承（钻石继承）\"><a href=\"#菱形继承（钻石继承）\" class=\"headerlink\" title=\"菱形继承（钻石继承）\"></a>菱形继承（钻石继承）</h3><p>两个子类继承同一个基类，<br>又有某个类同时继承着两个子类</p>\n<p>举例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base &#123; int age &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Sub1: public Base &#123;&#125;;</span><br><span class=\"line\">class Sub2: public Base &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class SubSub: public Sub1, public Sub2 &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这时候SubSub会有两个父类，有两份 age 属性，造成资源浪费</p>\n<p>这时候用虚继承(<code>virtual</code>)解决问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base &#123; public: int age &#125;; &#x2F;&#x2F; 这时候成为虚基类</span><br><span class=\"line\"></span><br><span class=\"line\">class Sub1: virtual public Base &#123;&#125;;</span><br><span class=\"line\">class Sub2: virtual public Base &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class SubSub: public Sub1, public Sub2 &#123;&#125;;</span><br></pre></td></tr></table></figure>\n<p>这时候age属性成为共享属性，最后谁改了就是谁的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SubSub s;</span><br><span class=\"line\">s.Sub1::age &#x3D; 1;</span><br><span class=\"line\">s.Sub2::age &#x3D; 10;</span><br><span class=\"line\">cout &lt;&lt; s.Sub1::age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br><span class=\"line\">cout &lt;&lt; s.Sub2::age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br><span class=\"line\">cout &lt;&lt; s.age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p>C++中，多态分两类</p>\n<p>静态多态：函数重载和运算符重载属于静态多态，复用函数名<br>动态多态：子类和虚函数实现运行时多态</p>\n<p>区别：</p>\n<p>静态多态的函数地址早绑定，编译阶段确定函数地址<br>动态多态的函数地址晚绑定，运行阶段确定函数地址</p>\n<p>动态多态满足条件：</p>\n<ol>\n<li>有继承关系</li>\n<li>子类重写父类虚函数</li>\n</ol>\n<p>动态多态使用<br>父类的指针或者引用指向子类对象</p>\n<p>静态多态举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void speak() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Animal Speak&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Cat: public Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void speak() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Cat Speak&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">void SomeoneSpeak(Animal &amp;animal) &#123;</span><br><span class=\"line\">    animal.speak();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Cat c;</span><br><span class=\"line\">    SomeoneSpeak(c); &#x2F;&#x2F; 由于SomeoneSpeak(Animal &amp;animal)，编译期间已经确定入参类型，所以输出 Animal Speak</span><br></pre></td></tr></table></figure>\n\n<p>如果想输出<code>Cat Speak</code>，只需进行如下修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    virtual void speak() &#123; &#x2F;&#x2F; 虚函数，可以告知由于SomeoneSpeak(Animal &amp;animal)运行时再确定入参类型</span><br><span class=\"line\">        cout &lt;&lt; &quot;Animal Speak&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>经常地，这种情况下也是动态多态，最后会输出<code>Cat Speak</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal *a &#x3D; new Cat;</span><br><span class=\"line\">a-&gt;speak();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"纯虚函数和抽象类\"><a href=\"#纯虚函数和抽象类\" class=\"headerlink\" title=\"纯虚函数和抽象类\"></a>纯虚函数和抽象类</h3><p>父类的虚函数的实现没什么意义，所以上面的虚函数代码改写为<code>纯虚函数</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">virtual void speak() &#x3D; 0;</span><br></pre></td></tr></table></figure>\n\n<p>当类中有了纯虚函数，则这个类称为<code>抽象类</code></p>\n<p>抽象类<strong>无法实例化对象</strong>，并且<strong>子类必须重写父类的纯虚函数</strong>，否则也成为<code>抽象类</code></p>\n<h3 id=\"虚析构和纯虚析构\"><a href=\"#虚析构和纯虚析构\" class=\"headerlink\" title=\"虚析构和纯虚析构\"></a>虚析构和纯虚析构</h3><p>当子类在堆区创建数据的时候，需要手动释放，父类需要添加虚析构或者纯虚析构函数，否则子类可能不走析构函数</p>\n<p>比如上面的<code>Animate</code>父类，我们补充一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    virtual ~Animal() &#x3D; 0; &#x2F;&#x2F; 纯虚析构</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal::~Animal() &#123; &#x2F;&#x2F; 析构实现</span><br><span class=\"line\">    cout &lt;&lt; &quot;Animal is Delete&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><p>文件打开方式</p>\n<p><code>ios::in</code>:读文件<br><code>ios::out</code>:写文件<br><code>ios::ate</code>:初始位置，文件尾<br><code>ios:app</code>:追加写文件<br><code>ios:trunc</code>:如果文件存在先删除，再创建<br><code>ios:binary</code>:二进制方式</p>\n<p>同时两种方式则使用<code>|</code>的方式，比如<code>ios::in|ios:binary</code></p>\n<h3 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ofstream stream;</span><br><span class=\"line\"></span><br><span class=\"line\">stream.open(&quot;Test.txt&quot;,ios::out);</span><br><span class=\"line\"></span><br><span class=\"line\">stream &lt;&lt; &quot;Line 1&quot; &lt;&lt; endl;</span><br><span class=\"line\">stream &lt;&lt; &quot;Line 2&quot; &lt;&lt; endl;</span><br><span class=\"line\">stream &lt;&lt; &quot;Line 3&quot; &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">stream.close();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifstream ifs;</span><br><span class=\"line\">ifs.open(&quot;Test.txt&quot;,ios::out);</span><br><span class=\"line\"></span><br><span class=\"line\">if(!ifs.is_open()) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;打开文件失败&quot; &lt;&lt; endl;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">string buf;</span><br><span class=\"line\">while (getline(ifs, buf)) &#123; &#x2F;&#x2F; 一行行读取</span><br><span class=\"line\">\tcout &lt;&lt; buf &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ifs.close();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h2><h3 id=\"构建类模板与类模板做参数\"><a href=\"#构建类模板与类模板做参数\" class=\"headerlink\" title=\"构建类模板与类模板做参数\"></a>构建类模板与类模板做参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class NameType,class AgeType&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Person(NameType name, AgeType age) &#123;</span><br><span class=\"line\">        this-&gt;_age &#x3D; age;</span><br><span class=\"line\">        this-&gt;_name &#x3D; name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    AgeType _age;</span><br><span class=\"line\">    NameType _name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 不会自动类型推导，需要自己显式声明类型</span><br><span class=\"line\">    Person&lt;string,int&gt; p(&quot;Haha&quot;,123);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; p._name &lt;&lt; &quot; &quot; &lt;&lt; p._age &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可以给类模板添加默认类型</p>\n<p><code>template&lt;class NameType,class AgeType = int&gt;</code></p>\n<p>这样子调用的时候就可以不全声明类型了</p>\n<p><code>Person&lt;string&gt; p(&quot;Haha&quot;,123);</code></p>\n<p>类模板做参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 指定类型的类模板做参数</span><br><span class=\"line\">void print(Person&lt;string,int&gt; &amp;p) &#123;</span><br><span class=\"line\">    p.showPerson();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 模板化参数的类模板做参数</span><br><span class=\"line\">template&lt;class T1,class T2&gt;</span><br><span class=\"line\">void print2(Person&lt;T1, T2&gt; &amp;p) &#123;</span><br><span class=\"line\">    p.showPerson();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 模板化类做参数</span><br><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">void print3(T &amp;p) &#123;</span><br><span class=\"line\">    p.showPerson();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Person&lt;string,int&gt; p(&quot;Haha&quot;,123);</span><br><span class=\"line\">    print(p);</span><br><span class=\"line\">    print2(p);</span><br><span class=\"line\">    print3(p);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类模板与继承\"><a href=\"#类模板与继承\" class=\"headerlink\" title=\"类模板与继承\"></a>类模板与继承</h3><p>继承时需要指定类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">class Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    T m;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class SubClass: public Base&lt;int&gt; &#123; &#x2F;&#x2F; 指定T的类型</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void print() &#123;</span><br><span class=\"line\">        cout &lt;&lt; m &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果不想指定类型，那么可以模板化子类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">class Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    T m;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;class T1,class T2&gt;</span><br><span class=\"line\">class SubClass: public Base&lt;T1&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    SubClass(T1 a, T2 b) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    T2 k;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tSubClass&lt;string, int&gt; c(&quot;String&quot;,1);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"STL-之-Vector容器\"><a href=\"#STL-之-Vector容器\" class=\"headerlink\" title=\"STL 之 Vector容器\"></a>STL 之 Vector容器</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int&gt; v1; &#x2F;&#x2F; 初始化指定容器内元素类型</span><br><span class=\"line\">v1.assign(10, 1); &#x2F;&#x2F; 插入10个1，也可以传入其他vector,比如v1.assign(v0.begin,v0.end); 或者直接 v1 &#x3D; v0; 只要保证是同种类型就好</span><br><span class=\"line\">for (vector&lt;int&gt;::iterator i &#x3D; v1.begin(); i !&#x3D; v1.end() ; i++) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; *i &lt;&lt; endl;</span><br><span class=\"line\">&#125; &#x2F;&#x2F; 打印10个1</span><br><span class=\"line\">cout &lt;&lt; &quot;Size &#x3D; &quot; &lt;&lt; v1.size() &lt;&lt; endl; &#x2F;&#x2F; 长度 10</span><br><span class=\"line\">cout &lt;&lt; &quot;isEmpty &#x3D; &quot; &lt;&lt; v1.empty() &lt;&lt; endl; &#x2F;&#x2F; 判空 0</span><br><span class=\"line\">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 容量 10</span><br><span class=\"line\">v1.resize(20,20); &#x2F;&#x2F; 调整容量为20，多出来的位置用20填充，这里的20可以不传，默认0</span><br><span class=\"line\">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 现在容量变成20</span><br><span class=\"line\"></span><br><span class=\"line\">v1.pop_back(); &#x2F;&#x2F; 删除最后一个元素</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; &quot;Size &#x3D; &quot; &lt;&lt; v1.size() &lt;&lt; endl; &#x2F;&#x2F; 长度 19</span><br><span class=\"line\">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 容量不变 20</span><br><span class=\"line\"></span><br><span class=\"line\">v1.insert(v1.begin() + 1, 199); &#x2F;&#x2F; 下标为1的位置插入元素199</span><br><span class=\"line\">v1.insert(v1.begin() + 1, 2, 199); &#x2F;&#x2F; 下标为1的位置插入两个元素199</span><br><span class=\"line\">v1.erase(v1.begin() + 2); &#x2F;&#x2F; 删除第二个元素</span><br><span class=\"line\">v1.erase(v1.begin() + 2 , v1.begin() + 3); &#x2F;&#x2F; 删除第二个到第三个元素</span><br><span class=\"line\">v1.clear(); &#x2F;&#x2F; 清空容器</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; &quot;第二个元素是&quot; &lt;&lt; v1.at(1) &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; &quot;第三个元素是&quot; &lt;&lt; v1[2] &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; &quot;第一个元素&quot; &lt;&lt; v1.front() &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; &quot;最后一个元素&quot; &lt;&lt; v1.back() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">v1.reverse(100000); &#x2F;&#x2F; 预留空间，减少以后动态拓展的次数</span><br><span class=\"line\"></span><br><span class=\"line\">v1.swap(v0); &#x2F;&#x2F; 交换元素，假如v1的预留空间很大，可以通过交换一个小预留空间的容器达到压缩内存的效果</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>在iOS开发过程中，有时候会用到一些C++的库，为了避免大家用到这种库的时候一脸懵逼，这里总结一些基础知识，不写C++没关系，起码当库出了什么问题的时候至少能看懂逻辑（或许吧）。</p>\n<p>这里全部都是基础语法知识，没事的时候可以看看熟悉一下。</p>","more":"<h2 id=\"指针和引用\"><a href=\"#指针和引用\" class=\"headerlink\" title=\"指针和引用\"></a>指针和引用</h2><p>略</p>\n<p>还是简单说一下：<code>.</code>是对象访问属性的操作符，<code>-&gt;</code>是指针访问指针属性的操作符，<br><code>(*a).b</code>=&gt;<code>a-&gt;b</code></p>\n<h2 id=\"权限访问\"><a href=\"#权限访问\" class=\"headerlink\" title=\"权限访问\"></a>权限访问</h2><p>public:   可以被任意实体访问</p>\n<p>protected:只允许子类及本类的成员函数访问</p>\n<p>private:只允许本类的成员函数访问</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><p>跟Swift差不多</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int func (int a , int b &#x3D; 10, int c &#x3D; 10); &#x2F;&#x2F; 声明中有默认参数，实现中不能有默认参数，比如下面这么写就会报错</span><br><span class=\"line\">&#x2F;&#x2F; 声明和实现只能其中一个有默认参数</span><br><span class=\"line\">int func (int a , int b &#x3D; 10, int c &#x3D; 10) &#123; &#x2F;&#x2F; 形参默认值，当b有默认值的时候，后面的参数都需要有默认值，不能b有c没有，但是可以c有b没有</span><br><span class=\"line\">\t return a + b + c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"占位参数（没啥用）\"><a href=\"#占位参数（没啥用）\" class=\"headerlink\" title=\"占位参数（没啥用）\"></a>占位参数（没啥用）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void func(int a,int &#x3D; 0) &#123; &#x2F;&#x2F; 占位参数可以有默认参数，也可以没有</span><br><span class=\"line\">\tcout &lt;&lt; a &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func(1,2);</span><br></pre></td></tr></table></figure>\n\n<p>其实主要是用与兼容C语言的不规范写法，因为在C语言中，传参个数可以比函数声明的参数个数还多，比如<code>func(1,2,3,4,5)</code>,会警告但是不会报错，但是C++这么写就会报错，所以为了兼容C语言的调用方式，就用占位参数，占个位但是不用它，这样子就不会报错。</p>\n<h3 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h3><p>同一个作用域，函数名相同，参数个数不同/类型不同/顺序不同</p>\n<p><strong>函数的返回值不可以作为函数重载的条件</strong></p>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void func() &#123;&#125;</span><br><span class=\"line\">void func(int a) &#123;&#125;</span><br><span class=\"line\">void func(double a) &#123;&#125;</span><br><span class=\"line\">void func(int a, double b) &#123;&#125;</span><br><span class=\"line\">void func(double a, int b) &#123;&#125;</span><br><span class=\"line\">int func() &#123;&#125; &#x2F;&#x2F; 这个会报错</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"特殊情况\"><a href=\"#特殊情况\" class=\"headerlink\" title=\"特殊情况\"></a>特殊情况</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 引用作为重载的条件</span><br><span class=\"line\">void func(int &amp;a) &#123; &#x2F;&#x2F; 方法1</span><br><span class=\"line\">\tcout &lt;&lt; &quot;func(int &amp;a)&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void func(cont int &amp;a) &#123;  &#x2F;&#x2F; 方法2</span><br><span class=\"line\">\tcout &lt;&lt; &quot;func(cont int &amp;a)&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int a &#x3D; 10;</span><br><span class=\"line\">func(a); &#x2F;&#x2F; 方法1</span><br><span class=\"line\"></span><br><span class=\"line\">func(10); &#x2F;&#x2F; 方法2 因为 const int &amp;a &#x3D; 10; 合法，int &amp;a &#x3D; 10; 不合法</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 函数重载碰到默认参数</span><br><span class=\"line\">void func2(int a) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;func2(int a)&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void func2(int a,int b &#x3D; 10) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;func2(int a, int b)&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func2(10); &#x2F;&#x2F; 出现歧义（二义性），两个方法都能走，报错，所以建议函数重载的时候不要带默认参数</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"struct-和-class-的区别\"><a href=\"#struct-和-class-的区别\" class=\"headerlink\" title=\"struct 和 class 的区别\"></a>struct 和 class 的区别</h2><p><code>struct</code>默认权限为<code>public</code><br><code>class</code>默认权限为<code>private</code></p>\n<h2 id=\"构造函数和析构函数\"><a href=\"#构造函数和析构函数\" class=\"headerlink\" title=\"构造函数和析构函数\"></a>构造函数和析构函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tPerson() &#123;</span><br><span class=\"line\">       cout &lt;&lt; &quot;默认构造函数：系统会默认生成&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPerson(int age) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;带参数构造函数，写了这个系统就不生成无参构造函数&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tthis-&gt;_age &#x3D; age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPerson(int age) : _height(15) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;初始化部分参数的构造函数&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tthis-&gt;_age &#x3D; age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPerson(int age, int height) : _height(height) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;初始化部分参数的构造函数,并且顺便赋值了_height属性&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\tthis-&gt;_age &#x3D; age;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPerson(const Person &amp;person) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;浅拷贝函数：系统会默认生成&quot; &lt;&lt; endl;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; 如果要深拷贝的话自己手动生成、赋值对象属性。</span><br><span class=\"line\">\t\t&#x2F;&#x2F;如果自己写拷贝构造函数的话，系统不提供其他普通构造函数（有&#x2F;无参）</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t~Person() &#123;</span><br><span class=\"line\">       cout&lt;&lt;&quot;析构函数：系统默认生成&quot;&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F;int age; &#x2F;&#x2F; 不建议使用跟形参同名的成员变量</span><br><span class=\"line\">\tint _age; &#x2F;&#x2F; 带个下划线吧</span><br><span class=\"line\">\tint _height;</span><br><span class=\"line\">\tSomeClass property; &#x2F;&#x2F; 别的类的属性：构造时会优先进入该类构造函数，析构时会优先进入Person的析构函数，再走这个类的析构函数</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tPerson p1; &#x2F;&#x2F; 这样子就实例化了</span><br><span class=\"line\">\tPerson p2(11); &#x2F;&#x2F; age &#x3D; 11</span><br><span class=\"line\">\tPerson p3(11,160); &#x2F;&#x2F; age &#x3D; 11 height &#x3D; 160</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"链式调用函数\"><a href=\"#链式调用函数\" class=\"headerlink\" title=\"链式调用函数\"></a>链式调用函数</h2><p>在上面的Person类内加多这么一个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person&amp; addAge(Person &amp;p) &#123;</span><br><span class=\"line\">\tthis-&gt;_age +&#x3D; p._Age;</span><br><span class=\"line\">\treturn *this; &#x2F;&#x2F; 返回当前对象指针！！！</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Person pp(20);</span><br><span class=\"line\">Person pp2(10);</span><br><span class=\"line\">pp.addAge(pp2).addAge(pp2).addAge(pp2); &#x2F;&#x2F; 爽快地链式调用</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tstatic void func() &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;静态方法只能访问静态常量&quot; &lt;&lt; test &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tstatic int test;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tPerson p;</span><br><span class=\"line\">\tp.func(); &#x2F;&#x2F; 可以这么调</span><br><span class=\"line\">\tPerson::func(); &#x2F;&#x2F; 也可以通过类名直接调</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常函数和常对象\"><a href=\"#常函数和常对象\" class=\"headerlink\" title=\"常函数和常对象\"></a>常函数和常对象</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid funcA() const &#123;</span><br><span class=\"line\">&#x2F;&#x2F;\t\tthis-&gt;_name &#x3D; &quot;test&quot;;  常函数不可以访问普通成员属性</span><br><span class=\"line\">\t\tthis-&gt;_age &#x3D; 1; &#x2F;&#x2F;常函数可以访问被mutable修饰的成员属性</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstring _name;</span><br><span class=\"line\">\tmutable int _age;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tvoid funcB() &#123;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tconst Person p;</span><br><span class=\"line\">&#x2F;&#x2F;\tp.funcB(); &#x2F;&#x2F; 常对象不能访问普通函数</span><br><span class=\"line\">\tp.funcA(); &#x2F;&#x2F; 常对象只能访问常函数</span><br><span class=\"line\">\treutrn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在类外部实现函数\"><a href=\"#在类外部实现函数\" class=\"headerlink\" title=\"在类外部实现函数\"></a>在类外部实现函数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public: &#x2F;&#x2F; 需要是public函数才可以这么玩</span><br><span class=\"line\">\tPerson(); &#x2F;&#x2F; 要在外部实现的都得事先声明</span><br><span class=\"line\">\tvoid test();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Person::Person() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Person::test() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"友元函数\"><a href=\"#友元函数\" class=\"headerlink\" title=\"友元函数\"></a>友元函数</h2><p>友元函数可以访问被<code>private</code>修饰的属性</p>\n<h3 id=\"全局函数做友元\"><a href=\"#全局函数做友元\" class=\"headerlink\" title=\"全局函数做友元\"></a>全局函数做友元</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">class Building &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 友元函数 可以访问私有属性</span><br><span class=\"line\">    friend void visitor(Building &amp;building);</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Building() &#123;</span><br><span class=\"line\">        m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class=\"line\">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    string m_SittingRoom;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    string m_Bedroom;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void visitor(Building &amp;building) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_SittingRoom &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_Bedroom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>顺带一提：如果入参是引用的话（<code>&amp;building</code>）,那么可以直接通过点语法访问成员属性，如果入参是指针的话（<code>*building</code>），那么就通过<code>-&gt;</code>访问，如（building-&gt;m_Bedroom）</p>\n</blockquote>\n<blockquote>\n<p>顺带再提，两种函数声明和调用方式的不同</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void visitor(Building &amp;building) &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_SittingRoom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void visitor2(Building *building) &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    Building building;  &#x2F;&#x2F; 生成对象</span><br><span class=\"line\">    visitor(building);  &#x2F;&#x2F; 直接传对象</span><br><span class=\"line\">    visitor2(&amp;building); &#x2F;&#x2F; 传对象地址</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"友元类\"><a href=\"#友元类\" class=\"headerlink\" title=\"友元类\"></a>友元类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Building &#123;</span><br><span class=\"line\">    friend class Visitor; &#x2F;&#x2F; 这个类下的所有函数都可以访问它的私有属性</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Building() &#123;</span><br><span class=\"line\">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    string m_Bedroom;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Visitor</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tVisitor() &#123;</span><br><span class=\"line\">\t\tbuilding &#x3D; new Building;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid visit();</span><br><span class=\"line\">\tBuilding *building;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">void Visitor::visit() &#123;</span><br><span class=\"line\">\tcout &lt;&lt; building-&gt;m_Bedroom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tVisitor v;</span><br><span class=\"line\">\tv.visit();</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"成员函数做友元函数\"><a href=\"#成员函数做友元函数\" class=\"headerlink\" title=\"成员函数做友元函数\"></a>成员函数做友元函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Building;</span><br><span class=\"line\">class Visitor</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Visitor();</span><br><span class=\"line\">    void visit();</span><br><span class=\"line\">    Building *building;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Building &#123;</span><br><span class=\"line\">    friend void Visitor::visit(); &#x2F;&#x2F; 指定Visitor的visit成员函数可以访问私有属性</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Building() &#123;</span><br><span class=\"line\">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    string m_Bedroom;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 为什么这个构造函数要写外面，不能写里面？</span><br><span class=\"line\">&#x2F;&#x2F; 因为Visitor需要在Building上面定义，不然不给定义Visitor上的友元函数，然后因为Visitor内有Building的属性，所以要声明一下class Building; 但是因为只是声明没有实现，所以就不能new Building;了，那就只能把这个通过类外实现的方式写在Building定义的下面。</span><br><span class=\"line\">Visitor::Visitor() &#123;  </span><br><span class=\"line\">    building &#x3D; new Building;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Visitor::visit() &#123;</span><br><span class=\"line\">    cout &lt;&lt; building-&gt;m_Bedroom &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Visitor v;</span><br><span class=\"line\">    v.visit();</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"运算符重载\"><a href=\"#运算符重载\" class=\"headerlink\" title=\"运算符重载\"></a>运算符重载</h2><p>跟Swift差不多</p>\n<h3 id=\"成员函数的运算符重载\"><a href=\"#成员函数的运算符重载\" class=\"headerlink\" title=\"成员函数的运算符重载\"></a>成员函数的运算符重载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Animal operator + (Animal &amp;a) &#123;</span><br><span class=\"line\">        Animal temp;</span><br><span class=\"line\">        temp.m_A &#x3D; this -&gt; m_A + a.m_A;</span><br><span class=\"line\">        return temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int m_A;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal a;</span><br><span class=\"line\">a.m_A &#x3D; 1;</span><br><span class=\"line\">Animal b;</span><br><span class=\"line\">b.m_A &#x3D; 2;</span><br><span class=\"line\">Animal c &#x3D; a + b;</span><br><span class=\"line\">cout &lt;&lt; c.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 3</span><br></pre></td></tr></table></figure>\n\n<p>本质：<code>Animal c = a.operator+(b);</code></p>\n<h3 id=\"全局函数的运算符重载\"><a href=\"#全局函数的运算符重载\" class=\"headerlink\" title=\"全局函数的运算符重载\"></a>全局函数的运算符重载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal operator - (Animal &amp;a, Animal &amp;b) &#123;</span><br><span class=\"line\">    Animal temp;</span><br><span class=\"line\">    temp.m_A &#x3D; a.m_A - b.m_A;</span><br><span class=\"line\">    return temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal a;</span><br><span class=\"line\">a.m_A &#x3D; 1;</span><br><span class=\"line\">Animal b;</span><br><span class=\"line\">b.m_A &#x3D; 2;</span><br><span class=\"line\">Animal c &#x3D; a - b;</span><br><span class=\"line\">cout &lt;&lt; c.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 -1</span><br></pre></td></tr></table></figure>\n\n<p>本质：<code>Animal c = operator-(a,b);</code></p>\n<h3 id=\"运算符重载也可以发生函数重载\"><a href=\"#运算符重载也可以发生函数重载\" class=\"headerlink\" title=\"运算符重载也可以发生函数重载\"></a>运算符重载也可以发生函数重载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal operator + (int a, Animal &amp;b) &#123;</span><br><span class=\"line\">    Animal temp;</span><br><span class=\"line\">    temp.m_A &#x3D; a + b.m_A;</span><br><span class=\"line\">    return temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal a;</span><br><span class=\"line\">a.m_A &#x3D; 1;</span><br><span class=\"line\">Animal d &#x3D; 10 + a;</span><br><span class=\"line\">cout &lt;&lt; d.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 11</span><br></pre></td></tr></table></figure>\n\n<p>本质：<code>Animal d = operator+(10,a);</code></p>\n<h3 id=\"左移运算符重载（比较常见输出对象细节）\"><a href=\"#左移运算符重载（比较常见输出对象细节）\" class=\"headerlink\" title=\"左移运算符重载（比较常见输出对象细节）\"></a>左移运算符重载（比较常见输出对象细节）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyInteger &#123;</span><br><span class=\"line\">    friend ostream&amp; operator&lt;&lt;(ostream&amp; cout,MyInteger myInt);</span><br><span class=\"line\">public:</span><br><span class=\"line\">    MyInteger() &#123;</span><br><span class=\"line\">        this-&gt;my_int &#x3D; 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">private:</span><br><span class=\"line\">    int my_int;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 必须是全局函数重载 ostream是cout的类型，为了能链式调用所以返回引用ostream&amp;</span><br><span class=\"line\">ostream&amp; operator&lt;&lt;(ostream&amp; cout,MyInteger myInt) &#123;</span><br><span class=\"line\">    cout &lt;&lt; myInt.my_int; &#x2F;&#x2F; 返回对象细节</span><br><span class=\"line\">    return cout;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    MyInteger myInt;</span><br><span class=\"line\">    cout &lt;&lt; myInt &lt;&lt; endl; &#x2F;&#x2F; 输出 my_int 的值 0</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关系运算符重载\"><a href=\"#关系运算符重载\" class=\"headerlink\" title=\"关系运算符重载\"></a>关系运算符重载</h3><p>Swift经常使用，参见<code>Equable</code>，<code>Comparable</code>协议</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Person</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    bool operator&#x3D;&#x3D;(Person &amp;p) &#123;</span><br><span class=\"line\">        if (this-&gt;m_Name &#x3D;&#x3D; p.m_Name) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bool operator!&#x3D;(Person &amp;p) &#123;</span><br><span class=\"line\">        if (this-&gt;m_Name !&#x3D; p.m_Name) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\tstring m_Name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tPerson p1; p1.m_Name &#x3D; &quot;A&quot;;</span><br><span class=\"line\">    Person p2; p2.m_Name &#x3D; &quot;A&quot;;</span><br><span class=\"line\">    if (p1 &#x3D;&#x3D; p2) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Equal&quot; &lt;&lt; endl; &#x2F;&#x2F; 输出</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Different&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (p1 !&#x3D; p2) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Different&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Equal&quot; &lt;&lt; endl; &#x2F;&#x2F; 输出</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数调用运算符的重载（骚操作）\"><a href=\"#函数调用运算符的重载（骚操作）\" class=\"headerlink\" title=\"函数调用运算符的重载（骚操作）\"></a>函数调用运算符的重载（骚操作）</h3><p>因为用起来很像函数，所以又叫做仿函数，STL里相当多这种骚操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyInteger &#123;</span><br><span class=\"line\">\tint operator()(int a,int b) &#123;</span><br><span class=\"line\">        return a + b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; MyInteger() ：匿名对象</span><br><span class=\"line\">    int result &#x3D; MyInteger()(1,2);</span><br><span class=\"line\"></span><br><span class=\"line\">    MyInteger i;</span><br><span class=\"line\">    int result2 &#x3D; i(5,2);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; result &lt;&lt; endl;  &#x2F;&#x2F; 5</span><br><span class=\"line\">    cout &lt;&lt; result2 &lt;&lt; endl; &#x2F;&#x2F; 7</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>C++有多继承，灰常厉害</p>\n<h3 id=\"继承方式\"><a href=\"#继承方式\" class=\"headerlink\" title=\"继承方式\"></a>继承方式</h3><p>三种继承方式<code>public</code>,<code>protected</code>,<code>private</code>，决定着继承下来的属性和方法以什么形式修饰，<code>class</code>默认<code>private</code>,<code>struct</code>默认<code>public</code>（没错，C++中结构体可以被继承）<br>父类的所有非静态属性会被继承，包括<code>private</code>类型的，但是<code>private</code>类型的默认隐藏，子类无法访问。</p>\n<p>继承语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class SubClass : public SuperClass &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"构造和析构\"><a href=\"#构造和析构\" class=\"headerlink\" title=\"构造和析构\"></a>构造和析构</h3><p>父类先构造，子类先析构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">superClass()</span><br><span class=\"line\">subClass()</span><br><span class=\"line\">~subClass()</span><br><span class=\"line\">~superClass()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"同名属性-函数-静态属性-静态函数的访问\"><a href=\"#同名属性-函数-静态属性-静态函数的访问\" class=\"headerlink\" title=\"同名属性/函数/静态属性/静态函数的访问\"></a>同名属性/函数/静态属性/静态函数的访问</h3><p>假如子类和父类拥有相同的名字的属性/函数/静态属性/静态函数，则直接调用子类对象的话都是访问子类的，如果要访问父类的话要添加作用域。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int _a &#x3D; 1;</span><br><span class=\"line\">    static int _b;</span><br><span class=\"line\">    static void staticFunc() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Base staticFunc()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void Func() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Base Func()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int Base::_b &#x3D; 10; &#x2F;&#x2F; 静态成员变量要在外面赋值</span><br><span class=\"line\"></span><br><span class=\"line\">class Sub1 : public Base &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int _a &#x3D; 2;</span><br><span class=\"line\">    static int _b;</span><br><span class=\"line\">    static void staticFunc() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;SubClass staticFunc()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void Func() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;SucClass Func()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int Sub1::_b &#x3D; 20;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Sub1 s;</span><br><span class=\"line\">    &#x2F;&#x2F; 直接调用</span><br><span class=\"line\">    cout &lt;&lt; s._a &lt;&lt; endl;</span><br><span class=\"line\">    &#x2F;&#x2F; 调用父类的</span><br><span class=\"line\">    cout &lt;&lt; s.Base::_a &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 静态直接调用</span><br><span class=\"line\">    cout &lt;&lt; s._b &lt;&lt; endl;</span><br><span class=\"line\">    &#x2F;&#x2F; 静态调用父类的</span><br><span class=\"line\">    cout &lt;&lt; s.Base::_b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 静态直接调用</span><br><span class=\"line\">    cout &lt;&lt; Sub1::_b &lt;&lt; endl;</span><br><span class=\"line\">    &#x2F;&#x2F; 静态调用父类的</span><br><span class=\"line\">    cout &lt;&lt; Sub1::Base::_b &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 直接调用</span><br><span class=\"line\">    s.Func();</span><br><span class=\"line\">    &#x2F;&#x2F; 调用父类的</span><br><span class=\"line\">    s.Base::Func();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 静态直接调用</span><br><span class=\"line\">    s.staticFunc();</span><br><span class=\"line\">    &#x2F;&#x2F; 静态调用父类的</span><br><span class=\"line\">    s.Base::staticFunc();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 静态直接调用</span><br><span class=\"line\">    Sub1::staticFunc();</span><br><span class=\"line\">    &#x2F;&#x2F; 静态调用父类的</span><br><span class=\"line\">    Sub1::Base::staticFunc();</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h3><p>不建议使用，因为麻烦事多</p>\n<p>语法：(参照上面的代码)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Other &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void Func() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Ohter Func()&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#x2F;&#x2F;...略</span><br><span class=\"line\">class Sub1 : public Base , public Other &#123;</span><br><span class=\"line\">&#x2F;&#x2F;...略</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当多个父类中出现同名属性/方法时，需要加作用域指定父类<code>s.Base::Func(); / s.Other::Func();</code></p>\n<h3 id=\"菱形继承（钻石继承）\"><a href=\"#菱形继承（钻石继承）\" class=\"headerlink\" title=\"菱形继承（钻石继承）\"></a>菱形继承（钻石继承）</h3><p>两个子类继承同一个基类，<br>又有某个类同时继承着两个子类</p>\n<p>举例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base &#123; int age &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Sub1: public Base &#123;&#125;;</span><br><span class=\"line\">class Sub2: public Base &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class SubSub: public Sub1, public Sub2 &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这时候SubSub会有两个父类，有两份 age 属性，造成资源浪费</p>\n<p>这时候用虚继承(<code>virtual</code>)解决问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Base &#123; public: int age &#125;; &#x2F;&#x2F; 这时候成为虚基类</span><br><span class=\"line\"></span><br><span class=\"line\">class Sub1: virtual public Base &#123;&#125;;</span><br><span class=\"line\">class Sub2: virtual public Base &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class SubSub: public Sub1, public Sub2 &#123;&#125;;</span><br></pre></td></tr></table></figure>\n<p>这时候age属性成为共享属性，最后谁改了就是谁的值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SubSub s;</span><br><span class=\"line\">s.Sub1::age &#x3D; 1;</span><br><span class=\"line\">s.Sub2::age &#x3D; 10;</span><br><span class=\"line\">cout &lt;&lt; s.Sub1::age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br><span class=\"line\">cout &lt;&lt; s.Sub2::age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br><span class=\"line\">cout &lt;&lt; s.age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p>C++中，多态分两类</p>\n<p>静态多态：函数重载和运算符重载属于静态多态，复用函数名<br>动态多态：子类和虚函数实现运行时多态</p>\n<p>区别：</p>\n<p>静态多态的函数地址早绑定，编译阶段确定函数地址<br>动态多态的函数地址晚绑定，运行阶段确定函数地址</p>\n<p>动态多态满足条件：</p>\n<ol>\n<li>有继承关系</li>\n<li>子类重写父类虚函数</li>\n</ol>\n<p>动态多态使用<br>父类的指针或者引用指向子类对象</p>\n<p>静态多态举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void speak() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Animal Speak&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class Cat: public Animal</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void speak() &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;Cat Speak&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">void SomeoneSpeak(Animal &amp;animal) &#123;</span><br><span class=\"line\">    animal.speak();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Cat c;</span><br><span class=\"line\">    SomeoneSpeak(c); &#x2F;&#x2F; 由于SomeoneSpeak(Animal &amp;animal)，编译期间已经确定入参类型，所以输出 Animal Speak</span><br></pre></td></tr></table></figure>\n\n<p>如果想输出<code>Cat Speak</code>，只需进行如下修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    virtual void speak() &#123; &#x2F;&#x2F; 虚函数，可以告知由于SomeoneSpeak(Animal &amp;animal)运行时再确定入参类型</span><br><span class=\"line\">        cout &lt;&lt; &quot;Animal Speak&quot; &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>经常地，这种情况下也是动态多态，最后会输出<code>Cat Speak</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal *a &#x3D; new Cat;</span><br><span class=\"line\">a-&gt;speak();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"纯虚函数和抽象类\"><a href=\"#纯虚函数和抽象类\" class=\"headerlink\" title=\"纯虚函数和抽象类\"></a>纯虚函数和抽象类</h3><p>父类的虚函数的实现没什么意义，所以上面的虚函数代码改写为<code>纯虚函数</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">virtual void speak() &#x3D; 0;</span><br></pre></td></tr></table></figure>\n\n<p>当类中有了纯虚函数，则这个类称为<code>抽象类</code></p>\n<p>抽象类<strong>无法实例化对象</strong>，并且<strong>子类必须重写父类的纯虚函数</strong>，否则也成为<code>抽象类</code></p>\n<h3 id=\"虚析构和纯虚析构\"><a href=\"#虚析构和纯虚析构\" class=\"headerlink\" title=\"虚析构和纯虚析构\"></a>虚析构和纯虚析构</h3><p>当子类在堆区创建数据的时候，需要手动释放，父类需要添加虚析构或者纯虚析构函数，否则子类可能不走析构函数</p>\n<p>比如上面的<code>Animate</code>父类，我们补充一下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    virtual ~Animal() &#x3D; 0; &#x2F;&#x2F; 纯虚析构</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal::~Animal() &#123; &#x2F;&#x2F; 析构实现</span><br><span class=\"line\">    cout &lt;&lt; &quot;Animal is Delete&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><p>文件打开方式</p>\n<p><code>ios::in</code>:读文件<br><code>ios::out</code>:写文件<br><code>ios::ate</code>:初始位置，文件尾<br><code>ios:app</code>:追加写文件<br><code>ios:trunc</code>:如果文件存在先删除，再创建<br><code>ios:binary</code>:二进制方式</p>\n<p>同时两种方式则使用<code>|</code>的方式，比如<code>ios::in|ios:binary</code></p>\n<h3 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ofstream stream;</span><br><span class=\"line\"></span><br><span class=\"line\">stream.open(&quot;Test.txt&quot;,ios::out);</span><br><span class=\"line\"></span><br><span class=\"line\">stream &lt;&lt; &quot;Line 1&quot; &lt;&lt; endl;</span><br><span class=\"line\">stream &lt;&lt; &quot;Line 2&quot; &lt;&lt; endl;</span><br><span class=\"line\">stream &lt;&lt; &quot;Line 3&quot; &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">stream.close();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifstream ifs;</span><br><span class=\"line\">ifs.open(&quot;Test.txt&quot;,ios::out);</span><br><span class=\"line\"></span><br><span class=\"line\">if(!ifs.is_open()) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;打开文件失败&quot; &lt;&lt; endl;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">string buf;</span><br><span class=\"line\">while (getline(ifs, buf)) &#123; &#x2F;&#x2F; 一行行读取</span><br><span class=\"line\">\tcout &lt;&lt; buf &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ifs.close();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h2><h3 id=\"构建类模板与类模板做参数\"><a href=\"#构建类模板与类模板做参数\" class=\"headerlink\" title=\"构建类模板与类模板做参数\"></a>构建类模板与类模板做参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class NameType,class AgeType&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Person(NameType name, AgeType age) &#123;</span><br><span class=\"line\">        this-&gt;_age &#x3D; age;</span><br><span class=\"line\">        this-&gt;_name &#x3D; name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    AgeType _age;</span><br><span class=\"line\">    NameType _name;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; 不会自动类型推导，需要自己显式声明类型</span><br><span class=\"line\">    Person&lt;string,int&gt; p(&quot;Haha&quot;,123);</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; p._name &lt;&lt; &quot; &quot; &lt;&lt; p._age &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可以给类模板添加默认类型</p>\n<p><code>template&lt;class NameType,class AgeType = int&gt;</code></p>\n<p>这样子调用的时候就可以不全声明类型了</p>\n<p><code>Person&lt;string&gt; p(&quot;Haha&quot;,123);</code></p>\n<p>类模板做参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 指定类型的类模板做参数</span><br><span class=\"line\">void print(Person&lt;string,int&gt; &amp;p) &#123;</span><br><span class=\"line\">    p.showPerson();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 模板化参数的类模板做参数</span><br><span class=\"line\">template&lt;class T1,class T2&gt;</span><br><span class=\"line\">void print2(Person&lt;T1, T2&gt; &amp;p) &#123;</span><br><span class=\"line\">    p.showPerson();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 模板化类做参数</span><br><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">void print3(T &amp;p) &#123;</span><br><span class=\"line\">    p.showPerson();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    Person&lt;string,int&gt; p(&quot;Haha&quot;,123);</span><br><span class=\"line\">    print(p);</span><br><span class=\"line\">    print2(p);</span><br><span class=\"line\">    print3(p);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类模板与继承\"><a href=\"#类模板与继承\" class=\"headerlink\" title=\"类模板与继承\"></a>类模板与继承</h3><p>继承时需要指定类型</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">class Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    T m;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class SubClass: public Base&lt;int&gt; &#123; &#x2F;&#x2F; 指定T的类型</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void print() &#123;</span><br><span class=\"line\">        cout &lt;&lt; m &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>如果不想指定类型，那么可以模板化子类</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">template&lt;class T&gt;</span><br><span class=\"line\">class Base</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    T m;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">template&lt;class T1,class T2&gt;</span><br><span class=\"line\">class SubClass: public Base&lt;T1&gt; &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    SubClass(T1 a, T2 b) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    T2 k;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tSubClass&lt;string, int&gt; c(&quot;String&quot;,1);</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"STL-之-Vector容器\"><a href=\"#STL-之-Vector容器\" class=\"headerlink\" title=\"STL 之 Vector容器\"></a>STL 之 Vector容器</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int&gt; v1; &#x2F;&#x2F; 初始化指定容器内元素类型</span><br><span class=\"line\">v1.assign(10, 1); &#x2F;&#x2F; 插入10个1，也可以传入其他vector,比如v1.assign(v0.begin,v0.end); 或者直接 v1 &#x3D; v0; 只要保证是同种类型就好</span><br><span class=\"line\">for (vector&lt;int&gt;::iterator i &#x3D; v1.begin(); i !&#x3D; v1.end() ; i++) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; *i &lt;&lt; endl;</span><br><span class=\"line\">&#125; &#x2F;&#x2F; 打印10个1</span><br><span class=\"line\">cout &lt;&lt; &quot;Size &#x3D; &quot; &lt;&lt; v1.size() &lt;&lt; endl; &#x2F;&#x2F; 长度 10</span><br><span class=\"line\">cout &lt;&lt; &quot;isEmpty &#x3D; &quot; &lt;&lt; v1.empty() &lt;&lt; endl; &#x2F;&#x2F; 判空 0</span><br><span class=\"line\">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 容量 10</span><br><span class=\"line\">v1.resize(20,20); &#x2F;&#x2F; 调整容量为20，多出来的位置用20填充，这里的20可以不传，默认0</span><br><span class=\"line\">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 现在容量变成20</span><br><span class=\"line\"></span><br><span class=\"line\">v1.pop_back(); &#x2F;&#x2F; 删除最后一个元素</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; &quot;Size &#x3D; &quot; &lt;&lt; v1.size() &lt;&lt; endl; &#x2F;&#x2F; 长度 19</span><br><span class=\"line\">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 容量不变 20</span><br><span class=\"line\"></span><br><span class=\"line\">v1.insert(v1.begin() + 1, 199); &#x2F;&#x2F; 下标为1的位置插入元素199</span><br><span class=\"line\">v1.insert(v1.begin() + 1, 2, 199); &#x2F;&#x2F; 下标为1的位置插入两个元素199</span><br><span class=\"line\">v1.erase(v1.begin() + 2); &#x2F;&#x2F; 删除第二个元素</span><br><span class=\"line\">v1.erase(v1.begin() + 2 , v1.begin() + 3); &#x2F;&#x2F; 删除第二个到第三个元素</span><br><span class=\"line\">v1.clear(); &#x2F;&#x2F; 清空容器</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; &quot;第二个元素是&quot; &lt;&lt; v1.at(1) &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; &quot;第三个元素是&quot; &lt;&lt; v1[2] &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; &quot;第一个元素&quot; &lt;&lt; v1.front() &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; &quot;最后一个元素&quot; &lt;&lt; v1.back() &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">v1.reverse(100000); &#x2F;&#x2F; 预留空间，减少以后动态拓展的次数</span><br><span class=\"line\"></span><br><span class=\"line\">v1.swap(v0); &#x2F;&#x2F; 交换元素，假如v1的预留空间很大，可以通过交换一个小预留空间的容器达到压缩内存的效果</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"2016-Dankal-iOS-MySummary","author":"Arclin","abbrlink":"61929cc2","date":"2017-01-23T16:00:00.000Z","_content":"总结2016在 Dankal 工作过程中学习到的东西\n\n<!-- more -->\n\n### Main Argument 主要论点\n中介者\n组件化\n封装\nMVVM\nReactiveCocoa\n\n### 基于MVC的组件化设计 CTMediator + （CTNetworking -> DKNetworking -> DKHTTPTool）\nCTMediator和CTNetworking 是我在5-6月份左右看的一套源码，出处是这里,然后去年年底作者又发布了[基于 CTMediator工程实践](http://casatwy.com/modulization_in_action.html)。总的设计思想如下：\n\n### 组件逻辑\n\n- CTMediator 是一种组件化方案，主要是针对大型项目多人开发情况下的一种方案。路由方式是 Targer-Action，通过这种方式进行模块之间的沟通，模块使用私有 pod 进行封装（这个是在第二篇的实践中提出来的），因为目前我们还没接触过这种大型的项目，所以一直停留在理论阶段（也就是虽然我看懂了源码的设计思想但是却没得地方实现），后来启动了觅书项目，打算尝试这种设计，结果发现过于大材小用了。模块的创建要先通过中介者进行注册，调用要通过中介者进行调用，总结一下大概就像这样子：\n\n```\n             --------------------------------------\n             | [CTMediator sharedInstance]        |\n             |                                    |\n             |                openUrl:       <<<<<<<<<  (AppDelegate)  <<<<  Call From Other App With URL\n             |                                    |\n             |                   |                |\n             |                   |/               |\n             |                parseUrl            |\n             |                                    |\n             |                   |                |\n.................................|...............................\n             |                   |                |\n             |                   |/               |\n             |  performTarget:action:params: <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  Call From Native Module\n             |                   |/               |\n             |             -------------          |\n             |             |  runtime  |          |\n             |             -------------          |\n             ---------------.---------.------------\n                           .           .\n                          .             .\n-------------------------------      --------------------------------\n|                       ·     |      |    ·                         |\n|                     ·       |      |     ·                        |\n|           Target            |      |           Target             |\n|                             |      |                              |\n|         /   |   \\           |      |         /   |   \\            |\n|        /    |    \\          |      |        /    |    \\           |\n|                             |      |                              |\n|   Action Action Action ...  |      |   Action Action Action ...   |\n|                             |      |                              |\n|Service  A                   |      | Service  B                   |\n-------------------------------      --------------------------------\n```\n\n这里面包括了内部调用和远程应用调用，远程应用调用因为我们目前还用不着所以先不管，内部调用的流程为了方便理解我举个例子，fromController通过performTarget:action:params:方法传入toController类名和在toController要执行的方法和所需的参数，这样子组件之间就实现了解耦，fromController 只需要知道他想去的地方是 toController和要给什么值出去，甚至这个 controller 存不存在都无所谓，而 toController 只需要遵循协议方法/重写父类方法去的到参数即可，然后里面就可以直接调这个参数，并且这一系列跳转规则和传参规则都通过 CTMediator 中介者去控制。\n\n### 服务层（Service Layer） 或者叫 业务层（Business Layer）\n\n刚刚总结了一下CTMediator的组件间的逻辑,现在来总结一下业务层与 ViewController 层之间的设计.因为虽然是 MVC，那当然也得尽量避免 Mess View Controller ,Service 在这里可以理解为数据仓库+业务逻辑仓库，为的是令ViewController中避免出现像数据 A处理判断完才显示到控件上的情况，尽量能把最直接的数据给 ViewController 显示,利用像下图这种方式，业务层暴露出 Target 和 action供外界调用，调用方法后就进入了CTMediator 进行处理，接下来的事情就像我上面说的一样了。\n\n```\n         --------------------------------\n         |           Service  A         |\n         ---  ----------  ----------  ---\n           |  |        |  |        |  |\n...........|  |........|  |........|  |...........\n.          |  |        |  |        |  |          .\n.        ---  ---    ---  ---    ---  ---        .\n.        |action|    |action|    |action|        .\n.        ---|----    -----|--    --|-----        .\n.           |             |        |             .\n.           |             |        |             .\n.       ----|------     --|--------|--           .\n.       |Target_A1|     |  Target_A2 |           .\n.       -----------     --------------           .\n..................................................\n```\n\n### CTNetworking -> DKNetworking -> DKHTTPTool\n\n- CTNetworking 是一个基于AFNetworking的开源网络层组件，经过改装之后我组装出了 DKNetworking（虽然后面发现有 RAC神器之后就觉得这个东西不够轻便了）。\n\n- CTNetworking 解决了以下几个问题\n\t- 使用哪种交互模式来跟业务层做对接？\n\t- 是否有必要将API返回的数据封装成对象然后再交付给业务层？\n\t- 使用集约化调用方式还是离散型调用方式去调用API？\n\n- 上面三个问题分别给出的答案是\n\t- 代理模式\n\t- 没必要\n\t- 离散型\n\n- CTNetworking考虑的东西相当地多，除了上面几个问题之外，还考虑到了网络层安全机制（数据传输，HTTPS）,链接环节的优化（链接传输量和链接复用）等，一开始看源码也是看的很懵逼\n- 通过协议的方式进行组件内的方法封装\n\n|协议名|解释|\n|----|----|\n|CTAPIManagerApiCallBackDelegate|回调协议|\n|CTAPIManagerCallbackDataReformer|负责重新组装API数据的对象|\n|CTAPIManagerValidator|验证器验证参数和返回|\n|CTAPIManagerParamSourceDelegate|参数源|\n|CTAPIManager|CTAPIBaseManager的派生类必须符合这个protocal|\n|CTAPIManagerInterceptor|拦截器，拦截参数和回调|\n\n- 用协议的好处就是各取所需。当你想要统一管理所有回调的时候，那你这个类只要遵循`CTAPIManagerApiCallBackDelegate`代理和实现对应的方法，如果你这个类想要拦截参数，那么就遵循`CTAPIManagerInterceptor`协议并实现对应的方法，大抵就是这种思想，然后底层就会进行各种判断并拼接各个协议的方法的返回值，最后发出请求，得到回调然后处理值并返回出去。\n\n- CTNetworking 框架没有使用数据模型，原因就是认为模型嵌入模型的时候处理数据很麻烦，另外模型的复用性很差，容易出现类型爆炸，提高维护成本，还有就是不够NSDictionary、NSArray直观,最最重要的一点就是同一API的数据被不同View展示时，难以控制数据转化的代码，它们有可能会散落在任何需要的地方。所以框架使用了 Reformer 的方法去处理返回的数据（NSDictionary）转成 View 需要的数据（NSDictionary）。\n\n- DKNetworking 把 Refromer 部分的实现给改了，依赖了 MJExtension，去实现数据模型数组，因为总感觉NSDictionary很麻烦，难维护就难维护吧，反正项目也不大。\n\n- DKHTTPTool 是我在近期集成出来的框架，主要特性包括：\n\t- 支持缓存策略选择\n\t- 支持链式调用\n\t- 支持 RACSignal 返回\n\t- 支持拦截器、验证器\n\t- 支持直观的Logger输出\n\t- 支持全局请求头、请求参数\n\t- 服务器异常直接弹出异常数据而不是一坨 NSData\n\t- 支持错误码表，统一处理错误\n    \n还有其他的吗？忘记了\n总的来说，这个还是挺管用的,毕竟能支持 RAC,符合我们现在的 \nMVVM+ReactiveCocoa的架构\n\n### MVVM+ReactiveCocoa\n\n- ReactiveCocoa 博大精深，以致于现在都用不到它提供的功能的一半\n- 第二份优秀的源码（虽然跑不起来）[MVVMReactiveCocoa](https://github.com/leichunfeng/MVVMReactiveCocoa)\n- 产出成品[Poi](https://coding.net/u/Arclin/p/Poi/git)\n\n### Navigation-With-ViewModel\n\n 使用 MVVM 模式应该注意的问题\n\n- 以 ViewModel 为驱动引导着整个应用而不是 ViewController\n- ViewModel 中不应该引入任何 UIKit 框架\n- 模块与模块间通过 服务总线 去沟通 , 减少模块之间的耦合\n\n先看看用 ViewModel 进行 push操作的流程\n\n ```\n--------------------------------    \n|        ViewModel A           |   \n---  ----------  ----------  ---   \n\t|\n\t| \n[- initWithService:params:]\n\t| ---------------\n\t| | service bus | --- > - pushViewModel: animated: \n\t| ---------------                 |\n\t|\t\t\t             （HOOK）[rac_responseToSelector:]\n\t|\t\t\t                     |/\n\t|\t\t\t               <DKNavigationProtocol>-- @{ viewModel:viewController}--->navigationController [pushViewController:animated:]\n\t|/\n --------------------------------\n |        ViewModel B           |\n ---  ----------  ----------  ---\n```\n\n说明： ViewModelA 与 ViewControllerA ，ViewModelB 与 ViewControllerB 在 Router 里面通过字典的方式绑定在了一起，然后通过 RAC的方法监听pushViewModel: animated: 方法的执行，然后通过字典得到viewController从而进行真正的 push 操作，大概就是这样子\n\n### 抽出父类和ReactiveCocoa\n\nMVVMReactiveCocoa 通过封装父类的方式来实现这个架构，这些父类已经被我抽出来了，过几天会传上去，然后先写一些使用说明\n\n1. 每个 Vc 对应一个 ViewModel\n2. TableViewController必须对应 ViewModel\n3. ViewModel 的初始化方法在 - initliazed 中\n4. 初始化之前添加一些额外的方法，需要重写 - initWithServer:params:\n5. DKTableViewController是一个二维数组，里面封装的是 viewmodel\n6. cell 要遵循 DKReactiveView 协议\n7. 绑定 cell与 viewModel 就在 ViewController里面重写 configureCell:withObject\n8. 待补充\n\nReativeCocoa 主要是用来实现 MVVM 的融合剂，当然也不一定要用 RAC去实现 MVVM,说实话 RAC 的学习成本还是相当高的，目前已经在尝试 DKRACHTTPTool,用纯 RAC 的方式去实现网络层和数据持久层的封装，另外还有些异常处理之类的,在这里面使用了filter: ignore: thottle: startWith: doNext: catch: try: doComplete: map: flattenMap: flatten: 等等的方法，非常好使，其他的可以看看我的几篇笔记\"使用RAC-DKHTTPTool实践\"、\"RACCommand使用注意\"\n\n最近的一个个人项目 Poi 就实践了这个架构。UI 结构如下\n\n```\n   \t    --------------------------------\n            |     NavigationConroller0     |\n            ---  ----------  ----------  ---\n\t\t\t    |\n \t    --------------------------------\n            |       TabBarController       |\n            ---  ----------  ----------  ---\n\t\t|\t\t\t |\n--------------------------------     --------------------------------   \n|     NavigationConroller1     |     |     NavigationConroller2     |\n---  ----------  ----------  ---     ---  ----------  ----------  ---\n\t\t|                   \t\t    |\n--------------------------------     --------------------------------\n|       ViewConroller1         |     |       ViewConroller2         |\n---  ----------  ----------  --      --------------------------------\n```\n\n默认整个应用的跳转用的是NavigationConroller0，这样子做的原因是使用了一个第三方框架，为了可以在TabBarController中滑动切换。\n当 pushViewModel 执行的时候，有一个 NavigationStack 会拿到最底部的 NavigationController 进行 push，如果 modal 出一个 navigationController,那么这个 navigationcontroller 将会压入NavigationStack ,然后这个 modal 出来的 viewController 后面的页面跳转就用这个 stack最上层的 NavigationController，dismiss 之后就会就会从栈中移除这个 NavigationController\n\n大概就是长这样子\n\n```\n--------------------------------\n|     NavigationConroller0     |  \n---  ----------  ----------  ---    \n\t\t |\tstack + 1\tpush\n--------------------------------    \n|       TabBarController       |    \n---  ----------  ----------  ---  \n\t\t |\t\t           \n--------------------------------   \n|     NavigationConroller1     |    \n---  ----------  ----------  ---    \n\t\t |      nv0 push     \n--------------------------------    \n|       ViewConroller1         |    \n---  ----------  ----------  ---\t  \n\t\t |   \tv1 modal\n--------------------------------    \n|      NavigationConroller2    |    \n---  ----------  ----------  ---\t  \n\t\t |     stack + 1  push   \n--------------------------------    \n|      ViewConroller2\t       |    \n---  ----------  ----------  ---\t\n\t\t| dismiss\n\tstack - 1 pop\n```\n\n### MVVM WithOut ReacitveCocoa\n用 Block 的方式代替 Reactive 的绑定功能。\n\n### 其他\n- BugReporter For iOS\n\t- 和思华一起开发的基于 iOS 的 bug自动反馈系统，一旦发生崩溃事故就会给开发者发送邮件\n- 自动部署系统Jenkines\n- JSPatch 热修复平台\n- UMeng 用户数据统计\n- 等等","source":"_posts/2016-Dankal-iOS-MySummary.md","raw":"---\ntitle: 2016-Dankal-iOS-MySummary\nauthor: Arclin\ntags:\n  - iOS\n  - 杂谈\ncategories:\n  - iOS\nabbrlink: 61929cc2\ndate: 2017-01-24 00:00:00\n---\n总结2016在 Dankal 工作过程中学习到的东西\n\n<!-- more -->\n\n### Main Argument 主要论点\n中介者\n组件化\n封装\nMVVM\nReactiveCocoa\n\n### 基于MVC的组件化设计 CTMediator + （CTNetworking -> DKNetworking -> DKHTTPTool）\nCTMediator和CTNetworking 是我在5-6月份左右看的一套源码，出处是这里,然后去年年底作者又发布了[基于 CTMediator工程实践](http://casatwy.com/modulization_in_action.html)。总的设计思想如下：\n\n### 组件逻辑\n\n- CTMediator 是一种组件化方案，主要是针对大型项目多人开发情况下的一种方案。路由方式是 Targer-Action，通过这种方式进行模块之间的沟通，模块使用私有 pod 进行封装（这个是在第二篇的实践中提出来的），因为目前我们还没接触过这种大型的项目，所以一直停留在理论阶段（也就是虽然我看懂了源码的设计思想但是却没得地方实现），后来启动了觅书项目，打算尝试这种设计，结果发现过于大材小用了。模块的创建要先通过中介者进行注册，调用要通过中介者进行调用，总结一下大概就像这样子：\n\n```\n             --------------------------------------\n             | [CTMediator sharedInstance]        |\n             |                                    |\n             |                openUrl:       <<<<<<<<<  (AppDelegate)  <<<<  Call From Other App With URL\n             |                                    |\n             |                   |                |\n             |                   |/               |\n             |                parseUrl            |\n             |                                    |\n             |                   |                |\n.................................|...............................\n             |                   |                |\n             |                   |/               |\n             |  performTarget:action:params: <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  Call From Native Module\n             |                   |/               |\n             |             -------------          |\n             |             |  runtime  |          |\n             |             -------------          |\n             ---------------.---------.------------\n                           .           .\n                          .             .\n-------------------------------      --------------------------------\n|                       ·     |      |    ·                         |\n|                     ·       |      |     ·                        |\n|           Target            |      |           Target             |\n|                             |      |                              |\n|         /   |   \\           |      |         /   |   \\            |\n|        /    |    \\          |      |        /    |    \\           |\n|                             |      |                              |\n|   Action Action Action ...  |      |   Action Action Action ...   |\n|                             |      |                              |\n|Service  A                   |      | Service  B                   |\n-------------------------------      --------------------------------\n```\n\n这里面包括了内部调用和远程应用调用，远程应用调用因为我们目前还用不着所以先不管，内部调用的流程为了方便理解我举个例子，fromController通过performTarget:action:params:方法传入toController类名和在toController要执行的方法和所需的参数，这样子组件之间就实现了解耦，fromController 只需要知道他想去的地方是 toController和要给什么值出去，甚至这个 controller 存不存在都无所谓，而 toController 只需要遵循协议方法/重写父类方法去的到参数即可，然后里面就可以直接调这个参数，并且这一系列跳转规则和传参规则都通过 CTMediator 中介者去控制。\n\n### 服务层（Service Layer） 或者叫 业务层（Business Layer）\n\n刚刚总结了一下CTMediator的组件间的逻辑,现在来总结一下业务层与 ViewController 层之间的设计.因为虽然是 MVC，那当然也得尽量避免 Mess View Controller ,Service 在这里可以理解为数据仓库+业务逻辑仓库，为的是令ViewController中避免出现像数据 A处理判断完才显示到控件上的情况，尽量能把最直接的数据给 ViewController 显示,利用像下图这种方式，业务层暴露出 Target 和 action供外界调用，调用方法后就进入了CTMediator 进行处理，接下来的事情就像我上面说的一样了。\n\n```\n         --------------------------------\n         |           Service  A         |\n         ---  ----------  ----------  ---\n           |  |        |  |        |  |\n...........|  |........|  |........|  |...........\n.          |  |        |  |        |  |          .\n.        ---  ---    ---  ---    ---  ---        .\n.        |action|    |action|    |action|        .\n.        ---|----    -----|--    --|-----        .\n.           |             |        |             .\n.           |             |        |             .\n.       ----|------     --|--------|--           .\n.       |Target_A1|     |  Target_A2 |           .\n.       -----------     --------------           .\n..................................................\n```\n\n### CTNetworking -> DKNetworking -> DKHTTPTool\n\n- CTNetworking 是一个基于AFNetworking的开源网络层组件，经过改装之后我组装出了 DKNetworking（虽然后面发现有 RAC神器之后就觉得这个东西不够轻便了）。\n\n- CTNetworking 解决了以下几个问题\n\t- 使用哪种交互模式来跟业务层做对接？\n\t- 是否有必要将API返回的数据封装成对象然后再交付给业务层？\n\t- 使用集约化调用方式还是离散型调用方式去调用API？\n\n- 上面三个问题分别给出的答案是\n\t- 代理模式\n\t- 没必要\n\t- 离散型\n\n- CTNetworking考虑的东西相当地多，除了上面几个问题之外，还考虑到了网络层安全机制（数据传输，HTTPS）,链接环节的优化（链接传输量和链接复用）等，一开始看源码也是看的很懵逼\n- 通过协议的方式进行组件内的方法封装\n\n|协议名|解释|\n|----|----|\n|CTAPIManagerApiCallBackDelegate|回调协议|\n|CTAPIManagerCallbackDataReformer|负责重新组装API数据的对象|\n|CTAPIManagerValidator|验证器验证参数和返回|\n|CTAPIManagerParamSourceDelegate|参数源|\n|CTAPIManager|CTAPIBaseManager的派生类必须符合这个protocal|\n|CTAPIManagerInterceptor|拦截器，拦截参数和回调|\n\n- 用协议的好处就是各取所需。当你想要统一管理所有回调的时候，那你这个类只要遵循`CTAPIManagerApiCallBackDelegate`代理和实现对应的方法，如果你这个类想要拦截参数，那么就遵循`CTAPIManagerInterceptor`协议并实现对应的方法，大抵就是这种思想，然后底层就会进行各种判断并拼接各个协议的方法的返回值，最后发出请求，得到回调然后处理值并返回出去。\n\n- CTNetworking 框架没有使用数据模型，原因就是认为模型嵌入模型的时候处理数据很麻烦，另外模型的复用性很差，容易出现类型爆炸，提高维护成本，还有就是不够NSDictionary、NSArray直观,最最重要的一点就是同一API的数据被不同View展示时，难以控制数据转化的代码，它们有可能会散落在任何需要的地方。所以框架使用了 Reformer 的方法去处理返回的数据（NSDictionary）转成 View 需要的数据（NSDictionary）。\n\n- DKNetworking 把 Refromer 部分的实现给改了，依赖了 MJExtension，去实现数据模型数组，因为总感觉NSDictionary很麻烦，难维护就难维护吧，反正项目也不大。\n\n- DKHTTPTool 是我在近期集成出来的框架，主要特性包括：\n\t- 支持缓存策略选择\n\t- 支持链式调用\n\t- 支持 RACSignal 返回\n\t- 支持拦截器、验证器\n\t- 支持直观的Logger输出\n\t- 支持全局请求头、请求参数\n\t- 服务器异常直接弹出异常数据而不是一坨 NSData\n\t- 支持错误码表，统一处理错误\n    \n还有其他的吗？忘记了\n总的来说，这个还是挺管用的,毕竟能支持 RAC,符合我们现在的 \nMVVM+ReactiveCocoa的架构\n\n### MVVM+ReactiveCocoa\n\n- ReactiveCocoa 博大精深，以致于现在都用不到它提供的功能的一半\n- 第二份优秀的源码（虽然跑不起来）[MVVMReactiveCocoa](https://github.com/leichunfeng/MVVMReactiveCocoa)\n- 产出成品[Poi](https://coding.net/u/Arclin/p/Poi/git)\n\n### Navigation-With-ViewModel\n\n 使用 MVVM 模式应该注意的问题\n\n- 以 ViewModel 为驱动引导着整个应用而不是 ViewController\n- ViewModel 中不应该引入任何 UIKit 框架\n- 模块与模块间通过 服务总线 去沟通 , 减少模块之间的耦合\n\n先看看用 ViewModel 进行 push操作的流程\n\n ```\n--------------------------------    \n|        ViewModel A           |   \n---  ----------  ----------  ---   \n\t|\n\t| \n[- initWithService:params:]\n\t| ---------------\n\t| | service bus | --- > - pushViewModel: animated: \n\t| ---------------                 |\n\t|\t\t\t             （HOOK）[rac_responseToSelector:]\n\t|\t\t\t                     |/\n\t|\t\t\t               <DKNavigationProtocol>-- @{ viewModel:viewController}--->navigationController [pushViewController:animated:]\n\t|/\n --------------------------------\n |        ViewModel B           |\n ---  ----------  ----------  ---\n```\n\n说明： ViewModelA 与 ViewControllerA ，ViewModelB 与 ViewControllerB 在 Router 里面通过字典的方式绑定在了一起，然后通过 RAC的方法监听pushViewModel: animated: 方法的执行，然后通过字典得到viewController从而进行真正的 push 操作，大概就是这样子\n\n### 抽出父类和ReactiveCocoa\n\nMVVMReactiveCocoa 通过封装父类的方式来实现这个架构，这些父类已经被我抽出来了，过几天会传上去，然后先写一些使用说明\n\n1. 每个 Vc 对应一个 ViewModel\n2. TableViewController必须对应 ViewModel\n3. ViewModel 的初始化方法在 - initliazed 中\n4. 初始化之前添加一些额外的方法，需要重写 - initWithServer:params:\n5. DKTableViewController是一个二维数组，里面封装的是 viewmodel\n6. cell 要遵循 DKReactiveView 协议\n7. 绑定 cell与 viewModel 就在 ViewController里面重写 configureCell:withObject\n8. 待补充\n\nReativeCocoa 主要是用来实现 MVVM 的融合剂，当然也不一定要用 RAC去实现 MVVM,说实话 RAC 的学习成本还是相当高的，目前已经在尝试 DKRACHTTPTool,用纯 RAC 的方式去实现网络层和数据持久层的封装，另外还有些异常处理之类的,在这里面使用了filter: ignore: thottle: startWith: doNext: catch: try: doComplete: map: flattenMap: flatten: 等等的方法，非常好使，其他的可以看看我的几篇笔记\"使用RAC-DKHTTPTool实践\"、\"RACCommand使用注意\"\n\n最近的一个个人项目 Poi 就实践了这个架构。UI 结构如下\n\n```\n   \t    --------------------------------\n            |     NavigationConroller0     |\n            ---  ----------  ----------  ---\n\t\t\t    |\n \t    --------------------------------\n            |       TabBarController       |\n            ---  ----------  ----------  ---\n\t\t|\t\t\t |\n--------------------------------     --------------------------------   \n|     NavigationConroller1     |     |     NavigationConroller2     |\n---  ----------  ----------  ---     ---  ----------  ----------  ---\n\t\t|                   \t\t    |\n--------------------------------     --------------------------------\n|       ViewConroller1         |     |       ViewConroller2         |\n---  ----------  ----------  --      --------------------------------\n```\n\n默认整个应用的跳转用的是NavigationConroller0，这样子做的原因是使用了一个第三方框架，为了可以在TabBarController中滑动切换。\n当 pushViewModel 执行的时候，有一个 NavigationStack 会拿到最底部的 NavigationController 进行 push，如果 modal 出一个 navigationController,那么这个 navigationcontroller 将会压入NavigationStack ,然后这个 modal 出来的 viewController 后面的页面跳转就用这个 stack最上层的 NavigationController，dismiss 之后就会就会从栈中移除这个 NavigationController\n\n大概就是长这样子\n\n```\n--------------------------------\n|     NavigationConroller0     |  \n---  ----------  ----------  ---    \n\t\t |\tstack + 1\tpush\n--------------------------------    \n|       TabBarController       |    \n---  ----------  ----------  ---  \n\t\t |\t\t           \n--------------------------------   \n|     NavigationConroller1     |    \n---  ----------  ----------  ---    \n\t\t |      nv0 push     \n--------------------------------    \n|       ViewConroller1         |    \n---  ----------  ----------  ---\t  \n\t\t |   \tv1 modal\n--------------------------------    \n|      NavigationConroller2    |    \n---  ----------  ----------  ---\t  \n\t\t |     stack + 1  push   \n--------------------------------    \n|      ViewConroller2\t       |    \n---  ----------  ----------  ---\t\n\t\t| dismiss\n\tstack - 1 pop\n```\n\n### MVVM WithOut ReacitveCocoa\n用 Block 的方式代替 Reactive 的绑定功能。\n\n### 其他\n- BugReporter For iOS\n\t- 和思华一起开发的基于 iOS 的 bug自动反馈系统，一旦发生崩溃事故就会给开发者发送邮件\n- 自动部署系统Jenkines\n- JSPatch 热修复平台\n- UMeng 用户数据统计\n- 等等","slug":"2016-Dankal-iOS-MySummary","published":1,"updated":"2021-04-12T06:07:04.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog4q000a45n00avj47vk","content":"<p>总结2016在 Dankal 工作过程中学习到的东西</p>\n<span id=\"more\"></span>\n\n<h3 id=\"Main-Argument-主要论点\"><a href=\"#Main-Argument-主要论点\" class=\"headerlink\" title=\"Main Argument 主要论点\"></a>Main Argument 主要论点</h3><p>中介者<br>组件化<br>封装<br>MVVM<br>ReactiveCocoa</p>\n<h3 id=\"基于MVC的组件化设计-CTMediator-（CTNetworking-gt-DKNetworking-gt-DKHTTPTool）\"><a href=\"#基于MVC的组件化设计-CTMediator-（CTNetworking-gt-DKNetworking-gt-DKHTTPTool）\" class=\"headerlink\" title=\"基于MVC的组件化设计 CTMediator + （CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool）\"></a>基于MVC的组件化设计 CTMediator + （CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool）</h3><p>CTMediator和CTNetworking 是我在5-6月份左右看的一套源码，出处是这里,然后去年年底作者又发布了<a href=\"http://casatwy.com/modulization_in_action.html\">基于 CTMediator工程实践</a>。总的设计思想如下：</p>\n<h3 id=\"组件逻辑\"><a href=\"#组件逻辑\" class=\"headerlink\" title=\"组件逻辑\"></a>组件逻辑</h3><ul>\n<li>CTMediator 是一种组件化方案，主要是针对大型项目多人开发情况下的一种方案。路由方式是 Targer-Action，通过这种方式进行模块之间的沟通，模块使用私有 pod 进行封装（这个是在第二篇的实践中提出来的），因为目前我们还没接触过这种大型的项目，所以一直停留在理论阶段（也就是虽然我看懂了源码的设计思想但是却没得地方实现），后来启动了觅书项目，打算尝试这种设计，结果发现过于大材小用了。模块的创建要先通过中介者进行注册，调用要通过中介者进行调用，总结一下大概就像这样子：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">             --------------------------------------</span><br><span class=\"line\">             | [CTMediator sharedInstance]        |</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                openUrl:       &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  (AppDelegate)  &lt;&lt;&lt;&lt;  Call From Other App With URL</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">             |                   |&#x2F;               |</span><br><span class=\"line\">             |                parseUrl            |</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">.................................|...............................</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">             |                   |&#x2F;               |</span><br><span class=\"line\">             |  performTarget:action:params: &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  Call From Native Module</span><br><span class=\"line\">             |                   |&#x2F;               |</span><br><span class=\"line\">             |             -------------          |</span><br><span class=\"line\">             |             |  runtime  |          |</span><br><span class=\"line\">             |             -------------          |</span><br><span class=\"line\">             ---------------.---------.------------</span><br><span class=\"line\">                           .           .</span><br><span class=\"line\">                          .             .</span><br><span class=\"line\">-------------------------------      --------------------------------</span><br><span class=\"line\">|                       ·     |      |    ·                         |</span><br><span class=\"line\">|                     ·       |      |     ·                        |</span><br><span class=\"line\">|           Target            |      |           Target             |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|         &#x2F;   |   \\           |      |         &#x2F;   |   \\            |</span><br><span class=\"line\">|        &#x2F;    |    \\          |      |        &#x2F;    |    \\           |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|   Action Action Action ...  |      |   Action Action Action ...   |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|Service  A                   |      | Service  B                   |</span><br><span class=\"line\">-------------------------------      --------------------------------</span><br></pre></td></tr></table></figure>\n\n<p>这里面包括了内部调用和远程应用调用，远程应用调用因为我们目前还用不着所以先不管，内部调用的流程为了方便理解我举个例子，fromController通过performTarget:action:params:方法传入toController类名和在toController要执行的方法和所需的参数，这样子组件之间就实现了解耦，fromController 只需要知道他想去的地方是 toController和要给什么值出去，甚至这个 controller 存不存在都无所谓，而 toController 只需要遵循协议方法/重写父类方法去的到参数即可，然后里面就可以直接调这个参数，并且这一系列跳转规则和传参规则都通过 CTMediator 中介者去控制。</p>\n<h3 id=\"服务层（Service-Layer）-或者叫-业务层（Business-Layer）\"><a href=\"#服务层（Service-Layer）-或者叫-业务层（Business-Layer）\" class=\"headerlink\" title=\"服务层（Service Layer） 或者叫 业务层（Business Layer）\"></a>服务层（Service Layer） 或者叫 业务层（Business Layer）</h3><p>刚刚总结了一下CTMediator的组件间的逻辑,现在来总结一下业务层与 ViewController 层之间的设计.因为虽然是 MVC，那当然也得尽量避免 Mess View Controller ,Service 在这里可以理解为数据仓库+业务逻辑仓库，为的是令ViewController中避免出现像数据 A处理判断完才显示到控件上的情况，尽量能把最直接的数据给 ViewController 显示,利用像下图这种方式，业务层暴露出 Target 和 action供外界调用，调用方法后就进入了CTMediator 进行处理，接下来的事情就像我上面说的一样了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         --------------------------------</span><br><span class=\"line\">         |           Service  A         |</span><br><span class=\"line\">         ---  ----------  ----------  ---</span><br><span class=\"line\">           |  |        |  |        |  |</span><br><span class=\"line\">...........|  |........|  |........|  |...........</span><br><span class=\"line\">.          |  |        |  |        |  |          .</span><br><span class=\"line\">.        ---  ---    ---  ---    ---  ---        .</span><br><span class=\"line\">.        |action|    |action|    |action|        .</span><br><span class=\"line\">.        ---|----    -----|--    --|-----        .</span><br><span class=\"line\">.           |             |        |             .</span><br><span class=\"line\">.           |             |        |             .</span><br><span class=\"line\">.       ----|------     --|--------|--           .</span><br><span class=\"line\">.       |Target_A1|     |  Target_A2 |           .</span><br><span class=\"line\">.       -----------     --------------           .</span><br><span class=\"line\">..................................................</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CTNetworking-gt-DKNetworking-gt-DKHTTPTool\"><a href=\"#CTNetworking-gt-DKNetworking-gt-DKHTTPTool\" class=\"headerlink\" title=\"CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool\"></a>CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool</h3><ul>\n<li><p>CTNetworking 是一个基于AFNetworking的开源网络层组件，经过改装之后我组装出了 DKNetworking（虽然后面发现有 RAC神器之后就觉得这个东西不够轻便了）。</p>\n</li>\n<li><p>CTNetworking 解决了以下几个问题</p>\n<ul>\n<li>使用哪种交互模式来跟业务层做对接？</li>\n<li>是否有必要将API返回的数据封装成对象然后再交付给业务层？</li>\n<li>使用集约化调用方式还是离散型调用方式去调用API？</li>\n</ul>\n</li>\n<li><p>上面三个问题分别给出的答案是</p>\n<ul>\n<li>代理模式</li>\n<li>没必要</li>\n<li>离散型</li>\n</ul>\n</li>\n<li><p>CTNetworking考虑的东西相当地多，除了上面几个问题之外，还考虑到了网络层安全机制（数据传输，HTTPS）,链接环节的优化（链接传输量和链接复用）等，一开始看源码也是看的很懵逼</p>\n</li>\n<li><p>通过协议的方式进行组件内的方法封装</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>协议名</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CTAPIManagerApiCallBackDelegate</td>\n<td>回调协议</td>\n</tr>\n<tr>\n<td>CTAPIManagerCallbackDataReformer</td>\n<td>负责重新组装API数据的对象</td>\n</tr>\n<tr>\n<td>CTAPIManagerValidator</td>\n<td>验证器验证参数和返回</td>\n</tr>\n<tr>\n<td>CTAPIManagerParamSourceDelegate</td>\n<td>参数源</td>\n</tr>\n<tr>\n<td>CTAPIManager</td>\n<td>CTAPIBaseManager的派生类必须符合这个protocal</td>\n</tr>\n<tr>\n<td>CTAPIManagerInterceptor</td>\n<td>拦截器，拦截参数和回调</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>用协议的好处就是各取所需。当你想要统一管理所有回调的时候，那你这个类只要遵循<code>CTAPIManagerApiCallBackDelegate</code>代理和实现对应的方法，如果你这个类想要拦截参数，那么就遵循<code>CTAPIManagerInterceptor</code>协议并实现对应的方法，大抵就是这种思想，然后底层就会进行各种判断并拼接各个协议的方法的返回值，最后发出请求，得到回调然后处理值并返回出去。</p>\n</li>\n<li><p>CTNetworking 框架没有使用数据模型，原因就是认为模型嵌入模型的时候处理数据很麻烦，另外模型的复用性很差，容易出现类型爆炸，提高维护成本，还有就是不够NSDictionary、NSArray直观,最最重要的一点就是同一API的数据被不同View展示时，难以控制数据转化的代码，它们有可能会散落在任何需要的地方。所以框架使用了 Reformer 的方法去处理返回的数据（NSDictionary）转成 View 需要的数据（NSDictionary）。</p>\n</li>\n<li><p>DKNetworking 把 Refromer 部分的实现给改了，依赖了 MJExtension，去实现数据模型数组，因为总感觉NSDictionary很麻烦，难维护就难维护吧，反正项目也不大。</p>\n</li>\n<li><p>DKHTTPTool 是我在近期集成出来的框架，主要特性包括：</p>\n<ul>\n<li>支持缓存策略选择</li>\n<li>支持链式调用</li>\n<li>支持 RACSignal 返回</li>\n<li>支持拦截器、验证器</li>\n<li>支持直观的Logger输出</li>\n<li>支持全局请求头、请求参数</li>\n<li>服务器异常直接弹出异常数据而不是一坨 NSData</li>\n<li>支持错误码表，统一处理错误</li>\n</ul>\n</li>\n</ul>\n<p>还有其他的吗？忘记了<br>总的来说，这个还是挺管用的,毕竟能支持 RAC,符合我们现在的<br>MVVM+ReactiveCocoa的架构</p>\n<h3 id=\"MVVM-ReactiveCocoa\"><a href=\"#MVVM-ReactiveCocoa\" class=\"headerlink\" title=\"MVVM+ReactiveCocoa\"></a>MVVM+ReactiveCocoa</h3><ul>\n<li>ReactiveCocoa 博大精深，以致于现在都用不到它提供的功能的一半</li>\n<li>第二份优秀的源码（虽然跑不起来）<a href=\"https://github.com/leichunfeng/MVVMReactiveCocoa\">MVVMReactiveCocoa</a></li>\n<li>产出成品<a href=\"https://coding.net/u/Arclin/p/Poi/git\">Poi</a></li>\n</ul>\n<h3 id=\"Navigation-With-ViewModel\"><a href=\"#Navigation-With-ViewModel\" class=\"headerlink\" title=\"Navigation-With-ViewModel\"></a>Navigation-With-ViewModel</h3><p> 使用 MVVM 模式应该注意的问题</p>\n<ul>\n<li>以 ViewModel 为驱动引导着整个应用而不是 ViewController</li>\n<li>ViewModel 中不应该引入任何 UIKit 框架</li>\n<li>模块与模块间通过 服务总线 去沟通 , 减少模块之间的耦合</li>\n</ul>\n<p>先看看用 ViewModel 进行 push操作的流程</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|        ViewModel A           |   </span><br><span class=\"line\">---  ----------  ----------  ---   </span><br><span class=\"line\">\t|</span><br><span class=\"line\">\t| </span><br><span class=\"line\">[- initWithService:params:]</span><br><span class=\"line\">\t| ---------------</span><br><span class=\"line\">\t| | service bus | --- &gt; - pushViewModel: animated: </span><br><span class=\"line\">\t| ---------------                 |</span><br><span class=\"line\">\t|\t\t\t             （HOOK）[rac_responseToSelector:]</span><br><span class=\"line\">\t|\t\t\t                     |&#x2F;</span><br><span class=\"line\">\t|\t\t\t               &lt;DKNavigationProtocol&gt;-- @&#123; viewModel:viewController&#125;---&gt;navigationController [pushViewController:animated:]</span><br><span class=\"line\">\t|&#x2F;</span><br><span class=\"line\"> --------------------------------</span><br><span class=\"line\"> |        ViewModel B           |</span><br><span class=\"line\"> ---  ----------  ----------  ---</span><br></pre></td></tr></table></figure>\n\n<p>说明： ViewModelA 与 ViewControllerA ，ViewModelB 与 ViewControllerB 在 Router 里面通过字典的方式绑定在了一起，然后通过 RAC的方法监听pushViewModel: animated: 方法的执行，然后通过字典得到viewController从而进行真正的 push 操作，大概就是这样子</p>\n<h3 id=\"抽出父类和ReactiveCocoa\"><a href=\"#抽出父类和ReactiveCocoa\" class=\"headerlink\" title=\"抽出父类和ReactiveCocoa\"></a>抽出父类和ReactiveCocoa</h3><p>MVVMReactiveCocoa 通过封装父类的方式来实现这个架构，这些父类已经被我抽出来了，过几天会传上去，然后先写一些使用说明</p>\n<ol>\n<li>每个 Vc 对应一个 ViewModel</li>\n<li>TableViewController必须对应 ViewModel</li>\n<li>ViewModel 的初始化方法在 - initliazed 中</li>\n<li>初始化之前添加一些额外的方法，需要重写 - initWithServer:params:</li>\n<li>DKTableViewController是一个二维数组，里面封装的是 viewmodel</li>\n<li>cell 要遵循 DKReactiveView 协议</li>\n<li>绑定 cell与 viewModel 就在 ViewController里面重写 configureCell:withObject</li>\n<li>待补充</li>\n</ol>\n<p>ReativeCocoa 主要是用来实现 MVVM 的融合剂，当然也不一定要用 RAC去实现 MVVM,说实话 RAC 的学习成本还是相当高的，目前已经在尝试 DKRACHTTPTool,用纯 RAC 的方式去实现网络层和数据持久层的封装，另外还有些异常处理之类的,在这里面使用了filter: ignore: thottle: startWith: doNext: catch: try: doComplete: map: flattenMap: flatten: 等等的方法，非常好使，其他的可以看看我的几篇笔记”使用RAC-DKHTTPTool实践”、”RACCommand使用注意”</p>\n<p>最近的一个个人项目 Poi 就实践了这个架构。UI 结构如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   \t    --------------------------------</span><br><span class=\"line\">            |     NavigationConroller0     |</span><br><span class=\"line\">            ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t\t    |</span><br><span class=\"line\"> \t    --------------------------------</span><br><span class=\"line\">            |       TabBarController       |</span><br><span class=\"line\">            ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t|\t\t\t |</span><br><span class=\"line\">--------------------------------     --------------------------------   </span><br><span class=\"line\">|     NavigationConroller1     |     |     NavigationConroller2     |</span><br><span class=\"line\">---  ----------  ----------  ---     ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t|                   \t\t    |</span><br><span class=\"line\">--------------------------------     --------------------------------</span><br><span class=\"line\">|       ViewConroller1         |     |       ViewConroller2         |</span><br><span class=\"line\">---  ----------  ----------  --      --------------------------------</span><br></pre></td></tr></table></figure>\n\n<p>默认整个应用的跳转用的是NavigationConroller0，这样子做的原因是使用了一个第三方框架，为了可以在TabBarController中滑动切换。<br>当 pushViewModel 执行的时候，有一个 NavigationStack 会拿到最底部的 NavigationController 进行 push，如果 modal 出一个 navigationController,那么这个 navigationcontroller 将会压入NavigationStack ,然后这个 modal 出来的 viewController 后面的页面跳转就用这个 stack最上层的 NavigationController，dismiss 之后就会就会从栈中移除这个 NavigationController</p>\n<p>大概就是长这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------------------------------</span><br><span class=\"line\">|     NavigationConroller0     |  </span><br><span class=\"line\">---  ----------  ----------  ---    </span><br><span class=\"line\">\t\t |\tstack + 1\tpush</span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|       TabBarController       |    </span><br><span class=\"line\">---  ----------  ----------  ---  </span><br><span class=\"line\">\t\t |\t\t           </span><br><span class=\"line\">--------------------------------   </span><br><span class=\"line\">|     NavigationConroller1     |    </span><br><span class=\"line\">---  ----------  ----------  ---    </span><br><span class=\"line\">\t\t |      nv0 push     </span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|       ViewConroller1         |    </span><br><span class=\"line\">---  ----------  ----------  ---\t  </span><br><span class=\"line\">\t\t |   \tv1 modal</span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|      NavigationConroller2    |    </span><br><span class=\"line\">---  ----------  ----------  ---\t  </span><br><span class=\"line\">\t\t |     stack + 1  push   </span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|      ViewConroller2\t       |    </span><br><span class=\"line\">---  ----------  ----------  ---\t</span><br><span class=\"line\">\t\t| dismiss</span><br><span class=\"line\">\tstack - 1 pop</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MVVM-WithOut-ReacitveCocoa\"><a href=\"#MVVM-WithOut-ReacitveCocoa\" class=\"headerlink\" title=\"MVVM WithOut ReacitveCocoa\"></a>MVVM WithOut ReacitveCocoa</h3><p>用 Block 的方式代替 Reactive 的绑定功能。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>BugReporter For iOS<ul>\n<li>和思华一起开发的基于 iOS 的 bug自动反馈系统，一旦发生崩溃事故就会给开发者发送邮件</li>\n</ul>\n</li>\n<li>自动部署系统Jenkines</li>\n<li>JSPatch 热修复平台</li>\n<li>UMeng 用户数据统计</li>\n<li>等等</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>总结2016在 Dankal 工作过程中学习到的东西</p>","more":"<h3 id=\"Main-Argument-主要论点\"><a href=\"#Main-Argument-主要论点\" class=\"headerlink\" title=\"Main Argument 主要论点\"></a>Main Argument 主要论点</h3><p>中介者<br>组件化<br>封装<br>MVVM<br>ReactiveCocoa</p>\n<h3 id=\"基于MVC的组件化设计-CTMediator-（CTNetworking-gt-DKNetworking-gt-DKHTTPTool）\"><a href=\"#基于MVC的组件化设计-CTMediator-（CTNetworking-gt-DKNetworking-gt-DKHTTPTool）\" class=\"headerlink\" title=\"基于MVC的组件化设计 CTMediator + （CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool）\"></a>基于MVC的组件化设计 CTMediator + （CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool）</h3><p>CTMediator和CTNetworking 是我在5-6月份左右看的一套源码，出处是这里,然后去年年底作者又发布了<a href=\"http://casatwy.com/modulization_in_action.html\">基于 CTMediator工程实践</a>。总的设计思想如下：</p>\n<h3 id=\"组件逻辑\"><a href=\"#组件逻辑\" class=\"headerlink\" title=\"组件逻辑\"></a>组件逻辑</h3><ul>\n<li>CTMediator 是一种组件化方案，主要是针对大型项目多人开发情况下的一种方案。路由方式是 Targer-Action，通过这种方式进行模块之间的沟通，模块使用私有 pod 进行封装（这个是在第二篇的实践中提出来的），因为目前我们还没接触过这种大型的项目，所以一直停留在理论阶段（也就是虽然我看懂了源码的设计思想但是却没得地方实现），后来启动了觅书项目，打算尝试这种设计，结果发现过于大材小用了。模块的创建要先通过中介者进行注册，调用要通过中介者进行调用，总结一下大概就像这样子：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">             --------------------------------------</span><br><span class=\"line\">             | [CTMediator sharedInstance]        |</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                openUrl:       &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  (AppDelegate)  &lt;&lt;&lt;&lt;  Call From Other App With URL</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">             |                   |&#x2F;               |</span><br><span class=\"line\">             |                parseUrl            |</span><br><span class=\"line\">             |                                    |</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">.................................|...............................</span><br><span class=\"line\">             |                   |                |</span><br><span class=\"line\">             |                   |&#x2F;               |</span><br><span class=\"line\">             |  performTarget:action:params: &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  Call From Native Module</span><br><span class=\"line\">             |                   |&#x2F;               |</span><br><span class=\"line\">             |             -------------          |</span><br><span class=\"line\">             |             |  runtime  |          |</span><br><span class=\"line\">             |             -------------          |</span><br><span class=\"line\">             ---------------.---------.------------</span><br><span class=\"line\">                           .           .</span><br><span class=\"line\">                          .             .</span><br><span class=\"line\">-------------------------------      --------------------------------</span><br><span class=\"line\">|                       ·     |      |    ·                         |</span><br><span class=\"line\">|                     ·       |      |     ·                        |</span><br><span class=\"line\">|           Target            |      |           Target             |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|         &#x2F;   |   \\           |      |         &#x2F;   |   \\            |</span><br><span class=\"line\">|        &#x2F;    |    \\          |      |        &#x2F;    |    \\           |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|   Action Action Action ...  |      |   Action Action Action ...   |</span><br><span class=\"line\">|                             |      |                              |</span><br><span class=\"line\">|Service  A                   |      | Service  B                   |</span><br><span class=\"line\">-------------------------------      --------------------------------</span><br></pre></td></tr></table></figure>\n\n<p>这里面包括了内部调用和远程应用调用，远程应用调用因为我们目前还用不着所以先不管，内部调用的流程为了方便理解我举个例子，fromController通过performTarget:action:params:方法传入toController类名和在toController要执行的方法和所需的参数，这样子组件之间就实现了解耦，fromController 只需要知道他想去的地方是 toController和要给什么值出去，甚至这个 controller 存不存在都无所谓，而 toController 只需要遵循协议方法/重写父类方法去的到参数即可，然后里面就可以直接调这个参数，并且这一系列跳转规则和传参规则都通过 CTMediator 中介者去控制。</p>\n<h3 id=\"服务层（Service-Layer）-或者叫-业务层（Business-Layer）\"><a href=\"#服务层（Service-Layer）-或者叫-业务层（Business-Layer）\" class=\"headerlink\" title=\"服务层（Service Layer） 或者叫 业务层（Business Layer）\"></a>服务层（Service Layer） 或者叫 业务层（Business Layer）</h3><p>刚刚总结了一下CTMediator的组件间的逻辑,现在来总结一下业务层与 ViewController 层之间的设计.因为虽然是 MVC，那当然也得尽量避免 Mess View Controller ,Service 在这里可以理解为数据仓库+业务逻辑仓库，为的是令ViewController中避免出现像数据 A处理判断完才显示到控件上的情况，尽量能把最直接的数据给 ViewController 显示,利用像下图这种方式，业务层暴露出 Target 和 action供外界调用，调用方法后就进入了CTMediator 进行处理，接下来的事情就像我上面说的一样了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         --------------------------------</span><br><span class=\"line\">         |           Service  A         |</span><br><span class=\"line\">         ---  ----------  ----------  ---</span><br><span class=\"line\">           |  |        |  |        |  |</span><br><span class=\"line\">...........|  |........|  |........|  |...........</span><br><span class=\"line\">.          |  |        |  |        |  |          .</span><br><span class=\"line\">.        ---  ---    ---  ---    ---  ---        .</span><br><span class=\"line\">.        |action|    |action|    |action|        .</span><br><span class=\"line\">.        ---|----    -----|--    --|-----        .</span><br><span class=\"line\">.           |             |        |             .</span><br><span class=\"line\">.           |             |        |             .</span><br><span class=\"line\">.       ----|------     --|--------|--           .</span><br><span class=\"line\">.       |Target_A1|     |  Target_A2 |           .</span><br><span class=\"line\">.       -----------     --------------           .</span><br><span class=\"line\">..................................................</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CTNetworking-gt-DKNetworking-gt-DKHTTPTool\"><a href=\"#CTNetworking-gt-DKNetworking-gt-DKHTTPTool\" class=\"headerlink\" title=\"CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool\"></a>CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool</h3><ul>\n<li><p>CTNetworking 是一个基于AFNetworking的开源网络层组件，经过改装之后我组装出了 DKNetworking（虽然后面发现有 RAC神器之后就觉得这个东西不够轻便了）。</p>\n</li>\n<li><p>CTNetworking 解决了以下几个问题</p>\n<ul>\n<li>使用哪种交互模式来跟业务层做对接？</li>\n<li>是否有必要将API返回的数据封装成对象然后再交付给业务层？</li>\n<li>使用集约化调用方式还是离散型调用方式去调用API？</li>\n</ul>\n</li>\n<li><p>上面三个问题分别给出的答案是</p>\n<ul>\n<li>代理模式</li>\n<li>没必要</li>\n<li>离散型</li>\n</ul>\n</li>\n<li><p>CTNetworking考虑的东西相当地多，除了上面几个问题之外，还考虑到了网络层安全机制（数据传输，HTTPS）,链接环节的优化（链接传输量和链接复用）等，一开始看源码也是看的很懵逼</p>\n</li>\n<li><p>通过协议的方式进行组件内的方法封装</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>协议名</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CTAPIManagerApiCallBackDelegate</td>\n<td>回调协议</td>\n</tr>\n<tr>\n<td>CTAPIManagerCallbackDataReformer</td>\n<td>负责重新组装API数据的对象</td>\n</tr>\n<tr>\n<td>CTAPIManagerValidator</td>\n<td>验证器验证参数和返回</td>\n</tr>\n<tr>\n<td>CTAPIManagerParamSourceDelegate</td>\n<td>参数源</td>\n</tr>\n<tr>\n<td>CTAPIManager</td>\n<td>CTAPIBaseManager的派生类必须符合这个protocal</td>\n</tr>\n<tr>\n<td>CTAPIManagerInterceptor</td>\n<td>拦截器，拦截参数和回调</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>用协议的好处就是各取所需。当你想要统一管理所有回调的时候，那你这个类只要遵循<code>CTAPIManagerApiCallBackDelegate</code>代理和实现对应的方法，如果你这个类想要拦截参数，那么就遵循<code>CTAPIManagerInterceptor</code>协议并实现对应的方法，大抵就是这种思想，然后底层就会进行各种判断并拼接各个协议的方法的返回值，最后发出请求，得到回调然后处理值并返回出去。</p>\n</li>\n<li><p>CTNetworking 框架没有使用数据模型，原因就是认为模型嵌入模型的时候处理数据很麻烦，另外模型的复用性很差，容易出现类型爆炸，提高维护成本，还有就是不够NSDictionary、NSArray直观,最最重要的一点就是同一API的数据被不同View展示时，难以控制数据转化的代码，它们有可能会散落在任何需要的地方。所以框架使用了 Reformer 的方法去处理返回的数据（NSDictionary）转成 View 需要的数据（NSDictionary）。</p>\n</li>\n<li><p>DKNetworking 把 Refromer 部分的实现给改了，依赖了 MJExtension，去实现数据模型数组，因为总感觉NSDictionary很麻烦，难维护就难维护吧，反正项目也不大。</p>\n</li>\n<li><p>DKHTTPTool 是我在近期集成出来的框架，主要特性包括：</p>\n<ul>\n<li>支持缓存策略选择</li>\n<li>支持链式调用</li>\n<li>支持 RACSignal 返回</li>\n<li>支持拦截器、验证器</li>\n<li>支持直观的Logger输出</li>\n<li>支持全局请求头、请求参数</li>\n<li>服务器异常直接弹出异常数据而不是一坨 NSData</li>\n<li>支持错误码表，统一处理错误</li>\n</ul>\n</li>\n</ul>\n<p>还有其他的吗？忘记了<br>总的来说，这个还是挺管用的,毕竟能支持 RAC,符合我们现在的<br>MVVM+ReactiveCocoa的架构</p>\n<h3 id=\"MVVM-ReactiveCocoa\"><a href=\"#MVVM-ReactiveCocoa\" class=\"headerlink\" title=\"MVVM+ReactiveCocoa\"></a>MVVM+ReactiveCocoa</h3><ul>\n<li>ReactiveCocoa 博大精深，以致于现在都用不到它提供的功能的一半</li>\n<li>第二份优秀的源码（虽然跑不起来）<a href=\"https://github.com/leichunfeng/MVVMReactiveCocoa\">MVVMReactiveCocoa</a></li>\n<li>产出成品<a href=\"https://coding.net/u/Arclin/p/Poi/git\">Poi</a></li>\n</ul>\n<h3 id=\"Navigation-With-ViewModel\"><a href=\"#Navigation-With-ViewModel\" class=\"headerlink\" title=\"Navigation-With-ViewModel\"></a>Navigation-With-ViewModel</h3><p> 使用 MVVM 模式应该注意的问题</p>\n<ul>\n<li>以 ViewModel 为驱动引导着整个应用而不是 ViewController</li>\n<li>ViewModel 中不应该引入任何 UIKit 框架</li>\n<li>模块与模块间通过 服务总线 去沟通 , 减少模块之间的耦合</li>\n</ul>\n<p>先看看用 ViewModel 进行 push操作的流程</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|        ViewModel A           |   </span><br><span class=\"line\">---  ----------  ----------  ---   </span><br><span class=\"line\">\t|</span><br><span class=\"line\">\t| </span><br><span class=\"line\">[- initWithService:params:]</span><br><span class=\"line\">\t| ---------------</span><br><span class=\"line\">\t| | service bus | --- &gt; - pushViewModel: animated: </span><br><span class=\"line\">\t| ---------------                 |</span><br><span class=\"line\">\t|\t\t\t             （HOOK）[rac_responseToSelector:]</span><br><span class=\"line\">\t|\t\t\t                     |&#x2F;</span><br><span class=\"line\">\t|\t\t\t               &lt;DKNavigationProtocol&gt;-- @&#123; viewModel:viewController&#125;---&gt;navigationController [pushViewController:animated:]</span><br><span class=\"line\">\t|&#x2F;</span><br><span class=\"line\"> --------------------------------</span><br><span class=\"line\"> |        ViewModel B           |</span><br><span class=\"line\"> ---  ----------  ----------  ---</span><br></pre></td></tr></table></figure>\n\n<p>说明： ViewModelA 与 ViewControllerA ，ViewModelB 与 ViewControllerB 在 Router 里面通过字典的方式绑定在了一起，然后通过 RAC的方法监听pushViewModel: animated: 方法的执行，然后通过字典得到viewController从而进行真正的 push 操作，大概就是这样子</p>\n<h3 id=\"抽出父类和ReactiveCocoa\"><a href=\"#抽出父类和ReactiveCocoa\" class=\"headerlink\" title=\"抽出父类和ReactiveCocoa\"></a>抽出父类和ReactiveCocoa</h3><p>MVVMReactiveCocoa 通过封装父类的方式来实现这个架构，这些父类已经被我抽出来了，过几天会传上去，然后先写一些使用说明</p>\n<ol>\n<li>每个 Vc 对应一个 ViewModel</li>\n<li>TableViewController必须对应 ViewModel</li>\n<li>ViewModel 的初始化方法在 - initliazed 中</li>\n<li>初始化之前添加一些额外的方法，需要重写 - initWithServer:params:</li>\n<li>DKTableViewController是一个二维数组，里面封装的是 viewmodel</li>\n<li>cell 要遵循 DKReactiveView 协议</li>\n<li>绑定 cell与 viewModel 就在 ViewController里面重写 configureCell:withObject</li>\n<li>待补充</li>\n</ol>\n<p>ReativeCocoa 主要是用来实现 MVVM 的融合剂，当然也不一定要用 RAC去实现 MVVM,说实话 RAC 的学习成本还是相当高的，目前已经在尝试 DKRACHTTPTool,用纯 RAC 的方式去实现网络层和数据持久层的封装，另外还有些异常处理之类的,在这里面使用了filter: ignore: thottle: startWith: doNext: catch: try: doComplete: map: flattenMap: flatten: 等等的方法，非常好使，其他的可以看看我的几篇笔记”使用RAC-DKHTTPTool实践”、”RACCommand使用注意”</p>\n<p>最近的一个个人项目 Poi 就实践了这个架构。UI 结构如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   \t    --------------------------------</span><br><span class=\"line\">            |     NavigationConroller0     |</span><br><span class=\"line\">            ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t\t    |</span><br><span class=\"line\"> \t    --------------------------------</span><br><span class=\"line\">            |       TabBarController       |</span><br><span class=\"line\">            ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t|\t\t\t |</span><br><span class=\"line\">--------------------------------     --------------------------------   </span><br><span class=\"line\">|     NavigationConroller1     |     |     NavigationConroller2     |</span><br><span class=\"line\">---  ----------  ----------  ---     ---  ----------  ----------  ---</span><br><span class=\"line\">\t\t|                   \t\t    |</span><br><span class=\"line\">--------------------------------     --------------------------------</span><br><span class=\"line\">|       ViewConroller1         |     |       ViewConroller2         |</span><br><span class=\"line\">---  ----------  ----------  --      --------------------------------</span><br></pre></td></tr></table></figure>\n\n<p>默认整个应用的跳转用的是NavigationConroller0，这样子做的原因是使用了一个第三方框架，为了可以在TabBarController中滑动切换。<br>当 pushViewModel 执行的时候，有一个 NavigationStack 会拿到最底部的 NavigationController 进行 push，如果 modal 出一个 navigationController,那么这个 navigationcontroller 将会压入NavigationStack ,然后这个 modal 出来的 viewController 后面的页面跳转就用这个 stack最上层的 NavigationController，dismiss 之后就会就会从栈中移除这个 NavigationController</p>\n<p>大概就是长这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--------------------------------</span><br><span class=\"line\">|     NavigationConroller0     |  </span><br><span class=\"line\">---  ----------  ----------  ---    </span><br><span class=\"line\">\t\t |\tstack + 1\tpush</span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|       TabBarController       |    </span><br><span class=\"line\">---  ----------  ----------  ---  </span><br><span class=\"line\">\t\t |\t\t           </span><br><span class=\"line\">--------------------------------   </span><br><span class=\"line\">|     NavigationConroller1     |    </span><br><span class=\"line\">---  ----------  ----------  ---    </span><br><span class=\"line\">\t\t |      nv0 push     </span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|       ViewConroller1         |    </span><br><span class=\"line\">---  ----------  ----------  ---\t  </span><br><span class=\"line\">\t\t |   \tv1 modal</span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|      NavigationConroller2    |    </span><br><span class=\"line\">---  ----------  ----------  ---\t  </span><br><span class=\"line\">\t\t |     stack + 1  push   </span><br><span class=\"line\">--------------------------------    </span><br><span class=\"line\">|      ViewConroller2\t       |    </span><br><span class=\"line\">---  ----------  ----------  ---\t</span><br><span class=\"line\">\t\t| dismiss</span><br><span class=\"line\">\tstack - 1 pop</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"MVVM-WithOut-ReacitveCocoa\"><a href=\"#MVVM-WithOut-ReacitveCocoa\" class=\"headerlink\" title=\"MVVM WithOut ReacitveCocoa\"></a>MVVM WithOut ReacitveCocoa</h3><p>用 Block 的方式代替 Reactive 的绑定功能。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li>BugReporter For iOS<ul>\n<li>和思华一起开发的基于 iOS 的 bug自动反馈系统，一旦发生崩溃事故就会给开发者发送邮件</li>\n</ul>\n</li>\n<li>自动部署系统Jenkines</li>\n<li>JSPatch 热修复平台</li>\n<li>UMeng 用户数据统计</li>\n<li>等等</li>\n</ul>"},{"title":"Express学习笔记","author":"Arclin","abbrlink":"dcb90c85","date":"2017-03-06T16:00:00.000Z","_content":"Express 是 Node.js 的一个轻量级web框架,目前使用EJS模板引擎,该笔记持续更新\n\n<!-- more -->\n\n## supervisor\n\n使用supervisor监听文件改变然后自动重启node服务器,这样子就不用每改一次代码run一遍服务器了\n\n`sudo npm install -g supervisor`\n\n### WebStrom配置supervisor\n\n文件目录结构\n```\n├── app.js        项目入口及程序启动文件。\n├── bin\n│   └── www       存放启动项目的脚本文件，默认www。\n├── package.json  项目依赖配置及开发者信息。\n├── public        静态资源文件夹，默认images、javascripts、stylesheets。\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n├── routes        路由文件相当于MVC中的Controller，默认index.js、users.js。\n│   ├── index.js\n│   └── users.js\n└── views         页面文件，相当于MVC中的view，Ejs模板默认error.ejs、index.ejs\n    ├── error.ejs\n    └── index.ejs\n```\n\n项目依赖配置 `package.json`\n\n`package.json` 里面有项目依赖配置及开发者信息。\n在dependencies后面写上依赖的包名和版本号,然后在项目根目录执行npm install就可以像cocopods一样一次性安装包依赖\n\n## 路由 Routes\n路由用来处理URL的访问\n\n`index.js`\n\n```\nvar express = require('express');   获取express对象\nvar router = express.Router();      获取router对象\n```\n\nrouter有get(),post(),put(),delete()对象,代表接受的请求方式,对应查,增,改,删\n\n```\nrouter.get('/getSomething',function(req,res,next) {});\nrouter.post('/post', function (req,res) {});\nrouter.put('/put',function(req,res,next) {});\nrouter.delete('/delete',function(req,res,next) {});\n```\n\n方法中第一个参数意味着请求路径,例如第一个的请求路径是`http://localhost:3000/getSomething`,第二个参数是获取请求内容和准备返回的响应体.\n\n## Request获取请求参数\n\n例如请求发送了id参数,则`var id = req.params.id;`可以取得\nResponse返回响应体\n\n`send()`方法向浏览器发送一个响应信息\n例如想返回一个json,则res.send({test:id = ${id},name = ${name}});\n当参数为一个Number时，并且没有上面提到的任何一条在响应体里，Express会帮你设置一个响应 体，比如：200会返回字符”OK”。\nres.send(200); // OK\nres.send(404); // Not Found\nres.send(500); // Internal Server Error\n\n## Response重定向\n\n`res.redirect(\"http://www.hubwiz.com\");`\n\n## Response渲染页面\n\n如果想渲染`hello.ejs`页面,`res.render('hello',{title:\"MySQL\",test_params:'aaa'});`\n`hello.ejs`页面通过`<%= title %>`的方式取得title等参数\n\nRequest获取主机名,路径名\n\n`req.host`获取主机名，`req.path`获取请求路径名\n\n## restful 方式路由\n\n```\nrouter.post('/restful/:id/name/:name', function (req,res) {\n  var id  = req.params.id;\n  var name = req.params.name;\n  console.log(JSON.stringify(req.params));\n  res.send({test:`id = ${id},name = ${name}`});\n});\nJSON.stringify() 把js对象转成json\n```\n\n## 数据库\n\n### MySQL\n安装MySQL\n\n`$ npm install mysql`\n\n引入MySQL并配置\n```\nvar mysql      = require('mysql');\nvar connection = mysql.createConnection({\n    host     : 'localhost',\n    user     : 'root',\n    password : '123456',\n    database : 'csdn_test',\n    port     : 3306\n});\n```\n\n连接数据库\n\n```\nconnection.connect()\n```\n\n这个方法可以接受一个回调用来判断是否连接成功\n\n```\nconnection.connect(function(err) {\n    if (!err) {\n   \t\t// 连接成功\n     } else {\n      // 连接失败 \n     }\n});\nconnection.end();\n```\n\n#### 查询\n\n```\nconnection.query('SELECT 1 + 1 AS solution', function(err, rows, fields) {\n  if (err) throw err;\n  console.log('The solution is: ', rows[0].solution);\n});\n```\n\n同上,接受一个回调来判断是否成功关闭连接\n\n`connection.end(err => console.log(`连接中断${err}`));'\n\n### MongoDB\n\n安装\n\n`npm install -g mongoose`\n配置\n\n```\nvar mongoose = require('mongoose');\nvar options = {\n    db_user: \"root\",\n    db_pwd: \"123456\",\n    db_host: \"localhost\",\n    db_port: 27017,\n    db_name: \"csdn_test\"\n};\n```\n\n#### 连接\n\n```\nvar dbURL = \"mongodb://\" + options.db_user + \":\" + options.db_pwd + \"@\" + options.db_host + \":\" + options.db_port + \"/\" + options.db_name;\n\n// 连接\nmongoose.connect(dbURL);\n\n// 监听连接事件\nmongoose.connection.on('connected', function (err) {\n    if (err) logger.error('Database connection failure');\n});\n\n// 监听错误事件\nmongoose.connection.on('error', function (err) {\n    logger.error('Mongoose connected error ' + err);\n});\n\n// 监听断开事件\nmongoose.connection.on('disconnected', function () {\n    logger.error('Mongoose disconnected');\n});\n查询\n\nmongoose.collection('mamals').find().toArray(function(err, result) {\n  if (err) throw err;\n  console.log(result);\n});\n```\n\n其他方法以后遇到再补充.","source":"_posts/Express学习笔记.md","raw":"---\ntitle: Express学习笔记\nauthor: Arclin\ntags:\n  - Node.js\n  - Express\ncategories:\n  - Node.js\nabbrlink: dcb90c85\ndate: 2017-03-07 00:00:00\n---\nExpress 是 Node.js 的一个轻量级web框架,目前使用EJS模板引擎,该笔记持续更新\n\n<!-- more -->\n\n## supervisor\n\n使用supervisor监听文件改变然后自动重启node服务器,这样子就不用每改一次代码run一遍服务器了\n\n`sudo npm install -g supervisor`\n\n### WebStrom配置supervisor\n\n文件目录结构\n```\n├── app.js        项目入口及程序启动文件。\n├── bin\n│   └── www       存放启动项目的脚本文件，默认www。\n├── package.json  项目依赖配置及开发者信息。\n├── public        静态资源文件夹，默认images、javascripts、stylesheets。\n│   ├── images\n│   ├── javascripts\n│   └── stylesheets\n├── routes        路由文件相当于MVC中的Controller，默认index.js、users.js。\n│   ├── index.js\n│   └── users.js\n└── views         页面文件，相当于MVC中的view，Ejs模板默认error.ejs、index.ejs\n    ├── error.ejs\n    └── index.ejs\n```\n\n项目依赖配置 `package.json`\n\n`package.json` 里面有项目依赖配置及开发者信息。\n在dependencies后面写上依赖的包名和版本号,然后在项目根目录执行npm install就可以像cocopods一样一次性安装包依赖\n\n## 路由 Routes\n路由用来处理URL的访问\n\n`index.js`\n\n```\nvar express = require('express');   获取express对象\nvar router = express.Router();      获取router对象\n```\n\nrouter有get(),post(),put(),delete()对象,代表接受的请求方式,对应查,增,改,删\n\n```\nrouter.get('/getSomething',function(req,res,next) {});\nrouter.post('/post', function (req,res) {});\nrouter.put('/put',function(req,res,next) {});\nrouter.delete('/delete',function(req,res,next) {});\n```\n\n方法中第一个参数意味着请求路径,例如第一个的请求路径是`http://localhost:3000/getSomething`,第二个参数是获取请求内容和准备返回的响应体.\n\n## Request获取请求参数\n\n例如请求发送了id参数,则`var id = req.params.id;`可以取得\nResponse返回响应体\n\n`send()`方法向浏览器发送一个响应信息\n例如想返回一个json,则res.send({test:id = ${id},name = ${name}});\n当参数为一个Number时，并且没有上面提到的任何一条在响应体里，Express会帮你设置一个响应 体，比如：200会返回字符”OK”。\nres.send(200); // OK\nres.send(404); // Not Found\nres.send(500); // Internal Server Error\n\n## Response重定向\n\n`res.redirect(\"http://www.hubwiz.com\");`\n\n## Response渲染页面\n\n如果想渲染`hello.ejs`页面,`res.render('hello',{title:\"MySQL\",test_params:'aaa'});`\n`hello.ejs`页面通过`<%= title %>`的方式取得title等参数\n\nRequest获取主机名,路径名\n\n`req.host`获取主机名，`req.path`获取请求路径名\n\n## restful 方式路由\n\n```\nrouter.post('/restful/:id/name/:name', function (req,res) {\n  var id  = req.params.id;\n  var name = req.params.name;\n  console.log(JSON.stringify(req.params));\n  res.send({test:`id = ${id},name = ${name}`});\n});\nJSON.stringify() 把js对象转成json\n```\n\n## 数据库\n\n### MySQL\n安装MySQL\n\n`$ npm install mysql`\n\n引入MySQL并配置\n```\nvar mysql      = require('mysql');\nvar connection = mysql.createConnection({\n    host     : 'localhost',\n    user     : 'root',\n    password : '123456',\n    database : 'csdn_test',\n    port     : 3306\n});\n```\n\n连接数据库\n\n```\nconnection.connect()\n```\n\n这个方法可以接受一个回调用来判断是否连接成功\n\n```\nconnection.connect(function(err) {\n    if (!err) {\n   \t\t// 连接成功\n     } else {\n      // 连接失败 \n     }\n});\nconnection.end();\n```\n\n#### 查询\n\n```\nconnection.query('SELECT 1 + 1 AS solution', function(err, rows, fields) {\n  if (err) throw err;\n  console.log('The solution is: ', rows[0].solution);\n});\n```\n\n同上,接受一个回调来判断是否成功关闭连接\n\n`connection.end(err => console.log(`连接中断${err}`));'\n\n### MongoDB\n\n安装\n\n`npm install -g mongoose`\n配置\n\n```\nvar mongoose = require('mongoose');\nvar options = {\n    db_user: \"root\",\n    db_pwd: \"123456\",\n    db_host: \"localhost\",\n    db_port: 27017,\n    db_name: \"csdn_test\"\n};\n```\n\n#### 连接\n\n```\nvar dbURL = \"mongodb://\" + options.db_user + \":\" + options.db_pwd + \"@\" + options.db_host + \":\" + options.db_port + \"/\" + options.db_name;\n\n// 连接\nmongoose.connect(dbURL);\n\n// 监听连接事件\nmongoose.connection.on('connected', function (err) {\n    if (err) logger.error('Database connection failure');\n});\n\n// 监听错误事件\nmongoose.connection.on('error', function (err) {\n    logger.error('Mongoose connected error ' + err);\n});\n\n// 监听断开事件\nmongoose.connection.on('disconnected', function () {\n    logger.error('Mongoose disconnected');\n});\n查询\n\nmongoose.collection('mamals').find().toArray(function(err, result) {\n  if (err) throw err;\n  console.log(result);\n});\n```\n\n其他方法以后遇到再补充.","slug":"Express学习笔记","published":1,"updated":"2021-04-12T06:07:04.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog4s000e45n05i2g3yp1","content":"<p>Express 是 Node.js 的一个轻量级web框架,目前使用EJS模板引擎,该笔记持续更新</p>\n<span id=\"more\"></span>\n\n<h2 id=\"supervisor\"><a href=\"#supervisor\" class=\"headerlink\" title=\"supervisor\"></a>supervisor</h2><p>使用supervisor监听文件改变然后自动重启node服务器,这样子就不用每改一次代码run一遍服务器了</p>\n<p><code>sudo npm install -g supervisor</code></p>\n<h3 id=\"WebStrom配置supervisor\"><a href=\"#WebStrom配置supervisor\" class=\"headerlink\" title=\"WebStrom配置supervisor\"></a>WebStrom配置supervisor</h3><p>文件目录结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── app.js        项目入口及程序启动文件。</span><br><span class=\"line\">├── bin</span><br><span class=\"line\">│   └── www       存放启动项目的脚本文件，默认www。</span><br><span class=\"line\">├── package.json  项目依赖配置及开发者信息。</span><br><span class=\"line\">├── public        静态资源文件夹，默认images、javascripts、stylesheets。</span><br><span class=\"line\">│   ├── images</span><br><span class=\"line\">│   ├── javascripts</span><br><span class=\"line\">│   └── stylesheets</span><br><span class=\"line\">├── routes        路由文件相当于MVC中的Controller，默认index.js、users.js。</span><br><span class=\"line\">│   ├── index.js</span><br><span class=\"line\">│   └── users.js</span><br><span class=\"line\">└── views         页面文件，相当于MVC中的view，Ejs模板默认error.ejs、index.ejs</span><br><span class=\"line\">    ├── error.ejs</span><br><span class=\"line\">    └── index.ejs</span><br></pre></td></tr></table></figure>\n\n<p>项目依赖配置 <code>package.json</code></p>\n<p><code>package.json</code> 里面有项目依赖配置及开发者信息。<br>在dependencies后面写上依赖的包名和版本号,然后在项目根目录执行npm install就可以像cocopods一样一次性安装包依赖</p>\n<h2 id=\"路由-Routes\"><a href=\"#路由-Routes\" class=\"headerlink\" title=\"路由 Routes\"></a>路由 Routes</h2><p>路由用来处理URL的访问</p>\n<p><code>index.js</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express &#x3D; require(&#39;express&#39;);   获取express对象</span><br><span class=\"line\">var router &#x3D; express.Router();      获取router对象</span><br></pre></td></tr></table></figure>\n\n<p>router有get(),post(),put(),delete()对象,代表接受的请求方式,对应查,增,改,删</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.get(&#39;&#x2F;getSomething&#39;,function(req,res,next) &#123;&#125;);</span><br><span class=\"line\">router.post(&#39;&#x2F;post&#39;, function (req,res) &#123;&#125;);</span><br><span class=\"line\">router.put(&#39;&#x2F;put&#39;,function(req,res,next) &#123;&#125;);</span><br><span class=\"line\">router.delete(&#39;&#x2F;delete&#39;,function(req,res,next) &#123;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>方法中第一个参数意味着请求路径,例如第一个的请求路径是<code>http://localhost:3000/getSomething</code>,第二个参数是获取请求内容和准备返回的响应体.</p>\n<h2 id=\"Request获取请求参数\"><a href=\"#Request获取请求参数\" class=\"headerlink\" title=\"Request获取请求参数\"></a>Request获取请求参数</h2><p>例如请求发送了id参数,则<code>var id = req.params.id;</code>可以取得<br>Response返回响应体</p>\n<p><code>send()</code>方法向浏览器发送一个响应信息<br>例如想返回一个json,则res.send({test:id = ${id},name = ${name}});<br>当参数为一个Number时，并且没有上面提到的任何一条在响应体里，Express会帮你设置一个响应 体，比如：200会返回字符”OK”。<br>res.send(200); // OK<br>res.send(404); // Not Found<br>res.send(500); // Internal Server Error</p>\n<h2 id=\"Response重定向\"><a href=\"#Response重定向\" class=\"headerlink\" title=\"Response重定向\"></a>Response重定向</h2><p><code>res.redirect(&quot;http://www.hubwiz.com&quot;);</code></p>\n<h2 id=\"Response渲染页面\"><a href=\"#Response渲染页面\" class=\"headerlink\" title=\"Response渲染页面\"></a>Response渲染页面</h2><p>如果想渲染<code>hello.ejs</code>页面,<code>res.render(&#39;hello&#39;,&#123;title:&quot;MySQL&quot;,test_params:&#39;aaa&#39;&#125;);</code><br><code>hello.ejs</code>页面通过<code>&lt;%= title %&gt;</code>的方式取得title等参数</p>\n<p>Request获取主机名,路径名</p>\n<p><code>req.host</code>获取主机名，<code>req.path</code>获取请求路径名</p>\n<h2 id=\"restful-方式路由\"><a href=\"#restful-方式路由\" class=\"headerlink\" title=\"restful 方式路由\"></a>restful 方式路由</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.post(&#39;&#x2F;restful&#x2F;:id&#x2F;name&#x2F;:name&#39;, function (req,res) &#123;</span><br><span class=\"line\">  var id  &#x3D; req.params.id;</span><br><span class=\"line\">  var name &#x3D; req.params.name;</span><br><span class=\"line\">  console.log(JSON.stringify(req.params));</span><br><span class=\"line\">  res.send(&#123;test:&#96;id &#x3D; $&#123;id&#125;,name &#x3D; $&#123;name&#125;&#96;&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">JSON.stringify() 把js对象转成json</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><p>安装MySQL</p>\n<p><code>$ npm install mysql</code></p>\n<p>引入MySQL并配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mysql      &#x3D; require(&#39;mysql&#39;);</span><br><span class=\"line\">var connection &#x3D; mysql.createConnection(&#123;</span><br><span class=\"line\">    host     : &#39;localhost&#39;,</span><br><span class=\"line\">    user     : &#39;root&#39;,</span><br><span class=\"line\">    password : &#39;123456&#39;,</span><br><span class=\"line\">    database : &#39;csdn_test&#39;,</span><br><span class=\"line\">    port     : 3306</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>连接数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.connect()</span><br></pre></td></tr></table></figure>\n\n<p>这个方法可以接受一个回调用来判断是否连接成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.connect(function(err) &#123;</span><br><span class=\"line\">    if (!err) &#123;</span><br><span class=\"line\">   \t\t&#x2F;&#x2F; 连接成功</span><br><span class=\"line\">     &#125; else &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; 连接失败 </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.end();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.query(&#39;SELECT 1 + 1 AS solution&#39;, function(err, rows, fields) &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(&#39;The solution is: &#39;, rows[0].solution);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>同上,接受一个回调来判断是否成功关闭连接</p>\n<p><code>connection.end(err =&gt; console.log(</code>连接中断${err}`));’</p>\n<h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><p>安装</p>\n<p><code>npm install -g mongoose</code><br>配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class=\"line\">var options &#x3D; &#123;</span><br><span class=\"line\">    db_user: &quot;root&quot;,</span><br><span class=\"line\">    db_pwd: &quot;123456&quot;,</span><br><span class=\"line\">    db_host: &quot;localhost&quot;,</span><br><span class=\"line\">    db_port: 27017,</span><br><span class=\"line\">    db_name: &quot;csdn_test&quot;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dbURL &#x3D; &quot;mongodb:&#x2F;&#x2F;&quot; + options.db_user + &quot;:&quot; + options.db_pwd + &quot;@&quot; + options.db_host + &quot;:&quot; + options.db_port + &quot;&#x2F;&quot; + options.db_name;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 连接</span><br><span class=\"line\">mongoose.connect(dbURL);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 监听连接事件</span><br><span class=\"line\">mongoose.connection.on(&#39;connected&#39;, function (err) &#123;</span><br><span class=\"line\">    if (err) logger.error(&#39;Database connection failure&#39;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 监听错误事件</span><br><span class=\"line\">mongoose.connection.on(&#39;error&#39;, function (err) &#123;</span><br><span class=\"line\">    logger.error(&#39;Mongoose connected error &#39; + err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 监听断开事件</span><br><span class=\"line\">mongoose.connection.on(&#39;disconnected&#39;, function () &#123;</span><br><span class=\"line\">    logger.error(&#39;Mongoose disconnected&#39;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">查询</span><br><span class=\"line\"></span><br><span class=\"line\">mongoose.collection(&#39;mamals&#39;).find().toArray(function(err, result) &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>其他方法以后遇到再补充.</p>\n","site":{"data":{}},"excerpt":"<p>Express 是 Node.js 的一个轻量级web框架,目前使用EJS模板引擎,该笔记持续更新</p>","more":"<h2 id=\"supervisor\"><a href=\"#supervisor\" class=\"headerlink\" title=\"supervisor\"></a>supervisor</h2><p>使用supervisor监听文件改变然后自动重启node服务器,这样子就不用每改一次代码run一遍服务器了</p>\n<p><code>sudo npm install -g supervisor</code></p>\n<h3 id=\"WebStrom配置supervisor\"><a href=\"#WebStrom配置supervisor\" class=\"headerlink\" title=\"WebStrom配置supervisor\"></a>WebStrom配置supervisor</h3><p>文件目录结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── app.js        项目入口及程序启动文件。</span><br><span class=\"line\">├── bin</span><br><span class=\"line\">│   └── www       存放启动项目的脚本文件，默认www。</span><br><span class=\"line\">├── package.json  项目依赖配置及开发者信息。</span><br><span class=\"line\">├── public        静态资源文件夹，默认images、javascripts、stylesheets。</span><br><span class=\"line\">│   ├── images</span><br><span class=\"line\">│   ├── javascripts</span><br><span class=\"line\">│   └── stylesheets</span><br><span class=\"line\">├── routes        路由文件相当于MVC中的Controller，默认index.js、users.js。</span><br><span class=\"line\">│   ├── index.js</span><br><span class=\"line\">│   └── users.js</span><br><span class=\"line\">└── views         页面文件，相当于MVC中的view，Ejs模板默认error.ejs、index.ejs</span><br><span class=\"line\">    ├── error.ejs</span><br><span class=\"line\">    └── index.ejs</span><br></pre></td></tr></table></figure>\n\n<p>项目依赖配置 <code>package.json</code></p>\n<p><code>package.json</code> 里面有项目依赖配置及开发者信息。<br>在dependencies后面写上依赖的包名和版本号,然后在项目根目录执行npm install就可以像cocopods一样一次性安装包依赖</p>\n<h2 id=\"路由-Routes\"><a href=\"#路由-Routes\" class=\"headerlink\" title=\"路由 Routes\"></a>路由 Routes</h2><p>路由用来处理URL的访问</p>\n<p><code>index.js</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var express &#x3D; require(&#39;express&#39;);   获取express对象</span><br><span class=\"line\">var router &#x3D; express.Router();      获取router对象</span><br></pre></td></tr></table></figure>\n\n<p>router有get(),post(),put(),delete()对象,代表接受的请求方式,对应查,增,改,删</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.get(&#39;&#x2F;getSomething&#39;,function(req,res,next) &#123;&#125;);</span><br><span class=\"line\">router.post(&#39;&#x2F;post&#39;, function (req,res) &#123;&#125;);</span><br><span class=\"line\">router.put(&#39;&#x2F;put&#39;,function(req,res,next) &#123;&#125;);</span><br><span class=\"line\">router.delete(&#39;&#x2F;delete&#39;,function(req,res,next) &#123;&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>方法中第一个参数意味着请求路径,例如第一个的请求路径是<code>http://localhost:3000/getSomething</code>,第二个参数是获取请求内容和准备返回的响应体.</p>\n<h2 id=\"Request获取请求参数\"><a href=\"#Request获取请求参数\" class=\"headerlink\" title=\"Request获取请求参数\"></a>Request获取请求参数</h2><p>例如请求发送了id参数,则<code>var id = req.params.id;</code>可以取得<br>Response返回响应体</p>\n<p><code>send()</code>方法向浏览器发送一个响应信息<br>例如想返回一个json,则res.send({test:id = ${id},name = ${name}});<br>当参数为一个Number时，并且没有上面提到的任何一条在响应体里，Express会帮你设置一个响应 体，比如：200会返回字符”OK”。<br>res.send(200); // OK<br>res.send(404); // Not Found<br>res.send(500); // Internal Server Error</p>\n<h2 id=\"Response重定向\"><a href=\"#Response重定向\" class=\"headerlink\" title=\"Response重定向\"></a>Response重定向</h2><p><code>res.redirect(&quot;http://www.hubwiz.com&quot;);</code></p>\n<h2 id=\"Response渲染页面\"><a href=\"#Response渲染页面\" class=\"headerlink\" title=\"Response渲染页面\"></a>Response渲染页面</h2><p>如果想渲染<code>hello.ejs</code>页面,<code>res.render(&#39;hello&#39;,&#123;title:&quot;MySQL&quot;,test_params:&#39;aaa&#39;&#125;);</code><br><code>hello.ejs</code>页面通过<code>&lt;%= title %&gt;</code>的方式取得title等参数</p>\n<p>Request获取主机名,路径名</p>\n<p><code>req.host</code>获取主机名，<code>req.path</code>获取请求路径名</p>\n<h2 id=\"restful-方式路由\"><a href=\"#restful-方式路由\" class=\"headerlink\" title=\"restful 方式路由\"></a>restful 方式路由</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">router.post(&#39;&#x2F;restful&#x2F;:id&#x2F;name&#x2F;:name&#39;, function (req,res) &#123;</span><br><span class=\"line\">  var id  &#x3D; req.params.id;</span><br><span class=\"line\">  var name &#x3D; req.params.name;</span><br><span class=\"line\">  console.log(JSON.stringify(req.params));</span><br><span class=\"line\">  res.send(&#123;test:&#96;id &#x3D; $&#123;id&#125;,name &#x3D; $&#123;name&#125;&#96;&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">JSON.stringify() 把js对象转成json</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><p>安装MySQL</p>\n<p><code>$ npm install mysql</code></p>\n<p>引入MySQL并配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mysql      &#x3D; require(&#39;mysql&#39;);</span><br><span class=\"line\">var connection &#x3D; mysql.createConnection(&#123;</span><br><span class=\"line\">    host     : &#39;localhost&#39;,</span><br><span class=\"line\">    user     : &#39;root&#39;,</span><br><span class=\"line\">    password : &#39;123456&#39;,</span><br><span class=\"line\">    database : &#39;csdn_test&#39;,</span><br><span class=\"line\">    port     : 3306</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>连接数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.connect()</span><br></pre></td></tr></table></figure>\n\n<p>这个方法可以接受一个回调用来判断是否连接成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.connect(function(err) &#123;</span><br><span class=\"line\">    if (!err) &#123;</span><br><span class=\"line\">   \t\t&#x2F;&#x2F; 连接成功</span><br><span class=\"line\">     &#125; else &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; 连接失败 </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">connection.end();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connection.query(&#39;SELECT 1 + 1 AS solution&#39;, function(err, rows, fields) &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(&#39;The solution is: &#39;, rows[0].solution);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>同上,接受一个回调来判断是否成功关闭连接</p>\n<p><code>connection.end(err =&gt; console.log(</code>连接中断${err}`));’</p>\n<h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><p>安装</p>\n<p><code>npm install -g mongoose</code><br>配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class=\"line\">var options &#x3D; &#123;</span><br><span class=\"line\">    db_user: &quot;root&quot;,</span><br><span class=\"line\">    db_pwd: &quot;123456&quot;,</span><br><span class=\"line\">    db_host: &quot;localhost&quot;,</span><br><span class=\"line\">    db_port: 27017,</span><br><span class=\"line\">    db_name: &quot;csdn_test&quot;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var dbURL &#x3D; &quot;mongodb:&#x2F;&#x2F;&quot; + options.db_user + &quot;:&quot; + options.db_pwd + &quot;@&quot; + options.db_host + &quot;:&quot; + options.db_port + &quot;&#x2F;&quot; + options.db_name;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 连接</span><br><span class=\"line\">mongoose.connect(dbURL);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 监听连接事件</span><br><span class=\"line\">mongoose.connection.on(&#39;connected&#39;, function (err) &#123;</span><br><span class=\"line\">    if (err) logger.error(&#39;Database connection failure&#39;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 监听错误事件</span><br><span class=\"line\">mongoose.connection.on(&#39;error&#39;, function (err) &#123;</span><br><span class=\"line\">    logger.error(&#39;Mongoose connected error &#39; + err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 监听断开事件</span><br><span class=\"line\">mongoose.connection.on(&#39;disconnected&#39;, function () &#123;</span><br><span class=\"line\">    logger.error(&#39;Mongoose disconnected&#39;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">查询</span><br><span class=\"line\"></span><br><span class=\"line\">mongoose.collection(&#39;mamals&#39;).find().toArray(function(err, result) &#123;</span><br><span class=\"line\">  if (err) throw err;</span><br><span class=\"line\">  console.log(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>其他方法以后遇到再补充.</p>"},{"title":"Dankal_iOS崩溃信息提交","author":"Arclin","abbrlink":"afeed214","date":"2016-10-31T16:00:00.000Z","_content":"Dankal_iOS 崩溃信息提交\n<!-- more -->\n\n1. 获取到崩溃信息（异常原因，异常方法，异常类名，堆栈）\n2. 获取到本机信息（型号，系统）\n3. 保存为 plist到本地\n4. 下次启动应用的时候发送信息到服务器(POST发送，记得添加 token 到HEADER)\n5. 发送完之后删除掉 plist 文件\n\n---\n\n## 如何捕获崩溃信息\n\nC 语言捕获\n\n```\n#include <libkern/OSAtomic.h>\n#include <execinfo.h>\n\n// 系统信号截获处理方法\nvoid signalHandler(int signal);\n// 异常截获处理方法\nvoid exceptionHandler(NSException *exception);\nconst int32_t _uncaughtExceptionMaximum = 20;\n\nNSString * const UncaughtExceptionHandlerSignalKey = @\"UncaughtExceptionHandlerSignalKey\";\nNSString *const SingalExceptionHandlerAddressesKey = @\"SingalExceptionHandlerAddressesKey\";\nNSString *const ExceptionHandlerAddressesKey = @\"ExceptionHandlerAddressesKey\";\n\nvoid signalHandler(int signal)\n{\n    volatile int32_t _uncaughtExceptionCount = 0;\n    int32_t exceptionCount = OSAtomicIncrement32(&_uncaughtExceptionCount);\n    if (exceptionCount > _uncaughtExceptionMaximum) // 如果太多不用处理\n    {\n        return;\n    }\n    // 获取信息\n    NSMutableDictionary *userInfo =\n    [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey];\n    \n    NSArray *callStack = [DKUncaughtExceptionHandler backtrace];\n    [userInfo  setObject:callStack  forKey:SingalExceptionHandlerAddressesKey];\n    \n}\n\nvoid exceptionHandler(NSException *exception)\n{\n    volatile int32_t _uncaughtExceptionCount = 0;\n    int32_t exceptionCount = OSAtomicIncrement32(&_uncaughtExceptionCount);\n    if (exceptionCount > _uncaughtExceptionMaximum) // 如果太多不用处理\n    {\n        return;\n    }\n    \n    NSArray *callStack = [DKUncaughtExceptionHandler backtrace];\n    NSMutableDictionary *userInfo =[NSMutableDictionary dictionaryWithDictionary:[exception userInfo]];\n    [userInfo setObject:callStack forKey:ExceptionHandlerAddressesKey];\n    \n    // 保存信息到本地\n    NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] stringByAppendingPathComponent:@\"crash.plist\"];\n    \n    // 获取本机信息\n    struct utsname systemInfo;\n    uname(&systemInfo);\n    \n    NSDictionary *crashInfo = @{@\"crash_time\":[NSDate dateStringWithDateFormat:@\"yyyy-MM-dd HH:mm:ss\"],\n                                @\"device_type\": [DKUncaughtExceptionHandler deviceVersion:[NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]],\n                                @\"device_system\": [UIDevice currentDevice].systemVersion,\n                                @\"crash_type\":exception.name,\n                                @\"crash_reason\":exception.reason,\n                                @\"crash_stack\":userInfo.descriptionInStringsFileFormat};\n    [crashInfo writeToFile:path atomically:YES];\n}\n```\n\n## OC 部分获取调用堆栈和注册崩溃拦截\n\n```\n//获取调用堆栈\n+ (NSArray *)backtrace\n{\n    void* callstack[128];\n    int frames = backtrace(callstack, 128);\n    char **strs = backtrace_symbols(callstack,frames);\n    \n    NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames];\n    for (int i=0;i<frames;i++)\n    {\n        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];\n    }\n    free(strs);\n    \n    return backtrace;\n}\n\n// 注册崩溃拦截\n- (void)installExceptionHandler\n{\n    NSSetUncaughtExceptionHandler(&exceptionHandler);\n    signal(SIGHUP, signalHandler);\n    signal(SIGINT, signalHandler);\n    signal(SIGQUIT, signalHandler);\n    \n    signal(SIGABRT, signalHandler);\n    signal(SIGILL, signalHandler);\n    signal(SIGSEGV, signalHandler);\n    signal(SIGFPE, signalHandler);\n    signal(SIGBUS, signalHandler);\n    signal(SIGPIPE, signalHandler);\n    \n    NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] stringByAppendingPathComponent:@\"crash.plist\"];\n    if([[NSFileManager defaultManager] fileExistsAtPath:path]){\n        NSDictionary *params = [[NSDictionary alloc] initWithContentsOfFile:path];\n        [DKHTTPTool POST:去看 Coding 的Crash Reporter项目说明文档  parameters:params header:@{@\"token\":去看 Coding的Crash Reporter项目说明文档} responseBlock:^(DKResponse *response) {\n            if (!response.error) {\n                NSError *error;\n                [[NSFileManager defaultManager] removeItemAtPath:path error:&error];\n                if(error)DKLog(@\"%@\",error);\n            }\n        }];\n    }\n}\n```\n\n## 发送请求的AFN封装方法\n\n```\n+ (void)POST:(NSString *)URLString parameters:(id)parameters header:(NSDictionary *)headerField responseBlock:(DKHTTPResponseBlock)block\n{\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n    AFHTTPRequestSerializer *requestSerializer =  [AFJSONRequestSerializer serializer];\n    [headerField enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        [requestSerializer setValue:obj forHTTPHeaderField:key];\n    }];\n    mgr.requestSerializer = requestSerializer;\n    [mgr POST:URLString parameters:parameters  progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\n        resp.rawData = responseObject;\n        if(block){\n            block(resp);\n        }\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        DKResponse *resp = [[DKResponse alloc] init];\n        resp.error = error;\n        if (block) {\n            block(resp);\n        }\n    }];\n} \n```    \n\n## 在 AppDelegte内注册\n\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n  [[[DKUncaughtExceptionHandler alloc] init] installExceptionHandler];\n\treturn YES:\n}\n```\n\n## iOS设备测试编号转机型\n\n```\n+ (NSString *) deviceVersion:(NSString *)deviceString\n{\n    //iPhone\n    if ([deviceString isEqualToString:@\"iPhone1,1\"])    return @\"iPhone 1G\";\n    if ([deviceString isEqualToString:@\"iPhone1,2\"])    return @\"iPhone 3G\";\n    if ([deviceString isEqualToString:@\"iPhone2,1\"])    return @\"iPhone 3GS\";\n    if ([deviceString isEqualToString:@\"iPhone3,1\"])    return @\"iPhone 4\";\n    if ([deviceString isEqualToString:@\"iPhone3,2\"])    return @\"Verizon iPhone 4\";\n    if ([deviceString isEqualToString:@\"iPhone4,1\"])    return @\"iPhone 4S\";\n    if ([deviceString isEqualToString:@\"iPhone5,1\"])    return @\"iPhone 5\";\n    if ([deviceString isEqualToString:@\"iPhone5,2\"])    return @\"iPhone 5\";\n    if ([deviceString isEqualToString:@\"iPhone5,3\"])    return @\"iPhone 5C\";\n    if ([deviceString isEqualToString:@\"iPhone5,4\"])    return @\"iPhone 5C\";\n    if ([deviceString isEqualToString:@\"iPhone6,1\"])    return @\"iPhone 5S\";\n    if ([deviceString isEqualToString:@\"iPhone6,2\"])    return @\"iPhone 5S\";\n    if ([deviceString isEqualToString:@\"iPhone7,1\"])    return @\"iPhone 6 Plus\";\n    if ([deviceString isEqualToString:@\"iPhone7,2\"])    return @\"iPhone 6\";\n    if ([deviceString isEqualToString:@\"iPhone8,1\"])    return @\"iPhone 6s\";\n    if ([deviceString isEqualToString:@\"iPhone8,2\"])    return @\"iPhone 6s Plus\";\n    if ([deviceString isEqualToString:@\"iPhone8,4\"])    return @\"iPhone SE\";\n    if ([deviceString isEqualToString:@\"iPhone9,1\"])    return @\"iPhone 7\";\n    if ([deviceString isEqualToString:@\"iPhone9,3\"])    return @\"iPhone 7\";\n    if ([deviceString isEqualToString:@\"iPhone9,2\"])    return @\"iPhone 7 Plus\";\n    if ([deviceString isEqualToString:@\"iPhone9,4\"])    return @\"iPhone 7 Plus\";\n    \n    //iPod\n    if ([deviceString isEqualToString:@\"iPod1,1\"])      return @\"iPod Touch 1G\";\n    if ([deviceString isEqualToString:@\"iPod2,1\"])      return @\"iPod Touch 2G\";\n    if ([deviceString isEqualToString:@\"iPod3,1\"])      return @\"iPod Touch 3G\";\n    if ([deviceString isEqualToString:@\"iPod4,1\"])      return @\"iPod Touch 4G\";\n    if ([deviceString isEqualToString:@\"iPod5,1\"])      return @\"iPod Touch 5G\";\n    \n    //iPad\n    if ([deviceString isEqualToString:@\"iPad1,1\"])      return @\"iPad\";\n    if ([deviceString isEqualToString:@\"iPad2,1\"])      return @\"iPad 2 (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad2,2\"])      return @\"iPad 2 (GSM)\";\n    if ([deviceString isEqualToString:@\"iPad2,3\"])      return @\"iPad 2 (CDMA)\";\n    if ([deviceString isEqualToString:@\"iPad2,4\"])      return @\"iPad 2 (32nm)\";\n    if ([deviceString isEqualToString:@\"iPad2,5\"])      return @\"iPad mini (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad2,6\"])      return @\"iPad mini (GSM)\";\n    if ([deviceString isEqualToString:@\"iPad2,7\"])      return @\"iPad mini (CDMA)\";\n    \n    if ([deviceString isEqualToString:@\"iPad3,1\"])      return @\"iPad 3(WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad3,2\"])      return @\"iPad 3(CDMA)\";\n    if ([deviceString isEqualToString:@\"iPad3,3\"])      return @\"iPad 3(4G)\";\n    if ([deviceString isEqualToString:@\"iPad3,4\"])      return @\"iPad 4 (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad3,5\"])      return @\"iPad 4 (4G)\";\n    if ([deviceString isEqualToString:@\"iPad3,6\"])      return @\"iPad 4 (CDMA)\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,1\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad4,2\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad4,3\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad5,3\"])      return @\"iPad Air 2\";\n    if ([deviceString isEqualToString:@\"iPad5,4\"])      return @\"iPad Air 2\";\n    if ([deviceString isEqualToString:@\"i386\"])         return @\"Simulator\";\n    if ([deviceString isEqualToString:@\"x86_64\"])       return @\"Simulator\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,4\"]\n        ||[deviceString isEqualToString:@\"iPad4,5\"]\n        ||[deviceString isEqualToString:@\"iPad4,6\"])      return @\"iPad mini 2\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,7\"]\n        ||[deviceString isEqualToString:@\"iPad4,8\"]\n        ||[deviceString isEqualToString:@\"iPad4,9\"])      return @\"iPad mini 3\";\n    \n    return deviceString;\n}\n```","source":"_posts/Dankal-iOS崩溃信息提交.md","raw":"---\ntitle: Dankal_iOS崩溃信息提交\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: afeed214\ndate: 2016-11-01 00:00:00\n---\nDankal_iOS 崩溃信息提交\n<!-- more -->\n\n1. 获取到崩溃信息（异常原因，异常方法，异常类名，堆栈）\n2. 获取到本机信息（型号，系统）\n3. 保存为 plist到本地\n4. 下次启动应用的时候发送信息到服务器(POST发送，记得添加 token 到HEADER)\n5. 发送完之后删除掉 plist 文件\n\n---\n\n## 如何捕获崩溃信息\n\nC 语言捕获\n\n```\n#include <libkern/OSAtomic.h>\n#include <execinfo.h>\n\n// 系统信号截获处理方法\nvoid signalHandler(int signal);\n// 异常截获处理方法\nvoid exceptionHandler(NSException *exception);\nconst int32_t _uncaughtExceptionMaximum = 20;\n\nNSString * const UncaughtExceptionHandlerSignalKey = @\"UncaughtExceptionHandlerSignalKey\";\nNSString *const SingalExceptionHandlerAddressesKey = @\"SingalExceptionHandlerAddressesKey\";\nNSString *const ExceptionHandlerAddressesKey = @\"ExceptionHandlerAddressesKey\";\n\nvoid signalHandler(int signal)\n{\n    volatile int32_t _uncaughtExceptionCount = 0;\n    int32_t exceptionCount = OSAtomicIncrement32(&_uncaughtExceptionCount);\n    if (exceptionCount > _uncaughtExceptionMaximum) // 如果太多不用处理\n    {\n        return;\n    }\n    // 获取信息\n    NSMutableDictionary *userInfo =\n    [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey];\n    \n    NSArray *callStack = [DKUncaughtExceptionHandler backtrace];\n    [userInfo  setObject:callStack  forKey:SingalExceptionHandlerAddressesKey];\n    \n}\n\nvoid exceptionHandler(NSException *exception)\n{\n    volatile int32_t _uncaughtExceptionCount = 0;\n    int32_t exceptionCount = OSAtomicIncrement32(&_uncaughtExceptionCount);\n    if (exceptionCount > _uncaughtExceptionMaximum) // 如果太多不用处理\n    {\n        return;\n    }\n    \n    NSArray *callStack = [DKUncaughtExceptionHandler backtrace];\n    NSMutableDictionary *userInfo =[NSMutableDictionary dictionaryWithDictionary:[exception userInfo]];\n    [userInfo setObject:callStack forKey:ExceptionHandlerAddressesKey];\n    \n    // 保存信息到本地\n    NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] stringByAppendingPathComponent:@\"crash.plist\"];\n    \n    // 获取本机信息\n    struct utsname systemInfo;\n    uname(&systemInfo);\n    \n    NSDictionary *crashInfo = @{@\"crash_time\":[NSDate dateStringWithDateFormat:@\"yyyy-MM-dd HH:mm:ss\"],\n                                @\"device_type\": [DKUncaughtExceptionHandler deviceVersion:[NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]],\n                                @\"device_system\": [UIDevice currentDevice].systemVersion,\n                                @\"crash_type\":exception.name,\n                                @\"crash_reason\":exception.reason,\n                                @\"crash_stack\":userInfo.descriptionInStringsFileFormat};\n    [crashInfo writeToFile:path atomically:YES];\n}\n```\n\n## OC 部分获取调用堆栈和注册崩溃拦截\n\n```\n//获取调用堆栈\n+ (NSArray *)backtrace\n{\n    void* callstack[128];\n    int frames = backtrace(callstack, 128);\n    char **strs = backtrace_symbols(callstack,frames);\n    \n    NSMutableArray *backtrace = [NSMutableArray arrayWithCapacity:frames];\n    for (int i=0;i<frames;i++)\n    {\n        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];\n    }\n    free(strs);\n    \n    return backtrace;\n}\n\n// 注册崩溃拦截\n- (void)installExceptionHandler\n{\n    NSSetUncaughtExceptionHandler(&exceptionHandler);\n    signal(SIGHUP, signalHandler);\n    signal(SIGINT, signalHandler);\n    signal(SIGQUIT, signalHandler);\n    \n    signal(SIGABRT, signalHandler);\n    signal(SIGILL, signalHandler);\n    signal(SIGSEGV, signalHandler);\n    signal(SIGFPE, signalHandler);\n    signal(SIGBUS, signalHandler);\n    signal(SIGPIPE, signalHandler);\n    \n    NSString *path = [[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] stringByAppendingPathComponent:@\"crash.plist\"];\n    if([[NSFileManager defaultManager] fileExistsAtPath:path]){\n        NSDictionary *params = [[NSDictionary alloc] initWithContentsOfFile:path];\n        [DKHTTPTool POST:去看 Coding 的Crash Reporter项目说明文档  parameters:params header:@{@\"token\":去看 Coding的Crash Reporter项目说明文档} responseBlock:^(DKResponse *response) {\n            if (!response.error) {\n                NSError *error;\n                [[NSFileManager defaultManager] removeItemAtPath:path error:&error];\n                if(error)DKLog(@\"%@\",error);\n            }\n        }];\n    }\n}\n```\n\n## 发送请求的AFN封装方法\n\n```\n+ (void)POST:(NSString *)URLString parameters:(id)parameters header:(NSDictionary *)headerField responseBlock:(DKHTTPResponseBlock)block\n{\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n    AFHTTPRequestSerializer *requestSerializer =  [AFJSONRequestSerializer serializer];\n    [headerField enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        [requestSerializer setValue:obj forHTTPHeaderField:key];\n    }];\n    mgr.requestSerializer = requestSerializer;\n    [mgr POST:URLString parameters:parameters  progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\n        resp.rawData = responseObject;\n        if(block){\n            block(resp);\n        }\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        DKResponse *resp = [[DKResponse alloc] init];\n        resp.error = error;\n        if (block) {\n            block(resp);\n        }\n    }];\n} \n```    \n\n## 在 AppDelegte内注册\n\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n  [[[DKUncaughtExceptionHandler alloc] init] installExceptionHandler];\n\treturn YES:\n}\n```\n\n## iOS设备测试编号转机型\n\n```\n+ (NSString *) deviceVersion:(NSString *)deviceString\n{\n    //iPhone\n    if ([deviceString isEqualToString:@\"iPhone1,1\"])    return @\"iPhone 1G\";\n    if ([deviceString isEqualToString:@\"iPhone1,2\"])    return @\"iPhone 3G\";\n    if ([deviceString isEqualToString:@\"iPhone2,1\"])    return @\"iPhone 3GS\";\n    if ([deviceString isEqualToString:@\"iPhone3,1\"])    return @\"iPhone 4\";\n    if ([deviceString isEqualToString:@\"iPhone3,2\"])    return @\"Verizon iPhone 4\";\n    if ([deviceString isEqualToString:@\"iPhone4,1\"])    return @\"iPhone 4S\";\n    if ([deviceString isEqualToString:@\"iPhone5,1\"])    return @\"iPhone 5\";\n    if ([deviceString isEqualToString:@\"iPhone5,2\"])    return @\"iPhone 5\";\n    if ([deviceString isEqualToString:@\"iPhone5,3\"])    return @\"iPhone 5C\";\n    if ([deviceString isEqualToString:@\"iPhone5,4\"])    return @\"iPhone 5C\";\n    if ([deviceString isEqualToString:@\"iPhone6,1\"])    return @\"iPhone 5S\";\n    if ([deviceString isEqualToString:@\"iPhone6,2\"])    return @\"iPhone 5S\";\n    if ([deviceString isEqualToString:@\"iPhone7,1\"])    return @\"iPhone 6 Plus\";\n    if ([deviceString isEqualToString:@\"iPhone7,2\"])    return @\"iPhone 6\";\n    if ([deviceString isEqualToString:@\"iPhone8,1\"])    return @\"iPhone 6s\";\n    if ([deviceString isEqualToString:@\"iPhone8,2\"])    return @\"iPhone 6s Plus\";\n    if ([deviceString isEqualToString:@\"iPhone8,4\"])    return @\"iPhone SE\";\n    if ([deviceString isEqualToString:@\"iPhone9,1\"])    return @\"iPhone 7\";\n    if ([deviceString isEqualToString:@\"iPhone9,3\"])    return @\"iPhone 7\";\n    if ([deviceString isEqualToString:@\"iPhone9,2\"])    return @\"iPhone 7 Plus\";\n    if ([deviceString isEqualToString:@\"iPhone9,4\"])    return @\"iPhone 7 Plus\";\n    \n    //iPod\n    if ([deviceString isEqualToString:@\"iPod1,1\"])      return @\"iPod Touch 1G\";\n    if ([deviceString isEqualToString:@\"iPod2,1\"])      return @\"iPod Touch 2G\";\n    if ([deviceString isEqualToString:@\"iPod3,1\"])      return @\"iPod Touch 3G\";\n    if ([deviceString isEqualToString:@\"iPod4,1\"])      return @\"iPod Touch 4G\";\n    if ([deviceString isEqualToString:@\"iPod5,1\"])      return @\"iPod Touch 5G\";\n    \n    //iPad\n    if ([deviceString isEqualToString:@\"iPad1,1\"])      return @\"iPad\";\n    if ([deviceString isEqualToString:@\"iPad2,1\"])      return @\"iPad 2 (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad2,2\"])      return @\"iPad 2 (GSM)\";\n    if ([deviceString isEqualToString:@\"iPad2,3\"])      return @\"iPad 2 (CDMA)\";\n    if ([deviceString isEqualToString:@\"iPad2,4\"])      return @\"iPad 2 (32nm)\";\n    if ([deviceString isEqualToString:@\"iPad2,5\"])      return @\"iPad mini (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad2,6\"])      return @\"iPad mini (GSM)\";\n    if ([deviceString isEqualToString:@\"iPad2,7\"])      return @\"iPad mini (CDMA)\";\n    \n    if ([deviceString isEqualToString:@\"iPad3,1\"])      return @\"iPad 3(WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad3,2\"])      return @\"iPad 3(CDMA)\";\n    if ([deviceString isEqualToString:@\"iPad3,3\"])      return @\"iPad 3(4G)\";\n    if ([deviceString isEqualToString:@\"iPad3,4\"])      return @\"iPad 4 (WiFi)\";\n    if ([deviceString isEqualToString:@\"iPad3,5\"])      return @\"iPad 4 (4G)\";\n    if ([deviceString isEqualToString:@\"iPad3,6\"])      return @\"iPad 4 (CDMA)\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,1\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad4,2\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad4,3\"])      return @\"iPad Air\";\n    if ([deviceString isEqualToString:@\"iPad5,3\"])      return @\"iPad Air 2\";\n    if ([deviceString isEqualToString:@\"iPad5,4\"])      return @\"iPad Air 2\";\n    if ([deviceString isEqualToString:@\"i386\"])         return @\"Simulator\";\n    if ([deviceString isEqualToString:@\"x86_64\"])       return @\"Simulator\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,4\"]\n        ||[deviceString isEqualToString:@\"iPad4,5\"]\n        ||[deviceString isEqualToString:@\"iPad4,6\"])      return @\"iPad mini 2\";\n    \n    if ([deviceString isEqualToString:@\"iPad4,7\"]\n        ||[deviceString isEqualToString:@\"iPad4,8\"]\n        ||[deviceString isEqualToString:@\"iPad4,9\"])      return @\"iPad mini 3\";\n    \n    return deviceString;\n}\n```","slug":"Dankal-iOS崩溃信息提交","published":1,"updated":"2021-04-12T06:07:04.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog4t000f45n039k76w3x","content":"<p>Dankal_iOS 崩溃信息提交</p>\n<span id=\"more\"></span>\n\n<ol>\n<li>获取到崩溃信息（异常原因，异常方法，异常类名，堆栈）</li>\n<li>获取到本机信息（型号，系统）</li>\n<li>保存为 plist到本地</li>\n<li>下次启动应用的时候发送信息到服务器(POST发送，记得添加 token 到HEADER)</li>\n<li>发送完之后删除掉 plist 文件</li>\n</ol>\n<hr>\n<h2 id=\"如何捕获崩溃信息\"><a href=\"#如何捕获崩溃信息\" class=\"headerlink\" title=\"如何捕获崩溃信息\"></a>如何捕获崩溃信息</h2><p>C 语言捕获</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;libkern&#x2F;OSAtomic.h&gt;</span><br><span class=\"line\">#include &lt;execinfo.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 系统信号截获处理方法</span><br><span class=\"line\">void signalHandler(int signal);</span><br><span class=\"line\">&#x2F;&#x2F; 异常截获处理方法</span><br><span class=\"line\">void exceptionHandler(NSException *exception);</span><br><span class=\"line\">const int32_t _uncaughtExceptionMaximum &#x3D; 20;</span><br><span class=\"line\"></span><br><span class=\"line\">NSString * const UncaughtExceptionHandlerSignalKey &#x3D; @&quot;UncaughtExceptionHandlerSignalKey&quot;;</span><br><span class=\"line\">NSString *const SingalExceptionHandlerAddressesKey &#x3D; @&quot;SingalExceptionHandlerAddressesKey&quot;;</span><br><span class=\"line\">NSString *const ExceptionHandlerAddressesKey &#x3D; @&quot;ExceptionHandlerAddressesKey&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">void signalHandler(int signal)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    volatile int32_t _uncaughtExceptionCount &#x3D; 0;</span><br><span class=\"line\">    int32_t exceptionCount &#x3D; OSAtomicIncrement32(&amp;_uncaughtExceptionCount);</span><br><span class=\"line\">    if (exceptionCount &gt; _uncaughtExceptionMaximum) &#x2F;&#x2F; 如果太多不用处理</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 获取信息</span><br><span class=\"line\">    NSMutableDictionary *userInfo &#x3D;</span><br><span class=\"line\">    [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSArray *callStack &#x3D; [DKUncaughtExceptionHandler backtrace];</span><br><span class=\"line\">    [userInfo  setObject:callStack  forKey:SingalExceptionHandlerAddressesKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void exceptionHandler(NSException *exception)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    volatile int32_t _uncaughtExceptionCount &#x3D; 0;</span><br><span class=\"line\">    int32_t exceptionCount &#x3D; OSAtomicIncrement32(&amp;_uncaughtExceptionCount);</span><br><span class=\"line\">    if (exceptionCount &gt; _uncaughtExceptionMaximum) &#x2F;&#x2F; 如果太多不用处理</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSArray *callStack &#x3D; [DKUncaughtExceptionHandler backtrace];</span><br><span class=\"line\">    NSMutableDictionary *userInfo &#x3D;[NSMutableDictionary dictionaryWithDictionary:[exception userInfo]];</span><br><span class=\"line\">    [userInfo setObject:callStack forKey:ExceptionHandlerAddressesKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 保存信息到本地</span><br><span class=\"line\">    NSString *path &#x3D; [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] stringByAppendingPathComponent:@&quot;crash.plist&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 获取本机信息</span><br><span class=\"line\">    struct utsname systemInfo;</span><br><span class=\"line\">    uname(&amp;systemInfo);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSDictionary *crashInfo &#x3D; @&#123;@&quot;crash_time&quot;:[NSDate dateStringWithDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;],</span><br><span class=\"line\">                                @&quot;device_type&quot;: [DKUncaughtExceptionHandler deviceVersion:[NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]],</span><br><span class=\"line\">                                @&quot;device_system&quot;: [UIDevice currentDevice].systemVersion,</span><br><span class=\"line\">                                @&quot;crash_type&quot;:exception.name,</span><br><span class=\"line\">                                @&quot;crash_reason&quot;:exception.reason,</span><br><span class=\"line\">                                @&quot;crash_stack&quot;:userInfo.descriptionInStringsFileFormat&#125;;</span><br><span class=\"line\">    [crashInfo writeToFile:path atomically:YES];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"OC-部分获取调用堆栈和注册崩溃拦截\"><a href=\"#OC-部分获取调用堆栈和注册崩溃拦截\" class=\"headerlink\" title=\"OC 部分获取调用堆栈和注册崩溃拦截\"></a>OC 部分获取调用堆栈和注册崩溃拦截</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;获取调用堆栈</span><br><span class=\"line\">+ (NSArray *)backtrace</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    void* callstack[128];</span><br><span class=\"line\">    int frames &#x3D; backtrace(callstack, 128);</span><br><span class=\"line\">    char **strs &#x3D; backtrace_symbols(callstack,frames);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSMutableArray *backtrace &#x3D; [NSMutableArray arrayWithCapacity:frames];</span><br><span class=\"line\">    for (int i&#x3D;0;i&lt;frames;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free(strs);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return backtrace;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 注册崩溃拦截</span><br><span class=\"line\">- (void)installExceptionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSSetUncaughtExceptionHandler(&amp;exceptionHandler);</span><br><span class=\"line\">    signal(SIGHUP, signalHandler);</span><br><span class=\"line\">    signal(SIGINT, signalHandler);</span><br><span class=\"line\">    signal(SIGQUIT, signalHandler);</span><br><span class=\"line\">    </span><br><span class=\"line\">    signal(SIGABRT, signalHandler);</span><br><span class=\"line\">    signal(SIGILL, signalHandler);</span><br><span class=\"line\">    signal(SIGSEGV, signalHandler);</span><br><span class=\"line\">    signal(SIGFPE, signalHandler);</span><br><span class=\"line\">    signal(SIGBUS, signalHandler);</span><br><span class=\"line\">    signal(SIGPIPE, signalHandler);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSString *path &#x3D; [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] stringByAppendingPathComponent:@&quot;crash.plist&quot;];</span><br><span class=\"line\">    if([[NSFileManager defaultManager] fileExistsAtPath:path])&#123;</span><br><span class=\"line\">        NSDictionary *params &#x3D; [[NSDictionary alloc] initWithContentsOfFile:path];</span><br><span class=\"line\">        [DKHTTPTool POST:去看 Coding 的Crash Reporter项目说明文档  parameters:params header:@&#123;@&quot;token&quot;:去看 Coding的Crash Reporter项目说明文档&#125; responseBlock:^(DKResponse *response) &#123;</span><br><span class=\"line\">            if (!response.error) &#123;</span><br><span class=\"line\">                NSError *error;</span><br><span class=\"line\">                [[NSFileManager defaultManager] removeItemAtPath:path error:&amp;error];</span><br><span class=\"line\">                if(error)DKLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"发送请求的AFN封装方法\"><a href=\"#发送请求的AFN封装方法\" class=\"headerlink\" title=\"发送请求的AFN封装方法\"></a>发送请求的AFN封装方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)POST:(NSString *)URLString parameters:(id)parameters header:(NSDictionary *)headerField responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer &#x3D;  [AFJSONRequestSerializer serializer];</span><br><span class=\"line\">    [headerField enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [requestSerializer setValue:obj forHTTPHeaderField:key];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    mgr.requestSerializer &#x3D; requestSerializer;</span><br><span class=\"line\">    [mgr POST:URLString parameters:parameters  progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject];</span><br><span class=\"line\">        resp.rawData &#x3D; responseObject;</span><br><span class=\"line\">        if(block)&#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [[DKResponse alloc] init];</span><br><span class=\"line\">        resp.error &#x3D; error;</span><br><span class=\"line\">        if (block) &#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">&#96;&#96;&#96;    </span><br><span class=\"line\"></span><br><span class=\"line\">## 在 AppDelegte内注册</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions<br>{<br>[[[DKUncaughtExceptionHandler alloc] init] installExceptionHandler];<br>  return YES:<br>}<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## iOS设备测试编号转机型</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li>(NSString *) deviceVersion:(NSString *)deviceString<br>{<br>  //iPhone<br>  if ([deviceString isEqualToString:@”iPhone1,1”])    return @”iPhone 1G”;<br>  if ([deviceString isEqualToString:@”iPhone1,2”])    return @”iPhone 3G”;<br>  if ([deviceString isEqualToString:@”iPhone2,1”])    return @”iPhone 3GS”;<br>  if ([deviceString isEqualToString:@”iPhone3,1”])    return @”iPhone 4”;<br>  if ([deviceString isEqualToString:@”iPhone3,2”])    return @”Verizon iPhone 4”;<br>  if ([deviceString isEqualToString:@”iPhone4,1”])    return @”iPhone 4S”;<br>  if ([deviceString isEqualToString:@”iPhone5,1”])    return @”iPhone 5”;<br>  if ([deviceString isEqualToString:@”iPhone5,2”])    return @”iPhone 5”;<br>  if ([deviceString isEqualToString:@”iPhone5,3”])    return @”iPhone 5C”;<br>  if ([deviceString isEqualToString:@”iPhone5,4”])    return @”iPhone 5C”;<br>  if ([deviceString isEqualToString:@”iPhone6,1”])    return @”iPhone 5S”;<br>  if ([deviceString isEqualToString:@”iPhone6,2”])    return @”iPhone 5S”;<br>  if ([deviceString isEqualToString:@”iPhone7,1”])    return @”iPhone 6 Plus”;<br>  if ([deviceString isEqualToString:@”iPhone7,2”])    return @”iPhone 6”;<br>  if ([deviceString isEqualToString:@”iPhone8,1”])    return @”iPhone 6s”;<br>  if ([deviceString isEqualToString:@”iPhone8,2”])    return @”iPhone 6s Plus”;<br>  if ([deviceString isEqualToString:@”iPhone8,4”])    return @”iPhone SE”;<br>  if ([deviceString isEqualToString:@”iPhone9,1”])    return @”iPhone 7”;<br>  if ([deviceString isEqualToString:@”iPhone9,3”])    return @”iPhone 7”;<br>  if ([deviceString isEqualToString:@”iPhone9,2”])    return @”iPhone 7 Plus”;<br>  if ([deviceString isEqualToString:@”iPhone9,4”])    return @”iPhone 7 Plus”;  //iPod<br>  if ([deviceString isEqualToString:@”iPod1,1”])      return @”iPod Touch 1G”;<br>  if ([deviceString isEqualToString:@”iPod2,1”])      return @”iPod Touch 2G”;<br>  if ([deviceString isEqualToString:@”iPod3,1”])      return @”iPod Touch 3G”;<br>  if ([deviceString isEqualToString:@”iPod4,1”])      return @”iPod Touch 4G”;<br>  if ([deviceString isEqualToString:@”iPod5,1”])      return @”iPod Touch 5G”;  //iPad<br>  if ([deviceString isEqualToString:@”iPad1,1”])      return @”iPad”;<br>  if ([deviceString isEqualToString:@”iPad2,1”])      return @”iPad 2 (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad2,2”])      return @”iPad 2 (GSM)”;<br>  if ([deviceString isEqualToString:@”iPad2,3”])      return @”iPad 2 (CDMA)”;<br>  if ([deviceString isEqualToString:@”iPad2,4”])      return @”iPad 2 (32nm)”;<br>  if ([deviceString isEqualToString:@”iPad2,5”])      return @”iPad mini (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad2,6”])      return @”iPad mini (GSM)”;<br>  if ([deviceString isEqualToString:@”iPad2,7”])      return @”iPad mini (CDMA)”;  if ([deviceString isEqualToString:@”iPad3,1”])      return @”iPad 3(WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad3,2”])      return @”iPad 3(CDMA)”;<br>  if ([deviceString isEqualToString:@”iPad3,3”])      return @”iPad 3(4G)”;<br>  if ([deviceString isEqualToString:@”iPad3,4”])      return @”iPad 4 (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad3,5”])      return @”iPad 4 (4G)”;<br>  if ([deviceString isEqualToString:@”iPad3,6”])      return @”iPad 4 (CDMA)”;  if ([deviceString isEqualToString:@”iPad4,1”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad4,2”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad4,3”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad5,3”])      return @”iPad Air 2”;<br>  if ([deviceString isEqualToString:@”iPad5,4”])      return @”iPad Air 2”;<br>  if ([deviceString isEqualToString:@”i386”])         return @”Simulator”;<br>  if ([deviceString isEqualToString:@”x86_64”])       return @”Simulator”;  if ([deviceString isEqualToString:@”iPad4,4”]<pre><code>  ||[deviceString isEqualToString:@&quot;iPad4,5&quot;]\n  ||[deviceString isEqualToString:@&quot;iPad4,6&quot;])      return @&quot;iPad mini 2&quot;;\n</code></pre>\n  if ([deviceString isEqualToString:@”iPad4,7”]<pre><code>  ||[deviceString isEqualToString:@&quot;iPad4,8&quot;]\n  ||[deviceString isEqualToString:@&quot;iPad4,9&quot;])      return @&quot;iPad mini 3&quot;;\n</code></pre>\n  return deviceString;<br>}<br>```</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Dankal_iOS 崩溃信息提交</p>","more":"<ol>\n<li>获取到崩溃信息（异常原因，异常方法，异常类名，堆栈）</li>\n<li>获取到本机信息（型号，系统）</li>\n<li>保存为 plist到本地</li>\n<li>下次启动应用的时候发送信息到服务器(POST发送，记得添加 token 到HEADER)</li>\n<li>发送完之后删除掉 plist 文件</li>\n</ol>\n<hr>\n<h2 id=\"如何捕获崩溃信息\"><a href=\"#如何捕获崩溃信息\" class=\"headerlink\" title=\"如何捕获崩溃信息\"></a>如何捕获崩溃信息</h2><p>C 语言捕获</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;libkern&#x2F;OSAtomic.h&gt;</span><br><span class=\"line\">#include &lt;execinfo.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 系统信号截获处理方法</span><br><span class=\"line\">void signalHandler(int signal);</span><br><span class=\"line\">&#x2F;&#x2F; 异常截获处理方法</span><br><span class=\"line\">void exceptionHandler(NSException *exception);</span><br><span class=\"line\">const int32_t _uncaughtExceptionMaximum &#x3D; 20;</span><br><span class=\"line\"></span><br><span class=\"line\">NSString * const UncaughtExceptionHandlerSignalKey &#x3D; @&quot;UncaughtExceptionHandlerSignalKey&quot;;</span><br><span class=\"line\">NSString *const SingalExceptionHandlerAddressesKey &#x3D; @&quot;SingalExceptionHandlerAddressesKey&quot;;</span><br><span class=\"line\">NSString *const ExceptionHandlerAddressesKey &#x3D; @&quot;ExceptionHandlerAddressesKey&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">void signalHandler(int signal)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    volatile int32_t _uncaughtExceptionCount &#x3D; 0;</span><br><span class=\"line\">    int32_t exceptionCount &#x3D; OSAtomicIncrement32(&amp;_uncaughtExceptionCount);</span><br><span class=\"line\">    if (exceptionCount &gt; _uncaughtExceptionMaximum) &#x2F;&#x2F; 如果太多不用处理</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 获取信息</span><br><span class=\"line\">    NSMutableDictionary *userInfo &#x3D;</span><br><span class=\"line\">    [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSArray *callStack &#x3D; [DKUncaughtExceptionHandler backtrace];</span><br><span class=\"line\">    [userInfo  setObject:callStack  forKey:SingalExceptionHandlerAddressesKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void exceptionHandler(NSException *exception)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    volatile int32_t _uncaughtExceptionCount &#x3D; 0;</span><br><span class=\"line\">    int32_t exceptionCount &#x3D; OSAtomicIncrement32(&amp;_uncaughtExceptionCount);</span><br><span class=\"line\">    if (exceptionCount &gt; _uncaughtExceptionMaximum) &#x2F;&#x2F; 如果太多不用处理</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSArray *callStack &#x3D; [DKUncaughtExceptionHandler backtrace];</span><br><span class=\"line\">    NSMutableDictionary *userInfo &#x3D;[NSMutableDictionary dictionaryWithDictionary:[exception userInfo]];</span><br><span class=\"line\">    [userInfo setObject:callStack forKey:ExceptionHandlerAddressesKey];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 保存信息到本地</span><br><span class=\"line\">    NSString *path &#x3D; [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] stringByAppendingPathComponent:@&quot;crash.plist&quot;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 获取本机信息</span><br><span class=\"line\">    struct utsname systemInfo;</span><br><span class=\"line\">    uname(&amp;systemInfo);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSDictionary *crashInfo &#x3D; @&#123;@&quot;crash_time&quot;:[NSDate dateStringWithDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;],</span><br><span class=\"line\">                                @&quot;device_type&quot;: [DKUncaughtExceptionHandler deviceVersion:[NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]],</span><br><span class=\"line\">                                @&quot;device_system&quot;: [UIDevice currentDevice].systemVersion,</span><br><span class=\"line\">                                @&quot;crash_type&quot;:exception.name,</span><br><span class=\"line\">                                @&quot;crash_reason&quot;:exception.reason,</span><br><span class=\"line\">                                @&quot;crash_stack&quot;:userInfo.descriptionInStringsFileFormat&#125;;</span><br><span class=\"line\">    [crashInfo writeToFile:path atomically:YES];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"OC-部分获取调用堆栈和注册崩溃拦截\"><a href=\"#OC-部分获取调用堆栈和注册崩溃拦截\" class=\"headerlink\" title=\"OC 部分获取调用堆栈和注册崩溃拦截\"></a>OC 部分获取调用堆栈和注册崩溃拦截</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;获取调用堆栈</span><br><span class=\"line\">+ (NSArray *)backtrace</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    void* callstack[128];</span><br><span class=\"line\">    int frames &#x3D; backtrace(callstack, 128);</span><br><span class=\"line\">    char **strs &#x3D; backtrace_symbols(callstack,frames);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSMutableArray *backtrace &#x3D; [NSMutableArray arrayWithCapacity:frames];</span><br><span class=\"line\">    for (int i&#x3D;0;i&lt;frames;i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free(strs);</span><br><span class=\"line\">    </span><br><span class=\"line\">    return backtrace;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 注册崩溃拦截</span><br><span class=\"line\">- (void)installExceptionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSSetUncaughtExceptionHandler(&amp;exceptionHandler);</span><br><span class=\"line\">    signal(SIGHUP, signalHandler);</span><br><span class=\"line\">    signal(SIGINT, signalHandler);</span><br><span class=\"line\">    signal(SIGQUIT, signalHandler);</span><br><span class=\"line\">    </span><br><span class=\"line\">    signal(SIGABRT, signalHandler);</span><br><span class=\"line\">    signal(SIGILL, signalHandler);</span><br><span class=\"line\">    signal(SIGSEGV, signalHandler);</span><br><span class=\"line\">    signal(SIGFPE, signalHandler);</span><br><span class=\"line\">    signal(SIGBUS, signalHandler);</span><br><span class=\"line\">    signal(SIGPIPE, signalHandler);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSString *path &#x3D; [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] stringByAppendingPathComponent:@&quot;crash.plist&quot;];</span><br><span class=\"line\">    if([[NSFileManager defaultManager] fileExistsAtPath:path])&#123;</span><br><span class=\"line\">        NSDictionary *params &#x3D; [[NSDictionary alloc] initWithContentsOfFile:path];</span><br><span class=\"line\">        [DKHTTPTool POST:去看 Coding 的Crash Reporter项目说明文档  parameters:params header:@&#123;@&quot;token&quot;:去看 Coding的Crash Reporter项目说明文档&#125; responseBlock:^(DKResponse *response) &#123;</span><br><span class=\"line\">            if (!response.error) &#123;</span><br><span class=\"line\">                NSError *error;</span><br><span class=\"line\">                [[NSFileManager defaultManager] removeItemAtPath:path error:&amp;error];</span><br><span class=\"line\">                if(error)DKLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"发送请求的AFN封装方法\"><a href=\"#发送请求的AFN封装方法\" class=\"headerlink\" title=\"发送请求的AFN封装方法\"></a>发送请求的AFN封装方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)POST:(NSString *)URLString parameters:(id)parameters header:(NSDictionary *)headerField responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer &#x3D;  [AFJSONRequestSerializer serializer];</span><br><span class=\"line\">    [headerField enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [requestSerializer setValue:obj forHTTPHeaderField:key];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    mgr.requestSerializer &#x3D; requestSerializer;</span><br><span class=\"line\">    [mgr POST:URLString parameters:parameters  progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject];</span><br><span class=\"line\">        resp.rawData &#x3D; responseObject;</span><br><span class=\"line\">        if(block)&#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [[DKResponse alloc] init];</span><br><span class=\"line\">        resp.error &#x3D; error;</span><br><span class=\"line\">        if (block) &#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">&#96;&#96;&#96;    </span><br><span class=\"line\"></span><br><span class=\"line\">## 在 AppDelegte内注册</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions<br>{<br>[[[DKUncaughtExceptionHandler alloc] init] installExceptionHandler];<br>  return YES:<br>}<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## iOS设备测试编号转机型</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li>(NSString *) deviceVersion:(NSString *)deviceString<br>{<br>  //iPhone<br>  if ([deviceString isEqualToString:@”iPhone1,1”])    return @”iPhone 1G”;<br>  if ([deviceString isEqualToString:@”iPhone1,2”])    return @”iPhone 3G”;<br>  if ([deviceString isEqualToString:@”iPhone2,1”])    return @”iPhone 3GS”;<br>  if ([deviceString isEqualToString:@”iPhone3,1”])    return @”iPhone 4”;<br>  if ([deviceString isEqualToString:@”iPhone3,2”])    return @”Verizon iPhone 4”;<br>  if ([deviceString isEqualToString:@”iPhone4,1”])    return @”iPhone 4S”;<br>  if ([deviceString isEqualToString:@”iPhone5,1”])    return @”iPhone 5”;<br>  if ([deviceString isEqualToString:@”iPhone5,2”])    return @”iPhone 5”;<br>  if ([deviceString isEqualToString:@”iPhone5,3”])    return @”iPhone 5C”;<br>  if ([deviceString isEqualToString:@”iPhone5,4”])    return @”iPhone 5C”;<br>  if ([deviceString isEqualToString:@”iPhone6,1”])    return @”iPhone 5S”;<br>  if ([deviceString isEqualToString:@”iPhone6,2”])    return @”iPhone 5S”;<br>  if ([deviceString isEqualToString:@”iPhone7,1”])    return @”iPhone 6 Plus”;<br>  if ([deviceString isEqualToString:@”iPhone7,2”])    return @”iPhone 6”;<br>  if ([deviceString isEqualToString:@”iPhone8,1”])    return @”iPhone 6s”;<br>  if ([deviceString isEqualToString:@”iPhone8,2”])    return @”iPhone 6s Plus”;<br>  if ([deviceString isEqualToString:@”iPhone8,4”])    return @”iPhone SE”;<br>  if ([deviceString isEqualToString:@”iPhone9,1”])    return @”iPhone 7”;<br>  if ([deviceString isEqualToString:@”iPhone9,3”])    return @”iPhone 7”;<br>  if ([deviceString isEqualToString:@”iPhone9,2”])    return @”iPhone 7 Plus”;<br>  if ([deviceString isEqualToString:@”iPhone9,4”])    return @”iPhone 7 Plus”;  //iPod<br>  if ([deviceString isEqualToString:@”iPod1,1”])      return @”iPod Touch 1G”;<br>  if ([deviceString isEqualToString:@”iPod2,1”])      return @”iPod Touch 2G”;<br>  if ([deviceString isEqualToString:@”iPod3,1”])      return @”iPod Touch 3G”;<br>  if ([deviceString isEqualToString:@”iPod4,1”])      return @”iPod Touch 4G”;<br>  if ([deviceString isEqualToString:@”iPod5,1”])      return @”iPod Touch 5G”;  //iPad<br>  if ([deviceString isEqualToString:@”iPad1,1”])      return @”iPad”;<br>  if ([deviceString isEqualToString:@”iPad2,1”])      return @”iPad 2 (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad2,2”])      return @”iPad 2 (GSM)”;<br>  if ([deviceString isEqualToString:@”iPad2,3”])      return @”iPad 2 (CDMA)”;<br>  if ([deviceString isEqualToString:@”iPad2,4”])      return @”iPad 2 (32nm)”;<br>  if ([deviceString isEqualToString:@”iPad2,5”])      return @”iPad mini (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad2,6”])      return @”iPad mini (GSM)”;<br>  if ([deviceString isEqualToString:@”iPad2,7”])      return @”iPad mini (CDMA)”;  if ([deviceString isEqualToString:@”iPad3,1”])      return @”iPad 3(WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad3,2”])      return @”iPad 3(CDMA)”;<br>  if ([deviceString isEqualToString:@”iPad3,3”])      return @”iPad 3(4G)”;<br>  if ([deviceString isEqualToString:@”iPad3,4”])      return @”iPad 4 (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad3,5”])      return @”iPad 4 (4G)”;<br>  if ([deviceString isEqualToString:@”iPad3,6”])      return @”iPad 4 (CDMA)”;  if ([deviceString isEqualToString:@”iPad4,1”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad4,2”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad4,3”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad5,3”])      return @”iPad Air 2”;<br>  if ([deviceString isEqualToString:@”iPad5,4”])      return @”iPad Air 2”;<br>  if ([deviceString isEqualToString:@”i386”])         return @”Simulator”;<br>  if ([deviceString isEqualToString:@”x86_64”])       return @”Simulator”;  if ([deviceString isEqualToString:@”iPad4,4”]<pre><code>  ||[deviceString isEqualToString:@&quot;iPad4,5&quot;]\n  ||[deviceString isEqualToString:@&quot;iPad4,6&quot;])      return @&quot;iPad mini 2&quot;;\n</code></pre>\n  if ([deviceString isEqualToString:@”iPad4,7”]<pre><code>  ||[deviceString isEqualToString:@&quot;iPad4,8&quot;]\n  ||[deviceString isEqualToString:@&quot;iPad4,9&quot;])      return @&quot;iPad mini 3&quot;;\n</code></pre>\n  return deviceString;<br>}<br>```</li>\n</ul>"},{"title":"DKLogger--iOS日志管理框架","author":"Arclin","abbrlink":"abce56f1","date":"2017-02-22T16:00:00.000Z","_content":"用于管理iOS的Log信息的框架\n\n<!-- more -->\n可以用在平时的调试中,另外如果app在用户使用过程中发生一些意外事件或者程序崩溃事件,那我们也可以通过服务器的文件得知问题所在\n\n特性\n- 支持四个Log等级 `DEBUG`,`INFO`,`WARN`,`ERROR`\n- 支持储存Log文件到本地和上传到服务器\n- 支持自定义打印Log类型和写入Log类型\n- 支持捕获&发送崩溃信息\n- 在界面长按2秒可以查看Log信息\n- 可以获取用户的在App内的查看轨迹(进入了哪些控制器)\n- 崩溃的时候重启RunLoop,进入ANR状态,不闪退\n- 支持服务器端同步显示Log信息(建议搭建本地服务器,因为这样子Log发送快)\n\n使用\n\n```\nDKLog(@\"...\"); 普通log\nDKInfoLog(@\"...\"); 包含特殊信息的log\nDKWRANLog(@\"...\"); 警告log\nDKERRLog(@\"...\"); 错误log\n```\n```\n/**\t\n 初始化: 创建Txt的Log文件并写入输出\n \n @param path  文件夹路径,默认Documents\n @param url   上传log地址 当发生崩溃事故的时候就会提示用户是否上传Log到服务器\n @param debug 调试模式 */\n- (void)registerLoggerInPath:(NSString *)path uploadUrlStr:(NSString *)url debug:(BOOL)debug;\neg:\n[[DKSharedLogger registerLoggerInPath:[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] uploadUrlStr:@\"http://192.168.1.91/public/index/Index/hello\" debug:YES];\n```\n\n```\n[DKSharedLogger printLevel:DKLoggerLevelInfo|DKLoggerLevelWARN]; 在控制器只打印Info和Warn等级的Log\n```\n```\n[DKSharedLogger saveLevel:DKLoggerLevelError|DKLoggerLevelInfo]; 在文件中之写入Info和Error等级的Log\n```\n\n```\nDK_VAR_DUMP(arr); 查看对象信息,例如变量arr\n```\n\n长按界面2秒弹出log信息界面\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/1011.png?raw=true)","source":"_posts/DKLogger-iOS日志管理框架.md","raw":"---\ntitle: DKLogger--iOS日志管理框架\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: abce56f1\ndate: 2017-02-23 00:00:00\n---\n用于管理iOS的Log信息的框架\n\n<!-- more -->\n可以用在平时的调试中,另外如果app在用户使用过程中发生一些意外事件或者程序崩溃事件,那我们也可以通过服务器的文件得知问题所在\n\n特性\n- 支持四个Log等级 `DEBUG`,`INFO`,`WARN`,`ERROR`\n- 支持储存Log文件到本地和上传到服务器\n- 支持自定义打印Log类型和写入Log类型\n- 支持捕获&发送崩溃信息\n- 在界面长按2秒可以查看Log信息\n- 可以获取用户的在App内的查看轨迹(进入了哪些控制器)\n- 崩溃的时候重启RunLoop,进入ANR状态,不闪退\n- 支持服务器端同步显示Log信息(建议搭建本地服务器,因为这样子Log发送快)\n\n使用\n\n```\nDKLog(@\"...\"); 普通log\nDKInfoLog(@\"...\"); 包含特殊信息的log\nDKWRANLog(@\"...\"); 警告log\nDKERRLog(@\"...\"); 错误log\n```\n```\n/**\t\n 初始化: 创建Txt的Log文件并写入输出\n \n @param path  文件夹路径,默认Documents\n @param url   上传log地址 当发生崩溃事故的时候就会提示用户是否上传Log到服务器\n @param debug 调试模式 */\n- (void)registerLoggerInPath:(NSString *)path uploadUrlStr:(NSString *)url debug:(BOOL)debug;\neg:\n[[DKSharedLogger registerLoggerInPath:[NSHomeDirectory() stringByAppendingPathComponent:@\"Documents\"] uploadUrlStr:@\"http://192.168.1.91/public/index/Index/hello\" debug:YES];\n```\n\n```\n[DKSharedLogger printLevel:DKLoggerLevelInfo|DKLoggerLevelWARN]; 在控制器只打印Info和Warn等级的Log\n```\n```\n[DKSharedLogger saveLevel:DKLoggerLevelError|DKLoggerLevelInfo]; 在文件中之写入Info和Error等级的Log\n```\n\n```\nDK_VAR_DUMP(arr); 查看对象信息,例如变量arr\n```\n\n长按界面2秒弹出log信息界面\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/1011.png?raw=true)","slug":"DKLogger-iOS日志管理框架","published":1,"updated":"2021-04-12T06:07:04.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog4v000j45n08arj9y1z","content":"<p>用于管理iOS的Log信息的框架</p>\n<span id=\"more\"></span>\n<p>可以用在平时的调试中,另外如果app在用户使用过程中发生一些意外事件或者程序崩溃事件,那我们也可以通过服务器的文件得知问题所在</p>\n<p>特性</p>\n<ul>\n<li>支持四个Log等级 <code>DEBUG</code>,<code>INFO</code>,<code>WARN</code>,<code>ERROR</code></li>\n<li>支持储存Log文件到本地和上传到服务器</li>\n<li>支持自定义打印Log类型和写入Log类型</li>\n<li>支持捕获&amp;发送崩溃信息</li>\n<li>在界面长按2秒可以查看Log信息</li>\n<li>可以获取用户的在App内的查看轨迹(进入了哪些控制器)</li>\n<li>崩溃的时候重启RunLoop,进入ANR状态,不闪退</li>\n<li>支持服务器端同步显示Log信息(建议搭建本地服务器,因为这样子Log发送快)</li>\n</ul>\n<p>使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKLog(@&quot;...&quot;); 普通log</span><br><span class=\"line\">DKInfoLog(@&quot;...&quot;); 包含特殊信息的log</span><br><span class=\"line\">DKWRANLog(@&quot;...&quot;); 警告log</span><br><span class=\"line\">DKERRLog(@&quot;...&quot;); 错误log</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**\t</span><br><span class=\"line\"> 初始化: 创建Txt的Log文件并写入输出</span><br><span class=\"line\"> </span><br><span class=\"line\"> @param path  文件夹路径,默认Documents</span><br><span class=\"line\"> @param url   上传log地址 当发生崩溃事故的时候就会提示用户是否上传Log到服务器</span><br><span class=\"line\"> @param debug 调试模式 *&#x2F;</span><br><span class=\"line\">- (void)registerLoggerInPath:(NSString *)path uploadUrlStr:(NSString *)url debug:(BOOL)debug;</span><br><span class=\"line\">eg:</span><br><span class=\"line\">[[DKSharedLogger registerLoggerInPath:[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] uploadUrlStr:@&quot;http:&#x2F;&#x2F;192.168.1.91&#x2F;public&#x2F;index&#x2F;Index&#x2F;hello&quot; debug:YES];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKSharedLogger printLevel:DKLoggerLevelInfo|DKLoggerLevelWARN]; 在控制器只打印Info和Warn等级的Log</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKSharedLogger saveLevel:DKLoggerLevelError|DKLoggerLevelInfo]; 在文件中之写入Info和Error等级的Log</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DK_VAR_DUMP(arr); 查看对象信息,例如变量arr</span><br></pre></td></tr></table></figure>\n\n<p>长按界面2秒弹出log信息界面</p>\n<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/1011.png?raw=true\"></p>\n","site":{"data":{}},"excerpt":"<p>用于管理iOS的Log信息的框架</p>","more":"<p>可以用在平时的调试中,另外如果app在用户使用过程中发生一些意外事件或者程序崩溃事件,那我们也可以通过服务器的文件得知问题所在</p>\n<p>特性</p>\n<ul>\n<li>支持四个Log等级 <code>DEBUG</code>,<code>INFO</code>,<code>WARN</code>,<code>ERROR</code></li>\n<li>支持储存Log文件到本地和上传到服务器</li>\n<li>支持自定义打印Log类型和写入Log类型</li>\n<li>支持捕获&amp;发送崩溃信息</li>\n<li>在界面长按2秒可以查看Log信息</li>\n<li>可以获取用户的在App内的查看轨迹(进入了哪些控制器)</li>\n<li>崩溃的时候重启RunLoop,进入ANR状态,不闪退</li>\n<li>支持服务器端同步显示Log信息(建议搭建本地服务器,因为这样子Log发送快)</li>\n</ul>\n<p>使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKLog(@&quot;...&quot;); 普通log</span><br><span class=\"line\">DKInfoLog(@&quot;...&quot;); 包含特殊信息的log</span><br><span class=\"line\">DKWRANLog(@&quot;...&quot;); 警告log</span><br><span class=\"line\">DKERRLog(@&quot;...&quot;); 错误log</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**\t</span><br><span class=\"line\"> 初始化: 创建Txt的Log文件并写入输出</span><br><span class=\"line\"> </span><br><span class=\"line\"> @param path  文件夹路径,默认Documents</span><br><span class=\"line\"> @param url   上传log地址 当发生崩溃事故的时候就会提示用户是否上传Log到服务器</span><br><span class=\"line\"> @param debug 调试模式 *&#x2F;</span><br><span class=\"line\">- (void)registerLoggerInPath:(NSString *)path uploadUrlStr:(NSString *)url debug:(BOOL)debug;</span><br><span class=\"line\">eg:</span><br><span class=\"line\">[[DKSharedLogger registerLoggerInPath:[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] uploadUrlStr:@&quot;http:&#x2F;&#x2F;192.168.1.91&#x2F;public&#x2F;index&#x2F;Index&#x2F;hello&quot; debug:YES];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKSharedLogger printLevel:DKLoggerLevelInfo|DKLoggerLevelWARN]; 在控制器只打印Info和Warn等级的Log</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKSharedLogger saveLevel:DKLoggerLevelError|DKLoggerLevelInfo]; 在文件中之写入Info和Error等级的Log</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DK_VAR_DUMP(arr); 查看对象信息,例如变量arr</span><br></pre></td></tr></table></figure>\n\n<p>长按界面2秒弹出log信息界面</p>\n<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/1011.png?raw=true\"></p>"},{"title":"Jenkins上蒲公英插件中update description 无法自动写入commit message问题解决","author":"Arclin","abbrlink":"5fcbb764","date":"2018-05-10T02:46:00.000Z","_content":"花了一天时间解决这个问题，找了好多资料都没找到，最后终于想到了办法。\n<!--more-->\n\n### 背景\n\n在Jenkins上使用蒲公英上传软件安装包有两种方法，一种是使用命令行的方式\n类似下面这种\n\n```\nIPANAME=\"jinkens-myapp\"\nfastlane gym --export_method ad-hoc --output_name ${IPANAME}\n\nMSG=`git log -1 --pretty=%B`\nPASSWORD=123456\ncurl -F \"file=@${IPANAME}\" -F \"uKey=USER_KEY\" -F \"_api_key=API_KEY\" -F \"updateDescription=${MSG}\" -F \"password=${PASSWORD}\" https://qiniu-storage.pgyer.com/apiv1/app/upload\n```\n\n这种方式的话就可以直接通过命令行获得`commit message`作为版本更新说明，但是缺点是无法直接通过环境变量获得上传后的App的各种信息，比如安装包地址，app二维码图片的等等。\n\n第二种方式是通过蒲公英在Jenkins上发布的插件`Upload to pgyer`，优点是上传后的各种App的信息都会被注入到环境变量中，可以在邮件模板中直接调用。缺点是Upload description必须写死为某个值，或者使用某个环境变量，但是Jenkins的Git插件又不提供给你最后一条`commit message`的环境变量。\n\n所以说为了结合两种方式的优点，想出了如下办法解决了。\n\n### 方法\n\n1. 安装插件\t`Environment Injector Plugin`\n2. 构建步骤添加`Execute Shell`，填写\n\t```\n\t# 把commit message写入文件中\n\tMSG=$(git log -1 --pretty=%B)\n\techo \"commitMessage=\"${MSG} > commitMessage.txt\n    ```\n3. 构件步骤中添加`Inject Environment variables`，`Properties File Path`填写`${WORKSPACE}/commitMessage.txt`(也有可能是别的路径，不要写错了)\n4. 最后在蒲公英插件`Upload to pgyer`上`updateDescription`中填写`${commitMessage}`\n\n\n就这样子就可以了，就是把message写到文件中，然后通过文件注入环境变量，然后蒲公英插件再去用就行了。","source":"_posts/Jenkins上蒲公英插件中update-description-无法自动写入commit-message问题解决.md","raw":"title: Jenkins上蒲公英插件中update description 无法自动写入commit message问题解决\nauthor: Arclin\ntags:\n  - Jenkins\ncategories:\n  - Jenkins\nabbrlink: 5fcbb764\ndate: 2018-05-10 10:46:00\n---\n花了一天时间解决这个问题，找了好多资料都没找到，最后终于想到了办法。\n<!--more-->\n\n### 背景\n\n在Jenkins上使用蒲公英上传软件安装包有两种方法，一种是使用命令行的方式\n类似下面这种\n\n```\nIPANAME=\"jinkens-myapp\"\nfastlane gym --export_method ad-hoc --output_name ${IPANAME}\n\nMSG=`git log -1 --pretty=%B`\nPASSWORD=123456\ncurl -F \"file=@${IPANAME}\" -F \"uKey=USER_KEY\" -F \"_api_key=API_KEY\" -F \"updateDescription=${MSG}\" -F \"password=${PASSWORD}\" https://qiniu-storage.pgyer.com/apiv1/app/upload\n```\n\n这种方式的话就可以直接通过命令行获得`commit message`作为版本更新说明，但是缺点是无法直接通过环境变量获得上传后的App的各种信息，比如安装包地址，app二维码图片的等等。\n\n第二种方式是通过蒲公英在Jenkins上发布的插件`Upload to pgyer`，优点是上传后的各种App的信息都会被注入到环境变量中，可以在邮件模板中直接调用。缺点是Upload description必须写死为某个值，或者使用某个环境变量，但是Jenkins的Git插件又不提供给你最后一条`commit message`的环境变量。\n\n所以说为了结合两种方式的优点，想出了如下办法解决了。\n\n### 方法\n\n1. 安装插件\t`Environment Injector Plugin`\n2. 构建步骤添加`Execute Shell`，填写\n\t```\n\t# 把commit message写入文件中\n\tMSG=$(git log -1 --pretty=%B)\n\techo \"commitMessage=\"${MSG} > commitMessage.txt\n    ```\n3. 构件步骤中添加`Inject Environment variables`，`Properties File Path`填写`${WORKSPACE}/commitMessage.txt`(也有可能是别的路径，不要写错了)\n4. 最后在蒲公英插件`Upload to pgyer`上`updateDescription`中填写`${commitMessage}`\n\n\n就这样子就可以了，就是把message写到文件中，然后通过文件注入环境变量，然后蒲公英插件再去用就行了。","slug":"Jenkins上蒲公英插件中update-description-无法自动写入commit-message问题解决","published":1,"updated":"2021-04-12T06:07:04.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog4v000l45n08xpgh24l","content":"<p>花了一天时间解决这个问题，找了好多资料都没找到，最后终于想到了办法。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>在Jenkins上使用蒲公英上传软件安装包有两种方法，一种是使用命令行的方式<br>类似下面这种</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IPANAME&#x3D;&quot;jinkens-myapp&quot;</span><br><span class=\"line\">fastlane gym --export_method ad-hoc --output_name $&#123;IPANAME&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MSG&#x3D;&#96;git log -1 --pretty&#x3D;%B&#96;</span><br><span class=\"line\">PASSWORD&#x3D;123456</span><br><span class=\"line\">curl -F &quot;file&#x3D;@$&#123;IPANAME&#125;&quot; -F &quot;uKey&#x3D;USER_KEY&quot; -F &quot;_api_key&#x3D;API_KEY&quot; -F &quot;updateDescription&#x3D;$&#123;MSG&#125;&quot; -F &quot;password&#x3D;$&#123;PASSWORD&#125;&quot; https:&#x2F;&#x2F;qiniu-storage.pgyer.com&#x2F;apiv1&#x2F;app&#x2F;upload</span><br></pre></td></tr></table></figure>\n\n<p>这种方式的话就可以直接通过命令行获得<code>commit message</code>作为版本更新说明，但是缺点是无法直接通过环境变量获得上传后的App的各种信息，比如安装包地址，app二维码图片的等等。</p>\n<p>第二种方式是通过蒲公英在Jenkins上发布的插件<code>Upload to pgyer</code>，优点是上传后的各种App的信息都会被注入到环境变量中，可以在邮件模板中直接调用。缺点是Upload description必须写死为某个值，或者使用某个环境变量，但是Jenkins的Git插件又不提供给你最后一条<code>commit message</code>的环境变量。</p>\n<p>所以说为了结合两种方式的优点，想出了如下办法解决了。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><ol>\n<li>安装插件    <code>Environment Injector Plugin</code></li>\n<li>构建步骤添加<code>Execute Shell</code>，填写 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 把commit message写入文件中</span><br><span class=\"line\">MSG&#x3D;$(git log -1 --pretty&#x3D;%B)</span><br><span class=\"line\">echo &quot;commitMessage&#x3D;&quot;$&#123;MSG&#125; &gt; commitMessage.txt</span><br></pre></td></tr></table></figure></li>\n<li>构件步骤中添加<code>Inject Environment variables</code>，<code>Properties File Path</code>填写<code>$&#123;WORKSPACE&#125;/commitMessage.txt</code>(也有可能是别的路径，不要写错了)</li>\n<li>最后在蒲公英插件<code>Upload to pgyer</code>上<code>updateDescription</code>中填写<code>$&#123;commitMessage&#125;</code></li>\n</ol>\n<p>就这样子就可以了，就是把message写到文件中，然后通过文件注入环境变量，然后蒲公英插件再去用就行了。</p>\n","site":{"data":{}},"excerpt":"<p>花了一天时间解决这个问题，找了好多资料都没找到，最后终于想到了办法。</p>","more":"<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>在Jenkins上使用蒲公英上传软件安装包有两种方法，一种是使用命令行的方式<br>类似下面这种</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IPANAME&#x3D;&quot;jinkens-myapp&quot;</span><br><span class=\"line\">fastlane gym --export_method ad-hoc --output_name $&#123;IPANAME&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MSG&#x3D;&#96;git log -1 --pretty&#x3D;%B&#96;</span><br><span class=\"line\">PASSWORD&#x3D;123456</span><br><span class=\"line\">curl -F &quot;file&#x3D;@$&#123;IPANAME&#125;&quot; -F &quot;uKey&#x3D;USER_KEY&quot; -F &quot;_api_key&#x3D;API_KEY&quot; -F &quot;updateDescription&#x3D;$&#123;MSG&#125;&quot; -F &quot;password&#x3D;$&#123;PASSWORD&#125;&quot; https:&#x2F;&#x2F;qiniu-storage.pgyer.com&#x2F;apiv1&#x2F;app&#x2F;upload</span><br></pre></td></tr></table></figure>\n\n<p>这种方式的话就可以直接通过命令行获得<code>commit message</code>作为版本更新说明，但是缺点是无法直接通过环境变量获得上传后的App的各种信息，比如安装包地址，app二维码图片的等等。</p>\n<p>第二种方式是通过蒲公英在Jenkins上发布的插件<code>Upload to pgyer</code>，优点是上传后的各种App的信息都会被注入到环境变量中，可以在邮件模板中直接调用。缺点是Upload description必须写死为某个值，或者使用某个环境变量，但是Jenkins的Git插件又不提供给你最后一条<code>commit message</code>的环境变量。</p>\n<p>所以说为了结合两种方式的优点，想出了如下办法解决了。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><ol>\n<li>安装插件    <code>Environment Injector Plugin</code></li>\n<li>构建步骤添加<code>Execute Shell</code>，填写 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 把commit message写入文件中</span><br><span class=\"line\">MSG&#x3D;$(git log -1 --pretty&#x3D;%B)</span><br><span class=\"line\">echo &quot;commitMessage&#x3D;&quot;$&#123;MSG&#125; &gt; commitMessage.txt</span><br></pre></td></tr></table></figure></li>\n<li>构件步骤中添加<code>Inject Environment variables</code>，<code>Properties File Path</code>填写<code>$&#123;WORKSPACE&#125;/commitMessage.txt</code>(也有可能是别的路径，不要写错了)</li>\n<li>最后在蒲公英插件<code>Upload to pgyer</code>上<code>updateDescription</code>中填写<code>$&#123;commitMessage&#125;</code></li>\n</ol>\n<p>就这样子就可以了，就是把message写到文件中，然后通过文件注入环境变量，然后蒲公英插件再去用就行了。</p>"},{"title":"Let’s Encrypt 免费https","author":"Arclin","abbrlink":"feddc8a5","date":"2018-02-18T13:34:00.000Z","_content":"在服务器配置免费的CA证书\n\n<!-- more -->\n\n下载源码\n\n```\ngit clone https://github.com/letsencrypt/letsencrypt\n```\n\n生成证书\n\n```\ncd letsencrypt/\n\n./letsencrypt-auto certonly --standalone --email arclin@dankal.cn -d arclin.me -d g.arclin.me \n```\n\n默认有效期90天\n\n自动续期\n\n```\n./letsencrypt-auto certonly --renew-by-default --email arclin@dankal.cn -d arclin.me -d g.arclin.me\n```\n\n报错及解决\n\n- 报错\nProblem binding to port 443: Could not bind to IPv4 or IPv6.\n\n- 解决\n停止443端口\n比如 关闭ShadowSocks服务(ssserver)  关闭nginx\n\n- 报错 \nFailed authorization procedure. arclin.me (tls-sni-01): urn:acme:error:connection :: The server could not connect to the client to verify the domain :: Connection refused\n\n- 解决\n在DNSPod 绑定 arclin.me域名到本服务器\n\n修改Nginx 配置\n\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    listen 443 ssl http2; #443这里是https的端口  开启http2服务需要安装http_v2_module模块\n    ssl_certificate /etc/letsencrypt/live/arclin.me/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/arclin.me/privkey.pem;\n    resolver 8.8.8.8;\n    location / {\n        google on;\n    }\n  }\n```\n\n重启服务\n\n```\nnginx -c /usr/local/nginx/conf/nginx.conf\nnginx -s reload\nservice nginx restart\n```","source":"_posts/Let’s-Encrypt-免费https.md","raw":"---\ntitle: Let’s Encrypt 免费https\nauthor: Arclin\ntags:\n  - Let's Encrypt\n  - https\ncategories:\n  - Linux\nabbrlink: feddc8a5\ndate: 2018-02-18 21:34:00\n---\n在服务器配置免费的CA证书\n\n<!-- more -->\n\n下载源码\n\n```\ngit clone https://github.com/letsencrypt/letsencrypt\n```\n\n生成证书\n\n```\ncd letsencrypt/\n\n./letsencrypt-auto certonly --standalone --email arclin@dankal.cn -d arclin.me -d g.arclin.me \n```\n\n默认有效期90天\n\n自动续期\n\n```\n./letsencrypt-auto certonly --renew-by-default --email arclin@dankal.cn -d arclin.me -d g.arclin.me\n```\n\n报错及解决\n\n- 报错\nProblem binding to port 443: Could not bind to IPv4 or IPv6.\n\n- 解决\n停止443端口\n比如 关闭ShadowSocks服务(ssserver)  关闭nginx\n\n- 报错 \nFailed authorization procedure. arclin.me (tls-sni-01): urn:acme:error:connection :: The server could not connect to the client to verify the domain :: Connection refused\n\n- 解决\n在DNSPod 绑定 arclin.me域名到本服务器\n\n修改Nginx 配置\n\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    listen 443 ssl http2; #443这里是https的端口  开启http2服务需要安装http_v2_module模块\n    ssl_certificate /etc/letsencrypt/live/arclin.me/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/arclin.me/privkey.pem;\n    resolver 8.8.8.8;\n    location / {\n        google on;\n    }\n  }\n```\n\n重启服务\n\n```\nnginx -c /usr/local/nginx/conf/nginx.conf\nnginx -s reload\nservice nginx restart\n```","slug":"Let’s-Encrypt-免费https","published":1,"updated":"2021-04-12T06:07:04.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog4x000q45n0asmre47m","content":"<p>在服务器配置免费的CA证书</p>\n<span id=\"more\"></span>\n\n<p>下载源码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;letsencrypt&#x2F;letsencrypt</span><br></pre></td></tr></table></figure>\n\n<p>生成证书</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd letsencrypt&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">.&#x2F;letsencrypt-auto certonly --standalone --email arclin@dankal.cn -d arclin.me -d g.arclin.me </span><br></pre></td></tr></table></figure>\n\n<p>默认有效期90天</p>\n<p>自动续期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;letsencrypt-auto certonly --renew-by-default --email arclin@dankal.cn -d arclin.me -d g.arclin.me</span><br></pre></td></tr></table></figure>\n\n<p>报错及解决</p>\n<ul>\n<li><p>报错<br>Problem binding to port 443: Could not bind to IPv4 or IPv6.</p>\n</li>\n<li><p>解决<br>停止443端口<br>比如 关闭ShadowSocks服务(ssserver)  关闭nginx</p>\n</li>\n<li><p>报错<br>Failed authorization procedure. arclin.me (tls-sni-01): urn:acme:error:connection :: The server could not connect to the client to verify the domain :: Connection refused</p>\n</li>\n<li><p>解决<br>在DNSPod 绑定 arclin.me域名到本服务器</p>\n</li>\n</ul>\n<p>修改Nginx 配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    listen 443 ssl http2; #443这里是https的端口  开启http2服务需要安装http_v2_module模块</span><br><span class=\"line\">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;fullchain.pem;</span><br><span class=\"line\">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;privkey.pem;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location &#x2F; &#123;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>重启服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class=\"line\">nginx -s reload</span><br><span class=\"line\">service nginx restart</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>在服务器配置免费的CA证书</p>","more":"<p>下载源码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;letsencrypt&#x2F;letsencrypt</span><br></pre></td></tr></table></figure>\n\n<p>生成证书</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd letsencrypt&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">.&#x2F;letsencrypt-auto certonly --standalone --email arclin@dankal.cn -d arclin.me -d g.arclin.me </span><br></pre></td></tr></table></figure>\n\n<p>默认有效期90天</p>\n<p>自动续期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;letsencrypt-auto certonly --renew-by-default --email arclin@dankal.cn -d arclin.me -d g.arclin.me</span><br></pre></td></tr></table></figure>\n\n<p>报错及解决</p>\n<ul>\n<li><p>报错<br>Problem binding to port 443: Could not bind to IPv4 or IPv6.</p>\n</li>\n<li><p>解决<br>停止443端口<br>比如 关闭ShadowSocks服务(ssserver)  关闭nginx</p>\n</li>\n<li><p>报错<br>Failed authorization procedure. arclin.me (tls-sni-01): urn:acme:error:connection :: The server could not connect to the client to verify the domain :: Connection refused</p>\n</li>\n<li><p>解决<br>在DNSPod 绑定 arclin.me域名到本服务器</p>\n</li>\n</ul>\n<p>修改Nginx 配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    listen 443 ssl http2; #443这里是https的端口  开启http2服务需要安装http_v2_module模块</span><br><span class=\"line\">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;fullchain.pem;</span><br><span class=\"line\">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;privkey.pem;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location &#x2F; &#123;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>重启服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class=\"line\">nginx -s reload</span><br><span class=\"line\">service nginx restart</span><br></pre></td></tr></table></figure>"},{"title":"Nginx 内容替换模块 http_substitutions_filter_module","author":"Arclin","abbrlink":"e35ccdb6","date":"2018-02-18T14:16:00.000Z","_content":"在镜像了某个网站之后,想要改变这个网站上某些元素的显示内容, 这是我们可以使用nginx的一个第三方模块`http_substitutions_filter_module`\n\n<!-- more -->\n\n修改nginx配置文件\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    listen 443 ssl http2;\n    ssl_certificate /etc/letsencrypt/live/arclin.me/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/arclin.me/privkey.pem;\n    resolver 8.8.8.8;\n    location / {\n        subs_filter Google\\s提供 Arclin提供 r;\n        google on;\n    }\n  }\n```","source":"_posts/Nginx-内容替换模块-http-substitutions-filter-module.md","raw":"---\ntitle: Nginx 内容替换模块 http_substitutions_filter_module\nauthor: Arclin\ntags:\n  - nginx\ncategories:\n  - Linux\nabbrlink: e35ccdb6\ndate: 2018-02-18 22:16:00\n---\n在镜像了某个网站之后,想要改变这个网站上某些元素的显示内容, 这是我们可以使用nginx的一个第三方模块`http_substitutions_filter_module`\n\n<!-- more -->\n\n修改nginx配置文件\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    listen 443 ssl http2;\n    ssl_certificate /etc/letsencrypt/live/arclin.me/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/arclin.me/privkey.pem;\n    resolver 8.8.8.8;\n    location / {\n        subs_filter Google\\s提供 Arclin提供 r;\n        google on;\n    }\n  }\n```","slug":"Nginx-内容替换模块-http-substitutions-filter-module","published":1,"updated":"2021-04-12T06:07:04.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog4x000t45n0g3icaq94","content":"<p>在镜像了某个网站之后,想要改变这个网站上某些元素的显示内容, 这是我们可以使用nginx的一个第三方模块<code>http_substitutions_filter_module</code></p>\n<span id=\"more\"></span>\n\n<p>修改nginx配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    listen 443 ssl http2;</span><br><span class=\"line\">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;fullchain.pem;</span><br><span class=\"line\">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;privkey.pem;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location &#x2F; &#123;</span><br><span class=\"line\">        subs_filter Google\\s提供 Arclin提供 r;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>在镜像了某个网站之后,想要改变这个网站上某些元素的显示内容, 这是我们可以使用nginx的一个第三方模块<code>http_substitutions_filter_module</code></p>","more":"<p>修改nginx配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    listen 443 ssl http2;</span><br><span class=\"line\">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;fullchain.pem;</span><br><span class=\"line\">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;privkey.pem;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location &#x2F; &#123;</span><br><span class=\"line\">        subs_filter Google\\s提供 Arclin提供 r;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>"},{"title":"RACCommand使用注意","author":"Arclin","abbrlink":"79533f9e","date":"2016-10-16T16:00:00.000Z","_content":"RACCommand使用注意\n\n<!-- more -->\n\n 1. `signalBlock`必须要返回一个信号，不能传nil. \n 2. 如果不想要传递信号，直接创建空的信号`[RACSignal empty]`;\n 3. RACCommand中信号如果数据传递完，必须调用`[subscriber sendCompleted]`，这时命令才会执行完毕，否则永远处于执行中。\n 4. `RACCommand`需要被强引用，否则接收不到`RACCommand`中的信号，因此RACCommand中的信号是延迟发送的。\n\n- `RACCommand`设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。\n\n \t1. 在RAC开发中，通常会把网络请求封装到`RACCommand`，直接执行某个RACCommand就能发送请求。\n \t2. 当`RACCommand`内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。\n\n- 如何拿到RACCommand中返回信号发出的数据。\n\n \t1. RACCommand有个执行信号源`executionSignals`，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。\n \t2. 订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。\n\n- 监听当前命令是否正在执行`executing`\n- 使用场景,监听按钮点击，网络请求","source":"_posts/RACCommand使用注意.md","raw":"---\ntitle: RACCommand使用注意\nauthor: Arclin\ntags:\n  - iOS\n  - Reactive Cocoa\ncategories:\n  - iOS\nabbrlink: 79533f9e\ndate: 2016-10-17 00:00:00\n---\nRACCommand使用注意\n\n<!-- more -->\n\n 1. `signalBlock`必须要返回一个信号，不能传nil. \n 2. 如果不想要传递信号，直接创建空的信号`[RACSignal empty]`;\n 3. RACCommand中信号如果数据传递完，必须调用`[subscriber sendCompleted]`，这时命令才会执行完毕，否则永远处于执行中。\n 4. `RACCommand`需要被强引用，否则接收不到`RACCommand`中的信号，因此RACCommand中的信号是延迟发送的。\n\n- `RACCommand`设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。\n\n \t1. 在RAC开发中，通常会把网络请求封装到`RACCommand`，直接执行某个RACCommand就能发送请求。\n \t2. 当`RACCommand`内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。\n\n- 如何拿到RACCommand中返回信号发出的数据。\n\n \t1. RACCommand有个执行信号源`executionSignals`，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。\n \t2. 订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。\n\n- 监听当前命令是否正在执行`executing`\n- 使用场景,监听按钮点击，网络请求","slug":"RACCommand使用注意","published":1,"updated":"2021-04-12T06:07:04.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog4y000y45n0b8xwhm24","content":"<p>RACCommand使用注意</p>\n<span id=\"more\"></span>\n\n<ol>\n<li><code>signalBlock</code>必须要返回一个信号，不能传nil. </li>\n<li>如果不想要传递信号，直接创建空的信号<code>[RACSignal empty]</code>;</li>\n<li>RACCommand中信号如果数据传递完，必须调用<code>[subscriber sendCompleted]</code>，这时命令才会执行完毕，否则永远处于执行中。</li>\n<li><code>RACCommand</code>需要被强引用，否则接收不到<code>RACCommand</code>中的信号，因此RACCommand中的信号是延迟发送的。</li>\n</ol>\n<ul>\n<li><p><code>RACCommand</code>设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。</p>\n<ol>\n<li>在RAC开发中，通常会把网络请求封装到<code>RACCommand</code>，直接执行某个RACCommand就能发送请求。</li>\n<li>当<code>RACCommand</code>内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。</li>\n</ol>\n</li>\n<li><p>如何拿到RACCommand中返回信号发出的数据。</p>\n<ol>\n<li>RACCommand有个执行信号源<code>executionSignals</code>，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。</li>\n<li>订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。</li>\n</ol>\n</li>\n<li><p>监听当前命令是否正在执行<code>executing</code></p>\n</li>\n<li><p>使用场景,监听按钮点击，网络请求</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>RACCommand使用注意</p>","more":"<ol>\n<li><code>signalBlock</code>必须要返回一个信号，不能传nil. </li>\n<li>如果不想要传递信号，直接创建空的信号<code>[RACSignal empty]</code>;</li>\n<li>RACCommand中信号如果数据传递完，必须调用<code>[subscriber sendCompleted]</code>，这时命令才会执行完毕，否则永远处于执行中。</li>\n<li><code>RACCommand</code>需要被强引用，否则接收不到<code>RACCommand</code>中的信号，因此RACCommand中的信号是延迟发送的。</li>\n</ol>\n<ul>\n<li><p><code>RACCommand</code>设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。</p>\n<ol>\n<li>在RAC开发中，通常会把网络请求封装到<code>RACCommand</code>，直接执行某个RACCommand就能发送请求。</li>\n<li>当<code>RACCommand</code>内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。</li>\n</ol>\n</li>\n<li><p>如何拿到RACCommand中返回信号发出的数据。</p>\n<ol>\n<li>RACCommand有个执行信号源<code>executionSignals</code>，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。</li>\n<li>订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。</li>\n</ol>\n</li>\n<li><p>监听当前命令是否正在执行<code>executing</code></p>\n</li>\n<li><p>使用场景,监听按钮点击，网络请求</p>\n</li>\n</ul>"},{"title":"Node.js学习笔记","author":"Arclin","abbrlink":"1aafa723","date":"2017-03-05T16:00:00.000Z","_content":"Node.js的学习笔记,持续更新\n\n<!-- more -->\n\n> Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型\n>\n> 事件驱动\n>> 所谓事件驱动，简单地说就是你点什么按钮（即产生什么事件），电脑执行什么操作（即调用什么函数）.当然事件不仅限于用户的操作. 事件驱动的核心自然是事件。从事件角度说，事件驱动程序的基本结构是由一个事件收集器、一个事件发送器和一个_事件处理器组成。\n\n>> 事件收集器专门负责收集所有事件，包括来自用户的（如鼠标、键盘事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。\n事件发送器负责将收集器收集到的事件分发到目标对象中。\n事件处理器做具体的事件响应工作，它往往要到实现阶段才完全确定，因而需要运用虚函数机制（函数名往往取为类似于HandleMsg的一个名字）。对于框架的使用者来说，他们唯一能够看到的是事件处理器。这也是他们所关心的内容。\n\n> 非阻塞式 I/O\n\n>> I/O 即Input/Output 的缩写\n\n>> 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.\n\n>> 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。\n非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。\n\n>>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。\n在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。\n\n## let var const\n\n`let` 允许把变量的作用域限制在块级域中。与 `var` 不同处是：`var` 申明变量要么是全局的，要么是函数级的，而无法是块级的。\n\n`let`的作用域是块，而`var`的作用域是函数\n\n```\n'use strict';\nfor (let i = 0; i < 10; i++) {\n  console.log(i); // 0, 1, 2, 3, 4 ... 9\n}\nconsole.log(i); // i is not defined\nconst这个声明创建一个常量,可以全局或局部的函数声明,不可以被重新赋值.\n```\n\n## Map WeakMap Set WeakSet\n\n### Map\nMap原生提供三个遍历器生成函数和一个遍历方法。\n\n`keys()` 返回键名的遍历器。\n`values()` 返回键值的遍历器。\n`entries()` 返回所有成员的遍历器。\n`forEach()` 遍历Map的所有成员。\n\n```\nvar myMap = new Map();\nmyMap.set(0, \"zero\");\nmyMap.set(1, \"one\");\n \nfor (var key of myMap.keys()) {\n  console.log(key);\n}\n// 0 1\n \nfor (var value of myMap.values()) {\n  console.log(value);\n}\n// zero one\n \nfor (var item of myMap.entries()) {\n  console.log(item[0] + \" = \" + item[1]);\n}\n// 0 = zero 1 = one\n \nmyMap.forEach(function(value, key) {\n  console.log(key + \" = \" + value);\n}, myMap)\n// 0 = zero 1 = one\n```\n\n### WeakMap\nWeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。\nWeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。\nWeakMap只有四个方法可用：get()、set()、has()、delete()。\n\n### Set\n`add(value)` 添加某个值，返回Set结构本身。\n`delete(value)` 删除某个值，返回一个布尔值，表示删除是否成功。\n`has(value)` 返回一个布尔值，表示该值是否为Set的成员。\n`clear()` 清除所有成员，没有返回值。 上面这些属性和方法的实例如下。\n\n```\nvar s = new Set();\ns.add(1).add(2).add(2);\n// 注意2被加入了两次\nconsole.log(s.size); // 2\nconsole.log(s.has(1)); // true\nconsole.log(s.has(2)); // true\nconsole.log(s.has(3)); // false\nconsole.log(s.delete(2));\nconsole.log(s.has(2)); // false\n```\n\nSet的遍历跟Map差不多,但是如果使用`set.entries()`去遍历的话,出来的结果会是像这样子[\"red\", \"red\"] [\"green\", \"green\"] [\"blue\", \"blue\"],包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。\n### WeakSet\nweakSet和WeakMap的道理也差不多,WeakSet的成员只能是对象，而不能是其他类型的值.WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用\nWeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。\n\n```\nvar ws = new WeakSet();\nvar obj = {};\nvar foo = {};\nws.add(obj);\nws.has(foo);    // false\nWeakSet没有size属性，没有办法遍历它的成员。\nws.size // undefined\nws.forEach // undefined\nws.forEach(function(item){ console.log('WeakSet has ' + item)})\n```\n\n```\n// TypeError: undefined is not a function\n```\n## Generator Promise Symbol\n### Generator\nGenerator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。\n\n执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。\n\n```\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\nvar hw = helloWorldGenerator();\nconsole.log(hw.next()); \\\\ { value: 'hello', done: false }\nconsole.log(hw.next()); \\\\ { value: 'world', done: false }\nconsole.log(hw.next()); \\\\ { value: 'ending', done: true }\nconsole.log(hw.next()); \\\\ { value: undefined, done: true }\n```\n\n`yield` 意为’产出’ 是用来定义不同的内部状态,调用next()方法的时候会返回Generator的下一个状态,直到return为止,输出的done中的值表示Generator函数是否已经执行结束.\n\n`yield *` 语句 : 用来在一个Generator中执行另外一个Generator函数\n\n```\nfunction* anotherGenerator(i) {\n  yield i + 1;\n  yield i + 2;\n  yield i + 3;\n}\nfunction* generator(i){\n  yield i;\n  yield* anotherGenerator(i);\n  yield i + 10;\n}\nvar gen = generator(10);\nconsole.log(gen.next().value); // 10\nconsole.log(gen.next().value); // 11\nconsole.log(gen.next().value); // 12\nconsole.log(gen.next().value); // 13\nconsole.log(gen.next().value); // 20\n```\n运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。\n\n### Promise\nPromise 是一个构造函数\n\n```\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\nPromise函数自带两个参数: `resolve`意为返回一个成功的回调,`reject`意为返回一个错误的回调\n然后订阅回调的方法如下\n\n```\npromise.then(function(value) {\n  // success\n}, function(value) {\n  // failure\n});\n```\n\nPS: 这个函数很像OC的block方法,上面的函数就类似OC的如下写法\n\n```\n- (void)promise:(void(^)(id success))resolve failure:(void(^)(id failure))reject {\n\tif(...){\n\t\tresolve(resolveValue);\n\t}else {\n\t\treject(rejectValue);\n\t}\n} \n\n//订阅\n[self promise:^(id success){\n\tNSLog(success);\n} failure:^(id failure){\n\tNSLog(failure);\n}];\n// 纯脑补,也不知道有没有写对\n```\n\n#### catch() 方法\n专门用来捕获异常的回调,会捕获到`then()`的第二个参数的回调\n\n如果在`then()`中使用了throw xxx;语句,那么也会走`catch()`回调\n\n`catch()`和`then()`方法都会返回Promise对象,所以可以链式调用\n\n```\npromise.then(function(value) {\n    console.log(value);      \n},null).catch(function(value){\n\tconsole.log(value);\n});\n```\n\nOR\n\n```\np1.then(function(value) {\n  console.log(value); // \"成功!\"\n  throw \"哦，不!\";\n}).catch(function(e) {\n  console.log(e); // \"哦，不!\"\n});\n```\n\n你还可以`then()`完再`then()`\n\n```\nvar p2 = new Promise(function(resolve, reject) {\n  resolve(1);\n});\n\np2.then(function(value) {\n  console.log(value); // 1\n  return value + 1;\n}).then(function(value) {\n  console.log(value); // 2\n});\n```\n#### all() 方法\n\nPromise.all方法用于将多个Promise实例，包装成一个新的Promise实例。\n\n```\nvar p = Promise.all([p1,p2,p3]);\n```\n\n只要有一个reject了,那么p就会抛出失败的回调,只有全部都resolve了,才会抛出成功的回调\n\n#### race() 方法\n顾名思义 赛跑\n\n同样是来绑定多个Promise实例,不同的是谁先返回就走谁的回调,如果p1五秒后发失败回调,p2一秒后发成功回调,那么Promise.race([p1, p2])就等于p2.\n\n```\nPromise.race([p1, p2]).then(function(value) {\n  console.log(value); // \"two\"\n  // Both resolve, but p2 is faster\n});\n```\n\n### Symbol\n符号\n\n用Symbol生成的对象,绝对不会重复!!!\n\n```\nvar s1 = Symbol(\"foo\");\nvar s2 = Symbol(\"foo\");\nconsole.log(s1 === s2); // false\ngetOwnPropertySymbols()\n```\n\n这个方法可以获得对象的所有Symbol类型的成员属性名\n\n```\nvar obj = {};\nvar a = Symbol('a');\nvar b = Symbol('b');\n \nobj[a] = 'Hello';\nobj[b] = 'World';\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\nconsole.log(objectSymbols);\n// [Symbol(a), Symbol(b)]\n```\n\n#### Symbol.for()\n这个方法用来搜索之前有没有定义过某个Symbol名,如果有的话就返回值没有的话就就新建一个Symbol,有种取缓存的感觉\n\n```\nvar s1 = Symbol.for('foo'); // 定义一下\nvar s2 = Symbol.for('foo'); // 取出之前定义的值\nconsole.log(s1 === s2); // true\nSymbol.keyFor()\n跟上面的是相反的,通过值来取键\n\nvar s1 = Symbol.for(\"foo\");\nSymbol.keyFor(s1) // \"foo\"\n \nvar s2 = Symbol(\"foo\");\nSymbol.keyFor(s2) // undefined\n```\n\n## 箭头函数\n其实就是简写方法而已\n\n```\nvar  f = function(v1,v2) {\n\treturn v1+v2;\n}\n```\n\n等同于\n\n```\nvar f = (v1,v2) => v1+v2;\n```\n\n### 注意事项\n\n函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。\n不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。\n不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用`Rest`参数代替。\n不可以使用`yield`命令，因此箭头函数不能用作Generator函数。\n\n## 网络请求\n\n### 方式一 使用 http.request()\n\n```\nvar http = require('http');  \n  \nvar qs = require('querystring');  \n  \nvar data = {  \n    a: 123,  \n    time: new Date().getTime()};//这是需要提交的数据  \n    \nvar content = qs.stringify(data);   \nvar options = {  \n    hostname: '127.0.0.1',  \n    port: 10086,  \n    path: '/pay/pay_callback?' + content,  \n    method: 'GET'  \n};  \n  \nvar req = http.request(options, function (res) {  \n    console.log('STATUS: ' + res.statusCode);  \n    console.log('HEADERS: ' + JSON.stringify(res.headers));  \n    res.setEncoding('utf8');  \n    res.on('data', function (chunk) {  \n        console.log('BODY: ' + chunk);  \n    });  \n});  \n  \nreq.on('error', function (e) {  \n    console.log('problem with request: ' + e.message);  \n});  \n  \nreq.end();\n```\n\n### 方式二 使用 http.get() 发送GET请求\n\n```\nvar httpRequest = http.get('http://localhost:8088/tempFile/LocalData.json',function(request,response){\n      var html='';\n      request.on('data',function(data){\n        \thtml+=data;\n      });\n      request.on('end',function(){\n\t\t\tconsole.log(html);\n      });\n  });\n```\n\n> 学习资料来自:[http://www.hubwiz.com](http://www.hubwiz.com) 等","source":"_posts/Node-js学习笔记.md","raw":"---\ntitle: Node.js学习笔记\nauthor: Arclin\ntags:\n  - Node.js\ncategories:\n  - Node.js\nabbrlink: 1aafa723\ndate: 2017-03-06 00:00:00\n---\nNode.js的学习笔记,持续更新\n\n<!-- more -->\n\n> Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型\n>\n> 事件驱动\n>> 所谓事件驱动，简单地说就是你点什么按钮（即产生什么事件），电脑执行什么操作（即调用什么函数）.当然事件不仅限于用户的操作. 事件驱动的核心自然是事件。从事件角度说，事件驱动程序的基本结构是由一个事件收集器、一个事件发送器和一个_事件处理器组成。\n\n>> 事件收集器专门负责收集所有事件，包括来自用户的（如鼠标、键盘事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。\n事件发送器负责将收集器收集到的事件分发到目标对象中。\n事件处理器做具体的事件响应工作，它往往要到实现阶段才完全确定，因而需要运用虚函数机制（函数名往往取为类似于HandleMsg的一个名字）。对于框架的使用者来说，他们唯一能够看到的是事件处理器。这也是他们所关心的内容。\n\n> 非阻塞式 I/O\n\n>> I/O 即Input/Output 的缩写\n\n>> 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.\n\n>> 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。\n非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。\n\n>>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。\n在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。\n\n## let var const\n\n`let` 允许把变量的作用域限制在块级域中。与 `var` 不同处是：`var` 申明变量要么是全局的，要么是函数级的，而无法是块级的。\n\n`let`的作用域是块，而`var`的作用域是函数\n\n```\n'use strict';\nfor (let i = 0; i < 10; i++) {\n  console.log(i); // 0, 1, 2, 3, 4 ... 9\n}\nconsole.log(i); // i is not defined\nconst这个声明创建一个常量,可以全局或局部的函数声明,不可以被重新赋值.\n```\n\n## Map WeakMap Set WeakSet\n\n### Map\nMap原生提供三个遍历器生成函数和一个遍历方法。\n\n`keys()` 返回键名的遍历器。\n`values()` 返回键值的遍历器。\n`entries()` 返回所有成员的遍历器。\n`forEach()` 遍历Map的所有成员。\n\n```\nvar myMap = new Map();\nmyMap.set(0, \"zero\");\nmyMap.set(1, \"one\");\n \nfor (var key of myMap.keys()) {\n  console.log(key);\n}\n// 0 1\n \nfor (var value of myMap.values()) {\n  console.log(value);\n}\n// zero one\n \nfor (var item of myMap.entries()) {\n  console.log(item[0] + \" = \" + item[1]);\n}\n// 0 = zero 1 = one\n \nmyMap.forEach(function(value, key) {\n  console.log(key + \" = \" + value);\n}, myMap)\n// 0 = zero 1 = one\n```\n\n### WeakMap\nWeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。\nWeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。\nWeakMap只有四个方法可用：get()、set()、has()、delete()。\n\n### Set\n`add(value)` 添加某个值，返回Set结构本身。\n`delete(value)` 删除某个值，返回一个布尔值，表示删除是否成功。\n`has(value)` 返回一个布尔值，表示该值是否为Set的成员。\n`clear()` 清除所有成员，没有返回值。 上面这些属性和方法的实例如下。\n\n```\nvar s = new Set();\ns.add(1).add(2).add(2);\n// 注意2被加入了两次\nconsole.log(s.size); // 2\nconsole.log(s.has(1)); // true\nconsole.log(s.has(2)); // true\nconsole.log(s.has(3)); // false\nconsole.log(s.delete(2));\nconsole.log(s.has(2)); // false\n```\n\nSet的遍历跟Map差不多,但是如果使用`set.entries()`去遍历的话,出来的结果会是像这样子[\"red\", \"red\"] [\"green\", \"green\"] [\"blue\", \"blue\"],包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。\n### WeakSet\nweakSet和WeakMap的道理也差不多,WeakSet的成员只能是对象，而不能是其他类型的值.WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用\nWeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。\n\n```\nvar ws = new WeakSet();\nvar obj = {};\nvar foo = {};\nws.add(obj);\nws.has(foo);    // false\nWeakSet没有size属性，没有办法遍历它的成员。\nws.size // undefined\nws.forEach // undefined\nws.forEach(function(item){ console.log('WeakSet has ' + item)})\n```\n\n```\n// TypeError: undefined is not a function\n```\n## Generator Promise Symbol\n### Generator\nGenerator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。\n\n执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。\n\n```\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\nvar hw = helloWorldGenerator();\nconsole.log(hw.next()); \\\\ { value: 'hello', done: false }\nconsole.log(hw.next()); \\\\ { value: 'world', done: false }\nconsole.log(hw.next()); \\\\ { value: 'ending', done: true }\nconsole.log(hw.next()); \\\\ { value: undefined, done: true }\n```\n\n`yield` 意为’产出’ 是用来定义不同的内部状态,调用next()方法的时候会返回Generator的下一个状态,直到return为止,输出的done中的值表示Generator函数是否已经执行结束.\n\n`yield *` 语句 : 用来在一个Generator中执行另外一个Generator函数\n\n```\nfunction* anotherGenerator(i) {\n  yield i + 1;\n  yield i + 2;\n  yield i + 3;\n}\nfunction* generator(i){\n  yield i;\n  yield* anotherGenerator(i);\n  yield i + 10;\n}\nvar gen = generator(10);\nconsole.log(gen.next().value); // 10\nconsole.log(gen.next().value); // 11\nconsole.log(gen.next().value); // 12\nconsole.log(gen.next().value); // 13\nconsole.log(gen.next().value); // 20\n```\n运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。\n\n### Promise\nPromise 是一个构造函数\n\n```\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\nPromise函数自带两个参数: `resolve`意为返回一个成功的回调,`reject`意为返回一个错误的回调\n然后订阅回调的方法如下\n\n```\npromise.then(function(value) {\n  // success\n}, function(value) {\n  // failure\n});\n```\n\nPS: 这个函数很像OC的block方法,上面的函数就类似OC的如下写法\n\n```\n- (void)promise:(void(^)(id success))resolve failure:(void(^)(id failure))reject {\n\tif(...){\n\t\tresolve(resolveValue);\n\t}else {\n\t\treject(rejectValue);\n\t}\n} \n\n//订阅\n[self promise:^(id success){\n\tNSLog(success);\n} failure:^(id failure){\n\tNSLog(failure);\n}];\n// 纯脑补,也不知道有没有写对\n```\n\n#### catch() 方法\n专门用来捕获异常的回调,会捕获到`then()`的第二个参数的回调\n\n如果在`then()`中使用了throw xxx;语句,那么也会走`catch()`回调\n\n`catch()`和`then()`方法都会返回Promise对象,所以可以链式调用\n\n```\npromise.then(function(value) {\n    console.log(value);      \n},null).catch(function(value){\n\tconsole.log(value);\n});\n```\n\nOR\n\n```\np1.then(function(value) {\n  console.log(value); // \"成功!\"\n  throw \"哦，不!\";\n}).catch(function(e) {\n  console.log(e); // \"哦，不!\"\n});\n```\n\n你还可以`then()`完再`then()`\n\n```\nvar p2 = new Promise(function(resolve, reject) {\n  resolve(1);\n});\n\np2.then(function(value) {\n  console.log(value); // 1\n  return value + 1;\n}).then(function(value) {\n  console.log(value); // 2\n});\n```\n#### all() 方法\n\nPromise.all方法用于将多个Promise实例，包装成一个新的Promise实例。\n\n```\nvar p = Promise.all([p1,p2,p3]);\n```\n\n只要有一个reject了,那么p就会抛出失败的回调,只有全部都resolve了,才会抛出成功的回调\n\n#### race() 方法\n顾名思义 赛跑\n\n同样是来绑定多个Promise实例,不同的是谁先返回就走谁的回调,如果p1五秒后发失败回调,p2一秒后发成功回调,那么Promise.race([p1, p2])就等于p2.\n\n```\nPromise.race([p1, p2]).then(function(value) {\n  console.log(value); // \"two\"\n  // Both resolve, but p2 is faster\n});\n```\n\n### Symbol\n符号\n\n用Symbol生成的对象,绝对不会重复!!!\n\n```\nvar s1 = Symbol(\"foo\");\nvar s2 = Symbol(\"foo\");\nconsole.log(s1 === s2); // false\ngetOwnPropertySymbols()\n```\n\n这个方法可以获得对象的所有Symbol类型的成员属性名\n\n```\nvar obj = {};\nvar a = Symbol('a');\nvar b = Symbol('b');\n \nobj[a] = 'Hello';\nobj[b] = 'World';\nvar objectSymbols = Object.getOwnPropertySymbols(obj);\nconsole.log(objectSymbols);\n// [Symbol(a), Symbol(b)]\n```\n\n#### Symbol.for()\n这个方法用来搜索之前有没有定义过某个Symbol名,如果有的话就返回值没有的话就就新建一个Symbol,有种取缓存的感觉\n\n```\nvar s1 = Symbol.for('foo'); // 定义一下\nvar s2 = Symbol.for('foo'); // 取出之前定义的值\nconsole.log(s1 === s2); // true\nSymbol.keyFor()\n跟上面的是相反的,通过值来取键\n\nvar s1 = Symbol.for(\"foo\");\nSymbol.keyFor(s1) // \"foo\"\n \nvar s2 = Symbol(\"foo\");\nSymbol.keyFor(s2) // undefined\n```\n\n## 箭头函数\n其实就是简写方法而已\n\n```\nvar  f = function(v1,v2) {\n\treturn v1+v2;\n}\n```\n\n等同于\n\n```\nvar f = (v1,v2) => v1+v2;\n```\n\n### 注意事项\n\n函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。\n不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。\n不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用`Rest`参数代替。\n不可以使用`yield`命令，因此箭头函数不能用作Generator函数。\n\n## 网络请求\n\n### 方式一 使用 http.request()\n\n```\nvar http = require('http');  \n  \nvar qs = require('querystring');  \n  \nvar data = {  \n    a: 123,  \n    time: new Date().getTime()};//这是需要提交的数据  \n    \nvar content = qs.stringify(data);   \nvar options = {  \n    hostname: '127.0.0.1',  \n    port: 10086,  \n    path: '/pay/pay_callback?' + content,  \n    method: 'GET'  \n};  \n  \nvar req = http.request(options, function (res) {  \n    console.log('STATUS: ' + res.statusCode);  \n    console.log('HEADERS: ' + JSON.stringify(res.headers));  \n    res.setEncoding('utf8');  \n    res.on('data', function (chunk) {  \n        console.log('BODY: ' + chunk);  \n    });  \n});  \n  \nreq.on('error', function (e) {  \n    console.log('problem with request: ' + e.message);  \n});  \n  \nreq.end();\n```\n\n### 方式二 使用 http.get() 发送GET请求\n\n```\nvar httpRequest = http.get('http://localhost:8088/tempFile/LocalData.json',function(request,response){\n      var html='';\n      request.on('data',function(data){\n        \thtml+=data;\n      });\n      request.on('end',function(){\n\t\t\tconsole.log(html);\n      });\n  });\n```\n\n> 学习资料来自:[http://www.hubwiz.com](http://www.hubwiz.com) 等","slug":"Node-js学习笔记","published":1,"updated":"2021-04-12T06:07:04.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog4z001145n0ccw556ro","content":"<p>Node.js的学习笔记,持续更新</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型</p>\n<p>事件驱动</p>\n<blockquote>\n<p>所谓事件驱动，简单地说就是你点什么按钮（即产生什么事件），电脑执行什么操作（即调用什么函数）.当然事件不仅限于用户的操作. 事件驱动的核心自然是事件。从事件角度说，事件驱动程序的基本结构是由一个事件收集器、一个事件发送器和一个_事件处理器组成。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>事件收集器专门负责收集所有事件，包括来自用户的（如鼠标、键盘事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。<br>事件发送器负责将收集器收集到的事件分发到目标对象中。<br>事件处理器做具体的事件响应工作，它往往要到实现阶段才完全确定，因而需要运用虚函数机制（函数名往往取为类似于HandleMsg的一个名字）。对于框架的使用者来说，他们唯一能够看到的是事件处理器。这也是他们所关心的内容。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>非阻塞式 I/O</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>I/O 即Input/Output 的缩写</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>\n</blockquote>\n</blockquote>\n<h2 id=\"let-var-const\"><a href=\"#let-var-const\" class=\"headerlink\" title=\"let var const\"></a>let var const</h2><p><code>let</code> 允许把变量的作用域限制在块级域中。与 <code>var</code> 不同处是：<code>var</code> 申明变量要么是全局的，要么是函数级的，而无法是块级的。</p>\n<p><code>let</code>的作用域是块，而<code>var</code>的作用域是函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;use strict&#39;;</span><br><span class=\"line\">for (let i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">  console.log(i); &#x2F;&#x2F; 0, 1, 2, 3, 4 ... 9</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(i); &#x2F;&#x2F; i is not defined</span><br><span class=\"line\">const这个声明创建一个常量,可以全局或局部的函数声明,不可以被重新赋值.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Map-WeakMap-Set-WeakSet\"><a href=\"#Map-WeakMap-Set-WeakSet\" class=\"headerlink\" title=\"Map WeakMap Set WeakSet\"></a>Map WeakMap Set WeakSet</h2><h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>Map原生提供三个遍历器生成函数和一个遍历方法。</p>\n<p><code>keys()</code> 返回键名的遍历器。<br><code>values()</code> 返回键值的遍历器。<br><code>entries()</code> 返回所有成员的遍历器。<br><code>forEach()</code> 遍历Map的所有成员。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myMap &#x3D; new Map();</span><br><span class=\"line\">myMap.set(0, &quot;zero&quot;);</span><br><span class=\"line\">myMap.set(1, &quot;one&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var key of myMap.keys()) &#123;</span><br><span class=\"line\">  console.log(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 0 1</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var value of myMap.values()) &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; zero one</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var item of myMap.entries()) &#123;</span><br><span class=\"line\">  console.log(item[0] + &quot; &#x3D; &quot; + item[1]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 0 &#x3D; zero 1 &#x3D; one</span><br><span class=\"line\"> </span><br><span class=\"line\">myMap.forEach(function(value, key) &#123;</span><br><span class=\"line\">  console.log(key + &quot; &#x3D; &quot; + value);</span><br><span class=\"line\">&#125;, myMap)</span><br><span class=\"line\">&#x2F;&#x2F; 0 &#x3D; zero 1 &#x3D; one</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h3><p>WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。<br>WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。<br>WeakMap只有四个方法可用：get()、set()、has()、delete()。</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p><code>add(value)</code> 添加某个值，返回Set结构本身。<br><code>delete(value)</code> 删除某个值，返回一个布尔值，表示删除是否成功。<br><code>has(value)</code> 返回一个布尔值，表示该值是否为Set的成员。<br><code>clear()</code> 清除所有成员，没有返回值。 上面这些属性和方法的实例如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s &#x3D; new Set();</span><br><span class=\"line\">s.add(1).add(2).add(2);</span><br><span class=\"line\">&#x2F;&#x2F; 注意2被加入了两次</span><br><span class=\"line\">console.log(s.size); &#x2F;&#x2F; 2</span><br><span class=\"line\">console.log(s.has(1)); &#x2F;&#x2F; true</span><br><span class=\"line\">console.log(s.has(2)); &#x2F;&#x2F; true</span><br><span class=\"line\">console.log(s.has(3)); &#x2F;&#x2F; false</span><br><span class=\"line\">console.log(s.delete(2));</span><br><span class=\"line\">console.log(s.has(2)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>\n\n<p>Set的遍历跟Map差不多,但是如果使用<code>set.entries()</code>去遍历的话,出来的结果会是像这样子[“red”, “red”] [“green”, “green”] [“blue”, “blue”],包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p>weakSet和WeakMap的道理也差不多,WeakSet的成员只能是对象，而不能是其他类型的值.WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用<br>WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ws &#x3D; new WeakSet();</span><br><span class=\"line\">var obj &#x3D; &#123;&#125;;</span><br><span class=\"line\">var foo &#x3D; &#123;&#125;;</span><br><span class=\"line\">ws.add(obj);</span><br><span class=\"line\">ws.has(foo);    &#x2F;&#x2F; false</span><br><span class=\"line\">WeakSet没有size属性，没有办法遍历它的成员。</span><br><span class=\"line\">ws.size &#x2F;&#x2F; undefined</span><br><span class=\"line\">ws.forEach &#x2F;&#x2F; undefined</span><br><span class=\"line\">ws.forEach(function(item)&#123; console.log(&#39;WeakSet has &#39; + item)&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; TypeError: undefined is not a function</span><br></pre></td></tr></table></figure>\n<h2 id=\"Generator-Promise-Symbol\"><a href=\"#Generator-Promise-Symbol\" class=\"headerlink\" title=\"Generator Promise Symbol\"></a>Generator Promise Symbol</h2><h3 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h3><p>Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。</p>\n<p>执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* helloWorldGenerator() &#123;</span><br><span class=\"line\">  yield &#39;hello&#39;;</span><br><span class=\"line\">  yield &#39;world&#39;;</span><br><span class=\"line\">  return &#39;ending&#39;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var hw &#x3D; helloWorldGenerator();</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &#39;hello&#39;, done: false &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &#39;world&#39;, done: false &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &#39;ending&#39;, done: true &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>yield</code> 意为’产出’ 是用来定义不同的内部状态,调用next()方法的时候会返回Generator的下一个状态,直到return为止,输出的done中的值表示Generator函数是否已经执行结束.</p>\n<p><code>yield *</code> 语句 : 用来在一个Generator中执行另外一个Generator函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* anotherGenerator(i) &#123;</span><br><span class=\"line\">  yield i + 1;</span><br><span class=\"line\">  yield i + 2;</span><br><span class=\"line\">  yield i + 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function* generator(i)&#123;</span><br><span class=\"line\">  yield i;</span><br><span class=\"line\">  yield* anotherGenerator(i);</span><br><span class=\"line\">  yield i + 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var gen &#x3D; generator(10);</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 10</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 11</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 12</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 13</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 20</span><br></pre></td></tr></table></figure>\n<p>运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。</p>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>Promise 是一个构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ... some code</span><br><span class=\"line\">  if (&#x2F;* 异步操作成功 *&#x2F;)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>Promise函数自带两个参数: <code>resolve</code>意为返回一个成功的回调,<code>reject</code>意为返回一个错误的回调<br>然后订阅回调的方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(function(value) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; success</span><br><span class=\"line\">&#125;, function(value) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; failure</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>PS: 这个函数很像OC的block方法,上面的函数就类似OC的如下写法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)promise:(void(^)(id success))resolve failure:(void(^)(id failure))reject &#123;</span><br><span class=\"line\">\tif(...)&#123;</span><br><span class=\"line\">\t\tresolve(resolveValue);</span><br><span class=\"line\">\t&#125;else &#123;</span><br><span class=\"line\">\t\treject(rejectValue);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;订阅</span><br><span class=\"line\">[self promise:^(id success)&#123;</span><br><span class=\"line\">\tNSLog(success);</span><br><span class=\"line\">&#125; failure:^(id failure)&#123;</span><br><span class=\"line\">\tNSLog(failure);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">&#x2F;&#x2F; 纯脑补,也不知道有没有写对</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"catch-方法\"><a href=\"#catch-方法\" class=\"headerlink\" title=\"catch() 方法\"></a>catch() 方法</h4><p>专门用来捕获异常的回调,会捕获到<code>then()</code>的第二个参数的回调</p>\n<p>如果在<code>then()</code>中使用了throw xxx;语句,那么也会走<code>catch()</code>回调</p>\n<p><code>catch()</code>和<code>then()</code>方法都会返回Promise对象,所以可以链式调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(function(value) &#123;</span><br><span class=\"line\">    console.log(value);      </span><br><span class=\"line\">&#125;,null).catch(function(value)&#123;</span><br><span class=\"line\">\tconsole.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>OR</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p1.then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); &#x2F;&#x2F; &quot;成功!&quot;</span><br><span class=\"line\">  throw &quot;哦，不!&quot;;</span><br><span class=\"line\">&#125;).catch(function(e) &#123;</span><br><span class=\"line\">  console.log(e); &#x2F;&#x2F; &quot;哦，不!&quot;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>你还可以<code>then()</code>完再<code>then()</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p2 &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">  resolve(1);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p2.then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); &#x2F;&#x2F; 1</span><br><span class=\"line\">  return value + 1;</span><br><span class=\"line\">&#125;).then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); &#x2F;&#x2F; 2</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"all-方法\"><a href=\"#all-方法\" class=\"headerlink\" title=\"all() 方法\"></a>all() 方法</h4><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p &#x3D; Promise.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>\n\n<p>只要有一个reject了,那么p就会抛出失败的回调,只有全部都resolve了,才会抛出成功的回调</p>\n<h4 id=\"race-方法\"><a href=\"#race-方法\" class=\"headerlink\" title=\"race() 方法\"></a>race() 方法</h4><p>顾名思义 赛跑</p>\n<p>同样是来绑定多个Promise实例,不同的是谁先返回就走谁的回调,如果p1五秒后发失败回调,p2一秒后发成功回调,那么Promise.race([p1, p2])就等于p2.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.race([p1, p2]).then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); &#x2F;&#x2F; &quot;two&quot;</span><br><span class=\"line\">  &#x2F;&#x2F; Both resolve, but p2 is faster</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h3><p>符号</p>\n<p>用Symbol生成的对象,绝对不会重复!!!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class=\"line\">var s2 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class=\"line\">console.log(s1 &#x3D;&#x3D;&#x3D; s2); &#x2F;&#x2F; false</span><br><span class=\"line\">getOwnPropertySymbols()</span><br></pre></td></tr></table></figure>\n\n<p>这个方法可以获得对象的所有Symbol类型的成员属性名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj &#x3D; &#123;&#125;;</span><br><span class=\"line\">var a &#x3D; Symbol(&#39;a&#39;);</span><br><span class=\"line\">var b &#x3D; Symbol(&#39;b&#39;);</span><br><span class=\"line\"> </span><br><span class=\"line\">obj[a] &#x3D; &#39;Hello&#39;;</span><br><span class=\"line\">obj[b] &#x3D; &#39;World&#39;;</span><br><span class=\"line\">var objectSymbols &#x3D; Object.getOwnPropertySymbols(obj);</span><br><span class=\"line\">console.log(objectSymbols);</span><br><span class=\"line\">&#x2F;&#x2F; [Symbol(a), Symbol(b)]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Symbol-for\"><a href=\"#Symbol-for\" class=\"headerlink\" title=\"Symbol.for()\"></a>Symbol.for()</h4><p>这个方法用来搜索之前有没有定义过某个Symbol名,如果有的话就返回值没有的话就就新建一个Symbol,有种取缓存的感觉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1 &#x3D; Symbol.for(&#39;foo&#39;); &#x2F;&#x2F; 定义一下</span><br><span class=\"line\">var s2 &#x3D; Symbol.for(&#39;foo&#39;); &#x2F;&#x2F; 取出之前定义的值</span><br><span class=\"line\">console.log(s1 &#x3D;&#x3D;&#x3D; s2); &#x2F;&#x2F; true</span><br><span class=\"line\">Symbol.keyFor()</span><br><span class=\"line\">跟上面的是相反的,通过值来取键</span><br><span class=\"line\"></span><br><span class=\"line\">var s1 &#x3D; Symbol.for(&quot;foo&quot;);</span><br><span class=\"line\">Symbol.keyFor(s1) &#x2F;&#x2F; &quot;foo&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">var s2 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class=\"line\">Symbol.keyFor(s2) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>其实就是简写方法而已</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var  f &#x3D; function(v1,v2) &#123;</span><br><span class=\"line\">\treturn v1+v2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; (v1,v2) &#x3D;&gt; v1+v2;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。<br>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。<br>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用<code>Rest</code>参数代替。<br>不可以使用<code>yield</code>命令，因此箭头函数不能用作Generator函数。</p>\n<h2 id=\"网络请求\"><a href=\"#网络请求\" class=\"headerlink\" title=\"网络请求\"></a>网络请求</h2><h3 id=\"方式一-使用-http-request\"><a href=\"#方式一-使用-http-request\" class=\"headerlink\" title=\"方式一 使用 http.request()\"></a>方式一 使用 http.request()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var http &#x3D; require(&#39;http&#39;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">var qs &#x3D; require(&#39;querystring&#39;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">var data &#x3D; &#123;  </span><br><span class=\"line\">    a: 123,  </span><br><span class=\"line\">    time: new Date().getTime()&#125;;&#x2F;&#x2F;这是需要提交的数据  </span><br><span class=\"line\">    </span><br><span class=\"line\">var content &#x3D; qs.stringify(data);   </span><br><span class=\"line\">var options &#x3D; &#123;  </span><br><span class=\"line\">    hostname: &#39;127.0.0.1&#39;,  </span><br><span class=\"line\">    port: 10086,  </span><br><span class=\"line\">    path: &#39;&#x2F;pay&#x2F;pay_callback?&#39; + content,  </span><br><span class=\"line\">    method: &#39;GET&#39;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">var req &#x3D; http.request(options, function (res) &#123;  </span><br><span class=\"line\">    console.log(&#39;STATUS: &#39; + res.statusCode);  </span><br><span class=\"line\">    console.log(&#39;HEADERS: &#39; + JSON.stringify(res.headers));  </span><br><span class=\"line\">    res.setEncoding(&#39;utf8&#39;);  </span><br><span class=\"line\">    res.on(&#39;data&#39;, function (chunk) &#123;  </span><br><span class=\"line\">        console.log(&#39;BODY: &#39; + chunk);  </span><br><span class=\"line\">    &#125;);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">req.on(&#39;error&#39;, function (e) &#123;  </span><br><span class=\"line\">    console.log(&#39;problem with request: &#39; + e.message);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">req.end();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方式二-使用-http-get-发送GET请求\"><a href=\"#方式二-使用-http-get-发送GET请求\" class=\"headerlink\" title=\"方式二 使用 http.get() 发送GET请求\"></a>方式二 使用 http.get() 发送GET请求</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var httpRequest &#x3D; http.get(&#39;http:&#x2F;&#x2F;localhost:8088&#x2F;tempFile&#x2F;LocalData.json&#39;,function(request,response)&#123;</span><br><span class=\"line\">      var html&#x3D;&#39;&#39;;</span><br><span class=\"line\">      request.on(&#39;data&#39;,function(data)&#123;</span><br><span class=\"line\">        \thtml+&#x3D;data;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      request.on(&#39;end&#39;,function()&#123;</span><br><span class=\"line\">\t\t\tconsole.log(html);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>学习资料来自:<a href=\"http://www.hubwiz.com/\">http://www.hubwiz.com</a> 等</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>Node.js的学习笔记,持续更新</p>","more":"<blockquote>\n<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型</p>\n<p>事件驱动</p>\n<blockquote>\n<p>所谓事件驱动，简单地说就是你点什么按钮（即产生什么事件），电脑执行什么操作（即调用什么函数）.当然事件不仅限于用户的操作. 事件驱动的核心自然是事件。从事件角度说，事件驱动程序的基本结构是由一个事件收集器、一个事件发送器和一个_事件处理器组成。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>事件收集器专门负责收集所有事件，包括来自用户的（如鼠标、键盘事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。<br>事件发送器负责将收集器收集到的事件分发到目标对象中。<br>事件处理器做具体的事件响应工作，它往往要到实现阶段才完全确定，因而需要运用虚函数机制（函数名往往取为类似于HandleMsg的一个名字）。对于框架的使用者来说，他们唯一能够看到的是事件处理器。这也是他们所关心的内容。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>非阻塞式 I/O</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>I/O 即Input/Output 的缩写</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>\n</blockquote>\n</blockquote>\n<h2 id=\"let-var-const\"><a href=\"#let-var-const\" class=\"headerlink\" title=\"let var const\"></a>let var const</h2><p><code>let</code> 允许把变量的作用域限制在块级域中。与 <code>var</code> 不同处是：<code>var</code> 申明变量要么是全局的，要么是函数级的，而无法是块级的。</p>\n<p><code>let</code>的作用域是块，而<code>var</code>的作用域是函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;use strict&#39;;</span><br><span class=\"line\">for (let i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class=\"line\">  console.log(i); &#x2F;&#x2F; 0, 1, 2, 3, 4 ... 9</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(i); &#x2F;&#x2F; i is not defined</span><br><span class=\"line\">const这个声明创建一个常量,可以全局或局部的函数声明,不可以被重新赋值.</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Map-WeakMap-Set-WeakSet\"><a href=\"#Map-WeakMap-Set-WeakSet\" class=\"headerlink\" title=\"Map WeakMap Set WeakSet\"></a>Map WeakMap Set WeakSet</h2><h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>Map原生提供三个遍历器生成函数和一个遍历方法。</p>\n<p><code>keys()</code> 返回键名的遍历器。<br><code>values()</code> 返回键值的遍历器。<br><code>entries()</code> 返回所有成员的遍历器。<br><code>forEach()</code> 遍历Map的所有成员。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myMap &#x3D; new Map();</span><br><span class=\"line\">myMap.set(0, &quot;zero&quot;);</span><br><span class=\"line\">myMap.set(1, &quot;one&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var key of myMap.keys()) &#123;</span><br><span class=\"line\">  console.log(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 0 1</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var value of myMap.values()) &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; zero one</span><br><span class=\"line\"> </span><br><span class=\"line\">for (var item of myMap.entries()) &#123;</span><br><span class=\"line\">  console.log(item[0] + &quot; &#x3D; &quot; + item[1]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 0 &#x3D; zero 1 &#x3D; one</span><br><span class=\"line\"> </span><br><span class=\"line\">myMap.forEach(function(value, key) &#123;</span><br><span class=\"line\">  console.log(key + &quot; &#x3D; &quot; + value);</span><br><span class=\"line\">&#125;, myMap)</span><br><span class=\"line\">&#x2F;&#x2F; 0 &#x3D; zero 1 &#x3D; one</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h3><p>WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。<br>WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。<br>WeakMap只有四个方法可用：get()、set()、has()、delete()。</p>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p><code>add(value)</code> 添加某个值，返回Set结构本身。<br><code>delete(value)</code> 删除某个值，返回一个布尔值，表示删除是否成功。<br><code>has(value)</code> 返回一个布尔值，表示该值是否为Set的成员。<br><code>clear()</code> 清除所有成员，没有返回值。 上面这些属性和方法的实例如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s &#x3D; new Set();</span><br><span class=\"line\">s.add(1).add(2).add(2);</span><br><span class=\"line\">&#x2F;&#x2F; 注意2被加入了两次</span><br><span class=\"line\">console.log(s.size); &#x2F;&#x2F; 2</span><br><span class=\"line\">console.log(s.has(1)); &#x2F;&#x2F; true</span><br><span class=\"line\">console.log(s.has(2)); &#x2F;&#x2F; true</span><br><span class=\"line\">console.log(s.has(3)); &#x2F;&#x2F; false</span><br><span class=\"line\">console.log(s.delete(2));</span><br><span class=\"line\">console.log(s.has(2)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>\n\n<p>Set的遍历跟Map差不多,但是如果使用<code>set.entries()</code>去遍历的话,出来的结果会是像这样子[“red”, “red”] [“green”, “green”] [“blue”, “blue”],包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p>weakSet和WeakMap的道理也差不多,WeakSet的成员只能是对象，而不能是其他类型的值.WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用<br>WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var ws &#x3D; new WeakSet();</span><br><span class=\"line\">var obj &#x3D; &#123;&#125;;</span><br><span class=\"line\">var foo &#x3D; &#123;&#125;;</span><br><span class=\"line\">ws.add(obj);</span><br><span class=\"line\">ws.has(foo);    &#x2F;&#x2F; false</span><br><span class=\"line\">WeakSet没有size属性，没有办法遍历它的成员。</span><br><span class=\"line\">ws.size &#x2F;&#x2F; undefined</span><br><span class=\"line\">ws.forEach &#x2F;&#x2F; undefined</span><br><span class=\"line\">ws.forEach(function(item)&#123; console.log(&#39;WeakSet has &#39; + item)&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; TypeError: undefined is not a function</span><br></pre></td></tr></table></figure>\n<h2 id=\"Generator-Promise-Symbol\"><a href=\"#Generator-Promise-Symbol\" class=\"headerlink\" title=\"Generator Promise Symbol\"></a>Generator Promise Symbol</h2><h3 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h3><p>Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。</p>\n<p>执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* helloWorldGenerator() &#123;</span><br><span class=\"line\">  yield &#39;hello&#39;;</span><br><span class=\"line\">  yield &#39;world&#39;;</span><br><span class=\"line\">  return &#39;ending&#39;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var hw &#x3D; helloWorldGenerator();</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &#39;hello&#39;, done: false &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &#39;world&#39;, done: false &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: &#39;ending&#39;, done: true &#125;</span><br><span class=\"line\">console.log(hw.next()); \\\\ &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>yield</code> 意为’产出’ 是用来定义不同的内部状态,调用next()方法的时候会返回Generator的下一个状态,直到return为止,输出的done中的值表示Generator函数是否已经执行结束.</p>\n<p><code>yield *</code> 语句 : 用来在一个Generator中执行另外一个Generator函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function* anotherGenerator(i) &#123;</span><br><span class=\"line\">  yield i + 1;</span><br><span class=\"line\">  yield i + 2;</span><br><span class=\"line\">  yield i + 3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function* generator(i)&#123;</span><br><span class=\"line\">  yield i;</span><br><span class=\"line\">  yield* anotherGenerator(i);</span><br><span class=\"line\">  yield i + 10;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var gen &#x3D; generator(10);</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 10</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 11</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 12</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 13</span><br><span class=\"line\">console.log(gen.next().value); &#x2F;&#x2F; 20</span><br></pre></td></tr></table></figure>\n<p>运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。</p>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><p>Promise 是一个构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ... some code</span><br><span class=\"line\">  if (&#x2F;* 异步操作成功 *&#x2F;)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>Promise函数自带两个参数: <code>resolve</code>意为返回一个成功的回调,<code>reject</code>意为返回一个错误的回调<br>然后订阅回调的方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(function(value) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; success</span><br><span class=\"line\">&#125;, function(value) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; failure</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>PS: 这个函数很像OC的block方法,上面的函数就类似OC的如下写法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)promise:(void(^)(id success))resolve failure:(void(^)(id failure))reject &#123;</span><br><span class=\"line\">\tif(...)&#123;</span><br><span class=\"line\">\t\tresolve(resolveValue);</span><br><span class=\"line\">\t&#125;else &#123;</span><br><span class=\"line\">\t\treject(rejectValue);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;订阅</span><br><span class=\"line\">[self promise:^(id success)&#123;</span><br><span class=\"line\">\tNSLog(success);</span><br><span class=\"line\">&#125; failure:^(id failure)&#123;</span><br><span class=\"line\">\tNSLog(failure);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">&#x2F;&#x2F; 纯脑补,也不知道有没有写对</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"catch-方法\"><a href=\"#catch-方法\" class=\"headerlink\" title=\"catch() 方法\"></a>catch() 方法</h4><p>专门用来捕获异常的回调,会捕获到<code>then()</code>的第二个参数的回调</p>\n<p>如果在<code>then()</code>中使用了throw xxx;语句,那么也会走<code>catch()</code>回调</p>\n<p><code>catch()</code>和<code>then()</code>方法都会返回Promise对象,所以可以链式调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(function(value) &#123;</span><br><span class=\"line\">    console.log(value);      </span><br><span class=\"line\">&#125;,null).catch(function(value)&#123;</span><br><span class=\"line\">\tconsole.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>OR</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p1.then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); &#x2F;&#x2F; &quot;成功!&quot;</span><br><span class=\"line\">  throw &quot;哦，不!&quot;;</span><br><span class=\"line\">&#125;).catch(function(e) &#123;</span><br><span class=\"line\">  console.log(e); &#x2F;&#x2F; &quot;哦，不!&quot;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>你还可以<code>then()</code>完再<code>then()</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p2 &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">  resolve(1);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p2.then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); &#x2F;&#x2F; 1</span><br><span class=\"line\">  return value + 1;</span><br><span class=\"line\">&#125;).then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); &#x2F;&#x2F; 2</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"all-方法\"><a href=\"#all-方法\" class=\"headerlink\" title=\"all() 方法\"></a>all() 方法</h4><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p &#x3D; Promise.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>\n\n<p>只要有一个reject了,那么p就会抛出失败的回调,只有全部都resolve了,才会抛出成功的回调</p>\n<h4 id=\"race-方法\"><a href=\"#race-方法\" class=\"headerlink\" title=\"race() 方法\"></a>race() 方法</h4><p>顾名思义 赛跑</p>\n<p>同样是来绑定多个Promise实例,不同的是谁先返回就走谁的回调,如果p1五秒后发失败回调,p2一秒后发成功回调,那么Promise.race([p1, p2])就等于p2.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.race([p1, p2]).then(function(value) &#123;</span><br><span class=\"line\">  console.log(value); &#x2F;&#x2F; &quot;two&quot;</span><br><span class=\"line\">  &#x2F;&#x2F; Both resolve, but p2 is faster</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h3><p>符号</p>\n<p>用Symbol生成的对象,绝对不会重复!!!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class=\"line\">var s2 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class=\"line\">console.log(s1 &#x3D;&#x3D;&#x3D; s2); &#x2F;&#x2F; false</span><br><span class=\"line\">getOwnPropertySymbols()</span><br></pre></td></tr></table></figure>\n\n<p>这个方法可以获得对象的所有Symbol类型的成员属性名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj &#x3D; &#123;&#125;;</span><br><span class=\"line\">var a &#x3D; Symbol(&#39;a&#39;);</span><br><span class=\"line\">var b &#x3D; Symbol(&#39;b&#39;);</span><br><span class=\"line\"> </span><br><span class=\"line\">obj[a] &#x3D; &#39;Hello&#39;;</span><br><span class=\"line\">obj[b] &#x3D; &#39;World&#39;;</span><br><span class=\"line\">var objectSymbols &#x3D; Object.getOwnPropertySymbols(obj);</span><br><span class=\"line\">console.log(objectSymbols);</span><br><span class=\"line\">&#x2F;&#x2F; [Symbol(a), Symbol(b)]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Symbol-for\"><a href=\"#Symbol-for\" class=\"headerlink\" title=\"Symbol.for()\"></a>Symbol.for()</h4><p>这个方法用来搜索之前有没有定义过某个Symbol名,如果有的话就返回值没有的话就就新建一个Symbol,有种取缓存的感觉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s1 &#x3D; Symbol.for(&#39;foo&#39;); &#x2F;&#x2F; 定义一下</span><br><span class=\"line\">var s2 &#x3D; Symbol.for(&#39;foo&#39;); &#x2F;&#x2F; 取出之前定义的值</span><br><span class=\"line\">console.log(s1 &#x3D;&#x3D;&#x3D; s2); &#x2F;&#x2F; true</span><br><span class=\"line\">Symbol.keyFor()</span><br><span class=\"line\">跟上面的是相反的,通过值来取键</span><br><span class=\"line\"></span><br><span class=\"line\">var s1 &#x3D; Symbol.for(&quot;foo&quot;);</span><br><span class=\"line\">Symbol.keyFor(s1) &#x2F;&#x2F; &quot;foo&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">var s2 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class=\"line\">Symbol.keyFor(s2) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>其实就是简写方法而已</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var  f &#x3D; function(v1,v2) &#123;</span><br><span class=\"line\">\treturn v1+v2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; (v1,v2) &#x3D;&gt; v1+v2;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。<br>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。<br>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用<code>Rest</code>参数代替。<br>不可以使用<code>yield</code>命令，因此箭头函数不能用作Generator函数。</p>\n<h2 id=\"网络请求\"><a href=\"#网络请求\" class=\"headerlink\" title=\"网络请求\"></a>网络请求</h2><h3 id=\"方式一-使用-http-request\"><a href=\"#方式一-使用-http-request\" class=\"headerlink\" title=\"方式一 使用 http.request()\"></a>方式一 使用 http.request()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var http &#x3D; require(&#39;http&#39;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">var qs &#x3D; require(&#39;querystring&#39;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">var data &#x3D; &#123;  </span><br><span class=\"line\">    a: 123,  </span><br><span class=\"line\">    time: new Date().getTime()&#125;;&#x2F;&#x2F;这是需要提交的数据  </span><br><span class=\"line\">    </span><br><span class=\"line\">var content &#x3D; qs.stringify(data);   </span><br><span class=\"line\">var options &#x3D; &#123;  </span><br><span class=\"line\">    hostname: &#39;127.0.0.1&#39;,  </span><br><span class=\"line\">    port: 10086,  </span><br><span class=\"line\">    path: &#39;&#x2F;pay&#x2F;pay_callback?&#39; + content,  </span><br><span class=\"line\">    method: &#39;GET&#39;  </span><br><span class=\"line\">&#125;;  </span><br><span class=\"line\">  </span><br><span class=\"line\">var req &#x3D; http.request(options, function (res) &#123;  </span><br><span class=\"line\">    console.log(&#39;STATUS: &#39; + res.statusCode);  </span><br><span class=\"line\">    console.log(&#39;HEADERS: &#39; + JSON.stringify(res.headers));  </span><br><span class=\"line\">    res.setEncoding(&#39;utf8&#39;);  </span><br><span class=\"line\">    res.on(&#39;data&#39;, function (chunk) &#123;  </span><br><span class=\"line\">        console.log(&#39;BODY: &#39; + chunk);  </span><br><span class=\"line\">    &#125;);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">req.on(&#39;error&#39;, function (e) &#123;  </span><br><span class=\"line\">    console.log(&#39;problem with request: &#39; + e.message);  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">req.end();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方式二-使用-http-get-发送GET请求\"><a href=\"#方式二-使用-http-get-发送GET请求\" class=\"headerlink\" title=\"方式二 使用 http.get() 发送GET请求\"></a>方式二 使用 http.get() 发送GET请求</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var httpRequest &#x3D; http.get(&#39;http:&#x2F;&#x2F;localhost:8088&#x2F;tempFile&#x2F;LocalData.json&#39;,function(request,response)&#123;</span><br><span class=\"line\">      var html&#x3D;&#39;&#39;;</span><br><span class=\"line\">      request.on(&#39;data&#39;,function(data)&#123;</span><br><span class=\"line\">        \thtml+&#x3D;data;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      request.on(&#39;end&#39;,function()&#123;</span><br><span class=\"line\">\t\t\tconsole.log(html);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>学习资料来自:<a href=\"http://www.hubwiz.com/\">http://www.hubwiz.com</a> 等</p>\n</blockquote>"},{"title":"MongoDB笔记","author":"Arclin","abbrlink":"b3b38c86","date":"2018-02-18T13:58:00.000Z","_content":"MongoDB笔记\n\n<!-- more -->\n\nOS X安装\n\n`brew install mongodb`\n\n进入mongodb\n\n`mongo`\n\n查看所有数据库\n\n`db`\n\n查看所有*有数据的*数据库并带上内存信息\n\n`show dbs`\n\n创建/进入某个数据库\n\n`use DATABASE_NAME`\n\n删除数据库(需要先`use DATABASE_NAME` 进入数据库)\n\n`db.dropDatabase()`\n\n插入数据\n\n`db.DATABASE_NAME.insert({“COLUMN_NAME”:”VALUE”,”COLUMN_NAME_SECOND”:”SECOND_VALUE”})`\n\n查询所有数据\n\n`db.DATABASE_NAME.find()`\n\n查询所有数据并pretty形式打印\n\n`db.DATABASE_NAME.find().pretty()`\n\n更新满足条件的第一条数据\n\n`db.DATABASE_NAME.update({‘条件字段’:’条件值’},{$set:{‘更新字段’:’更新值’,‘更新字段2’:’更新值2’}})`\n\n更新满足条件的所有数据\n\n`db.DATABASE_NAME.update({‘条件字段’:’条件值’},{$set:{‘更新字段’:’更新值’,‘更新字段2’:’更新值2’},{multi:true}})`\n\n替换整条数据的内容(根据ID查找)\n\n`db.DATABASE_NAME.save({“_id”:ObjectId(“xxxxx”),”要替换的字段名”:”要替换的字段名”,”要替换的字段名2”:”要替换的字段名2”})`\n\n删除数据\n\n`db.DATABASE_NAME.remove({‘条件字段’:’条件值’})`\n\n删除第一条找到的记录\n\n`db.DATABASE_NAME.remove({‘条件字段’:’条件值’},1)`\n\n删除所有数据(请空表)\n\n`db.DATABASE_NAME.remove({})`\n\n\n\n\n\n\n","source":"_posts/MongoDB笔记.md","raw":"---\ntitle: MongoDB笔记\nauthor: Arclin\ntags:\n  - MongoDB\ncategories:\n  - MongoDB\nabbrlink: b3b38c86\ndate: 2018-02-18 21:58:00\n---\nMongoDB笔记\n\n<!-- more -->\n\nOS X安装\n\n`brew install mongodb`\n\n进入mongodb\n\n`mongo`\n\n查看所有数据库\n\n`db`\n\n查看所有*有数据的*数据库并带上内存信息\n\n`show dbs`\n\n创建/进入某个数据库\n\n`use DATABASE_NAME`\n\n删除数据库(需要先`use DATABASE_NAME` 进入数据库)\n\n`db.dropDatabase()`\n\n插入数据\n\n`db.DATABASE_NAME.insert({“COLUMN_NAME”:”VALUE”,”COLUMN_NAME_SECOND”:”SECOND_VALUE”})`\n\n查询所有数据\n\n`db.DATABASE_NAME.find()`\n\n查询所有数据并pretty形式打印\n\n`db.DATABASE_NAME.find().pretty()`\n\n更新满足条件的第一条数据\n\n`db.DATABASE_NAME.update({‘条件字段’:’条件值’},{$set:{‘更新字段’:’更新值’,‘更新字段2’:’更新值2’}})`\n\n更新满足条件的所有数据\n\n`db.DATABASE_NAME.update({‘条件字段’:’条件值’},{$set:{‘更新字段’:’更新值’,‘更新字段2’:’更新值2’},{multi:true}})`\n\n替换整条数据的内容(根据ID查找)\n\n`db.DATABASE_NAME.save({“_id”:ObjectId(“xxxxx”),”要替换的字段名”:”要替换的字段名”,”要替换的字段名2”:”要替换的字段名2”})`\n\n删除数据\n\n`db.DATABASE_NAME.remove({‘条件字段’:’条件值’})`\n\n删除第一条找到的记录\n\n`db.DATABASE_NAME.remove({‘条件字段’:’条件值’},1)`\n\n删除所有数据(请空表)\n\n`db.DATABASE_NAME.remove({})`\n\n\n\n\n\n\n","slug":"MongoDB笔记","published":1,"updated":"2021-04-12T06:07:04.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog51001645n0guap55xl","content":"<p>MongoDB笔记</p>\n<span id=\"more\"></span>\n\n<p>OS X安装</p>\n<p><code>brew install mongodb</code></p>\n<p>进入mongodb</p>\n<p><code>mongo</code></p>\n<p>查看所有数据库</p>\n<p><code>db</code></p>\n<p>查看所有<em>有数据的</em>数据库并带上内存信息</p>\n<p><code>show dbs</code></p>\n<p>创建/进入某个数据库</p>\n<p><code>use DATABASE_NAME</code></p>\n<p>删除数据库(需要先<code>use DATABASE_NAME</code> 进入数据库)</p>\n<p><code>db.dropDatabase()</code></p>\n<p>插入数据</p>\n<p><code>db.DATABASE_NAME.insert(&#123;“COLUMN_NAME”:”VALUE”,”COLUMN_NAME_SECOND”:”SECOND_VALUE”&#125;)</code></p>\n<p>查询所有数据</p>\n<p><code>db.DATABASE_NAME.find()</code></p>\n<p>查询所有数据并pretty形式打印</p>\n<p><code>db.DATABASE_NAME.find().pretty()</code></p>\n<p>更新满足条件的第一条数据</p>\n<p><code>db.DATABASE_NAME.update(&#123;‘条件字段’:’条件值’&#125;,&#123;$set:&#123;‘更新字段’:’更新值’,‘更新字段2’:’更新值2’&#125;&#125;)</code></p>\n<p>更新满足条件的所有数据</p>\n<p><code>db.DATABASE_NAME.update(&#123;‘条件字段’:’条件值’&#125;,&#123;$set:&#123;‘更新字段’:’更新值’,‘更新字段2’:’更新值2’&#125;,&#123;multi:true&#125;&#125;)</code></p>\n<p>替换整条数据的内容(根据ID查找)</p>\n<p><code>db.DATABASE_NAME.save(&#123;“_id”:ObjectId(“xxxxx”),”要替换的字段名”:”要替换的字段名”,”要替换的字段名2”:”要替换的字段名2”&#125;)</code></p>\n<p>删除数据</p>\n<p><code>db.DATABASE_NAME.remove(&#123;‘条件字段’:’条件值’&#125;)</code></p>\n<p>删除第一条找到的记录</p>\n<p><code>db.DATABASE_NAME.remove(&#123;‘条件字段’:’条件值’&#125;,1)</code></p>\n<p>删除所有数据(请空表)</p>\n<p><code>db.DATABASE_NAME.remove(&#123;&#125;)</code></p>\n","site":{"data":{}},"excerpt":"<p>MongoDB笔记</p>","more":"<p>OS X安装</p>\n<p><code>brew install mongodb</code></p>\n<p>进入mongodb</p>\n<p><code>mongo</code></p>\n<p>查看所有数据库</p>\n<p><code>db</code></p>\n<p>查看所有<em>有数据的</em>数据库并带上内存信息</p>\n<p><code>show dbs</code></p>\n<p>创建/进入某个数据库</p>\n<p><code>use DATABASE_NAME</code></p>\n<p>删除数据库(需要先<code>use DATABASE_NAME</code> 进入数据库)</p>\n<p><code>db.dropDatabase()</code></p>\n<p>插入数据</p>\n<p><code>db.DATABASE_NAME.insert(&#123;“COLUMN_NAME”:”VALUE”,”COLUMN_NAME_SECOND”:”SECOND_VALUE”&#125;)</code></p>\n<p>查询所有数据</p>\n<p><code>db.DATABASE_NAME.find()</code></p>\n<p>查询所有数据并pretty形式打印</p>\n<p><code>db.DATABASE_NAME.find().pretty()</code></p>\n<p>更新满足条件的第一条数据</p>\n<p><code>db.DATABASE_NAME.update(&#123;‘条件字段’:’条件值’&#125;,&#123;$set:&#123;‘更新字段’:’更新值’,‘更新字段2’:’更新值2’&#125;&#125;)</code></p>\n<p>更新满足条件的所有数据</p>\n<p><code>db.DATABASE_NAME.update(&#123;‘条件字段’:’条件值’&#125;,&#123;$set:&#123;‘更新字段’:’更新值’,‘更新字段2’:’更新值2’&#125;,&#123;multi:true&#125;&#125;)</code></p>\n<p>替换整条数据的内容(根据ID查找)</p>\n<p><code>db.DATABASE_NAME.save(&#123;“_id”:ObjectId(“xxxxx”),”要替换的字段名”:”要替换的字段名”,”要替换的字段名2”:”要替换的字段名2”&#125;)</code></p>\n<p>删除数据</p>\n<p><code>db.DATABASE_NAME.remove(&#123;‘条件字段’:’条件值’&#125;)</code></p>\n<p>删除第一条找到的记录</p>\n<p><code>db.DATABASE_NAME.remove(&#123;‘条件字段’:’条件值’&#125;,1)</code></p>\n<p>删除所有数据(请空表)</p>\n<p><code>db.DATABASE_NAME.remove(&#123;&#125;)</code></p>"},{"title":"React Native真机运行","author":"Arclin","abbrlink":"7724d1af","date":"2017-03-07T16:00:00.000Z","_content":"三步即可\n\n在项目根目录使用终端执行\n\n```\n$ curl http://localhost:8081/index.ios.bundle -o main.jsbundle\n```\n\n`AppDelegate.m` 找到这一行并注释\n\n```\njsCodeLocation = [NSURL URLWithString:@\"http://localhost:8081/index.ios.bundle?platform=ios&dev=true\"];\n```\n\n`AppDelegate.m` 写上或反注释这一行\n\n```\njsCodeLocation = [[NSBundle mainBundle] URLForResource:@\"main\" withExtension:@\"jsbundle\"];\n```\n","source":"_posts/React-Native真机运行.md","raw":"---\ntitle: React Native真机运行\nauthor: Arclin\ntags:\n  - React Native\n  - iOS\ncategories:\n  - React Native\nabbrlink: 7724d1af\ndate: 2017-03-08 00:00:00\n---\n三步即可\n\n在项目根目录使用终端执行\n\n```\n$ curl http://localhost:8081/index.ios.bundle -o main.jsbundle\n```\n\n`AppDelegate.m` 找到这一行并注释\n\n```\njsCodeLocation = [NSURL URLWithString:@\"http://localhost:8081/index.ios.bundle?platform=ios&dev=true\"];\n```\n\n`AppDelegate.m` 写上或反注释这一行\n\n```\njsCodeLocation = [[NSBundle mainBundle] URLForResource:@\"main\" withExtension:@\"jsbundle\"];\n```\n","slug":"React-Native真机运行","published":1,"updated":"2021-04-12T06:07:04.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog52001845n05fsr0hpy","content":"<p>三步即可</p>\n<p>在项目根目录使用终端执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl http:&#x2F;&#x2F;localhost:8081&#x2F;index.ios.bundle -o main.jsbundle</span><br></pre></td></tr></table></figure>\n\n<p><code>AppDelegate.m</code> 找到这一行并注释</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsCodeLocation &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;localhost:8081&#x2F;index.ios.bundle?platform&#x3D;ios&amp;dev&#x3D;true&quot;];</span><br></pre></td></tr></table></figure>\n\n<p><code>AppDelegate.m</code> 写上或反注释这一行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsCodeLocation &#x3D; [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;];</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>三步即可</p>\n<p>在项目根目录使用终端执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl http:&#x2F;&#x2F;localhost:8081&#x2F;index.ios.bundle -o main.jsbundle</span><br></pre></td></tr></table></figure>\n\n<p><code>AppDelegate.m</code> 找到这一行并注释</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsCodeLocation &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;localhost:8081&#x2F;index.ios.bundle?platform&#x3D;ios&amp;dev&#x3D;true&quot;];</span><br></pre></td></tr></table></figure>\n\n<p><code>AppDelegate.m</code> 写上或反注释这一行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsCodeLocation &#x3D; [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;];</span><br></pre></td></tr></table></figure>\n"},{"title":"RAC关于cell上的按钮点击后会重复发送信号的问题","author":"Arclin","abbrlink":"452efb32","date":"2016-10-16T16:00:00.000Z","_content":"关于cell上的按钮点击后会重复发送信号的问题\n\nRAC给`UITableViewCell`提供了一个方法：`rac_prepareForReuseSignal`，它的作用是当Cell即将要被重用时，告诉Cell。想象Cell上有多个button，Cell在初始化时给每个button都`addTarget:action:forControlEvents`，被重用时需要先移除这些target，下面这段代码就可以很方便地解决这个问题：\n\n```\n[[[self.cancelButton\n    rac_signalForControlEvents:UIControlEventTouchUpInside]\n    takeUntil:self.rac_prepareForReuseSignal]\n    subscribeNext:^(UIButton *x) {\n    // do other things\n}];\n```","source":"_posts/RAC关于cell上的按钮点击后会重复发送信号的问题.md","raw":"---\ntitle: RAC关于cell上的按钮点击后会重复发送信号的问题\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 452efb32\ndate: 2016-10-17 00:00:00\n---\n关于cell上的按钮点击后会重复发送信号的问题\n\nRAC给`UITableViewCell`提供了一个方法：`rac_prepareForReuseSignal`，它的作用是当Cell即将要被重用时，告诉Cell。想象Cell上有多个button，Cell在初始化时给每个button都`addTarget:action:forControlEvents`，被重用时需要先移除这些target，下面这段代码就可以很方便地解决这个问题：\n\n```\n[[[self.cancelButton\n    rac_signalForControlEvents:UIControlEventTouchUpInside]\n    takeUntil:self.rac_prepareForReuseSignal]\n    subscribeNext:^(UIButton *x) {\n    // do other things\n}];\n```","slug":"RAC关于cell上的按钮点击后会重复发送信号的问题","published":1,"updated":"2021-04-12T06:07:04.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog53001c45n0fui26yh4","content":"<p>关于cell上的按钮点击后会重复发送信号的问题</p>\n<p>RAC给<code>UITableViewCell</code>提供了一个方法：<code>rac_prepareForReuseSignal</code>，它的作用是当Cell即将要被重用时，告诉Cell。想象Cell上有多个button，Cell在初始化时给每个button都<code>addTarget:action:forControlEvents</code>，被重用时需要先移除这些target，下面这段代码就可以很方便地解决这个问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[[self.cancelButton</span><br><span class=\"line\">    rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class=\"line\">    takeUntil:self.rac_prepareForReuseSignal]</span><br><span class=\"line\">    subscribeNext:^(UIButton *x) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; do other things</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>关于cell上的按钮点击后会重复发送信号的问题</p>\n<p>RAC给<code>UITableViewCell</code>提供了一个方法：<code>rac_prepareForReuseSignal</code>，它的作用是当Cell即将要被重用时，告诉Cell。想象Cell上有多个button，Cell在初始化时给每个button都<code>addTarget:action:forControlEvents</code>，被重用时需要先移除这些target，下面这段代码就可以很方便地解决这个问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[[self.cancelButton</span><br><span class=\"line\">    rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class=\"line\">    takeUntil:self.rac_prepareForReuseSignal]</span><br><span class=\"line\">    subscribeNext:^(UIButton *x) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; do other things</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>"},{"title":"NavigationController的RootViewController和子ViewController的状态栏颜色不一样或者状态栏显示异常","author":"Arclin","abbrlink":"cacc49a3","date":"2016-10-16T16:00:00.000Z","_content":"如果NavigationController的状态栏颜色跟子ViewController的状态栏颜色不一样，那么就像下面这么写\n\n在UINavigationController的子类写这个\n\n```\n- (UIViewController *)childViewControllerForStatusBarStyle{\n    return self.topViewController;\n}\n```","source":"_posts/NavigationController的RootViewController和子ViewController的状态栏颜色不一样或者状态栏显示异常.md","raw":"---\ntitle: NavigationController的RootViewController和子ViewController的状态栏颜色不一样或者状态栏显示异常\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: cacc49a3\ndate: 2016-10-17 00:00:00\n---\n如果NavigationController的状态栏颜色跟子ViewController的状态栏颜色不一样，那么就像下面这么写\n\n在UINavigationController的子类写这个\n\n```\n- (UIViewController *)childViewControllerForStatusBarStyle{\n    return self.topViewController;\n}\n```","slug":"NavigationController的RootViewController和子ViewController的状态栏颜色不一样或者状态栏显示异常","published":1,"updated":"2021-04-12T06:07:04.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog54001f45n06u3e398p","content":"<p>如果NavigationController的状态栏颜色跟子ViewController的状态栏颜色不一样，那么就像下面这么写</p>\n<p>在UINavigationController的子类写这个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIViewController *)childViewControllerForStatusBarStyle&#123;</span><br><span class=\"line\">    return self.topViewController;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>如果NavigationController的状态栏颜色跟子ViewController的状态栏颜色不一样，那么就像下面这么写</p>\n<p>在UINavigationController的子类写这个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (UIViewController *)childViewControllerForStatusBarStyle&#123;</span><br><span class=\"line\">    return self.topViewController;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"ReactNative ListView flexWrap不起作用解决办法","author":"Arclin","abbrlink":"11785d19","date":"2017-03-01T16:00:00.000Z","_content":"`flexWrap:’wrap’ `作用是让超出页面的元素进行换行显示,但是在RN 0.28之后就发生了改变\n\n<!-- more -->\n\n|RN0.28之前|RN0.28之后|\n|----|----|\n|contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems: ‘stretch’,<br/>// 屏幕宽度<br/>width:width,<br/>},|contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems:’flex-start’,<br/>// 屏幕宽度<br/> width:width,<br/>},|\n\n`alignItems: ‘stretch’` 变成了 `alignItems:’flex-start’`,\n\n但是现在的教程基本上不会加上`alignItems`…只有一个`flexWrap`,但是放到现在就实现不了了","source":"_posts/ReactNative-ListView-flexWrap不起作用解决办法.md","raw":"---\ntitle: ReactNative ListView flexWrap不起作用解决办法\nauthor: Arclin\ntags:\n  - React Native\ncategories: []\nabbrlink: 11785d19\ndate: 2017-03-02 00:00:00\n---\n`flexWrap:’wrap’ `作用是让超出页面的元素进行换行显示,但是在RN 0.28之后就发生了改变\n\n<!-- more -->\n\n|RN0.28之前|RN0.28之后|\n|----|----|\n|contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems: ‘stretch’,<br/>// 屏幕宽度<br/>width:width,<br/>},|contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems:’flex-start’,<br/>// 屏幕宽度<br/> width:width,<br/>},|\n\n`alignItems: ‘stretch’` 变成了 `alignItems:’flex-start’`,\n\n但是现在的教程基本上不会加上`alignItems`…只有一个`flexWrap`,但是放到现在就实现不了了","slug":"ReactNative-ListView-flexWrap不起作用解决办法","published":1,"updated":"2021-04-12T06:07:04.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog54001i45n00vf0gzx5","content":"<p><code>flexWrap:’wrap’ </code>作用是让超出页面的元素进行换行显示,但是在RN 0.28之后就发生了改变</p>\n<span id=\"more\"></span>\n\n<table>\n<thead>\n<tr>\n<th>RN0.28之前</th>\n<th>RN0.28之后</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems: ‘stretch’,<br/>// 屏幕宽度<br/>width:width,<br/>},</td>\n<td>contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems:’flex-start’,<br/>// 屏幕宽度<br/> width:width,<br/>},</td>\n</tr>\n</tbody></table>\n<p><code>alignItems: ‘stretch’</code> 变成了 <code>alignItems:’flex-start’</code>,</p>\n<p>但是现在的教程基本上不会加上<code>alignItems</code>…只有一个<code>flexWrap</code>,但是放到现在就实现不了了</p>\n","site":{"data":{}},"excerpt":"<p><code>flexWrap:’wrap’ </code>作用是让超出页面的元素进行换行显示,但是在RN 0.28之后就发生了改变</p>","more":"<table>\n<thead>\n<tr>\n<th>RN0.28之前</th>\n<th>RN0.28之后</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems: ‘stretch’,<br/>// 屏幕宽度<br/>width:width,<br/>},</td>\n<td>contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems:’flex-start’,<br/>// 屏幕宽度<br/> width:width,<br/>},</td>\n</tr>\n</tbody></table>\n<p><code>alignItems: ‘stretch’</code> 变成了 <code>alignItems:’flex-start’</code>,</p>\n<p>但是现在的教程基本上不会加上<code>alignItems</code>…只有一个<code>flexWrap</code>,但是放到现在就实现不了了</p>"},{"title":"ReactNative与iOS原生代码之间传值","author":"Arclin","abbrlink":"a8a5ff12","date":"2017-02-25T16:00:00.000Z","_content":"本文包含两部分:\n\n- 原生传值到RN\n- RN传值到原生\n\n<!-- more -->\n\n### 原生传值到RN\n\n加载`RCTRootView`的时候在`initialProperties`内传值\n\n```\nNSDictionary *params = @{@\"image\":@\"https://dn-coding-net-production-static.qbox.me/ac823dee-6303-4745-9216-711ab4d83753.png?imageMogr2/auto-orient/format/png/crop/!651x651a0a0\"};\n\nRCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\n                                                         moduleName:@\"Test\"\n                                                  initialProperties:params\n                                                      launchOptions:nil];\n```\n\n发送的值可以在`this.props`内得到,像上面的例子就是`this.props.image`\n\n```\n<View style={[styles.tabContent,{backgroundColor:color}]}>\n            <Text style={styles.tabText}>{pageText}</Text>\n            <Text style={styles.tabText}>第{num}次重复渲染{pageText}</Text>\n            <Text stype={styles.tabText}>{this._renderImage(this.props.image)}</Text>\n</View>\n```\n\n### RN传值到原生\n\n原生代码实现协议`RCTBridgeModule`,如下\n\n```\n#import <React/RCTBridgeModule.h>\n\n@interface ReactViewController : UIViewController<RCTBridgeModule>\n\n@end\n```\n\n添加方法,下面代码中的`testPassValue`给这个Controller声明一个`testPassValue`方法,在RN中可以调用这个方法\n\n```\n// 导出模块\nRCT_EXPORT_MODULE(); // 此处不添加参数默认为这个类的类名\n\nRCT_EXPORT_METHOD(testPassValue:(NSString *)value)\n{\n    NSLog(@\"%@\",value);\n}\n```\n\nRN中调用原生的`testPassValue`方法\n\n```\nimport {\n    NativeModules,\n} from 'react-native';\n\nvar ReactViewController = NativeModules.ReactViewController;\n\n//方法调用\nReactViewController.testPassValue('I pass this value to controller');\n```\n\n注意: RN调用原生方法的时候,如果涉及到UI操作,记得使用`dispatch_async(dispatch_get_main_queue(), ^{});`拉回主线程,另外在被调用方法中调用的self的地址和真正的这个controller的地址是不一样的,所以在进入RN的controller的时候要把self保存起来,比如另外创建一个单例之类的,然后RN回调原生的时候取出控制器对象才可使用.\n\n类似下面这个例子是pop掉RN所在的控制器\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 保存到单例\n    [RNSingleton sharedInstance].rnvc = self;\n    \n    // Do any additional setup after loading the view.\n    self.navigationController.navigationBarHidden = YES;\n    NSString * strUrl = @\"http://localhost:8081/index.ios.bundle?platform=ios&dev=true\";\n    NSURL * jsCodeLocation = [NSURL URLWithString:strUrl];\n    \n    RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\n                                                         moduleName:@\"Test\"\n                                                  initialProperties:self.params\n                                                      launchOptions:nil];\n    self.view = rootView;\n}\n\n// 导出模块\nRCT_EXPORT_MODULE(); // 此处不添加参数默认为这个类的类名\n\nRCT_EXPORT_METHOD(testPassValue:(NSString *)value)\n{\n    NSLog(@\"%@\",value);\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [[RNSingleton sharedInstance].rnvc.navigationController popViewControllerAnimated:YES];\n    });\n}\n\n```","source":"_posts/ReactNative与iOS原生代码之间传值.md","raw":"---\ntitle: ReactNative与iOS原生代码之间传值\nauthor: Arclin\ntags:\n  - React Native\ncategories:\n  - React Native\nabbrlink: a8a5ff12\ndate: 2017-02-26 00:00:00\n---\n本文包含两部分:\n\n- 原生传值到RN\n- RN传值到原生\n\n<!-- more -->\n\n### 原生传值到RN\n\n加载`RCTRootView`的时候在`initialProperties`内传值\n\n```\nNSDictionary *params = @{@\"image\":@\"https://dn-coding-net-production-static.qbox.me/ac823dee-6303-4745-9216-711ab4d83753.png?imageMogr2/auto-orient/format/png/crop/!651x651a0a0\"};\n\nRCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\n                                                         moduleName:@\"Test\"\n                                                  initialProperties:params\n                                                      launchOptions:nil];\n```\n\n发送的值可以在`this.props`内得到,像上面的例子就是`this.props.image`\n\n```\n<View style={[styles.tabContent,{backgroundColor:color}]}>\n            <Text style={styles.tabText}>{pageText}</Text>\n            <Text style={styles.tabText}>第{num}次重复渲染{pageText}</Text>\n            <Text stype={styles.tabText}>{this._renderImage(this.props.image)}</Text>\n</View>\n```\n\n### RN传值到原生\n\n原生代码实现协议`RCTBridgeModule`,如下\n\n```\n#import <React/RCTBridgeModule.h>\n\n@interface ReactViewController : UIViewController<RCTBridgeModule>\n\n@end\n```\n\n添加方法,下面代码中的`testPassValue`给这个Controller声明一个`testPassValue`方法,在RN中可以调用这个方法\n\n```\n// 导出模块\nRCT_EXPORT_MODULE(); // 此处不添加参数默认为这个类的类名\n\nRCT_EXPORT_METHOD(testPassValue:(NSString *)value)\n{\n    NSLog(@\"%@\",value);\n}\n```\n\nRN中调用原生的`testPassValue`方法\n\n```\nimport {\n    NativeModules,\n} from 'react-native';\n\nvar ReactViewController = NativeModules.ReactViewController;\n\n//方法调用\nReactViewController.testPassValue('I pass this value to controller');\n```\n\n注意: RN调用原生方法的时候,如果涉及到UI操作,记得使用`dispatch_async(dispatch_get_main_queue(), ^{});`拉回主线程,另外在被调用方法中调用的self的地址和真正的这个controller的地址是不一样的,所以在进入RN的controller的时候要把self保存起来,比如另外创建一个单例之类的,然后RN回调原生的时候取出控制器对象才可使用.\n\n类似下面这个例子是pop掉RN所在的控制器\n\n```\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 保存到单例\n    [RNSingleton sharedInstance].rnvc = self;\n    \n    // Do any additional setup after loading the view.\n    self.navigationController.navigationBarHidden = YES;\n    NSString * strUrl = @\"http://localhost:8081/index.ios.bundle?platform=ios&dev=true\";\n    NSURL * jsCodeLocation = [NSURL URLWithString:strUrl];\n    \n    RCTRootView * rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\n                                                         moduleName:@\"Test\"\n                                                  initialProperties:self.params\n                                                      launchOptions:nil];\n    self.view = rootView;\n}\n\n// 导出模块\nRCT_EXPORT_MODULE(); // 此处不添加参数默认为这个类的类名\n\nRCT_EXPORT_METHOD(testPassValue:(NSString *)value)\n{\n    NSLog(@\"%@\",value);\n    dispatch_async(dispatch_get_main_queue(), ^{\n        [[RNSingleton sharedInstance].rnvc.navigationController popViewControllerAnimated:YES];\n    });\n}\n\n```","slug":"ReactNative与iOS原生代码之间传值","published":1,"updated":"2021-04-12T06:07:04.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog55001m45n091id0pww","content":"<p>本文包含两部分:</p>\n<ul>\n<li>原生传值到RN</li>\n<li>RN传值到原生</li>\n</ul>\n<span id=\"more\"></span>\n\n<h3 id=\"原生传值到RN\"><a href=\"#原生传值到RN\" class=\"headerlink\" title=\"原生传值到RN\"></a>原生传值到RN</h3><p>加载<code>RCTRootView</code>的时候在<code>initialProperties</code>内传值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSDictionary *params &#x3D; @&#123;@&quot;image&quot;:@&quot;https:&#x2F;&#x2F;dn-coding-net-production-static.qbox.me&#x2F;ac823dee-6303-4745-9216-711ab4d83753.png?imageMogr2&#x2F;auto-orient&#x2F;format&#x2F;png&#x2F;crop&#x2F;!651x651a0a0&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">RCTRootView * rootView &#x3D; [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class=\"line\">                                                         moduleName:@&quot;Test&quot;</span><br><span class=\"line\">                                                  initialProperties:params</span><br><span class=\"line\">                                                      launchOptions:nil];</span><br></pre></td></tr></table></figure>\n\n<p>发送的值可以在<code>this.props</code>内得到,像上面的例子就是<code>this.props.image</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;View style&#x3D;&#123;[styles.tabContent,&#123;backgroundColor:color&#125;]&#125;&gt;</span><br><span class=\"line\">            &lt;Text style&#x3D;&#123;styles.tabText&#125;&gt;&#123;pageText&#125;&lt;&#x2F;Text&gt;</span><br><span class=\"line\">            &lt;Text style&#x3D;&#123;styles.tabText&#125;&gt;第&#123;num&#125;次重复渲染&#123;pageText&#125;&lt;&#x2F;Text&gt;</span><br><span class=\"line\">            &lt;Text stype&#x3D;&#123;styles.tabText&#125;&gt;&#123;this._renderImage(this.props.image)&#125;&lt;&#x2F;Text&gt;</span><br><span class=\"line\">&lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RN传值到原生\"><a href=\"#RN传值到原生\" class=\"headerlink\" title=\"RN传值到原生\"></a>RN传值到原生</h3><p>原生代码实现协议<code>RCTBridgeModule</code>,如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;React&#x2F;RCTBridgeModule.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface ReactViewController : UIViewController&lt;RCTBridgeModule&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>添加方法,下面代码中的<code>testPassValue</code>给这个Controller声明一个<code>testPassValue</code>方法,在RN中可以调用这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 导出模块</span><br><span class=\"line\">RCT_EXPORT_MODULE(); &#x2F;&#x2F; 此处不添加参数默认为这个类的类名</span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_METHOD(testPassValue:(NSString *)value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>RN中调用原生的<code>testPassValue</code>方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;</span><br><span class=\"line\">    NativeModules,</span><br><span class=\"line\">&#125; from &#39;react-native&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">var ReactViewController &#x3D; NativeModules.ReactViewController;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;方法调用</span><br><span class=\"line\">ReactViewController.testPassValue(&#39;I pass this value to controller&#39;);</span><br></pre></td></tr></table></figure>\n\n<p>注意: RN调用原生方法的时候,如果涉及到UI操作,记得使用<code>dispatch_async(dispatch_get_main_queue(), ^&#123;&#125;);</code>拉回主线程,另外在被调用方法中调用的self的地址和真正的这个controller的地址是不一样的,所以在进入RN的controller的时候要把self保存起来,比如另外创建一个单例之类的,然后RN回调原生的时候取出控制器对象才可使用.</p>\n<p>类似下面这个例子是pop掉RN所在的控制器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 保存到单例</span><br><span class=\"line\">    [RNSingleton sharedInstance].rnvc &#x3D; self;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class=\"line\">    self.navigationController.navigationBarHidden &#x3D; YES;</span><br><span class=\"line\">    NSString * strUrl &#x3D; @&quot;http:&#x2F;&#x2F;localhost:8081&#x2F;index.ios.bundle?platform&#x3D;ios&amp;dev&#x3D;true&quot;;</span><br><span class=\"line\">    NSURL * jsCodeLocation &#x3D; [NSURL URLWithString:strUrl];</span><br><span class=\"line\">    </span><br><span class=\"line\">    RCTRootView * rootView &#x3D; [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class=\"line\">                                                         moduleName:@&quot;Test&quot;</span><br><span class=\"line\">                                                  initialProperties:self.params</span><br><span class=\"line\">                                                      launchOptions:nil];</span><br><span class=\"line\">    self.view &#x3D; rootView;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 导出模块</span><br><span class=\"line\">RCT_EXPORT_MODULE(); &#x2F;&#x2F; 此处不添加参数默认为这个类的类名</span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_METHOD(testPassValue:(NSString *)value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,value);</span><br><span class=\"line\">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        [[RNSingleton sharedInstance].rnvc.navigationController popViewControllerAnimated:YES];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>本文包含两部分:</p>\n<ul>\n<li>原生传值到RN</li>\n<li>RN传值到原生</li>\n</ul>","more":"<h3 id=\"原生传值到RN\"><a href=\"#原生传值到RN\" class=\"headerlink\" title=\"原生传值到RN\"></a>原生传值到RN</h3><p>加载<code>RCTRootView</code>的时候在<code>initialProperties</code>内传值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSDictionary *params &#x3D; @&#123;@&quot;image&quot;:@&quot;https:&#x2F;&#x2F;dn-coding-net-production-static.qbox.me&#x2F;ac823dee-6303-4745-9216-711ab4d83753.png?imageMogr2&#x2F;auto-orient&#x2F;format&#x2F;png&#x2F;crop&#x2F;!651x651a0a0&quot;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">RCTRootView * rootView &#x3D; [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class=\"line\">                                                         moduleName:@&quot;Test&quot;</span><br><span class=\"line\">                                                  initialProperties:params</span><br><span class=\"line\">                                                      launchOptions:nil];</span><br></pre></td></tr></table></figure>\n\n<p>发送的值可以在<code>this.props</code>内得到,像上面的例子就是<code>this.props.image</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;View style&#x3D;&#123;[styles.tabContent,&#123;backgroundColor:color&#125;]&#125;&gt;</span><br><span class=\"line\">            &lt;Text style&#x3D;&#123;styles.tabText&#125;&gt;&#123;pageText&#125;&lt;&#x2F;Text&gt;</span><br><span class=\"line\">            &lt;Text style&#x3D;&#123;styles.tabText&#125;&gt;第&#123;num&#125;次重复渲染&#123;pageText&#125;&lt;&#x2F;Text&gt;</span><br><span class=\"line\">            &lt;Text stype&#x3D;&#123;styles.tabText&#125;&gt;&#123;this._renderImage(this.props.image)&#125;&lt;&#x2F;Text&gt;</span><br><span class=\"line\">&lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"RN传值到原生\"><a href=\"#RN传值到原生\" class=\"headerlink\" title=\"RN传值到原生\"></a>RN传值到原生</h3><p>原生代码实现协议<code>RCTBridgeModule</code>,如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;React&#x2F;RCTBridgeModule.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface ReactViewController : UIViewController&lt;RCTBridgeModule&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>添加方法,下面代码中的<code>testPassValue</code>给这个Controller声明一个<code>testPassValue</code>方法,在RN中可以调用这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 导出模块</span><br><span class=\"line\">RCT_EXPORT_MODULE(); &#x2F;&#x2F; 此处不添加参数默认为这个类的类名</span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_METHOD(testPassValue:(NSString *)value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>RN中调用原生的<code>testPassValue</code>方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;</span><br><span class=\"line\">    NativeModules,</span><br><span class=\"line\">&#125; from &#39;react-native&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">var ReactViewController &#x3D; NativeModules.ReactViewController;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;方法调用</span><br><span class=\"line\">ReactViewController.testPassValue(&#39;I pass this value to controller&#39;);</span><br></pre></td></tr></table></figure>\n\n<p>注意: RN调用原生方法的时候,如果涉及到UI操作,记得使用<code>dispatch_async(dispatch_get_main_queue(), ^&#123;&#125;);</code>拉回主线程,另外在被调用方法中调用的self的地址和真正的这个controller的地址是不一样的,所以在进入RN的controller的时候要把self保存起来,比如另外创建一个单例之类的,然后RN回调原生的时候取出控制器对象才可使用.</p>\n<p>类似下面这个例子是pop掉RN所在的控制器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [super viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 保存到单例</span><br><span class=\"line\">    [RNSingleton sharedInstance].rnvc &#x3D; self;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class=\"line\">    self.navigationController.navigationBarHidden &#x3D; YES;</span><br><span class=\"line\">    NSString * strUrl &#x3D; @&quot;http:&#x2F;&#x2F;localhost:8081&#x2F;index.ios.bundle?platform&#x3D;ios&amp;dev&#x3D;true&quot;;</span><br><span class=\"line\">    NSURL * jsCodeLocation &#x3D; [NSURL URLWithString:strUrl];</span><br><span class=\"line\">    </span><br><span class=\"line\">    RCTRootView * rootView &#x3D; [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class=\"line\">                                                         moduleName:@&quot;Test&quot;</span><br><span class=\"line\">                                                  initialProperties:self.params</span><br><span class=\"line\">                                                      launchOptions:nil];</span><br><span class=\"line\">    self.view &#x3D; rootView;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 导出模块</span><br><span class=\"line\">RCT_EXPORT_MODULE(); &#x2F;&#x2F; 此处不添加参数默认为这个类的类名</span><br><span class=\"line\"></span><br><span class=\"line\">RCT_EXPORT_METHOD(testPassValue:(NSString *)value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,value);</span><br><span class=\"line\">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">        [[RNSingleton sharedInstance].rnvc.navigationController popViewControllerAnimated:YES];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"ReactNative网络请求","author":"Arclin","abbrlink":"b6bd206a","date":"2017-03-14T16:00:00.000Z","_content":"关于React Native 的网络请求的总结\n\n<!-- more -->\n\n因为这里使用的是`fetch()`方法,返回的是一个`Promise`对象,所以可以使用`then()`和`catch()`方法进行链式调用,也可以用`all()`,`race()` 去包装多个请求\n\n具体的话可以看这里\n\n### GET\n```\nfetch(\"http://localhost:3000/get\")\n\t.then((response) => response.json()) // 这里取出响应体的JSON数据并返回\n\t.then((responseJSON) => { // 处理上面返回的JSON数据\n\t\t// do something\n\t\t\n\t})\n\t.catch((err) => { // 捕获错误\n\t\t// catch err\n\t});\n```\n### POST\n网上说有两种,不过我一般用第二种比较多\n\n#### application/json\n```\nvar fetchOptions = {\n           method: 'POST',\n           headers: {\n               'Accept': 'application/json',\n               //json形式\n               'Content-Type': 'application/json'\n           },\n           body:JSON.stringify('data=test') // 这里是请求参数,键值对形式\n       };\n\nfetch(\"http://localhost:3000/post\", fetchOptions)\n   .then((response) => response.json())\n   .then((responseText) => {\n        console.log(responseText);\n   });\n```\n\n#### application/x-www-form-urlencoded\n\n```\n var fetchOptions = {\n           method: 'POST',\n           headers: {\n               'Accept': 'application/json',\n               //表单\n               'Content-Type': 'application/x-www-form-urlencoded'\n           },\n           body:'data=test' // 这里是请求参数,键值对形式\n       };\n\nfetch(\"http://localhost:3000/post\", fetchOptions)\n   .then((response) => response.json())\n   .then((responseText) => {\n        console.log(responseText);\n   });\n```\n如果使用的是Restful的API的话,那么只要把上面`fetchOption`里面的`method`改成对应的方法就好.\n\n当然,封装一个网络请求工具是有必要的,等我有时间写一下.","source":"_posts/ReactNative网络请求.md","raw":"---\ntitle: ReactNative网络请求\nauthor: Arclin\ntags:\n  - React Native\ncategories:\n  - React Native\nabbrlink: b6bd206a\ndate: 2017-03-15 00:00:00\n---\n关于React Native 的网络请求的总结\n\n<!-- more -->\n\n因为这里使用的是`fetch()`方法,返回的是一个`Promise`对象,所以可以使用`then()`和`catch()`方法进行链式调用,也可以用`all()`,`race()` 去包装多个请求\n\n具体的话可以看这里\n\n### GET\n```\nfetch(\"http://localhost:3000/get\")\n\t.then((response) => response.json()) // 这里取出响应体的JSON数据并返回\n\t.then((responseJSON) => { // 处理上面返回的JSON数据\n\t\t// do something\n\t\t\n\t})\n\t.catch((err) => { // 捕获错误\n\t\t// catch err\n\t});\n```\n### POST\n网上说有两种,不过我一般用第二种比较多\n\n#### application/json\n```\nvar fetchOptions = {\n           method: 'POST',\n           headers: {\n               'Accept': 'application/json',\n               //json形式\n               'Content-Type': 'application/json'\n           },\n           body:JSON.stringify('data=test') // 这里是请求参数,键值对形式\n       };\n\nfetch(\"http://localhost:3000/post\", fetchOptions)\n   .then((response) => response.json())\n   .then((responseText) => {\n        console.log(responseText);\n   });\n```\n\n#### application/x-www-form-urlencoded\n\n```\n var fetchOptions = {\n           method: 'POST',\n           headers: {\n               'Accept': 'application/json',\n               //表单\n               'Content-Type': 'application/x-www-form-urlencoded'\n           },\n           body:'data=test' // 这里是请求参数,键值对形式\n       };\n\nfetch(\"http://localhost:3000/post\", fetchOptions)\n   .then((response) => response.json())\n   .then((responseText) => {\n        console.log(responseText);\n   });\n```\n如果使用的是Restful的API的话,那么只要把上面`fetchOption`里面的`method`改成对应的方法就好.\n\n当然,封装一个网络请求工具是有必要的,等我有时间写一下.","slug":"ReactNative网络请求","published":1,"updated":"2021-04-12T06:07:04.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog55001p45n04uhnb56v","content":"<p>关于React Native 的网络请求的总结</p>\n<span id=\"more\"></span>\n\n<p>因为这里使用的是<code>fetch()</code>方法,返回的是一个<code>Promise</code>对象,所以可以使用<code>then()</code>和<code>catch()</code>方法进行链式调用,也可以用<code>all()</code>,<code>race()</code> 去包装多个请求</p>\n<p>具体的话可以看这里</p>\n<h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;get&quot;)</span><br><span class=\"line\">\t.then((response) &#x3D;&gt; response.json()) &#x2F;&#x2F; 这里取出响应体的JSON数据并返回</span><br><span class=\"line\">\t.then((responseJSON) &#x3D;&gt; &#123; &#x2F;&#x2F; 处理上面返回的JSON数据</span><br><span class=\"line\">\t\t&#x2F;&#x2F; do something</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.catch((err) &#x3D;&gt; &#123; &#x2F;&#x2F; 捕获错误</span><br><span class=\"line\">\t\t&#x2F;&#x2F; catch err</span><br><span class=\"line\">\t&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h3><p>网上说有两种,不过我一般用第二种比较多</p>\n<h4 id=\"application-json\"><a href=\"#application-json\" class=\"headerlink\" title=\"application/json\"></a>application/json</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fetchOptions &#x3D; &#123;</span><br><span class=\"line\">           method: &#39;POST&#39;,</span><br><span class=\"line\">           headers: &#123;</span><br><span class=\"line\">               &#39;Accept&#39;: &#39;application&#x2F;json&#39;,</span><br><span class=\"line\">               &#x2F;&#x2F;json形式</span><br><span class=\"line\">               &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           body:JSON.stringify(&#39;data&#x3D;test&#39;) &#x2F;&#x2F; 这里是请求参数,键值对形式</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fetch(&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;post&quot;, fetchOptions)</span><br><span class=\"line\">   .then((response) &#x3D;&gt; response.json())</span><br><span class=\"line\">   .then((responseText) &#x3D;&gt; &#123;</span><br><span class=\"line\">        console.log(responseText);</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"application-x-www-form-urlencoded\"><a href=\"#application-x-www-form-urlencoded\" class=\"headerlink\" title=\"application/x-www-form-urlencoded\"></a>application/x-www-form-urlencoded</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var fetchOptions &#x3D; &#123;</span><br><span class=\"line\">           method: &#39;POST&#39;,</span><br><span class=\"line\">           headers: &#123;</span><br><span class=\"line\">               &#39;Accept&#39;: &#39;application&#x2F;json&#39;,</span><br><span class=\"line\">               &#x2F;&#x2F;表单</span><br><span class=\"line\">               &#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39;</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           body:&#39;data&#x3D;test&#39; &#x2F;&#x2F; 这里是请求参数,键值对形式</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fetch(&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;post&quot;, fetchOptions)</span><br><span class=\"line\">   .then((response) &#x3D;&gt; response.json())</span><br><span class=\"line\">   .then((responseText) &#x3D;&gt; &#123;</span><br><span class=\"line\">        console.log(responseText);</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n<p>如果使用的是Restful的API的话,那么只要把上面<code>fetchOption</code>里面的<code>method</code>改成对应的方法就好.</p>\n<p>当然,封装一个网络请求工具是有必要的,等我有时间写一下.</p>\n","site":{"data":{}},"excerpt":"<p>关于React Native 的网络请求的总结</p>","more":"<p>因为这里使用的是<code>fetch()</code>方法,返回的是一个<code>Promise</code>对象,所以可以使用<code>then()</code>和<code>catch()</code>方法进行链式调用,也可以用<code>all()</code>,<code>race()</code> 去包装多个请求</p>\n<p>具体的话可以看这里</p>\n<h3 id=\"GET\"><a href=\"#GET\" class=\"headerlink\" title=\"GET\"></a>GET</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;get&quot;)</span><br><span class=\"line\">\t.then((response) &#x3D;&gt; response.json()) &#x2F;&#x2F; 这里取出响应体的JSON数据并返回</span><br><span class=\"line\">\t.then((responseJSON) &#x3D;&gt; &#123; &#x2F;&#x2F; 处理上面返回的JSON数据</span><br><span class=\"line\">\t\t&#x2F;&#x2F; do something</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.catch((err) &#x3D;&gt; &#123; &#x2F;&#x2F; 捕获错误</span><br><span class=\"line\">\t\t&#x2F;&#x2F; catch err</span><br><span class=\"line\">\t&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"POST\"><a href=\"#POST\" class=\"headerlink\" title=\"POST\"></a>POST</h3><p>网上说有两种,不过我一般用第二种比较多</p>\n<h4 id=\"application-json\"><a href=\"#application-json\" class=\"headerlink\" title=\"application/json\"></a>application/json</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fetchOptions &#x3D; &#123;</span><br><span class=\"line\">           method: &#39;POST&#39;,</span><br><span class=\"line\">           headers: &#123;</span><br><span class=\"line\">               &#39;Accept&#39;: &#39;application&#x2F;json&#39;,</span><br><span class=\"line\">               &#x2F;&#x2F;json形式</span><br><span class=\"line\">               &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           body:JSON.stringify(&#39;data&#x3D;test&#39;) &#x2F;&#x2F; 这里是请求参数,键值对形式</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fetch(&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;post&quot;, fetchOptions)</span><br><span class=\"line\">   .then((response) &#x3D;&gt; response.json())</span><br><span class=\"line\">   .then((responseText) &#x3D;&gt; &#123;</span><br><span class=\"line\">        console.log(responseText);</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"application-x-www-form-urlencoded\"><a href=\"#application-x-www-form-urlencoded\" class=\"headerlink\" title=\"application/x-www-form-urlencoded\"></a>application/x-www-form-urlencoded</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var fetchOptions &#x3D; &#123;</span><br><span class=\"line\">           method: &#39;POST&#39;,</span><br><span class=\"line\">           headers: &#123;</span><br><span class=\"line\">               &#39;Accept&#39;: &#39;application&#x2F;json&#39;,</span><br><span class=\"line\">               &#x2F;&#x2F;表单</span><br><span class=\"line\">               &#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39;</span><br><span class=\"line\">           &#125;,</span><br><span class=\"line\">           body:&#39;data&#x3D;test&#39; &#x2F;&#x2F; 这里是请求参数,键值对形式</span><br><span class=\"line\">       &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fetch(&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;post&quot;, fetchOptions)</span><br><span class=\"line\">   .then((response) &#x3D;&gt; response.json())</span><br><span class=\"line\">   .then((responseText) &#x3D;&gt; &#123;</span><br><span class=\"line\">        console.log(responseText);</span><br><span class=\"line\">   &#125;);</span><br></pre></td></tr></table></figure>\n<p>如果使用的是Restful的API的话,那么只要把上面<code>fetchOption</code>里面的<code>method</code>改成对应的方法就好.</p>\n<p>当然,封装一个网络请求工具是有必要的,等我有时间写一下.</p>"},{"title":"Salesforce SDK Bug","author":"Arclin","abbrlink":"e88dc875","date":"2018-02-18T13:59:00.000Z","_content":"Salesforce SDK 有几个bug 不修复的话跑不起来 所以在这里记录一下\n\n<!-- more -->\n\n1. `SFOAuthCoordinator` 960行 \n\n```\n   if ([self isRedirectURL:requestUrl]) {\n        [self handleUserAgentResponse:url];\n        decisionHandler(WKNavigationActionPolicyCancel);\n        return;\n    }\n```\n\n2. `SFSDKLoginHostListViewController` `viewDidLoad`最下面的注册cell移动到`viewDidLoad`的第一行\n","source":"_posts/Salesforce-SDK-Bug.md","raw":"---\ntitle: Salesforce SDK Bug\nauthor: Arclin\ntags:\n  - Salesforce\ncategories:\n  - iOS\nabbrlink: e88dc875\ndate: 2018-02-18 21:59:00\n---\nSalesforce SDK 有几个bug 不修复的话跑不起来 所以在这里记录一下\n\n<!-- more -->\n\n1. `SFOAuthCoordinator` 960行 \n\n```\n   if ([self isRedirectURL:requestUrl]) {\n        [self handleUserAgentResponse:url];\n        decisionHandler(WKNavigationActionPolicyCancel);\n        return;\n    }\n```\n\n2. `SFSDKLoginHostListViewController` `viewDidLoad`最下面的注册cell移动到`viewDidLoad`的第一行\n","slug":"Salesforce-SDK-Bug","published":1,"updated":"2021-04-12T06:07:04.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog56001t45n0gwod5o0h","content":"<p>Salesforce SDK 有几个bug 不修复的话跑不起来 所以在这里记录一下</p>\n<span id=\"more\"></span>\n\n<ol>\n<li><code>SFOAuthCoordinator</code> 960行 </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ([self isRedirectURL:requestUrl]) &#123;</span><br><span class=\"line\">     [self handleUserAgentResponse:url];</span><br><span class=\"line\">     decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class=\"line\">     return;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><code>SFSDKLoginHostListViewController</code> <code>viewDidLoad</code>最下面的注册cell移动到<code>viewDidLoad</code>的第一行</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Salesforce SDK 有几个bug 不修复的话跑不起来 所以在这里记录一下</p>","more":"<ol>\n<li><code>SFOAuthCoordinator</code> 960行 </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ([self isRedirectURL:requestUrl]) &#123;</span><br><span class=\"line\">     [self handleUserAgentResponse:url];</span><br><span class=\"line\">     decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class=\"line\">     return;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><code>SFSDKLoginHostListViewController</code> <code>viewDidLoad</code>最下面的注册cell移动到<code>viewDidLoad</code>的第一行</li>\n</ol>"},{"title":"Shell 笔记","author":"Arclin","abbrlink":"cfe784af","date":"2018-05-17T08:10:25.000Z","_content":"Shell 笔记，有机会写就会继续补充\n<!--more-->\n\n1. if语句的中括号要留空格  `if空格[空格 判断语句 空格]; then xxx fi` \n2. 判断买某个路径是否是文件夹  `if [ -d “./xxx” ]; then xxx fi`\n3. 建立一个数组 `check=(\"Wechat\" \"Ali\" \"Union\" \"Pay\")`\n4. 声明一个函数, 并取得第一个参数\n\t```\n    function xxx() {\n    \tdir=$1\n    }\n    ```\n5. 获得某个后缀名的文件 `directory=./${d%.*}\".app\"`\n6. 执行某个命令但不输出到控制台 `unzip $xxx > /dev/null 2>&1`\n7. 声明某个变量为局部变量，使用`local`关键字 `local dir=$1`\n8. 大写转小写 `local file_name_lower=$(echo $file_name | tr 'A-Z' 'a-z')`\n9. 小写转大写 `local file_name_lower=$(echo $file_name | tr 'a-z' 'A-Z')`\n10. 遍历数组\n  ```\n  for item in ${check[@]}; do\n      echo $item\n  done\n  ```\n11. 字符串A是否包含字符串B `if[[ $A =~ $B ]]; then xxx fi`","source":"_posts/Shell-笔记.md","raw":"title: Shell 笔记\nauthor: Arclin\nabbrlink: cfe784af\ndate: 2018-05-17 16:10:25\ntags:\n---\nShell 笔记，有机会写就会继续补充\n<!--more-->\n\n1. if语句的中括号要留空格  `if空格[空格 判断语句 空格]; then xxx fi` \n2. 判断买某个路径是否是文件夹  `if [ -d “./xxx” ]; then xxx fi`\n3. 建立一个数组 `check=(\"Wechat\" \"Ali\" \"Union\" \"Pay\")`\n4. 声明一个函数, 并取得第一个参数\n\t```\n    function xxx() {\n    \tdir=$1\n    }\n    ```\n5. 获得某个后缀名的文件 `directory=./${d%.*}\".app\"`\n6. 执行某个命令但不输出到控制台 `unzip $xxx > /dev/null 2>&1`\n7. 声明某个变量为局部变量，使用`local`关键字 `local dir=$1`\n8. 大写转小写 `local file_name_lower=$(echo $file_name | tr 'A-Z' 'a-z')`\n9. 小写转大写 `local file_name_lower=$(echo $file_name | tr 'a-z' 'A-Z')`\n10. 遍历数组\n  ```\n  for item in ${check[@]}; do\n      echo $item\n  done\n  ```\n11. 字符串A是否包含字符串B `if[[ $A =~ $B ]]; then xxx fi`","slug":"Shell-笔记","published":1,"updated":"2021-04-12T06:07:04.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog57001w45n0g33o78mc","content":"<p>Shell 笔记，有机会写就会继续补充</p>\n<span id=\"more\"></span>\n\n<ol>\n<li>if语句的中括号要留空格  <code>if空格[空格 判断语句 空格]; then xxx fi</code> </li>\n<li>判断买某个路径是否是文件夹  <code>if [ -d “./xxx” ]; then xxx fi</code></li>\n<li>建立一个数组 <code>check=(&quot;Wechat&quot; &quot;Ali&quot; &quot;Union&quot; &quot;Pay&quot;)</code></li>\n<li>声明一个函数, 并取得第一个参数 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function xxx() &#123;</span><br><span class=\"line\">\tdir&#x3D;$1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>获得某个后缀名的文件 <code>directory=./$&#123;d%.*&#125;&quot;.app&quot;</code></li>\n<li>执行某个命令但不输出到控制台 <code>unzip $xxx &gt; /dev/null 2&gt;&amp;1</code></li>\n<li>声明某个变量为局部变量，使用<code>local</code>关键字 <code>local dir=$1</code></li>\n<li>大写转小写 <code>local file_name_lower=$(echo $file_name | tr &#39;A-Z&#39; &#39;a-z&#39;)</code></li>\n<li>小写转大写 <code>local file_name_lower=$(echo $file_name | tr &#39;a-z&#39; &#39;A-Z&#39;)</code></li>\n<li>遍历数组<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for item in $&#123;check[@]&#125;; do</span><br><span class=\"line\">    echo $item</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></li>\n<li>字符串A是否包含字符串B <code>if[[ $A =~ $B ]]; then xxx fi</code></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Shell 笔记，有机会写就会继续补充</p>","more":"<ol>\n<li>if语句的中括号要留空格  <code>if空格[空格 判断语句 空格]; then xxx fi</code> </li>\n<li>判断买某个路径是否是文件夹  <code>if [ -d “./xxx” ]; then xxx fi</code></li>\n<li>建立一个数组 <code>check=(&quot;Wechat&quot; &quot;Ali&quot; &quot;Union&quot; &quot;Pay&quot;)</code></li>\n<li>声明一个函数, 并取得第一个参数 <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function xxx() &#123;</span><br><span class=\"line\">\tdir&#x3D;$1</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>获得某个后缀名的文件 <code>directory=./$&#123;d%.*&#125;&quot;.app&quot;</code></li>\n<li>执行某个命令但不输出到控制台 <code>unzip $xxx &gt; /dev/null 2&gt;&amp;1</code></li>\n<li>声明某个变量为局部变量，使用<code>local</code>关键字 <code>local dir=$1</code></li>\n<li>大写转小写 <code>local file_name_lower=$(echo $file_name | tr &#39;A-Z&#39; &#39;a-z&#39;)</code></li>\n<li>小写转大写 <code>local file_name_lower=$(echo $file_name | tr &#39;a-z&#39; &#39;A-Z&#39;)</code></li>\n<li>遍历数组<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for item in $&#123;check[@]&#125;; do</span><br><span class=\"line\">    echo $item</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></li>\n<li>字符串A是否包含字符串B <code>if[[ $A =~ $B ]]; then xxx fi</code></li>\n</ol>"},{"title":"Sign in with Apple接入指南","author":"Arclin","abbrlink":"ac0a85bd","date":"2019-11-01T05:15:00.000Z","_content":"如果你的应用接入了第三方登陆，那么请同时接入苹果登录。\n\n<!-- more -->\n\n[苹果审核指南的相关内容](https://developer.apple.com/app-store/review/guidelines/#sign-in-with-apple)\n[新闻：2020年4月前需要适配好苹果登录](https://developer.apple.com/news/?id=09122019b)\n\n## 简单接入\n\n[苹果登录官方文档](https://developer.apple.com/sign-in-with-apple/)\n\n流程：\n\n用户点击按钮 --- 调起苹果登录 --- 授权成功 --- 获取唯一标识符和其他信息 --- 返回给后端 --- 后端注册/登录 --- 返回token --- 登录成功\n\n### 必要的工作\n\n1. 首先去苹果后台开启`Sign in with apple`选项，然后重新导出`provisionprofile`证书\n\n2. 授权\n\t```\n\tASAuthorizationAppleIDProvider *provider = [[ASAuthorizationAppleIDProvider alloc] init];\n\tASAuthorizationAppleIDRequest *request = [provider createRequest];\n\trequest.requestedScopes = @[ASAuthorizationScopeFullName, ASAuthorizationScopeEmail];\n\n\tNSMutableArray <ASAuthorizationRequest *>* array = [NSMutableArray arrayWithCapacity:2];\n\tif (request) [array addObject:request];\n\n\tNSArray<ASAuthorizationRequest *> *requests = [array copy];\n\tASAuthorizationController *authorizationController = [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];\n\tauthorizationController.delegate = self;\n\tauthorizationController.presentationContextProvider = input;\n\t[authorizationController performRequests];\n\t```\n\n3. 回调，遵循回调`ASAuthorizationControllerPresentationContextProviding`\n\n\t```\n\t- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization API_AVAILABLE(ios(13.0))\n\t{\n\tif ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) {\n\t\t// 用户登录使用ASAuthorizationAppleIDCredential\n\t\tASAuthorizationAppleIDCredential *appleIDCredential = (ASAuthorizationAppleIDCredential *)authorization.credential;\n\t\tNSString *user = appleIDCredential.user;\n\t\tNSString *namePerfix = appleIDCredential.fullName.namePrefix;\n\t\tNSString *givenName = appleIDCredential.fullName.givenName;\n\t\tNSString *middleName = appleIDCredential.fullName.middleName;\n\t\tNSString *familyName = appleIDCredential.fullName.familyName;\n\t\tNSString *nameSuffix = appleIDCredential.fullName.nameSuffix;\n\t\tNSString *email = appleIDCredential.email;\n\t\tNSString *nickname = appleIDCredential.fullName.nickname;\n\n\t\tif (!nickname || nickname.length == 0) {\n\t\t\tnickname = [NSString stringWithFormat:@\"%@%@%@%@%@\",namePerfix?:@\"\",familyName?:@\"\",givenName?:@\"\",middleName?:@\"\",nameSuffix?:@\"\"];\n\t\t}\n\t} else {\n\t\t[self.errorSubject sendNext:LMError(@\"授权信息有误\")];\n\t}\n\t}\n\t- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithError:(NSError *)error API_AVAILABLE(ios(13.0))\n\t{\n\tNSString *errorMsg = nil;\n\tswitch (error.code) {\n\t\tcase ASAuthorizationErrorCanceled:\n\t\t\t\terrorMsg = @\"用户取消了授权请求\";\n\t\t\t\treturn;\n\t\t\tcase ASAuthorizationErrorFailed:\n\t\t\t\terrorMsg = @\"授权请求失败\";\n\t\t\t\tbreak;\n\t\t\tcase ASAuthorizationErrorInvalidResponse:\n\t\t\t\terrorMsg = @\"授权请求响应无效\";\n\t\t\t\tbreak;\n\t\t\tcase ASAuthorizationErrorNotHandled:\n\t\t\t\terrorMsg = @\"未能处理授权请求\";\n\t\t\t\tbreak;\n\t\t\tcase ASAuthorizationErrorUnknown:\n\t\t\t\terrorMsg = @\"授权请求失败未知原因\";\n\t\t\t\tbreak;\n\t\t}\n\t\t[self.errorSubject sendNext:LMError(errorMsg)];\n\t}\n\t```\n\n## 其他可选项\n\n### 苹果提供的登录按钮\n\n```\nASAuthorizationAppleIDButton *button = [ASAuthorizationAppleIDButton buttonWithType:ASAuthorizationAppleIDButtonTypeSignIn style:ASAuthorizationAppleIDButtonStyleWhiteOutline];\n```\n\n其中\n\n```\ntypedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonType) {\n    ASAuthorizationAppleIDButtonTypeSignIn, // 按钮文字显示 ：通过Apple登录\n    ASAuthorizationAppleIDButtonTypeContinue, // 按钮文字显示 ：通过Apple继续\n\n    ASAuthorizationAppleIDButtonTypeDefault = // 默认第一个 ASAuthorizationAppleIDButtonTypeSignIn,\n}\n\ntypedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonStyle) {\n    ASAuthorizationAppleIDButtonStyleWhite, // 白底黑字\n    ASAuthorizationAppleIDButtonStyleWhiteOutline, // 黑字白框\n    ASAuthorizationAppleIDButtonStyleBlack, // 黑底白字\n}\n\n```\n\n### 授权成功的回调可以来自于其他地方\n\n```\n//! 授权成功地回调\n- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization  API_AVAILABLE(ios(13.0)){\n    \n    NSLog(@\"%s\", __FUNCTION__);\n    NSLog(@\"%@\", controller);\n    NSLog(@\"%@\", authorization);\n    \n    NSLog(@\"authorization.credential：%@\", authorization.credential);\n    \n    NSMutableString *mStr = [NSMutableString string];\n    mStr = [_appleIDInfoTextView.text mutableCopy];\n    \n    if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) {\n        // 用户登录使用ASAuthorizationAppleIDCredential\n        ASAuthorizationAppleIDCredential *appleIDCredential = authorization.credential;\n        NSString *user = appleIDCredential.user;\n        //  最好使用钥匙串的方式保存用户的唯一信息 这里暂且处于测试阶段，用NSUserDefaults\n        [[NSUserDefaults standardUserDefaults] setValue:user forKey:QiShareCurrentIdentifier];\n        [mStr appendString:user?:@\"\"];\n        NSString *familyName = appleIDCredential.fullName.familyName;\n        [mStr appendString:familyName?:@\"\"];\n        NSString *givenName = appleIDCredential.fullName.givenName;\n        [mStr appendString:givenName?:@\"\"];\n        NSString *email = appleIDCredential.email;\n        [mStr appendString:email?:@\"\"];\n        NSLog(@\"mStr：%@\", mStr);\n        [mStr appendString:@\"\\n\"];\n        _appleIDInfoTextView.text = mStr;\n        \n    } else if ([authorization.credential isKindOfClass:[ASPasswordCredential class]]) {\n        // 用户登录使用现有的密码凭证\n        ASPasswordCredential *passwordCredential = authorization.credential;\n        // 密码凭证对象的用户标识 用户的唯一标识\n        NSString *user = passwordCredential.user;\n        // 密码凭证对象的密码\n        NSString *password = passwordCredential.password;\n        [mStr appendString:user?:@\"\"];\n        [mStr appendString:password?:@\"\"];\n        [mStr appendString:@\"\\n\"];\n        NSLog(@\"mStr：%@\", mStr);\n        _appleIDInfoTextView.text = mStr;\n    } else {\n        NSLog(@\"授权信息均不符\");\n        mStr = [@\"授权信息均不符\" mutableCopy];\n        _appleIDInfoTextView.text = mStr;\n    }\n}\n```\n\n### 已经使用Sign In With Apple登录过app的用户\n\n执行已经登录过的场景。如果设备中存在iCloud Keychain 凭证或者AppleID 凭证提示用户直接使用TouchID或FaceID登录即可。\n\n```\n- (void)perfomExistingAccountSetupFlows {\n    if (@available(iOS 13.0, *)) {\n        // A mechanism for generating requests to authenticate users based on their Apple ID.\n        // 基于用户的Apple ID授权用户，生成用户授权请求的一种机制\n        ASAuthorizationAppleIDProvider *appleIDProvider = [ASAuthorizationAppleIDProvider new];\n        // An OpenID authorization request that relies on the user’s Apple ID.\n        // 授权请求依赖于用于的AppleID\n        ASAuthorizationAppleIDRequest *authAppleIDRequest = [appleIDProvider createRequest];\n        // A mechanism for generating requests to perform keychain credential sharing.\n        // 为了执行钥匙串凭证分享生成请求的一种机制\n        ASAuthorizationPasswordRequest *passwordRequest = [[ASAuthorizationPasswordProvider new] createRequest];\n        \n        NSMutableArray <ASAuthorizationRequest *>* mArr = [NSMutableArray arrayWithCapacity:2];\n        if (authAppleIDRequest) {\n            [mArr addObject:authAppleIDRequest];\n        }\n        if (passwordRequest) {\n            [mArr addObject:passwordRequest];\n        }\n        // ASAuthorizationRequest：A base class for different kinds of authorization requests.\n        // ASAuthorizationRequest：对于不同种类授权请求的基类\n        NSArray <ASAuthorizationRequest *>* requests = [mArr copy];\n        \n        // A controller that manages authorization requests created by a provider.\n        // 由ASAuthorizationAppleIDProvider创建的授权请求 管理授权请求的控制器\n        // Creates a controller from a collection of authorization requests.\n        // 从一系列授权请求中创建授权控制器\n        ASAuthorizationController *authorizationController = [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];\n        // A delegate that the authorization controller informs about the success or failure of an authorization attempt.\n        // 设置授权控制器通知授权请求的成功与失败的代理\n        authorizationController.delegate = self;\n        // A delegate that provides a display context in which the system can present an authorization interface to the user.\n        // 设置提供 展示上下文的代理，在这个上下文中 系统可以展示授权界面给用户\n        authorizationController.presentationContextProvider = self;\n        // starts the authorization flows named during controller initialization.\n        // 在控制器初始化期间启动授权流\n        [authorizationController performRequests];\n    }\n}\n```\n\n### 监听授权状态变化\n\n监听授权状态改变，并且做出相应处理。授权状态有：\n\n```\nASAuthorizationAppleIDProviderCredentialRevoked：授权状态失效（用户停止使用AppID 登录App）\nASAuthorizationAppleIDProviderCredentialAuthorized：已授权(已使用AppleID 登录过App）\nASAuthorizationAppleIDProviderCredentialNotFound：授权凭证缺失（可能是使用AppleID 登录过App）\n```\n\n```\n//! 观察授权状态\n- (void)observeAuthticationState {\n    \n    if (@available(iOS 13.0, *)) {\n        // A mechanism for generating requests to authenticate users based on their Apple ID.\n        // 基于用户的Apple ID 生成授权用户请求的机制\n        ASAuthorizationAppleIDProvider *appleIDProvider = [ASAuthorizationAppleIDProvider new];\n        // 注意 存储用户标识信息需要使用钥匙串来存储 这里笔者简单期间 使用NSUserDefaults 做的简单示例\n        NSString *userIdentifier = [[NSUserDefaults standardUserDefaults] valueForKey:QiShareCurrentIdentifier];\n        \n        if (userIdentifier) {\n            NSString* __block errorMsg = nil;\n            //Returns the credential state for the given user in a completion handler.\n            // 在回调中返回用户的授权状态\n            [appleIDProvider getCredentialStateForUserID:userIdentifier completion:^(ASAuthorizationAppleIDProviderCredentialState credentialState, NSError * _Nullable error) {\n                switch (credentialState) {\n                        // 苹果证书的授权状态\n                    case ASAuthorizationAppleIDProviderCredentialRevoked:\n                        // 苹果授权凭证失效\n                        errorMsg = @\"苹果授权凭证失效\";\n                        break;\n                    case ASAuthorizationAppleIDProviderCredentialAuthorized:\n                        // 苹果授权凭证状态良好\n                        errorMsg = @\"苹果授权凭证状态良好\";\n                        break;\n                    case ASAuthorizationAppleIDProviderCredentialNotFound:\n                        // 未发现苹果授权凭证\n                        errorMsg = @\"未发现苹果授权凭证\";\n                        // 可以引导用户重新登录\n                        break;\n                }\n                dispatch_async(dispatch_get_main_queue(), ^{\n                    NSLog(@\"SignInWithApple授权状态变化情况\");\n                    NSLog(@\"%@\", errorMsg);\n                });\n            }];\n            \n        }\n    }\n}\n```\n\n使用通知的方式检测是否授权应用支持Sign In With Apple变化情况。如下的代码可以根据自己的业务场景去考虑放置的位置。\n\n```\n//! 添加苹果登录的状态通知\n- (void)observeAppleSignInState {\n    if (@available(iOS 13.0, *)) {\n        NSNotificationCenter *center = [NSNotificationCenter defaultCenter];\n        [center addObserver:self selector:@selector(handleSignInWithAppleStateChanged:) name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];\n    }\n}\n \n//! 观察SignInWithApple状态改变\n- (void)handleSignInWithAppleStateChanged:(id)noti {\n    \n    NSLog(@\"%s\", __FUNCTION__);\n    NSLog(@\"%@\", noti);\n}\n \n- (void)dealloc {\n    \n    if (@available(iOS 13.0, *)) {\n        [[NSNotificationCenter defaultCenter] removeObserver:self name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];\n    }\n}\n```\n\n## 重要（Important！）\n1. 最好使用苹果提供的按钮 `ASAuthorizationAppleIDButton` （只有黑白两种颜色）\n2. 不用他的按钮的话建议使用显眼的颜色 \n3. 尽量放在显眼位置（第一位）\n4. **不能比其他任何登录按钮要小**\n5. 保证登录页面一屏就能看到苹果登录按钮，不能滚动后才能看到\n6. 按钮的最小宽高有需求（看[苹果人机交互指南相关文档](https://developer.apple.com/design/human-interface-guidelines/sign-in-with-apple/overview/)）\n7. 如果登录后要绑定手机的话，就在备注里面写好 依据来源 http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm  指明(截图)第二十四条（苹果一般不会打开网页，建议下载个pdf给他）\n8. 如果不好好跟苹果爸爸的规矩来，那么可能会吃到2.1和4.0 (不要问我为什么知道)\n\n(更新至2019/11/01)\n\n|  最小宽度 | 最小高度  | 最小间距|\n| ------------ | ------------ | ------------ |\n| 140pt (140px @1x, 280px @2x)  |  30pt (30px @1x, 60px @2x) | 1/10 of the button's height）| \n\n## 参考其他教程\n\n[掘金](https://juejin.im/post/5d8c64d151882509606d6b17)\n","source":"_posts/Sign-in-with-Apple接入指南.md","raw":"title: Sign in with Apple接入指南\nauthor: Arclin\nabbrlink: ac0a85bd\ntags:\n  - iOS\ncategories:\n  - iOS\ndate: 2019-11-01 13:15:00\n---\n如果你的应用接入了第三方登陆，那么请同时接入苹果登录。\n\n<!-- more -->\n\n[苹果审核指南的相关内容](https://developer.apple.com/app-store/review/guidelines/#sign-in-with-apple)\n[新闻：2020年4月前需要适配好苹果登录](https://developer.apple.com/news/?id=09122019b)\n\n## 简单接入\n\n[苹果登录官方文档](https://developer.apple.com/sign-in-with-apple/)\n\n流程：\n\n用户点击按钮 --- 调起苹果登录 --- 授权成功 --- 获取唯一标识符和其他信息 --- 返回给后端 --- 后端注册/登录 --- 返回token --- 登录成功\n\n### 必要的工作\n\n1. 首先去苹果后台开启`Sign in with apple`选项，然后重新导出`provisionprofile`证书\n\n2. 授权\n\t```\n\tASAuthorizationAppleIDProvider *provider = [[ASAuthorizationAppleIDProvider alloc] init];\n\tASAuthorizationAppleIDRequest *request = [provider createRequest];\n\trequest.requestedScopes = @[ASAuthorizationScopeFullName, ASAuthorizationScopeEmail];\n\n\tNSMutableArray <ASAuthorizationRequest *>* array = [NSMutableArray arrayWithCapacity:2];\n\tif (request) [array addObject:request];\n\n\tNSArray<ASAuthorizationRequest *> *requests = [array copy];\n\tASAuthorizationController *authorizationController = [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];\n\tauthorizationController.delegate = self;\n\tauthorizationController.presentationContextProvider = input;\n\t[authorizationController performRequests];\n\t```\n\n3. 回调，遵循回调`ASAuthorizationControllerPresentationContextProviding`\n\n\t```\n\t- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization API_AVAILABLE(ios(13.0))\n\t{\n\tif ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) {\n\t\t// 用户登录使用ASAuthorizationAppleIDCredential\n\t\tASAuthorizationAppleIDCredential *appleIDCredential = (ASAuthorizationAppleIDCredential *)authorization.credential;\n\t\tNSString *user = appleIDCredential.user;\n\t\tNSString *namePerfix = appleIDCredential.fullName.namePrefix;\n\t\tNSString *givenName = appleIDCredential.fullName.givenName;\n\t\tNSString *middleName = appleIDCredential.fullName.middleName;\n\t\tNSString *familyName = appleIDCredential.fullName.familyName;\n\t\tNSString *nameSuffix = appleIDCredential.fullName.nameSuffix;\n\t\tNSString *email = appleIDCredential.email;\n\t\tNSString *nickname = appleIDCredential.fullName.nickname;\n\n\t\tif (!nickname || nickname.length == 0) {\n\t\t\tnickname = [NSString stringWithFormat:@\"%@%@%@%@%@\",namePerfix?:@\"\",familyName?:@\"\",givenName?:@\"\",middleName?:@\"\",nameSuffix?:@\"\"];\n\t\t}\n\t} else {\n\t\t[self.errorSubject sendNext:LMError(@\"授权信息有误\")];\n\t}\n\t}\n\t- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithError:(NSError *)error API_AVAILABLE(ios(13.0))\n\t{\n\tNSString *errorMsg = nil;\n\tswitch (error.code) {\n\t\tcase ASAuthorizationErrorCanceled:\n\t\t\t\terrorMsg = @\"用户取消了授权请求\";\n\t\t\t\treturn;\n\t\t\tcase ASAuthorizationErrorFailed:\n\t\t\t\terrorMsg = @\"授权请求失败\";\n\t\t\t\tbreak;\n\t\t\tcase ASAuthorizationErrorInvalidResponse:\n\t\t\t\terrorMsg = @\"授权请求响应无效\";\n\t\t\t\tbreak;\n\t\t\tcase ASAuthorizationErrorNotHandled:\n\t\t\t\terrorMsg = @\"未能处理授权请求\";\n\t\t\t\tbreak;\n\t\t\tcase ASAuthorizationErrorUnknown:\n\t\t\t\terrorMsg = @\"授权请求失败未知原因\";\n\t\t\t\tbreak;\n\t\t}\n\t\t[self.errorSubject sendNext:LMError(errorMsg)];\n\t}\n\t```\n\n## 其他可选项\n\n### 苹果提供的登录按钮\n\n```\nASAuthorizationAppleIDButton *button = [ASAuthorizationAppleIDButton buttonWithType:ASAuthorizationAppleIDButtonTypeSignIn style:ASAuthorizationAppleIDButtonStyleWhiteOutline];\n```\n\n其中\n\n```\ntypedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonType) {\n    ASAuthorizationAppleIDButtonTypeSignIn, // 按钮文字显示 ：通过Apple登录\n    ASAuthorizationAppleIDButtonTypeContinue, // 按钮文字显示 ：通过Apple继续\n\n    ASAuthorizationAppleIDButtonTypeDefault = // 默认第一个 ASAuthorizationAppleIDButtonTypeSignIn,\n}\n\ntypedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonStyle) {\n    ASAuthorizationAppleIDButtonStyleWhite, // 白底黑字\n    ASAuthorizationAppleIDButtonStyleWhiteOutline, // 黑字白框\n    ASAuthorizationAppleIDButtonStyleBlack, // 黑底白字\n}\n\n```\n\n### 授权成功的回调可以来自于其他地方\n\n```\n//! 授权成功地回调\n- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization  API_AVAILABLE(ios(13.0)){\n    \n    NSLog(@\"%s\", __FUNCTION__);\n    NSLog(@\"%@\", controller);\n    NSLog(@\"%@\", authorization);\n    \n    NSLog(@\"authorization.credential：%@\", authorization.credential);\n    \n    NSMutableString *mStr = [NSMutableString string];\n    mStr = [_appleIDInfoTextView.text mutableCopy];\n    \n    if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) {\n        // 用户登录使用ASAuthorizationAppleIDCredential\n        ASAuthorizationAppleIDCredential *appleIDCredential = authorization.credential;\n        NSString *user = appleIDCredential.user;\n        //  最好使用钥匙串的方式保存用户的唯一信息 这里暂且处于测试阶段，用NSUserDefaults\n        [[NSUserDefaults standardUserDefaults] setValue:user forKey:QiShareCurrentIdentifier];\n        [mStr appendString:user?:@\"\"];\n        NSString *familyName = appleIDCredential.fullName.familyName;\n        [mStr appendString:familyName?:@\"\"];\n        NSString *givenName = appleIDCredential.fullName.givenName;\n        [mStr appendString:givenName?:@\"\"];\n        NSString *email = appleIDCredential.email;\n        [mStr appendString:email?:@\"\"];\n        NSLog(@\"mStr：%@\", mStr);\n        [mStr appendString:@\"\\n\"];\n        _appleIDInfoTextView.text = mStr;\n        \n    } else if ([authorization.credential isKindOfClass:[ASPasswordCredential class]]) {\n        // 用户登录使用现有的密码凭证\n        ASPasswordCredential *passwordCredential = authorization.credential;\n        // 密码凭证对象的用户标识 用户的唯一标识\n        NSString *user = passwordCredential.user;\n        // 密码凭证对象的密码\n        NSString *password = passwordCredential.password;\n        [mStr appendString:user?:@\"\"];\n        [mStr appendString:password?:@\"\"];\n        [mStr appendString:@\"\\n\"];\n        NSLog(@\"mStr：%@\", mStr);\n        _appleIDInfoTextView.text = mStr;\n    } else {\n        NSLog(@\"授权信息均不符\");\n        mStr = [@\"授权信息均不符\" mutableCopy];\n        _appleIDInfoTextView.text = mStr;\n    }\n}\n```\n\n### 已经使用Sign In With Apple登录过app的用户\n\n执行已经登录过的场景。如果设备中存在iCloud Keychain 凭证或者AppleID 凭证提示用户直接使用TouchID或FaceID登录即可。\n\n```\n- (void)perfomExistingAccountSetupFlows {\n    if (@available(iOS 13.0, *)) {\n        // A mechanism for generating requests to authenticate users based on their Apple ID.\n        // 基于用户的Apple ID授权用户，生成用户授权请求的一种机制\n        ASAuthorizationAppleIDProvider *appleIDProvider = [ASAuthorizationAppleIDProvider new];\n        // An OpenID authorization request that relies on the user’s Apple ID.\n        // 授权请求依赖于用于的AppleID\n        ASAuthorizationAppleIDRequest *authAppleIDRequest = [appleIDProvider createRequest];\n        // A mechanism for generating requests to perform keychain credential sharing.\n        // 为了执行钥匙串凭证分享生成请求的一种机制\n        ASAuthorizationPasswordRequest *passwordRequest = [[ASAuthorizationPasswordProvider new] createRequest];\n        \n        NSMutableArray <ASAuthorizationRequest *>* mArr = [NSMutableArray arrayWithCapacity:2];\n        if (authAppleIDRequest) {\n            [mArr addObject:authAppleIDRequest];\n        }\n        if (passwordRequest) {\n            [mArr addObject:passwordRequest];\n        }\n        // ASAuthorizationRequest：A base class for different kinds of authorization requests.\n        // ASAuthorizationRequest：对于不同种类授权请求的基类\n        NSArray <ASAuthorizationRequest *>* requests = [mArr copy];\n        \n        // A controller that manages authorization requests created by a provider.\n        // 由ASAuthorizationAppleIDProvider创建的授权请求 管理授权请求的控制器\n        // Creates a controller from a collection of authorization requests.\n        // 从一系列授权请求中创建授权控制器\n        ASAuthorizationController *authorizationController = [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];\n        // A delegate that the authorization controller informs about the success or failure of an authorization attempt.\n        // 设置授权控制器通知授权请求的成功与失败的代理\n        authorizationController.delegate = self;\n        // A delegate that provides a display context in which the system can present an authorization interface to the user.\n        // 设置提供 展示上下文的代理，在这个上下文中 系统可以展示授权界面给用户\n        authorizationController.presentationContextProvider = self;\n        // starts the authorization flows named during controller initialization.\n        // 在控制器初始化期间启动授权流\n        [authorizationController performRequests];\n    }\n}\n```\n\n### 监听授权状态变化\n\n监听授权状态改变，并且做出相应处理。授权状态有：\n\n```\nASAuthorizationAppleIDProviderCredentialRevoked：授权状态失效（用户停止使用AppID 登录App）\nASAuthorizationAppleIDProviderCredentialAuthorized：已授权(已使用AppleID 登录过App）\nASAuthorizationAppleIDProviderCredentialNotFound：授权凭证缺失（可能是使用AppleID 登录过App）\n```\n\n```\n//! 观察授权状态\n- (void)observeAuthticationState {\n    \n    if (@available(iOS 13.0, *)) {\n        // A mechanism for generating requests to authenticate users based on their Apple ID.\n        // 基于用户的Apple ID 生成授权用户请求的机制\n        ASAuthorizationAppleIDProvider *appleIDProvider = [ASAuthorizationAppleIDProvider new];\n        // 注意 存储用户标识信息需要使用钥匙串来存储 这里笔者简单期间 使用NSUserDefaults 做的简单示例\n        NSString *userIdentifier = [[NSUserDefaults standardUserDefaults] valueForKey:QiShareCurrentIdentifier];\n        \n        if (userIdentifier) {\n            NSString* __block errorMsg = nil;\n            //Returns the credential state for the given user in a completion handler.\n            // 在回调中返回用户的授权状态\n            [appleIDProvider getCredentialStateForUserID:userIdentifier completion:^(ASAuthorizationAppleIDProviderCredentialState credentialState, NSError * _Nullable error) {\n                switch (credentialState) {\n                        // 苹果证书的授权状态\n                    case ASAuthorizationAppleIDProviderCredentialRevoked:\n                        // 苹果授权凭证失效\n                        errorMsg = @\"苹果授权凭证失效\";\n                        break;\n                    case ASAuthorizationAppleIDProviderCredentialAuthorized:\n                        // 苹果授权凭证状态良好\n                        errorMsg = @\"苹果授权凭证状态良好\";\n                        break;\n                    case ASAuthorizationAppleIDProviderCredentialNotFound:\n                        // 未发现苹果授权凭证\n                        errorMsg = @\"未发现苹果授权凭证\";\n                        // 可以引导用户重新登录\n                        break;\n                }\n                dispatch_async(dispatch_get_main_queue(), ^{\n                    NSLog(@\"SignInWithApple授权状态变化情况\");\n                    NSLog(@\"%@\", errorMsg);\n                });\n            }];\n            \n        }\n    }\n}\n```\n\n使用通知的方式检测是否授权应用支持Sign In With Apple变化情况。如下的代码可以根据自己的业务场景去考虑放置的位置。\n\n```\n//! 添加苹果登录的状态通知\n- (void)observeAppleSignInState {\n    if (@available(iOS 13.0, *)) {\n        NSNotificationCenter *center = [NSNotificationCenter defaultCenter];\n        [center addObserver:self selector:@selector(handleSignInWithAppleStateChanged:) name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];\n    }\n}\n \n//! 观察SignInWithApple状态改变\n- (void)handleSignInWithAppleStateChanged:(id)noti {\n    \n    NSLog(@\"%s\", __FUNCTION__);\n    NSLog(@\"%@\", noti);\n}\n \n- (void)dealloc {\n    \n    if (@available(iOS 13.0, *)) {\n        [[NSNotificationCenter defaultCenter] removeObserver:self name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];\n    }\n}\n```\n\n## 重要（Important！）\n1. 最好使用苹果提供的按钮 `ASAuthorizationAppleIDButton` （只有黑白两种颜色）\n2. 不用他的按钮的话建议使用显眼的颜色 \n3. 尽量放在显眼位置（第一位）\n4. **不能比其他任何登录按钮要小**\n5. 保证登录页面一屏就能看到苹果登录按钮，不能滚动后才能看到\n6. 按钮的最小宽高有需求（看[苹果人机交互指南相关文档](https://developer.apple.com/design/human-interface-guidelines/sign-in-with-apple/overview/)）\n7. 如果登录后要绑定手机的话，就在备注里面写好 依据来源 http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm  指明(截图)第二十四条（苹果一般不会打开网页，建议下载个pdf给他）\n8. 如果不好好跟苹果爸爸的规矩来，那么可能会吃到2.1和4.0 (不要问我为什么知道)\n\n(更新至2019/11/01)\n\n|  最小宽度 | 最小高度  | 最小间距|\n| ------------ | ------------ | ------------ |\n| 140pt (140px @1x, 280px @2x)  |  30pt (30px @1x, 60px @2x) | 1/10 of the button's height）| \n\n## 参考其他教程\n\n[掘金](https://juejin.im/post/5d8c64d151882509606d6b17)\n","slug":"Sign-in-with-Apple接入指南","published":1,"updated":"2021-04-12T06:07:04.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog58002145n0h67623sd","content":"<p>如果你的应用接入了第三方登陆，那么请同时接入苹果登录。</p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://developer.apple.com/app-store/review/guidelines/#sign-in-with-apple\">苹果审核指南的相关内容</a><br><a href=\"https://developer.apple.com/news/?id=09122019b\">新闻：2020年4月前需要适配好苹果登录</a></p>\n<h2 id=\"简单接入\"><a href=\"#简单接入\" class=\"headerlink\" title=\"简单接入\"></a>简单接入</h2><p><a href=\"https://developer.apple.com/sign-in-with-apple/\">苹果登录官方文档</a></p>\n<p>流程：</p>\n<p>用户点击按钮 — 调起苹果登录 — 授权成功 — 获取唯一标识符和其他信息 — 返回给后端 — 后端注册/登录 — 返回token — 登录成功</p>\n<h3 id=\"必要的工作\"><a href=\"#必要的工作\" class=\"headerlink\" title=\"必要的工作\"></a>必要的工作</h3><ol>\n<li><p>首先去苹果后台开启<code>Sign in with apple</code>选项，然后重新导出<code>provisionprofile</code>证书</p>\n</li>\n<li><p>授权</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASAuthorizationAppleIDProvider *provider &#x3D; [[ASAuthorizationAppleIDProvider alloc] init];</span><br><span class=\"line\">ASAuthorizationAppleIDRequest *request &#x3D; [provider createRequest];</span><br><span class=\"line\">request.requestedScopes &#x3D; @[ASAuthorizationScopeFullName, ASAuthorizationScopeEmail];</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableArray &lt;ASAuthorizationRequest *&gt;* array &#x3D; [NSMutableArray arrayWithCapacity:2];</span><br><span class=\"line\">if (request) [array addObject:request];</span><br><span class=\"line\"></span><br><span class=\"line\">NSArray&lt;ASAuthorizationRequest *&gt; *requests &#x3D; [array copy];</span><br><span class=\"line\">ASAuthorizationController *authorizationController &#x3D; [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];</span><br><span class=\"line\">authorizationController.delegate &#x3D; self;</span><br><span class=\"line\">authorizationController.presentationContextProvider &#x3D; input;</span><br><span class=\"line\">[authorizationController performRequests];</span><br></pre></td></tr></table></figure></li>\n<li><p>回调，遵循回调<code>ASAuthorizationControllerPresentationContextProviding</code></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization API_AVAILABLE(ios(13.0))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 用户登录使用ASAuthorizationAppleIDCredential</span><br><span class=\"line\">\tASAuthorizationAppleIDCredential *appleIDCredential &#x3D; (ASAuthorizationAppleIDCredential *)authorization.credential;</span><br><span class=\"line\">\tNSString *user &#x3D; appleIDCredential.user;</span><br><span class=\"line\">\tNSString *namePerfix &#x3D; appleIDCredential.fullName.namePrefix;</span><br><span class=\"line\">\tNSString *givenName &#x3D; appleIDCredential.fullName.givenName;</span><br><span class=\"line\">\tNSString *middleName &#x3D; appleIDCredential.fullName.middleName;</span><br><span class=\"line\">\tNSString *familyName &#x3D; appleIDCredential.fullName.familyName;</span><br><span class=\"line\">\tNSString *nameSuffix &#x3D; appleIDCredential.fullName.nameSuffix;</span><br><span class=\"line\">\tNSString *email &#x3D; appleIDCredential.email;</span><br><span class=\"line\">\tNSString *nickname &#x3D; appleIDCredential.fullName.nickname;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!nickname || nickname.length &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">\t\tnickname &#x3D; [NSString stringWithFormat:@&quot;%@%@%@%@%@&quot;,namePerfix?:@&quot;&quot;,familyName?:@&quot;&quot;,givenName?:@&quot;&quot;,middleName?:@&quot;&quot;,nameSuffix?:@&quot;&quot;];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">\t[self.errorSubject sendNext:LMError(@&quot;授权信息有误&quot;)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithError:(NSError *)error API_AVAILABLE(ios(13.0))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">NSString *errorMsg &#x3D; nil;</span><br><span class=\"line\">switch (error.code) &#123;</span><br><span class=\"line\">\tcase ASAuthorizationErrorCanceled:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;用户取消了授权请求&quot;;</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\tcase ASAuthorizationErrorFailed:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;授权请求失败&quot;;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase ASAuthorizationErrorInvalidResponse:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;授权请求响应无效&quot;;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase ASAuthorizationErrorNotHandled:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;未能处理授权请求&quot;;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase ASAuthorizationErrorUnknown:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;授权请求失败未知原因&quot;;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t[self.errorSubject sendNext:LMError(errorMsg)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"其他可选项\"><a href=\"#其他可选项\" class=\"headerlink\" title=\"其他可选项\"></a>其他可选项</h2><h3 id=\"苹果提供的登录按钮\"><a href=\"#苹果提供的登录按钮\" class=\"headerlink\" title=\"苹果提供的登录按钮\"></a>苹果提供的登录按钮</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASAuthorizationAppleIDButton *button &#x3D; [ASAuthorizationAppleIDButton buttonWithType:ASAuthorizationAppleIDButtonTypeSignIn style:ASAuthorizationAppleIDButtonStyleWhiteOutline];</span><br></pre></td></tr></table></figure>\n\n<p>其中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonType) &#123;</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonTypeSignIn, &#x2F;&#x2F; 按钮文字显示 ：通过Apple登录</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonTypeContinue, &#x2F;&#x2F; 按钮文字显示 ：通过Apple继续</span><br><span class=\"line\"></span><br><span class=\"line\">    ASAuthorizationAppleIDButtonTypeDefault &#x3D; &#x2F;&#x2F; 默认第一个 ASAuthorizationAppleIDButtonTypeSignIn,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonStyle) &#123;</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonStyleWhite, &#x2F;&#x2F; 白底黑字</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonStyleWhiteOutline, &#x2F;&#x2F; 黑字白框</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonStyleBlack, &#x2F;&#x2F; 黑底白字</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"授权成功的回调可以来自于其他地方\"><a href=\"#授权成功的回调可以来自于其他地方\" class=\"headerlink\" title=\"授权成功的回调可以来自于其他地方\"></a>授权成功的回调可以来自于其他地方</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;! 授权成功地回调</span><br><span class=\"line\">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization  API_AVAILABLE(ios(13.0))&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;, controller);</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;, authorization);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;authorization.credential：%@&quot;, authorization.credential);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSMutableString *mStr &#x3D; [NSMutableString string];</span><br><span class=\"line\">    mStr &#x3D; [_appleIDInfoTextView.text mutableCopy];</span><br><span class=\"line\">    </span><br><span class=\"line\">    if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 用户登录使用ASAuthorizationAppleIDCredential</span><br><span class=\"line\">        ASAuthorizationAppleIDCredential *appleIDCredential &#x3D; authorization.credential;</span><br><span class=\"line\">        NSString *user &#x3D; appleIDCredential.user;</span><br><span class=\"line\">        &#x2F;&#x2F;  最好使用钥匙串的方式保存用户的唯一信息 这里暂且处于测试阶段，用NSUserDefaults</span><br><span class=\"line\">        [[NSUserDefaults standardUserDefaults] setValue:user forKey:QiShareCurrentIdentifier];</span><br><span class=\"line\">        [mStr appendString:user?:@&quot;&quot;];</span><br><span class=\"line\">        NSString *familyName &#x3D; appleIDCredential.fullName.familyName;</span><br><span class=\"line\">        [mStr appendString:familyName?:@&quot;&quot;];</span><br><span class=\"line\">        NSString *givenName &#x3D; appleIDCredential.fullName.givenName;</span><br><span class=\"line\">        [mStr appendString:givenName?:@&quot;&quot;];</span><br><span class=\"line\">        NSString *email &#x3D; appleIDCredential.email;</span><br><span class=\"line\">        [mStr appendString:email?:@&quot;&quot;];</span><br><span class=\"line\">        NSLog(@&quot;mStr：%@&quot;, mStr);</span><br><span class=\"line\">        [mStr appendString:@&quot;\\n&quot;];</span><br><span class=\"line\">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; else if ([authorization.credential isKindOfClass:[ASPasswordCredential class]]) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 用户登录使用现有的密码凭证</span><br><span class=\"line\">        ASPasswordCredential *passwordCredential &#x3D; authorization.credential;</span><br><span class=\"line\">        &#x2F;&#x2F; 密码凭证对象的用户标识 用户的唯一标识</span><br><span class=\"line\">        NSString *user &#x3D; passwordCredential.user;</span><br><span class=\"line\">        &#x2F;&#x2F; 密码凭证对象的密码</span><br><span class=\"line\">        NSString *password &#x3D; passwordCredential.password;</span><br><span class=\"line\">        [mStr appendString:user?:@&quot;&quot;];</span><br><span class=\"line\">        [mStr appendString:password?:@&quot;&quot;];</span><br><span class=\"line\">        [mStr appendString:@&quot;\\n&quot;];</span><br><span class=\"line\">        NSLog(@&quot;mStr：%@&quot;, mStr);</span><br><span class=\"line\">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        NSLog(@&quot;授权信息均不符&quot;);</span><br><span class=\"line\">        mStr &#x3D; [@&quot;授权信息均不符&quot; mutableCopy];</span><br><span class=\"line\">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"已经使用Sign-In-With-Apple登录过app的用户\"><a href=\"#已经使用Sign-In-With-Apple登录过app的用户\" class=\"headerlink\" title=\"已经使用Sign In With Apple登录过app的用户\"></a>已经使用Sign In With Apple登录过app的用户</h3><p>执行已经登录过的场景。如果设备中存在iCloud Keychain 凭证或者AppleID 凭证提示用户直接使用TouchID或FaceID登录即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)perfomExistingAccountSetupFlows &#123;</span><br><span class=\"line\">    if (@available(iOS 13.0, *)) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; A mechanism for generating requests to authenticate users based on their Apple ID.</span><br><span class=\"line\">        &#x2F;&#x2F; 基于用户的Apple ID授权用户，生成用户授权请求的一种机制</span><br><span class=\"line\">        ASAuthorizationAppleIDProvider *appleIDProvider &#x3D; [ASAuthorizationAppleIDProvider new];</span><br><span class=\"line\">        &#x2F;&#x2F; An OpenID authorization request that relies on the user’s Apple ID.</span><br><span class=\"line\">        &#x2F;&#x2F; 授权请求依赖于用于的AppleID</span><br><span class=\"line\">        ASAuthorizationAppleIDRequest *authAppleIDRequest &#x3D; [appleIDProvider createRequest];</span><br><span class=\"line\">        &#x2F;&#x2F; A mechanism for generating requests to perform keychain credential sharing.</span><br><span class=\"line\">        &#x2F;&#x2F; 为了执行钥匙串凭证分享生成请求的一种机制</span><br><span class=\"line\">        ASAuthorizationPasswordRequest *passwordRequest &#x3D; [[ASAuthorizationPasswordProvider new] createRequest];</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSMutableArray &lt;ASAuthorizationRequest *&gt;* mArr &#x3D; [NSMutableArray arrayWithCapacity:2];</span><br><span class=\"line\">        if (authAppleIDRequest) &#123;</span><br><span class=\"line\">            [mArr addObject:authAppleIDRequest];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (passwordRequest) &#123;</span><br><span class=\"line\">            [mArr addObject:passwordRequest];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; ASAuthorizationRequest：A base class for different kinds of authorization requests.</span><br><span class=\"line\">        &#x2F;&#x2F; ASAuthorizationRequest：对于不同种类授权请求的基类</span><br><span class=\"line\">        NSArray &lt;ASAuthorizationRequest *&gt;* requests &#x3D; [mArr copy];</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#x2F;&#x2F; A controller that manages authorization requests created by a provider.</span><br><span class=\"line\">        &#x2F;&#x2F; 由ASAuthorizationAppleIDProvider创建的授权请求 管理授权请求的控制器</span><br><span class=\"line\">        &#x2F;&#x2F; Creates a controller from a collection of authorization requests.</span><br><span class=\"line\">        &#x2F;&#x2F; 从一系列授权请求中创建授权控制器</span><br><span class=\"line\">        ASAuthorizationController *authorizationController &#x3D; [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];</span><br><span class=\"line\">        &#x2F;&#x2F; A delegate that the authorization controller informs about the success or failure of an authorization attempt.</span><br><span class=\"line\">        &#x2F;&#x2F; 设置授权控制器通知授权请求的成功与失败的代理</span><br><span class=\"line\">        authorizationController.delegate &#x3D; self;</span><br><span class=\"line\">        &#x2F;&#x2F; A delegate that provides a display context in which the system can present an authorization interface to the user.</span><br><span class=\"line\">        &#x2F;&#x2F; 设置提供 展示上下文的代理，在这个上下文中 系统可以展示授权界面给用户</span><br><span class=\"line\">        authorizationController.presentationContextProvider &#x3D; self;</span><br><span class=\"line\">        &#x2F;&#x2F; starts the authorization flows named during controller initialization.</span><br><span class=\"line\">        &#x2F;&#x2F; 在控制器初始化期间启动授权流</span><br><span class=\"line\">        [authorizationController performRequests];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"监听授权状态变化\"><a href=\"#监听授权状态变化\" class=\"headerlink\" title=\"监听授权状态变化\"></a>监听授权状态变化</h3><p>监听授权状态改变，并且做出相应处理。授权状态有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASAuthorizationAppleIDProviderCredentialRevoked：授权状态失效（用户停止使用AppID 登录App）</span><br><span class=\"line\">ASAuthorizationAppleIDProviderCredentialAuthorized：已授权(已使用AppleID 登录过App）</span><br><span class=\"line\">ASAuthorizationAppleIDProviderCredentialNotFound：授权凭证缺失（可能是使用AppleID 登录过App）</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;! 观察授权状态</span><br><span class=\"line\">- (void)observeAuthticationState &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (@available(iOS 13.0, *)) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; A mechanism for generating requests to authenticate users based on their Apple ID.</span><br><span class=\"line\">        &#x2F;&#x2F; 基于用户的Apple ID 生成授权用户请求的机制</span><br><span class=\"line\">        ASAuthorizationAppleIDProvider *appleIDProvider &#x3D; [ASAuthorizationAppleIDProvider new];</span><br><span class=\"line\">        &#x2F;&#x2F; 注意 存储用户标识信息需要使用钥匙串来存储 这里笔者简单期间 使用NSUserDefaults 做的简单示例</span><br><span class=\"line\">        NSString *userIdentifier &#x3D; [[NSUserDefaults standardUserDefaults] valueForKey:QiShareCurrentIdentifier];</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (userIdentifier) &#123;</span><br><span class=\"line\">            NSString* __block errorMsg &#x3D; nil;</span><br><span class=\"line\">            &#x2F;&#x2F;Returns the credential state for the given user in a completion handler.</span><br><span class=\"line\">            &#x2F;&#x2F; 在回调中返回用户的授权状态</span><br><span class=\"line\">            [appleIDProvider getCredentialStateForUserID:userIdentifier completion:^(ASAuthorizationAppleIDProviderCredentialState credentialState, NSError * _Nullable error) &#123;</span><br><span class=\"line\">                switch (credentialState) &#123;</span><br><span class=\"line\">                        &#x2F;&#x2F; 苹果证书的授权状态</span><br><span class=\"line\">                    case ASAuthorizationAppleIDProviderCredentialRevoked:</span><br><span class=\"line\">                        &#x2F;&#x2F; 苹果授权凭证失效</span><br><span class=\"line\">                        errorMsg &#x3D; @&quot;苹果授权凭证失效&quot;;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case ASAuthorizationAppleIDProviderCredentialAuthorized:</span><br><span class=\"line\">                        &#x2F;&#x2F; 苹果授权凭证状态良好</span><br><span class=\"line\">                        errorMsg &#x3D; @&quot;苹果授权凭证状态良好&quot;;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case ASAuthorizationAppleIDProviderCredentialNotFound:</span><br><span class=\"line\">                        &#x2F;&#x2F; 未发现苹果授权凭证</span><br><span class=\"line\">                        errorMsg &#x3D; @&quot;未发现苹果授权凭证&quot;;</span><br><span class=\"line\">                        &#x2F;&#x2F; 可以引导用户重新登录</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">                    NSLog(@&quot;SignInWithApple授权状态变化情况&quot;);</span><br><span class=\"line\">                    NSLog(@&quot;%@&quot;, errorMsg);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;];</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用通知的方式检测是否授权应用支持Sign In With Apple变化情况。如下的代码可以根据自己的业务场景去考虑放置的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;! 添加苹果登录的状态通知</span><br><span class=\"line\">- (void)observeAppleSignInState &#123;</span><br><span class=\"line\">    if (@available(iOS 13.0, *)) &#123;</span><br><span class=\"line\">        NSNotificationCenter *center &#x3D; [NSNotificationCenter defaultCenter];</span><br><span class=\"line\">        [center addObserver:self selector:@selector(handleSignInWithAppleStateChanged:) name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F;! 观察SignInWithApple状态改变</span><br><span class=\"line\">- (void)handleSignInWithAppleStateChanged:(id)noti &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;, noti);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">- (void)dealloc &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (@available(iOS 13.0, *)) &#123;</span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] removeObserver:self name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重要（Important！）\"><a href=\"#重要（Important！）\" class=\"headerlink\" title=\"重要（Important！）\"></a>重要（Important！）</h2><ol>\n<li>最好使用苹果提供的按钮 <code>ASAuthorizationAppleIDButton</code> （只有黑白两种颜色）</li>\n<li>不用他的按钮的话建议使用显眼的颜色 </li>\n<li>尽量放在显眼位置（第一位）</li>\n<li><strong>不能比其他任何登录按钮要小</strong></li>\n<li>保证登录页面一屏就能看到苹果登录按钮，不能滚动后才能看到</li>\n<li>按钮的最小宽高有需求（看<a href=\"https://developer.apple.com/design/human-interface-guidelines/sign-in-with-apple/overview/\">苹果人机交互指南相关文档</a>）</li>\n<li>如果登录后要绑定手机的话，就在备注里面写好 依据来源 <a href=\"http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm\">http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm</a>  指明(截图)第二十四条（苹果一般不会打开网页，建议下载个pdf给他）</li>\n<li>如果不好好跟苹果爸爸的规矩来，那么可能会吃到2.1和4.0 (不要问我为什么知道)</li>\n</ol>\n<p>(更新至2019/11/01)</p>\n<table>\n<thead>\n<tr>\n<th>最小宽度</th>\n<th>最小高度</th>\n<th>最小间距</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>140pt (140px @1x, 280px @2x)</td>\n<td>30pt (30px @1x, 60px @2x)</td>\n<td>1/10 of the button’s height）</td>\n</tr>\n</tbody></table>\n<h2 id=\"参考其他教程\"><a href=\"#参考其他教程\" class=\"headerlink\" title=\"参考其他教程\"></a>参考其他教程</h2><p><a href=\"https://juejin.im/post/5d8c64d151882509606d6b17\">掘金</a></p>\n","site":{"data":{}},"excerpt":"<p>如果你的应用接入了第三方登陆，那么请同时接入苹果登录。</p>","more":"<p><a href=\"https://developer.apple.com/app-store/review/guidelines/#sign-in-with-apple\">苹果审核指南的相关内容</a><br><a href=\"https://developer.apple.com/news/?id=09122019b\">新闻：2020年4月前需要适配好苹果登录</a></p>\n<h2 id=\"简单接入\"><a href=\"#简单接入\" class=\"headerlink\" title=\"简单接入\"></a>简单接入</h2><p><a href=\"https://developer.apple.com/sign-in-with-apple/\">苹果登录官方文档</a></p>\n<p>流程：</p>\n<p>用户点击按钮 — 调起苹果登录 — 授权成功 — 获取唯一标识符和其他信息 — 返回给后端 — 后端注册/登录 — 返回token — 登录成功</p>\n<h3 id=\"必要的工作\"><a href=\"#必要的工作\" class=\"headerlink\" title=\"必要的工作\"></a>必要的工作</h3><ol>\n<li><p>首先去苹果后台开启<code>Sign in with apple</code>选项，然后重新导出<code>provisionprofile</code>证书</p>\n</li>\n<li><p>授权</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASAuthorizationAppleIDProvider *provider &#x3D; [[ASAuthorizationAppleIDProvider alloc] init];</span><br><span class=\"line\">ASAuthorizationAppleIDRequest *request &#x3D; [provider createRequest];</span><br><span class=\"line\">request.requestedScopes &#x3D; @[ASAuthorizationScopeFullName, ASAuthorizationScopeEmail];</span><br><span class=\"line\"></span><br><span class=\"line\">NSMutableArray &lt;ASAuthorizationRequest *&gt;* array &#x3D; [NSMutableArray arrayWithCapacity:2];</span><br><span class=\"line\">if (request) [array addObject:request];</span><br><span class=\"line\"></span><br><span class=\"line\">NSArray&lt;ASAuthorizationRequest *&gt; *requests &#x3D; [array copy];</span><br><span class=\"line\">ASAuthorizationController *authorizationController &#x3D; [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];</span><br><span class=\"line\">authorizationController.delegate &#x3D; self;</span><br><span class=\"line\">authorizationController.presentationContextProvider &#x3D; input;</span><br><span class=\"line\">[authorizationController performRequests];</span><br></pre></td></tr></table></figure></li>\n<li><p>回调，遵循回调<code>ASAuthorizationControllerPresentationContextProviding</code></p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization API_AVAILABLE(ios(13.0))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 用户登录使用ASAuthorizationAppleIDCredential</span><br><span class=\"line\">\tASAuthorizationAppleIDCredential *appleIDCredential &#x3D; (ASAuthorizationAppleIDCredential *)authorization.credential;</span><br><span class=\"line\">\tNSString *user &#x3D; appleIDCredential.user;</span><br><span class=\"line\">\tNSString *namePerfix &#x3D; appleIDCredential.fullName.namePrefix;</span><br><span class=\"line\">\tNSString *givenName &#x3D; appleIDCredential.fullName.givenName;</span><br><span class=\"line\">\tNSString *middleName &#x3D; appleIDCredential.fullName.middleName;</span><br><span class=\"line\">\tNSString *familyName &#x3D; appleIDCredential.fullName.familyName;</span><br><span class=\"line\">\tNSString *nameSuffix &#x3D; appleIDCredential.fullName.nameSuffix;</span><br><span class=\"line\">\tNSString *email &#x3D; appleIDCredential.email;</span><br><span class=\"line\">\tNSString *nickname &#x3D; appleIDCredential.fullName.nickname;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif (!nickname || nickname.length &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">\t\tnickname &#x3D; [NSString stringWithFormat:@&quot;%@%@%@%@%@&quot;,namePerfix?:@&quot;&quot;,familyName?:@&quot;&quot;,givenName?:@&quot;&quot;,middleName?:@&quot;&quot;,nameSuffix?:@&quot;&quot;];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">\t[self.errorSubject sendNext:LMError(@&quot;授权信息有误&quot;)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithError:(NSError *)error API_AVAILABLE(ios(13.0))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">NSString *errorMsg &#x3D; nil;</span><br><span class=\"line\">switch (error.code) &#123;</span><br><span class=\"line\">\tcase ASAuthorizationErrorCanceled:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;用户取消了授权请求&quot;;</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\tcase ASAuthorizationErrorFailed:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;授权请求失败&quot;;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase ASAuthorizationErrorInvalidResponse:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;授权请求响应无效&quot;;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase ASAuthorizationErrorNotHandled:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;未能处理授权请求&quot;;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase ASAuthorizationErrorUnknown:</span><br><span class=\"line\">\t\t\terrorMsg &#x3D; @&quot;授权请求失败未知原因&quot;;</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t[self.errorSubject sendNext:LMError(errorMsg)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"其他可选项\"><a href=\"#其他可选项\" class=\"headerlink\" title=\"其他可选项\"></a>其他可选项</h2><h3 id=\"苹果提供的登录按钮\"><a href=\"#苹果提供的登录按钮\" class=\"headerlink\" title=\"苹果提供的登录按钮\"></a>苹果提供的登录按钮</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASAuthorizationAppleIDButton *button &#x3D; [ASAuthorizationAppleIDButton buttonWithType:ASAuthorizationAppleIDButtonTypeSignIn style:ASAuthorizationAppleIDButtonStyleWhiteOutline];</span><br></pre></td></tr></table></figure>\n\n<p>其中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonType) &#123;</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonTypeSignIn, &#x2F;&#x2F; 按钮文字显示 ：通过Apple登录</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonTypeContinue, &#x2F;&#x2F; 按钮文字显示 ：通过Apple继续</span><br><span class=\"line\"></span><br><span class=\"line\">    ASAuthorizationAppleIDButtonTypeDefault &#x3D; &#x2F;&#x2F; 默认第一个 ASAuthorizationAppleIDButtonTypeSignIn,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonStyle) &#123;</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonStyleWhite, &#x2F;&#x2F; 白底黑字</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonStyleWhiteOutline, &#x2F;&#x2F; 黑字白框</span><br><span class=\"line\">    ASAuthorizationAppleIDButtonStyleBlack, &#x2F;&#x2F; 黑底白字</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"授权成功的回调可以来自于其他地方\"><a href=\"#授权成功的回调可以来自于其他地方\" class=\"headerlink\" title=\"授权成功的回调可以来自于其他地方\"></a>授权成功的回调可以来自于其他地方</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;! 授权成功地回调</span><br><span class=\"line\">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization  API_AVAILABLE(ios(13.0))&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;, controller);</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;, authorization);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;authorization.credential：%@&quot;, authorization.credential);</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSMutableString *mStr &#x3D; [NSMutableString string];</span><br><span class=\"line\">    mStr &#x3D; [_appleIDInfoTextView.text mutableCopy];</span><br><span class=\"line\">    </span><br><span class=\"line\">    if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 用户登录使用ASAuthorizationAppleIDCredential</span><br><span class=\"line\">        ASAuthorizationAppleIDCredential *appleIDCredential &#x3D; authorization.credential;</span><br><span class=\"line\">        NSString *user &#x3D; appleIDCredential.user;</span><br><span class=\"line\">        &#x2F;&#x2F;  最好使用钥匙串的方式保存用户的唯一信息 这里暂且处于测试阶段，用NSUserDefaults</span><br><span class=\"line\">        [[NSUserDefaults standardUserDefaults] setValue:user forKey:QiShareCurrentIdentifier];</span><br><span class=\"line\">        [mStr appendString:user?:@&quot;&quot;];</span><br><span class=\"line\">        NSString *familyName &#x3D; appleIDCredential.fullName.familyName;</span><br><span class=\"line\">        [mStr appendString:familyName?:@&quot;&quot;];</span><br><span class=\"line\">        NSString *givenName &#x3D; appleIDCredential.fullName.givenName;</span><br><span class=\"line\">        [mStr appendString:givenName?:@&quot;&quot;];</span><br><span class=\"line\">        NSString *email &#x3D; appleIDCredential.email;</span><br><span class=\"line\">        [mStr appendString:email?:@&quot;&quot;];</span><br><span class=\"line\">        NSLog(@&quot;mStr：%@&quot;, mStr);</span><br><span class=\"line\">        [mStr appendString:@&quot;\\n&quot;];</span><br><span class=\"line\">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; else if ([authorization.credential isKindOfClass:[ASPasswordCredential class]]) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 用户登录使用现有的密码凭证</span><br><span class=\"line\">        ASPasswordCredential *passwordCredential &#x3D; authorization.credential;</span><br><span class=\"line\">        &#x2F;&#x2F; 密码凭证对象的用户标识 用户的唯一标识</span><br><span class=\"line\">        NSString *user &#x3D; passwordCredential.user;</span><br><span class=\"line\">        &#x2F;&#x2F; 密码凭证对象的密码</span><br><span class=\"line\">        NSString *password &#x3D; passwordCredential.password;</span><br><span class=\"line\">        [mStr appendString:user?:@&quot;&quot;];</span><br><span class=\"line\">        [mStr appendString:password?:@&quot;&quot;];</span><br><span class=\"line\">        [mStr appendString:@&quot;\\n&quot;];</span><br><span class=\"line\">        NSLog(@&quot;mStr：%@&quot;, mStr);</span><br><span class=\"line\">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        NSLog(@&quot;授权信息均不符&quot;);</span><br><span class=\"line\">        mStr &#x3D; [@&quot;授权信息均不符&quot; mutableCopy];</span><br><span class=\"line\">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"已经使用Sign-In-With-Apple登录过app的用户\"><a href=\"#已经使用Sign-In-With-Apple登录过app的用户\" class=\"headerlink\" title=\"已经使用Sign In With Apple登录过app的用户\"></a>已经使用Sign In With Apple登录过app的用户</h3><p>执行已经登录过的场景。如果设备中存在iCloud Keychain 凭证或者AppleID 凭证提示用户直接使用TouchID或FaceID登录即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)perfomExistingAccountSetupFlows &#123;</span><br><span class=\"line\">    if (@available(iOS 13.0, *)) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; A mechanism for generating requests to authenticate users based on their Apple ID.</span><br><span class=\"line\">        &#x2F;&#x2F; 基于用户的Apple ID授权用户，生成用户授权请求的一种机制</span><br><span class=\"line\">        ASAuthorizationAppleIDProvider *appleIDProvider &#x3D; [ASAuthorizationAppleIDProvider new];</span><br><span class=\"line\">        &#x2F;&#x2F; An OpenID authorization request that relies on the user’s Apple ID.</span><br><span class=\"line\">        &#x2F;&#x2F; 授权请求依赖于用于的AppleID</span><br><span class=\"line\">        ASAuthorizationAppleIDRequest *authAppleIDRequest &#x3D; [appleIDProvider createRequest];</span><br><span class=\"line\">        &#x2F;&#x2F; A mechanism for generating requests to perform keychain credential sharing.</span><br><span class=\"line\">        &#x2F;&#x2F; 为了执行钥匙串凭证分享生成请求的一种机制</span><br><span class=\"line\">        ASAuthorizationPasswordRequest *passwordRequest &#x3D; [[ASAuthorizationPasswordProvider new] createRequest];</span><br><span class=\"line\">        </span><br><span class=\"line\">        NSMutableArray &lt;ASAuthorizationRequest *&gt;* mArr &#x3D; [NSMutableArray arrayWithCapacity:2];</span><br><span class=\"line\">        if (authAppleIDRequest) &#123;</span><br><span class=\"line\">            [mArr addObject:authAppleIDRequest];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (passwordRequest) &#123;</span><br><span class=\"line\">            [mArr addObject:passwordRequest];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; ASAuthorizationRequest：A base class for different kinds of authorization requests.</span><br><span class=\"line\">        &#x2F;&#x2F; ASAuthorizationRequest：对于不同种类授权请求的基类</span><br><span class=\"line\">        NSArray &lt;ASAuthorizationRequest *&gt;* requests &#x3D; [mArr copy];</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#x2F;&#x2F; A controller that manages authorization requests created by a provider.</span><br><span class=\"line\">        &#x2F;&#x2F; 由ASAuthorizationAppleIDProvider创建的授权请求 管理授权请求的控制器</span><br><span class=\"line\">        &#x2F;&#x2F; Creates a controller from a collection of authorization requests.</span><br><span class=\"line\">        &#x2F;&#x2F; 从一系列授权请求中创建授权控制器</span><br><span class=\"line\">        ASAuthorizationController *authorizationController &#x3D; [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];</span><br><span class=\"line\">        &#x2F;&#x2F; A delegate that the authorization controller informs about the success or failure of an authorization attempt.</span><br><span class=\"line\">        &#x2F;&#x2F; 设置授权控制器通知授权请求的成功与失败的代理</span><br><span class=\"line\">        authorizationController.delegate &#x3D; self;</span><br><span class=\"line\">        &#x2F;&#x2F; A delegate that provides a display context in which the system can present an authorization interface to the user.</span><br><span class=\"line\">        &#x2F;&#x2F; 设置提供 展示上下文的代理，在这个上下文中 系统可以展示授权界面给用户</span><br><span class=\"line\">        authorizationController.presentationContextProvider &#x3D; self;</span><br><span class=\"line\">        &#x2F;&#x2F; starts the authorization flows named during controller initialization.</span><br><span class=\"line\">        &#x2F;&#x2F; 在控制器初始化期间启动授权流</span><br><span class=\"line\">        [authorizationController performRequests];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"监听授权状态变化\"><a href=\"#监听授权状态变化\" class=\"headerlink\" title=\"监听授权状态变化\"></a>监听授权状态变化</h3><p>监听授权状态改变，并且做出相应处理。授权状态有：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASAuthorizationAppleIDProviderCredentialRevoked：授权状态失效（用户停止使用AppID 登录App）</span><br><span class=\"line\">ASAuthorizationAppleIDProviderCredentialAuthorized：已授权(已使用AppleID 登录过App）</span><br><span class=\"line\">ASAuthorizationAppleIDProviderCredentialNotFound：授权凭证缺失（可能是使用AppleID 登录过App）</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;! 观察授权状态</span><br><span class=\"line\">- (void)observeAuthticationState &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (@available(iOS 13.0, *)) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; A mechanism for generating requests to authenticate users based on their Apple ID.</span><br><span class=\"line\">        &#x2F;&#x2F; 基于用户的Apple ID 生成授权用户请求的机制</span><br><span class=\"line\">        ASAuthorizationAppleIDProvider *appleIDProvider &#x3D; [ASAuthorizationAppleIDProvider new];</span><br><span class=\"line\">        &#x2F;&#x2F; 注意 存储用户标识信息需要使用钥匙串来存储 这里笔者简单期间 使用NSUserDefaults 做的简单示例</span><br><span class=\"line\">        NSString *userIdentifier &#x3D; [[NSUserDefaults standardUserDefaults] valueForKey:QiShareCurrentIdentifier];</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (userIdentifier) &#123;</span><br><span class=\"line\">            NSString* __block errorMsg &#x3D; nil;</span><br><span class=\"line\">            &#x2F;&#x2F;Returns the credential state for the given user in a completion handler.</span><br><span class=\"line\">            &#x2F;&#x2F; 在回调中返回用户的授权状态</span><br><span class=\"line\">            [appleIDProvider getCredentialStateForUserID:userIdentifier completion:^(ASAuthorizationAppleIDProviderCredentialState credentialState, NSError * _Nullable error) &#123;</span><br><span class=\"line\">                switch (credentialState) &#123;</span><br><span class=\"line\">                        &#x2F;&#x2F; 苹果证书的授权状态</span><br><span class=\"line\">                    case ASAuthorizationAppleIDProviderCredentialRevoked:</span><br><span class=\"line\">                        &#x2F;&#x2F; 苹果授权凭证失效</span><br><span class=\"line\">                        errorMsg &#x3D; @&quot;苹果授权凭证失效&quot;;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case ASAuthorizationAppleIDProviderCredentialAuthorized:</span><br><span class=\"line\">                        &#x2F;&#x2F; 苹果授权凭证状态良好</span><br><span class=\"line\">                        errorMsg &#x3D; @&quot;苹果授权凭证状态良好&quot;;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    case ASAuthorizationAppleIDProviderCredentialNotFound:</span><br><span class=\"line\">                        &#x2F;&#x2F; 未发现苹果授权凭证</span><br><span class=\"line\">                        errorMsg &#x3D; @&quot;未发现苹果授权凭证&quot;;</span><br><span class=\"line\">                        &#x2F;&#x2F; 可以引导用户重新登录</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">                    NSLog(@&quot;SignInWithApple授权状态变化情况&quot;);</span><br><span class=\"line\">                    NSLog(@&quot;%@&quot;, errorMsg);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;];</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用通知的方式检测是否授权应用支持Sign In With Apple变化情况。如下的代码可以根据自己的业务场景去考虑放置的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;! 添加苹果登录的状态通知</span><br><span class=\"line\">- (void)observeAppleSignInState &#123;</span><br><span class=\"line\">    if (@available(iOS 13.0, *)) &#123;</span><br><span class=\"line\">        NSNotificationCenter *center &#x3D; [NSNotificationCenter defaultCenter];</span><br><span class=\"line\">        [center addObserver:self selector:@selector(handleSignInWithAppleStateChanged:) name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F;! 观察SignInWithApple状态改变</span><br><span class=\"line\">- (void)handleSignInWithAppleStateChanged:(id)noti &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;, noti);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">- (void)dealloc &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (@available(iOS 13.0, *)) &#123;</span><br><span class=\"line\">        [[NSNotificationCenter defaultCenter] removeObserver:self name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重要（Important！）\"><a href=\"#重要（Important！）\" class=\"headerlink\" title=\"重要（Important！）\"></a>重要（Important！）</h2><ol>\n<li>最好使用苹果提供的按钮 <code>ASAuthorizationAppleIDButton</code> （只有黑白两种颜色）</li>\n<li>不用他的按钮的话建议使用显眼的颜色 </li>\n<li>尽量放在显眼位置（第一位）</li>\n<li><strong>不能比其他任何登录按钮要小</strong></li>\n<li>保证登录页面一屏就能看到苹果登录按钮，不能滚动后才能看到</li>\n<li>按钮的最小宽高有需求（看<a href=\"https://developer.apple.com/design/human-interface-guidelines/sign-in-with-apple/overview/\">苹果人机交互指南相关文档</a>）</li>\n<li>如果登录后要绑定手机的话，就在备注里面写好 依据来源 <a href=\"http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm\">http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm</a>  指明(截图)第二十四条（苹果一般不会打开网页，建议下载个pdf给他）</li>\n<li>如果不好好跟苹果爸爸的规矩来，那么可能会吃到2.1和4.0 (不要问我为什么知道)</li>\n</ol>\n<p>(更新至2019/11/01)</p>\n<table>\n<thead>\n<tr>\n<th>最小宽度</th>\n<th>最小高度</th>\n<th>最小间距</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>140pt (140px @1x, 280px @2x)</td>\n<td>30pt (30px @1x, 60px @2x)</td>\n<td>1/10 of the button’s height）</td>\n</tr>\n</tbody></table>\n<h2 id=\"参考其他教程\"><a href=\"#参考其他教程\" class=\"headerlink\" title=\"参考其他教程\"></a>参考其他教程</h2><p><a href=\"https://juejin.im/post/5d8c64d151882509606d6b17\">掘金</a></p>"},{"title":"Vue学习笔记","author":"Arclin","abbrlink":"71513ccb","date":"2017-08-07T16:10:00.000Z","_content":"Vue.js 是一个用于构建用户界面的渐进式前端框架\n\n<!-- more -->\n\n## 安装 vue-cli 命令行工具\n\n 安装Vue\n`npm install -g vue-cli`\n\n## 初始化项目\nvue init webpack-simple 项目名\n\n项目模板有很多种,这里用了webpack-simple webpack-simple 没有包括Eslint检查功能等等功能，webpack有,但是普通项目用webpack-simple就足够了.\n\n构造Vue实例\n\n```\nvar vm = new Vue({\n  // 选项\n})\n```\n\n例子\n\n```\nwindow.onload=function(){\n //在这里面写Vue.js代码\n new Vue({\n  el: '#demo', // 需要渲染的DOM元素\n  data: {\t\t // 渲染的数据,key-value方式\n    message: 'Hello Vue.js!' \n  }\n})\n//----------------\n}\n```\n\n## HTML中数据绑定\n\n### 单次插值\n\n```\n<span>Message: {{ message }}</span>\n```\n\n如果想要单次插值,即今后的数据变化就不会再引起插值更新,加个 *\n\n```\n<span>This will never change: {{* message }}</span>\n```\n\n例子\n\n```\nJS\n\nvar data={message:'Hello Vue.js!'};\nnew Vue({\n  el: '#demo',\n  data: data\n })\ndata.message =\"Hello World!\";\ndata.message =\"Hello\"; // 再次改变时候,第二个元素内的值不会变化\n\nHTML\n\n<span>This will never change: {{ message }}</span><br>\n<span>This will never change: {{* message }}</span>\n```\n\n### 嵌入HTML\n\n三个大括号表示不是插入文本而是html标签\n\n```\nHTML\n\n<div>{{{ msg }}}</div>\n```\n\n```\nJS\n\nvar data={msg:'<p>Hello Vue.js!</p>'};\nnew Vue({\n    el: '#demo',\n    data: data\n})\n\n```\n\n### HTMl特性\n比如说修改某个元素的id属性\n\n```\nHTML\n\n<div id=\"{{ id }}\"></div>\n```\n\n```\nJS\n\nvar data={id:'demo'};\nnew Vue({\n  el: 'div',\n  data: data\n})\n```\n\n### JavaScript表达式\n\n绑定的数据支持JavaScript表达式\n\n```\nJS\n\nwindow.onload=function(){\n //在这里面写Vue.js代码\n var data={message:'Hello ',number:3,ok:true};\n new Vue({\n  el: '#demo',\n  data: data\n })\n //----------------\n}\n```\n\n```\n<div id='demo'>\n{{ number + 1 }}<br/>\n{{ ok ? 'YES' : 'NO' }}<br/>\n{{ message.split('').reverse().join('') }}\n</div>\n```\n\n输出\n\n```\nYES\nolleH\n```\n\n### 过滤器\n使用管道符 |\n\n将message内的全部转换为小写字母\n\n```\n{{ message | lowercase }}\n```\n\n转为小写字母后,首字母大写\n\n```\n{{msg | lowercase | capitalize}}\n```\n\n此外还有大写过滤器`uppercase`\n\n```\nJS\n var data={msg:'heLLO!'};\n new Vue({\n  el: '#demo',\n  data: data\n })\n```\n\n输出\n\n```\nHello\n```\n\n### 指令\n渲染数据的时候的逻辑表达式\nv-text v-html v-model v-on v-else\n\n```\nJS\n\nvar data={msg:0};\n new Vue({\n  el: '#demo',\n  data: data\n })\n```\n\n当msg的值为1的时候才打印Hello!\n\n```\nHTML\n<p v-if=\"msg\">Hello!</p>\n```\n\n### 计算属性\n\n在模板中表达式非常便利，但是它们实际上只用于简单的操作。模板是为了描述视图的结构。在模板中放入太多的逻辑会让模板过重且难以维护。这就是为什么 Vue.js 将绑定表达式限制为一个表达式。如果需要多于一个表达式的逻辑，应当使用计算属性。\n\n```\nJS\n\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    a: 1\n  },\n  computed: {\n    // 一个计算属性的 getter\n    b: function () {\n      // `this` 指向 vm 实例\n      return this.a + 1\n    }\n  }\n})\n```\n```\nHTML\n\n<div id=\"example\">\n  a={{ a }}, b={{ b }}\n</div>\n```\n输出\n\n```\n1\na=1, b=2\n```","source":"_posts/Vue学习笔记.md","raw":"---\ntitle: Vue学习笔记\nauthor: Arclin\ntags:\n  - Vue.js\ncategories:\n  - 前端\nabbrlink: 71513ccb\ndate: 2017-08-08 00:10:00\n---\nVue.js 是一个用于构建用户界面的渐进式前端框架\n\n<!-- more -->\n\n## 安装 vue-cli 命令行工具\n\n 安装Vue\n`npm install -g vue-cli`\n\n## 初始化项目\nvue init webpack-simple 项目名\n\n项目模板有很多种,这里用了webpack-simple webpack-simple 没有包括Eslint检查功能等等功能，webpack有,但是普通项目用webpack-simple就足够了.\n\n构造Vue实例\n\n```\nvar vm = new Vue({\n  // 选项\n})\n```\n\n例子\n\n```\nwindow.onload=function(){\n //在这里面写Vue.js代码\n new Vue({\n  el: '#demo', // 需要渲染的DOM元素\n  data: {\t\t // 渲染的数据,key-value方式\n    message: 'Hello Vue.js!' \n  }\n})\n//----------------\n}\n```\n\n## HTML中数据绑定\n\n### 单次插值\n\n```\n<span>Message: {{ message }}</span>\n```\n\n如果想要单次插值,即今后的数据变化就不会再引起插值更新,加个 *\n\n```\n<span>This will never change: {{* message }}</span>\n```\n\n例子\n\n```\nJS\n\nvar data={message:'Hello Vue.js!'};\nnew Vue({\n  el: '#demo',\n  data: data\n })\ndata.message =\"Hello World!\";\ndata.message =\"Hello\"; // 再次改变时候,第二个元素内的值不会变化\n\nHTML\n\n<span>This will never change: {{ message }}</span><br>\n<span>This will never change: {{* message }}</span>\n```\n\n### 嵌入HTML\n\n三个大括号表示不是插入文本而是html标签\n\n```\nHTML\n\n<div>{{{ msg }}}</div>\n```\n\n```\nJS\n\nvar data={msg:'<p>Hello Vue.js!</p>'};\nnew Vue({\n    el: '#demo',\n    data: data\n})\n\n```\n\n### HTMl特性\n比如说修改某个元素的id属性\n\n```\nHTML\n\n<div id=\"{{ id }}\"></div>\n```\n\n```\nJS\n\nvar data={id:'demo'};\nnew Vue({\n  el: 'div',\n  data: data\n})\n```\n\n### JavaScript表达式\n\n绑定的数据支持JavaScript表达式\n\n```\nJS\n\nwindow.onload=function(){\n //在这里面写Vue.js代码\n var data={message:'Hello ',number:3,ok:true};\n new Vue({\n  el: '#demo',\n  data: data\n })\n //----------------\n}\n```\n\n```\n<div id='demo'>\n{{ number + 1 }}<br/>\n{{ ok ? 'YES' : 'NO' }}<br/>\n{{ message.split('').reverse().join('') }}\n</div>\n```\n\n输出\n\n```\nYES\nolleH\n```\n\n### 过滤器\n使用管道符 |\n\n将message内的全部转换为小写字母\n\n```\n{{ message | lowercase }}\n```\n\n转为小写字母后,首字母大写\n\n```\n{{msg | lowercase | capitalize}}\n```\n\n此外还有大写过滤器`uppercase`\n\n```\nJS\n var data={msg:'heLLO!'};\n new Vue({\n  el: '#demo',\n  data: data\n })\n```\n\n输出\n\n```\nHello\n```\n\n### 指令\n渲染数据的时候的逻辑表达式\nv-text v-html v-model v-on v-else\n\n```\nJS\n\nvar data={msg:0};\n new Vue({\n  el: '#demo',\n  data: data\n })\n```\n\n当msg的值为1的时候才打印Hello!\n\n```\nHTML\n<p v-if=\"msg\">Hello!</p>\n```\n\n### 计算属性\n\n在模板中表达式非常便利，但是它们实际上只用于简单的操作。模板是为了描述视图的结构。在模板中放入太多的逻辑会让模板过重且难以维护。这就是为什么 Vue.js 将绑定表达式限制为一个表达式。如果需要多于一个表达式的逻辑，应当使用计算属性。\n\n```\nJS\n\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    a: 1\n  },\n  computed: {\n    // 一个计算属性的 getter\n    b: function () {\n      // `this` 指向 vm 实例\n      return this.a + 1\n    }\n  }\n})\n```\n```\nHTML\n\n<div id=\"example\">\n  a={{ a }}, b={{ b }}\n</div>\n```\n输出\n\n```\n1\na=1, b=2\n```","slug":"Vue学习笔记","published":1,"updated":"2021-04-12T06:07:04.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog58002245n0fr750fon","content":"<p>Vue.js 是一个用于构建用户界面的渐进式前端框架</p>\n<span id=\"more\"></span>\n\n<h2 id=\"安装-vue-cli-命令行工具\"><a href=\"#安装-vue-cli-命令行工具\" class=\"headerlink\" title=\"安装 vue-cli 命令行工具\"></a>安装 vue-cli 命令行工具</h2><p> 安装Vue<br><code>npm install -g vue-cli</code></p>\n<h2 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h2><p>vue init webpack-simple 项目名</p>\n<p>项目模板有很多种,这里用了webpack-simple webpack-simple 没有包括Eslint检查功能等等功能，webpack有,但是普通项目用webpack-simple就足够了.</p>\n<p>构造Vue实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 选项</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.onload&#x3D;function()&#123;</span><br><span class=\"line\"> &#x2F;&#x2F;在这里面写Vue.js代码</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;, &#x2F;&#x2F; 需要渲染的DOM元素</span><br><span class=\"line\">  data: &#123;\t\t &#x2F;&#x2F; 渲染的数据,key-value方式</span><br><span class=\"line\">    message: &#39;Hello Vue.js!&#39; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#x2F;&#x2F;----------------</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"HTML中数据绑定\"><a href=\"#HTML中数据绑定\" class=\"headerlink\" title=\"HTML中数据绑定\"></a>HTML中数据绑定</h2><h3 id=\"单次插值\"><a href=\"#单次插值\" class=\"headerlink\" title=\"单次插值\"></a>单次插值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span&gt;Message: &#123;&#123; message &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果想要单次插值,即今后的数据变化就不会再引起插值更新,加个 *</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123;* message &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>\n\n<p>例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data&#x3D;&#123;message:&#39;Hello Vue.js!&#39;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\">data.message &#x3D;&quot;Hello World!&quot;;</span><br><span class=\"line\">data.message &#x3D;&quot;Hello&quot;; &#x2F;&#x2F; 再次改变时候,第二个元素内的值不会变化</span><br><span class=\"line\"></span><br><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123; message &#125;&#125;&lt;&#x2F;span&gt;&lt;br&gt;</span><br><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123;* message &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"嵌入HTML\"><a href=\"#嵌入HTML\" class=\"headerlink\" title=\"嵌入HTML\"></a>嵌入HTML</h3><p>三个大括号表示不是插入文本而是html标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;&#123;&#123;&#123; msg &#125;&#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data&#x3D;&#123;msg:&#39;&lt;p&gt;Hello Vue.js!&lt;&#x2F;p&gt;&#39;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: &#39;#demo&#39;,</span><br><span class=\"line\">    data: data</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTMl特性\"><a href=\"#HTMl特性\" class=\"headerlink\" title=\"HTMl特性\"></a>HTMl特性</h3><p>比如说修改某个元素的id属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id&#x3D;&quot;&#123;&#123; id &#125;&#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data&#x3D;&#123;id:&#39;demo&#39;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#39;div&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JavaScript表达式\"><a href=\"#JavaScript表达式\" class=\"headerlink\" title=\"JavaScript表达式\"></a>JavaScript表达式</h3><p>绑定的数据支持JavaScript表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">window.onload&#x3D;function()&#123;</span><br><span class=\"line\"> &#x2F;&#x2F;在这里面写Vue.js代码</span><br><span class=\"line\"> var data&#x3D;&#123;message:&#39;Hello &#39;,number:3,ok:true&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> &#x2F;&#x2F;----------------</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&#39;demo&#39;&gt;</span><br><span class=\"line\">&#123;&#123; number + 1 &#125;&#125;&lt;br&#x2F;&gt;</span><br><span class=\"line\">&#123;&#123; ok ? &#39;YES&#39; : &#39;NO&#39; &#125;&#125;&lt;br&#x2F;&gt;</span><br><span class=\"line\">&#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YES</span><br><span class=\"line\">olleH</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h3><p>使用管道符 |</p>\n<p>将message内的全部转换为小写字母</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; message | lowercase &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>转为小写字母后,首字母大写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;msg | lowercase | capitalize&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此外还有大写过滤器<code>uppercase</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"> var data&#x3D;&#123;msg:&#39;heLLO!&#39;&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h3><p>渲染数据的时候的逻辑表达式<br>v-text v-html v-model v-on v-else</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data&#x3D;&#123;msg:0&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>当msg的值为1的时候才打印Hello!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\">&lt;p v-if&#x3D;&quot;msg&quot;&gt;Hello!&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h3><p>在模板中表达式非常便利，但是它们实际上只用于简单的操作。模板是为了描述视图的结构。在模板中放入太多的逻辑会让模板过重且难以维护。这就是为什么 Vue.js 将绑定表达式限制为一个表达式。如果需要多于一个表达式的逻辑，应当使用计算属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#example&#39;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    a: 1</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 一个计算属性的 getter</span><br><span class=\"line\">    b: function () &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; &#96;this&#96; 指向 vm 实例</span><br><span class=\"line\">      return this.a + 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class=\"line\">  a&#x3D;&#123;&#123; a &#125;&#125;, b&#x3D;&#123;&#123; b &#125;&#125;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">a&#x3D;1, b&#x3D;2</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>Vue.js 是一个用于构建用户界面的渐进式前端框架</p>","more":"<h2 id=\"安装-vue-cli-命令行工具\"><a href=\"#安装-vue-cli-命令行工具\" class=\"headerlink\" title=\"安装 vue-cli 命令行工具\"></a>安装 vue-cli 命令行工具</h2><p> 安装Vue<br><code>npm install -g vue-cli</code></p>\n<h2 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h2><p>vue init webpack-simple 项目名</p>\n<p>项目模板有很多种,这里用了webpack-simple webpack-simple 没有包括Eslint检查功能等等功能，webpack有,但是普通项目用webpack-simple就足够了.</p>\n<p>构造Vue实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 选项</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.onload&#x3D;function()&#123;</span><br><span class=\"line\"> &#x2F;&#x2F;在这里面写Vue.js代码</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;, &#x2F;&#x2F; 需要渲染的DOM元素</span><br><span class=\"line\">  data: &#123;\t\t &#x2F;&#x2F; 渲染的数据,key-value方式</span><br><span class=\"line\">    message: &#39;Hello Vue.js!&#39; </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#x2F;&#x2F;----------------</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"HTML中数据绑定\"><a href=\"#HTML中数据绑定\" class=\"headerlink\" title=\"HTML中数据绑定\"></a>HTML中数据绑定</h2><h3 id=\"单次插值\"><a href=\"#单次插值\" class=\"headerlink\" title=\"单次插值\"></a>单次插值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span&gt;Message: &#123;&#123; message &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果想要单次插值,即今后的数据变化就不会再引起插值更新,加个 *</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123;* message &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>\n\n<p>例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data&#x3D;&#123;message:&#39;Hello Vue.js!&#39;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\">data.message &#x3D;&quot;Hello World!&quot;;</span><br><span class=\"line\">data.message &#x3D;&quot;Hello&quot;; &#x2F;&#x2F; 再次改变时候,第二个元素内的值不会变化</span><br><span class=\"line\"></span><br><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123; message &#125;&#125;&lt;&#x2F;span&gt;&lt;br&gt;</span><br><span class=\"line\">&lt;span&gt;This will never change: &#123;&#123;* message &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"嵌入HTML\"><a href=\"#嵌入HTML\" class=\"headerlink\" title=\"嵌入HTML\"></a>嵌入HTML</h3><p>三个大括号表示不是插入文本而是html标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;&#123;&#123;&#123; msg &#125;&#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data&#x3D;&#123;msg:&#39;&lt;p&gt;Hello Vue.js!&lt;&#x2F;p&gt;&#39;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">    el: &#39;#demo&#39;,</span><br><span class=\"line\">    data: data</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTMl特性\"><a href=\"#HTMl特性\" class=\"headerlink\" title=\"HTMl特性\"></a>HTMl特性</h3><p>比如说修改某个元素的id属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id&#x3D;&quot;&#123;&#123; id &#125;&#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data&#x3D;&#123;id:&#39;demo&#39;&#125;;</span><br><span class=\"line\">new Vue(&#123;</span><br><span class=\"line\">  el: &#39;div&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JavaScript表达式\"><a href=\"#JavaScript表达式\" class=\"headerlink\" title=\"JavaScript表达式\"></a>JavaScript表达式</h3><p>绑定的数据支持JavaScript表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">window.onload&#x3D;function()&#123;</span><br><span class=\"line\"> &#x2F;&#x2F;在这里面写Vue.js代码</span><br><span class=\"line\"> var data&#x3D;&#123;message:&#39;Hello &#39;,number:3,ok:true&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br><span class=\"line\"> &#x2F;&#x2F;----------------</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&#39;demo&#39;&gt;</span><br><span class=\"line\">&#123;&#123; number + 1 &#125;&#125;&lt;br&#x2F;&gt;</span><br><span class=\"line\">&#123;&#123; ok ? &#39;YES&#39; : &#39;NO&#39; &#125;&#125;&lt;br&#x2F;&gt;</span><br><span class=\"line\">&#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">YES</span><br><span class=\"line\">olleH</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h3><p>使用管道符 |</p>\n<p>将message内的全部转换为小写字母</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123; message | lowercase &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>转为小写字母后,首字母大写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#123;msg | lowercase | capitalize&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此外还有大写过滤器<code>uppercase</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"> var data&#x3D;&#123;msg:&#39;heLLO!&#39;&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h3><p>渲染数据的时候的逻辑表达式<br>v-text v-html v-model v-on v-else</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var data&#x3D;&#123;msg:0&#125;;</span><br><span class=\"line\"> new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#demo&#39;,</span><br><span class=\"line\">  data: data</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>当msg的值为1的时候才打印Hello!</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\">&lt;p v-if&#x3D;&quot;msg&quot;&gt;Hello!&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h3><p>在模板中表达式非常便利，但是它们实际上只用于简单的操作。模板是为了描述视图的结构。在模板中放入太多的逻辑会让模板过重且难以维护。这就是为什么 Vue.js 将绑定表达式限制为一个表达式。如果需要多于一个表达式的逻辑，应当使用计算属性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\"></span><br><span class=\"line\">var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">  el: &#39;#example&#39;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    a: 1</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 一个计算属性的 getter</span><br><span class=\"line\">    b: function () &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; &#96;this&#96; 指向 vm 实例</span><br><span class=\"line\">      return this.a + 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTML</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class=\"line\">  a&#x3D;&#123;&#123; a &#125;&#125;, b&#x3D;&#123;&#123; b &#125;&#125;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">a&#x3D;1, b&#x3D;2</span><br></pre></td></tr></table></figure>"},{"title":"Apache强制https ","author":"Arclin","abbrlink":"f6ce3122","date":"2018-02-18T13:50:00.000Z","_content":"当用户访问http的地址的时候，Apache如何强制跳转到https地址\n\n<!-- more -->\n\n修改httpd.conf\n\n1. LoadModule rewrite_module modules/mod_rewrite.so 这个拓展貌似是已经被加载了；\n2. 修改Apache默认项目路径的这个\n\n```\n<Directory \"/var/www/html\">\n```\n\n其实是修改为项目发布的路径\n```\n<Directory \"/var/www/html/app/src/htdocs_www\">\n```\n改为All\n\n```\nAllowOverride All\n```\n\n\n```\n# \n# Possible values for the Options directive are \"None\", \"All\", \n# or any combination of: \n# Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews \n# \n# Note that \"MultiViews\" must be named *explicitly* --- \"Options All\" \n# doesn't give it to you. \n# \n# The Options directive is both complicated and important. Please see \n# http://httpd.apache.org/docs/2.2/mod/core.html\n# options \n# for more information. \n# Options Indexes FollowSymLinks \n# \n# AllowOverride controls what directives may be placed in .htaccess files. \n# It can be \"All\", \"None\", or any combination of the keywords: \n# Options FileInfo AuthConfig Limit \n# \n# \n# Controls who can get stuff from this server. \n# \nOrder allow,deny \nAllow from all\n```\n\n添加三行代码\n\n```\nRewriteEngine on\nRewriteCond %{SERVER_PORT} !^443$\nRewriteRule ^(.*)?$ https://%{SERVER_NAME}/$1 [L,R]\n```","source":"_posts/Untitled.md","raw":"---\ntitle: 'Apache强制https '\nauthor: Arclin\ntags:\n  - https\ncategories:\n  - Linux\nabbrlink: f6ce3122\ndate: 2018-02-18 21:50:00\n---\n当用户访问http的地址的时候，Apache如何强制跳转到https地址\n\n<!-- more -->\n\n修改httpd.conf\n\n1. LoadModule rewrite_module modules/mod_rewrite.so 这个拓展貌似是已经被加载了；\n2. 修改Apache默认项目路径的这个\n\n```\n<Directory \"/var/www/html\">\n```\n\n其实是修改为项目发布的路径\n```\n<Directory \"/var/www/html/app/src/htdocs_www\">\n```\n改为All\n\n```\nAllowOverride All\n```\n\n\n```\n# \n# Possible values for the Options directive are \"None\", \"All\", \n# or any combination of: \n# Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews \n# \n# Note that \"MultiViews\" must be named *explicitly* --- \"Options All\" \n# doesn't give it to you. \n# \n# The Options directive is both complicated and important. Please see \n# http://httpd.apache.org/docs/2.2/mod/core.html\n# options \n# for more information. \n# Options Indexes FollowSymLinks \n# \n# AllowOverride controls what directives may be placed in .htaccess files. \n# It can be \"All\", \"None\", or any combination of the keywords: \n# Options FileInfo AuthConfig Limit \n# \n# \n# Controls who can get stuff from this server. \n# \nOrder allow,deny \nAllow from all\n```\n\n添加三行代码\n\n```\nRewriteEngine on\nRewriteCond %{SERVER_PORT} !^443$\nRewriteRule ^(.*)?$ https://%{SERVER_NAME}/$1 [L,R]\n```","slug":"Untitled","published":1,"updated":"2021-04-12T06:07:04.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog59002745n0aiaw3vyu","content":"<p>当用户访问http的地址的时候，Apache如何强制跳转到https地址</p>\n<span id=\"more\"></span>\n\n<p>修改httpd.conf</p>\n<ol>\n<li>LoadModule rewrite_module modules/mod_rewrite.so 这个拓展貌似是已经被加载了；</li>\n<li>修改Apache默认项目路径的这个</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>其实是修改为项目发布的路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;app&#x2F;src&#x2F;htdocs_www&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>改为All</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AllowOverride All</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># </span><br><span class=\"line\"># Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, </span><br><span class=\"line\"># or any combination of: </span><br><span class=\"line\"># Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews </span><br><span class=\"line\"># </span><br><span class=\"line\"># Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; </span><br><span class=\"line\"># doesn&#39;t give it to you. </span><br><span class=\"line\"># </span><br><span class=\"line\"># The Options directive is both complicated and important. Please see </span><br><span class=\"line\"># http:&#x2F;&#x2F;httpd.apache.org&#x2F;docs&#x2F;2.2&#x2F;mod&#x2F;core.html</span><br><span class=\"line\"># options </span><br><span class=\"line\"># for more information. </span><br><span class=\"line\"># Options Indexes FollowSymLinks </span><br><span class=\"line\"># </span><br><span class=\"line\"># AllowOverride controls what directives may be placed in .htaccess files. </span><br><span class=\"line\"># It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: </span><br><span class=\"line\"># Options FileInfo AuthConfig Limit </span><br><span class=\"line\"># </span><br><span class=\"line\"># </span><br><span class=\"line\"># Controls who can get stuff from this server. </span><br><span class=\"line\"># </span><br><span class=\"line\">Order allow,deny </span><br><span class=\"line\">Allow from all</span><br></pre></td></tr></table></figure>\n\n<p>添加三行代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RewriteEngine on</span><br><span class=\"line\">RewriteCond %&#123;SERVER_PORT&#125; !^443$</span><br><span class=\"line\">RewriteRule ^(.*)?$ https:&#x2F;&#x2F;%&#123;SERVER_NAME&#125;&#x2F;$1 [L,R]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>当用户访问http的地址的时候，Apache如何强制跳转到https地址</p>","more":"<p>修改httpd.conf</p>\n<ol>\n<li>LoadModule rewrite_module modules/mod_rewrite.so 这个拓展貌似是已经被加载了；</li>\n<li>修改Apache默认项目路径的这个</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>其实是修改为项目发布的路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;app&#x2F;src&#x2F;htdocs_www&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>改为All</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AllowOverride All</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># </span><br><span class=\"line\"># Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, </span><br><span class=\"line\"># or any combination of: </span><br><span class=\"line\"># Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews </span><br><span class=\"line\"># </span><br><span class=\"line\"># Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; </span><br><span class=\"line\"># doesn&#39;t give it to you. </span><br><span class=\"line\"># </span><br><span class=\"line\"># The Options directive is both complicated and important. Please see </span><br><span class=\"line\"># http:&#x2F;&#x2F;httpd.apache.org&#x2F;docs&#x2F;2.2&#x2F;mod&#x2F;core.html</span><br><span class=\"line\"># options </span><br><span class=\"line\"># for more information. </span><br><span class=\"line\"># Options Indexes FollowSymLinks </span><br><span class=\"line\"># </span><br><span class=\"line\"># AllowOverride controls what directives may be placed in .htaccess files. </span><br><span class=\"line\"># It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: </span><br><span class=\"line\"># Options FileInfo AuthConfig Limit </span><br><span class=\"line\"># </span><br><span class=\"line\"># </span><br><span class=\"line\"># Controls who can get stuff from this server. </span><br><span class=\"line\"># </span><br><span class=\"line\">Order allow,deny </span><br><span class=\"line\">Allow from all</span><br></pre></td></tr></table></figure>\n\n<p>添加三行代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RewriteEngine on</span><br><span class=\"line\">RewriteCond %&#123;SERVER_PORT&#125; !^443$</span><br><span class=\"line\">RewriteRule ^(.*)?$ https:&#x2F;&#x2F;%&#123;SERVER_NAME&#125;&#x2F;$1 [L,R]</span><br></pre></td></tr></table></figure>"},{"title":"URLWithString返回空","author":"Arclin","abbrlink":"890a3088","date":"2016-10-16T16:00:00.000Z","_content":"`[NSURL URLWithString:@”…………”]` 返回空 nil\n但是貌似汉字或者空格等无法被识别，String不被认为是URLString，这个NSURL的值也就一直是nil\n要怎样才能够让它识别呢？\n解决方法如下 ：\n\n1. 转换编码\n\n  ```\n  str1 = [str1 stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n\n  NSURL *url = [NSURL URLWithString:[Tool returnFormatString:str1]];\n  ```\n\n2. 除去空格\n\n  ```\n  +(NSString *)returnFormatString:(NSString *)str\n  {\n      return [str stringByReplacingOccurrencesOfString:@\" \"withString:@\" \"];\n  }\n\n   NSLog(@\"URL==%@\",url);\n  ```","source":"_posts/URLWithString返回空.md","raw":"---\ntitle: URLWithString返回空\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 890a3088\ndate: 2016-10-17 00:00:00\n---\n`[NSURL URLWithString:@”…………”]` 返回空 nil\n但是貌似汉字或者空格等无法被识别，String不被认为是URLString，这个NSURL的值也就一直是nil\n要怎样才能够让它识别呢？\n解决方法如下 ：\n\n1. 转换编码\n\n  ```\n  str1 = [str1 stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];\n\n  NSURL *url = [NSURL URLWithString:[Tool returnFormatString:str1]];\n  ```\n\n2. 除去空格\n\n  ```\n  +(NSString *)returnFormatString:(NSString *)str\n  {\n      return [str stringByReplacingOccurrencesOfString:@\" \"withString:@\" \"];\n  }\n\n   NSLog(@\"URL==%@\",url);\n  ```","slug":"URLWithString返回空","published":1,"updated":"2021-04-12T06:07:04.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5a002a45n012ml5hsl","content":"<p><code>[NSURL URLWithString:@”…………”]</code> 返回空 nil<br>但是貌似汉字或者空格等无法被识别，String不被认为是URLString，这个NSURL的值也就一直是nil<br>要怎样才能够让它识别呢？<br>解决方法如下 ：</p>\n<ol>\n<li>转换编码</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 &#x3D; [str1 stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class=\"line\"></span><br><span class=\"line\">NSURL *url &#x3D; [NSURL URLWithString:[Tool returnFormatString:str1]];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>除去空格</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+(NSString *)returnFormatString:(NSString *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return [str stringByReplacingOccurrencesOfString:@&quot; &quot;withString:@&quot; &quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> NSLog(@&quot;URL&#x3D;&#x3D;%@&quot;,url);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><code>[NSURL URLWithString:@”…………”]</code> 返回空 nil<br>但是貌似汉字或者空格等无法被识别，String不被认为是URLString，这个NSURL的值也就一直是nil<br>要怎样才能够让它识别呢？<br>解决方法如下 ：</p>\n<ol>\n<li>转换编码</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str1 &#x3D; [str1 stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class=\"line\"></span><br><span class=\"line\">NSURL *url &#x3D; [NSURL URLWithString:[Tool returnFormatString:str1]];</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>除去空格</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+(NSString *)returnFormatString:(NSString *)str</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return [str stringByReplacingOccurrencesOfString:@&quot; &quot;withString:@&quot; &quot;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> NSLog(@&quot;URL&#x3D;&#x3D;%@&quot;,url);</span><br></pre></td></tr></table></figure>"},{"title":"WordPress常用函数","author":"Arclin","abbrlink":"3fd5c9ca","date":"2017-03-01T16:00:00.000Z","_content":"wordpress自定义主题的时候需要用到的函数\n\n<!-- more -->\n\n[参考文档](https://codex.wordpress.org/zh-cn:模板标签)\n\n\n|函数名|作用|\n|----|----|\n|bloginfo()|可以拿到博客的信息,name,description,version,特别注意bloginfo('stylesheet_url');会直接找到根目录下的style.css文件,这个页面的样式表|\n|wp_head()|\t一般放在header.php,会有很多东西引入进去|\n|wp_title()|网站标题|\n|get_header()|检查同目录下是否有header.php,有的话就会调用这个文件作为页面头部|\n|get_sidebar()|检查sidebar.php,调用作为侧边栏|\n|get_footer()|检查footer.php,调用作为底部栏|\n|have_posts()|判断是否有日志|\n|the_post()|调用一篇具体的日志,和主循环配合使用|\n|the_permalink()|每篇日志地址|\n|the_title()|日志标题|\n|the_content()|日志内容|\n|_e()|框架里面有语言文件,这里是调用语言文件内对应文字,使用类似这样子_e(\"Archives\"),中文页面下显示归档,英文页面下显示Archives|\n|the_category()|分类,这个函数里面有一个参数,可以表示用什么符号去分割多个分类名,例如the_category(',')|\n|the_author()|作者名|\n|the_excerpt()|日志摘要|\n|comments_popup_link(‘No Comments »’, ‘1 Comment »’, ‘% Comments »’);|当弹出留言的功能激活的话，comments_popup_link() 调用一个弹出的留言窗口，如果没有激活，comments_popup_link() 则只是简单的显示留言列表。No Comments » 是在没有留言的时候显示的。1 Comment » 是用于当刚好只有1条留言时候。% Comments &187; 是用于当有多于一条留言的时候。比如：8 Comments »。百分号 % 用来显示数字。» 是用来显示一个双层箭头 »。|\n|edit_post_link(‘Edit’, ‘&124’, ”);\t|这个只有当我们以管理员或者作者身份登录的的时候才可见。|\n|edit_post_link()|只是简单显示一个可以用来编辑当前日志的编辑链接，这样就可以让我们不必去管理界面搜寻该日志就能直接编辑。|\n|edit_post_link() |有三个参数。第一个是用来确定哪个词你将用在编辑链接的链接标题。如果你使用 Edit post，那么将显示 Edit post 而不是 Edit。第二个参数是用来显示在链接前面的字符，在这里是竖线，代码就是&124;。第三个参数是用于显示在编辑链接后面的字符，在这里没有使用。登录 WordPress 之后，再返回到首页就可以看到“Edit”的链接和一条竖线。|\n|posts_nav_link(‘中间页’, ‘<<上一页’, ‘下一页>>’)|调用后一页和前一页的链接,3个参数，分别给链接的中间，前面和后面的设置字符|\n|previous_post_link(‘%link’)|上一篇日志|\n|next_post_link(‘%link’)|下一篇日志|\n|wp_list_pages()|展示页面列表,如果参数里面填`title_li=<h2>Pages</h2>&depth=3`,可以设置title的样式,depth指的是页面的展示深度|\n|wp_list_cats()|展示分类列表,参数可填`sort_column=name&optioncount=1&hierarchical=0`,分别是设置排序根据,是否显示文章个数,以分层缩进的方式显示分类列表|\n|get_links_list();|友情链接列表,在后台装插件之后就可以用了|\n|wp_get_archives()|意思跟上面的差不多,也是有参数,获取的是文章归档列表,参数填type=daily的话就是按日期分,monthly按月分,yearly按年分,format=link以链接形式显示|\n|wp_loginout()|退出登录链接|\n|wp_register()|注册链接|\n|wp_meta()|显示管理员的相关控制信息|\n|get_calendar()|显示一个日历|\n|include(TEMPLATEPATH . ‘/searchform.php’)|导入某个自定义文件,像左边就是/searchform.php文件|\n\n### 判断是否有日志并循环输出日志\n```\n<?php if(have_posts()) : ?> <!--检查是否有日志-->\n\t<?php while(have_posts()) : the_post(); ?> <!--循环输出日志-->\n\t\t\t<div class=\"post\" id=\"post-<?php the_ID(); ?>\">\n\t\t\t\t<h2><a href=\"<?php the_permalink(); ?>\" title=\"<?php the_title(); ?>\"><?php the_title(); ?></a></h2><!--日志标题-->\n\t\t\t\t<div class='entry'>\n\t\t\t\t<?php the_content(); ?>\n\t\t\t</div>\n\t\t\t<p class=\"postmetadata\">\n\t\t\t<?php _e('Filed under&#58;'); ?> <?php the_category(', ') ?> <?php _e('by'); ?> <?php  the_author(); ?><br />\n\t\t\t<?php comments_popup_link('No Comments &#187;', '1 Comment &#187;', '% Comments &#187;'); ?> <?php edit_post_link('Edit', ' &#124; ', ''); ?>\n\t\t\t</p>\n\t\t\t</div>\n\t<?php endwhile; ?>\n\t<div class=\"navigation\">\n\t\t\t<?php posts_nav_link('index', '<<上一页', '下一页>>'); ?>\n\t</div>\n\t<?php else : ?> <!--如果没有日志-->\n\t<div class = \"post\">\n\t\t<h2><?php _e(\"Not Found\"); ?></h2>\n\t</div>\n<?php endif; ?>\n```\n\n### 搜索框\n\n```\n<form method=\"get\" id=\"searchform\" action=\"<?php bloginfo('home'); ?>/\">\n\n<div>\n\n\t<input type=\"text\" value=\"<?php echo wp_specialchars($s, 1); ?>\" name=\"s\" id=\"s\" size=\"15\" /><br />\n\n\t<input type=\"submit\" id=\"searchsubmit\" value=\"Search\" />\n\n</div>\n\n</form>\n```","source":"_posts/WordPress常用函数.md","raw":"---\ntitle: WordPress常用函数\nauthor: Arclin\ntags:\n  - PHP\n  - WordPress\ncategories:\n  - PHP\nabbrlink: 3fd5c9ca\ndate: 2017-03-02 00:00:00\n---\nwordpress自定义主题的时候需要用到的函数\n\n<!-- more -->\n\n[参考文档](https://codex.wordpress.org/zh-cn:模板标签)\n\n\n|函数名|作用|\n|----|----|\n|bloginfo()|可以拿到博客的信息,name,description,version,特别注意bloginfo('stylesheet_url');会直接找到根目录下的style.css文件,这个页面的样式表|\n|wp_head()|\t一般放在header.php,会有很多东西引入进去|\n|wp_title()|网站标题|\n|get_header()|检查同目录下是否有header.php,有的话就会调用这个文件作为页面头部|\n|get_sidebar()|检查sidebar.php,调用作为侧边栏|\n|get_footer()|检查footer.php,调用作为底部栏|\n|have_posts()|判断是否有日志|\n|the_post()|调用一篇具体的日志,和主循环配合使用|\n|the_permalink()|每篇日志地址|\n|the_title()|日志标题|\n|the_content()|日志内容|\n|_e()|框架里面有语言文件,这里是调用语言文件内对应文字,使用类似这样子_e(\"Archives\"),中文页面下显示归档,英文页面下显示Archives|\n|the_category()|分类,这个函数里面有一个参数,可以表示用什么符号去分割多个分类名,例如the_category(',')|\n|the_author()|作者名|\n|the_excerpt()|日志摘要|\n|comments_popup_link(‘No Comments »’, ‘1 Comment »’, ‘% Comments »’);|当弹出留言的功能激活的话，comments_popup_link() 调用一个弹出的留言窗口，如果没有激活，comments_popup_link() 则只是简单的显示留言列表。No Comments » 是在没有留言的时候显示的。1 Comment » 是用于当刚好只有1条留言时候。% Comments &187; 是用于当有多于一条留言的时候。比如：8 Comments »。百分号 % 用来显示数字。» 是用来显示一个双层箭头 »。|\n|edit_post_link(‘Edit’, ‘&124’, ”);\t|这个只有当我们以管理员或者作者身份登录的的时候才可见。|\n|edit_post_link()|只是简单显示一个可以用来编辑当前日志的编辑链接，这样就可以让我们不必去管理界面搜寻该日志就能直接编辑。|\n|edit_post_link() |有三个参数。第一个是用来确定哪个词你将用在编辑链接的链接标题。如果你使用 Edit post，那么将显示 Edit post 而不是 Edit。第二个参数是用来显示在链接前面的字符，在这里是竖线，代码就是&124;。第三个参数是用于显示在编辑链接后面的字符，在这里没有使用。登录 WordPress 之后，再返回到首页就可以看到“Edit”的链接和一条竖线。|\n|posts_nav_link(‘中间页’, ‘<<上一页’, ‘下一页>>’)|调用后一页和前一页的链接,3个参数，分别给链接的中间，前面和后面的设置字符|\n|previous_post_link(‘%link’)|上一篇日志|\n|next_post_link(‘%link’)|下一篇日志|\n|wp_list_pages()|展示页面列表,如果参数里面填`title_li=<h2>Pages</h2>&depth=3`,可以设置title的样式,depth指的是页面的展示深度|\n|wp_list_cats()|展示分类列表,参数可填`sort_column=name&optioncount=1&hierarchical=0`,分别是设置排序根据,是否显示文章个数,以分层缩进的方式显示分类列表|\n|get_links_list();|友情链接列表,在后台装插件之后就可以用了|\n|wp_get_archives()|意思跟上面的差不多,也是有参数,获取的是文章归档列表,参数填type=daily的话就是按日期分,monthly按月分,yearly按年分,format=link以链接形式显示|\n|wp_loginout()|退出登录链接|\n|wp_register()|注册链接|\n|wp_meta()|显示管理员的相关控制信息|\n|get_calendar()|显示一个日历|\n|include(TEMPLATEPATH . ‘/searchform.php’)|导入某个自定义文件,像左边就是/searchform.php文件|\n\n### 判断是否有日志并循环输出日志\n```\n<?php if(have_posts()) : ?> <!--检查是否有日志-->\n\t<?php while(have_posts()) : the_post(); ?> <!--循环输出日志-->\n\t\t\t<div class=\"post\" id=\"post-<?php the_ID(); ?>\">\n\t\t\t\t<h2><a href=\"<?php the_permalink(); ?>\" title=\"<?php the_title(); ?>\"><?php the_title(); ?></a></h2><!--日志标题-->\n\t\t\t\t<div class='entry'>\n\t\t\t\t<?php the_content(); ?>\n\t\t\t</div>\n\t\t\t<p class=\"postmetadata\">\n\t\t\t<?php _e('Filed under&#58;'); ?> <?php the_category(', ') ?> <?php _e('by'); ?> <?php  the_author(); ?><br />\n\t\t\t<?php comments_popup_link('No Comments &#187;', '1 Comment &#187;', '% Comments &#187;'); ?> <?php edit_post_link('Edit', ' &#124; ', ''); ?>\n\t\t\t</p>\n\t\t\t</div>\n\t<?php endwhile; ?>\n\t<div class=\"navigation\">\n\t\t\t<?php posts_nav_link('index', '<<上一页', '下一页>>'); ?>\n\t</div>\n\t<?php else : ?> <!--如果没有日志-->\n\t<div class = \"post\">\n\t\t<h2><?php _e(\"Not Found\"); ?></h2>\n\t</div>\n<?php endif; ?>\n```\n\n### 搜索框\n\n```\n<form method=\"get\" id=\"searchform\" action=\"<?php bloginfo('home'); ?>/\">\n\n<div>\n\n\t<input type=\"text\" value=\"<?php echo wp_specialchars($s, 1); ?>\" name=\"s\" id=\"s\" size=\"15\" /><br />\n\n\t<input type=\"submit\" id=\"searchsubmit\" value=\"Search\" />\n\n</div>\n\n</form>\n```","slug":"WordPress常用函数","published":1,"updated":"2021-04-12T06:07:04.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5b002e45n0gas74dex","content":"<p>wordpress自定义主题的时候需要用到的函数</p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://codex.wordpress.org/zh-cn:%E6%A8%A1%E6%9D%BF%E6%A0%87%E7%AD%BE\">参考文档</a></p>\n<table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bloginfo()</td>\n<td>可以拿到博客的信息,name,description,version,特别注意bloginfo(‘stylesheet_url’);会直接找到根目录下的style.css文件,这个页面的样式表</td>\n</tr>\n<tr>\n<td>wp_head()</td>\n<td>一般放在header.php,会有很多东西引入进去</td>\n</tr>\n<tr>\n<td>wp_title()</td>\n<td>网站标题</td>\n</tr>\n<tr>\n<td>get_header()</td>\n<td>检查同目录下是否有header.php,有的话就会调用这个文件作为页面头部</td>\n</tr>\n<tr>\n<td>get_sidebar()</td>\n<td>检查sidebar.php,调用作为侧边栏</td>\n</tr>\n<tr>\n<td>get_footer()</td>\n<td>检查footer.php,调用作为底部栏</td>\n</tr>\n<tr>\n<td>have_posts()</td>\n<td>判断是否有日志</td>\n</tr>\n<tr>\n<td>the_post()</td>\n<td>调用一篇具体的日志,和主循环配合使用</td>\n</tr>\n<tr>\n<td>the_permalink()</td>\n<td>每篇日志地址</td>\n</tr>\n<tr>\n<td>the_title()</td>\n<td>日志标题</td>\n</tr>\n<tr>\n<td>the_content()</td>\n<td>日志内容</td>\n</tr>\n<tr>\n<td>_e()</td>\n<td>框架里面有语言文件,这里是调用语言文件内对应文字,使用类似这样子_e(“Archives”),中文页面下显示归档,英文页面下显示Archives</td>\n</tr>\n<tr>\n<td>the_category()</td>\n<td>分类,这个函数里面有一个参数,可以表示用什么符号去分割多个分类名,例如the_category(‘,’)</td>\n</tr>\n<tr>\n<td>the_author()</td>\n<td>作者名</td>\n</tr>\n<tr>\n<td>the_excerpt()</td>\n<td>日志摘要</td>\n</tr>\n<tr>\n<td>comments_popup_link(‘No Comments »’, ‘1 Comment »’, ‘% Comments »’);</td>\n<td>当弹出留言的功能激活的话，comments_popup_link() 调用一个弹出的留言窗口，如果没有激活，comments_popup_link() 则只是简单的显示留言列表。No Comments » 是在没有留言的时候显示的。1 Comment » 是用于当刚好只有1条留言时候。% Comments &187; 是用于当有多于一条留言的时候。比如：8 Comments »。百分号 % 用来显示数字。» 是用来显示一个双层箭头 »。</td>\n</tr>\n<tr>\n<td>edit_post_link(‘Edit’, ‘&amp;124’, ”);</td>\n<td>这个只有当我们以管理员或者作者身份登录的的时候才可见。</td>\n</tr>\n<tr>\n<td>edit_post_link()</td>\n<td>只是简单显示一个可以用来编辑当前日志的编辑链接，这样就可以让我们不必去管理界面搜寻该日志就能直接编辑。</td>\n</tr>\n<tr>\n<td>edit_post_link()</td>\n<td>有三个参数。第一个是用来确定哪个词你将用在编辑链接的链接标题。如果你使用 Edit post，那么将显示 Edit post 而不是 Edit。第二个参数是用来显示在链接前面的字符，在这里是竖线，代码就是&124;。第三个参数是用于显示在编辑链接后面的字符，在这里没有使用。登录 WordPress 之后，再返回到首页就可以看到“Edit”的链接和一条竖线。</td>\n</tr>\n<tr>\n<td>posts_nav_link(‘中间页’, ‘&lt;&lt;上一页’, ‘下一页&gt;&gt;’)</td>\n<td>调用后一页和前一页的链接,3个参数，分别给链接的中间，前面和后面的设置字符</td>\n</tr>\n<tr>\n<td>previous_post_link(‘%link’)</td>\n<td>上一篇日志</td>\n</tr>\n<tr>\n<td>next_post_link(‘%link’)</td>\n<td>下一篇日志</td>\n</tr>\n<tr>\n<td>wp_list_pages()</td>\n<td>展示页面列表,如果参数里面填<code>title_li=&lt;h2&gt;Pages&lt;/h2&gt;&amp;depth=3</code>,可以设置title的样式,depth指的是页面的展示深度</td>\n</tr>\n<tr>\n<td>wp_list_cats()</td>\n<td>展示分类列表,参数可填<code>sort_column=name&amp;optioncount=1&amp;hierarchical=0</code>,分别是设置排序根据,是否显示文章个数,以分层缩进的方式显示分类列表</td>\n</tr>\n<tr>\n<td>get_links_list();</td>\n<td>友情链接列表,在后台装插件之后就可以用了</td>\n</tr>\n<tr>\n<td>wp_get_archives()</td>\n<td>意思跟上面的差不多,也是有参数,获取的是文章归档列表,参数填type=daily的话就是按日期分,monthly按月分,yearly按年分,format=link以链接形式显示</td>\n</tr>\n<tr>\n<td>wp_loginout()</td>\n<td>退出登录链接</td>\n</tr>\n<tr>\n<td>wp_register()</td>\n<td>注册链接</td>\n</tr>\n<tr>\n<td>wp_meta()</td>\n<td>显示管理员的相关控制信息</td>\n</tr>\n<tr>\n<td>get_calendar()</td>\n<td>显示一个日历</td>\n</tr>\n<tr>\n<td>include(TEMPLATEPATH . ‘/searchform.php’)</td>\n<td>导入某个自定义文件,像左边就是/searchform.php文件</td>\n</tr>\n</tbody></table>\n<h3 id=\"判断是否有日志并循环输出日志\"><a href=\"#判断是否有日志并循环输出日志\" class=\"headerlink\" title=\"判断是否有日志并循环输出日志\"></a>判断是否有日志并循环输出日志</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php if(have_posts()) : ?&gt; &lt;!--检查是否有日志--&gt;</span><br><span class=\"line\">\t&lt;?php while(have_posts()) : the_post(); ?&gt; &lt;!--循环输出日志--&gt;</span><br><span class=\"line\">\t\t\t&lt;div class&#x3D;&quot;post&quot; id&#x3D;&quot;post-&lt;?php the_ID(); ?&gt;&quot;&gt;</span><br><span class=\"line\">\t\t\t\t&lt;h2&gt;&lt;a href&#x3D;&quot;&lt;?php the_permalink(); ?&gt;&quot; title&#x3D;&quot;&lt;?php the_title(); ?&gt;&quot;&gt;&lt;?php the_title(); ?&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;&lt;!--日志标题--&gt;</span><br><span class=\"line\">\t\t\t\t&lt;div class&#x3D;&#39;entry&#39;&gt;</span><br><span class=\"line\">\t\t\t\t&lt;?php the_content(); ?&gt;</span><br><span class=\"line\">\t\t\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">\t\t\t&lt;p class&#x3D;&quot;postmetadata&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;?php _e(&#39;Filed under&amp;#58;&#39;); ?&gt; &lt;?php the_category(&#39;, &#39;) ?&gt; &lt;?php _e(&#39;by&#39;); ?&gt; &lt;?php  the_author(); ?&gt;&lt;br &#x2F;&gt;</span><br><span class=\"line\">\t\t\t&lt;?php comments_popup_link(&#39;No Comments &amp;#187;&#39;, &#39;1 Comment &amp;#187;&#39;, &#39;% Comments &amp;#187;&#39;); ?&gt; &lt;?php edit_post_link(&#39;Edit&#39;, &#39; &amp;#124; &#39;, &#39;&#39;); ?&gt;</span><br><span class=\"line\">\t\t\t&lt;&#x2F;p&gt;</span><br><span class=\"line\">\t\t\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">\t&lt;?php endwhile; ?&gt;</span><br><span class=\"line\">\t&lt;div class&#x3D;&quot;navigation&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;?php posts_nav_link(&#39;index&#39;, &#39;&lt;&lt;上一页&#39;, &#39;下一页&gt;&gt;&#39;); ?&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">\t&lt;?php else : ?&gt; &lt;!--如果没有日志--&gt;</span><br><span class=\"line\">\t&lt;div class &#x3D; &quot;post&quot;&gt;</span><br><span class=\"line\">\t\t&lt;h2&gt;&lt;?php _e(&quot;Not Found&quot;); ?&gt;&lt;&#x2F;h2&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;?php endif; ?&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"搜索框\"><a href=\"#搜索框\" class=\"headerlink\" title=\"搜索框\"></a>搜索框</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form method&#x3D;&quot;get&quot; id&#x3D;&quot;searchform&quot; action&#x3D;&quot;&lt;?php bloginfo(&#39;home&#39;); ?&gt;&#x2F;&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;&lt;?php echo wp_specialchars($s, 1); ?&gt;&quot; name&#x3D;&quot;s&quot; id&#x3D;&quot;s&quot; size&#x3D;&quot;15&quot; &#x2F;&gt;&lt;br &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;input type&#x3D;&quot;submit&quot; id&#x3D;&quot;searchsubmit&quot; value&#x3D;&quot;Search&quot; &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>wordpress自定义主题的时候需要用到的函数</p>","more":"<p><a href=\"https://codex.wordpress.org/zh-cn:%E6%A8%A1%E6%9D%BF%E6%A0%87%E7%AD%BE\">参考文档</a></p>\n<table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bloginfo()</td>\n<td>可以拿到博客的信息,name,description,version,特别注意bloginfo(‘stylesheet_url’);会直接找到根目录下的style.css文件,这个页面的样式表</td>\n</tr>\n<tr>\n<td>wp_head()</td>\n<td>一般放在header.php,会有很多东西引入进去</td>\n</tr>\n<tr>\n<td>wp_title()</td>\n<td>网站标题</td>\n</tr>\n<tr>\n<td>get_header()</td>\n<td>检查同目录下是否有header.php,有的话就会调用这个文件作为页面头部</td>\n</tr>\n<tr>\n<td>get_sidebar()</td>\n<td>检查sidebar.php,调用作为侧边栏</td>\n</tr>\n<tr>\n<td>get_footer()</td>\n<td>检查footer.php,调用作为底部栏</td>\n</tr>\n<tr>\n<td>have_posts()</td>\n<td>判断是否有日志</td>\n</tr>\n<tr>\n<td>the_post()</td>\n<td>调用一篇具体的日志,和主循环配合使用</td>\n</tr>\n<tr>\n<td>the_permalink()</td>\n<td>每篇日志地址</td>\n</tr>\n<tr>\n<td>the_title()</td>\n<td>日志标题</td>\n</tr>\n<tr>\n<td>the_content()</td>\n<td>日志内容</td>\n</tr>\n<tr>\n<td>_e()</td>\n<td>框架里面有语言文件,这里是调用语言文件内对应文字,使用类似这样子_e(“Archives”),中文页面下显示归档,英文页面下显示Archives</td>\n</tr>\n<tr>\n<td>the_category()</td>\n<td>分类,这个函数里面有一个参数,可以表示用什么符号去分割多个分类名,例如the_category(‘,’)</td>\n</tr>\n<tr>\n<td>the_author()</td>\n<td>作者名</td>\n</tr>\n<tr>\n<td>the_excerpt()</td>\n<td>日志摘要</td>\n</tr>\n<tr>\n<td>comments_popup_link(‘No Comments »’, ‘1 Comment »’, ‘% Comments »’);</td>\n<td>当弹出留言的功能激活的话，comments_popup_link() 调用一个弹出的留言窗口，如果没有激活，comments_popup_link() 则只是简单的显示留言列表。No Comments » 是在没有留言的时候显示的。1 Comment » 是用于当刚好只有1条留言时候。% Comments &187; 是用于当有多于一条留言的时候。比如：8 Comments »。百分号 % 用来显示数字。» 是用来显示一个双层箭头 »。</td>\n</tr>\n<tr>\n<td>edit_post_link(‘Edit’, ‘&amp;124’, ”);</td>\n<td>这个只有当我们以管理员或者作者身份登录的的时候才可见。</td>\n</tr>\n<tr>\n<td>edit_post_link()</td>\n<td>只是简单显示一个可以用来编辑当前日志的编辑链接，这样就可以让我们不必去管理界面搜寻该日志就能直接编辑。</td>\n</tr>\n<tr>\n<td>edit_post_link()</td>\n<td>有三个参数。第一个是用来确定哪个词你将用在编辑链接的链接标题。如果你使用 Edit post，那么将显示 Edit post 而不是 Edit。第二个参数是用来显示在链接前面的字符，在这里是竖线，代码就是&124;。第三个参数是用于显示在编辑链接后面的字符，在这里没有使用。登录 WordPress 之后，再返回到首页就可以看到“Edit”的链接和一条竖线。</td>\n</tr>\n<tr>\n<td>posts_nav_link(‘中间页’, ‘&lt;&lt;上一页’, ‘下一页&gt;&gt;’)</td>\n<td>调用后一页和前一页的链接,3个参数，分别给链接的中间，前面和后面的设置字符</td>\n</tr>\n<tr>\n<td>previous_post_link(‘%link’)</td>\n<td>上一篇日志</td>\n</tr>\n<tr>\n<td>next_post_link(‘%link’)</td>\n<td>下一篇日志</td>\n</tr>\n<tr>\n<td>wp_list_pages()</td>\n<td>展示页面列表,如果参数里面填<code>title_li=&lt;h2&gt;Pages&lt;/h2&gt;&amp;depth=3</code>,可以设置title的样式,depth指的是页面的展示深度</td>\n</tr>\n<tr>\n<td>wp_list_cats()</td>\n<td>展示分类列表,参数可填<code>sort_column=name&amp;optioncount=1&amp;hierarchical=0</code>,分别是设置排序根据,是否显示文章个数,以分层缩进的方式显示分类列表</td>\n</tr>\n<tr>\n<td>get_links_list();</td>\n<td>友情链接列表,在后台装插件之后就可以用了</td>\n</tr>\n<tr>\n<td>wp_get_archives()</td>\n<td>意思跟上面的差不多,也是有参数,获取的是文章归档列表,参数填type=daily的话就是按日期分,monthly按月分,yearly按年分,format=link以链接形式显示</td>\n</tr>\n<tr>\n<td>wp_loginout()</td>\n<td>退出登录链接</td>\n</tr>\n<tr>\n<td>wp_register()</td>\n<td>注册链接</td>\n</tr>\n<tr>\n<td>wp_meta()</td>\n<td>显示管理员的相关控制信息</td>\n</tr>\n<tr>\n<td>get_calendar()</td>\n<td>显示一个日历</td>\n</tr>\n<tr>\n<td>include(TEMPLATEPATH . ‘/searchform.php’)</td>\n<td>导入某个自定义文件,像左边就是/searchform.php文件</td>\n</tr>\n</tbody></table>\n<h3 id=\"判断是否有日志并循环输出日志\"><a href=\"#判断是否有日志并循环输出日志\" class=\"headerlink\" title=\"判断是否有日志并循环输出日志\"></a>判断是否有日志并循环输出日志</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php if(have_posts()) : ?&gt; &lt;!--检查是否有日志--&gt;</span><br><span class=\"line\">\t&lt;?php while(have_posts()) : the_post(); ?&gt; &lt;!--循环输出日志--&gt;</span><br><span class=\"line\">\t\t\t&lt;div class&#x3D;&quot;post&quot; id&#x3D;&quot;post-&lt;?php the_ID(); ?&gt;&quot;&gt;</span><br><span class=\"line\">\t\t\t\t&lt;h2&gt;&lt;a href&#x3D;&quot;&lt;?php the_permalink(); ?&gt;&quot; title&#x3D;&quot;&lt;?php the_title(); ?&gt;&quot;&gt;&lt;?php the_title(); ?&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;&lt;!--日志标题--&gt;</span><br><span class=\"line\">\t\t\t\t&lt;div class&#x3D;&#39;entry&#39;&gt;</span><br><span class=\"line\">\t\t\t\t&lt;?php the_content(); ?&gt;</span><br><span class=\"line\">\t\t\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">\t\t\t&lt;p class&#x3D;&quot;postmetadata&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;?php _e(&#39;Filed under&amp;#58;&#39;); ?&gt; &lt;?php the_category(&#39;, &#39;) ?&gt; &lt;?php _e(&#39;by&#39;); ?&gt; &lt;?php  the_author(); ?&gt;&lt;br &#x2F;&gt;</span><br><span class=\"line\">\t\t\t&lt;?php comments_popup_link(&#39;No Comments &amp;#187;&#39;, &#39;1 Comment &amp;#187;&#39;, &#39;% Comments &amp;#187;&#39;); ?&gt; &lt;?php edit_post_link(&#39;Edit&#39;, &#39; &amp;#124; &#39;, &#39;&#39;); ?&gt;</span><br><span class=\"line\">\t\t\t&lt;&#x2F;p&gt;</span><br><span class=\"line\">\t\t\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">\t&lt;?php endwhile; ?&gt;</span><br><span class=\"line\">\t&lt;div class&#x3D;&quot;navigation&quot;&gt;</span><br><span class=\"line\">\t\t\t&lt;?php posts_nav_link(&#39;index&#39;, &#39;&lt;&lt;上一页&#39;, &#39;下一页&gt;&gt;&#39;); ?&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">\t&lt;?php else : ?&gt; &lt;!--如果没有日志--&gt;</span><br><span class=\"line\">\t&lt;div class &#x3D; &quot;post&quot;&gt;</span><br><span class=\"line\">\t\t&lt;h2&gt;&lt;?php _e(&quot;Not Found&quot;); ?&gt;&lt;&#x2F;h2&gt;</span><br><span class=\"line\">\t&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;?php endif; ?&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"搜索框\"><a href=\"#搜索框\" class=\"headerlink\" title=\"搜索框\"></a>搜索框</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form method&#x3D;&quot;get&quot; id&#x3D;&quot;searchform&quot; action&#x3D;&quot;&lt;?php bloginfo(&#39;home&#39;); ?&gt;&#x2F;&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;&lt;?php echo wp_specialchars($s, 1); ?&gt;&quot; name&#x3D;&quot;s&quot; id&#x3D;&quot;s&quot; size&#x3D;&quot;15&quot; &#x2F;&gt;&lt;br &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;input type&#x3D;&quot;submit&quot; id&#x3D;&quot;searchsubmit&quot; value&#x3D;&quot;Search&quot; &#x2F;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>"},{"title":"ReactiveCocoa解决异步串行任务执行中多层嵌套/递归的问题","author":"Arclin","abbrlink":"5f5664e4","date":"2017-03-19T16:00:00.000Z","_content":"\n因为在项目中遇到了一个异步的串行任务执行的问题,通过ReactiveCocoa解决了,所以在这里记录一下\n\n<!-- more -->\n\n首先是一个第三方的API,这个API会进行一个网络请求,并且使用block进行回调.批量执行并且是串行执行.\n如果不用RAC,我们可以通过递归,当任务一结束的时候递归执行任务二,以达到串行的效果,然后判断索引达到最后的时候跳出递归,但这种操作如果一多容易造成栈溢出,所以用RAC的优化如下.\n\n首先使用一个`RACSignal`包装API,如下\n\n```\n- (RACSignal *)deleteWithId:(NSString *)identifier\n{\n    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        GTLQueryDrive *query = [GTLQueryDrive queryForFilesDeleteWithFileId:identifier];\n        [self.service executeQuery:query completionHandler:^(GTLServiceTicket *ticket, id object, NSError *error) {\n            if(!error) {\n                [subscriber sendNext:nil];\n                [subscriber sendCompleted];\n            }else {\n                [subscriber sendError:error]; // 失败的时候抛出异常\n            }\n        }];\n        return nil;\n    }];\n    return signal;\n}\n```\n  \n接下来把多个任务组装成一个数组\n\n```\nNSMutableArray *signals = [NSMutableArray array];\nfor (NSString *identifier in identifiers) {\n    RACSignal * signal = [self deleteWithId:identifier];\n    [signals addObject:signal];\n}\n```\n然后使用`RACSignal`的`concat`方法\n\n`concat`会顺序执行数组中的信号内容,上一个signal的信号`sendComplete`之后下一个信号内容才会开始执行\n\n因为我们要在任务全部执行完成的时候发送一个回调和任务执行到一半的时候抛出异常停止任务和队列.\n所以我们顺便加一个`doCompleted`和`catch`\n\n```\nRACSignal *concatSignal = [[[RACSignal concat:signals] doCompleted:^{\n       completeBlock(nil); // 回调告诉前台说所有任务都完成了\n   }] catch:^RACSignal *(NSError *error) {\n       completeBlock(error); // 回调告诉前台说异常了\n       return [RACSignal empty]; // 停止当前和接下来的任务的执行\n   }];\n```\n\n如果你要订阅concatSignal信号的时候用到了UI刷新或者其他需要在主线程执行的任务,那么这里可以加多一个`deliverOn:[RACScheduler mainThreadScheduler]]`\n\n所以最后的信号可能是这样子\n\n```\nRACSignal *concatSignal = [[[[RACSignal concat:signals] doCompleted:^{\n    completeBlock(nil);\n}] catch:^RACSignal *(NSError *error) {\n    completeBlock(error);\n    return [RACSignal empty];\n}] deliverOn:[RACScheduler mainThreadScheduler]];\n```\n\n那订阅信号就简单了\n\n```\n[concatSignal subscribeNext:^(id x) {\n    DKLog(@\"%@\",x);\n}];\n```\n执行的时候他会根据数组的顺序一个个执行信号内的内容,这样子写起来也好看了很多.\n","source":"_posts/ReactiveCocoa解决异步串行任务执行中多层嵌套-递归的问题.md","raw":"---\ntitle: ReactiveCocoa解决异步串行任务执行中多层嵌套/递归的问题\nauthor: Arclin\ntags:\n  - iOS\n  - Reactive Cocoa\ncategories:\n  - iOS\nabbrlink: 5f5664e4\ndate: 2017-03-20 00:00:00\n---\n\n因为在项目中遇到了一个异步的串行任务执行的问题,通过ReactiveCocoa解决了,所以在这里记录一下\n\n<!-- more -->\n\n首先是一个第三方的API,这个API会进行一个网络请求,并且使用block进行回调.批量执行并且是串行执行.\n如果不用RAC,我们可以通过递归,当任务一结束的时候递归执行任务二,以达到串行的效果,然后判断索引达到最后的时候跳出递归,但这种操作如果一多容易造成栈溢出,所以用RAC的优化如下.\n\n首先使用一个`RACSignal`包装API,如下\n\n```\n- (RACSignal *)deleteWithId:(NSString *)identifier\n{\n    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id<RACSubscriber> subscriber) {\n        GTLQueryDrive *query = [GTLQueryDrive queryForFilesDeleteWithFileId:identifier];\n        [self.service executeQuery:query completionHandler:^(GTLServiceTicket *ticket, id object, NSError *error) {\n            if(!error) {\n                [subscriber sendNext:nil];\n                [subscriber sendCompleted];\n            }else {\n                [subscriber sendError:error]; // 失败的时候抛出异常\n            }\n        }];\n        return nil;\n    }];\n    return signal;\n}\n```\n  \n接下来把多个任务组装成一个数组\n\n```\nNSMutableArray *signals = [NSMutableArray array];\nfor (NSString *identifier in identifiers) {\n    RACSignal * signal = [self deleteWithId:identifier];\n    [signals addObject:signal];\n}\n```\n然后使用`RACSignal`的`concat`方法\n\n`concat`会顺序执行数组中的信号内容,上一个signal的信号`sendComplete`之后下一个信号内容才会开始执行\n\n因为我们要在任务全部执行完成的时候发送一个回调和任务执行到一半的时候抛出异常停止任务和队列.\n所以我们顺便加一个`doCompleted`和`catch`\n\n```\nRACSignal *concatSignal = [[[RACSignal concat:signals] doCompleted:^{\n       completeBlock(nil); // 回调告诉前台说所有任务都完成了\n   }] catch:^RACSignal *(NSError *error) {\n       completeBlock(error); // 回调告诉前台说异常了\n       return [RACSignal empty]; // 停止当前和接下来的任务的执行\n   }];\n```\n\n如果你要订阅concatSignal信号的时候用到了UI刷新或者其他需要在主线程执行的任务,那么这里可以加多一个`deliverOn:[RACScheduler mainThreadScheduler]]`\n\n所以最后的信号可能是这样子\n\n```\nRACSignal *concatSignal = [[[[RACSignal concat:signals] doCompleted:^{\n    completeBlock(nil);\n}] catch:^RACSignal *(NSError *error) {\n    completeBlock(error);\n    return [RACSignal empty];\n}] deliverOn:[RACScheduler mainThreadScheduler]];\n```\n\n那订阅信号就简单了\n\n```\n[concatSignal subscribeNext:^(id x) {\n    DKLog(@\"%@\",x);\n}];\n```\n执行的时候他会根据数组的顺序一个个执行信号内的内容,这样子写起来也好看了很多.\n","slug":"ReactiveCocoa解决异步串行任务执行中多层嵌套-递归的问题","published":1,"updated":"2021-04-12T06:07:04.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5b002i45n06e4y5y5y","content":"<p>因为在项目中遇到了一个异步的串行任务执行的问题,通过ReactiveCocoa解决了,所以在这里记录一下</p>\n<span id=\"more\"></span>\n\n<p>首先是一个第三方的API,这个API会进行一个网络请求,并且使用block进行回调.批量执行并且是串行执行.<br>如果不用RAC,我们可以通过递归,当任务一结束的时候递归执行任务二,以达到串行的效果,然后判断索引达到最后的时候跳出递归,但这种操作如果一多容易造成栈溢出,所以用RAC的优化如下.</p>\n<p>首先使用一个<code>RACSignal</code>包装API,如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (RACSignal *)deleteWithId:(NSString *)identifier</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RACSignal *signal &#x3D; [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class=\"line\">        GTLQueryDrive *query &#x3D; [GTLQueryDrive queryForFilesDeleteWithFileId:identifier];</span><br><span class=\"line\">        [self.service executeQuery:query completionHandler:^(GTLServiceTicket *ticket, id object, NSError *error) &#123;</span><br><span class=\"line\">            if(!error) &#123;</span><br><span class=\"line\">                [subscriber sendNext:nil];</span><br><span class=\"line\">                [subscriber sendCompleted];</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                [subscriber sendError:error]; &#x2F;&#x2F; 失败的时候抛出异常</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    return signal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来把多个任务组装成一个数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableArray *signals &#x3D; [NSMutableArray array];</span><br><span class=\"line\">for (NSString *identifier in identifiers) &#123;</span><br><span class=\"line\">    RACSignal * signal &#x3D; [self deleteWithId:identifier];</span><br><span class=\"line\">    [signals addObject:signal];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后使用<code>RACSignal</code>的<code>concat</code>方法</p>\n<p><code>concat</code>会顺序执行数组中的信号内容,上一个signal的信号<code>sendComplete</code>之后下一个信号内容才会开始执行</p>\n<p>因为我们要在任务全部执行完成的时候发送一个回调和任务执行到一半的时候抛出异常停止任务和队列.<br>所以我们顺便加一个<code>doCompleted</code>和<code>catch</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *concatSignal &#x3D; [[[RACSignal concat:signals] doCompleted:^&#123;</span><br><span class=\"line\">       completeBlock(nil); &#x2F;&#x2F; 回调告诉前台说所有任务都完成了</span><br><span class=\"line\">   &#125;] catch:^RACSignal *(NSError *error) &#123;</span><br><span class=\"line\">       completeBlock(error); &#x2F;&#x2F; 回调告诉前台说异常了</span><br><span class=\"line\">       return [RACSignal empty]; &#x2F;&#x2F; 停止当前和接下来的任务的执行</span><br><span class=\"line\">   &#125;];</span><br></pre></td></tr></table></figure>\n\n<p>如果你要订阅concatSignal信号的时候用到了UI刷新或者其他需要在主线程执行的任务,那么这里可以加多一个<code>deliverOn:[RACScheduler mainThreadScheduler]]</code></p>\n<p>所以最后的信号可能是这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *concatSignal &#x3D; [[[[RACSignal concat:signals] doCompleted:^&#123;</span><br><span class=\"line\">    completeBlock(nil);</span><br><span class=\"line\">&#125;] catch:^RACSignal *(NSError *error) &#123;</span><br><span class=\"line\">    completeBlock(error);</span><br><span class=\"line\">    return [RACSignal empty];</span><br><span class=\"line\">&#125;] deliverOn:[RACScheduler mainThreadScheduler]];</span><br></pre></td></tr></table></figure>\n\n<p>那订阅信号就简单了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[concatSignal subscribeNext:^(id x) &#123;</span><br><span class=\"line\">    DKLog(@&quot;%@&quot;,x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>执行的时候他会根据数组的顺序一个个执行信号内的内容,这样子写起来也好看了很多.</p>\n","site":{"data":{}},"excerpt":"<p>因为在项目中遇到了一个异步的串行任务执行的问题,通过ReactiveCocoa解决了,所以在这里记录一下</p>","more":"<p>首先是一个第三方的API,这个API会进行一个网络请求,并且使用block进行回调.批量执行并且是串行执行.<br>如果不用RAC,我们可以通过递归,当任务一结束的时候递归执行任务二,以达到串行的效果,然后判断索引达到最后的时候跳出递归,但这种操作如果一多容易造成栈溢出,所以用RAC的优化如下.</p>\n<p>首先使用一个<code>RACSignal</code>包装API,如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (RACSignal *)deleteWithId:(NSString *)identifier</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RACSignal *signal &#x3D; [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class=\"line\">        GTLQueryDrive *query &#x3D; [GTLQueryDrive queryForFilesDeleteWithFileId:identifier];</span><br><span class=\"line\">        [self.service executeQuery:query completionHandler:^(GTLServiceTicket *ticket, id object, NSError *error) &#123;</span><br><span class=\"line\">            if(!error) &#123;</span><br><span class=\"line\">                [subscriber sendNext:nil];</span><br><span class=\"line\">                [subscriber sendCompleted];</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                [subscriber sendError:error]; &#x2F;&#x2F; 失败的时候抛出异常</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    return signal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来把多个任务组装成一个数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSMutableArray *signals &#x3D; [NSMutableArray array];</span><br><span class=\"line\">for (NSString *identifier in identifiers) &#123;</span><br><span class=\"line\">    RACSignal * signal &#x3D; [self deleteWithId:identifier];</span><br><span class=\"line\">    [signals addObject:signal];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后使用<code>RACSignal</code>的<code>concat</code>方法</p>\n<p><code>concat</code>会顺序执行数组中的信号内容,上一个signal的信号<code>sendComplete</code>之后下一个信号内容才会开始执行</p>\n<p>因为我们要在任务全部执行完成的时候发送一个回调和任务执行到一半的时候抛出异常停止任务和队列.<br>所以我们顺便加一个<code>doCompleted</code>和<code>catch</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *concatSignal &#x3D; [[[RACSignal concat:signals] doCompleted:^&#123;</span><br><span class=\"line\">       completeBlock(nil); &#x2F;&#x2F; 回调告诉前台说所有任务都完成了</span><br><span class=\"line\">   &#125;] catch:^RACSignal *(NSError *error) &#123;</span><br><span class=\"line\">       completeBlock(error); &#x2F;&#x2F; 回调告诉前台说异常了</span><br><span class=\"line\">       return [RACSignal empty]; &#x2F;&#x2F; 停止当前和接下来的任务的执行</span><br><span class=\"line\">   &#125;];</span><br></pre></td></tr></table></figure>\n\n<p>如果你要订阅concatSignal信号的时候用到了UI刷新或者其他需要在主线程执行的任务,那么这里可以加多一个<code>deliverOn:[RACScheduler mainThreadScheduler]]</code></p>\n<p>所以最后的信号可能是这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *concatSignal &#x3D; [[[[RACSignal concat:signals] doCompleted:^&#123;</span><br><span class=\"line\">    completeBlock(nil);</span><br><span class=\"line\">&#125;] catch:^RACSignal *(NSError *error) &#123;</span><br><span class=\"line\">    completeBlock(error);</span><br><span class=\"line\">    return [RACSignal empty];</span><br><span class=\"line\">&#125;] deliverOn:[RACScheduler mainThreadScheduler]];</span><br></pre></td></tr></table></figure>\n\n<p>那订阅信号就简单了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[concatSignal subscribeNext:^(id x) &#123;</span><br><span class=\"line\">    DKLog(@&quot;%@&quot;,x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>执行的时候他会根据数组的顺序一个个执行信号内的内容,这样子写起来也好看了很多.</p>"},{"title":" UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃的问题","author":"Arclin","abbrlink":"1787ee1c","date":"2016-11-08T16:00:00.000Z","_content":"UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃\n\n```\n-[UIPopoverController dealloc] reached while popover is still visible.\n```\n\n<!-- more -->\n\n错误的大体意思是：popover在仍旧可见的时候被销毁了（调用了dealloc）\n\n从错误可以得出的结论\n当popover仍旧可见的时候，不准销毁popover对象\n在销\n毁popover对象之前，一定先让popover消失（不可见）\n\n```\n@property (retain, nonatomic) UIPopoverController *popoverController;\n\n- (void)splitViewController:(UISplitViewController *)svc willHideViewController:(UIViewController *)aViewController withBarButtonItem:(UIBarButtonItem *)barButtonItem forPopoverController:(UIPopoverController *)pc\n{\n    self.popoverController = pc;\n}\n\n- (void)dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion\n{\n    [self.popoverController dismissPopoverAnimated:YES];\n    [super dismissViewControllerAnimated:YES completion:nil];\n}\n```","source":"_posts/UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃的问题.md","raw":"---\ntitle: ' UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃的问题'\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 1787ee1c\ndate: 2016-11-09 00:00:00\n---\nUISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃\n\n```\n-[UIPopoverController dealloc] reached while popover is still visible.\n```\n\n<!-- more -->\n\n错误的大体意思是：popover在仍旧可见的时候被销毁了（调用了dealloc）\n\n从错误可以得出的结论\n当popover仍旧可见的时候，不准销毁popover对象\n在销\n毁popover对象之前，一定先让popover消失（不可见）\n\n```\n@property (retain, nonatomic) UIPopoverController *popoverController;\n\n- (void)splitViewController:(UISplitViewController *)svc willHideViewController:(UIViewController *)aViewController withBarButtonItem:(UIBarButtonItem *)barButtonItem forPopoverController:(UIPopoverController *)pc\n{\n    self.popoverController = pc;\n}\n\n- (void)dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion\n{\n    [self.popoverController dismissPopoverAnimated:YES];\n    [super dismissViewControllerAnimated:YES completion:nil];\n}\n```","slug":"UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃的问题","published":1,"updated":"2021-04-12T06:07:04.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5c002m45n01lknhsof","content":"<p>UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-[UIPopoverController dealloc] reached while popover is still visible.</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<p>错误的大体意思是：popover在仍旧可见的时候被销毁了（调用了dealloc）</p>\n<p>从错误可以得出的结论<br>当popover仍旧可见的时候，不准销毁popover对象<br>在销<br>毁popover对象之前，一定先让popover消失（不可见）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property (retain, nonatomic) UIPopoverController *popoverController;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)splitViewController:(UISplitViewController *)svc willHideViewController:(UIViewController *)aViewController withBarButtonItem:(UIBarButtonItem *)barButtonItem forPopoverController:(UIPopoverController *)pc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self.popoverController &#x3D; pc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.popoverController dismissPopoverAnimated:YES];</span><br><span class=\"line\">    [super dismissViewControllerAnimated:YES completion:nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-[UIPopoverController dealloc] reached while popover is still visible.</span><br></pre></td></tr></table></figure>","more":"<p>错误的大体意思是：popover在仍旧可见的时候被销毁了（调用了dealloc）</p>\n<p>从错误可以得出的结论<br>当popover仍旧可见的时候，不准销毁popover对象<br>在销<br>毁popover对象之前，一定先让popover消失（不可见）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property (retain, nonatomic) UIPopoverController *popoverController;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)splitViewController:(UISplitViewController *)svc willHideViewController:(UIViewController *)aViewController withBarButtonItem:(UIBarButtonItem *)barButtonItem forPopoverController:(UIPopoverController *)pc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self.popoverController &#x3D; pc;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.popoverController dismissPopoverAnimated:YES];</span><br><span class=\"line\">    [super dismissViewControllerAnimated:YES completion:nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"docker笔记","author":"Arclin","abbrlink":"4417b09c","date":"2018-02-18T14:19:00.000Z","_content":"docker学习笔记\n\n<!-- more -->\n\ndocker是一种类似虚拟机的存在\n\n\n// 查看本机docker信息\n\n`docker info`\n\n// 运行hello world\n\n`docker run centos:6.7 /bin/echo \"Hello World\"`\n\n//  -t 进入伪终端\n//  -i 允许你对容器内的标准输入 (STDIN) 进行交互。 \n\n`docker run -i -t centos:6.7 /bin/bash`\n\n// -d 后台模式\n\n` docker run -d centos:6.7 /bin/sh -c \"while true;do echo hello world; sleep 1; done\"`\n\n//  查看当前运行的容器\n\n`docker ps`\n\n// -l 最近创建的容器\n\n`docker ps -l`\n\n// -a 所有容器\n\n`docker ps -a`\n\n// 查看运行log\n\n`docker logs 2b1b7a428627`\n\n//或\n\n`docker logs angry_austin`\n\n// 具体参数看ps的内容进行替换\n\n// 停止容器\n\n`docker stop angry_austin`\n\n\n// 删除容器\n\n`docker rm awesome_bardeen`\n\n// 进入容器终端 允许标准输入\n\n`docker exec -it practical_fermat /bin/bash`\n\n中间的参数是容器名\n\n// 拉取镜像 (如:httpd)\n\n`docker pull httpd`\n\n// 指定端口运行容器\n\n`docker run -d -p 5000:5001 httpd`\n\n// 提交新的镜像并添加tag v2 \n\n`docker commit -m \"has update\" -a=\"arclin\" 000c5746fa52 arclin/centos:v2`\n\n// 添加标签dev  中间那串是容器id\n\n`docker tag d 607e5fac1115 arclin/centos:dev`\n\n// 删除标签 6.7\n\n`docker rmi -f arclin/centos:6.7`\n\n\n// 指定端口运行  8080 是本地端口 80是容器端口 -d 是后台运行的意思\n\n`docker run -d -p 8080:80 httpd`\n\n// 随机端口运行 -P\n\n`docker run -d -P  httpd`\n\n// 查看容器practical_fermat的80端口被绑定到本机的哪个端口上了\n\n`docker port practical_fermat 80`\n\n// 运行的时候顺便给容器命名\n\n`docker run -d -P --name testName httpd`\n\n// 给容器重命名\n\n`docker rename practical_fermat test_httpd`\n\n// 运行nginx\n```\ndocker run -p 81:80 --name mynginx -v $PWD/www:/www -v \n\n$PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx  \n-p 81:80：将容器的80端口映射到主机的81端口\n--name mynginx：将容器命名为mynginx\n-v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www\n-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf\n-v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs\n```\n\n// 查看nginx的文件系统\n\n`docker inspect mynginx | grep Mounts -A 20`\n\n\n// 安装Apache\n\n`mkdir -p  ~/apache/www ~/apache/logs ~/apache/conf `\n\n// 运行Apache\n\n`docker run -p 80:80 -v $PWD/www/:/usr/local/apache2/htdocs/ -v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf -v $PWD/logs/:/usr/local/apache2/logs/ -d httpd`\n\n\n// 删除所有容器\n\n`sudo docker rm $(docker ps -a -q)`\n\n// 下载容器内的文件\n\n`docker cp ecef8319d2c8:/root/test.txt /root/`\n\n// 上传文件到容器中\n\n`docker cp /root/test.txt ecef8319d2c8:/root/`\n","source":"_posts/docker笔记.md","raw":"---\ntitle: docker笔记\nauthor: Arclin\ntags:\n  - docker\ncategories:\n  - Linux\nabbrlink: 4417b09c\ndate: 2018-02-18 22:19:00\n---\ndocker学习笔记\n\n<!-- more -->\n\ndocker是一种类似虚拟机的存在\n\n\n// 查看本机docker信息\n\n`docker info`\n\n// 运行hello world\n\n`docker run centos:6.7 /bin/echo \"Hello World\"`\n\n//  -t 进入伪终端\n//  -i 允许你对容器内的标准输入 (STDIN) 进行交互。 \n\n`docker run -i -t centos:6.7 /bin/bash`\n\n// -d 后台模式\n\n` docker run -d centos:6.7 /bin/sh -c \"while true;do echo hello world; sleep 1; done\"`\n\n//  查看当前运行的容器\n\n`docker ps`\n\n// -l 最近创建的容器\n\n`docker ps -l`\n\n// -a 所有容器\n\n`docker ps -a`\n\n// 查看运行log\n\n`docker logs 2b1b7a428627`\n\n//或\n\n`docker logs angry_austin`\n\n// 具体参数看ps的内容进行替换\n\n// 停止容器\n\n`docker stop angry_austin`\n\n\n// 删除容器\n\n`docker rm awesome_bardeen`\n\n// 进入容器终端 允许标准输入\n\n`docker exec -it practical_fermat /bin/bash`\n\n中间的参数是容器名\n\n// 拉取镜像 (如:httpd)\n\n`docker pull httpd`\n\n// 指定端口运行容器\n\n`docker run -d -p 5000:5001 httpd`\n\n// 提交新的镜像并添加tag v2 \n\n`docker commit -m \"has update\" -a=\"arclin\" 000c5746fa52 arclin/centos:v2`\n\n// 添加标签dev  中间那串是容器id\n\n`docker tag d 607e5fac1115 arclin/centos:dev`\n\n// 删除标签 6.7\n\n`docker rmi -f arclin/centos:6.7`\n\n\n// 指定端口运行  8080 是本地端口 80是容器端口 -d 是后台运行的意思\n\n`docker run -d -p 8080:80 httpd`\n\n// 随机端口运行 -P\n\n`docker run -d -P  httpd`\n\n// 查看容器practical_fermat的80端口被绑定到本机的哪个端口上了\n\n`docker port practical_fermat 80`\n\n// 运行的时候顺便给容器命名\n\n`docker run -d -P --name testName httpd`\n\n// 给容器重命名\n\n`docker rename practical_fermat test_httpd`\n\n// 运行nginx\n```\ndocker run -p 81:80 --name mynginx -v $PWD/www:/www -v \n\n$PWD/conf/nginx.conf:/etc/nginx/nginx.conf -v $PWD/logs:/wwwlogs  -d nginx  \n-p 81:80：将容器的80端口映射到主机的81端口\n--name mynginx：将容器命名为mynginx\n-v $PWD/www:/www：将主机中当前目录下的www挂载到容器的/www\n-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的/etc/nginx/nginx.conf\n-v $PWD/logs:/wwwlogs：将主机中当前目录下的logs挂载到容器的/wwwlogs\n```\n\n// 查看nginx的文件系统\n\n`docker inspect mynginx | grep Mounts -A 20`\n\n\n// 安装Apache\n\n`mkdir -p  ~/apache/www ~/apache/logs ~/apache/conf `\n\n// 运行Apache\n\n`docker run -p 80:80 -v $PWD/www/:/usr/local/apache2/htdocs/ -v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf -v $PWD/logs/:/usr/local/apache2/logs/ -d httpd`\n\n\n// 删除所有容器\n\n`sudo docker rm $(docker ps -a -q)`\n\n// 下载容器内的文件\n\n`docker cp ecef8319d2c8:/root/test.txt /root/`\n\n// 上传文件到容器中\n\n`docker cp /root/test.txt ecef8319d2c8:/root/`\n","slug":"docker笔记","published":1,"updated":"2021-04-12T06:07:04.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5d002q45n0ak3a55c3","content":"<p>docker学习笔记</p>\n<span id=\"more\"></span>\n\n<p>docker是一种类似虚拟机的存在</p>\n<p>// 查看本机docker信息</p>\n<p><code>docker info</code></p>\n<p>// 运行hello world</p>\n<p><code>docker run centos:6.7 /bin/echo &quot;Hello World&quot;</code></p>\n<p>//  -t 进入伪终端<br>//  -i 允许你对容器内的标准输入 (STDIN) 进行交互。 </p>\n<p><code>docker run -i -t centos:6.7 /bin/bash</code></p>\n<p>// -d 后台模式</p>\n<p><code> docker run -d centos:6.7 /bin/sh -c &quot;while true;do echo hello world; sleep 1; done&quot;</code></p>\n<p>//  查看当前运行的容器</p>\n<p><code>docker ps</code></p>\n<p>// -l 最近创建的容器</p>\n<p><code>docker ps -l</code></p>\n<p>// -a 所有容器</p>\n<p><code>docker ps -a</code></p>\n<p>// 查看运行log</p>\n<p><code>docker logs 2b1b7a428627</code></p>\n<p>//或</p>\n<p><code>docker logs angry_austin</code></p>\n<p>// 具体参数看ps的内容进行替换</p>\n<p>// 停止容器</p>\n<p><code>docker stop angry_austin</code></p>\n<p>// 删除容器</p>\n<p><code>docker rm awesome_bardeen</code></p>\n<p>// 进入容器终端 允许标准输入</p>\n<p><code>docker exec -it practical_fermat /bin/bash</code></p>\n<p>中间的参数是容器名</p>\n<p>// 拉取镜像 (如:httpd)</p>\n<p><code>docker pull httpd</code></p>\n<p>// 指定端口运行容器</p>\n<p><code>docker run -d -p 5000:5001 httpd</code></p>\n<p>// 提交新的镜像并添加tag v2 </p>\n<p><code>docker commit -m &quot;has update&quot; -a=&quot;arclin&quot; 000c5746fa52 arclin/centos:v2</code></p>\n<p>// 添加标签dev  中间那串是容器id</p>\n<p><code>docker tag d 607e5fac1115 arclin/centos:dev</code></p>\n<p>// 删除标签 6.7</p>\n<p><code>docker rmi -f arclin/centos:6.7</code></p>\n<p>// 指定端口运行  8080 是本地端口 80是容器端口 -d 是后台运行的意思</p>\n<p><code>docker run -d -p 8080:80 httpd</code></p>\n<p>// 随机端口运行 -P</p>\n<p><code>docker run -d -P  httpd</code></p>\n<p>// 查看容器practical_fermat的80端口被绑定到本机的哪个端口上了</p>\n<p><code>docker port practical_fermat 80</code></p>\n<p>// 运行的时候顺便给容器命名</p>\n<p><code>docker run -d -P --name testName httpd</code></p>\n<p>// 给容器重命名</p>\n<p><code>docker rename practical_fermat test_httpd</code></p>\n<p>// 运行nginx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p 81:80 --name mynginx -v $PWD&#x2F;www:&#x2F;www -v </span><br><span class=\"line\"></span><br><span class=\"line\">$PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf -v $PWD&#x2F;logs:&#x2F;wwwlogs  -d nginx  </span><br><span class=\"line\">-p 81:80：将容器的80端口映射到主机的81端口</span><br><span class=\"line\">--name mynginx：将容器命名为mynginx</span><br><span class=\"line\">-v $PWD&#x2F;www:&#x2F;www：将主机中当前目录下的www挂载到容器的&#x2F;www</span><br><span class=\"line\">-v $PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class=\"line\">-v $PWD&#x2F;logs:&#x2F;wwwlogs：将主机中当前目录下的logs挂载到容器的&#x2F;wwwlogs</span><br></pre></td></tr></table></figure>\n\n<p>// 查看nginx的文件系统</p>\n<p><code>docker inspect mynginx | grep Mounts -A 20</code></p>\n<p>// 安装Apache</p>\n<p><code>mkdir -p  ~/apache/www ~/apache/logs ~/apache/conf </code></p>\n<p>// 运行Apache</p>\n<p><code>docker run -p 80:80 -v $PWD/www/:/usr/local/apache2/htdocs/ -v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf -v $PWD/logs/:/usr/local/apache2/logs/ -d httpd</code></p>\n<p>// 删除所有容器</p>\n<p><code>sudo docker rm $(docker ps -a -q)</code></p>\n<p>// 下载容器内的文件</p>\n<p><code>docker cp ecef8319d2c8:/root/test.txt /root/</code></p>\n<p>// 上传文件到容器中</p>\n<p><code>docker cp /root/test.txt ecef8319d2c8:/root/</code></p>\n","site":{"data":{}},"excerpt":"<p>docker学习笔记</p>","more":"<p>docker是一种类似虚拟机的存在</p>\n<p>// 查看本机docker信息</p>\n<p><code>docker info</code></p>\n<p>// 运行hello world</p>\n<p><code>docker run centos:6.7 /bin/echo &quot;Hello World&quot;</code></p>\n<p>//  -t 进入伪终端<br>//  -i 允许你对容器内的标准输入 (STDIN) 进行交互。 </p>\n<p><code>docker run -i -t centos:6.7 /bin/bash</code></p>\n<p>// -d 后台模式</p>\n<p><code> docker run -d centos:6.7 /bin/sh -c &quot;while true;do echo hello world; sleep 1; done&quot;</code></p>\n<p>//  查看当前运行的容器</p>\n<p><code>docker ps</code></p>\n<p>// -l 最近创建的容器</p>\n<p><code>docker ps -l</code></p>\n<p>// -a 所有容器</p>\n<p><code>docker ps -a</code></p>\n<p>// 查看运行log</p>\n<p><code>docker logs 2b1b7a428627</code></p>\n<p>//或</p>\n<p><code>docker logs angry_austin</code></p>\n<p>// 具体参数看ps的内容进行替换</p>\n<p>// 停止容器</p>\n<p><code>docker stop angry_austin</code></p>\n<p>// 删除容器</p>\n<p><code>docker rm awesome_bardeen</code></p>\n<p>// 进入容器终端 允许标准输入</p>\n<p><code>docker exec -it practical_fermat /bin/bash</code></p>\n<p>中间的参数是容器名</p>\n<p>// 拉取镜像 (如:httpd)</p>\n<p><code>docker pull httpd</code></p>\n<p>// 指定端口运行容器</p>\n<p><code>docker run -d -p 5000:5001 httpd</code></p>\n<p>// 提交新的镜像并添加tag v2 </p>\n<p><code>docker commit -m &quot;has update&quot; -a=&quot;arclin&quot; 000c5746fa52 arclin/centos:v2</code></p>\n<p>// 添加标签dev  中间那串是容器id</p>\n<p><code>docker tag d 607e5fac1115 arclin/centos:dev</code></p>\n<p>// 删除标签 6.7</p>\n<p><code>docker rmi -f arclin/centos:6.7</code></p>\n<p>// 指定端口运行  8080 是本地端口 80是容器端口 -d 是后台运行的意思</p>\n<p><code>docker run -d -p 8080:80 httpd</code></p>\n<p>// 随机端口运行 -P</p>\n<p><code>docker run -d -P  httpd</code></p>\n<p>// 查看容器practical_fermat的80端口被绑定到本机的哪个端口上了</p>\n<p><code>docker port practical_fermat 80</code></p>\n<p>// 运行的时候顺便给容器命名</p>\n<p><code>docker run -d -P --name testName httpd</code></p>\n<p>// 给容器重命名</p>\n<p><code>docker rename practical_fermat test_httpd</code></p>\n<p>// 运行nginx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -p 81:80 --name mynginx -v $PWD&#x2F;www:&#x2F;www -v </span><br><span class=\"line\"></span><br><span class=\"line\">$PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf -v $PWD&#x2F;logs:&#x2F;wwwlogs  -d nginx  </span><br><span class=\"line\">-p 81:80：将容器的80端口映射到主机的81端口</span><br><span class=\"line\">--name mynginx：将容器命名为mynginx</span><br><span class=\"line\">-v $PWD&#x2F;www:&#x2F;www：将主机中当前目录下的www挂载到容器的&#x2F;www</span><br><span class=\"line\">-v $PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class=\"line\">-v $PWD&#x2F;logs:&#x2F;wwwlogs：将主机中当前目录下的logs挂载到容器的&#x2F;wwwlogs</span><br></pre></td></tr></table></figure>\n\n<p>// 查看nginx的文件系统</p>\n<p><code>docker inspect mynginx | grep Mounts -A 20</code></p>\n<p>// 安装Apache</p>\n<p><code>mkdir -p  ~/apache/www ~/apache/logs ~/apache/conf </code></p>\n<p>// 运行Apache</p>\n<p><code>docker run -p 80:80 -v $PWD/www/:/usr/local/apache2/htdocs/ -v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf -v $PWD/logs/:/usr/local/apache2/logs/ -d httpd</code></p>\n<p>// 删除所有容器</p>\n<p><code>sudo docker rm $(docker ps -a -q)</code></p>\n<p>// 下载容器内的文件</p>\n<p><code>docker cp ecef8319d2c8:/root/test.txt /root/</code></p>\n<p>// 上传文件到容器中</p>\n<p><code>docker cp /root/test.txt ecef8319d2c8:/root/</code></p>"},{"title":"frp 内网穿透","author":"Arclin","abbrlink":"b72542c2","date":"2018-02-18T14:05:00.000Z","_content":"frp 内网穿透\n\n<!-- more -->\n\n[文档](https://github.com/fatedier/frp/blob/master/README_zh.md)\n\n### 服务器CentOS下载安装\n\n```\nwget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_linux_amd64.tar.gz\ntar -zxvf frp_0.13.0_linux_amd64.tar.gz\ncd frp_0.13.0_linux_amd64.tar.gz\nrm -f frpc\nrm -f frpc.ini\nvi frps.ini\n```\n\n编辑frps.ini\n\n```\n[common]\nvhost_http_port = 8001 # http访问端口\nbind_port = 8009 # 远程响应的地址\ndashboard_port = 8002 #控制面板端口号\n# dashboard 用户名密码，默认都为 admin\ndashboard_user = admin\ndashboard_pwd = admin\n```\n\n### 启动服务端\n\n```\n./frps -c ./frps.ini\n```\n\n### Mac客户端下载\n\n```\nwget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_darwin_amd64.tar.gz\ntar -zxvf frp_0.13.0_darwin_amd64.tar.gz\ncd frp_0.13.0_darwin_amd64.tar.gz\nrm -f frps\nrm -f frps.ini\nvi frpc.ini\n```\n\n编辑frpc.ini\n\n```\n[common]\nserver_addr = 120.78.175.51 # 远程服务器地址\nserver_port = 8009 # 服务端填写的bind_port\n\n[web]\ntype = http \nlocal_port = 3000 # 本地要映射的端口\ncustom_domains = frp.arclin.me # 自定义的域名,需要在dnspod绑定远程主机地址\n```\n\n### 客户端运行\n\n```\n ./frpc -c ./frpc.ini\n```","source":"_posts/frp-内网穿透.md","raw":"---\ntitle: frp 内网穿透\nauthor: Arclin\ntags:\n  - frp\ncategories:\n  - Linux\nabbrlink: b72542c2\ndate: 2018-02-18 22:05:00\n---\nfrp 内网穿透\n\n<!-- more -->\n\n[文档](https://github.com/fatedier/frp/blob/master/README_zh.md)\n\n### 服务器CentOS下载安装\n\n```\nwget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_linux_amd64.tar.gz\ntar -zxvf frp_0.13.0_linux_amd64.tar.gz\ncd frp_0.13.0_linux_amd64.tar.gz\nrm -f frpc\nrm -f frpc.ini\nvi frps.ini\n```\n\n编辑frps.ini\n\n```\n[common]\nvhost_http_port = 8001 # http访问端口\nbind_port = 8009 # 远程响应的地址\ndashboard_port = 8002 #控制面板端口号\n# dashboard 用户名密码，默认都为 admin\ndashboard_user = admin\ndashboard_pwd = admin\n```\n\n### 启动服务端\n\n```\n./frps -c ./frps.ini\n```\n\n### Mac客户端下载\n\n```\nwget https://github.com/fatedier/frp/releases/download/v0.13.0/frp_0.13.0_darwin_amd64.tar.gz\ntar -zxvf frp_0.13.0_darwin_amd64.tar.gz\ncd frp_0.13.0_darwin_amd64.tar.gz\nrm -f frps\nrm -f frps.ini\nvi frpc.ini\n```\n\n编辑frpc.ini\n\n```\n[common]\nserver_addr = 120.78.175.51 # 远程服务器地址\nserver_port = 8009 # 服务端填写的bind_port\n\n[web]\ntype = http \nlocal_port = 3000 # 本地要映射的端口\ncustom_domains = frp.arclin.me # 自定义的域名,需要在dnspod绑定远程主机地址\n```\n\n### 客户端运行\n\n```\n ./frpc -c ./frpc.ini\n```","slug":"frp-内网穿透","published":1,"updated":"2021-04-12T06:07:04.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5f002u45n054q476dp","content":"<p>frp 内网穿透</p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://github.com/fatedier/frp/blob/master/README_zh.md\">文档</a></p>\n<h3 id=\"服务器CentOS下载安装\"><a href=\"#服务器CentOS下载安装\" class=\"headerlink\" title=\"服务器CentOS下载安装\"></a>服务器CentOS下载安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.13.0&#x2F;frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">tar -zxvf frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">cd frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">rm -f frpc</span><br><span class=\"line\">rm -f frpc.ini</span><br><span class=\"line\">vi frps.ini</span><br></pre></td></tr></table></figure>\n\n<p>编辑frps.ini</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">vhost_http_port &#x3D; 8001 # http访问端口</span><br><span class=\"line\">bind_port &#x3D; 8009 # 远程响应的地址</span><br><span class=\"line\">dashboard_port &#x3D; 8002 #控制面板端口号</span><br><span class=\"line\"># dashboard 用户名密码，默认都为 admin</span><br><span class=\"line\">dashboard_user &#x3D; admin</span><br><span class=\"line\">dashboard_pwd &#x3D; admin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动服务端\"><a href=\"#启动服务端\" class=\"headerlink\" title=\"启动服务端\"></a>启动服务端</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;frps -c .&#x2F;frps.ini</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Mac客户端下载\"><a href=\"#Mac客户端下载\" class=\"headerlink\" title=\"Mac客户端下载\"></a>Mac客户端下载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.13.0&#x2F;frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">tar -zxvf frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">cd frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">rm -f frps</span><br><span class=\"line\">rm -f frps.ini</span><br><span class=\"line\">vi frpc.ini</span><br></pre></td></tr></table></figure>\n\n<p>编辑frpc.ini</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">server_addr &#x3D; 120.78.175.51 # 远程服务器地址</span><br><span class=\"line\">server_port &#x3D; 8009 # 服务端填写的bind_port</span><br><span class=\"line\"></span><br><span class=\"line\">[web]</span><br><span class=\"line\">type &#x3D; http </span><br><span class=\"line\">local_port &#x3D; 3000 # 本地要映射的端口</span><br><span class=\"line\">custom_domains &#x3D; frp.arclin.me # 自定义的域名,需要在dnspod绑定远程主机地址</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"客户端运行\"><a href=\"#客户端运行\" class=\"headerlink\" title=\"客户端运行\"></a>客户端运行</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;frpc -c .&#x2F;frpc.ini</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>frp 内网穿透</p>","more":"<p><a href=\"https://github.com/fatedier/frp/blob/master/README_zh.md\">文档</a></p>\n<h3 id=\"服务器CentOS下载安装\"><a href=\"#服务器CentOS下载安装\" class=\"headerlink\" title=\"服务器CentOS下载安装\"></a>服务器CentOS下载安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.13.0&#x2F;frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">tar -zxvf frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">cd frp_0.13.0_linux_amd64.tar.gz</span><br><span class=\"line\">rm -f frpc</span><br><span class=\"line\">rm -f frpc.ini</span><br><span class=\"line\">vi frps.ini</span><br></pre></td></tr></table></figure>\n\n<p>编辑frps.ini</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">vhost_http_port &#x3D; 8001 # http访问端口</span><br><span class=\"line\">bind_port &#x3D; 8009 # 远程响应的地址</span><br><span class=\"line\">dashboard_port &#x3D; 8002 #控制面板端口号</span><br><span class=\"line\"># dashboard 用户名密码，默认都为 admin</span><br><span class=\"line\">dashboard_user &#x3D; admin</span><br><span class=\"line\">dashboard_pwd &#x3D; admin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动服务端\"><a href=\"#启动服务端\" class=\"headerlink\" title=\"启动服务端\"></a>启动服务端</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;frps -c .&#x2F;frps.ini</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Mac客户端下载\"><a href=\"#Mac客户端下载\" class=\"headerlink\" title=\"Mac客户端下载\"></a>Mac客户端下载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.13.0&#x2F;frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">tar -zxvf frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">cd frp_0.13.0_darwin_amd64.tar.gz</span><br><span class=\"line\">rm -f frps</span><br><span class=\"line\">rm -f frps.ini</span><br><span class=\"line\">vi frpc.ini</span><br></pre></td></tr></table></figure>\n\n<p>编辑frpc.ini</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[common]</span><br><span class=\"line\">server_addr &#x3D; 120.78.175.51 # 远程服务器地址</span><br><span class=\"line\">server_port &#x3D; 8009 # 服务端填写的bind_port</span><br><span class=\"line\"></span><br><span class=\"line\">[web]</span><br><span class=\"line\">type &#x3D; http </span><br><span class=\"line\">local_port &#x3D; 3000 # 本地要映射的端口</span><br><span class=\"line\">custom_domains &#x3D; frp.arclin.me # 自定义的域名,需要在dnspod绑定远程主机地址</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"客户端运行\"><a href=\"#客户端运行\" class=\"headerlink\" title=\"客户端运行\"></a>客户端运行</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;frpc -c .&#x2F;frpc.ini</span><br></pre></td></tr></table></figure>"},{"title":"XCode 添加Target","author":"Arclin","abbrlink":"8cafabb2","date":"2018-02-18T14:08:00.000Z","_content":"在区分开发环境和测试环境或生产环境的时候经常需要在XCode 添加Target, 所以在此记录一下\n\n<!-- more -->\n\n1. Duplicate target\n2. Change DisplayName & Bundle Identifier\n3. A copy-info.plist，默认生成在程序环境根目录，也就是`A.xcodeproj`的同级目录中，如果想放到里层（比如与`A-info.plist`放在同级目录），可以先在Xcode删除`A copy-info.plist`索引，然后拷贝文件到制定目录中，然后更名为`B-info.plist`，在add到project中。在`Project`的`Build Settings`中，修改`Info.plist` File选项为`B-info.plist`的目录（相对路径）,这样就可以看到Info页了（就是B-info.plist），接着修改`ProductName`和`Bundle identifier`，使之成为另一个app。`Prefix Header的路径`，视具体需求而定是否要修改，如果两个target可以公用同一个`Prefix Header`，那么就不需要修改这里的路径\n4. 修改scheme，在调试的Stop按钮边上，我们可以选择本工程中所有的target来做编译，如果不修改，在这里选择出来的名字就是A copy，为了与新建的target统一起来，同样也要修改这里的名字。点击scheme选择区，然后选Manager Scheme，找到A copy，然后改成你需要的名字，比如B\n5. 生成一个新的target，一定会与原target有区别，这里可以定义预编译宏，来区分两个版本的不同代码，预编译宏可以在Build Settings中Preprocessor Macros定义，比如在我们新建的target B中定义预编译宏MACRO，然后在代码中通过\n```\n\t#if defined (MACRO)\n\t//target  B需要执行的代码\n\t#else\n\t//target A需要执行的代码\n\t#endif\n```\n来区分\n6. 其他：Build Phases（各target编译所包含的内容，需要注意的是，如果创建了target B后，再往A里面添加资源或文件，target B中不会自动增加这些资源，需要手动添加）\n\t- Compile Sources\n\t需要编译的代码文件\n\t- Link Binary With Libraries\n\t编译所依赖的库\n\t- Copy Bundle Resources\n\t编译需要的资源\n\t每个target可以根据具体需要增减里面的内容\n","source":"_posts/XCode-添加Target.md","raw":"---\ntitle: XCode 添加Target\nauthor: Arclin\ntags:\n  - iOS\n  - XCode\ncategories:\n  - iOS\nabbrlink: 8cafabb2\ndate: 2018-02-18 22:08:00\n---\n在区分开发环境和测试环境或生产环境的时候经常需要在XCode 添加Target, 所以在此记录一下\n\n<!-- more -->\n\n1. Duplicate target\n2. Change DisplayName & Bundle Identifier\n3. A copy-info.plist，默认生成在程序环境根目录，也就是`A.xcodeproj`的同级目录中，如果想放到里层（比如与`A-info.plist`放在同级目录），可以先在Xcode删除`A copy-info.plist`索引，然后拷贝文件到制定目录中，然后更名为`B-info.plist`，在add到project中。在`Project`的`Build Settings`中，修改`Info.plist` File选项为`B-info.plist`的目录（相对路径）,这样就可以看到Info页了（就是B-info.plist），接着修改`ProductName`和`Bundle identifier`，使之成为另一个app。`Prefix Header的路径`，视具体需求而定是否要修改，如果两个target可以公用同一个`Prefix Header`，那么就不需要修改这里的路径\n4. 修改scheme，在调试的Stop按钮边上，我们可以选择本工程中所有的target来做编译，如果不修改，在这里选择出来的名字就是A copy，为了与新建的target统一起来，同样也要修改这里的名字。点击scheme选择区，然后选Manager Scheme，找到A copy，然后改成你需要的名字，比如B\n5. 生成一个新的target，一定会与原target有区别，这里可以定义预编译宏，来区分两个版本的不同代码，预编译宏可以在Build Settings中Preprocessor Macros定义，比如在我们新建的target B中定义预编译宏MACRO，然后在代码中通过\n```\n\t#if defined (MACRO)\n\t//target  B需要执行的代码\n\t#else\n\t//target A需要执行的代码\n\t#endif\n```\n来区分\n6. 其他：Build Phases（各target编译所包含的内容，需要注意的是，如果创建了target B后，再往A里面添加资源或文件，target B中不会自动增加这些资源，需要手动添加）\n\t- Compile Sources\n\t需要编译的代码文件\n\t- Link Binary With Libraries\n\t编译所依赖的库\n\t- Copy Bundle Resources\n\t编译需要的资源\n\t每个target可以根据具体需要增减里面的内容\n","slug":"XCode-添加Target","published":1,"updated":"2021-04-12T06:07:04.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5g002y45n0ar0t5kb0","content":"<p>在区分开发环境和测试环境或生产环境的时候经常需要在XCode 添加Target, 所以在此记录一下</p>\n<span id=\"more\"></span>\n\n<ol>\n<li>Duplicate target</li>\n<li>Change DisplayName &amp; Bundle Identifier</li>\n<li>A copy-info.plist，默认生成在程序环境根目录，也就是<code>A.xcodeproj</code>的同级目录中，如果想放到里层（比如与<code>A-info.plist</code>放在同级目录），可以先在Xcode删除<code>A copy-info.plist</code>索引，然后拷贝文件到制定目录中，然后更名为<code>B-info.plist</code>，在add到project中。在<code>Project</code>的<code>Build Settings</code>中，修改<code>Info.plist</code> File选项为<code>B-info.plist</code>的目录（相对路径）,这样就可以看到Info页了（就是B-info.plist），接着修改<code>ProductName</code>和<code>Bundle identifier</code>，使之成为另一个app。<code>Prefix Header的路径</code>，视具体需求而定是否要修改，如果两个target可以公用同一个<code>Prefix Header</code>，那么就不需要修改这里的路径</li>\n<li>修改scheme，在调试的Stop按钮边上，我们可以选择本工程中所有的target来做编译，如果不修改，在这里选择出来的名字就是A copy，为了与新建的target统一起来，同样也要修改这里的名字。点击scheme选择区，然后选Manager Scheme，找到A copy，然后改成你需要的名字，比如B</li>\n<li>生成一个新的target，一定会与原target有区别，这里可以定义预编译宏，来区分两个版本的不同代码，预编译宏可以在Build Settings中Preprocessor Macros定义，比如在我们新建的target B中定义预编译宏MACRO，然后在代码中通过<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if defined (MACRO)</span><br><span class=\"line\">&#x2F;&#x2F;target  B需要执行的代码</span><br><span class=\"line\">#else</span><br><span class=\"line\">&#x2F;&#x2F;target A需要执行的代码</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n来区分</li>\n<li>其他：Build Phases（各target编译所包含的内容，需要注意的是，如果创建了target B后，再往A里面添加资源或文件，target B中不会自动增加这些资源，需要手动添加）<ul>\n<li>Compile Sources<br>需要编译的代码文件</li>\n<li>Link Binary With Libraries<br>编译所依赖的库</li>\n<li>Copy Bundle Resources<br>编译需要的资源<br>每个target可以根据具体需要增减里面的内容</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在区分开发环境和测试环境或生产环境的时候经常需要在XCode 添加Target, 所以在此记录一下</p>","more":"<ol>\n<li>Duplicate target</li>\n<li>Change DisplayName &amp; Bundle Identifier</li>\n<li>A copy-info.plist，默认生成在程序环境根目录，也就是<code>A.xcodeproj</code>的同级目录中，如果想放到里层（比如与<code>A-info.plist</code>放在同级目录），可以先在Xcode删除<code>A copy-info.plist</code>索引，然后拷贝文件到制定目录中，然后更名为<code>B-info.plist</code>，在add到project中。在<code>Project</code>的<code>Build Settings</code>中，修改<code>Info.plist</code> File选项为<code>B-info.plist</code>的目录（相对路径）,这样就可以看到Info页了（就是B-info.plist），接着修改<code>ProductName</code>和<code>Bundle identifier</code>，使之成为另一个app。<code>Prefix Header的路径</code>，视具体需求而定是否要修改，如果两个target可以公用同一个<code>Prefix Header</code>，那么就不需要修改这里的路径</li>\n<li>修改scheme，在调试的Stop按钮边上，我们可以选择本工程中所有的target来做编译，如果不修改，在这里选择出来的名字就是A copy，为了与新建的target统一起来，同样也要修改这里的名字。点击scheme选择区，然后选Manager Scheme，找到A copy，然后改成你需要的名字，比如B</li>\n<li>生成一个新的target，一定会与原target有区别，这里可以定义预编译宏，来区分两个版本的不同代码，预编译宏可以在Build Settings中Preprocessor Macros定义，比如在我们新建的target B中定义预编译宏MACRO，然后在代码中通过<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#if defined (MACRO)</span><br><span class=\"line\">&#x2F;&#x2F;target  B需要执行的代码</span><br><span class=\"line\">#else</span><br><span class=\"line\">&#x2F;&#x2F;target A需要执行的代码</span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n来区分</li>\n<li>其他：Build Phases（各target编译所包含的内容，需要注意的是，如果创建了target B后，再往A里面添加资源或文件，target B中不会自动增加这些资源，需要手动添加）<ul>\n<li>Compile Sources<br>需要编译的代码文件</li>\n<li>Link Binary With Libraries<br>编译所依赖的库</li>\n<li>Copy Bundle Resources<br>编译需要的资源<br>每个target可以根据具体需要增减里面的内容</li>\n</ul>\n</li>\n</ol>"},{"title":"iOS-定位总结","author":"Arclin","abbrlink":"2684222a","date":"2016-10-28T16:00:00.000Z","_content":"iOS-定位总结\n<!-- more -->\n\ninfo.plist 请求用户位置授权\n\n```\n<key>NSLocationWhenInUseUsageDescription</key>\n\t<string>需要使用位置</string>\n<key>NSLocationAlwaysUsageDescription</key>\n\t<string>需要使用位置</string>\n```\n\n代码\n\n\nlanguage: 要生成的位置信息的语言（’China‘还是’中国‘）\n\n - 中文 : @”zh-hans”\n - 英文 : @”en”\n - 日文 : @”jp”\n\n```\n- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location;\n```\n\n```\n@interface DKLocation()<CLLocationManagerDelegate>\n\n@property (nonatomic,strong) CLLocationManager *locationManager;\n\n@end\n@implementation DKLocation\n- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location\n{\n    \n    [[self rac_signalForSelector:@selector(locationManager:didUpdateToLocation:fromLocation:) fromProtocol:@protocol(CLLocationManagerDelegate)] subscribeNext:^(RACTuple *tuple) {\n        // 停止位置更新\n        CLLocationManager *manager = tuple.first;\n        CLLocation *newLocation = tuple.second;\n        \n        [manager stopUpdatingLocation];\n        [_locationManager stopUpdatingLocation];\n        _locationManager.delegate = nil;\n        // 保存 Device 的现语言\n        NSString *userDefaultLanguages = DKUserDefaults(kAppLanguage);\n        // 强制 成 英文\n        [[NSUserDefaults standardUserDefaults] setObject:[NSArray arrayWithObjects:language,nil] forKey:@\"AppleLanguages\"];\n        // 逆地理编码\n        CLGeocoder * geoCoder = [[CLGeocoder alloc] init];\n        [geoCoder reverseGeocodeLocation:newLocation completionHandler:^(NSArray *placemarks, NSError *error) {\n            if(!error){\n                for (CLPlacemark * placemark in placemarks) {\n                    NSString *provinceName = placemark.administrativeArea;\n                    NSString *country = placemark.country;\n                    location(country,provinceName);\n                    DKLog(@\"%@%@\",country,provinceName);\n                    break;\n                }\n            }\n            // 还原Device 的语言\n            [[NSUserDefaults standardUserDefaults] setObject:@[userDefaultLanguages] forKey:@\"AppleLanguages\"];\n        }];\n\n    }];\n    \n    // 初始化定位管理器\n    _locationManager = [[CLLocationManager alloc] init];\n    _locationManager.delegate = self;\n    // 设置定位精确度到米\n    _locationManager.desiredAccuracy = kCLLocationAccuracyBest;\n    // 设置过滤器为无\n    _locationManager.distanceFilter = kCLDistanceFilterNone;\n    if ([_locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) {\n        [_locationManager requestAlwaysAuthorization];\n    }\n    //开始定位，不断调用其代理方法\n    [_locationManager startUpdatingLocation];\n    \n}\n\n@end\n```","source":"_posts/iOS-定位总结.md","raw":"---\ntitle: iOS-定位总结\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 2684222a\ndate: 2016-10-29 00:00:00\n---\niOS-定位总结\n<!-- more -->\n\ninfo.plist 请求用户位置授权\n\n```\n<key>NSLocationWhenInUseUsageDescription</key>\n\t<string>需要使用位置</string>\n<key>NSLocationAlwaysUsageDescription</key>\n\t<string>需要使用位置</string>\n```\n\n代码\n\n\nlanguage: 要生成的位置信息的语言（’China‘还是’中国‘）\n\n - 中文 : @”zh-hans”\n - 英文 : @”en”\n - 日文 : @”jp”\n\n```\n- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location;\n```\n\n```\n@interface DKLocation()<CLLocationManagerDelegate>\n\n@property (nonatomic,strong) CLLocationManager *locationManager;\n\n@end\n@implementation DKLocation\n- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location\n{\n    \n    [[self rac_signalForSelector:@selector(locationManager:didUpdateToLocation:fromLocation:) fromProtocol:@protocol(CLLocationManagerDelegate)] subscribeNext:^(RACTuple *tuple) {\n        // 停止位置更新\n        CLLocationManager *manager = tuple.first;\n        CLLocation *newLocation = tuple.second;\n        \n        [manager stopUpdatingLocation];\n        [_locationManager stopUpdatingLocation];\n        _locationManager.delegate = nil;\n        // 保存 Device 的现语言\n        NSString *userDefaultLanguages = DKUserDefaults(kAppLanguage);\n        // 强制 成 英文\n        [[NSUserDefaults standardUserDefaults] setObject:[NSArray arrayWithObjects:language,nil] forKey:@\"AppleLanguages\"];\n        // 逆地理编码\n        CLGeocoder * geoCoder = [[CLGeocoder alloc] init];\n        [geoCoder reverseGeocodeLocation:newLocation completionHandler:^(NSArray *placemarks, NSError *error) {\n            if(!error){\n                for (CLPlacemark * placemark in placemarks) {\n                    NSString *provinceName = placemark.administrativeArea;\n                    NSString *country = placemark.country;\n                    location(country,provinceName);\n                    DKLog(@\"%@%@\",country,provinceName);\n                    break;\n                }\n            }\n            // 还原Device 的语言\n            [[NSUserDefaults standardUserDefaults] setObject:@[userDefaultLanguages] forKey:@\"AppleLanguages\"];\n        }];\n\n    }];\n    \n    // 初始化定位管理器\n    _locationManager = [[CLLocationManager alloc] init];\n    _locationManager.delegate = self;\n    // 设置定位精确度到米\n    _locationManager.desiredAccuracy = kCLLocationAccuracyBest;\n    // 设置过滤器为无\n    _locationManager.distanceFilter = kCLDistanceFilterNone;\n    if ([_locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) {\n        [_locationManager requestAlwaysAuthorization];\n    }\n    //开始定位，不断调用其代理方法\n    [_locationManager startUpdatingLocation];\n    \n}\n\n@end\n```","slug":"iOS-定位总结","published":1,"updated":"2021-04-12T06:07:04.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5g003245n07eh0ea0s","content":"<p>iOS-定位总结</p>\n<span id=\"more\"></span>\n\n<p>info.plist 请求用户位置授权</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;&#x2F;key&gt;</span><br><span class=\"line\">\t&lt;string&gt;需要使用位置&lt;&#x2F;string&gt;</span><br><span class=\"line\">&lt;key&gt;NSLocationAlwaysUsageDescription&lt;&#x2F;key&gt;</span><br><span class=\"line\">\t&lt;string&gt;需要使用位置&lt;&#x2F;string&gt;</span><br></pre></td></tr></table></figure>\n\n<p>代码</p>\n<p>language: 要生成的位置信息的语言（’China‘还是’中国‘）</p>\n<ul>\n<li>中文 : @”zh-hans”</li>\n<li>英文 : @”en”</li>\n<li>日文 : @”jp”</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface DKLocation()&lt;CLLocationManagerDelegate&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic,strong) CLLocationManager *locationManager;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\">@implementation DKLocation</span><br><span class=\"line\">- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [[self rac_signalForSelector:@selector(locationManager:didUpdateToLocation:fromLocation:) fromProtocol:@protocol(CLLocationManagerDelegate)] subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 停止位置更新</span><br><span class=\"line\">        CLLocationManager *manager &#x3D; tuple.first;</span><br><span class=\"line\">        CLLocation *newLocation &#x3D; tuple.second;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [manager stopUpdatingLocation];</span><br><span class=\"line\">        [_locationManager stopUpdatingLocation];</span><br><span class=\"line\">        _locationManager.delegate &#x3D; nil;</span><br><span class=\"line\">        &#x2F;&#x2F; 保存 Device 的现语言</span><br><span class=\"line\">        NSString *userDefaultLanguages &#x3D; DKUserDefaults(kAppLanguage);</span><br><span class=\"line\">        &#x2F;&#x2F; 强制 成 英文</span><br><span class=\"line\">        [[NSUserDefaults standardUserDefaults] setObject:[NSArray arrayWithObjects:language,nil] forKey:@&quot;AppleLanguages&quot;];</span><br><span class=\"line\">        &#x2F;&#x2F; 逆地理编码</span><br><span class=\"line\">        CLGeocoder * geoCoder &#x3D; [[CLGeocoder alloc] init];</span><br><span class=\"line\">        [geoCoder reverseGeocodeLocation:newLocation completionHandler:^(NSArray *placemarks, NSError *error) &#123;</span><br><span class=\"line\">            if(!error)&#123;</span><br><span class=\"line\">                for (CLPlacemark * placemark in placemarks) &#123;</span><br><span class=\"line\">                    NSString *provinceName &#x3D; placemark.administrativeArea;</span><br><span class=\"line\">                    NSString *country &#x3D; placemark.country;</span><br><span class=\"line\">                    location(country,provinceName);</span><br><span class=\"line\">                    DKLog(@&quot;%@%@&quot;,country,provinceName);</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#x2F;&#x2F; 还原Device 的语言</span><br><span class=\"line\">            [[NSUserDefaults standardUserDefaults] setObject:@[userDefaultLanguages] forKey:@&quot;AppleLanguages&quot;];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 初始化定位管理器</span><br><span class=\"line\">    _locationManager &#x3D; [[CLLocationManager alloc] init];</span><br><span class=\"line\">    _locationManager.delegate &#x3D; self;</span><br><span class=\"line\">    &#x2F;&#x2F; 设置定位精确度到米</span><br><span class=\"line\">    _locationManager.desiredAccuracy &#x3D; kCLLocationAccuracyBest;</span><br><span class=\"line\">    &#x2F;&#x2F; 设置过滤器为无</span><br><span class=\"line\">    _locationManager.distanceFilter &#x3D; kCLDistanceFilterNone;</span><br><span class=\"line\">    if ([_locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) &#123;</span><br><span class=\"line\">        [_locationManager requestAlwaysAuthorization];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;开始定位，不断调用其代理方法</span><br><span class=\"line\">    [_locationManager startUpdatingLocation];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>iOS-定位总结</p>","more":"<p>info.plist 请求用户位置授权</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;&#x2F;key&gt;</span><br><span class=\"line\">\t&lt;string&gt;需要使用位置&lt;&#x2F;string&gt;</span><br><span class=\"line\">&lt;key&gt;NSLocationAlwaysUsageDescription&lt;&#x2F;key&gt;</span><br><span class=\"line\">\t&lt;string&gt;需要使用位置&lt;&#x2F;string&gt;</span><br></pre></td></tr></table></figure>\n\n<p>代码</p>\n<p>language: 要生成的位置信息的语言（’China‘还是’中国‘）</p>\n<ul>\n<li>中文 : @”zh-hans”</li>\n<li>英文 : @”en”</li>\n<li>日文 : @”jp”</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface DKLocation()&lt;CLLocationManagerDelegate&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic,strong) CLLocationManager *locationManager;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\">@implementation DKLocation</span><br><span class=\"line\">- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [[self rac_signalForSelector:@selector(locationManager:didUpdateToLocation:fromLocation:) fromProtocol:@protocol(CLLocationManagerDelegate)] subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 停止位置更新</span><br><span class=\"line\">        CLLocationManager *manager &#x3D; tuple.first;</span><br><span class=\"line\">        CLLocation *newLocation &#x3D; tuple.second;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [manager stopUpdatingLocation];</span><br><span class=\"line\">        [_locationManager stopUpdatingLocation];</span><br><span class=\"line\">        _locationManager.delegate &#x3D; nil;</span><br><span class=\"line\">        &#x2F;&#x2F; 保存 Device 的现语言</span><br><span class=\"line\">        NSString *userDefaultLanguages &#x3D; DKUserDefaults(kAppLanguage);</span><br><span class=\"line\">        &#x2F;&#x2F; 强制 成 英文</span><br><span class=\"line\">        [[NSUserDefaults standardUserDefaults] setObject:[NSArray arrayWithObjects:language,nil] forKey:@&quot;AppleLanguages&quot;];</span><br><span class=\"line\">        &#x2F;&#x2F; 逆地理编码</span><br><span class=\"line\">        CLGeocoder * geoCoder &#x3D; [[CLGeocoder alloc] init];</span><br><span class=\"line\">        [geoCoder reverseGeocodeLocation:newLocation completionHandler:^(NSArray *placemarks, NSError *error) &#123;</span><br><span class=\"line\">            if(!error)&#123;</span><br><span class=\"line\">                for (CLPlacemark * placemark in placemarks) &#123;</span><br><span class=\"line\">                    NSString *provinceName &#x3D; placemark.administrativeArea;</span><br><span class=\"line\">                    NSString *country &#x3D; placemark.country;</span><br><span class=\"line\">                    location(country,provinceName);</span><br><span class=\"line\">                    DKLog(@&quot;%@%@&quot;,country,provinceName);</span><br><span class=\"line\">                    break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#x2F;&#x2F; 还原Device 的语言</span><br><span class=\"line\">            [[NSUserDefaults standardUserDefaults] setObject:@[userDefaultLanguages] forKey:@&quot;AppleLanguages&quot;];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 初始化定位管理器</span><br><span class=\"line\">    _locationManager &#x3D; [[CLLocationManager alloc] init];</span><br><span class=\"line\">    _locationManager.delegate &#x3D; self;</span><br><span class=\"line\">    &#x2F;&#x2F; 设置定位精确度到米</span><br><span class=\"line\">    _locationManager.desiredAccuracy &#x3D; kCLLocationAccuracyBest;</span><br><span class=\"line\">    &#x2F;&#x2F; 设置过滤器为无</span><br><span class=\"line\">    _locationManager.distanceFilter &#x3D; kCLDistanceFilterNone;</span><br><span class=\"line\">    if ([_locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) &#123;</span><br><span class=\"line\">        [_locationManager requestAlwaysAuthorization];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;开始定位，不断调用其代理方法</span><br><span class=\"line\">    [_locationManager startUpdatingLocation];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>"},{"title":"iOS13新API","author":"Arclin","abbrlink":"f356f3c1","date":"2019-10-24T05:18:00.000Z","_content":"\n可能会用到的iOS13新Api\n\n<!-- more -->\n\n## 接口类\n\n### 截图转PDF\n\nsafari可以长截图了\n<img width=20% src=\"https://i.loli.net/2019/10/24/iHxWAqL63E2ZfMY.jpg\">\n\n然后我们可以把`UIScrollView`的截图转成PDF\n\n[文档](https://developer.apple.com/documentation/uikit/uiscreenshotservicedelegate)\n\n### 双指滑动手势\n\n![](https://i.loli.net/2019/10/24/FbSEV8WCXcQRrf9.gif)\n\n```\n/// 是否允许多指选中\noptional func tableView(_ tableView: UITableView, shouldBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) -> Bool\n\n///多指选中开始，这里可以做一些UI修改，比如修改导航栏上按钮的文本\noptional func tableView(_ tableView: UITableView, didBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) \n```\n\n### 深色模式\n\n见[文章](https://www.jianshu.com/p/176537b0d9dd)\n\n## Framework类\n\n### Multiple UI Instances\n\n可以支持一个界面同时展示多个控制器（不是父子控制器那种）\n在iPad上可以使用\n\n![](https://docs-assets.developer.apple.com/published/8ce996907a/fc0975ae-c186-438c-abdd-5280f650c377.png)\n\n主要类`UIScene`\n\n[文档](https://developer.apple.com/documentation/uikit/app_and_environment)\n\n\n### BackgroundTasks\n\n好消息~ 现在维持后台不被杀可以直接用这个API了，以前的会用后台获取定位和播放静音音乐的方式，但是现在只要注册后台就可以了，但是还是只有短期，长时间的话可能会要求充电状态或者持续的网络状态。\n\n[文档](https://developer.apple.com/documentation/backgroundtasks/)\n\n### Camera Capture\n\n现在可以同时使用前后摄像头，可以进行分割遮罩，可以识别出头发，皮肤，牙齿\n\n[文档1](https://developer.apple.com/documentation/avfoundation/avcapturemulticamsession/)\n\n[文档2](https://developer.apple.com/documentation/avfoundation/avsemanticsegmentationmatte/)\n\n### Combine\n\n官方版RxSwift，主要是配合SwiftUI使用\n\n[文档](https://developer.apple.com/documentation/combine/)\n\n### Core Haptics\n\n可以在UI交互的时候给点小触觉反馈，比如打开关闭UISwitch的时候小震动一下，或者播放点声音之类的\n\n[文档](https://developer.apple.com/documentation/corehaptics/)\n\n### Apple CryptoKit\n\n好消息，苹果自带HMAC、SHA、AES、NIST加密算法啦\n\n[文档](https://developer.apple.com/documentation/cryptokit/)\n\n### VisionKit\n\n好消息，苹果自带图片转文字功能啦\n\n[文档](https://developer.apple.com/documentation/visionkit/)\n\n### MetricKit\n\n用来收集用户设备信息的，主要是使用App的过程中的耗电，CPU等等性能指标，可以依据这些优化你的App\n\n[文档](https://developer.apple.com/documentation/metrickit/)\n\n### PencilKit\n\niPad上跟Apple Pencil交互的API\n\n[文档](https://developer.apple.com/documentation/pencilkit/)\n\n### Vision\n\n图像识别相关framework\niOS11的功能：面部和面部界标检测，条形码识别，图像配准以及一般特征跟踪。\n\niOS13的新功能：\n1. 对图像进行显著性分析。\n2. 在图像中检测人类和动物。\n3. 对图像进行分类和搜索。\n4. 分析图像与特征打印的相似性。\n5. 对文档执行文本识别。\n\n[文档](https://developer.apple.com/documentation/vision/)\n\n### Sign in with Apple\n\n苹果登录\n\n[文档](https://developer.apple.com/sign-in-with-apple/get-started/)\n\n### SF Symbols\n\n可以用来显示矢量图\n\n[文档](https://developer.apple.com/documentation/uikit/uiimage/configuring_and_displaying_symbol_images_in_your_ui/)\n\n### Bring Your iPad App to Mac\n\n直接把iPad App 迁移到 Mac，不过还是要做适配的，下面文档会有一些适配规则，以兼容两个端\n\n[参考](https://developer.apple.com/design/human-interface-guidelines/ios/overview/mac-catalyst/)\n\n[文档1](https://developer.apple.com/documentation/xcode/creating_a_mac_version_of_your_ipad_app)\n\n[文档2](https://developer.apple.com/documentation/uikit/mac_catalyst/optimizing_your_ipad_app_for_mac)\n\n### ARKit 3\n\n应该大家都知道ARKit，这次主要是多了些新特性，包括动态捕捉动作，同时捕捉多个面部，同时开启前后摄像头等。\n\n[文档](https://developer.apple.com/documentation/arkit/)\n\n### RealityKit\n\n3D模型搭建、展示用\n\n[文档](https://developer.apple.com/documentation/realitykit/)\n\n### Core ML 3\n\n升级版机器学习套件\n\n[文档](https://developer.apple.com/documentation/coreml/)\n\n","source":"_posts/iOS13新API.md","raw":"title: iOS13新API\nauthor: Arclin\nabbrlink: f356f3c1\ntags:\n  - iOS\n  - feature\ncategories:\n  - iOS\ndate: 2019-10-24 13:18:00\n---\n\n可能会用到的iOS13新Api\n\n<!-- more -->\n\n## 接口类\n\n### 截图转PDF\n\nsafari可以长截图了\n<img width=20% src=\"https://i.loli.net/2019/10/24/iHxWAqL63E2ZfMY.jpg\">\n\n然后我们可以把`UIScrollView`的截图转成PDF\n\n[文档](https://developer.apple.com/documentation/uikit/uiscreenshotservicedelegate)\n\n### 双指滑动手势\n\n![](https://i.loli.net/2019/10/24/FbSEV8WCXcQRrf9.gif)\n\n```\n/// 是否允许多指选中\noptional func tableView(_ tableView: UITableView, shouldBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) -> Bool\n\n///多指选中开始，这里可以做一些UI修改，比如修改导航栏上按钮的文本\noptional func tableView(_ tableView: UITableView, didBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) \n```\n\n### 深色模式\n\n见[文章](https://www.jianshu.com/p/176537b0d9dd)\n\n## Framework类\n\n### Multiple UI Instances\n\n可以支持一个界面同时展示多个控制器（不是父子控制器那种）\n在iPad上可以使用\n\n![](https://docs-assets.developer.apple.com/published/8ce996907a/fc0975ae-c186-438c-abdd-5280f650c377.png)\n\n主要类`UIScene`\n\n[文档](https://developer.apple.com/documentation/uikit/app_and_environment)\n\n\n### BackgroundTasks\n\n好消息~ 现在维持后台不被杀可以直接用这个API了，以前的会用后台获取定位和播放静音音乐的方式，但是现在只要注册后台就可以了，但是还是只有短期，长时间的话可能会要求充电状态或者持续的网络状态。\n\n[文档](https://developer.apple.com/documentation/backgroundtasks/)\n\n### Camera Capture\n\n现在可以同时使用前后摄像头，可以进行分割遮罩，可以识别出头发，皮肤，牙齿\n\n[文档1](https://developer.apple.com/documentation/avfoundation/avcapturemulticamsession/)\n\n[文档2](https://developer.apple.com/documentation/avfoundation/avsemanticsegmentationmatte/)\n\n### Combine\n\n官方版RxSwift，主要是配合SwiftUI使用\n\n[文档](https://developer.apple.com/documentation/combine/)\n\n### Core Haptics\n\n可以在UI交互的时候给点小触觉反馈，比如打开关闭UISwitch的时候小震动一下，或者播放点声音之类的\n\n[文档](https://developer.apple.com/documentation/corehaptics/)\n\n### Apple CryptoKit\n\n好消息，苹果自带HMAC、SHA、AES、NIST加密算法啦\n\n[文档](https://developer.apple.com/documentation/cryptokit/)\n\n### VisionKit\n\n好消息，苹果自带图片转文字功能啦\n\n[文档](https://developer.apple.com/documentation/visionkit/)\n\n### MetricKit\n\n用来收集用户设备信息的，主要是使用App的过程中的耗电，CPU等等性能指标，可以依据这些优化你的App\n\n[文档](https://developer.apple.com/documentation/metrickit/)\n\n### PencilKit\n\niPad上跟Apple Pencil交互的API\n\n[文档](https://developer.apple.com/documentation/pencilkit/)\n\n### Vision\n\n图像识别相关framework\niOS11的功能：面部和面部界标检测，条形码识别，图像配准以及一般特征跟踪。\n\niOS13的新功能：\n1. 对图像进行显著性分析。\n2. 在图像中检测人类和动物。\n3. 对图像进行分类和搜索。\n4. 分析图像与特征打印的相似性。\n5. 对文档执行文本识别。\n\n[文档](https://developer.apple.com/documentation/vision/)\n\n### Sign in with Apple\n\n苹果登录\n\n[文档](https://developer.apple.com/sign-in-with-apple/get-started/)\n\n### SF Symbols\n\n可以用来显示矢量图\n\n[文档](https://developer.apple.com/documentation/uikit/uiimage/configuring_and_displaying_symbol_images_in_your_ui/)\n\n### Bring Your iPad App to Mac\n\n直接把iPad App 迁移到 Mac，不过还是要做适配的，下面文档会有一些适配规则，以兼容两个端\n\n[参考](https://developer.apple.com/design/human-interface-guidelines/ios/overview/mac-catalyst/)\n\n[文档1](https://developer.apple.com/documentation/xcode/creating_a_mac_version_of_your_ipad_app)\n\n[文档2](https://developer.apple.com/documentation/uikit/mac_catalyst/optimizing_your_ipad_app_for_mac)\n\n### ARKit 3\n\n应该大家都知道ARKit，这次主要是多了些新特性，包括动态捕捉动作，同时捕捉多个面部，同时开启前后摄像头等。\n\n[文档](https://developer.apple.com/documentation/arkit/)\n\n### RealityKit\n\n3D模型搭建、展示用\n\n[文档](https://developer.apple.com/documentation/realitykit/)\n\n### Core ML 3\n\n升级版机器学习套件\n\n[文档](https://developer.apple.com/documentation/coreml/)\n\n","slug":"iOS13新API","published":1,"updated":"2021-04-19T02:11:38.064Z","_id":"cknndog5h003645n0820f43bb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>可能会用到的iOS13新Api</p>\n<span id=\"more\"></span>\n\n<h2 id=\"接口类\"><a href=\"#接口类\" class=\"headerlink\" title=\"接口类\"></a>接口类</h2><h3 id=\"截图转PDF\"><a href=\"#截图转PDF\" class=\"headerlink\" title=\"截图转PDF\"></a>截图转PDF</h3><p>safari可以长截图了<br><img width=20% src=\"https://i.loli.net/2019/10/24/iHxWAqL63E2ZfMY.jpg\"></p>\n<p>然后我们可以把<code>UIScrollView</code>的截图转成PDF</p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiscreenshotservicedelegate\">文档</a></p>\n<h3 id=\"双指滑动手势\"><a href=\"#双指滑动手势\" class=\"headerlink\" title=\"双指滑动手势\"></a>双指滑动手势</h3><p><img src=\"https://i.loli.net/2019/10/24/FbSEV8WCXcQRrf9.gif\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;&#x2F; 是否允许多指选中</span><br><span class=\"line\">optional func tableView(_ tableView: UITableView, shouldBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) -&gt; Bool</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;&#x2F;多指选中开始，这里可以做一些UI修改，比如修改导航栏上按钮的文本</span><br><span class=\"line\">optional func tableView(_ tableView: UITableView, didBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"深色模式\"><a href=\"#深色模式\" class=\"headerlink\" title=\"深色模式\"></a>深色模式</h3><p>见<a href=\"https://www.jianshu.com/p/176537b0d9dd\">文章</a></p>\n<h2 id=\"Framework类\"><a href=\"#Framework类\" class=\"headerlink\" title=\"Framework类\"></a>Framework类</h2><h3 id=\"Multiple-UI-Instances\"><a href=\"#Multiple-UI-Instances\" class=\"headerlink\" title=\"Multiple UI Instances\"></a>Multiple UI Instances</h3><p>可以支持一个界面同时展示多个控制器（不是父子控制器那种）<br>在iPad上可以使用</p>\n<p><img src=\"https://docs-assets.developer.apple.com/published/8ce996907a/fc0975ae-c186-438c-abdd-5280f650c377.png\"></p>\n<p>主要类<code>UIScene</code></p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/app_and_environment\">文档</a></p>\n<h3 id=\"BackgroundTasks\"><a href=\"#BackgroundTasks\" class=\"headerlink\" title=\"BackgroundTasks\"></a>BackgroundTasks</h3><p>好消息~ 现在维持后台不被杀可以直接用这个API了，以前的会用后台获取定位和播放静音音乐的方式，但是现在只要注册后台就可以了，但是还是只有短期，长时间的话可能会要求充电状态或者持续的网络状态。</p>\n<p><a href=\"https://developer.apple.com/documentation/backgroundtasks/\">文档</a></p>\n<h3 id=\"Camera-Capture\"><a href=\"#Camera-Capture\" class=\"headerlink\" title=\"Camera Capture\"></a>Camera Capture</h3><p>现在可以同时使用前后摄像头，可以进行分割遮罩，可以识别出头发，皮肤，牙齿</p>\n<p><a href=\"https://developer.apple.com/documentation/avfoundation/avcapturemulticamsession/\">文档1</a></p>\n<p><a href=\"https://developer.apple.com/documentation/avfoundation/avsemanticsegmentationmatte/\">文档2</a></p>\n<h3 id=\"Combine\"><a href=\"#Combine\" class=\"headerlink\" title=\"Combine\"></a>Combine</h3><p>官方版RxSwift，主要是配合SwiftUI使用</p>\n<p><a href=\"https://developer.apple.com/documentation/combine/\">文档</a></p>\n<h3 id=\"Core-Haptics\"><a href=\"#Core-Haptics\" class=\"headerlink\" title=\"Core Haptics\"></a>Core Haptics</h3><p>可以在UI交互的时候给点小触觉反馈，比如打开关闭UISwitch的时候小震动一下，或者播放点声音之类的</p>\n<p><a href=\"https://developer.apple.com/documentation/corehaptics/\">文档</a></p>\n<h3 id=\"Apple-CryptoKit\"><a href=\"#Apple-CryptoKit\" class=\"headerlink\" title=\"Apple CryptoKit\"></a>Apple CryptoKit</h3><p>好消息，苹果自带HMAC、SHA、AES、NIST加密算法啦</p>\n<p><a href=\"https://developer.apple.com/documentation/cryptokit/\">文档</a></p>\n<h3 id=\"VisionKit\"><a href=\"#VisionKit\" class=\"headerlink\" title=\"VisionKit\"></a>VisionKit</h3><p>好消息，苹果自带图片转文字功能啦</p>\n<p><a href=\"https://developer.apple.com/documentation/visionkit/\">文档</a></p>\n<h3 id=\"MetricKit\"><a href=\"#MetricKit\" class=\"headerlink\" title=\"MetricKit\"></a>MetricKit</h3><p>用来收集用户设备信息的，主要是使用App的过程中的耗电，CPU等等性能指标，可以依据这些优化你的App</p>\n<p><a href=\"https://developer.apple.com/documentation/metrickit/\">文档</a></p>\n<h3 id=\"PencilKit\"><a href=\"#PencilKit\" class=\"headerlink\" title=\"PencilKit\"></a>PencilKit</h3><p>iPad上跟Apple Pencil交互的API</p>\n<p><a href=\"https://developer.apple.com/documentation/pencilkit/\">文档</a></p>\n<h3 id=\"Vision\"><a href=\"#Vision\" class=\"headerlink\" title=\"Vision\"></a>Vision</h3><p>图像识别相关framework<br>iOS11的功能：面部和面部界标检测，条形码识别，图像配准以及一般特征跟踪。</p>\n<p>iOS13的新功能：</p>\n<ol>\n<li>对图像进行显著性分析。</li>\n<li>在图像中检测人类和动物。</li>\n<li>对图像进行分类和搜索。</li>\n<li>分析图像与特征打印的相似性。</li>\n<li>对文档执行文本识别。</li>\n</ol>\n<p><a href=\"https://developer.apple.com/documentation/vision/\">文档</a></p>\n<h3 id=\"Sign-in-with-Apple\"><a href=\"#Sign-in-with-Apple\" class=\"headerlink\" title=\"Sign in with Apple\"></a>Sign in with Apple</h3><p>苹果登录</p>\n<p><a href=\"https://developer.apple.com/sign-in-with-apple/get-started/\">文档</a></p>\n<h3 id=\"SF-Symbols\"><a href=\"#SF-Symbols\" class=\"headerlink\" title=\"SF Symbols\"></a>SF Symbols</h3><p>可以用来显示矢量图</p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiimage/configuring_and_displaying_symbol_images_in_your_ui/\">文档</a></p>\n<h3 id=\"Bring-Your-iPad-App-to-Mac\"><a href=\"#Bring-Your-iPad-App-to-Mac\" class=\"headerlink\" title=\"Bring Your iPad App to Mac\"></a>Bring Your iPad App to Mac</h3><p>直接把iPad App 迁移到 Mac，不过还是要做适配的，下面文档会有一些适配规则，以兼容两个端</p>\n<p><a href=\"https://developer.apple.com/design/human-interface-guidelines/ios/overview/mac-catalyst/\">参考</a></p>\n<p><a href=\"https://developer.apple.com/documentation/xcode/creating_a_mac_version_of_your_ipad_app\">文档1</a></p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/mac_catalyst/optimizing_your_ipad_app_for_mac\">文档2</a></p>\n<h3 id=\"ARKit-3\"><a href=\"#ARKit-3\" class=\"headerlink\" title=\"ARKit 3\"></a>ARKit 3</h3><p>应该大家都知道ARKit，这次主要是多了些新特性，包括动态捕捉动作，同时捕捉多个面部，同时开启前后摄像头等。</p>\n<p><a href=\"https://developer.apple.com/documentation/arkit/\">文档</a></p>\n<h3 id=\"RealityKit\"><a href=\"#RealityKit\" class=\"headerlink\" title=\"RealityKit\"></a>RealityKit</h3><p>3D模型搭建、展示用</p>\n<p><a href=\"https://developer.apple.com/documentation/realitykit/\">文档</a></p>\n<h3 id=\"Core-ML-3\"><a href=\"#Core-ML-3\" class=\"headerlink\" title=\"Core ML 3\"></a>Core ML 3</h3><p>升级版机器学习套件</p>\n<p><a href=\"https://developer.apple.com/documentation/coreml/\">文档</a></p>\n","site":{"data":{}},"excerpt":"<p>可能会用到的iOS13新Api</p>","more":"<h2 id=\"接口类\"><a href=\"#接口类\" class=\"headerlink\" title=\"接口类\"></a>接口类</h2><h3 id=\"截图转PDF\"><a href=\"#截图转PDF\" class=\"headerlink\" title=\"截图转PDF\"></a>截图转PDF</h3><p>safari可以长截图了<br><img width=20% src=\"https://i.loli.net/2019/10/24/iHxWAqL63E2ZfMY.jpg\"></p>\n<p>然后我们可以把<code>UIScrollView</code>的截图转成PDF</p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiscreenshotservicedelegate\">文档</a></p>\n<h3 id=\"双指滑动手势\"><a href=\"#双指滑动手势\" class=\"headerlink\" title=\"双指滑动手势\"></a>双指滑动手势</h3><p><img src=\"https://i.loli.net/2019/10/24/FbSEV8WCXcQRrf9.gif\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;&#x2F; 是否允许多指选中</span><br><span class=\"line\">optional func tableView(_ tableView: UITableView, shouldBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) -&gt; Bool</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;&#x2F;多指选中开始，这里可以做一些UI修改，比如修改导航栏上按钮的文本</span><br><span class=\"line\">optional func tableView(_ tableView: UITableView, didBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"深色模式\"><a href=\"#深色模式\" class=\"headerlink\" title=\"深色模式\"></a>深色模式</h3><p>见<a href=\"https://www.jianshu.com/p/176537b0d9dd\">文章</a></p>\n<h2 id=\"Framework类\"><a href=\"#Framework类\" class=\"headerlink\" title=\"Framework类\"></a>Framework类</h2><h3 id=\"Multiple-UI-Instances\"><a href=\"#Multiple-UI-Instances\" class=\"headerlink\" title=\"Multiple UI Instances\"></a>Multiple UI Instances</h3><p>可以支持一个界面同时展示多个控制器（不是父子控制器那种）<br>在iPad上可以使用</p>\n<p><img src=\"https://docs-assets.developer.apple.com/published/8ce996907a/fc0975ae-c186-438c-abdd-5280f650c377.png\"></p>\n<p>主要类<code>UIScene</code></p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/app_and_environment\">文档</a></p>\n<h3 id=\"BackgroundTasks\"><a href=\"#BackgroundTasks\" class=\"headerlink\" title=\"BackgroundTasks\"></a>BackgroundTasks</h3><p>好消息~ 现在维持后台不被杀可以直接用这个API了，以前的会用后台获取定位和播放静音音乐的方式，但是现在只要注册后台就可以了，但是还是只有短期，长时间的话可能会要求充电状态或者持续的网络状态。</p>\n<p><a href=\"https://developer.apple.com/documentation/backgroundtasks/\">文档</a></p>\n<h3 id=\"Camera-Capture\"><a href=\"#Camera-Capture\" class=\"headerlink\" title=\"Camera Capture\"></a>Camera Capture</h3><p>现在可以同时使用前后摄像头，可以进行分割遮罩，可以识别出头发，皮肤，牙齿</p>\n<p><a href=\"https://developer.apple.com/documentation/avfoundation/avcapturemulticamsession/\">文档1</a></p>\n<p><a href=\"https://developer.apple.com/documentation/avfoundation/avsemanticsegmentationmatte/\">文档2</a></p>\n<h3 id=\"Combine\"><a href=\"#Combine\" class=\"headerlink\" title=\"Combine\"></a>Combine</h3><p>官方版RxSwift，主要是配合SwiftUI使用</p>\n<p><a href=\"https://developer.apple.com/documentation/combine/\">文档</a></p>\n<h3 id=\"Core-Haptics\"><a href=\"#Core-Haptics\" class=\"headerlink\" title=\"Core Haptics\"></a>Core Haptics</h3><p>可以在UI交互的时候给点小触觉反馈，比如打开关闭UISwitch的时候小震动一下，或者播放点声音之类的</p>\n<p><a href=\"https://developer.apple.com/documentation/corehaptics/\">文档</a></p>\n<h3 id=\"Apple-CryptoKit\"><a href=\"#Apple-CryptoKit\" class=\"headerlink\" title=\"Apple CryptoKit\"></a>Apple CryptoKit</h3><p>好消息，苹果自带HMAC、SHA、AES、NIST加密算法啦</p>\n<p><a href=\"https://developer.apple.com/documentation/cryptokit/\">文档</a></p>\n<h3 id=\"VisionKit\"><a href=\"#VisionKit\" class=\"headerlink\" title=\"VisionKit\"></a>VisionKit</h3><p>好消息，苹果自带图片转文字功能啦</p>\n<p><a href=\"https://developer.apple.com/documentation/visionkit/\">文档</a></p>\n<h3 id=\"MetricKit\"><a href=\"#MetricKit\" class=\"headerlink\" title=\"MetricKit\"></a>MetricKit</h3><p>用来收集用户设备信息的，主要是使用App的过程中的耗电，CPU等等性能指标，可以依据这些优化你的App</p>\n<p><a href=\"https://developer.apple.com/documentation/metrickit/\">文档</a></p>\n<h3 id=\"PencilKit\"><a href=\"#PencilKit\" class=\"headerlink\" title=\"PencilKit\"></a>PencilKit</h3><p>iPad上跟Apple Pencil交互的API</p>\n<p><a href=\"https://developer.apple.com/documentation/pencilkit/\">文档</a></p>\n<h3 id=\"Vision\"><a href=\"#Vision\" class=\"headerlink\" title=\"Vision\"></a>Vision</h3><p>图像识别相关framework<br>iOS11的功能：面部和面部界标检测，条形码识别，图像配准以及一般特征跟踪。</p>\n<p>iOS13的新功能：</p>\n<ol>\n<li>对图像进行显著性分析。</li>\n<li>在图像中检测人类和动物。</li>\n<li>对图像进行分类和搜索。</li>\n<li>分析图像与特征打印的相似性。</li>\n<li>对文档执行文本识别。</li>\n</ol>\n<p><a href=\"https://developer.apple.com/documentation/vision/\">文档</a></p>\n<h3 id=\"Sign-in-with-Apple\"><a href=\"#Sign-in-with-Apple\" class=\"headerlink\" title=\"Sign in with Apple\"></a>Sign in with Apple</h3><p>苹果登录</p>\n<p><a href=\"https://developer.apple.com/sign-in-with-apple/get-started/\">文档</a></p>\n<h3 id=\"SF-Symbols\"><a href=\"#SF-Symbols\" class=\"headerlink\" title=\"SF Symbols\"></a>SF Symbols</h3><p>可以用来显示矢量图</p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/uiimage/configuring_and_displaying_symbol_images_in_your_ui/\">文档</a></p>\n<h3 id=\"Bring-Your-iPad-App-to-Mac\"><a href=\"#Bring-Your-iPad-App-to-Mac\" class=\"headerlink\" title=\"Bring Your iPad App to Mac\"></a>Bring Your iPad App to Mac</h3><p>直接把iPad App 迁移到 Mac，不过还是要做适配的，下面文档会有一些适配规则，以兼容两个端</p>\n<p><a href=\"https://developer.apple.com/design/human-interface-guidelines/ios/overview/mac-catalyst/\">参考</a></p>\n<p><a href=\"https://developer.apple.com/documentation/xcode/creating_a_mac_version_of_your_ipad_app\">文档1</a></p>\n<p><a href=\"https://developer.apple.com/documentation/uikit/mac_catalyst/optimizing_your_ipad_app_for_mac\">文档2</a></p>\n<h3 id=\"ARKit-3\"><a href=\"#ARKit-3\" class=\"headerlink\" title=\"ARKit 3\"></a>ARKit 3</h3><p>应该大家都知道ARKit，这次主要是多了些新特性，包括动态捕捉动作，同时捕捉多个面部，同时开启前后摄像头等。</p>\n<p><a href=\"https://developer.apple.com/documentation/arkit/\">文档</a></p>\n<h3 id=\"RealityKit\"><a href=\"#RealityKit\" class=\"headerlink\" title=\"RealityKit\"></a>RealityKit</h3><p>3D模型搭建、展示用</p>\n<p><a href=\"https://developer.apple.com/documentation/realitykit/\">文档</a></p>\n<h3 id=\"Core-ML-3\"><a href=\"#Core-ML-3\" class=\"headerlink\" title=\"Core ML 3\"></a>Core ML 3</h3><p>升级版机器学习套件</p>\n<p><a href=\"https://developer.apple.com/documentation/coreml/\">文档</a></p>"},{"title":"iOS基于Navigation-Base-on-ViewModel的路由搭建——HOOK方式实现","author":"Arclin","abbrlink":"b111382b","date":"2017-01-04T16:00:00.000Z","_content":"本文主要讲述的是在 iOS 中使用 MVVM 架构开发的情况下，将 ViewModel 作为行为驱动主体，通过 Hook 的方式，设计一个 App 的路由层\n\n<!-- more -->\n\n- 什么是路由\n\n\t- 路由在服务端指的是url请求的分层解析，将一个请求分发到对应的应用处理程序。\n在移动端指的是将 App 内页面访问、H5与App之间和访问请求和 App之间的访问请求 进行分发的逻辑层。\n\n- 在移动端中路由需要做什么事情\n\n\t- 针对网络上的各种说法，这里做一下简要说明：\n\t\t- 提供接口供外部访问，这里的”外部”指的可能是App内的一个ViewController，也有可能是其他应用（包括系统应用），也有可能是 H5页面。\n分发资源。路由不需要依赖外部的资源的定义，就可以将资源传递给目的地。（‘资源’在这里指的是原生页面、模块、组件等等）\n\t\t- 统一的标识符（或者统一格式的标识符）去标识资源，并且可以通过这些标示符去统一访问请求的过程。\n\t\t- 解决安全访问的问题，如果是外部的H5、App去访问你的 App,那么就得特别注意这个问题。（本文暂不提及这个问题）\n\n- 在移动端中路由的使用场景\n\n\t- 原生界面之间，模块之间与组件之间的交互（例如页面的跳转之类）\n\t- H5页面与原生界面之间的交互\n\t- 解除业务依赖\n\t- 组件化开发\n\n- iOS自带的系统访问方式、统一的连接协议\n\n\t- 苹果开发了[URLScheme](https://developer.apple.com/library/content/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899)这种东西，使得 App 能够在沙盒机制的前提下互相调用，定义URL-Scheme的方式如下\n> - 协议部分来标示App应用\n> - 主机Host部分用于标示业务线或者是应用提供的划分好的服务实体，比方说index、discover是业务条线，api-asycn是对外提供的api，pushService是App内部的推送服务等。\n> - 路径部分则可以是细分的页面、组件或者服务的标示\n> - 参数定义有一些是必要的，比如说action来标示动作，比方说可以使用get标示获取、insert增加，userToken表示安全的用户令牌，source表示来源，当然像是userToken与source这些都是路由层需要进行解析和验证的，而action则是业务相关的参数，这一点在路由曾设计的时候需要进行详细区分\n\n- 讲完了路由的概念，接下来谈谈 路由设计\n\t- 我们先抽取最常见的页面跳转来讲，因为我们使用的是 MVVM,那么从理论上来讲，我们就应该让App以 ViewModel为驱动进行运作，而不是用 ViewController,之前说 ViewController 在跳转的时候只需要关心跳转过去的界面是否是一个 UIViewController 的子类，而不需要关心这个 viewController的具体细节,所以考虑用 ViewModel把 目的 ViewController 传递到当前 ViewController，但是ViewModel 严格来讲不能引入任何 UIKit 的任何内容，不然ViewModel级就会失去其可测试性，所以我们通过引入服务总线的概念，维护一个NavigationController 的堆栈（这个思想来自于雷纯锋的博客中的一篇文章[MVVM With ReactiveCocoa](http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/)）具体实现如下\n\n```\n//这个是协议声明部分\n@protocol MRCNavigationProtocol <NSObject>\n- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated;\n- (void)popViewModelAnimated:(BOOL)animated;\n- (void)popToRootViewModelAnimated:(BOOL)animated;\n- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion;\n- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion;\n- (void)resetRootViewModel:(MRCViewModel *)viewModel;\n@end\n```\n  \n以下是方法的实现部分，没有写任何方法的实现过程，只是进行了空操作，目的是使用 Hook 思想去捕获操作\n  \n```\n- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated {}\n- (void)popViewModelAnimated:(BOOL)animated {}\n- (void)popToRootViewModelAnimated:(BOOL)animated {}\n- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion {}\n- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion {}\n- (void)resetRootViewModel:(MRCViewModel *)viewModel {}\n```\n\n栈顶的 NavigationController 进行 Hook 并执行真正的跳转操作(使用到了 ReactiveCocoa， 因为要捕获的方法太多，这里只列举两条)\n\n```\n- (void)registerNavigationHooks {\n  \t @weakify(self)\n    [[(NSObject *)self.services\n        rac_signalForSelector:@selector(pushViewModel:animated:)]\n        subscribeNext:^(RACTuple *tuple) {\n            @strongify(self)\n            UIViewController *viewController = (UIViewController *)[MRCRouter.sharedInstance viewControllerForViewModel:tuple.first];\n            [self.navigationControllers.lastObject pushViewController:viewController animated:[tuple.second boolValue]];\n        }];\n    [[(NSObject *)self.services\n        rac_signalForSelector:@selector(popViewModelAnimated:)]\n        subscribeNext:^(RACTuple *tuple) {\n          @strongify(self)\n            [self.navigationControllers.lastObject popViewControllerAnimated:[tuple.first boolValue]];\n    }];\n}\n```\n\n实际在 ViewController 里面调用起来就会是这种感觉\n\n```\n- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {\n    [tableView deselectRowAtIndexPath:indexPath animated:YES];\n    if (indexPath.section == 0) {\n        MRCTrendingViewModel *trendingViewModel = [[MRCTrendingViewModel alloc] initWithServices:self.viewModel.services params:nil];\n        [self.viewModel.services pushViewModel:trendingViewModel animated:YES];\n    }\n}\n```\n\n然后看下将ViewModel与 ViewController 关联起来的 路由内的映射(截取部分)\n\n```\n- (NSDictionary *)viewModelViewMappings {\n   return @{\n   \t   @\"MRCLoginViewModel\": @\"MRCLoginViewController\",\n      @\"MRCHomepageViewModel\": @\"MRCHomepageViewController\",\n      @\"MRCRepoDetailViewModel\": @\"MRCRepoDetailViewController\",\n      @\"MRCWebViewModel\": @\"MRCWebViewController\",\n   };\n}\n```\n\n当然这上面的只是路由的实现方案1，纯粹地将 ViewController 与 ViewModel 关联起来，方案2是 建立一个路由层通过URL 的方式进行路由交互参考[一步步构建iOS路由](http://www.jianshu.com/p/3a902f274a3d)这部分我后面会讲讲我的思考。\n\n","source":"_posts/iOS基于Navigation-Base-on-ViewModel的路由搭建——HOOK方式实现.md","raw":"---\ntitle: iOS基于Navigation-Base-on-ViewModel的路由搭建——HOOK方式实现\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: b111382b\ndate: 2017-01-05 00:00:00\n---\n本文主要讲述的是在 iOS 中使用 MVVM 架构开发的情况下，将 ViewModel 作为行为驱动主体，通过 Hook 的方式，设计一个 App 的路由层\n\n<!-- more -->\n\n- 什么是路由\n\n\t- 路由在服务端指的是url请求的分层解析，将一个请求分发到对应的应用处理程序。\n在移动端指的是将 App 内页面访问、H5与App之间和访问请求和 App之间的访问请求 进行分发的逻辑层。\n\n- 在移动端中路由需要做什么事情\n\n\t- 针对网络上的各种说法，这里做一下简要说明：\n\t\t- 提供接口供外部访问，这里的”外部”指的可能是App内的一个ViewController，也有可能是其他应用（包括系统应用），也有可能是 H5页面。\n分发资源。路由不需要依赖外部的资源的定义，就可以将资源传递给目的地。（‘资源’在这里指的是原生页面、模块、组件等等）\n\t\t- 统一的标识符（或者统一格式的标识符）去标识资源，并且可以通过这些标示符去统一访问请求的过程。\n\t\t- 解决安全访问的问题，如果是外部的H5、App去访问你的 App,那么就得特别注意这个问题。（本文暂不提及这个问题）\n\n- 在移动端中路由的使用场景\n\n\t- 原生界面之间，模块之间与组件之间的交互（例如页面的跳转之类）\n\t- H5页面与原生界面之间的交互\n\t- 解除业务依赖\n\t- 组件化开发\n\n- iOS自带的系统访问方式、统一的连接协议\n\n\t- 苹果开发了[URLScheme](https://developer.apple.com/library/content/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899)这种东西，使得 App 能够在沙盒机制的前提下互相调用，定义URL-Scheme的方式如下\n> - 协议部分来标示App应用\n> - 主机Host部分用于标示业务线或者是应用提供的划分好的服务实体，比方说index、discover是业务条线，api-asycn是对外提供的api，pushService是App内部的推送服务等。\n> - 路径部分则可以是细分的页面、组件或者服务的标示\n> - 参数定义有一些是必要的，比如说action来标示动作，比方说可以使用get标示获取、insert增加，userToken表示安全的用户令牌，source表示来源，当然像是userToken与source这些都是路由层需要进行解析和验证的，而action则是业务相关的参数，这一点在路由曾设计的时候需要进行详细区分\n\n- 讲完了路由的概念，接下来谈谈 路由设计\n\t- 我们先抽取最常见的页面跳转来讲，因为我们使用的是 MVVM,那么从理论上来讲，我们就应该让App以 ViewModel为驱动进行运作，而不是用 ViewController,之前说 ViewController 在跳转的时候只需要关心跳转过去的界面是否是一个 UIViewController 的子类，而不需要关心这个 viewController的具体细节,所以考虑用 ViewModel把 目的 ViewController 传递到当前 ViewController，但是ViewModel 严格来讲不能引入任何 UIKit 的任何内容，不然ViewModel级就会失去其可测试性，所以我们通过引入服务总线的概念，维护一个NavigationController 的堆栈（这个思想来自于雷纯锋的博客中的一篇文章[MVVM With ReactiveCocoa](http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/)）具体实现如下\n\n```\n//这个是协议声明部分\n@protocol MRCNavigationProtocol <NSObject>\n- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated;\n- (void)popViewModelAnimated:(BOOL)animated;\n- (void)popToRootViewModelAnimated:(BOOL)animated;\n- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion;\n- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion;\n- (void)resetRootViewModel:(MRCViewModel *)viewModel;\n@end\n```\n  \n以下是方法的实现部分，没有写任何方法的实现过程，只是进行了空操作，目的是使用 Hook 思想去捕获操作\n  \n```\n- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated {}\n- (void)popViewModelAnimated:(BOOL)animated {}\n- (void)popToRootViewModelAnimated:(BOOL)animated {}\n- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion {}\n- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion {}\n- (void)resetRootViewModel:(MRCViewModel *)viewModel {}\n```\n\n栈顶的 NavigationController 进行 Hook 并执行真正的跳转操作(使用到了 ReactiveCocoa， 因为要捕获的方法太多，这里只列举两条)\n\n```\n- (void)registerNavigationHooks {\n  \t @weakify(self)\n    [[(NSObject *)self.services\n        rac_signalForSelector:@selector(pushViewModel:animated:)]\n        subscribeNext:^(RACTuple *tuple) {\n            @strongify(self)\n            UIViewController *viewController = (UIViewController *)[MRCRouter.sharedInstance viewControllerForViewModel:tuple.first];\n            [self.navigationControllers.lastObject pushViewController:viewController animated:[tuple.second boolValue]];\n        }];\n    [[(NSObject *)self.services\n        rac_signalForSelector:@selector(popViewModelAnimated:)]\n        subscribeNext:^(RACTuple *tuple) {\n          @strongify(self)\n            [self.navigationControllers.lastObject popViewControllerAnimated:[tuple.first boolValue]];\n    }];\n}\n```\n\n实际在 ViewController 里面调用起来就会是这种感觉\n\n```\n- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {\n    [tableView deselectRowAtIndexPath:indexPath animated:YES];\n    if (indexPath.section == 0) {\n        MRCTrendingViewModel *trendingViewModel = [[MRCTrendingViewModel alloc] initWithServices:self.viewModel.services params:nil];\n        [self.viewModel.services pushViewModel:trendingViewModel animated:YES];\n    }\n}\n```\n\n然后看下将ViewModel与 ViewController 关联起来的 路由内的映射(截取部分)\n\n```\n- (NSDictionary *)viewModelViewMappings {\n   return @{\n   \t   @\"MRCLoginViewModel\": @\"MRCLoginViewController\",\n      @\"MRCHomepageViewModel\": @\"MRCHomepageViewController\",\n      @\"MRCRepoDetailViewModel\": @\"MRCRepoDetailViewController\",\n      @\"MRCWebViewModel\": @\"MRCWebViewController\",\n   };\n}\n```\n\n当然这上面的只是路由的实现方案1，纯粹地将 ViewController 与 ViewModel 关联起来，方案2是 建立一个路由层通过URL 的方式进行路由交互参考[一步步构建iOS路由](http://www.jianshu.com/p/3a902f274a3d)这部分我后面会讲讲我的思考。\n\n","slug":"iOS基于Navigation-Base-on-ViewModel的路由搭建——HOOK方式实现","published":1,"updated":"2021-04-12T06:07:04.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5i003945n00q2tbg8s","content":"<p>本文主要讲述的是在 iOS 中使用 MVVM 架构开发的情况下，将 ViewModel 作为行为驱动主体，通过 Hook 的方式，设计一个 App 的路由层</p>\n<span id=\"more\"></span>\n\n<ul>\n<li><p>什么是路由</p>\n<ul>\n<li>路由在服务端指的是url请求的分层解析，将一个请求分发到对应的应用处理程序。<br>在移动端指的是将 App 内页面访问、H5与App之间和访问请求和 App之间的访问请求 进行分发的逻辑层。</li>\n</ul>\n</li>\n<li><p>在移动端中路由需要做什么事情</p>\n<ul>\n<li>针对网络上的各种说法，这里做一下简要说明：<ul>\n<li>提供接口供外部访问，这里的”外部”指的可能是App内的一个ViewController，也有可能是其他应用（包括系统应用），也有可能是 H5页面。<br>分发资源。路由不需要依赖外部的资源的定义，就可以将资源传递给目的地。（‘资源’在这里指的是原生页面、模块、组件等等）</li>\n<li>统一的标识符（或者统一格式的标识符）去标识资源，并且可以通过这些标示符去统一访问请求的过程。</li>\n<li>解决安全访问的问题，如果是外部的H5、App去访问你的 App,那么就得特别注意这个问题。（本文暂不提及这个问题）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>在移动端中路由的使用场景</p>\n<ul>\n<li>原生界面之间，模块之间与组件之间的交互（例如页面的跳转之类）</li>\n<li>H5页面与原生界面之间的交互</li>\n<li>解除业务依赖</li>\n<li>组件化开发</li>\n</ul>\n</li>\n<li><p>iOS自带的系统访问方式、统一的连接协议</p>\n<ul>\n<li>苹果开发了<a href=\"https://developer.apple.com/library/content/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899\">URLScheme</a>这种东西，使得 App 能够在沙盒机制的前提下互相调用，定义URL-Scheme的方式如下<blockquote>\n<ul>\n<li>协议部分来标示App应用</li>\n<li>主机Host部分用于标示业务线或者是应用提供的划分好的服务实体，比方说index、discover是业务条线，api-asycn是对外提供的api，pushService是App内部的推送服务等。</li>\n<li>路径部分则可以是细分的页面、组件或者服务的标示</li>\n<li>参数定义有一些是必要的，比如说action来标示动作，比方说可以使用get标示获取、insert增加，userToken表示安全的用户令牌，source表示来源，当然像是userToken与source这些都是路由层需要进行解析和验证的，而action则是业务相关的参数，这一点在路由曾设计的时候需要进行详细区分</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>讲完了路由的概念，接下来谈谈 路由设计</p>\n<ul>\n<li>我们先抽取最常见的页面跳转来讲，因为我们使用的是 MVVM,那么从理论上来讲，我们就应该让App以 ViewModel为驱动进行运作，而不是用 ViewController,之前说 ViewController 在跳转的时候只需要关心跳转过去的界面是否是一个 UIViewController 的子类，而不需要关心这个 viewController的具体细节,所以考虑用 ViewModel把 目的 ViewController 传递到当前 ViewController，但是ViewModel 严格来讲不能引入任何 UIKit 的任何内容，不然ViewModel级就会失去其可测试性，所以我们通过引入服务总线的概念，维护一个NavigationController 的堆栈（这个思想来自于雷纯锋的博客中的一篇文章<a href=\"http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/\">MVVM With ReactiveCocoa</a>）具体实现如下</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;这个是协议声明部分</span><br><span class=\"line\">@protocol MRCNavigationProtocol &lt;NSObject&gt;</span><br><span class=\"line\">- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated;</span><br><span class=\"line\">- (void)popViewModelAnimated:(BOOL)animated;</span><br><span class=\"line\">- (void)popToRootViewModelAnimated:(BOOL)animated;</span><br><span class=\"line\">- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion;</span><br><span class=\"line\">- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion;</span><br><span class=\"line\">- (void)resetRootViewModel:(MRCViewModel *)viewModel;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>以下是方法的实现部分，没有写任何方法的实现过程，只是进行了空操作，目的是使用 Hook 思想去捕获操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)popViewModelAnimated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)popToRootViewModelAnimated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion &#123;&#125;</span><br><span class=\"line\">- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion &#123;&#125;</span><br><span class=\"line\">- (void)resetRootViewModel:(MRCViewModel *)viewModel &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>栈顶的 NavigationController 进行 Hook 并执行真正的跳转操作(使用到了 ReactiveCocoa， 因为要捕获的方法太多，这里只列举两条)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)registerNavigationHooks &#123;</span><br><span class=\"line\">  \t @weakify(self)</span><br><span class=\"line\">    [[(NSObject *)self.services</span><br><span class=\"line\">        rac_signalForSelector:@selector(pushViewModel:animated:)]</span><br><span class=\"line\">        subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">            @strongify(self)</span><br><span class=\"line\">            UIViewController *viewController &#x3D; (UIViewController *)[MRCRouter.sharedInstance viewControllerForViewModel:tuple.first];</span><br><span class=\"line\">            [self.navigationControllers.lastObject pushViewController:viewController animated:[tuple.second boolValue]];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    [[(NSObject *)self.services</span><br><span class=\"line\">        rac_signalForSelector:@selector(popViewModelAnimated:)]</span><br><span class=\"line\">        subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">          @strongify(self)</span><br><span class=\"line\">            [self.navigationControllers.lastObject popViewControllerAnimated:[tuple.first boolValue]];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际在 ViewController 里面调用起来就会是这种感觉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class=\"line\">    [tableView deselectRowAtIndexPath:indexPath animated:YES];</span><br><span class=\"line\">    if (indexPath.section &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">        MRCTrendingViewModel *trendingViewModel &#x3D; [[MRCTrendingViewModel alloc] initWithServices:self.viewModel.services params:nil];</span><br><span class=\"line\">        [self.viewModel.services pushViewModel:trendingViewModel animated:YES];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后看下将ViewModel与 ViewController 关联起来的 路由内的映射(截取部分)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSDictionary *)viewModelViewMappings &#123;</span><br><span class=\"line\">   return @&#123;</span><br><span class=\"line\">   \t   @&quot;MRCLoginViewModel&quot;: @&quot;MRCLoginViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCHomepageViewModel&quot;: @&quot;MRCHomepageViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCRepoDetailViewModel&quot;: @&quot;MRCRepoDetailViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCWebViewModel&quot;: @&quot;MRCWebViewController&quot;,</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然这上面的只是路由的实现方案1，纯粹地将 ViewController 与 ViewModel 关联起来，方案2是 建立一个路由层通过URL 的方式进行路由交互参考<a href=\"http://www.jianshu.com/p/3a902f274a3d\">一步步构建iOS路由</a>这部分我后面会讲讲我的思考。</p>\n","site":{"data":{}},"excerpt":"<p>本文主要讲述的是在 iOS 中使用 MVVM 架构开发的情况下，将 ViewModel 作为行为驱动主体，通过 Hook 的方式，设计一个 App 的路由层</p>","more":"<ul>\n<li><p>什么是路由</p>\n<ul>\n<li>路由在服务端指的是url请求的分层解析，将一个请求分发到对应的应用处理程序。<br>在移动端指的是将 App 内页面访问、H5与App之间和访问请求和 App之间的访问请求 进行分发的逻辑层。</li>\n</ul>\n</li>\n<li><p>在移动端中路由需要做什么事情</p>\n<ul>\n<li>针对网络上的各种说法，这里做一下简要说明：<ul>\n<li>提供接口供外部访问，这里的”外部”指的可能是App内的一个ViewController，也有可能是其他应用（包括系统应用），也有可能是 H5页面。<br>分发资源。路由不需要依赖外部的资源的定义，就可以将资源传递给目的地。（‘资源’在这里指的是原生页面、模块、组件等等）</li>\n<li>统一的标识符（或者统一格式的标识符）去标识资源，并且可以通过这些标示符去统一访问请求的过程。</li>\n<li>解决安全访问的问题，如果是外部的H5、App去访问你的 App,那么就得特别注意这个问题。（本文暂不提及这个问题）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>在移动端中路由的使用场景</p>\n<ul>\n<li>原生界面之间，模块之间与组件之间的交互（例如页面的跳转之类）</li>\n<li>H5页面与原生界面之间的交互</li>\n<li>解除业务依赖</li>\n<li>组件化开发</li>\n</ul>\n</li>\n<li><p>iOS自带的系统访问方式、统一的连接协议</p>\n<ul>\n<li>苹果开发了<a href=\"https://developer.apple.com/library/content/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899\">URLScheme</a>这种东西，使得 App 能够在沙盒机制的前提下互相调用，定义URL-Scheme的方式如下<blockquote>\n<ul>\n<li>协议部分来标示App应用</li>\n<li>主机Host部分用于标示业务线或者是应用提供的划分好的服务实体，比方说index、discover是业务条线，api-asycn是对外提供的api，pushService是App内部的推送服务等。</li>\n<li>路径部分则可以是细分的页面、组件或者服务的标示</li>\n<li>参数定义有一些是必要的，比如说action来标示动作，比方说可以使用get标示获取、insert增加，userToken表示安全的用户令牌，source表示来源，当然像是userToken与source这些都是路由层需要进行解析和验证的，而action则是业务相关的参数，这一点在路由曾设计的时候需要进行详细区分</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>讲完了路由的概念，接下来谈谈 路由设计</p>\n<ul>\n<li>我们先抽取最常见的页面跳转来讲，因为我们使用的是 MVVM,那么从理论上来讲，我们就应该让App以 ViewModel为驱动进行运作，而不是用 ViewController,之前说 ViewController 在跳转的时候只需要关心跳转过去的界面是否是一个 UIViewController 的子类，而不需要关心这个 viewController的具体细节,所以考虑用 ViewModel把 目的 ViewController 传递到当前 ViewController，但是ViewModel 严格来讲不能引入任何 UIKit 的任何内容，不然ViewModel级就会失去其可测试性，所以我们通过引入服务总线的概念，维护一个NavigationController 的堆栈（这个思想来自于雷纯锋的博客中的一篇文章<a href=\"http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/\">MVVM With ReactiveCocoa</a>）具体实现如下</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;这个是协议声明部分</span><br><span class=\"line\">@protocol MRCNavigationProtocol &lt;NSObject&gt;</span><br><span class=\"line\">- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated;</span><br><span class=\"line\">- (void)popViewModelAnimated:(BOOL)animated;</span><br><span class=\"line\">- (void)popToRootViewModelAnimated:(BOOL)animated;</span><br><span class=\"line\">- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion;</span><br><span class=\"line\">- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion;</span><br><span class=\"line\">- (void)resetRootViewModel:(MRCViewModel *)viewModel;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>以下是方法的实现部分，没有写任何方法的实现过程，只是进行了空操作，目的是使用 Hook 思想去捕获操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)popViewModelAnimated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)popToRootViewModelAnimated:(BOOL)animated &#123;&#125;</span><br><span class=\"line\">- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion &#123;&#125;</span><br><span class=\"line\">- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion &#123;&#125;</span><br><span class=\"line\">- (void)resetRootViewModel:(MRCViewModel *)viewModel &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>栈顶的 NavigationController 进行 Hook 并执行真正的跳转操作(使用到了 ReactiveCocoa， 因为要捕获的方法太多，这里只列举两条)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)registerNavigationHooks &#123;</span><br><span class=\"line\">  \t @weakify(self)</span><br><span class=\"line\">    [[(NSObject *)self.services</span><br><span class=\"line\">        rac_signalForSelector:@selector(pushViewModel:animated:)]</span><br><span class=\"line\">        subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">            @strongify(self)</span><br><span class=\"line\">            UIViewController *viewController &#x3D; (UIViewController *)[MRCRouter.sharedInstance viewControllerForViewModel:tuple.first];</span><br><span class=\"line\">            [self.navigationControllers.lastObject pushViewController:viewController animated:[tuple.second boolValue]];</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    [[(NSObject *)self.services</span><br><span class=\"line\">        rac_signalForSelector:@selector(popViewModelAnimated:)]</span><br><span class=\"line\">        subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class=\"line\">          @strongify(self)</span><br><span class=\"line\">            [self.navigationControllers.lastObject popViewControllerAnimated:[tuple.first boolValue]];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际在 ViewController 里面调用起来就会是这种感觉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class=\"line\">    [tableView deselectRowAtIndexPath:indexPath animated:YES];</span><br><span class=\"line\">    if (indexPath.section &#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">        MRCTrendingViewModel *trendingViewModel &#x3D; [[MRCTrendingViewModel alloc] initWithServices:self.viewModel.services params:nil];</span><br><span class=\"line\">        [self.viewModel.services pushViewModel:trendingViewModel animated:YES];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后看下将ViewModel与 ViewController 关联起来的 路由内的映射(截取部分)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSDictionary *)viewModelViewMappings &#123;</span><br><span class=\"line\">   return @&#123;</span><br><span class=\"line\">   \t   @&quot;MRCLoginViewModel&quot;: @&quot;MRCLoginViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCHomepageViewModel&quot;: @&quot;MRCHomepageViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCRepoDetailViewModel&quot;: @&quot;MRCRepoDetailViewController&quot;,</span><br><span class=\"line\">      @&quot;MRCWebViewModel&quot;: @&quot;MRCWebViewController&quot;,</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然这上面的只是路由的实现方案1，纯粹地将 ViewController 与 ViewModel 关联起来，方案2是 建立一个路由层通过URL 的方式进行路由交互参考<a href=\"http://www.jianshu.com/p/3a902f274a3d\">一步步构建iOS路由</a>这部分我后面会讲讲我的思考。</p>"},{"title":"ipad和iphone使用UIAlertViewController","author":"Arclin","abbrlink":"f0080c3e","date":"2016-10-16T16:00:00.000Z","_content":"ipad和iphone使用UIAlertViewController\n\n```\nid aController;\n    if(DKDeviceiPad){\n    alertC.modalPresentationStyle = UIModalPresentationPopover;\n    UIPopoverPresentationController *popPc = alertC.popoverPresentationController;\n    popPc.barButtonItem = self.downloadItem;\n    popPc.permittedArrowDirections = UIPopoverArrowDirectionAny;\n    aController = alertC;\n}else{\n    aController = alertC;\n}\n[window.rootViewController presentViewController:aController animated:YES completion:nil];\n```","source":"_posts/ipad和iphone使用UIAlertViewController.md","raw":"---\ntitle: ipad和iphone使用UIAlertViewController\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: f0080c3e\ndate: 2016-10-17 00:00:00\n---\nipad和iphone使用UIAlertViewController\n\n```\nid aController;\n    if(DKDeviceiPad){\n    alertC.modalPresentationStyle = UIModalPresentationPopover;\n    UIPopoverPresentationController *popPc = alertC.popoverPresentationController;\n    popPc.barButtonItem = self.downloadItem;\n    popPc.permittedArrowDirections = UIPopoverArrowDirectionAny;\n    aController = alertC;\n}else{\n    aController = alertC;\n}\n[window.rootViewController presentViewController:aController animated:YES completion:nil];\n```","slug":"ipad和iphone使用UIAlertViewController","published":1,"updated":"2021-04-12T06:07:04.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5j003d45n04tyha92k","content":"<p>ipad和iphone使用UIAlertViewController</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id aController;</span><br><span class=\"line\">    if(DKDeviceiPad)&#123;</span><br><span class=\"line\">    alertC.modalPresentationStyle &#x3D; UIModalPresentationPopover;</span><br><span class=\"line\">    UIPopoverPresentationController *popPc &#x3D; alertC.popoverPresentationController;</span><br><span class=\"line\">    popPc.barButtonItem &#x3D; self.downloadItem;</span><br><span class=\"line\">    popPc.permittedArrowDirections &#x3D; UIPopoverArrowDirectionAny;</span><br><span class=\"line\">    aController &#x3D; alertC;</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">    aController &#x3D; alertC;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[window.rootViewController presentViewController:aController animated:YES completion:nil];</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>ipad和iphone使用UIAlertViewController</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id aController;</span><br><span class=\"line\">    if(DKDeviceiPad)&#123;</span><br><span class=\"line\">    alertC.modalPresentationStyle &#x3D; UIModalPresentationPopover;</span><br><span class=\"line\">    UIPopoverPresentationController *popPc &#x3D; alertC.popoverPresentationController;</span><br><span class=\"line\">    popPc.barButtonItem &#x3D; self.downloadItem;</span><br><span class=\"line\">    popPc.permittedArrowDirections &#x3D; UIPopoverArrowDirectionAny;</span><br><span class=\"line\">    aController &#x3D; alertC;</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">    aController &#x3D; alertC;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">[window.rootViewController presentViewController:aController animated:YES completion:nil];</span><br></pre></td></tr></table></figure>"},{"title":"iOS从服务器下载DAE文件并动态加载到SCNScene","author":"Arclin","abbrlink":"8c9c88ab","date":"2017-02-22T16:00:00.000Z","_content":"ViewController 已有 SCNScene,怎么从服务器下载3D模型文件(DAE)然后加载到这个 SCNScene呢？\n\n<!-- more -->\n\n1. 由于 `SCNScene` 不支持动态加载 DAE 文件，或者说不支持动态加载 `COLLADA` 方案下的所有3d 类型，但是测试发现直接把 DAE 文件放进 `arc.scnassets` 文件夹下的时候是可以加载的，可见系统编译的时候应该是做了某些手脚，查询资料后发现系统是执行了两个脚本，两个脚本的路径分别是`/Applications/Xcode.app/Contents/Developer/usr/bin/copySceneKitAssets`和\n`/Applications/Xcode.app/Contents/Developer/usr/bin/scntool` 所以先把这两个文件拷出来\n\n2. 新建一个文件夹，命名是 自定义名字.scnassets,例如abc.scnassets\n\n3. 把模型文件放在里面,然后在这个文件夹外面放上copySceneKitAssets和scntool\n4. 终端执行./copySceneKitAssets abc.scnassets -o abc-o.scnassets 如果没问题的话就会生成一个 abc-o.scnassets 文件夹\n5. 打包 zip 上传服务器\n6. 代码下载 zip包,解压,然后载入文件\n\n```\ndocumentsDirectoryURL = [documentsDirectoryURL URLByAppendingPathComponent:@\"abc-o.scnassets/test.dae\"];\nSCNSceneSource *sceneSource = [SCNSceneSource sceneSourceWithURL:documentsDirectoryURL options:nil];\nSCNNode *theCube = [sceneSource entryWithIdentifier:@\"Cube\" withClass:[SCNNode class]];\n```\n或者使用SCNScene这个方法\n\n```\n+ (nullable instancetype)sceneWithURL:(NSURL *)url options:(nullable NSDictionary<SCNSceneSourceLoadingOption, id> *)options error:(NSError **)error;\n```\n也是可以的\n\n","source":"_posts/iOS从服务器下载DAE文件并动态加载到SCNScene.md","raw":"---\ntitle: iOS从服务器下载DAE文件并动态加载到SCNScene\nauthor: Arclin\ntags:\n  - iOS\n  - Scene Kit\n  - ''\ncategories:\n  - iOS\nabbrlink: 8c9c88ab\ndate: 2017-02-23 00:00:00\n---\nViewController 已有 SCNScene,怎么从服务器下载3D模型文件(DAE)然后加载到这个 SCNScene呢？\n\n<!-- more -->\n\n1. 由于 `SCNScene` 不支持动态加载 DAE 文件，或者说不支持动态加载 `COLLADA` 方案下的所有3d 类型，但是测试发现直接把 DAE 文件放进 `arc.scnassets` 文件夹下的时候是可以加载的，可见系统编译的时候应该是做了某些手脚，查询资料后发现系统是执行了两个脚本，两个脚本的路径分别是`/Applications/Xcode.app/Contents/Developer/usr/bin/copySceneKitAssets`和\n`/Applications/Xcode.app/Contents/Developer/usr/bin/scntool` 所以先把这两个文件拷出来\n\n2. 新建一个文件夹，命名是 自定义名字.scnassets,例如abc.scnassets\n\n3. 把模型文件放在里面,然后在这个文件夹外面放上copySceneKitAssets和scntool\n4. 终端执行./copySceneKitAssets abc.scnassets -o abc-o.scnassets 如果没问题的话就会生成一个 abc-o.scnassets 文件夹\n5. 打包 zip 上传服务器\n6. 代码下载 zip包,解压,然后载入文件\n\n```\ndocumentsDirectoryURL = [documentsDirectoryURL URLByAppendingPathComponent:@\"abc-o.scnassets/test.dae\"];\nSCNSceneSource *sceneSource = [SCNSceneSource sceneSourceWithURL:documentsDirectoryURL options:nil];\nSCNNode *theCube = [sceneSource entryWithIdentifier:@\"Cube\" withClass:[SCNNode class]];\n```\n或者使用SCNScene这个方法\n\n```\n+ (nullable instancetype)sceneWithURL:(NSURL *)url options:(nullable NSDictionary<SCNSceneSourceLoadingOption, id> *)options error:(NSError **)error;\n```\n也是可以的\n\n","slug":"iOS从服务器下载DAE文件并动态加载到SCNScene","published":1,"updated":"2021-04-12T06:07:04.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5m003g45n02as63d8o","content":"<p>ViewController 已有 SCNScene,怎么从服务器下载3D模型文件(DAE)然后加载到这个 SCNScene呢？</p>\n<span id=\"more\"></span>\n\n<ol>\n<li><p>由于 <code>SCNScene</code> 不支持动态加载 DAE 文件，或者说不支持动态加载 <code>COLLADA</code> 方案下的所有3d 类型，但是测试发现直接把 DAE 文件放进 <code>arc.scnassets</code> 文件夹下的时候是可以加载的，可见系统编译的时候应该是做了某些手脚，查询资料后发现系统是执行了两个脚本，两个脚本的路径分别是<code>/Applications/Xcode.app/Contents/Developer/usr/bin/copySceneKitAssets</code>和<br><code>/Applications/Xcode.app/Contents/Developer/usr/bin/scntool</code> 所以先把这两个文件拷出来</p>\n</li>\n<li><p>新建一个文件夹，命名是 自定义名字.scnassets,例如abc.scnassets</p>\n</li>\n<li><p>把模型文件放在里面,然后在这个文件夹外面放上copySceneKitAssets和scntool</p>\n</li>\n<li><p>终端执行./copySceneKitAssets abc.scnassets -o abc-o.scnassets 如果没问题的话就会生成一个 abc-o.scnassets 文件夹</p>\n</li>\n<li><p>打包 zip 上传服务器</p>\n</li>\n<li><p>代码下载 zip包,解压,然后载入文件</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">documentsDirectoryURL &#x3D; [documentsDirectoryURL URLByAppendingPathComponent:@&quot;abc-o.scnassets&#x2F;test.dae&quot;];</span><br><span class=\"line\">SCNSceneSource *sceneSource &#x3D; [SCNSceneSource sceneSourceWithURL:documentsDirectoryURL options:nil];</span><br><span class=\"line\">SCNNode *theCube &#x3D; [sceneSource entryWithIdentifier:@&quot;Cube&quot; withClass:[SCNNode class]];</span><br></pre></td></tr></table></figure>\n<p>或者使用SCNScene这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (nullable instancetype)sceneWithURL:(NSURL *)url options:(nullable NSDictionary&lt;SCNSceneSourceLoadingOption, id&gt; *)options error:(NSError **)error;</span><br></pre></td></tr></table></figure>\n<p>也是可以的</p>\n","site":{"data":{}},"excerpt":"<p>ViewController 已有 SCNScene,怎么从服务器下载3D模型文件(DAE)然后加载到这个 SCNScene呢？</p>","more":"<ol>\n<li><p>由于 <code>SCNScene</code> 不支持动态加载 DAE 文件，或者说不支持动态加载 <code>COLLADA</code> 方案下的所有3d 类型，但是测试发现直接把 DAE 文件放进 <code>arc.scnassets</code> 文件夹下的时候是可以加载的，可见系统编译的时候应该是做了某些手脚，查询资料后发现系统是执行了两个脚本，两个脚本的路径分别是<code>/Applications/Xcode.app/Contents/Developer/usr/bin/copySceneKitAssets</code>和<br><code>/Applications/Xcode.app/Contents/Developer/usr/bin/scntool</code> 所以先把这两个文件拷出来</p>\n</li>\n<li><p>新建一个文件夹，命名是 自定义名字.scnassets,例如abc.scnassets</p>\n</li>\n<li><p>把模型文件放在里面,然后在这个文件夹外面放上copySceneKitAssets和scntool</p>\n</li>\n<li><p>终端执行./copySceneKitAssets abc.scnassets -o abc-o.scnassets 如果没问题的话就会生成一个 abc-o.scnassets 文件夹</p>\n</li>\n<li><p>打包 zip 上传服务器</p>\n</li>\n<li><p>代码下载 zip包,解压,然后载入文件</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">documentsDirectoryURL &#x3D; [documentsDirectoryURL URLByAppendingPathComponent:@&quot;abc-o.scnassets&#x2F;test.dae&quot;];</span><br><span class=\"line\">SCNSceneSource *sceneSource &#x3D; [SCNSceneSource sceneSourceWithURL:documentsDirectoryURL options:nil];</span><br><span class=\"line\">SCNNode *theCube &#x3D; [sceneSource entryWithIdentifier:@&quot;Cube&quot; withClass:[SCNNode class]];</span><br></pre></td></tr></table></figure>\n<p>或者使用SCNScene这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (nullable instancetype)sceneWithURL:(NSURL *)url options:(nullable NSDictionary&lt;SCNSceneSourceLoadingOption, id&gt; *)options error:(NSError **)error;</span><br></pre></td></tr></table></figure>\n<p>也是可以的</p>"},{"abbrlink":"0","author":"Arclin","title":"iOS12 新玩具ShortCut(捷径)使用","date":"2018-09-28T05:05:00.000Z","_content":"\n### 介绍\n\n升级iOS12之后可以在`设置-Siri`与搜索 中发现一个 `捷径` 功能, 所谓ShortCut就是其英文翻译\n其作用就是让用户自定义一个一句话或者短语, 然后可以触发app做一系列动作\n\n<!-- more -->\n\n### 接入\n\nShortCut分为两种, 一种是在手机的`Spotlight`上搜索某个关键字的时候可以搜索到你的app, 这个关键字就是ShortCut的一种(文字输入), 你需要使用`NSUserActivity`去实现这个功能\n> 依赖 `CoreSpotlight` `CoreServices`\n\n另外一种叫做 `Intent`(语音输入), 需要添加一个IntentExtension和IntentExtensionUI, 然后在主Target添加一个intentdefinition文件, 详细的配置大家可以参考\n[文章1](https://juejin.im/post/5b2077d8f265da6e45549c68)\n[文章2](http://www.cnblogs.com/czjie2010/p/czjie.html)\n\n> 依赖`Intents` `IntentsUI`\n\n\n### 最简单的配置操作步骤\n\n1. 项目的`Capabilities`打开`Siri`\n2. 授权\n\t```\n\tif (@available(iOS 10.0, *)) {\n\t\t[INPreferences requestSiriAuthorization:^(INSiriAuthorizationStatus status) {\n\t\t\tswitch (status) {\n\t\t\t\tcase INSiriAuthorizationStatusNotDetermined:\n\t\t\t\t\tNSLog(@\"用户尚未对该应用程序作出选择。\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase INSiriAuthorizationStatusRestricted:\n\t\t\t\t\tNSLog(@\"此应用程序无权使用Siri服务\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase INSiriAuthorizationStatusDenied:\n\t\t\t\t\tNSLog(@\"用户已明确拒绝此应用程序的授权\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase INSiriAuthorizationStatusAuthorized:\n\t\t\t\t\tNSLog(@\"用户可以使用此应用程序的授权\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}];\n\t}\n\t```\n\t- 新建一个`intentdefinition`，比如`A.intentdefinition`\n\t- 新建一个`Target`,`Intent Extension`有需要的话把`Intent UI Extension`也加上，`General`中配置相关证书\n\t- 进入`A.intentdefinition`，界面左下角`+`号点一下，点击`new intent`\n\t- 界面右边`Target Membership`，把`步骤2`中新增的`Target`给勾上\n\t-  界面中间`Title`填写需要展示的标题，`Descripion` 写描述\n\t- Build一下，系统自动生成头文件，头文件名字在界面右测的导航页的第三个按钮的`Custom Class`里\n\t- 找个控制器，导入`步骤8`生成的头文件，添加个按钮，比如\n\n\t```\n\tself.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@\"捷径\" style:UIBarButtonItemStylePlain target:self action:@selector(siri:)];\n\t```\n\n3. 点击按钮召唤添加Shortcut的控制器\n\n\t```\n\t- (void)siri:(UIBarButtonItem *)item {\n\t    if (@available(iOS 12.0, *)) {\n\t    \t // 这个类名具体看你生成了叫什么名字的头文件\n\t        ZeRiIntent *intent = [[ZeRiIntent alloc] init];\n\t        intent.suggestedInvocationPhrase = @\"打开xxx\"; // 引导用户说的语句\n\t        INShortcut *shortCur = [[INShortcut alloc] initWithIntent:intent];\n\t        INUIAddVoiceShortcutViewController *vc = [[INUIAddVoiceShortcutViewController alloc] initWithShortcut:shortCur];\n\t        vc.delegate = self;\n\t        [self presentViewController:vc animated:YES completion:nil];\n\t    } else {\n\t        // Fallback on earlier versions\n\t    }\n\t}\n\t```\n\n4. 同个地方实现代理方法\n\n\t```\n\t#pragma mark - INUIAddVoiceShortcutViewControllerDelegate\n\t- (void)addVoiceShortcutViewControllerDidCancel:(INUIAddVoiceShortcutViewController *)controller  API_AVAILABLE(ios(12.0)){\n\t\t[controller dismissViewControllerAnimated:YES completion:nil];\n\t}\n\t- (void)addVoiceShortcutViewController:(INUIAddVoiceShortcutViewController *)controller didFinishWithVoiceShortcut:(INVoiceShortcut *)voiceShortcut error:(NSError *)error  API_AVAILABLE(ios(12.0)){\n\t\t[controller dismissViewControllerAnimated:YES completion:nil];\n\t}\n\t```\n\n5. 进入`Intent` target中的`IntentHandler`类，导入`步骤8`生成的头文件，要是头文件找不到，在这个target的`info.plist`中`NSExtension`下的`IntentsSupported`下添加一个名为那个头文件的值，主target的`info.plist`的`NSUserActivityTypes`下也加一个一样的\n\n6. `IntentHandler.m`遵循协议`XXXIntentHandling`（具体协议名看你的类名），实现两个方法\n\n\t```\n\t\t// 用户说了那句话之后要Siri做什么事情\n\t- (void)handleZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion {\n\t\tcompletion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);\n\t}\n\t  // 用户确认了之后要Siri做什么事情\n\t- (void)confirmZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion {\n\t\tcompletion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);\n\t}\n\t```\n\n\t  `ZeRiIntentResponseCodeContinueInApp`只是枚举中其中一个值，使用不同的值会有不同     效果，自己探索一下，这里的值指的是打开app(具体方法名看协议)\n\n7. 进入`AppDelegate`，实现方法如下，根据`Intent`类名判断用户想要的操作\n\n\t```\n\t- (BOOL)application:(UIApplication *)application continueUserActivity:(nonnull NSUserActivity *)userActivity restorationHandler:(nonnull void (^)(NSArray<id<UIUserActivityRestoring>> * _Nullable))restorationHandler {\n\tif ([userActivity.activityType isEqualToString:@\"XXXIntent\"]) {\n\t}\n    return YES;\n}\n```\n8. 结束","source":"_posts/iOS12-新玩具ShortCut-捷径-使用.md","raw":"abbrlink: '0'\ntags:\n  - iOS\ncategories:\n  - iOS\nauthor: Arclin\ntitle: iOS12 新玩具ShortCut(捷径)使用\ndate: 2018-09-28 13:05:00\n---\n\n### 介绍\n\n升级iOS12之后可以在`设置-Siri`与搜索 中发现一个 `捷径` 功能, 所谓ShortCut就是其英文翻译\n其作用就是让用户自定义一个一句话或者短语, 然后可以触发app做一系列动作\n\n<!-- more -->\n\n### 接入\n\nShortCut分为两种, 一种是在手机的`Spotlight`上搜索某个关键字的时候可以搜索到你的app, 这个关键字就是ShortCut的一种(文字输入), 你需要使用`NSUserActivity`去实现这个功能\n> 依赖 `CoreSpotlight` `CoreServices`\n\n另外一种叫做 `Intent`(语音输入), 需要添加一个IntentExtension和IntentExtensionUI, 然后在主Target添加一个intentdefinition文件, 详细的配置大家可以参考\n[文章1](https://juejin.im/post/5b2077d8f265da6e45549c68)\n[文章2](http://www.cnblogs.com/czjie2010/p/czjie.html)\n\n> 依赖`Intents` `IntentsUI`\n\n\n### 最简单的配置操作步骤\n\n1. 项目的`Capabilities`打开`Siri`\n2. 授权\n\t```\n\tif (@available(iOS 10.0, *)) {\n\t\t[INPreferences requestSiriAuthorization:^(INSiriAuthorizationStatus status) {\n\t\t\tswitch (status) {\n\t\t\t\tcase INSiriAuthorizationStatusNotDetermined:\n\t\t\t\t\tNSLog(@\"用户尚未对该应用程序作出选择。\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase INSiriAuthorizationStatusRestricted:\n\t\t\t\t\tNSLog(@\"此应用程序无权使用Siri服务\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase INSiriAuthorizationStatusDenied:\n\t\t\t\t\tNSLog(@\"用户已明确拒绝此应用程序的授权\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase INSiriAuthorizationStatusAuthorized:\n\t\t\t\t\tNSLog(@\"用户可以使用此应用程序的授权\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}];\n\t}\n\t```\n\t- 新建一个`intentdefinition`，比如`A.intentdefinition`\n\t- 新建一个`Target`,`Intent Extension`有需要的话把`Intent UI Extension`也加上，`General`中配置相关证书\n\t- 进入`A.intentdefinition`，界面左下角`+`号点一下，点击`new intent`\n\t- 界面右边`Target Membership`，把`步骤2`中新增的`Target`给勾上\n\t-  界面中间`Title`填写需要展示的标题，`Descripion` 写描述\n\t- Build一下，系统自动生成头文件，头文件名字在界面右测的导航页的第三个按钮的`Custom Class`里\n\t- 找个控制器，导入`步骤8`生成的头文件，添加个按钮，比如\n\n\t```\n\tself.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:@\"捷径\" style:UIBarButtonItemStylePlain target:self action:@selector(siri:)];\n\t```\n\n3. 点击按钮召唤添加Shortcut的控制器\n\n\t```\n\t- (void)siri:(UIBarButtonItem *)item {\n\t    if (@available(iOS 12.0, *)) {\n\t    \t // 这个类名具体看你生成了叫什么名字的头文件\n\t        ZeRiIntent *intent = [[ZeRiIntent alloc] init];\n\t        intent.suggestedInvocationPhrase = @\"打开xxx\"; // 引导用户说的语句\n\t        INShortcut *shortCur = [[INShortcut alloc] initWithIntent:intent];\n\t        INUIAddVoiceShortcutViewController *vc = [[INUIAddVoiceShortcutViewController alloc] initWithShortcut:shortCur];\n\t        vc.delegate = self;\n\t        [self presentViewController:vc animated:YES completion:nil];\n\t    } else {\n\t        // Fallback on earlier versions\n\t    }\n\t}\n\t```\n\n4. 同个地方实现代理方法\n\n\t```\n\t#pragma mark - INUIAddVoiceShortcutViewControllerDelegate\n\t- (void)addVoiceShortcutViewControllerDidCancel:(INUIAddVoiceShortcutViewController *)controller  API_AVAILABLE(ios(12.0)){\n\t\t[controller dismissViewControllerAnimated:YES completion:nil];\n\t}\n\t- (void)addVoiceShortcutViewController:(INUIAddVoiceShortcutViewController *)controller didFinishWithVoiceShortcut:(INVoiceShortcut *)voiceShortcut error:(NSError *)error  API_AVAILABLE(ios(12.0)){\n\t\t[controller dismissViewControllerAnimated:YES completion:nil];\n\t}\n\t```\n\n5. 进入`Intent` target中的`IntentHandler`类，导入`步骤8`生成的头文件，要是头文件找不到，在这个target的`info.plist`中`NSExtension`下的`IntentsSupported`下添加一个名为那个头文件的值，主target的`info.plist`的`NSUserActivityTypes`下也加一个一样的\n\n6. `IntentHandler.m`遵循协议`XXXIntentHandling`（具体协议名看你的类名），实现两个方法\n\n\t```\n\t\t// 用户说了那句话之后要Siri做什么事情\n\t- (void)handleZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion {\n\t\tcompletion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);\n\t}\n\t  // 用户确认了之后要Siri做什么事情\n\t- (void)confirmZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion {\n\t\tcompletion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);\n\t}\n\t```\n\n\t  `ZeRiIntentResponseCodeContinueInApp`只是枚举中其中一个值，使用不同的值会有不同     效果，自己探索一下，这里的值指的是打开app(具体方法名看协议)\n\n7. 进入`AppDelegate`，实现方法如下，根据`Intent`类名判断用户想要的操作\n\n\t```\n\t- (BOOL)application:(UIApplication *)application continueUserActivity:(nonnull NSUserActivity *)userActivity restorationHandler:(nonnull void (^)(NSArray<id<UIUserActivityRestoring>> * _Nullable))restorationHandler {\n\tif ([userActivity.activityType isEqualToString:@\"XXXIntent\"]) {\n\t}\n    return YES;\n}\n```\n8. 结束","slug":"iOS12-新玩具ShortCut-捷径-使用","published":1,"updated":"2021-04-12T06:07:04.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5p003k45n07fghgcmb","content":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>升级iOS12之后可以在<code>设置-Siri</code>与搜索 中发现一个 <code>捷径</code> 功能, 所谓ShortCut就是其英文翻译<br>其作用就是让用户自定义一个一句话或者短语, 然后可以触发app做一系列动作</p>\n<span id=\"more\"></span>\n\n<h3 id=\"接入\"><a href=\"#接入\" class=\"headerlink\" title=\"接入\"></a>接入</h3><p>ShortCut分为两种, 一种是在手机的<code>Spotlight</code>上搜索某个关键字的时候可以搜索到你的app, 这个关键字就是ShortCut的一种(文字输入), 你需要使用<code>NSUserActivity</code>去实现这个功能</p>\n<blockquote>\n<p>依赖 <code>CoreSpotlight</code> <code>CoreServices</code></p>\n</blockquote>\n<p>另外一种叫做 <code>Intent</code>(语音输入), 需要添加一个IntentExtension和IntentExtensionUI, 然后在主Target添加一个intentdefinition文件, 详细的配置大家可以参考<br><a href=\"https://juejin.im/post/5b2077d8f265da6e45549c68\">文章1</a><br><a href=\"http://www.cnblogs.com/czjie2010/p/czjie.html\">文章2</a></p>\n<blockquote>\n<p>依赖<code>Intents</code> <code>IntentsUI</code></p>\n</blockquote>\n<h3 id=\"最简单的配置操作步骤\"><a href=\"#最简单的配置操作步骤\" class=\"headerlink\" title=\"最简单的配置操作步骤\"></a>最简单的配置操作步骤</h3><ol>\n<li><p>项目的<code>Capabilities</code>打开<code>Siri</code></p>\n</li>\n<li><p>授权</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (@available(iOS 10.0, *)) &#123;</span><br><span class=\"line\">\t[INPreferences requestSiriAuthorization:^(INSiriAuthorizationStatus status) &#123;</span><br><span class=\"line\">\t\tswitch (status) &#123;</span><br><span class=\"line\">\t\t\tcase INSiriAuthorizationStatusNotDetermined:</span><br><span class=\"line\">\t\t\t\tNSLog(@&quot;用户尚未对该应用程序作出选择。&quot;);</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tcase INSiriAuthorizationStatusRestricted:</span><br><span class=\"line\">\t\t\t\tNSLog(@&quot;此应用程序无权使用Siri服务&quot;);</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tcase INSiriAuthorizationStatusDenied:</span><br><span class=\"line\">\t\t\t\tNSLog(@&quot;用户已明确拒绝此应用程序的授权&quot;);</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tcase INSiriAuthorizationStatusAuthorized:</span><br><span class=\"line\">\t\t\t\tNSLog(@&quot;用户可以使用此应用程序的授权&quot;);</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tdefault:</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>新建一个<code>intentdefinition</code>，比如<code>A.intentdefinition</code></li>\n<li>新建一个<code>Target</code>,<code>Intent Extension</code>有需要的话把<code>Intent UI Extension</code>也加上，<code>General</code>中配置相关证书</li>\n<li>进入<code>A.intentdefinition</code>，界面左下角<code>+</code>号点一下，点击<code>new intent</code></li>\n<li>界面右边<code>Target Membership</code>，把<code>步骤2</code>中新增的<code>Target</code>给勾上</li>\n<li> 界面中间<code>Title</code>填写需要展示的标题，<code>Descripion</code> 写描述</li>\n<li>Build一下，系统自动生成头文件，头文件名字在界面右测的导航页的第三个按钮的<code>Custom Class</code>里</li>\n<li>找个控制器，导入<code>步骤8</code>生成的头文件，添加个按钮，比如</li>\n</ul>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.navigationItem.rightBarButtonItem &#x3D; [[UIBarButtonItem alloc] initWithTitle:@&quot;捷径&quot; style:UIBarButtonItemStylePlain target:self action:@selector(siri:)];</span><br></pre></td></tr></table></figure></li>\n<li><p>点击按钮召唤添加Shortcut的控制器</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)siri:(UIBarButtonItem *)item &#123;</span><br><span class=\"line\">    if (@available(iOS 12.0, *)) &#123;</span><br><span class=\"line\">    \t &#x2F;&#x2F; 这个类名具体看你生成了叫什么名字的头文件</span><br><span class=\"line\">        ZeRiIntent *intent &#x3D; [[ZeRiIntent alloc] init];</span><br><span class=\"line\">        intent.suggestedInvocationPhrase &#x3D; @&quot;打开xxx&quot;; &#x2F;&#x2F; 引导用户说的语句</span><br><span class=\"line\">        INShortcut *shortCur &#x3D; [[INShortcut alloc] initWithIntent:intent];</span><br><span class=\"line\">        INUIAddVoiceShortcutViewController *vc &#x3D; [[INUIAddVoiceShortcutViewController alloc] initWithShortcut:shortCur];</span><br><span class=\"line\">        vc.delegate &#x3D; self;</span><br><span class=\"line\">        [self presentViewController:vc animated:YES completion:nil];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; Fallback on earlier versions</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>同个地方实现代理方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - INUIAddVoiceShortcutViewControllerDelegate</span><br><span class=\"line\">- (void)addVoiceShortcutViewControllerDidCancel:(INUIAddVoiceShortcutViewController *)controller  API_AVAILABLE(ios(12.0))&#123;</span><br><span class=\"line\">\t[controller dismissViewControllerAnimated:YES completion:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)addVoiceShortcutViewController:(INUIAddVoiceShortcutViewController *)controller didFinishWithVoiceShortcut:(INVoiceShortcut *)voiceShortcut error:(NSError *)error  API_AVAILABLE(ios(12.0))&#123;</span><br><span class=\"line\">\t[controller dismissViewControllerAnimated:YES completion:nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>进入<code>Intent</code> target中的<code>IntentHandler</code>类，导入<code>步骤8</code>生成的头文件，要是头文件找不到，在这个target的<code>info.plist</code>中<code>NSExtension</code>下的<code>IntentsSupported</code>下添加一个名为那个头文件的值，主target的<code>info.plist</code>的<code>NSUserActivityTypes</code>下也加一个一样的</p>\n</li>\n<li><p><code>IntentHandler.m</code>遵循协议<code>XXXIntentHandling</code>（具体协议名看你的类名），实现两个方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#x2F;&#x2F; 用户说了那句话之后要Siri做什么事情</span><br><span class=\"line\">- (void)handleZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion &#123;</span><br><span class=\"line\">\tcompletion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  &#x2F;&#x2F; 用户确认了之后要Siri做什么事情</span><br><span class=\"line\">- (void)confirmZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion &#123;</span><br><span class=\"line\">\tcompletion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>   <code>ZeRiIntentResponseCodeContinueInApp</code>只是枚举中其中一个值，使用不同的值会有不同     效果，自己探索一下，这里的值指的是打开app(具体方法名看协议)</p>\n</li>\n<li><p>进入<code>AppDelegate</code>，实现方法如下，根据<code>Intent</code>类名判断用户想要的操作</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t- (BOOL)application:(UIApplication *)application continueUserActivity:(nonnull NSUserActivity *)userActivity restorationHandler:(nonnull void (^)(NSArray&lt;id&lt;UIUserActivityRestoring&gt;&gt; * _Nullable))restorationHandler &#123;</span><br><span class=\"line\">\tif ([userActivity.activityType isEqualToString:@&quot;XXXIntent&quot;]) &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>结束</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>升级iOS12之后可以在<code>设置-Siri</code>与搜索 中发现一个 <code>捷径</code> 功能, 所谓ShortCut就是其英文翻译<br>其作用就是让用户自定义一个一句话或者短语, 然后可以触发app做一系列动作</p>","more":"<h3 id=\"接入\"><a href=\"#接入\" class=\"headerlink\" title=\"接入\"></a>接入</h3><p>ShortCut分为两种, 一种是在手机的<code>Spotlight</code>上搜索某个关键字的时候可以搜索到你的app, 这个关键字就是ShortCut的一种(文字输入), 你需要使用<code>NSUserActivity</code>去实现这个功能</p>\n<blockquote>\n<p>依赖 <code>CoreSpotlight</code> <code>CoreServices</code></p>\n</blockquote>\n<p>另外一种叫做 <code>Intent</code>(语音输入), 需要添加一个IntentExtension和IntentExtensionUI, 然后在主Target添加一个intentdefinition文件, 详细的配置大家可以参考<br><a href=\"https://juejin.im/post/5b2077d8f265da6e45549c68\">文章1</a><br><a href=\"http://www.cnblogs.com/czjie2010/p/czjie.html\">文章2</a></p>\n<blockquote>\n<p>依赖<code>Intents</code> <code>IntentsUI</code></p>\n</blockquote>\n<h3 id=\"最简单的配置操作步骤\"><a href=\"#最简单的配置操作步骤\" class=\"headerlink\" title=\"最简单的配置操作步骤\"></a>最简单的配置操作步骤</h3><ol>\n<li><p>项目的<code>Capabilities</code>打开<code>Siri</code></p>\n</li>\n<li><p>授权</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (@available(iOS 10.0, *)) &#123;</span><br><span class=\"line\">\t[INPreferences requestSiriAuthorization:^(INSiriAuthorizationStatus status) &#123;</span><br><span class=\"line\">\t\tswitch (status) &#123;</span><br><span class=\"line\">\t\t\tcase INSiriAuthorizationStatusNotDetermined:</span><br><span class=\"line\">\t\t\t\tNSLog(@&quot;用户尚未对该应用程序作出选择。&quot;);</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tcase INSiriAuthorizationStatusRestricted:</span><br><span class=\"line\">\t\t\t\tNSLog(@&quot;此应用程序无权使用Siri服务&quot;);</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tcase INSiriAuthorizationStatusDenied:</span><br><span class=\"line\">\t\t\t\tNSLog(@&quot;用户已明确拒绝此应用程序的授权&quot;);</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tcase INSiriAuthorizationStatusAuthorized:</span><br><span class=\"line\">\t\t\t\tNSLog(@&quot;用户可以使用此应用程序的授权&quot;);</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t\tdefault:</span><br><span class=\"line\">\t\t\t\tbreak;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>新建一个<code>intentdefinition</code>，比如<code>A.intentdefinition</code></li>\n<li>新建一个<code>Target</code>,<code>Intent Extension</code>有需要的话把<code>Intent UI Extension</code>也加上，<code>General</code>中配置相关证书</li>\n<li>进入<code>A.intentdefinition</code>，界面左下角<code>+</code>号点一下，点击<code>new intent</code></li>\n<li>界面右边<code>Target Membership</code>，把<code>步骤2</code>中新增的<code>Target</code>给勾上</li>\n<li> 界面中间<code>Title</code>填写需要展示的标题，<code>Descripion</code> 写描述</li>\n<li>Build一下，系统自动生成头文件，头文件名字在界面右测的导航页的第三个按钮的<code>Custom Class</code>里</li>\n<li>找个控制器，导入<code>步骤8</code>生成的头文件，添加个按钮，比如</li>\n</ul>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.navigationItem.rightBarButtonItem &#x3D; [[UIBarButtonItem alloc] initWithTitle:@&quot;捷径&quot; style:UIBarButtonItemStylePlain target:self action:@selector(siri:)];</span><br></pre></td></tr></table></figure></li>\n<li><p>点击按钮召唤添加Shortcut的控制器</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)siri:(UIBarButtonItem *)item &#123;</span><br><span class=\"line\">    if (@available(iOS 12.0, *)) &#123;</span><br><span class=\"line\">    \t &#x2F;&#x2F; 这个类名具体看你生成了叫什么名字的头文件</span><br><span class=\"line\">        ZeRiIntent *intent &#x3D; [[ZeRiIntent alloc] init];</span><br><span class=\"line\">        intent.suggestedInvocationPhrase &#x3D; @&quot;打开xxx&quot;; &#x2F;&#x2F; 引导用户说的语句</span><br><span class=\"line\">        INShortcut *shortCur &#x3D; [[INShortcut alloc] initWithIntent:intent];</span><br><span class=\"line\">        INUIAddVoiceShortcutViewController *vc &#x3D; [[INUIAddVoiceShortcutViewController alloc] initWithShortcut:shortCur];</span><br><span class=\"line\">        vc.delegate &#x3D; self;</span><br><span class=\"line\">        [self presentViewController:vc animated:YES completion:nil];</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; Fallback on earlier versions</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>同个地方实现代理方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - INUIAddVoiceShortcutViewControllerDelegate</span><br><span class=\"line\">- (void)addVoiceShortcutViewControllerDidCancel:(INUIAddVoiceShortcutViewController *)controller  API_AVAILABLE(ios(12.0))&#123;</span><br><span class=\"line\">\t[controller dismissViewControllerAnimated:YES completion:nil];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)addVoiceShortcutViewController:(INUIAddVoiceShortcutViewController *)controller didFinishWithVoiceShortcut:(INVoiceShortcut *)voiceShortcut error:(NSError *)error  API_AVAILABLE(ios(12.0))&#123;</span><br><span class=\"line\">\t[controller dismissViewControllerAnimated:YES completion:nil];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>进入<code>Intent</code> target中的<code>IntentHandler</code>类，导入<code>步骤8</code>生成的头文件，要是头文件找不到，在这个target的<code>info.plist</code>中<code>NSExtension</code>下的<code>IntentsSupported</code>下添加一个名为那个头文件的值，主target的<code>info.plist</code>的<code>NSUserActivityTypes</code>下也加一个一样的</p>\n</li>\n<li><p><code>IntentHandler.m</code>遵循协议<code>XXXIntentHandling</code>（具体协议名看你的类名），实现两个方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t&#x2F;&#x2F; 用户说了那句话之后要Siri做什么事情</span><br><span class=\"line\">- (void)handleZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion &#123;</span><br><span class=\"line\">\tcompletion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  &#x2F;&#x2F; 用户确认了之后要Siri做什么事情</span><br><span class=\"line\">- (void)confirmZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion &#123;</span><br><span class=\"line\">\tcompletion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>   <code>ZeRiIntentResponseCodeContinueInApp</code>只是枚举中其中一个值，使用不同的值会有不同     效果，自己探索一下，这里的值指的是打开app(具体方法名看协议)</p>\n</li>\n<li><p>进入<code>AppDelegate</code>，实现方法如下，根据<code>Intent</code>类名判断用户想要的操作</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t- (BOOL)application:(UIApplication *)application continueUserActivity:(nonnull NSUserActivity *)userActivity restorationHandler:(nonnull void (^)(NSArray&lt;id&lt;UIUserActivityRestoring&gt;&gt; * _Nullable))restorationHandler &#123;</span><br><span class=\"line\">\tif ([userActivity.activityType isEqualToString:@&quot;XXXIntent&quot;]) &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>结束</p>\n</li>\n</ol>"},{"title":"ngrok 内网穿透使用","author":"Arclin","abbrlink":"dda122f4","date":"2018-02-18T14:02:00.000Z","_content":"ngrok 内网穿透使用\n\n<!-- more -->\n\n### 安装golang\n\n```\nsudo yum install build-essential golang mercurial git\n```\n\n### 运行脚本\n\n```\ncd ~\ngit clone https://github.com/tutumcloud/ngrok.git ngrok\nexport NGROK_DOMAIN=\"ngrok.arclin.me\"\ncd ngrok\nopenssl genrsa -out rootCA.key 2048\nopenssl req -x509 -new -nodes -key rootCA.key -subj \"/CN=$NGROK_DOMAIN” -days 5000 -out rootCA.pem\nopenssl genrsa -out device.key 2048\nopenssl req -new -key device.key -subj \"/CN=$NGROK_DOMAIN” -out device.csr\nopenssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000\ncp rootCA.pem assets/client/tls/ngrokroot.crt\ncp device.crt assets/server/tls/snakeoil.crt\ncp device.key assets/server/tls/snakeoil.key\nGOOS=linux GOARCH=amd64\nmake release-server\ncd /usr/lib/golang/src/\nGOOS=darwin GOARCH=amd64 ./make.bash\ncd ~/ngrok\nGOOS=darwin GOARCH=amd64 make release-client\n```\n\n### 服务端运行脚本\n\n```\nnohup  bin/ngrokd -domain=\"ngrok.arclin.me\" -httpAddr=\":8081\" -httpsAddr=\":8082\" &\n```\n> nohub 后台运行\n\n### 客户端\n\n新建 `./ngrok.cfg` 文件写入信息\n\n```\nserver_addr:arclin.me:4443\ntrust_host_root_certs: false\n```\n\n客户端运行\n```\n./ngrok -config=./ngrok.cfg -subdomain=test 3000\n```","source":"_posts/ngrok-内网穿透使用.md","raw":"---\ntitle: ngrok 内网穿透使用\nauthor: Arclin\ntags:\n  - ngrok\ncategories:\n  - Linux\nabbrlink: dda122f4\ndate: 2018-02-18 22:02:00\n---\nngrok 内网穿透使用\n\n<!-- more -->\n\n### 安装golang\n\n```\nsudo yum install build-essential golang mercurial git\n```\n\n### 运行脚本\n\n```\ncd ~\ngit clone https://github.com/tutumcloud/ngrok.git ngrok\nexport NGROK_DOMAIN=\"ngrok.arclin.me\"\ncd ngrok\nopenssl genrsa -out rootCA.key 2048\nopenssl req -x509 -new -nodes -key rootCA.key -subj \"/CN=$NGROK_DOMAIN” -days 5000 -out rootCA.pem\nopenssl genrsa -out device.key 2048\nopenssl req -new -key device.key -subj \"/CN=$NGROK_DOMAIN” -out device.csr\nopenssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000\ncp rootCA.pem assets/client/tls/ngrokroot.crt\ncp device.crt assets/server/tls/snakeoil.crt\ncp device.key assets/server/tls/snakeoil.key\nGOOS=linux GOARCH=amd64\nmake release-server\ncd /usr/lib/golang/src/\nGOOS=darwin GOARCH=amd64 ./make.bash\ncd ~/ngrok\nGOOS=darwin GOARCH=amd64 make release-client\n```\n\n### 服务端运行脚本\n\n```\nnohup  bin/ngrokd -domain=\"ngrok.arclin.me\" -httpAddr=\":8081\" -httpsAddr=\":8082\" &\n```\n> nohub 后台运行\n\n### 客户端\n\n新建 `./ngrok.cfg` 文件写入信息\n\n```\nserver_addr:arclin.me:4443\ntrust_host_root_certs: false\n```\n\n客户端运行\n```\n./ngrok -config=./ngrok.cfg -subdomain=test 3000\n```","slug":"ngrok-内网穿透使用","published":1,"updated":"2021-04-12T06:07:04.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5q003n45n03re560ha","content":"<p>ngrok 内网穿透使用</p>\n<span id=\"more\"></span>\n\n<h3 id=\"安装golang\"><a href=\"#安装golang\" class=\"headerlink\" title=\"安装golang\"></a>安装golang</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install build-essential golang mercurial git</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行脚本\"><a href=\"#运行脚本\" class=\"headerlink\" title=\"运行脚本\"></a>运行脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;tutumcloud&#x2F;ngrok.git ngrok</span><br><span class=\"line\">export NGROK_DOMAIN&#x3D;&quot;ngrok.arclin.me&quot;</span><br><span class=\"line\">cd ngrok</span><br><span class=\"line\">openssl genrsa -out rootCA.key 2048</span><br><span class=\"line\">openssl req -x509 -new -nodes -key rootCA.key -subj &quot;&#x2F;CN&#x3D;$NGROK_DOMAIN” -days 5000 -out rootCA.pem</span><br><span class=\"line\">openssl genrsa -out device.key 2048</span><br><span class=\"line\">openssl req -new -key device.key -subj &quot;&#x2F;CN&#x3D;$NGROK_DOMAIN” -out device.csr</span><br><span class=\"line\">openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br><span class=\"line\">cp rootCA.pem assets&#x2F;client&#x2F;tls&#x2F;ngrokroot.crt</span><br><span class=\"line\">cp device.crt assets&#x2F;server&#x2F;tls&#x2F;snakeoil.crt</span><br><span class=\"line\">cp device.key assets&#x2F;server&#x2F;tls&#x2F;snakeoil.key</span><br><span class=\"line\">GOOS&#x3D;linux GOARCH&#x3D;amd64</span><br><span class=\"line\">make release-server</span><br><span class=\"line\">cd &#x2F;usr&#x2F;lib&#x2F;golang&#x2F;src&#x2F;</span><br><span class=\"line\">GOOS&#x3D;darwin GOARCH&#x3D;amd64 .&#x2F;make.bash</span><br><span class=\"line\">cd ~&#x2F;ngrok</span><br><span class=\"line\">GOOS&#x3D;darwin GOARCH&#x3D;amd64 make release-client</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务端运行脚本\"><a href=\"#服务端运行脚本\" class=\"headerlink\" title=\"服务端运行脚本\"></a>服务端运行脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup  bin&#x2F;ngrokd -domain&#x3D;&quot;ngrok.arclin.me&quot; -httpAddr&#x3D;&quot;:8081&quot; -httpsAddr&#x3D;&quot;:8082&quot; &amp;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>nohub 后台运行</p>\n</blockquote>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><p>新建 <code>./ngrok.cfg</code> 文件写入信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server_addr:arclin.me:4443</span><br><span class=\"line\">trust_host_root_certs: false</span><br></pre></td></tr></table></figure>\n\n<p>客户端运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;ngrok -config&#x3D;.&#x2F;ngrok.cfg -subdomain&#x3D;test 3000</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>ngrok 内网穿透使用</p>","more":"<h3 id=\"安装golang\"><a href=\"#安装golang\" class=\"headerlink\" title=\"安装golang\"></a>安装golang</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install build-essential golang mercurial git</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运行脚本\"><a href=\"#运行脚本\" class=\"headerlink\" title=\"运行脚本\"></a>运行脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;tutumcloud&#x2F;ngrok.git ngrok</span><br><span class=\"line\">export NGROK_DOMAIN&#x3D;&quot;ngrok.arclin.me&quot;</span><br><span class=\"line\">cd ngrok</span><br><span class=\"line\">openssl genrsa -out rootCA.key 2048</span><br><span class=\"line\">openssl req -x509 -new -nodes -key rootCA.key -subj &quot;&#x2F;CN&#x3D;$NGROK_DOMAIN” -days 5000 -out rootCA.pem</span><br><span class=\"line\">openssl genrsa -out device.key 2048</span><br><span class=\"line\">openssl req -new -key device.key -subj &quot;&#x2F;CN&#x3D;$NGROK_DOMAIN” -out device.csr</span><br><span class=\"line\">openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br><span class=\"line\">cp rootCA.pem assets&#x2F;client&#x2F;tls&#x2F;ngrokroot.crt</span><br><span class=\"line\">cp device.crt assets&#x2F;server&#x2F;tls&#x2F;snakeoil.crt</span><br><span class=\"line\">cp device.key assets&#x2F;server&#x2F;tls&#x2F;snakeoil.key</span><br><span class=\"line\">GOOS&#x3D;linux GOARCH&#x3D;amd64</span><br><span class=\"line\">make release-server</span><br><span class=\"line\">cd &#x2F;usr&#x2F;lib&#x2F;golang&#x2F;src&#x2F;</span><br><span class=\"line\">GOOS&#x3D;darwin GOARCH&#x3D;amd64 .&#x2F;make.bash</span><br><span class=\"line\">cd ~&#x2F;ngrok</span><br><span class=\"line\">GOOS&#x3D;darwin GOARCH&#x3D;amd64 make release-client</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务端运行脚本\"><a href=\"#服务端运行脚本\" class=\"headerlink\" title=\"服务端运行脚本\"></a>服务端运行脚本</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup  bin&#x2F;ngrokd -domain&#x3D;&quot;ngrok.arclin.me&quot; -httpAddr&#x3D;&quot;:8081&quot; -httpsAddr&#x3D;&quot;:8082&quot; &amp;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>nohub 后台运行</p>\n</blockquote>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><p>新建 <code>./ngrok.cfg</code> 文件写入信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server_addr:arclin.me:4443</span><br><span class=\"line\">trust_host_root_certs: false</span><br></pre></td></tr></table></figure>\n\n<p>客户端运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;ngrok -config&#x3D;.&#x2F;ngrok.cfg -subdomain&#x3D;test 3000</span><br></pre></td></tr></table></figure>"},{"title":"nginx 镜像谷歌","author":"Arclin","abbrlink":"a6a89073","date":"2018-02-18T14:12:00.000Z","_content":"nginx 镜像谷歌\n\n<!-- more -->\n\n安装nginx第三方模块\n\n下载->解压->编译\n\n```\nwget http://artfiles.org/openssl.org/source/old/1.1.0/openssl-1.1.0g.tar.gz\nwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz\nwget http://zlib.net/zlib-1.2.11.tar.gz\n\ngit clone https://github.com/nginx/nginx.git\ngit clone https://github.com/cuber/ngx_http_google_filter_module\ngit clone https://github.com/yaoweibin/ngx_http_substitutions_filter_module\n\ncd ngx_http_google_filter_module\ngit checkout 77532b9\ncd ..\n\ntar -zxvf openssl-1.1.0g.tar.gz \ntar -zxvf pcre-8.39.tar.gz \ntar -zxvf zlib-1.2.11.tar.gz\n\ncd nginx\n\n./auto/configure --prefix=/usr/local/nginx --conf-path=/usr/local/nginx/conf/nginx.conf --with-http_v2_module --with-pcre=../pcre-8.39 --with-openssl=../openssl-1.1.0g --with-zlib=../zlib-1.2.11 --with-http_ssl_module --add-module=../ngx_http_google_filter_module --add-module=../ngx_http_substitutions_filter_module\n\nmake -j 4\n\nsudo make install\n```\n\n修改配置文件\n\n`vi /usr/local/nginx/conf/nginx.conf`\n\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    resolver 8.8.8.8;\n    location / {\n        google on;\n    }\n}\n```\n\n重启nginx\n\n```\nnginx -s reload\nservice nginx restart\n```\n\nreload 时发生错误\n\n```\nnginx: [error] open() \"/var/run/nginx.pid\" failed (2: No such file or directory)\n```\n\n解决\n\n```\nnginx -c /usr/local/nginx/conf/nginx.conf\n```\n","source":"_posts/nginx-镜像谷歌.md","raw":"---\ntitle: nginx 镜像谷歌\nauthor: Arclin\ntags:\n  - nginx\ncategories:\n  - Linux\nabbrlink: a6a89073\ndate: 2018-02-18 22:12:00\n---\nnginx 镜像谷歌\n\n<!-- more -->\n\n安装nginx第三方模块\n\n下载->解压->编译\n\n```\nwget http://artfiles.org/openssl.org/source/old/1.1.0/openssl-1.1.0g.tar.gz\nwget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.39.tar.gz\nwget http://zlib.net/zlib-1.2.11.tar.gz\n\ngit clone https://github.com/nginx/nginx.git\ngit clone https://github.com/cuber/ngx_http_google_filter_module\ngit clone https://github.com/yaoweibin/ngx_http_substitutions_filter_module\n\ncd ngx_http_google_filter_module\ngit checkout 77532b9\ncd ..\n\ntar -zxvf openssl-1.1.0g.tar.gz \ntar -zxvf pcre-8.39.tar.gz \ntar -zxvf zlib-1.2.11.tar.gz\n\ncd nginx\n\n./auto/configure --prefix=/usr/local/nginx --conf-path=/usr/local/nginx/conf/nginx.conf --with-http_v2_module --with-pcre=../pcre-8.39 --with-openssl=../openssl-1.1.0g --with-zlib=../zlib-1.2.11 --with-http_ssl_module --add-module=../ngx_http_google_filter_module --add-module=../ngx_http_substitutions_filter_module\n\nmake -j 4\n\nsudo make install\n```\n\n修改配置文件\n\n`vi /usr/local/nginx/conf/nginx.conf`\n\n```\nserver {\n    server_name g.arclin.me;\n    listen 80;\n    resolver 8.8.8.8;\n    location / {\n        google on;\n    }\n}\n```\n\n重启nginx\n\n```\nnginx -s reload\nservice nginx restart\n```\n\nreload 时发生错误\n\n```\nnginx: [error] open() \"/var/run/nginx.pid\" failed (2: No such file or directory)\n```\n\n解决\n\n```\nnginx -c /usr/local/nginx/conf/nginx.conf\n```\n","slug":"nginx-镜像谷歌","published":1,"updated":"2021-04-12T06:07:04.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5q003r45n0c8kecaik","content":"<p>nginx 镜像谷歌</p>\n<span id=\"more\"></span>\n\n<p>安装nginx第三方模块</p>\n<p>下载-&gt;解压-&gt;编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http:&#x2F;&#x2F;artfiles.org&#x2F;openssl.org&#x2F;source&#x2F;old&#x2F;1.1.0&#x2F;openssl-1.1.0g.tar.gz</span><br><span class=\"line\">wget ftp:&#x2F;&#x2F;ftp.csx.cam.ac.uk&#x2F;pub&#x2F;software&#x2F;programming&#x2F;pcre&#x2F;pcre-8.39.tar.gz</span><br><span class=\"line\">wget http:&#x2F;&#x2F;zlib.net&#x2F;zlib-1.2.11.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;nginx&#x2F;nginx.git</span><br><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;cuber&#x2F;ngx_http_google_filter_module</span><br><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;yaoweibin&#x2F;ngx_http_substitutions_filter_module</span><br><span class=\"line\"></span><br><span class=\"line\">cd ngx_http_google_filter_module</span><br><span class=\"line\">git checkout 77532b9</span><br><span class=\"line\">cd ..</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf openssl-1.1.0g.tar.gz </span><br><span class=\"line\">tar -zxvf pcre-8.39.tar.gz </span><br><span class=\"line\">tar -zxvf zlib-1.2.11.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">cd nginx</span><br><span class=\"line\"></span><br><span class=\"line\">.&#x2F;auto&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --conf-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf --with-http_v2_module --with-pcre&#x3D;..&#x2F;pcre-8.39 --with-openssl&#x3D;..&#x2F;openssl-1.1.0g --with-zlib&#x3D;..&#x2F;zlib-1.2.11 --with-http_ssl_module --add-module&#x3D;..&#x2F;ngx_http_google_filter_module --add-module&#x3D;..&#x2F;ngx_http_substitutions_filter_module</span><br><span class=\"line\"></span><br><span class=\"line\">make -j 4</span><br><span class=\"line\"></span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件</p>\n<p><code>vi /usr/local/nginx/conf/nginx.conf</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location &#x2F; &#123;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重启nginx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br><span class=\"line\">service nginx restart</span><br></pre></td></tr></table></figure>\n\n<p>reload 时发生错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx: [error] open() &quot;&#x2F;var&#x2F;run&#x2F;nginx.pid&quot; failed (2: No such file or directory)</span><br></pre></td></tr></table></figure>\n\n<p>解决</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>nginx 镜像谷歌</p>","more":"<p>安装nginx第三方模块</p>\n<p>下载-&gt;解压-&gt;编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http:&#x2F;&#x2F;artfiles.org&#x2F;openssl.org&#x2F;source&#x2F;old&#x2F;1.1.0&#x2F;openssl-1.1.0g.tar.gz</span><br><span class=\"line\">wget ftp:&#x2F;&#x2F;ftp.csx.cam.ac.uk&#x2F;pub&#x2F;software&#x2F;programming&#x2F;pcre&#x2F;pcre-8.39.tar.gz</span><br><span class=\"line\">wget http:&#x2F;&#x2F;zlib.net&#x2F;zlib-1.2.11.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;nginx&#x2F;nginx.git</span><br><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;cuber&#x2F;ngx_http_google_filter_module</span><br><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;yaoweibin&#x2F;ngx_http_substitutions_filter_module</span><br><span class=\"line\"></span><br><span class=\"line\">cd ngx_http_google_filter_module</span><br><span class=\"line\">git checkout 77532b9</span><br><span class=\"line\">cd ..</span><br><span class=\"line\"></span><br><span class=\"line\">tar -zxvf openssl-1.1.0g.tar.gz </span><br><span class=\"line\">tar -zxvf pcre-8.39.tar.gz </span><br><span class=\"line\">tar -zxvf zlib-1.2.11.tar.gz</span><br><span class=\"line\"></span><br><span class=\"line\">cd nginx</span><br><span class=\"line\"></span><br><span class=\"line\">.&#x2F;auto&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --conf-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf --with-http_v2_module --with-pcre&#x3D;..&#x2F;pcre-8.39 --with-openssl&#x3D;..&#x2F;openssl-1.1.0g --with-zlib&#x3D;..&#x2F;zlib-1.2.11 --with-http_ssl_module --add-module&#x3D;..&#x2F;ngx_http_google_filter_module --add-module&#x3D;..&#x2F;ngx_http_substitutions_filter_module</span><br><span class=\"line\"></span><br><span class=\"line\">make -j 4</span><br><span class=\"line\"></span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure>\n\n<p>修改配置文件</p>\n<p><code>vi /usr/local/nginx/conf/nginx.conf</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    server_name g.arclin.me;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    resolver 8.8.8.8;</span><br><span class=\"line\">    location &#x2F; &#123;</span><br><span class=\"line\">        google on;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重启nginx</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -s reload</span><br><span class=\"line\">service nginx restart</span><br></pre></td></tr></table></figure>\n\n<p>reload 时发生错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx: [error] open() &quot;&#x2F;var&#x2F;run&#x2F;nginx.pid&quot; failed (2: No such file or directory)</span><br></pre></td></tr></table></figure>\n\n<p>解决</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>"},{"title":"pop后强制竖屏","author":"Arclin","abbrlink":"50c5f6e6","date":"2016-10-16T16:00:00.000Z","_content":"pop之后强制竖屏\n\n<!-- more -->\n\n`AppDeleagte.h`\n\n```\n// 控制全部不支持横屏，当allowRotation为YES的时候可以横/竖屏切换\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    if (self.allowRotation) {\n        return  UIInterfaceOrientationMaskAllButUpsideDown;\n    }\n    return UIInterfaceOrientationMaskPortrait;\n}\n```\n\npop之后强制竖屏\n\n```\n- (void)viewDidAppear:(BOOL)animated\n{\n     [super viewDidAppear:animated];\n    \n    // 强制竖屏\n    [[UIDevice currentDevice] setValue:@(UIDeviceOrientationPortrait) forKey:@\"orientation\"];\n}\n```","source":"_posts/pop后强制竖屏.md","raw":"---\ntitle: pop后强制竖屏\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 50c5f6e6\ndate: 2016-10-17 00:00:00\n---\npop之后强制竖屏\n\n<!-- more -->\n\n`AppDeleagte.h`\n\n```\n// 控制全部不支持横屏，当allowRotation为YES的时候可以横/竖屏切换\n- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window {\n    if (self.allowRotation) {\n        return  UIInterfaceOrientationMaskAllButUpsideDown;\n    }\n    return UIInterfaceOrientationMaskPortrait;\n}\n```\n\npop之后强制竖屏\n\n```\n- (void)viewDidAppear:(BOOL)animated\n{\n     [super viewDidAppear:animated];\n    \n    // 强制竖屏\n    [[UIDevice currentDevice] setValue:@(UIDeviceOrientationPortrait) forKey:@\"orientation\"];\n}\n```","slug":"pop后强制竖屏","published":1,"updated":"2021-04-12T06:07:04.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5r003u45n028s1a6ha","content":"<p>pop之后强制竖屏</p>\n<span id=\"more\"></span>\n\n<p><code>AppDeleagte.h</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 控制全部不支持横屏，当allowRotation为YES的时候可以横&#x2F;竖屏切换</span><br><span class=\"line\">- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;</span><br><span class=\"line\">    if (self.allowRotation) &#123;</span><br><span class=\"line\">        return  UIInterfaceOrientationMaskAllButUpsideDown;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return UIInterfaceOrientationMaskPortrait;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>pop之后强制竖屏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     [super viewDidAppear:animated];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 强制竖屏</span><br><span class=\"line\">    [[UIDevice currentDevice] setValue:@(UIDeviceOrientationPortrait) forKey:@&quot;orientation&quot;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>pop之后强制竖屏</p>","more":"<p><code>AppDeleagte.h</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 控制全部不支持横屏，当allowRotation为YES的时候可以横&#x2F;竖屏切换</span><br><span class=\"line\">- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;</span><br><span class=\"line\">    if (self.allowRotation) &#123;</span><br><span class=\"line\">        return  UIInterfaceOrientationMaskAllButUpsideDown;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return UIInterfaceOrientationMaskPortrait;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>pop之后强制竖屏</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     [super viewDidAppear:animated];</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#x2F;&#x2F; 强制竖屏</span><br><span class=\"line\">    [[UIDevice currentDevice] setValue:@(UIDeviceOrientationPortrait) forKey:@&quot;orientation&quot;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"pan手势判断方向","author":"Arclin","abbrlink":"34db2dbc","date":"2016-10-16T16:00:00.000Z","_content":"pan手势判断方向\n\n```\nUIPanGestureRecognizer *pan = (UIPanGestureRecognizer *)gestureRecognizer;\nCGPoint point = [pan translationInView:gestureRecognizer.view]; // point.x < 0 左滑\n```","source":"_posts/pan手势判断方向.md","raw":"---\ntitle: pan手势判断方向\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 34db2dbc\ndate: 2016-10-17 00:00:00\n---\npan手势判断方向\n\n```\nUIPanGestureRecognizer *pan = (UIPanGestureRecognizer *)gestureRecognizer;\nCGPoint point = [pan translationInView:gestureRecognizer.view]; // point.x < 0 左滑\n```","slug":"pan手势判断方向","published":1,"updated":"2021-04-12T06:07:04.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5s003y45n01ccm0bgm","content":"<p>pan手势判断方向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIPanGestureRecognizer *pan &#x3D; (UIPanGestureRecognizer *)gestureRecognizer;</span><br><span class=\"line\">CGPoint point &#x3D; [pan translationInView:gestureRecognizer.view]; &#x2F;&#x2F; point.x &lt; 0 左滑</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>pan手势判断方向</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIPanGestureRecognizer *pan &#x3D; (UIPanGestureRecognizer *)gestureRecognizer;</span><br><span class=\"line\">CGPoint point &#x3D; [pan translationInView:gestureRecognizer.view]; &#x2F;&#x2F; point.x &lt; 0 左滑</span><br></pre></td></tr></table></figure>"},{"title":"什么时候用weakSelf什么时候用strongSelf","author":"Arclin","abbrlink":"f9b1d95c","date":"2016-10-16T16:00:00.000Z","_content":"#### 什么时候用weakSelf 什么时候用 strongSelf\n\n - Objective C 的 Block 是一个很实用的语法，特别是与GCD结合使用，可以很方便地实现并发、异步任务。但是，如果使用不当，Block 也会引起一些循环引用问题(retain cycle)—— Block 会 retain ‘self’，而 ‘self‘ 又 retain 了 Block。因为在 ObjC 中，直接调用一个实例变量，会被编译器处理成 ‘self->theVar’，’self’ 是一个 strong 类型的变量，引用计数会加 1，于是，self retains queue， queue retains block，block retains self。\n\n - 解决 retain circle\n\n \t- Apple 官方的建议是，传进 Block 之前，把 ‘self’ 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。\n示例代码：\n\n```\n__weak typeof(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ \n\t[weakSelf doSomething]; \n});\n```\n\n - clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：\n\n```\n__weak typeof(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n \t[weakSelf doSomething]; \n \t[weakSelf doOtherThing]; \n});\n```\n\n - 在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，于是，strongSelf 就派上用场了：\n\n```\n__weak __typeof__(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n \t__strong typeof(self) strongSelf = weakSelf;\n   [strongSelf doSomething];\n   [strongSelf doOtherThing];\n });\n```\n\n - __strong 确保在 Block 内，strongSelf 不会被释放。\n\n- 总结\n\n\t- 在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。\n\n\t- 如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。","source":"_posts/什么时候用weakSelf什么时候用strongSelf.md","raw":"---\ntitle: 什么时候用weakSelf什么时候用strongSelf\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: f9b1d95c\ndate: 2016-10-17 00:00:00\n---\n#### 什么时候用weakSelf 什么时候用 strongSelf\n\n - Objective C 的 Block 是一个很实用的语法，特别是与GCD结合使用，可以很方便地实现并发、异步任务。但是，如果使用不当，Block 也会引起一些循环引用问题(retain cycle)—— Block 会 retain ‘self’，而 ‘self‘ 又 retain 了 Block。因为在 ObjC 中，直接调用一个实例变量，会被编译器处理成 ‘self->theVar’，’self’ 是一个 strong 类型的变量，引用计数会加 1，于是，self retains queue， queue retains block，block retains self。\n\n - 解决 retain circle\n\n \t- Apple 官方的建议是，传进 Block 之前，把 ‘self’ 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。\n示例代码：\n\n```\n__weak typeof(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ \n\t[weakSelf doSomething]; \n});\n```\n\n - clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：\n\n```\n__weak typeof(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n \t[weakSelf doSomething]; \n \t[weakSelf doOtherThing]; \n});\n```\n\n - 在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，于是，strongSelf 就派上用场了：\n\n```\n__weak __typeof__(self) weakSelf = self;\ndispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n \t__strong typeof(self) strongSelf = weakSelf;\n   [strongSelf doSomething];\n   [strongSelf doOtherThing];\n });\n```\n\n - __strong 确保在 Block 内，strongSelf 不会被释放。\n\n- 总结\n\n\t- 在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。\n\n\t- 如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。","slug":"什么时候用weakSelf什么时候用strongSelf","published":1,"updated":"2021-04-12T06:07:04.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5s004145n0gd5pemjc","content":"<h4 id=\"什么时候用weakSelf-什么时候用-strongSelf\"><a href=\"#什么时候用weakSelf-什么时候用-strongSelf\" class=\"headerlink\" title=\"什么时候用weakSelf 什么时候用 strongSelf\"></a>什么时候用weakSelf 什么时候用 strongSelf</h4><ul>\n<li><p>Objective C 的 Block 是一个很实用的语法，特别是与GCD结合使用，可以很方便地实现并发、异步任务。但是，如果使用不当，Block 也会引起一些循环引用问题(retain cycle)—— Block 会 retain ‘self’，而 ‘self‘ 又 retain 了 Block。因为在 ObjC 中，直接调用一个实例变量，会被编译器处理成 ‘self-&gt;theVar’，’self’ 是一个 strong 类型的变量，引用计数会加 1，于是，self retains queue， queue retains block，block retains self。</p>\n</li>\n<li><p>解决 retain circle</p>\n<ul>\n<li>Apple 官方的建议是，传进 Block 之前，把 ‘self’ 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。<br>示例代码：</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; </span><br><span class=\"line\">\t[weakSelf doSomething]; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\"> \t[weakSelf doSomething]; </span><br><span class=\"line\"> \t[weakSelf doOtherThing]; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，于是，strongSelf 就派上用场了：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak __typeof__(self) weakSelf &#x3D; self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\"> \t__strong typeof(self) strongSelf &#x3D; weakSelf;</span><br><span class=\"line\">   [strongSelf doSomething];</span><br><span class=\"line\">   [strongSelf doOtherThing];</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>__strong 确保在 Block 内，strongSelf 不会被释放。</p>\n</li>\n<li><p>总结</p>\n<ul>\n<li><p>在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。</p>\n</li>\n<li><p>如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"什么时候用weakSelf-什么时候用-strongSelf\"><a href=\"#什么时候用weakSelf-什么时候用-strongSelf\" class=\"headerlink\" title=\"什么时候用weakSelf 什么时候用 strongSelf\"></a>什么时候用weakSelf 什么时候用 strongSelf</h4><ul>\n<li><p>Objective C 的 Block 是一个很实用的语法，特别是与GCD结合使用，可以很方便地实现并发、异步任务。但是，如果使用不当，Block 也会引起一些循环引用问题(retain cycle)—— Block 会 retain ‘self’，而 ‘self‘ 又 retain 了 Block。因为在 ObjC 中，直接调用一个实例变量，会被编译器处理成 ‘self-&gt;theVar’，’self’ 是一个 strong 类型的变量，引用计数会加 1，于是，self retains queue， queue retains block，block retains self。</p>\n</li>\n<li><p>解决 retain circle</p>\n<ul>\n<li>Apple 官方的建议是，传进 Block 之前，把 ‘self’ 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。<br>示例代码：</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; </span><br><span class=\"line\">\t[weakSelf doSomething]; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\"> \t[weakSelf doSomething]; </span><br><span class=\"line\"> \t[weakSelf doOtherThing]; </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，于是，strongSelf 就派上用场了：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__weak __typeof__(self) weakSelf &#x3D; self;</span><br><span class=\"line\">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class=\"line\"> \t__strong typeof(self) strongSelf &#x3D; weakSelf;</span><br><span class=\"line\">   [strongSelf doSomething];</span><br><span class=\"line\">   [strongSelf doOtherThing];</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>__strong 确保在 Block 内，strongSelf 不会被释放。</p>\n</li>\n<li><p>总结</p>\n<ul>\n<li><p>在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。</p>\n</li>\n<li><p>如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"一句ipack命令解决iOS编译打包上传fir流程","author":"Arclin","abbrlink":"4edc914d","date":"2017-02-13T16:00:00.000Z","_content":"一行命令即可将包含 cocoapods 的iOS 项目编译打包并上传到 fir\n<!-- more -->\n\n### 准备工具\n - fir-cli\n - Cocopods\n \n### 功能\n\n进入任意一个有.xcodeworksapce文件的目录下，输入ipack（可以自定义）即可完成编译打包上传，加上-c 更新说明\n参数就可以填写本次打包的更新说明，这个说明会在 fir 上面显示出来\n\n### 编写shell脚本\n\nsh代码说明\n\n变量定义\n\n`basepath=$(pwd)`  命令行代码执行位置\n`bName=$(basename ${basepath})`  拿到项目文件夹名字\n`description=$(basename ${basepath})` 要写在 fir 的更新说明\n`achivepath=${basepath}'/build/'${bName}'.xcarchive'` 构建文件的储存位置\n\n`ipaPath=${basepath}'/'${bName}'.ipa'` ipa 的储存位置\n\n拿到参数\n\n```\nwhile getopts \":c:\" opt; do` # 遍历参数 虽然现在只有一个，不过为了拓展还是可以加上去\ncase $opt in\n    c ) description=\"$OPTARG\";;   # 如果参数是c 的话就把内容赋值给description\n    ? ) echo \"参数选项不正确，应该是 -c <发布内容>\"\n        exit 1;;\n    esca\ndone\n```\n\n判断命令是不是执行在有`.xcodeworksapce`文件的目录下\n\n`$(ls *.xcwork* >/dev/null 2>&1)`\n\n清除缓存\n\n```\n/usr/bin/xcodebuild -target　${bName} clean\n```\n\n编译\n\n```\n/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}\n```\n\n判断编译成功了吗\n\n`if [ ! -d ${achivepath} ];`\n\n打包\n\n/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}\n\n判断打包成功了吗\n\n`if [ ! -f ${ipaPath} ];`\n\n上传到 fir\n\n```\nfir publish ${bName}.ipa --token <你的 Fir Token> -c ${description}\n```\n\nfirToken 的位置\n\n![](/images/pasted-0.png)\n\n清理编译打包的文件\n\n```\nrm -rf ${ipaPath} ${achivepath}\n```\n\n完事\n\n执行\n如果你把 sh文件放在桌面的话，一般来说现在去到有.xcodeworksapce文件的目录下，执行\n\n```\n~/Desktop/iosPackage.sh\n```\n\n就可以了，加个参数就是\n\n```\n~/Desktop/iosPackage.sh -c \"测试测试\"`\n```\n\n但是`~/Desktop/iosPackage.sh`太长了，所以得给他加个别名\n\n所以执行\n\n```\ncd ~\ntouch .bash_profile\n```\n\n创建一个`.bash_profile`文件\n\n然后在里面填写 `alias ipack='~/Desktop/iosPackage.sh'`\n这个`ipack`你想写啥就啥\n\n然后保存之后执行\n\n`source ./bash_profile`\n\n之后就可以直接用 ipack 代替 `~/Desktop/iosPackage.sh`\n\n`ipack ipack -c \"测试测试\"`\n\nEND","source":"_posts/一句ipack命令解决iOS编译打包上传fir流程.md","raw":"---\ntitle: 一句ipack命令解决iOS编译打包上传fir流程\nauthor: Arclin\ntags:\n  - Fir\n  - shell\ncategories:\n  - iOS\nabbrlink: 4edc914d\ndate: 2017-02-14 00:00:00\n---\n一行命令即可将包含 cocoapods 的iOS 项目编译打包并上传到 fir\n<!-- more -->\n\n### 准备工具\n - fir-cli\n - Cocopods\n \n### 功能\n\n进入任意一个有.xcodeworksapce文件的目录下，输入ipack（可以自定义）即可完成编译打包上传，加上-c 更新说明\n参数就可以填写本次打包的更新说明，这个说明会在 fir 上面显示出来\n\n### 编写shell脚本\n\nsh代码说明\n\n变量定义\n\n`basepath=$(pwd)`  命令行代码执行位置\n`bName=$(basename ${basepath})`  拿到项目文件夹名字\n`description=$(basename ${basepath})` 要写在 fir 的更新说明\n`achivepath=${basepath}'/build/'${bName}'.xcarchive'` 构建文件的储存位置\n\n`ipaPath=${basepath}'/'${bName}'.ipa'` ipa 的储存位置\n\n拿到参数\n\n```\nwhile getopts \":c:\" opt; do` # 遍历参数 虽然现在只有一个，不过为了拓展还是可以加上去\ncase $opt in\n    c ) description=\"$OPTARG\";;   # 如果参数是c 的话就把内容赋值给description\n    ? ) echo \"参数选项不正确，应该是 -c <发布内容>\"\n        exit 1;;\n    esca\ndone\n```\n\n判断命令是不是执行在有`.xcodeworksapce`文件的目录下\n\n`$(ls *.xcwork* >/dev/null 2>&1)`\n\n清除缓存\n\n```\n/usr/bin/xcodebuild -target　${bName} clean\n```\n\n编译\n\n```\n/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}\n```\n\n判断编译成功了吗\n\n`if [ ! -d ${achivepath} ];`\n\n打包\n\n/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}\n\n判断打包成功了吗\n\n`if [ ! -f ${ipaPath} ];`\n\n上传到 fir\n\n```\nfir publish ${bName}.ipa --token <你的 Fir Token> -c ${description}\n```\n\nfirToken 的位置\n\n![](/images/pasted-0.png)\n\n清理编译打包的文件\n\n```\nrm -rf ${ipaPath} ${achivepath}\n```\n\n完事\n\n执行\n如果你把 sh文件放在桌面的话，一般来说现在去到有.xcodeworksapce文件的目录下，执行\n\n```\n~/Desktop/iosPackage.sh\n```\n\n就可以了，加个参数就是\n\n```\n~/Desktop/iosPackage.sh -c \"测试测试\"`\n```\n\n但是`~/Desktop/iosPackage.sh`太长了，所以得给他加个别名\n\n所以执行\n\n```\ncd ~\ntouch .bash_profile\n```\n\n创建一个`.bash_profile`文件\n\n然后在里面填写 `alias ipack='~/Desktop/iosPackage.sh'`\n这个`ipack`你想写啥就啥\n\n然后保存之后执行\n\n`source ./bash_profile`\n\n之后就可以直接用 ipack 代替 `~/Desktop/iosPackage.sh`\n\n`ipack ipack -c \"测试测试\"`\n\nEND","slug":"一句ipack命令解决iOS编译打包上传fir流程","published":1,"updated":"2021-04-12T06:07:04.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5t004445n0155eakmv","content":"<p>一行命令即可将包含 cocoapods 的iOS 项目编译打包并上传到 fir</p>\n<span id=\"more\"></span>\n\n<h3 id=\"准备工具\"><a href=\"#准备工具\" class=\"headerlink\" title=\"准备工具\"></a>准备工具</h3><ul>\n<li>fir-cli</li>\n<li>Cocopods</li>\n</ul>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>进入任意一个有.xcodeworksapce文件的目录下，输入ipack（可以自定义）即可完成编译打包上传，加上-c 更新说明<br>参数就可以填写本次打包的更新说明，这个说明会在 fir 上面显示出来</p>\n<h3 id=\"编写shell脚本\"><a href=\"#编写shell脚本\" class=\"headerlink\" title=\"编写shell脚本\"></a>编写shell脚本</h3><p>sh代码说明</p>\n<p>变量定义</p>\n<p><code>basepath=$(pwd)</code>  命令行代码执行位置<br><code>bName=$(basename $&#123;basepath&#125;)</code>  拿到项目文件夹名字<br><code>description=$(basename $&#123;basepath&#125;)</code> 要写在 fir 的更新说明<br><code>achivepath=$&#123;basepath&#125;&#39;/build/&#39;$&#123;bName&#125;&#39;.xcarchive&#39;</code> 构建文件的储存位置</p>\n<p><code>ipaPath=$&#123;basepath&#125;&#39;/&#39;$&#123;bName&#125;&#39;.ipa&#39;</code> ipa 的储存位置</p>\n<p>拿到参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while getopts &quot;:c:&quot; opt; do&#96; # 遍历参数 虽然现在只有一个，不过为了拓展还是可以加上去</span><br><span class=\"line\">case $opt in</span><br><span class=\"line\">    c ) description&#x3D;&quot;$OPTARG&quot;;;   # 如果参数是c 的话就把内容赋值给description</span><br><span class=\"line\">    ? ) echo &quot;参数选项不正确，应该是 -c &lt;发布内容&gt;&quot;</span><br><span class=\"line\">        exit 1;;</span><br><span class=\"line\">    esca</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n\n<p>判断命令是不是执行在有<code>.xcodeworksapce</code>文件的目录下</p>\n<p><code>$(ls *.xcwork* &gt;/dev/null 2&gt;&amp;1)</code></p>\n<p>清除缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;xcodebuild -target　$&#123;bName&#125; clean</span><br></pre></td></tr></table></figure>\n\n<p>编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;xcodebuild -exportArchive -exportFormat ipa -archivePath $&#123;achivepath&#125; -exportPath $&#123;ipaPath&#125;</span><br></pre></td></tr></table></figure>\n\n<p>判断编译成功了吗</p>\n<p><code>if [ ! -d $&#123;achivepath&#125; ];</code></p>\n<p>打包</p>\n<p>/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}</p>\n<p>判断打包成功了吗</p>\n<p><code>if [ ! -f $&#123;ipaPath&#125; ];</code></p>\n<p>上传到 fir</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fir publish $&#123;bName&#125;.ipa --token &lt;你的 Fir Token&gt; -c $&#123;description&#125;</span><br></pre></td></tr></table></figure>\n\n<p>firToken 的位置</p>\n<p><img src=\"/images/pasted-0.png\"></p>\n<p>清理编译打包的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf $&#123;ipaPath&#125; $&#123;achivepath&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完事</p>\n<p>执行<br>如果你把 sh文件放在桌面的话，一般来说现在去到有.xcodeworksapce文件的目录下，执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~&#x2F;Desktop&#x2F;iosPackage.sh</span><br></pre></td></tr></table></figure>\n\n<p>就可以了，加个参数就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~&#x2F;Desktop&#x2F;iosPackage.sh -c &quot;测试测试&quot;&#96;</span><br></pre></td></tr></table></figure>\n\n<p>但是<code>~/Desktop/iosPackage.sh</code>太长了，所以得给他加个别名</p>\n<p>所以执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">touch .bash_profile</span><br></pre></td></tr></table></figure>\n\n<p>创建一个<code>.bash_profile</code>文件</p>\n<p>然后在里面填写 <code>alias ipack=&#39;~/Desktop/iosPackage.sh&#39;</code><br>这个<code>ipack</code>你想写啥就啥</p>\n<p>然后保存之后执行</p>\n<p><code>source ./bash_profile</code></p>\n<p>之后就可以直接用 ipack 代替 <code>~/Desktop/iosPackage.sh</code></p>\n<p><code>ipack ipack -c &quot;测试测试&quot;</code></p>\n<p>END</p>\n","site":{"data":{}},"excerpt":"<p>一行命令即可将包含 cocoapods 的iOS 项目编译打包并上传到 fir</p>","more":"<h3 id=\"准备工具\"><a href=\"#准备工具\" class=\"headerlink\" title=\"准备工具\"></a>准备工具</h3><ul>\n<li>fir-cli</li>\n<li>Cocopods</li>\n</ul>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>进入任意一个有.xcodeworksapce文件的目录下，输入ipack（可以自定义）即可完成编译打包上传，加上-c 更新说明<br>参数就可以填写本次打包的更新说明，这个说明会在 fir 上面显示出来</p>\n<h3 id=\"编写shell脚本\"><a href=\"#编写shell脚本\" class=\"headerlink\" title=\"编写shell脚本\"></a>编写shell脚本</h3><p>sh代码说明</p>\n<p>变量定义</p>\n<p><code>basepath=$(pwd)</code>  命令行代码执行位置<br><code>bName=$(basename $&#123;basepath&#125;)</code>  拿到项目文件夹名字<br><code>description=$(basename $&#123;basepath&#125;)</code> 要写在 fir 的更新说明<br><code>achivepath=$&#123;basepath&#125;&#39;/build/&#39;$&#123;bName&#125;&#39;.xcarchive&#39;</code> 构建文件的储存位置</p>\n<p><code>ipaPath=$&#123;basepath&#125;&#39;/&#39;$&#123;bName&#125;&#39;.ipa&#39;</code> ipa 的储存位置</p>\n<p>拿到参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while getopts &quot;:c:&quot; opt; do&#96; # 遍历参数 虽然现在只有一个，不过为了拓展还是可以加上去</span><br><span class=\"line\">case $opt in</span><br><span class=\"line\">    c ) description&#x3D;&quot;$OPTARG&quot;;;   # 如果参数是c 的话就把内容赋值给description</span><br><span class=\"line\">    ? ) echo &quot;参数选项不正确，应该是 -c &lt;发布内容&gt;&quot;</span><br><span class=\"line\">        exit 1;;</span><br><span class=\"line\">    esca</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n\n<p>判断命令是不是执行在有<code>.xcodeworksapce</code>文件的目录下</p>\n<p><code>$(ls *.xcwork* &gt;/dev/null 2&gt;&amp;1)</code></p>\n<p>清除缓存</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;xcodebuild -target　$&#123;bName&#125; clean</span><br></pre></td></tr></table></figure>\n\n<p>编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;xcodebuild -exportArchive -exportFormat ipa -archivePath $&#123;achivepath&#125; -exportPath $&#123;ipaPath&#125;</span><br></pre></td></tr></table></figure>\n\n<p>判断编译成功了吗</p>\n<p><code>if [ ! -d $&#123;achivepath&#125; ];</code></p>\n<p>打包</p>\n<p>/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}</p>\n<p>判断打包成功了吗</p>\n<p><code>if [ ! -f $&#123;ipaPath&#125; ];</code></p>\n<p>上传到 fir</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fir publish $&#123;bName&#125;.ipa --token &lt;你的 Fir Token&gt; -c $&#123;description&#125;</span><br></pre></td></tr></table></figure>\n\n<p>firToken 的位置</p>\n<p><img src=\"/images/pasted-0.png\"></p>\n<p>清理编译打包的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf $&#123;ipaPath&#125; $&#123;achivepath&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完事</p>\n<p>执行<br>如果你把 sh文件放在桌面的话，一般来说现在去到有.xcodeworksapce文件的目录下，执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~&#x2F;Desktop&#x2F;iosPackage.sh</span><br></pre></td></tr></table></figure>\n\n<p>就可以了，加个参数就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~&#x2F;Desktop&#x2F;iosPackage.sh -c &quot;测试测试&quot;&#96;</span><br></pre></td></tr></table></figure>\n\n<p>但是<code>~/Desktop/iosPackage.sh</code>太长了，所以得给他加个别名</p>\n<p>所以执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~</span><br><span class=\"line\">touch .bash_profile</span><br></pre></td></tr></table></figure>\n\n<p>创建一个<code>.bash_profile</code>文件</p>\n<p>然后在里面填写 <code>alias ipack=&#39;~/Desktop/iosPackage.sh&#39;</code><br>这个<code>ipack</code>你想写啥就啥</p>\n<p>然后保存之后执行</p>\n<p><code>source ./bash_profile</code></p>\n<p>之后就可以直接用 ipack 代替 <code>~/Desktop/iosPackage.sh</code></p>\n<p><code>ipack ipack -c &quot;测试测试&quot;</code></p>\n<p>END</p>"},{"title":"使用RAC+DKHTTPTool实践","author":"Arclin","abbrlink":"8d52056b","date":"2016-12-25T16:00:00.000Z","_content":"使用RAC+DKHTTP套件实践\n- 这次通过一个简单的例子来解说DKHTTP套件与 RAC 结合的使用\n\n<!-- more -->\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/444.png?raw=true)\n\n- 首先简析下这个界面\n\t- 顶部搜索框部分的背景：广告栏位+图书推荐的图片，这里是一个获取图片的接口（接口 A）\n\t- 图书推荐： 这里也是一个接口，需要显示图书的封面（接口 B）\n\t- 笔记推荐： 这里也是一个接口，需要显示图书笔记的一些简介 （接口 C）\n- 页面渲染\n\n\t- 同页面多接口的渲染方式有多种： \n    \t-\t一是接口的串联，也就是一个接口返回的数据交作为参数给下一个接口去发送请求 ；\n    \t- 二是同时发送请求，根据接口返回的顺序渲染页面；\n    \t- 三是同时请求，等所有的接口返回之后再一次性进行渲染。\n\t- 上面的三种渲染方式，RACSignal都有相应的解决方案，假设这里页面渲染的方式选择的是依次渲染，那么我们使用 DKHTTPChainTool 的executeSignal()来写个例子\n\n```\n RACSignal *signalA = DKHTTPChainInstance.method(@\"POST\")\n                                         .url(@\"\")\n                                         .params(@{@\"did\":@\"1\",@\"page\":@\"1\",@\"num\":@\"100\"})\n                                         .executeSignal();\n\nRACSignal *signalB = DKHTTPChainInstance.method(@\"POST\")\n                                        .url(@\"\")\n                                        .params(@{@\"dis_id\":@\"9\"})\n                                        .executeSignal();\n\nRACSignal *signalC = DKHTTPChainInstance.method(@\"POST\")\n                                        .url(@\"\")\n                                        .params(@{@\"dis_id\":@\"9\"})\n                                        .executeSignal();\n\nRACSignal *mergeSignal = [RACSignal merge:@[signalA,signalB,signalC]];\n[mergeSignal subscribeNext:^(DKResponse *x){\n      DKLog(@\"%zd  %@\",x.taskIdentifier,x.rawData);\n}];\n```\n\n上面这个例子的结果会依次执行三个接口，并且按照接口返回的顺序执行mergeSignal 的 subscribeNext 的 block\n\n### 同时请求接口，等所有接口返回数据之后再进行渲染\n\n> 上面的三个 Signal就不重复写了\n\n```\nRACSignal *mergeSignal  = [RACSignal zip:@[signalA,signalB,signalC]];\n[mergeSignal subscribeNext:^(RACTuple *x){\n     [x.rac_sequence.signal subscribeNext:^(DKResponse *x) {\n         DKLog(@\"%@\",x.rawData);\n     }];\n}];\n```\n\n上面的 `mergeSignal` 里面会发送一个 `RACTuple` ,里面依次包装着三个请求 Signal的 `DKResponse`回调对象\n\n### 接口串联，上一个接口响应的数据作为下一个接口的参数\n\n```\n RACSignal *flattenSignal = [signalA flattenMap:^RACStream *(DKResponse *value) {\n        NSString *did = value.result[@\"content\"][0][@\"d_id\"];\n        return DKHTTPChainInstance.method(@\"GET\")\n                                 .url(@\"\")\n                                 .params(@{@\"did\":did,@\"page\":@\"1\",@\"num\":@\"20\"})\n                                 .executeSignal();\n}];\n[flattenSignal subscribeNext:^(DKResponse *x) {\n    DKLog(@\"%@\",x.rawData);\n}];\n```\n\n平时常用的大概就这么几个，待补充吧，之后我会继续讲讲关于异常处理的问题。","source":"_posts/使用RAC-DKHTTPTool实践.md","raw":"---\ntitle: 使用RAC+DKHTTPTool实践\nauthor: Arclin\ntags:\n  - iOS\n  - Reactive Cocoa\ncategories:\n  - iOS\nabbrlink: 8d52056b\ndate: 2016-12-26 00:00:00\n---\n使用RAC+DKHTTP套件实践\n- 这次通过一个简单的例子来解说DKHTTP套件与 RAC 结合的使用\n\n<!-- more -->\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/444.png?raw=true)\n\n- 首先简析下这个界面\n\t- 顶部搜索框部分的背景：广告栏位+图书推荐的图片，这里是一个获取图片的接口（接口 A）\n\t- 图书推荐： 这里也是一个接口，需要显示图书的封面（接口 B）\n\t- 笔记推荐： 这里也是一个接口，需要显示图书笔记的一些简介 （接口 C）\n- 页面渲染\n\n\t- 同页面多接口的渲染方式有多种： \n    \t-\t一是接口的串联，也就是一个接口返回的数据交作为参数给下一个接口去发送请求 ；\n    \t- 二是同时发送请求，根据接口返回的顺序渲染页面；\n    \t- 三是同时请求，等所有的接口返回之后再一次性进行渲染。\n\t- 上面的三种渲染方式，RACSignal都有相应的解决方案，假设这里页面渲染的方式选择的是依次渲染，那么我们使用 DKHTTPChainTool 的executeSignal()来写个例子\n\n```\n RACSignal *signalA = DKHTTPChainInstance.method(@\"POST\")\n                                         .url(@\"\")\n                                         .params(@{@\"did\":@\"1\",@\"page\":@\"1\",@\"num\":@\"100\"})\n                                         .executeSignal();\n\nRACSignal *signalB = DKHTTPChainInstance.method(@\"POST\")\n                                        .url(@\"\")\n                                        .params(@{@\"dis_id\":@\"9\"})\n                                        .executeSignal();\n\nRACSignal *signalC = DKHTTPChainInstance.method(@\"POST\")\n                                        .url(@\"\")\n                                        .params(@{@\"dis_id\":@\"9\"})\n                                        .executeSignal();\n\nRACSignal *mergeSignal = [RACSignal merge:@[signalA,signalB,signalC]];\n[mergeSignal subscribeNext:^(DKResponse *x){\n      DKLog(@\"%zd  %@\",x.taskIdentifier,x.rawData);\n}];\n```\n\n上面这个例子的结果会依次执行三个接口，并且按照接口返回的顺序执行mergeSignal 的 subscribeNext 的 block\n\n### 同时请求接口，等所有接口返回数据之后再进行渲染\n\n> 上面的三个 Signal就不重复写了\n\n```\nRACSignal *mergeSignal  = [RACSignal zip:@[signalA,signalB,signalC]];\n[mergeSignal subscribeNext:^(RACTuple *x){\n     [x.rac_sequence.signal subscribeNext:^(DKResponse *x) {\n         DKLog(@\"%@\",x.rawData);\n     }];\n}];\n```\n\n上面的 `mergeSignal` 里面会发送一个 `RACTuple` ,里面依次包装着三个请求 Signal的 `DKResponse`回调对象\n\n### 接口串联，上一个接口响应的数据作为下一个接口的参数\n\n```\n RACSignal *flattenSignal = [signalA flattenMap:^RACStream *(DKResponse *value) {\n        NSString *did = value.result[@\"content\"][0][@\"d_id\"];\n        return DKHTTPChainInstance.method(@\"GET\")\n                                 .url(@\"\")\n                                 .params(@{@\"did\":did,@\"page\":@\"1\",@\"num\":@\"20\"})\n                                 .executeSignal();\n}];\n[flattenSignal subscribeNext:^(DKResponse *x) {\n    DKLog(@\"%@\",x.rawData);\n}];\n```\n\n平时常用的大概就这么几个，待补充吧，之后我会继续讲讲关于异常处理的问题。","slug":"使用RAC-DKHTTPTool实践","published":1,"updated":"2021-04-12T06:07:04.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5u004845n00rxkb5wf","content":"<p>使用RAC+DKHTTP套件实践</p>\n<ul>\n<li>这次通过一个简单的例子来解说DKHTTP套件与 RAC 结合的使用</li>\n</ul>\n<span id=\"more\"></span>\n\n<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/444.png?raw=true\"></p>\n<ul>\n<li><p>首先简析下这个界面</p>\n<ul>\n<li>顶部搜索框部分的背景：广告栏位+图书推荐的图片，这里是一个获取图片的接口（接口 A）</li>\n<li>图书推荐： 这里也是一个接口，需要显示图书的封面（接口 B）</li>\n<li>笔记推荐： 这里也是一个接口，需要显示图书笔记的一些简介 （接口 C）</li>\n</ul>\n</li>\n<li><p>页面渲染</p>\n<ul>\n<li>同页面多接口的渲染方式有多种： <ul>\n<li>   一是接口的串联，也就是一个接口返回的数据交作为参数给下一个接口去发送请求 ；</li>\n<li>二是同时发送请求，根据接口返回的顺序渲染页面；</li>\n<li>三是同时请求，等所有的接口返回之后再一次性进行渲染。</li>\n</ul>\n</li>\n<li>上面的三种渲染方式，RACSignal都有相应的解决方案，假设这里页面渲染的方式选择的是依次渲染，那么我们使用 DKHTTPChainTool 的executeSignal()来写个例子</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> RACSignal *signalA &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                         .url(@&quot;&quot;)</span><br><span class=\"line\">                                         .params(@&#123;@&quot;did&quot;:@&quot;1&quot;,@&quot;page&quot;:@&quot;1&quot;,@&quot;num&quot;:@&quot;100&quot;&#125;)</span><br><span class=\"line\">                                         .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *signalB &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url(@&quot;&quot;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;dis_id&quot;:@&quot;9&quot;&#125;)</span><br><span class=\"line\">                                        .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *signalC &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url(@&quot;&quot;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;dis_id&quot;:@&quot;9&quot;&#125;)</span><br><span class=\"line\">                                        .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *mergeSignal &#x3D; [RACSignal merge:@[signalA,signalB,signalC]];</span><br><span class=\"line\">[mergeSignal subscribeNext:^(DKResponse *x)&#123;</span><br><span class=\"line\">      DKLog(@&quot;%zd  %@&quot;,x.taskIdentifier,x.rawData);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>上面这个例子的结果会依次执行三个接口，并且按照接口返回的顺序执行mergeSignal 的 subscribeNext 的 block</p>\n<h3 id=\"同时请求接口，等所有接口返回数据之后再进行渲染\"><a href=\"#同时请求接口，等所有接口返回数据之后再进行渲染\" class=\"headerlink\" title=\"同时请求接口，等所有接口返回数据之后再进行渲染\"></a>同时请求接口，等所有接口返回数据之后再进行渲染</h3><blockquote>\n<p>上面的三个 Signal就不重复写了</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *mergeSignal  &#x3D; [RACSignal zip:@[signalA,signalB,signalC]];</span><br><span class=\"line\">[mergeSignal subscribeNext:^(RACTuple *x)&#123;</span><br><span class=\"line\">     [x.rac_sequence.signal subscribeNext:^(DKResponse *x) &#123;</span><br><span class=\"line\">         DKLog(@&quot;%@&quot;,x.rawData);</span><br><span class=\"line\">     &#125;];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>上面的 <code>mergeSignal</code> 里面会发送一个 <code>RACTuple</code> ,里面依次包装着三个请求 Signal的 <code>DKResponse</code>回调对象</p>\n<h3 id=\"接口串联，上一个接口响应的数据作为下一个接口的参数\"><a href=\"#接口串联，上一个接口响应的数据作为下一个接口的参数\" class=\"headerlink\" title=\"接口串联，上一个接口响应的数据作为下一个接口的参数\"></a>接口串联，上一个接口响应的数据作为下一个接口的参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> RACSignal *flattenSignal &#x3D; [signalA flattenMap:^RACStream *(DKResponse *value) &#123;</span><br><span class=\"line\">        NSString *did &#x3D; value.result[@&quot;content&quot;][0][@&quot;d_id&quot;];</span><br><span class=\"line\">        return DKHTTPChainInstance.method(@&quot;GET&quot;)</span><br><span class=\"line\">                                 .url(@&quot;&quot;)</span><br><span class=\"line\">                                 .params(@&#123;@&quot;did&quot;:did,@&quot;page&quot;:@&quot;1&quot;,@&quot;num&quot;:@&quot;20&quot;&#125;)</span><br><span class=\"line\">                                 .executeSignal();</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">[flattenSignal subscribeNext:^(DKResponse *x) &#123;</span><br><span class=\"line\">    DKLog(@&quot;%@&quot;,x.rawData);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>平时常用的大概就这么几个，待补充吧，之后我会继续讲讲关于异常处理的问题。</p>\n","site":{"data":{}},"excerpt":"<p>使用RAC+DKHTTP套件实践</p>\n<ul>\n<li>这次通过一个简单的例子来解说DKHTTP套件与 RAC 结合的使用</li>\n</ul>","more":"<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/444.png?raw=true\"></p>\n<ul>\n<li><p>首先简析下这个界面</p>\n<ul>\n<li>顶部搜索框部分的背景：广告栏位+图书推荐的图片，这里是一个获取图片的接口（接口 A）</li>\n<li>图书推荐： 这里也是一个接口，需要显示图书的封面（接口 B）</li>\n<li>笔记推荐： 这里也是一个接口，需要显示图书笔记的一些简介 （接口 C）</li>\n</ul>\n</li>\n<li><p>页面渲染</p>\n<ul>\n<li>同页面多接口的渲染方式有多种： <ul>\n<li>   一是接口的串联，也就是一个接口返回的数据交作为参数给下一个接口去发送请求 ；</li>\n<li>二是同时发送请求，根据接口返回的顺序渲染页面；</li>\n<li>三是同时请求，等所有的接口返回之后再一次性进行渲染。</li>\n</ul>\n</li>\n<li>上面的三种渲染方式，RACSignal都有相应的解决方案，假设这里页面渲染的方式选择的是依次渲染，那么我们使用 DKHTTPChainTool 的executeSignal()来写个例子</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> RACSignal *signalA &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                         .url(@&quot;&quot;)</span><br><span class=\"line\">                                         .params(@&#123;@&quot;did&quot;:@&quot;1&quot;,@&quot;page&quot;:@&quot;1&quot;,@&quot;num&quot;:@&quot;100&quot;&#125;)</span><br><span class=\"line\">                                         .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *signalB &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url(@&quot;&quot;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;dis_id&quot;:@&quot;9&quot;&#125;)</span><br><span class=\"line\">                                        .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *signalC &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url(@&quot;&quot;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;dis_id&quot;:@&quot;9&quot;&#125;)</span><br><span class=\"line\">                                        .executeSignal();</span><br><span class=\"line\"></span><br><span class=\"line\">RACSignal *mergeSignal &#x3D; [RACSignal merge:@[signalA,signalB,signalC]];</span><br><span class=\"line\">[mergeSignal subscribeNext:^(DKResponse *x)&#123;</span><br><span class=\"line\">      DKLog(@&quot;%zd  %@&quot;,x.taskIdentifier,x.rawData);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>上面这个例子的结果会依次执行三个接口，并且按照接口返回的顺序执行mergeSignal 的 subscribeNext 的 block</p>\n<h3 id=\"同时请求接口，等所有接口返回数据之后再进行渲染\"><a href=\"#同时请求接口，等所有接口返回数据之后再进行渲染\" class=\"headerlink\" title=\"同时请求接口，等所有接口返回数据之后再进行渲染\"></a>同时请求接口，等所有接口返回数据之后再进行渲染</h3><blockquote>\n<p>上面的三个 Signal就不重复写了</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *mergeSignal  &#x3D; [RACSignal zip:@[signalA,signalB,signalC]];</span><br><span class=\"line\">[mergeSignal subscribeNext:^(RACTuple *x)&#123;</span><br><span class=\"line\">     [x.rac_sequence.signal subscribeNext:^(DKResponse *x) &#123;</span><br><span class=\"line\">         DKLog(@&quot;%@&quot;,x.rawData);</span><br><span class=\"line\">     &#125;];</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>上面的 <code>mergeSignal</code> 里面会发送一个 <code>RACTuple</code> ,里面依次包装着三个请求 Signal的 <code>DKResponse</code>回调对象</p>\n<h3 id=\"接口串联，上一个接口响应的数据作为下一个接口的参数\"><a href=\"#接口串联，上一个接口响应的数据作为下一个接口的参数\" class=\"headerlink\" title=\"接口串联，上一个接口响应的数据作为下一个接口的参数\"></a>接口串联，上一个接口响应的数据作为下一个接口的参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> RACSignal *flattenSignal &#x3D; [signalA flattenMap:^RACStream *(DKResponse *value) &#123;</span><br><span class=\"line\">        NSString *did &#x3D; value.result[@&quot;content&quot;][0][@&quot;d_id&quot;];</span><br><span class=\"line\">        return DKHTTPChainInstance.method(@&quot;GET&quot;)</span><br><span class=\"line\">                                 .url(@&quot;&quot;)</span><br><span class=\"line\">                                 .params(@&#123;@&quot;did&quot;:did,@&quot;page&quot;:@&quot;1&quot;,@&quot;num&quot;:@&quot;20&quot;&#125;)</span><br><span class=\"line\">                                 .executeSignal();</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">[flattenSignal subscribeNext:^(DKResponse *x) &#123;</span><br><span class=\"line\">    DKLog(@&quot;%@&quot;,x.rawData);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>平时常用的大概就这么几个，待补充吧，之后我会继续讲讲关于异常处理的问题。</p>"},{"title":"使用DKHTTPTool时的异常处理","author":"Arclin","abbrlink":"7daccd39","date":"2017-01-04T16:00:00.000Z","_content":"本文主要讲述的是在使用 DKHTTPTool 时，返回异常数据时的处理\n\n<!-- more -->\n\n如果是普通调用情况的话,也即是调用这个方法\n```\n- (NSInteger)requestForMethod:(NSString *)method\n                cacheStragety:(DKCacheStrategy)strategy\n                          url:(NSString *)URLString\n                       header:(NSDictionary *)header\n                       params:(NSDictionary *)params\n                       filter:(DKHTTPRequestFilterBlock)filterBlock\n                 verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock\n                responseBlock:(DKHTTPResponseBlock)block;\n```\n\n那么捕获异常只需要拿到回调中的DKResponse中的error属性即可\n\n如果是用链式调用的方法`RACSignal`回调的话，那么就得看情况了，如果你是用 `RACCommand` 去启用网络请求的话，那么记得 `RACCommand` 是用 `errors` 属性去存储错误信号的，如果你有多个 `RACCommand` 对象建议你在 `ViewModel` 里创建一个 `RACSubject` 去统一处理错误信号，然后你可以这么写`[[RACSignal merge:@[_addParamCommand.errors,_removeParamCommand.errors,_sendCommand.errors]] subscribe:self.errors];`\n\n如果你直接取得网络请求回调中的`RACSignal`对象的话 ，直接`subscribeError:`就可以得到`NSError`对象\n关于提示错误信息，从交互的角度上来讲，我觉得友好程度\n\n`TopBarMessage(TWMessageBarManager) > HUD > ALERT`\n\n当然实际运用的时候还是得看情况，不同情况使用不同的提示方式","source":"_posts/使用DKHTTPTool时的异常处理.md","raw":"---\ntitle: 使用DKHTTPTool时的异常处理\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 7daccd39\ndate: 2017-01-05 00:00:00\n---\n本文主要讲述的是在使用 DKHTTPTool 时，返回异常数据时的处理\n\n<!-- more -->\n\n如果是普通调用情况的话,也即是调用这个方法\n```\n- (NSInteger)requestForMethod:(NSString *)method\n                cacheStragety:(DKCacheStrategy)strategy\n                          url:(NSString *)URLString\n                       header:(NSDictionary *)header\n                       params:(NSDictionary *)params\n                       filter:(DKHTTPRequestFilterBlock)filterBlock\n                 verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock\n                responseBlock:(DKHTTPResponseBlock)block;\n```\n\n那么捕获异常只需要拿到回调中的DKResponse中的error属性即可\n\n如果是用链式调用的方法`RACSignal`回调的话，那么就得看情况了，如果你是用 `RACCommand` 去启用网络请求的话，那么记得 `RACCommand` 是用 `errors` 属性去存储错误信号的，如果你有多个 `RACCommand` 对象建议你在 `ViewModel` 里创建一个 `RACSubject` 去统一处理错误信号，然后你可以这么写`[[RACSignal merge:@[_addParamCommand.errors,_removeParamCommand.errors,_sendCommand.errors]] subscribe:self.errors];`\n\n如果你直接取得网络请求回调中的`RACSignal`对象的话 ，直接`subscribeError:`就可以得到`NSError`对象\n关于提示错误信息，从交互的角度上来讲，我觉得友好程度\n\n`TopBarMessage(TWMessageBarManager) > HUD > ALERT`\n\n当然实际运用的时候还是得看情况，不同情况使用不同的提示方式","slug":"使用DKHTTPTool时的异常处理","published":1,"updated":"2021-04-12T06:07:04.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5u004b45n02gy53dou","content":"<p>本文主要讲述的是在使用 DKHTTPTool 时，返回异常数据时的处理</p>\n<span id=\"more\"></span>\n\n<p>如果是普通调用情况的话,也即是调用这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method</span><br><span class=\"line\">                cacheStragety:(DKCacheStrategy)strategy</span><br><span class=\"line\">                          url:(NSString *)URLString</span><br><span class=\"line\">                       header:(NSDictionary *)header</span><br><span class=\"line\">                       params:(NSDictionary *)params</span><br><span class=\"line\">                       filter:(DKHTTPRequestFilterBlock)filterBlock</span><br><span class=\"line\">                 verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock</span><br><span class=\"line\">                responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n\n<p>那么捕获异常只需要拿到回调中的DKResponse中的error属性即可</p>\n<p>如果是用链式调用的方法<code>RACSignal</code>回调的话，那么就得看情况了，如果你是用 <code>RACCommand</code> 去启用网络请求的话，那么记得 <code>RACCommand</code> 是用 <code>errors</code> 属性去存储错误信号的，如果你有多个 <code>RACCommand</code> 对象建议你在 <code>ViewModel</code> 里创建一个 <code>RACSubject</code> 去统一处理错误信号，然后你可以这么写<code>[[RACSignal merge:@[_addParamCommand.errors,_removeParamCommand.errors,_sendCommand.errors]] subscribe:self.errors];</code></p>\n<p>如果你直接取得网络请求回调中的<code>RACSignal</code>对象的话 ，直接<code>subscribeError:</code>就可以得到<code>NSError</code>对象<br>关于提示错误信息，从交互的角度上来讲，我觉得友好程度</p>\n<p><code>TopBarMessage(TWMessageBarManager) &gt; HUD &gt; ALERT</code></p>\n<p>当然实际运用的时候还是得看情况，不同情况使用不同的提示方式</p>\n","site":{"data":{}},"excerpt":"<p>本文主要讲述的是在使用 DKHTTPTool 时，返回异常数据时的处理</p>","more":"<p>如果是普通调用情况的话,也即是调用这个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method</span><br><span class=\"line\">                cacheStragety:(DKCacheStrategy)strategy</span><br><span class=\"line\">                          url:(NSString *)URLString</span><br><span class=\"line\">                       header:(NSDictionary *)header</span><br><span class=\"line\">                       params:(NSDictionary *)params</span><br><span class=\"line\">                       filter:(DKHTTPRequestFilterBlock)filterBlock</span><br><span class=\"line\">                 verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock</span><br><span class=\"line\">                responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n\n<p>那么捕获异常只需要拿到回调中的DKResponse中的error属性即可</p>\n<p>如果是用链式调用的方法<code>RACSignal</code>回调的话，那么就得看情况了，如果你是用 <code>RACCommand</code> 去启用网络请求的话，那么记得 <code>RACCommand</code> 是用 <code>errors</code> 属性去存储错误信号的，如果你有多个 <code>RACCommand</code> 对象建议你在 <code>ViewModel</code> 里创建一个 <code>RACSubject</code> 去统一处理错误信号，然后你可以这么写<code>[[RACSignal merge:@[_addParamCommand.errors,_removeParamCommand.errors,_sendCommand.errors]] subscribe:self.errors];</code></p>\n<p>如果你直接取得网络请求回调中的<code>RACSignal</code>对象的话 ，直接<code>subscribeError:</code>就可以得到<code>NSError</code>对象<br>关于提示错误信息，从交互的角度上来讲，我觉得友好程度</p>\n<p><code>TopBarMessage(TWMessageBarManager) &gt; HUD &gt; ALERT</code></p>\n<p>当然实际运用的时候还是得看情况，不同情况使用不同的提示方式</p>"},{"title":"Jenkins+Git+Cocoapods+Fir.im实现iOS应用持续集成","author":"Arclin","abbrlink":"13ecfb47","date":"2017-02-07T16:00:00.000Z","_content":"Jenkins 可以定时检测 Git 上的某个分支的代码，打包生成 ipa 后直接上传到 Fir.im\n\n<!-- more -->\n\n### 安装 Jenkins\n\n#### JDK\nJenkins 是基于 Java 的一个应用，所以你需要先有JDK ，安装 JDK 网上有很多资料这里就跳过了\n\n使用 Brew 安装 Jenkins\n\n```\nbrew install jenkins\n```\n\n### 启动 Jenkins\n\n`jenkins` 或者 `java -jar /usr/local/opt/jenkins/libexec/jenkins.war --httpPort=8088` 这种方法可以指定端口号执行\n\n如果想自动启动，需要先执行以下命令，创建启动项\n`ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents`\n\n可以编辑一下`~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist`这个文件\n`open ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist`\n\n想要让局域网都可以访问，需要把`–httpListenAddress=127.0.0.1`改成自己的局域网IP\n\n手动启动启动项可以执行\n\n```\nlaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist\n```\n\n### 配置Xcode项目\n\n使用 CocoaPods\n终端进入已有项目的目录下，执行\n\n填写 podfile 类似下面这样子\n\n```\ntarget 'TestJenkins' do\n\tpod 'MJExtension'\n  target 'TestJenkinsTests' do\n    inherit! :search_paths\n  end\nend\n```\n\n然后执行 `pod install`\n\n执行完成之后打开`TestJenkins.xcworkspace`\n\n打开 `Product - Scheme - Manage Scheme`\n\n把 `Share` 下面的勾都打上\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/888.png)\n\n\n### 上传到Git\n在终端进入该项目根目录，执行`git init`\n\n在 Git托管平台上新建一个项目，得到 git 远程仓库地址，然后在项目中添加该远程地址\n\n`git remote add origin git@git.coding.net:Arclin/TestJenkins.git`\n\n新的项目或许还需要`git pull origin master` pull一下Readme等东西\n\n1. `git add . ` 添加项目文件\n2. `git git commit -m \"initial\"` 提交更改\n3. `git push origin master` 推送到 master远程分支\n\n### 配置 Jenkins\n\n在浏览器中打开 Jenkins,比如我指定了8088端口的话，那就打开`http://localhost:8088/`,然后根据提示安装，注意里面有一个选择插件的界面，根据需要选择就好。\n\n#### 安装插件\n系统管理 - 插件管理 可以安装插件,建议安装\n\n- Git Server Plugin  \n- Git Client Plugin  \n- fir-plugin  （安装教程看 http://www.jianshu.com/p/9a245918a219）\n- Xcode integration\n- Keychains and Provisioning Profiles Management\n\n下面我们就会用上这些插件\n\n#### 新建一个Job\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/999.png)\n\n进行一系列配置\n设置包的保留天数还有天数。\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1001.png)\n\n源码管理\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1002.png)\n\n要先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。\n\n![](http://upload-images.jianshu.io/upload_images/1194012-6d1b6f56e4dac318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n构建触发器\n构建触发器设置这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。\n\n不过这里有两个配置还是需要是配置的\n\nPoll SCM (poll source code management) 轮询源码管理\n需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次\nBuild periodically (定时build)\n一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。\n\n格式是这样的\n\n分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日)\n\n例如 `H/10 * * * *` 就是每十分钟一次\n\n#### 构建环境\niOS打包需要签名文件和证书，所以这部分我们勾选“Keychains and Code Signing Identities”和“Mobile Provisioning Profiles”。\n\n在这之前\n\n在系统设置中进入Keychains and Provisioning Profiles Management页面，点击“浏览”按钮，分别上传自己的keychain和证书（是这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下）。上传成功后，我们再为keychain指明签名文件的名称。点击“Add Code Signing Identity”，最后添加成功后如下图所示\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1003.png)\n\npassword 填写你的用户密码\n\nCode Signing Identity 的内容来源是这里\n\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_1.png?version=1&modificationDate=1375867279000)\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_2.png?version=2&modificationDate=1375868440000)\n\nProvision Profiles Directory Path 的内容填上\n\n`/Users/Shared/Jenkins/Library/MobileDevice`\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/Screen+Shot+2013-08-07+at+14.17.05.png?version=1&modificationDate=1375877888000)\n\n回到项目配置\n\n这样子填写\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1004.png)\n\n#### 构建\n点击”增加构建步骤”,先后选择 XCode 和 Execute Shell\n\nXCode 配置如下\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1005.png)\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1006.png)\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1007.png)\n\nExecute Shell 只要写入这个命令就好\n\n`fir publish /Users/Arclin/.jenkins/workspace/TestJenkins/build/TestJenkins.ipa --token=你的fir.im Token`\n\n如果没安装 fir 命令行工具的话\n\n用`gem install fir-cli` 安装\n如果发现问题就看这里\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1008.png)\n\n然后保存回到Jenkins项目首页，点击立即构建，然后如果成功的话就会像下图那样子\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1009.png)\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1010.png)\n\n每隔一个触发器设定的时间，他就会检查一下 git 上面的代码，如果有发现更新就会自动 pull然后打包并上传到 fir.im\n\n结束","source":"_posts/Jenkins-Git-CocoaPods-Fir-im实现iOS应用持续集成.md","raw":"---\ntitle: Jenkins+Git+Cocoapods+Fir.im实现iOS应用持续集成\nauthor: Arclin\ntags:\n  - Jenkins\n  - Git\n  - Cocoapods\n  - Fir\ncategories:\n  - iOS\nabbrlink: 13ecfb47\ndate: 2017-02-08 00:00:00\n---\nJenkins 可以定时检测 Git 上的某个分支的代码，打包生成 ipa 后直接上传到 Fir.im\n\n<!-- more -->\n\n### 安装 Jenkins\n\n#### JDK\nJenkins 是基于 Java 的一个应用，所以你需要先有JDK ，安装 JDK 网上有很多资料这里就跳过了\n\n使用 Brew 安装 Jenkins\n\n```\nbrew install jenkins\n```\n\n### 启动 Jenkins\n\n`jenkins` 或者 `java -jar /usr/local/opt/jenkins/libexec/jenkins.war --httpPort=8088` 这种方法可以指定端口号执行\n\n如果想自动启动，需要先执行以下命令，创建启动项\n`ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents`\n\n可以编辑一下`~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist`这个文件\n`open ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist`\n\n想要让局域网都可以访问，需要把`–httpListenAddress=127.0.0.1`改成自己的局域网IP\n\n手动启动启动项可以执行\n\n```\nlaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist\n```\n\n### 配置Xcode项目\n\n使用 CocoaPods\n终端进入已有项目的目录下，执行\n\n填写 podfile 类似下面这样子\n\n```\ntarget 'TestJenkins' do\n\tpod 'MJExtension'\n  target 'TestJenkinsTests' do\n    inherit! :search_paths\n  end\nend\n```\n\n然后执行 `pod install`\n\n执行完成之后打开`TestJenkins.xcworkspace`\n\n打开 `Product - Scheme - Manage Scheme`\n\n把 `Share` 下面的勾都打上\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/888.png)\n\n\n### 上传到Git\n在终端进入该项目根目录，执行`git init`\n\n在 Git托管平台上新建一个项目，得到 git 远程仓库地址，然后在项目中添加该远程地址\n\n`git remote add origin git@git.coding.net:Arclin/TestJenkins.git`\n\n新的项目或许还需要`git pull origin master` pull一下Readme等东西\n\n1. `git add . ` 添加项目文件\n2. `git git commit -m \"initial\"` 提交更改\n3. `git push origin master` 推送到 master远程分支\n\n### 配置 Jenkins\n\n在浏览器中打开 Jenkins,比如我指定了8088端口的话，那就打开`http://localhost:8088/`,然后根据提示安装，注意里面有一个选择插件的界面，根据需要选择就好。\n\n#### 安装插件\n系统管理 - 插件管理 可以安装插件,建议安装\n\n- Git Server Plugin  \n- Git Client Plugin  \n- fir-plugin  （安装教程看 http://www.jianshu.com/p/9a245918a219）\n- Xcode integration\n- Keychains and Provisioning Profiles Management\n\n下面我们就会用上这些插件\n\n#### 新建一个Job\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/999.png)\n\n进行一系列配置\n设置包的保留天数还有天数。\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1001.png)\n\n源码管理\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1002.png)\n\n要先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。\n\n![](http://upload-images.jianshu.io/upload_images/1194012-6d1b6f56e4dac318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n构建触发器\n构建触发器设置这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。\n\n不过这里有两个配置还是需要是配置的\n\nPoll SCM (poll source code management) 轮询源码管理\n需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次\nBuild periodically (定时build)\n一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。\n\n格式是这样的\n\n分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日)\n\n例如 `H/10 * * * *` 就是每十分钟一次\n\n#### 构建环境\niOS打包需要签名文件和证书，所以这部分我们勾选“Keychains and Code Signing Identities”和“Mobile Provisioning Profiles”。\n\n在这之前\n\n在系统设置中进入Keychains and Provisioning Profiles Management页面，点击“浏览”按钮，分别上传自己的keychain和证书（是这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下）。上传成功后，我们再为keychain指明签名文件的名称。点击“Add Code Signing Identity”，最后添加成功后如下图所示\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1003.png)\n\npassword 填写你的用户密码\n\nCode Signing Identity 的内容来源是这里\n\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_1.png?version=1&modificationDate=1375867279000)\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_2.png?version=2&modificationDate=1375868440000)\n\nProvision Profiles Directory Path 的内容填上\n\n`/Users/Shared/Jenkins/Library/MobileDevice`\n\n![](https://wiki.jenkins-ci.org/download/attachments/68386839/Screen+Shot+2013-08-07+at+14.17.05.png?version=1&modificationDate=1375877888000)\n\n回到项目配置\n\n这样子填写\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1004.png)\n\n#### 构建\n点击”增加构建步骤”,先后选择 XCode 和 Execute Shell\n\nXCode 配置如下\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1005.png)\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1006.png)\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1007.png)\n\nExecute Shell 只要写入这个命令就好\n\n`fir publish /Users/Arclin/.jenkins/workspace/TestJenkins/build/TestJenkins.ipa --token=你的fir.im Token`\n\n如果没安装 fir 命令行工具的话\n\n用`gem install fir-cli` 安装\n如果发现问题就看这里\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1008.png)\n\n然后保存回到Jenkins项目首页，点击立即构建，然后如果成功的话就会像下图那样子\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1009.png)\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1010.png)\n\n每隔一个触发器设定的时间，他就会检查一下 git 上面的代码，如果有发现更新就会自动 pull然后打包并上传到 fir.im\n\n结束","slug":"Jenkins-Git-CocoaPods-Fir-im实现iOS应用持续集成","published":1,"updated":"2021-04-19T02:15:44.349Z","_id":"cknndog5w004f45n06wb0eusi","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Jenkins 可以定时检测 Git 上的某个分支的代码，打包生成 ipa 后直接上传到 Fir.im</p>\n<span id=\"more\"></span>\n\n<h3 id=\"安装-Jenkins\"><a href=\"#安装-Jenkins\" class=\"headerlink\" title=\"安装 Jenkins\"></a>安装 Jenkins</h3><h4 id=\"JDK\"><a href=\"#JDK\" class=\"headerlink\" title=\"JDK\"></a>JDK</h4><p>Jenkins 是基于 Java 的一个应用，所以你需要先有JDK ，安装 JDK 网上有很多资料这里就跳过了</p>\n<p>使用 Brew 安装 Jenkins</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install jenkins</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动-Jenkins\"><a href=\"#启动-Jenkins\" class=\"headerlink\" title=\"启动 Jenkins\"></a>启动 Jenkins</h3><p><code>jenkins</code> 或者 <code>java -jar /usr/local/opt/jenkins/libexec/jenkins.war --httpPort=8088</code> 这种方法可以指定端口号执行</p>\n<p>如果想自动启动，需要先执行以下命令，创建启动项<br><code>ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents</code></p>\n<p>可以编辑一下<code>~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</code>这个文件<br><code>open ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</code></p>\n<p>想要让局域网都可以访问，需要把<code>–httpListenAddress=127.0.0.1</code>改成自己的局域网IP</p>\n<p>手动启动启动项可以执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">launchctl load ~&#x2F;Library&#x2F;LaunchAgents&#x2F;homebrew.mxcl.jenkins.plist</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置Xcode项目\"><a href=\"#配置Xcode项目\" class=\"headerlink\" title=\"配置Xcode项目\"></a>配置Xcode项目</h3><p>使用 CocoaPods<br>终端进入已有项目的目录下，执行</p>\n<p>填写 podfile 类似下面这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target &#39;TestJenkins&#39; do</span><br><span class=\"line\">\tpod &#39;MJExtension&#39;</span><br><span class=\"line\">  target &#39;TestJenkinsTests&#39; do</span><br><span class=\"line\">    inherit! :search_paths</span><br><span class=\"line\">  end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>然后执行 <code>pod install</code></p>\n<p>执行完成之后打开<code>TestJenkins.xcworkspace</code></p>\n<p>打开 <code>Product - Scheme - Manage Scheme</code></p>\n<p>把 <code>Share</code> 下面的勾都打上</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/888.png\"></p>\n<h3 id=\"上传到Git\"><a href=\"#上传到Git\" class=\"headerlink\" title=\"上传到Git\"></a>上传到Git</h3><p>在终端进入该项目根目录，执行<code>git init</code></p>\n<p>在 Git托管平台上新建一个项目，得到 git 远程仓库地址，然后在项目中添加该远程地址</p>\n<p><code>git remote add origin git@git.coding.net:Arclin/TestJenkins.git</code></p>\n<p>新的项目或许还需要<code>git pull origin master</code> pull一下Readme等东西</p>\n<ol>\n<li><code>git add . </code> 添加项目文件</li>\n<li><code>git git commit -m &quot;initial&quot;</code> 提交更改</li>\n<li><code>git push origin master</code> 推送到 master远程分支</li>\n</ol>\n<h3 id=\"配置-Jenkins\"><a href=\"#配置-Jenkins\" class=\"headerlink\" title=\"配置 Jenkins\"></a>配置 Jenkins</h3><p>在浏览器中打开 Jenkins,比如我指定了8088端口的话，那就打开<code>http://localhost:8088/</code>,然后根据提示安装，注意里面有一个选择插件的界面，根据需要选择就好。</p>\n<h4 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h4><p>系统管理 - 插件管理 可以安装插件,建议安装</p>\n<ul>\n<li>Git Server Plugin  </li>\n<li>Git Client Plugin  </li>\n<li>fir-plugin  （安装教程看 <a href=\"http://www.jianshu.com/p/9a245918a219%EF%BC%89\">http://www.jianshu.com/p/9a245918a219）</a></li>\n<li>Xcode integration</li>\n<li>Keychains and Provisioning Profiles Management</li>\n</ul>\n<p>下面我们就会用上这些插件</p>\n<h4 id=\"新建一个Job\"><a href=\"#新建一个Job\" class=\"headerlink\" title=\"新建一个Job\"></a>新建一个Job</h4><p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/999.png\"></p>\n<p>进行一系列配置<br>设置包的保留天数还有天数。</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1001.png\"></p>\n<p>源码管理</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1002.png\"></p>\n<p>要先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1194012-6d1b6f56e4dac318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>构建触发器<br>构建触发器设置这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。</p>\n<p>不过这里有两个配置还是需要是配置的</p>\n<p>Poll SCM (poll source code management) 轮询源码管理<br>需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次<br>Build periodically (定时build)<br>一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。</p>\n<p>格式是这样的</p>\n<p>分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日)</p>\n<p>例如 <code>H/10 * * * *</code> 就是每十分钟一次</p>\n<h4 id=\"构建环境\"><a href=\"#构建环境\" class=\"headerlink\" title=\"构建环境\"></a>构建环境</h4><p>iOS打包需要签名文件和证书，所以这部分我们勾选“Keychains and Code Signing Identities”和“Mobile Provisioning Profiles”。</p>\n<p>在这之前</p>\n<p>在系统设置中进入Keychains and Provisioning Profiles Management页面，点击“浏览”按钮，分别上传自己的keychain和证书（是这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下）。上传成功后，我们再为keychain指明签名文件的名称。点击“Add Code Signing Identity”，最后添加成功后如下图所示</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1003.png\"></p>\n<p>password 填写你的用户密码</p>\n<p>Code Signing Identity 的内容来源是这里</p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_1.png?version=1&modificationDate=1375867279000\"></p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_2.png?version=2&modificationDate=1375868440000\"></p>\n<p>Provision Profiles Directory Path 的内容填上</p>\n<p><code>/Users/Shared/Jenkins/Library/MobileDevice</code></p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/Screen+Shot+2013-08-07+at+14.17.05.png?version=1&modificationDate=1375877888000\"></p>\n<p>回到项目配置</p>\n<p>这样子填写</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1004.png\"></p>\n<h4 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h4><p>点击”增加构建步骤”,先后选择 XCode 和 Execute Shell</p>\n<p>XCode 配置如下</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1005.png\"><br><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1006.png\"><br><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1007.png\"></p>\n<p>Execute Shell 只要写入这个命令就好</p>\n<p><code>fir publish /Users/Arclin/.jenkins/workspace/TestJenkins/build/TestJenkins.ipa --token=你的fir.im Token</code></p>\n<p>如果没安装 fir 命令行工具的话</p>\n<p>用<code>gem install fir-cli</code> 安装<br>如果发现问题就看这里</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1008.png\"></p>\n<p>然后保存回到Jenkins项目首页，点击立即构建，然后如果成功的话就会像下图那样子</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1009.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1010.png\"></p>\n<p>每隔一个触发器设定的时间，他就会检查一下 git 上面的代码，如果有发现更新就会自动 pull然后打包并上传到 fir.im</p>\n<p>结束</p>\n","site":{"data":{}},"excerpt":"<p>Jenkins 可以定时检测 Git 上的某个分支的代码，打包生成 ipa 后直接上传到 Fir.im</p>","more":"<h3 id=\"安装-Jenkins\"><a href=\"#安装-Jenkins\" class=\"headerlink\" title=\"安装 Jenkins\"></a>安装 Jenkins</h3><h4 id=\"JDK\"><a href=\"#JDK\" class=\"headerlink\" title=\"JDK\"></a>JDK</h4><p>Jenkins 是基于 Java 的一个应用，所以你需要先有JDK ，安装 JDK 网上有很多资料这里就跳过了</p>\n<p>使用 Brew 安装 Jenkins</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install jenkins</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"启动-Jenkins\"><a href=\"#启动-Jenkins\" class=\"headerlink\" title=\"启动 Jenkins\"></a>启动 Jenkins</h3><p><code>jenkins</code> 或者 <code>java -jar /usr/local/opt/jenkins/libexec/jenkins.war --httpPort=8088</code> 这种方法可以指定端口号执行</p>\n<p>如果想自动启动，需要先执行以下命令，创建启动项<br><code>ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents</code></p>\n<p>可以编辑一下<code>~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</code>这个文件<br><code>open ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</code></p>\n<p>想要让局域网都可以访问，需要把<code>–httpListenAddress=127.0.0.1</code>改成自己的局域网IP</p>\n<p>手动启动启动项可以执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">launchctl load ~&#x2F;Library&#x2F;LaunchAgents&#x2F;homebrew.mxcl.jenkins.plist</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置Xcode项目\"><a href=\"#配置Xcode项目\" class=\"headerlink\" title=\"配置Xcode项目\"></a>配置Xcode项目</h3><p>使用 CocoaPods<br>终端进入已有项目的目录下，执行</p>\n<p>填写 podfile 类似下面这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target &#39;TestJenkins&#39; do</span><br><span class=\"line\">\tpod &#39;MJExtension&#39;</span><br><span class=\"line\">  target &#39;TestJenkinsTests&#39; do</span><br><span class=\"line\">    inherit! :search_paths</span><br><span class=\"line\">  end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>然后执行 <code>pod install</code></p>\n<p>执行完成之后打开<code>TestJenkins.xcworkspace</code></p>\n<p>打开 <code>Product - Scheme - Manage Scheme</code></p>\n<p>把 <code>Share</code> 下面的勾都打上</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/888.png\"></p>\n<h3 id=\"上传到Git\"><a href=\"#上传到Git\" class=\"headerlink\" title=\"上传到Git\"></a>上传到Git</h3><p>在终端进入该项目根目录，执行<code>git init</code></p>\n<p>在 Git托管平台上新建一个项目，得到 git 远程仓库地址，然后在项目中添加该远程地址</p>\n<p><code>git remote add origin git@git.coding.net:Arclin/TestJenkins.git</code></p>\n<p>新的项目或许还需要<code>git pull origin master</code> pull一下Readme等东西</p>\n<ol>\n<li><code>git add . </code> 添加项目文件</li>\n<li><code>git git commit -m &quot;initial&quot;</code> 提交更改</li>\n<li><code>git push origin master</code> 推送到 master远程分支</li>\n</ol>\n<h3 id=\"配置-Jenkins\"><a href=\"#配置-Jenkins\" class=\"headerlink\" title=\"配置 Jenkins\"></a>配置 Jenkins</h3><p>在浏览器中打开 Jenkins,比如我指定了8088端口的话，那就打开<code>http://localhost:8088/</code>,然后根据提示安装，注意里面有一个选择插件的界面，根据需要选择就好。</p>\n<h4 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h4><p>系统管理 - 插件管理 可以安装插件,建议安装</p>\n<ul>\n<li>Git Server Plugin  </li>\n<li>Git Client Plugin  </li>\n<li>fir-plugin  （安装教程看 <a href=\"http://www.jianshu.com/p/9a245918a219%EF%BC%89\">http://www.jianshu.com/p/9a245918a219）</a></li>\n<li>Xcode integration</li>\n<li>Keychains and Provisioning Profiles Management</li>\n</ul>\n<p>下面我们就会用上这些插件</p>\n<h4 id=\"新建一个Job\"><a href=\"#新建一个Job\" class=\"headerlink\" title=\"新建一个Job\"></a>新建一个Job</h4><p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/999.png\"></p>\n<p>进行一系列配置<br>设置包的保留天数还有天数。</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1001.png\"></p>\n<p>源码管理</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1002.png\"></p>\n<p>要先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1194012-6d1b6f56e4dac318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"></p>\n<p>构建触发器<br>构建触发器设置这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。</p>\n<p>不过这里有两个配置还是需要是配置的</p>\n<p>Poll SCM (poll source code management) 轮询源码管理<br>需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次<br>Build periodically (定时build)<br>一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。</p>\n<p>格式是这样的</p>\n<p>分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日)</p>\n<p>例如 <code>H/10 * * * *</code> 就是每十分钟一次</p>\n<h4 id=\"构建环境\"><a href=\"#构建环境\" class=\"headerlink\" title=\"构建环境\"></a>构建环境</h4><p>iOS打包需要签名文件和证书，所以这部分我们勾选“Keychains and Code Signing Identities”和“Mobile Provisioning Profiles”。</p>\n<p>在这之前</p>\n<p>在系统设置中进入Keychains and Provisioning Profiles Management页面，点击“浏览”按钮，分别上传自己的keychain和证书（是这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下）。上传成功后，我们再为keychain指明签名文件的名称。点击“Add Code Signing Identity”，最后添加成功后如下图所示</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1003.png\"></p>\n<p>password 填写你的用户密码</p>\n<p>Code Signing Identity 的内容来源是这里</p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_1.png?version=1&modificationDate=1375867279000\"></p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_2.png?version=2&modificationDate=1375868440000\"></p>\n<p>Provision Profiles Directory Path 的内容填上</p>\n<p><code>/Users/Shared/Jenkins/Library/MobileDevice</code></p>\n<p><img src=\"https://wiki.jenkins-ci.org/download/attachments/68386839/Screen+Shot+2013-08-07+at+14.17.05.png?version=1&modificationDate=1375877888000\"></p>\n<p>回到项目配置</p>\n<p>这样子填写</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1004.png\"></p>\n<h4 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h4><p>点击”增加构建步骤”,先后选择 XCode 和 Execute Shell</p>\n<p>XCode 配置如下</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1005.png\"><br><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1006.png\"><br><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1007.png\"></p>\n<p>Execute Shell 只要写入这个命令就好</p>\n<p><code>fir publish /Users/Arclin/.jenkins/workspace/TestJenkins/build/TestJenkins.ipa --token=你的fir.im Token</code></p>\n<p>如果没安装 fir 命令行工具的话</p>\n<p>用<code>gem install fir-cli</code> 安装<br>如果发现问题就看这里</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1008.png\"></p>\n<p>然后保存回到Jenkins项目首页，点击立即构建，然后如果成功的话就会像下图那样子</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1009.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1010.png\"></p>\n<p>每隔一个触发器设定的时间，他就会检查一下 git 上面的代码，如果有发现更新就会自动 pull然后打包并上传到 fir.im</p>\n<p>结束</p>"},{"title":"关于App混合开发的介绍","author":"Arclin","abbrlink":"b179ff40","date":"2017-03-13T16:00:00.000Z","_content":"![](https://ooo.0o0.ooo/2017/03/14/58c75bfb373da.png)\n\n### 前言\n\nHybrid App 混合开发意思是在web-app、native-app这两者之间的app开发,兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”, 并且也方便我们进行热修复.\n\n<!-- more -->\n\n> 跨平台就是你写一套代码,然后iOS和Android都能用,这样子可以大大节省人力成本和开发成本\n\n> 热修复就是应用发布之后你还可以通过下发补丁或者直接修改web部分代码去修改app的内容,由于iOS版本应用要上传到应用市场需要经过严格的审核,这将会花费很多时间,如果每次项目一有点小问题就重新发布上架,这将会是一场灾难,所以app的热修复技术在iOS中显得尤为重要\n\n目前比较流行的有Cordova/PhoneGap,HTML 5+,React Native,Weex,AppCan(因为这个平台在很多地方吐槽很严重所以暂时不讨论),接下来我们一个个地讨论这些开发框架.\n\n### Cordova/PhoneGap\t\n\n![Cordova logo](https://ooo.0o0.ooo/2017/03/14/58c7511a7b3cf.png)\n\n[Cordova 官网](http://cordova.apache.org/)\n\n#### 介绍\n为什么这两个要放在一起呢,因为PhoneGap被Adobe收购了,临走之前把核心代码给了Apache,Apache就把这个项目名作Cordova,所以说PhoneGap和Cordova出自同一家,他们都会被开源社区和Adobe所推动.\n\n这个框架是作为原生与web之间的中间件,它采用插件的形式调用原生模块,最后成品就是原生页面和web页面的一个混合应用,现在是一个为大多数混合应用所采用的框架,拥有广大的前景\n\n#### 优点\n用相对简单,学习成本低,对于不熟悉原生开发的前端工程师来说是不错的选择.\n\n#### 缺点\n说实话这个并不是Cordova的缺点,而是web应用共有的问题,就是页面响应迟钝和操作体验不佳的问题.但是这些问题在现在也已经有了足够多的解决方案,具体想了解可以自行上网查阅.\n\n### HTML 5+\n\n![HTML5+ logo](https://ooo.0o0.ooo/2017/03/14/58c7511a6ebea.png)\n\n[官方文档](http://ask.dcloud.net.cn/docs/)\n\n#### 介绍\nDCloud和H5中国产业联盟发起的项目,使用H5+框架自带的各种方法去进行与原生模块之间的沟通,结果产出的依然是web页面,但是\u0007性能相对比Cordova好.\n\n#### 优点\n上手简单,学习成本低,有完整的中文文档,作为移动端webView上的框架体验是很不错的,前端人员可以优先考虑使用这个框架.\n\n#### 缺点\n貌似国外基本没人知道这东西,第三方插件和资源相对较少,要是遇到问题也只能去dcloud社区里面找,stackoverflow是帮不到你的啦,而且就目前看来框架自带的bug还是有的.\n\n### ReactNative\n\n![ReactNative logo](https://ooo.0o0.ooo/2017/03/14/58c7511a63fec.jpg)\n\n[中文官网](http://reactnative.cn/)\n\n#### 介绍\nFacebook 发布的一个混合开发框架,使用ES5/ES6语法,通过ReactNative自带的框架去调用原生模块,但重点是他虽然写的是前端语言,JSX和ES5/ES6但是可以经过构建渲染,将DOM元素转为原生元素,也就是使用前端语言开发原生app已成为现实,既能保留原生的体验又能体现出跨平台和热修复的优势,所以近两年来这个框架十分火.\n\n#### 优点\n既有原生的体验,又能做到跨平台,虽然加载速度还是比纯原生慢一点,但是这个差距已经能达到毫秒级,基本不影响体验,目前像支付宝,手机QQ,淘宝 都已经在部分模块使用了React Native框架,市场前景广阔,拥有丰富的资料.\n\n#### 缺点\n因为这个框架还出现不久,目前还是0.x版本阶段,有部分原生模块还没有接入,只能等他更新\n\n需要一定的学习成本,如果你说你是个会HTML和CSS的前端工程师,那不好意思你还是从入门教程开始看吧╮(╯_╰)╭\n\n### Weex\n\n\n官网 … 额… 没官网..只有一个[论坛](http://www.weex.help/)\n\n#### 介绍\n阿里爸爸推出的跟ReactNative差不多的框架,所以介绍就跟上面差不多,其实我并不是很熟悉这个框架,而且这个框架是16年4月阿里才开放出来内测的,现在支持的原生元素还是不多,现在一年过去了感觉没引起多大关注,如果你学过Vue,那么这个框架你可能会比较好上手\n\n总之阿里爸爸推出了这个轮子还是很吊的.之后说不定会一鸣惊人呢?\n\n### AppCan\n\n[官网](http://www.appcan.cn/)\n\n#### 介绍\n国内的混合开发框架\n\n_(´ཀ`」 ∠) 这个东西是基于他们服务器运行的,所以说如果他们的服务器跪了,你的app就跪了,当然如果你是付费用户,他们就会很快地帮你处理.他们有自己的开发IDE,产出的是也是webView页面,这里就不过多介绍了,具体可以看他们官网.\n\n### 关于热修复\n前言就讲了热修复是啥东西,然后说说最近发生的一件事\n\n今年的三八妇女节那天,苹果发了邮件给使用了热修复的开发者,说你们在应用商店上面的app里面有使用了热修复框架,希望你们以后不要用,因为这会违反什么吧啦吧啦协议条款,然后一群不是很懂英文的程序员就猜来猜去,就说苹果不让用热修复了,JSPatch不能用了啊,ReactNative药丸啊╮(╯_╰)╭,我在V2看到的最多的就是iOS开发者的欢呼23333,感觉真是世态炎凉,原生的优势已经得通过保护才能体现了吗?\n\n嘛.认真看看邮件,苹果是说你们不能用热修复的手段去改变app的功能,像是调用runtime底层方法之类的,就比如说你这个功能本来是显示一个公司的产品展示的的,但是你通过了应用审核之后,远程下发补丁,然后一打开app就弹出一大堆广告,那这样子肯定是违反协议的,当然你用JSPatch的方式你想做啥就做啥,显然不是很好,所以现在JSPatch官方也说近期不要用(前几天我更新了一个app的新版本,没有移除JSPatch,居然也过审了???),但是RN框架是不会做这些事情的,收到邮件的RN开发者大多是因为里面用了Code Push或Expo之类的第三方.\n\n那结论就是,JSPatch不给用了,那也许大家会更倾向于RN或者web方案,所以近期RN的发展应该会更加迅速,反正无论如何,大家尝到热修复的甜头,肯定不会就此罢休.\n\n---\n\n文: Arclin\n\n2017.03.14","source":"_posts/关于App混合开发的介绍.md","raw":"---\ntitle: 关于App混合开发的介绍\nauthor: Arclin\ntags:\n  - React Native\n  - Cordova\n  - AppCan\n  - Weex\n  - HTML5+\ncategories:\n  - 杂谈\nabbrlink: b179ff40\ndate: 2017-03-14 00:00:00\n---\n![](https://ooo.0o0.ooo/2017/03/14/58c75bfb373da.png)\n\n### 前言\n\nHybrid App 混合开发意思是在web-app、native-app这两者之间的app开发,兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”, 并且也方便我们进行热修复.\n\n<!-- more -->\n\n> 跨平台就是你写一套代码,然后iOS和Android都能用,这样子可以大大节省人力成本和开发成本\n\n> 热修复就是应用发布之后你还可以通过下发补丁或者直接修改web部分代码去修改app的内容,由于iOS版本应用要上传到应用市场需要经过严格的审核,这将会花费很多时间,如果每次项目一有点小问题就重新发布上架,这将会是一场灾难,所以app的热修复技术在iOS中显得尤为重要\n\n目前比较流行的有Cordova/PhoneGap,HTML 5+,React Native,Weex,AppCan(因为这个平台在很多地方吐槽很严重所以暂时不讨论),接下来我们一个个地讨论这些开发框架.\n\n### Cordova/PhoneGap\t\n\n![Cordova logo](https://ooo.0o0.ooo/2017/03/14/58c7511a7b3cf.png)\n\n[Cordova 官网](http://cordova.apache.org/)\n\n#### 介绍\n为什么这两个要放在一起呢,因为PhoneGap被Adobe收购了,临走之前把核心代码给了Apache,Apache就把这个项目名作Cordova,所以说PhoneGap和Cordova出自同一家,他们都会被开源社区和Adobe所推动.\n\n这个框架是作为原生与web之间的中间件,它采用插件的形式调用原生模块,最后成品就是原生页面和web页面的一个混合应用,现在是一个为大多数混合应用所采用的框架,拥有广大的前景\n\n#### 优点\n用相对简单,学习成本低,对于不熟悉原生开发的前端工程师来说是不错的选择.\n\n#### 缺点\n说实话这个并不是Cordova的缺点,而是web应用共有的问题,就是页面响应迟钝和操作体验不佳的问题.但是这些问题在现在也已经有了足够多的解决方案,具体想了解可以自行上网查阅.\n\n### HTML 5+\n\n![HTML5+ logo](https://ooo.0o0.ooo/2017/03/14/58c7511a6ebea.png)\n\n[官方文档](http://ask.dcloud.net.cn/docs/)\n\n#### 介绍\nDCloud和H5中国产业联盟发起的项目,使用H5+框架自带的各种方法去进行与原生模块之间的沟通,结果产出的依然是web页面,但是\u0007性能相对比Cordova好.\n\n#### 优点\n上手简单,学习成本低,有完整的中文文档,作为移动端webView上的框架体验是很不错的,前端人员可以优先考虑使用这个框架.\n\n#### 缺点\n貌似国外基本没人知道这东西,第三方插件和资源相对较少,要是遇到问题也只能去dcloud社区里面找,stackoverflow是帮不到你的啦,而且就目前看来框架自带的bug还是有的.\n\n### ReactNative\n\n![ReactNative logo](https://ooo.0o0.ooo/2017/03/14/58c7511a63fec.jpg)\n\n[中文官网](http://reactnative.cn/)\n\n#### 介绍\nFacebook 发布的一个混合开发框架,使用ES5/ES6语法,通过ReactNative自带的框架去调用原生模块,但重点是他虽然写的是前端语言,JSX和ES5/ES6但是可以经过构建渲染,将DOM元素转为原生元素,也就是使用前端语言开发原生app已成为现实,既能保留原生的体验又能体现出跨平台和热修复的优势,所以近两年来这个框架十分火.\n\n#### 优点\n既有原生的体验,又能做到跨平台,虽然加载速度还是比纯原生慢一点,但是这个差距已经能达到毫秒级,基本不影响体验,目前像支付宝,手机QQ,淘宝 都已经在部分模块使用了React Native框架,市场前景广阔,拥有丰富的资料.\n\n#### 缺点\n因为这个框架还出现不久,目前还是0.x版本阶段,有部分原生模块还没有接入,只能等他更新\n\n需要一定的学习成本,如果你说你是个会HTML和CSS的前端工程师,那不好意思你还是从入门教程开始看吧╮(╯_╰)╭\n\n### Weex\n\n\n官网 … 额… 没官网..只有一个[论坛](http://www.weex.help/)\n\n#### 介绍\n阿里爸爸推出的跟ReactNative差不多的框架,所以介绍就跟上面差不多,其实我并不是很熟悉这个框架,而且这个框架是16年4月阿里才开放出来内测的,现在支持的原生元素还是不多,现在一年过去了感觉没引起多大关注,如果你学过Vue,那么这个框架你可能会比较好上手\n\n总之阿里爸爸推出了这个轮子还是很吊的.之后说不定会一鸣惊人呢?\n\n### AppCan\n\n[官网](http://www.appcan.cn/)\n\n#### 介绍\n国内的混合开发框架\n\n_(´ཀ`」 ∠) 这个东西是基于他们服务器运行的,所以说如果他们的服务器跪了,你的app就跪了,当然如果你是付费用户,他们就会很快地帮你处理.他们有自己的开发IDE,产出的是也是webView页面,这里就不过多介绍了,具体可以看他们官网.\n\n### 关于热修复\n前言就讲了热修复是啥东西,然后说说最近发生的一件事\n\n今年的三八妇女节那天,苹果发了邮件给使用了热修复的开发者,说你们在应用商店上面的app里面有使用了热修复框架,希望你们以后不要用,因为这会违反什么吧啦吧啦协议条款,然后一群不是很懂英文的程序员就猜来猜去,就说苹果不让用热修复了,JSPatch不能用了啊,ReactNative药丸啊╮(╯_╰)╭,我在V2看到的最多的就是iOS开发者的欢呼23333,感觉真是世态炎凉,原生的优势已经得通过保护才能体现了吗?\n\n嘛.认真看看邮件,苹果是说你们不能用热修复的手段去改变app的功能,像是调用runtime底层方法之类的,就比如说你这个功能本来是显示一个公司的产品展示的的,但是你通过了应用审核之后,远程下发补丁,然后一打开app就弹出一大堆广告,那这样子肯定是违反协议的,当然你用JSPatch的方式你想做啥就做啥,显然不是很好,所以现在JSPatch官方也说近期不要用(前几天我更新了一个app的新版本,没有移除JSPatch,居然也过审了???),但是RN框架是不会做这些事情的,收到邮件的RN开发者大多是因为里面用了Code Push或Expo之类的第三方.\n\n那结论就是,JSPatch不给用了,那也许大家会更倾向于RN或者web方案,所以近期RN的发展应该会更加迅速,反正无论如何,大家尝到热修复的甜头,肯定不会就此罢休.\n\n---\n\n文: Arclin\n\n2017.03.14","slug":"关于App混合开发的介绍","published":1,"updated":"2021-04-12T06:07:04.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5y004i45n0frht3bgc","content":"<p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c75bfb373da.png\"></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Hybrid App 混合开发意思是在web-app、native-app这两者之间的app开发,兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”, 并且也方便我们进行热修复.</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>跨平台就是你写一套代码,然后iOS和Android都能用,这样子可以大大节省人力成本和开发成本</p>\n</blockquote>\n<blockquote>\n<p>热修复就是应用发布之后你还可以通过下发补丁或者直接修改web部分代码去修改app的内容,由于iOS版本应用要上传到应用市场需要经过严格的审核,这将会花费很多时间,如果每次项目一有点小问题就重新发布上架,这将会是一场灾难,所以app的热修复技术在iOS中显得尤为重要</p>\n</blockquote>\n<p>目前比较流行的有Cordova/PhoneGap,HTML 5+,React Native,Weex,AppCan(因为这个平台在很多地方吐槽很严重所以暂时不讨论),接下来我们一个个地讨论这些开发框架.</p>\n<h3 id=\"Cordova-PhoneGap\"><a href=\"#Cordova-PhoneGap\" class=\"headerlink\" title=\"Cordova/PhoneGap\"></a>Cordova/PhoneGap</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a7b3cf.png\" alt=\"Cordova logo\"></p>\n<p><a href=\"http://cordova.apache.org/\">Cordova 官网</a></p>\n<h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>为什么这两个要放在一起呢,因为PhoneGap被Adobe收购了,临走之前把核心代码给了Apache,Apache就把这个项目名作Cordova,所以说PhoneGap和Cordova出自同一家,他们都会被开源社区和Adobe所推动.</p>\n<p>这个框架是作为原生与web之间的中间件,它采用插件的形式调用原生模块,最后成品就是原生页面和web页面的一个混合应用,现在是一个为大多数混合应用所采用的框架,拥有广大的前景</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>用相对简单,学习成本低,对于不熟悉原生开发的前端工程师来说是不错的选择.</p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>说实话这个并不是Cordova的缺点,而是web应用共有的问题,就是页面响应迟钝和操作体验不佳的问题.但是这些问题在现在也已经有了足够多的解决方案,具体想了解可以自行上网查阅.</p>\n<h3 id=\"HTML-5\"><a href=\"#HTML-5\" class=\"headerlink\" title=\"HTML 5+\"></a>HTML 5+</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a6ebea.png\" alt=\"HTML5+ logo\"></p>\n<p><a href=\"http://ask.dcloud.net.cn/docs/\">官方文档</a></p>\n<h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>DCloud和H5中国产业联盟发起的项目,使用H5+框架自带的各种方法去进行与原生模块之间的沟通,结果产出的依然是web页面,但是\u0007性能相对比Cordova好.</p>\n<h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>上手简单,学习成本低,有完整的中文文档,作为移动端webView上的框架体验是很不错的,前端人员可以优先考虑使用这个框架.</p>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>貌似国外基本没人知道这东西,第三方插件和资源相对较少,要是遇到问题也只能去dcloud社区里面找,stackoverflow是帮不到你的啦,而且就目前看来框架自带的bug还是有的.</p>\n<h3 id=\"ReactNative\"><a href=\"#ReactNative\" class=\"headerlink\" title=\"ReactNative\"></a>ReactNative</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a63fec.jpg\" alt=\"ReactNative logo\"></p>\n<p><a href=\"http://reactnative.cn/\">中文官网</a></p>\n<h4 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>Facebook 发布的一个混合开发框架,使用ES5/ES6语法,通过ReactNative自带的框架去调用原生模块,但重点是他虽然写的是前端语言,JSX和ES5/ES6但是可以经过构建渲染,将DOM元素转为原生元素,也就是使用前端语言开发原生app已成为现实,既能保留原生的体验又能体现出跨平台和热修复的优势,所以近两年来这个框架十分火.</p>\n<h4 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>既有原生的体验,又能做到跨平台,虽然加载速度还是比纯原生慢一点,但是这个差距已经能达到毫秒级,基本不影响体验,目前像支付宝,手机QQ,淘宝 都已经在部分模块使用了React Native框架,市场前景广阔,拥有丰富的资料.</p>\n<h4 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>因为这个框架还出现不久,目前还是0.x版本阶段,有部分原生模块还没有接入,只能等他更新</p>\n<p>需要一定的学习成本,如果你说你是个会HTML和CSS的前端工程师,那不好意思你还是从入门教程开始看吧╮(╯_╰)╭</p>\n<h3 id=\"Weex\"><a href=\"#Weex\" class=\"headerlink\" title=\"Weex\"></a>Weex</h3><p>官网 … 额… 没官网..只有一个<a href=\"http://www.weex.help/\">论坛</a></p>\n<h4 id=\"介绍-3\"><a href=\"#介绍-3\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>阿里爸爸推出的跟ReactNative差不多的框架,所以介绍就跟上面差不多,其实我并不是很熟悉这个框架,而且这个框架是16年4月阿里才开放出来内测的,现在支持的原生元素还是不多,现在一年过去了感觉没引起多大关注,如果你学过Vue,那么这个框架你可能会比较好上手</p>\n<p>总之阿里爸爸推出了这个轮子还是很吊的.之后说不定会一鸣惊人呢?</p>\n<h3 id=\"AppCan\"><a href=\"#AppCan\" class=\"headerlink\" title=\"AppCan\"></a>AppCan</h3><p><a href=\"http://www.appcan.cn/\">官网</a></p>\n<h4 id=\"介绍-4\"><a href=\"#介绍-4\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>国内的混合开发框架</p>\n<p>_(´ཀ`」 ∠) 这个东西是基于他们服务器运行的,所以说如果他们的服务器跪了,你的app就跪了,当然如果你是付费用户,他们就会很快地帮你处理.他们有自己的开发IDE,产出的是也是webView页面,这里就不过多介绍了,具体可以看他们官网.</p>\n<h3 id=\"关于热修复\"><a href=\"#关于热修复\" class=\"headerlink\" title=\"关于热修复\"></a>关于热修复</h3><p>前言就讲了热修复是啥东西,然后说说最近发生的一件事</p>\n<p>今年的三八妇女节那天,苹果发了邮件给使用了热修复的开发者,说你们在应用商店上面的app里面有使用了热修复框架,希望你们以后不要用,因为这会违反什么吧啦吧啦协议条款,然后一群不是很懂英文的程序员就猜来猜去,就说苹果不让用热修复了,JSPatch不能用了啊,ReactNative药丸啊╮(╯_╰)╭,我在V2看到的最多的就是iOS开发者的欢呼23333,感觉真是世态炎凉,原生的优势已经得通过保护才能体现了吗?</p>\n<p>嘛.认真看看邮件,苹果是说你们不能用热修复的手段去改变app的功能,像是调用runtime底层方法之类的,就比如说你这个功能本来是显示一个公司的产品展示的的,但是你通过了应用审核之后,远程下发补丁,然后一打开app就弹出一大堆广告,那这样子肯定是违反协议的,当然你用JSPatch的方式你想做啥就做啥,显然不是很好,所以现在JSPatch官方也说近期不要用(前几天我更新了一个app的新版本,没有移除JSPatch,居然也过审了???),但是RN框架是不会做这些事情的,收到邮件的RN开发者大多是因为里面用了Code Push或Expo之类的第三方.</p>\n<p>那结论就是,JSPatch不给用了,那也许大家会更倾向于RN或者web方案,所以近期RN的发展应该会更加迅速,反正无论如何,大家尝到热修复的甜头,肯定不会就此罢休.</p>\n<hr>\n<p>文: Arclin</p>\n<p>2017.03.14</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c75bfb373da.png\"></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>Hybrid App 混合开发意思是在web-app、native-app这两者之间的app开发,兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”, 并且也方便我们进行热修复.</p>","more":"<blockquote>\n<p>跨平台就是你写一套代码,然后iOS和Android都能用,这样子可以大大节省人力成本和开发成本</p>\n</blockquote>\n<blockquote>\n<p>热修复就是应用发布之后你还可以通过下发补丁或者直接修改web部分代码去修改app的内容,由于iOS版本应用要上传到应用市场需要经过严格的审核,这将会花费很多时间,如果每次项目一有点小问题就重新发布上架,这将会是一场灾难,所以app的热修复技术在iOS中显得尤为重要</p>\n</blockquote>\n<p>目前比较流行的有Cordova/PhoneGap,HTML 5+,React Native,Weex,AppCan(因为这个平台在很多地方吐槽很严重所以暂时不讨论),接下来我们一个个地讨论这些开发框架.</p>\n<h3 id=\"Cordova-PhoneGap\"><a href=\"#Cordova-PhoneGap\" class=\"headerlink\" title=\"Cordova/PhoneGap\"></a>Cordova/PhoneGap</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a7b3cf.png\" alt=\"Cordova logo\"></p>\n<p><a href=\"http://cordova.apache.org/\">Cordova 官网</a></p>\n<h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>为什么这两个要放在一起呢,因为PhoneGap被Adobe收购了,临走之前把核心代码给了Apache,Apache就把这个项目名作Cordova,所以说PhoneGap和Cordova出自同一家,他们都会被开源社区和Adobe所推动.</p>\n<p>这个框架是作为原生与web之间的中间件,它采用插件的形式调用原生模块,最后成品就是原生页面和web页面的一个混合应用,现在是一个为大多数混合应用所采用的框架,拥有广大的前景</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>用相对简单,学习成本低,对于不熟悉原生开发的前端工程师来说是不错的选择.</p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>说实话这个并不是Cordova的缺点,而是web应用共有的问题,就是页面响应迟钝和操作体验不佳的问题.但是这些问题在现在也已经有了足够多的解决方案,具体想了解可以自行上网查阅.</p>\n<h3 id=\"HTML-5\"><a href=\"#HTML-5\" class=\"headerlink\" title=\"HTML 5+\"></a>HTML 5+</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a6ebea.png\" alt=\"HTML5+ logo\"></p>\n<p><a href=\"http://ask.dcloud.net.cn/docs/\">官方文档</a></p>\n<h4 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>DCloud和H5中国产业联盟发起的项目,使用H5+框架自带的各种方法去进行与原生模块之间的沟通,结果产出的依然是web页面,但是\u0007性能相对比Cordova好.</p>\n<h4 id=\"优点-1\"><a href=\"#优点-1\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>上手简单,学习成本低,有完整的中文文档,作为移动端webView上的框架体验是很不错的,前端人员可以优先考虑使用这个框架.</p>\n<h4 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>貌似国外基本没人知道这东西,第三方插件和资源相对较少,要是遇到问题也只能去dcloud社区里面找,stackoverflow是帮不到你的啦,而且就目前看来框架自带的bug还是有的.</p>\n<h3 id=\"ReactNative\"><a href=\"#ReactNative\" class=\"headerlink\" title=\"ReactNative\"></a>ReactNative</h3><p><img src=\"https://ooo.0o0.ooo/2017/03/14/58c7511a63fec.jpg\" alt=\"ReactNative logo\"></p>\n<p><a href=\"http://reactnative.cn/\">中文官网</a></p>\n<h4 id=\"介绍-2\"><a href=\"#介绍-2\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>Facebook 发布的一个混合开发框架,使用ES5/ES6语法,通过ReactNative自带的框架去调用原生模块,但重点是他虽然写的是前端语言,JSX和ES5/ES6但是可以经过构建渲染,将DOM元素转为原生元素,也就是使用前端语言开发原生app已成为现实,既能保留原生的体验又能体现出跨平台和热修复的优势,所以近两年来这个框架十分火.</p>\n<h4 id=\"优点-2\"><a href=\"#优点-2\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p>既有原生的体验,又能做到跨平台,虽然加载速度还是比纯原生慢一点,但是这个差距已经能达到毫秒级,基本不影响体验,目前像支付宝,手机QQ,淘宝 都已经在部分模块使用了React Native框架,市场前景广阔,拥有丰富的资料.</p>\n<h4 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p>因为这个框架还出现不久,目前还是0.x版本阶段,有部分原生模块还没有接入,只能等他更新</p>\n<p>需要一定的学习成本,如果你说你是个会HTML和CSS的前端工程师,那不好意思你还是从入门教程开始看吧╮(╯_╰)╭</p>\n<h3 id=\"Weex\"><a href=\"#Weex\" class=\"headerlink\" title=\"Weex\"></a>Weex</h3><p>官网 … 额… 没官网..只有一个<a href=\"http://www.weex.help/\">论坛</a></p>\n<h4 id=\"介绍-3\"><a href=\"#介绍-3\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>阿里爸爸推出的跟ReactNative差不多的框架,所以介绍就跟上面差不多,其实我并不是很熟悉这个框架,而且这个框架是16年4月阿里才开放出来内测的,现在支持的原生元素还是不多,现在一年过去了感觉没引起多大关注,如果你学过Vue,那么这个框架你可能会比较好上手</p>\n<p>总之阿里爸爸推出了这个轮子还是很吊的.之后说不定会一鸣惊人呢?</p>\n<h3 id=\"AppCan\"><a href=\"#AppCan\" class=\"headerlink\" title=\"AppCan\"></a>AppCan</h3><p><a href=\"http://www.appcan.cn/\">官网</a></p>\n<h4 id=\"介绍-4\"><a href=\"#介绍-4\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>国内的混合开发框架</p>\n<p>_(´ཀ`」 ∠) 这个东西是基于他们服务器运行的,所以说如果他们的服务器跪了,你的app就跪了,当然如果你是付费用户,他们就会很快地帮你处理.他们有自己的开发IDE,产出的是也是webView页面,这里就不过多介绍了,具体可以看他们官网.</p>\n<h3 id=\"关于热修复\"><a href=\"#关于热修复\" class=\"headerlink\" title=\"关于热修复\"></a>关于热修复</h3><p>前言就讲了热修复是啥东西,然后说说最近发生的一件事</p>\n<p>今年的三八妇女节那天,苹果发了邮件给使用了热修复的开发者,说你们在应用商店上面的app里面有使用了热修复框架,希望你们以后不要用,因为这会违反什么吧啦吧啦协议条款,然后一群不是很懂英文的程序员就猜来猜去,就说苹果不让用热修复了,JSPatch不能用了啊,ReactNative药丸啊╮(╯_╰)╭,我在V2看到的最多的就是iOS开发者的欢呼23333,感觉真是世态炎凉,原生的优势已经得通过保护才能体现了吗?</p>\n<p>嘛.认真看看邮件,苹果是说你们不能用热修复的手段去改变app的功能,像是调用runtime底层方法之类的,就比如说你这个功能本来是显示一个公司的产品展示的的,但是你通过了应用审核之后,远程下发补丁,然后一打开app就弹出一大堆广告,那这样子肯定是违反协议的,当然你用JSPatch的方式你想做啥就做啥,显然不是很好,所以现在JSPatch官方也说近期不要用(前几天我更新了一个app的新版本,没有移除JSPatch,居然也过审了???),但是RN框架是不会做这些事情的,收到邮件的RN开发者大多是因为里面用了Code Push或Expo之类的第三方.</p>\n<p>那结论就是,JSPatch不给用了,那也许大家会更倾向于RN或者web方案,所以近期RN的发展应该会更加迅速,反正无论如何,大家尝到热修复的甜头,肯定不会就此罢休.</p>\n<hr>\n<p>文: Arclin</p>\n<p>2017.03.14</p>"},{"title":"关于案场管家的技术点总结","author":"Arclin","abbrlink":"8ff6aa28","date":"2016-06-11T16:00:00.000Z","_content":"案场管家的技术点总结\n\n<!-- more -->\n\n### xib与storyboard\n\n1. xib和storyboard均是用于布局所用，其实如果不需要过于复杂的布局的话完全也可以时候用masonry或者直接CGRect定位亦或者NSNSLayoutConstraint进行布局，如果要用代码的话个人觉得masonry是非常好用的，并且该框架所使用的函数式编程思想和链式编程思想也是值得学习的\n\n2. storyboard的作用类似于包含多个xib+视图管理，代码调用storyboard里面的控制器的代码如下\n\n\t```\n\tUIStoryboard *stroyboard = [UIStoryboard storyboardWithName:\"storyboard的文件名\" bundle:nil];\n\tXXXViewController *vc = [storyboard instantiateViewControllerWithIdentifier:“contorller的storyboard Id”];\n\t```\n\t如果是controller类xib，那么就直接 alloc init 一个该xib所绑定的controller就可以了\n\t如果是view类xib\n\t\n\t```\n\t[[[NSBundle mainBundle] loadNibNamed:@\"CMBuildingCell\" owner:nil options:nil] firstObject]\n\t```\n\n3. 之前曾经遇到过一个bug，从xib拖线到类文件的时候他会报错，原因是如果你的xib绑定的是一个继承UIView的类（比如一个cell），那么File Owner就应该保持为空，父view绑定类；如果绑定的是一个controller类，那父view绑定为空，File Owner绑定类，从以上说明我们可以得知，FileOwner就是这个xib所属的controller,如果他没有所属的controller，那么调用这个xib的controller就是他的File Owner，所以上面的代码里面的owner我们一直保持为nil就可以了\n \n### 关于网络获取与数据本地化\n\n1. 关于网络方面的话我之前写过一份xmind，大概流程是这样子的\n\t- 首先定义一个布尔变量，判断是否有存档\n\t- viewDidLoad 取档并刷新数据\n\t- viewWillAppear 中执行 loadDataFromNet\n\t- loadDataFromNet方法中判断是否有存档，没有存档并且获取网络数据失败的时候才提示数据刷新失败\n\t\n\t示例如下\n\t\n\t* 这里用NSCachesDirectory，也就是缓存目录，关于目录的选择看有道云笔记，上面有比较详细的说明 \n\t\n\t```\n\t #define XXFileName [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:@\"xx.data\"]\n\t- (void)viewDidLoad {\t\n\t\t [super viewDidLoad];\n\t\t // 取档\n\t    \tself.dataArray = [NSKeyedUnarchiver unarchiveObjectWithFile:XXFileName];\n\t    \n\t\t if (self.dataArray) {\n\t   \t\t[self.tableView reloadData];\n\t   \t\thasArchive = YES;\n\t\t}else{\n\t    \thasArchive = NO;\n\t    \t// 转菊花  或者 下拉刷新也行 \n\t    \t[SVProgressHUD setDefaultMaskType:SVProgressHUDMaskTypeBlack];\n\t \t    [SVProgressHUD show];\n\t\t}\n\t\t[self loadDataFromNet];\n\t}\n\t- (void)viewWillAppear:(BOOL)animated\n\t{\n\t    **如果能保证这个controller每次进来都会经过viewDidLoad(例如本身自己就是子控制器且自己也没有子控制器)则这里就不用写了**\n\t\t[self loadDataFromNet];\n\t}\t\n\t- (void)loadDataFromNet\n\t{\n\t\t[XXTool fetchMsg:^(XXData *data) {\n\t  \t\tself.data = data;\n\t    \t// 归档\n\t    \t[NSKeyedArchiver archiveRootObject:profile toFile:XXFileName];\n\t    \tdispatch_async(dispatch_get_main_queue(), ^{\n\t    \t\t[SVProgressHUD dismiss];\n\t        \t[self.tableView reloadData];\n\t    \t});\n\t\t } failure:^(NSError *error) {\n\t    \tNSLog(@\"%@\",error);\n\t    \tdispatch_async(dispatch_get_main_queue(), ^{\n\t    \t    if(!_hasArchive)[SVProgressHUD showErrorWithStatus:@\"加载失败\"];\n\t    \t});\n\t\t}];\n\t}\n\t```\n \t* 不过做项目的时候还是看实际情况进行调整吧，上面所说的只是一般情况下的网络处理\n\n\t近期稍微地研究了一下Runtime框架，加上一点脑洞和MJExtendsion的配合，感觉可以做出一个框架，能够实现获取数据之后直接生成跟远程数据库结构相同的本地数据库，一方面可以避开类似salesForce的SOQL语句无法进行多表查询之类的恶心问题，另一方面做数据筛选功能的时候也会简单很多，这个就待我去看看能不能搞出来\n\t\n### 关于单例\n1. 在这个项目里面我导入了一个外部框架（应该说是一个文件？）：Singleton.h\n这个东西使用起来很爽\n只要在你想单例的类的声明h里加 singleton_interface（类名）\n实现m里加 singleton_implementation（类名)\n就可以了\n之后你想调用这个类的时候就直接 [ClassName sharedClassName] 就可以直接获得到这个类的单例\n\n2. 什么情况下要用到单例？\n以案场这个为例子，我每次获取数据都需要加上限制条件，筛选当前项目下和当前登录用户的数据\n那么我就会频繁使用到projectId 和 userId ，__并且这两个值基本不变__\n所以我就给这个单例写了两个方法\n\n\t```\n\t- (NSString *)currentProjectId;\n\t- (NSString *)userId;\n\t- (CMProject *)currentProject\n\t{\t\n\t CMProject*currentProject = [NSKeyedUnarchiverunarchiveObjectWithFile:CMSelectProjectFileName];\n\t   \treturn currentProject;\n\t}\n\t\n\t- (NSString *)userId{ \n\treturn [SFUserAccountManager sharedInstance].currentUser.credentials.userId;\n\t}\n\t\n\t//使用\n\t[[CMUserTool sharedCMUserTool] userId];\n\t```\n\t\n### 关于传值\n\n1. 传值有三宝：代理、通知、block 另外还有storyboard专用segue传值和成员属性传值等，因为前三个比较重要所以我就说说前三个的使用\n\t- 代理用来两个视图之间的传值，最常用的就是自定义view上面的点击事件通过代理告诉调用它的controller，因为一个界面只能有一个controller，一般我们都是抽出另一个controller的view添加到这个controller上面，所以这时候就要用代理进行两个controller之间的数据传递\n通知，先说说使用方法\n\n\t```\n\t**消息接收方**\n\t[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(方法名) name:消息名 object:nil];\n\t\n\t**消息发送方**\n\t//创建一个消息对象\n\tNSNotification * notice = [NSNotification notificationWithName:消息名 object:nil userInfo:nil];\n\t//发送消息\n\t[[NSNotificationCenter defaultCenter]postNotification:notice];\n\t移除通知 \n\t\n\t移除单个通知\n\t[[NSNotificationCenter defaultCenter] removeObserver:self name:消息名 object:self];\n\t\n\t移除当前所有通知:[[NSNotificationCenterdefaultCenter]removeObserver:self];\n\t```\n\n\t但是优缺点并存\n\t\n\t> 优势：\n\t>\n\t> 1. 不需要编写多少代码，实现比较简单\n\t> 2. 对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单\n\t> 3. controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息\n\t\n\t> 缺点：\n\t>\n\t> 1. 在编译期不会检查通知是否能够被观察者正确的处理； \n\t> 2. 在释放注册的对象时，需要在通知中心取消注册；\n\t> 3. 在调试的时候应用的工作以及控制过程难跟踪；\n\t> 4. 需要第三方对象来管理controller与观察者对象之间的联系；\n\t> 5. controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；\n\t> 6. 通知发出后，controller不能从观察者获得任何的反馈信息。\n\t\n\n\t- block 用于反向传值，就是在子控制器操作数据后传值回到父控制器，这时候我们用block，不过block传值也有坑，很容易引起循环引用然后烧内存。解决方法就是用weak修饰对象比如 ` weak typeof(self) weakSelf = self `\n这样子我们用weakSelf.对象就不会引起循环引用\n\t\t- 还有block有一个小地方要注意，如果要在block里面调用外部变量的话，要给外部变量加一个__block修饰符\n\n### 关于枚举\n\n枚举不用讲太多，枚举就是为了方便判断而已，但是命名规范还是要说的,举个栗子\n\n```\ntypedef enum : NSUInteger {\n     CMRelatedTypeOpportunity,\n     CMRelatedTypeBooking,\n     CMRelatedTypeSalesOrder,\n     CMRelatedTypeContract,\n     CMRelatedTypeCollection,\n     CMRelatedTypeTrade\n } CMRelatedType;\n```\n \n枚举的成员名 = 枚举名 + 类型名\n\n### 关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller\n\n案场那个客户界是这个app中逻辑最复杂的一个界面，虽然通过了枚举的判断方便了一个代码的阅读，但总的来说上千行代码着实还是恶心。\n类似的场景应该以后应该还会经常发生，但是虽然开发的时候可能方便了但是维护起来也太费劲了，并且之前项目的种种维护的体验也告诉了我们一个事实：MVC框架不够用了\n\n所以——我们还是换个架构吧~\n\n我大概考虑了一下，逻辑层还是尽可能的细分，多几个类都行，然后耦合性应该低\n之前我们就已经习惯了把业务层从controller中抽取出来,这种方式应该保留\n然后我们可以尝试引入MVCS架构以及MVVM架构等，具体的demo应该会在近期实现","source":"_posts/关于案场管家的技术点总结.md","raw":"---\ntitle: 关于案场管家的技术点总结\nauthor: Arclin\ntags:\n  - iOS\n  - 杂谈\ncategories:\n  - iOS\nabbrlink: 8ff6aa28\ndate: 2016-06-12 00:00:00\n---\n案场管家的技术点总结\n\n<!-- more -->\n\n### xib与storyboard\n\n1. xib和storyboard均是用于布局所用，其实如果不需要过于复杂的布局的话完全也可以时候用masonry或者直接CGRect定位亦或者NSNSLayoutConstraint进行布局，如果要用代码的话个人觉得masonry是非常好用的，并且该框架所使用的函数式编程思想和链式编程思想也是值得学习的\n\n2. storyboard的作用类似于包含多个xib+视图管理，代码调用storyboard里面的控制器的代码如下\n\n\t```\n\tUIStoryboard *stroyboard = [UIStoryboard storyboardWithName:\"storyboard的文件名\" bundle:nil];\n\tXXXViewController *vc = [storyboard instantiateViewControllerWithIdentifier:“contorller的storyboard Id”];\n\t```\n\t如果是controller类xib，那么就直接 alloc init 一个该xib所绑定的controller就可以了\n\t如果是view类xib\n\t\n\t```\n\t[[[NSBundle mainBundle] loadNibNamed:@\"CMBuildingCell\" owner:nil options:nil] firstObject]\n\t```\n\n3. 之前曾经遇到过一个bug，从xib拖线到类文件的时候他会报错，原因是如果你的xib绑定的是一个继承UIView的类（比如一个cell），那么File Owner就应该保持为空，父view绑定类；如果绑定的是一个controller类，那父view绑定为空，File Owner绑定类，从以上说明我们可以得知，FileOwner就是这个xib所属的controller,如果他没有所属的controller，那么调用这个xib的controller就是他的File Owner，所以上面的代码里面的owner我们一直保持为nil就可以了\n \n### 关于网络获取与数据本地化\n\n1. 关于网络方面的话我之前写过一份xmind，大概流程是这样子的\n\t- 首先定义一个布尔变量，判断是否有存档\n\t- viewDidLoad 取档并刷新数据\n\t- viewWillAppear 中执行 loadDataFromNet\n\t- loadDataFromNet方法中判断是否有存档，没有存档并且获取网络数据失败的时候才提示数据刷新失败\n\t\n\t示例如下\n\t\n\t* 这里用NSCachesDirectory，也就是缓存目录，关于目录的选择看有道云笔记，上面有比较详细的说明 \n\t\n\t```\n\t #define XXFileName [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:@\"xx.data\"]\n\t- (void)viewDidLoad {\t\n\t\t [super viewDidLoad];\n\t\t // 取档\n\t    \tself.dataArray = [NSKeyedUnarchiver unarchiveObjectWithFile:XXFileName];\n\t    \n\t\t if (self.dataArray) {\n\t   \t\t[self.tableView reloadData];\n\t   \t\thasArchive = YES;\n\t\t}else{\n\t    \thasArchive = NO;\n\t    \t// 转菊花  或者 下拉刷新也行 \n\t    \t[SVProgressHUD setDefaultMaskType:SVProgressHUDMaskTypeBlack];\n\t \t    [SVProgressHUD show];\n\t\t}\n\t\t[self loadDataFromNet];\n\t}\n\t- (void)viewWillAppear:(BOOL)animated\n\t{\n\t    **如果能保证这个controller每次进来都会经过viewDidLoad(例如本身自己就是子控制器且自己也没有子控制器)则这里就不用写了**\n\t\t[self loadDataFromNet];\n\t}\t\n\t- (void)loadDataFromNet\n\t{\n\t\t[XXTool fetchMsg:^(XXData *data) {\n\t  \t\tself.data = data;\n\t    \t// 归档\n\t    \t[NSKeyedArchiver archiveRootObject:profile toFile:XXFileName];\n\t    \tdispatch_async(dispatch_get_main_queue(), ^{\n\t    \t\t[SVProgressHUD dismiss];\n\t        \t[self.tableView reloadData];\n\t    \t});\n\t\t } failure:^(NSError *error) {\n\t    \tNSLog(@\"%@\",error);\n\t    \tdispatch_async(dispatch_get_main_queue(), ^{\n\t    \t    if(!_hasArchive)[SVProgressHUD showErrorWithStatus:@\"加载失败\"];\n\t    \t});\n\t\t}];\n\t}\n\t```\n \t* 不过做项目的时候还是看实际情况进行调整吧，上面所说的只是一般情况下的网络处理\n\n\t近期稍微地研究了一下Runtime框架，加上一点脑洞和MJExtendsion的配合，感觉可以做出一个框架，能够实现获取数据之后直接生成跟远程数据库结构相同的本地数据库，一方面可以避开类似salesForce的SOQL语句无法进行多表查询之类的恶心问题，另一方面做数据筛选功能的时候也会简单很多，这个就待我去看看能不能搞出来\n\t\n### 关于单例\n1. 在这个项目里面我导入了一个外部框架（应该说是一个文件？）：Singleton.h\n这个东西使用起来很爽\n只要在你想单例的类的声明h里加 singleton_interface（类名）\n实现m里加 singleton_implementation（类名)\n就可以了\n之后你想调用这个类的时候就直接 [ClassName sharedClassName] 就可以直接获得到这个类的单例\n\n2. 什么情况下要用到单例？\n以案场这个为例子，我每次获取数据都需要加上限制条件，筛选当前项目下和当前登录用户的数据\n那么我就会频繁使用到projectId 和 userId ，__并且这两个值基本不变__\n所以我就给这个单例写了两个方法\n\n\t```\n\t- (NSString *)currentProjectId;\n\t- (NSString *)userId;\n\t- (CMProject *)currentProject\n\t{\t\n\t CMProject*currentProject = [NSKeyedUnarchiverunarchiveObjectWithFile:CMSelectProjectFileName];\n\t   \treturn currentProject;\n\t}\n\t\n\t- (NSString *)userId{ \n\treturn [SFUserAccountManager sharedInstance].currentUser.credentials.userId;\n\t}\n\t\n\t//使用\n\t[[CMUserTool sharedCMUserTool] userId];\n\t```\n\t\n### 关于传值\n\n1. 传值有三宝：代理、通知、block 另外还有storyboard专用segue传值和成员属性传值等，因为前三个比较重要所以我就说说前三个的使用\n\t- 代理用来两个视图之间的传值，最常用的就是自定义view上面的点击事件通过代理告诉调用它的controller，因为一个界面只能有一个controller，一般我们都是抽出另一个controller的view添加到这个controller上面，所以这时候就要用代理进行两个controller之间的数据传递\n通知，先说说使用方法\n\n\t```\n\t**消息接收方**\n\t[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(方法名) name:消息名 object:nil];\n\t\n\t**消息发送方**\n\t//创建一个消息对象\n\tNSNotification * notice = [NSNotification notificationWithName:消息名 object:nil userInfo:nil];\n\t//发送消息\n\t[[NSNotificationCenter defaultCenter]postNotification:notice];\n\t移除通知 \n\t\n\t移除单个通知\n\t[[NSNotificationCenter defaultCenter] removeObserver:self name:消息名 object:self];\n\t\n\t移除当前所有通知:[[NSNotificationCenterdefaultCenter]removeObserver:self];\n\t```\n\n\t但是优缺点并存\n\t\n\t> 优势：\n\t>\n\t> 1. 不需要编写多少代码，实现比较简单\n\t> 2. 对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单\n\t> 3. controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息\n\t\n\t> 缺点：\n\t>\n\t> 1. 在编译期不会检查通知是否能够被观察者正确的处理； \n\t> 2. 在释放注册的对象时，需要在通知中心取消注册；\n\t> 3. 在调试的时候应用的工作以及控制过程难跟踪；\n\t> 4. 需要第三方对象来管理controller与观察者对象之间的联系；\n\t> 5. controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；\n\t> 6. 通知发出后，controller不能从观察者获得任何的反馈信息。\n\t\n\n\t- block 用于反向传值，就是在子控制器操作数据后传值回到父控制器，这时候我们用block，不过block传值也有坑，很容易引起循环引用然后烧内存。解决方法就是用weak修饰对象比如 ` weak typeof(self) weakSelf = self `\n这样子我们用weakSelf.对象就不会引起循环引用\n\t\t- 还有block有一个小地方要注意，如果要在block里面调用外部变量的话，要给外部变量加一个__block修饰符\n\n### 关于枚举\n\n枚举不用讲太多，枚举就是为了方便判断而已，但是命名规范还是要说的,举个栗子\n\n```\ntypedef enum : NSUInteger {\n     CMRelatedTypeOpportunity,\n     CMRelatedTypeBooking,\n     CMRelatedTypeSalesOrder,\n     CMRelatedTypeContract,\n     CMRelatedTypeCollection,\n     CMRelatedTypeTrade\n } CMRelatedType;\n```\n \n枚举的成员名 = 枚举名 + 类型名\n\n### 关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller\n\n案场那个客户界是这个app中逻辑最复杂的一个界面，虽然通过了枚举的判断方便了一个代码的阅读，但总的来说上千行代码着实还是恶心。\n类似的场景应该以后应该还会经常发生，但是虽然开发的时候可能方便了但是维护起来也太费劲了，并且之前项目的种种维护的体验也告诉了我们一个事实：MVC框架不够用了\n\n所以——我们还是换个架构吧~\n\n我大概考虑了一下，逻辑层还是尽可能的细分，多几个类都行，然后耦合性应该低\n之前我们就已经习惯了把业务层从controller中抽取出来,这种方式应该保留\n然后我们可以尝试引入MVCS架构以及MVVM架构等，具体的demo应该会在近期实现","slug":"关于案场管家的技术点总结","published":1,"updated":"2021-04-12T06:07:04.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog5z004m45n0hx4x523j","content":"<p>案场管家的技术点总结</p>\n<span id=\"more\"></span>\n\n<h3 id=\"xib与storyboard\"><a href=\"#xib与storyboard\" class=\"headerlink\" title=\"xib与storyboard\"></a>xib与storyboard</h3><ol>\n<li><p>xib和storyboard均是用于布局所用，其实如果不需要过于复杂的布局的话完全也可以时候用masonry或者直接CGRect定位亦或者NSNSLayoutConstraint进行布局，如果要用代码的话个人觉得masonry是非常好用的，并且该框架所使用的函数式编程思想和链式编程思想也是值得学习的</p>\n</li>\n<li><p>storyboard的作用类似于包含多个xib+视图管理，代码调用storyboard里面的控制器的代码如下</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIStoryboard *stroyboard &#x3D; [UIStoryboard storyboardWithName:&quot;storyboard的文件名&quot; bundle:nil];</span><br><span class=\"line\">XXXViewController *vc &#x3D; [storyboard instantiateViewControllerWithIdentifier:“contorller的storyboard Id”];</span><br></pre></td></tr></table></figure>\n<p> 如果是controller类xib，那么就直接 alloc init 一个该xib所绑定的controller就可以了<br> 如果是view类xib</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[[NSBundle mainBundle] loadNibNamed:@&quot;CMBuildingCell&quot; owner:nil options:nil] firstObject]</span><br></pre></td></tr></table></figure></li>\n<li><p>之前曾经遇到过一个bug，从xib拖线到类文件的时候他会报错，原因是如果你的xib绑定的是一个继承UIView的类（比如一个cell），那么File Owner就应该保持为空，父view绑定类；如果绑定的是一个controller类，那父view绑定为空，File Owner绑定类，从以上说明我们可以得知，FileOwner就是这个xib所属的controller,如果他没有所属的controller，那么调用这个xib的controller就是他的File Owner，所以上面的代码里面的owner我们一直保持为nil就可以了</p>\n</li>\n</ol>\n<h3 id=\"关于网络获取与数据本地化\"><a href=\"#关于网络获取与数据本地化\" class=\"headerlink\" title=\"关于网络获取与数据本地化\"></a>关于网络获取与数据本地化</h3><ol>\n<li><p>关于网络方面的话我之前写过一份xmind，大概流程是这样子的</p>\n<ul>\n<li>首先定义一个布尔变量，判断是否有存档</li>\n<li>viewDidLoad 取档并刷新数据</li>\n<li>viewWillAppear 中执行 loadDataFromNet</li>\n<li>loadDataFromNet方法中判断是否有存档，没有存档并且获取网络数据失败的时候才提示数据刷新失败</li>\n</ul>\n<p> 示例如下</p>\n<ul>\n<li>这里用NSCachesDirectory，也就是缓存目录，关于目录的选择看有道云笔记，上面有比较详细的说明 </li>\n</ul>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> #define XXFileName [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:@&quot;xx.data&quot;]</span><br><span class=\"line\">- (void)viewDidLoad &#123;\t</span><br><span class=\"line\">\t [super viewDidLoad];</span><br><span class=\"line\">\t &#x2F;&#x2F; 取档</span><br><span class=\"line\">    \tself.dataArray &#x3D; [NSKeyedUnarchiver unarchiveObjectWithFile:XXFileName];</span><br><span class=\"line\">    </span><br><span class=\"line\">\t if (self.dataArray) &#123;</span><br><span class=\"line\">   \t\t[self.tableView reloadData];</span><br><span class=\"line\">   \t\thasArchive &#x3D; YES;</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">    \thasArchive &#x3D; NO;</span><br><span class=\"line\">    \t&#x2F;&#x2F; 转菊花  或者 下拉刷新也行 </span><br><span class=\"line\">    \t[SVProgressHUD setDefaultMaskType:SVProgressHUDMaskTypeBlack];</span><br><span class=\"line\"> \t    [SVProgressHUD show];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t[self loadDataFromNet];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)viewWillAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    **如果能保证这个controller每次进来都会经过viewDidLoad(例如本身自己就是子控制器且自己也没有子控制器)则这里就不用写了**</span><br><span class=\"line\">\t[self loadDataFromNet];</span><br><span class=\"line\">&#125;\t</span><br><span class=\"line\">- (void)loadDataFromNet</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[XXTool fetchMsg:^(XXData *data) &#123;</span><br><span class=\"line\">  \t\tself.data &#x3D; data;</span><br><span class=\"line\">    \t&#x2F;&#x2F; 归档</span><br><span class=\"line\">    \t[NSKeyedArchiver archiveRootObject:profile toFile:XXFileName];</span><br><span class=\"line\">    \tdispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    \t\t[SVProgressHUD dismiss];</span><br><span class=\"line\">        \t[self.tableView reloadData];</span><br><span class=\"line\">    \t&#125;);</span><br><span class=\"line\">\t &#125; failure:^(NSError *error) &#123;</span><br><span class=\"line\">    \tNSLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">    \tdispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    \t    if(!_hasArchive)[SVProgressHUD showErrorWithStatus:@&quot;加载失败&quot;];</span><br><span class=\"line\">    \t&#125;);</span><br><span class=\"line\">\t&#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>不过做项目的时候还是看实际情况进行调整吧，上面所说的只是一般情况下的网络处理</li>\n</ul>\n<p> 近期稍微地研究了一下Runtime框架，加上一点脑洞和MJExtendsion的配合，感觉可以做出一个框架，能够实现获取数据之后直接生成跟远程数据库结构相同的本地数据库，一方面可以避开类似salesForce的SOQL语句无法进行多表查询之类的恶心问题，另一方面做数据筛选功能的时候也会简单很多，这个就待我去看看能不能搞出来</p>\n</li>\n</ol>\n<h3 id=\"关于单例\"><a href=\"#关于单例\" class=\"headerlink\" title=\"关于单例\"></a>关于单例</h3><ol>\n<li><p>在这个项目里面我导入了一个外部框架（应该说是一个文件？）：Singleton.h<br>这个东西使用起来很爽<br>只要在你想单例的类的声明h里加 singleton_interface（类名）<br>实现m里加 singleton_implementation（类名)<br>就可以了<br>之后你想调用这个类的时候就直接 [ClassName sharedClassName] 就可以直接获得到这个类的单例</p>\n</li>\n<li><p>什么情况下要用到单例？<br>以案场这个为例子，我每次获取数据都需要加上限制条件，筛选当前项目下和当前登录用户的数据<br>那么我就会频繁使用到projectId 和 userId ，<strong>并且这两个值基本不变</strong><br>所以我就给这个单例写了两个方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSString *)currentProjectId;</span><br><span class=\"line\">- (NSString *)userId;</span><br><span class=\"line\">- (CMProject *)currentProject</span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\"> CMProject*currentProject &#x3D; [NSKeyedUnarchiverunarchiveObjectWithFile:CMSelectProjectFileName];</span><br><span class=\"line\">   \treturn currentProject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)userId&#123; </span><br><span class=\"line\">return [SFUserAccountManager sharedInstance].currentUser.credentials.userId;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;使用</span><br><span class=\"line\">[[CMUserTool sharedCMUserTool] userId];</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"关于传值\"><a href=\"#关于传值\" class=\"headerlink\" title=\"关于传值\"></a>关于传值</h3><ol>\n<li><p>传值有三宝：代理、通知、block 另外还有storyboard专用segue传值和成员属性传值等，因为前三个比较重要所以我就说说前三个的使用</p>\n<ul>\n<li>代理用来两个视图之间的传值，最常用的就是自定义view上面的点击事件通过代理告诉调用它的controller，因为一个界面只能有一个controller，一般我们都是抽出另一个controller的view添加到这个controller上面，所以这时候就要用代理进行两个controller之间的数据传递<br>通知，先说说使用方法</li>\n</ul>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**消息接收方**</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(方法名) name:消息名 object:nil];</span><br><span class=\"line\"></span><br><span class=\"line\">**消息发送方**</span><br><span class=\"line\">&#x2F;&#x2F;创建一个消息对象</span><br><span class=\"line\">NSNotification * notice &#x3D; [NSNotification notificationWithName:消息名 object:nil userInfo:nil];</span><br><span class=\"line\">&#x2F;&#x2F;发送消息</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter]postNotification:notice];</span><br><span class=\"line\">移除通知 </span><br><span class=\"line\"></span><br><span class=\"line\">移除单个通知</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter] removeObserver:self name:消息名 object:self];</span><br><span class=\"line\"></span><br><span class=\"line\">移除当前所有通知:[[NSNotificationCenterdefaultCenter]removeObserver:self];</span><br></pre></td></tr></table></figure>\n\n<p> 但是优缺点并存</p>\n<blockquote>\n<p>优势：</p>\n<ol>\n<li>不需要编写多少代码，实现比较简单</li>\n<li>对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单</li>\n<li>controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>缺点：</p>\n<ol>\n<li>在编译期不会检查通知是否能够被观察者正确的处理； </li>\n<li>在释放注册的对象时，需要在通知中心取消注册；</li>\n<li>在调试的时候应用的工作以及控制过程难跟踪；</li>\n<li>需要第三方对象来管理controller与观察者对象之间的联系；</li>\n<li>controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；</li>\n<li>通知发出后，controller不能从观察者获得任何的反馈信息。</li>\n</ol>\n</blockquote>\n<ul>\n<li>block 用于反向传值，就是在子控制器操作数据后传值回到父控制器，这时候我们用block，不过block传值也有坑，很容易引起循环引用然后烧内存。解决方法就是用weak修饰对象比如 <code>weak typeof(self) weakSelf = self</code><br>这样子我们用weakSelf.对象就不会引起循环引用<ul>\n<li>还有block有一个小地方要注意，如果要在block里面调用外部变量的话，要给外部变量加一个__block修饰符</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"关于枚举\"><a href=\"#关于枚举\" class=\"headerlink\" title=\"关于枚举\"></a>关于枚举</h3><p>枚举不用讲太多，枚举就是为了方便判断而已，但是命名规范还是要说的,举个栗子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef enum : NSUInteger &#123;</span><br><span class=\"line\">     CMRelatedTypeOpportunity,</span><br><span class=\"line\">     CMRelatedTypeBooking,</span><br><span class=\"line\">     CMRelatedTypeSalesOrder,</span><br><span class=\"line\">     CMRelatedTypeContract,</span><br><span class=\"line\">     CMRelatedTypeCollection,</span><br><span class=\"line\">     CMRelatedTypeTrade</span><br><span class=\"line\"> &#125; CMRelatedType;</span><br></pre></td></tr></table></figure>\n<p>枚举的成员名 = 枚举名 + 类型名</p>\n<h3 id=\"关于案场的客户界面-——-复杂的逻辑-TO-一个Controller\"><a href=\"#关于案场的客户界面-——-复杂的逻辑-TO-一个Controller\" class=\"headerlink\" title=\"关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller\"></a>关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller</h3><p>案场那个客户界是这个app中逻辑最复杂的一个界面，虽然通过了枚举的判断方便了一个代码的阅读，但总的来说上千行代码着实还是恶心。<br>类似的场景应该以后应该还会经常发生，但是虽然开发的时候可能方便了但是维护起来也太费劲了，并且之前项目的种种维护的体验也告诉了我们一个事实：MVC框架不够用了</p>\n<p>所以——我们还是换个架构吧~</p>\n<p>我大概考虑了一下，逻辑层还是尽可能的细分，多几个类都行，然后耦合性应该低<br>之前我们就已经习惯了把业务层从controller中抽取出来,这种方式应该保留<br>然后我们可以尝试引入MVCS架构以及MVVM架构等，具体的demo应该会在近期实现</p>\n","site":{"data":{}},"excerpt":"<p>案场管家的技术点总结</p>","more":"<h3 id=\"xib与storyboard\"><a href=\"#xib与storyboard\" class=\"headerlink\" title=\"xib与storyboard\"></a>xib与storyboard</h3><ol>\n<li><p>xib和storyboard均是用于布局所用，其实如果不需要过于复杂的布局的话完全也可以时候用masonry或者直接CGRect定位亦或者NSNSLayoutConstraint进行布局，如果要用代码的话个人觉得masonry是非常好用的，并且该框架所使用的函数式编程思想和链式编程思想也是值得学习的</p>\n</li>\n<li><p>storyboard的作用类似于包含多个xib+视图管理，代码调用storyboard里面的控制器的代码如下</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIStoryboard *stroyboard &#x3D; [UIStoryboard storyboardWithName:&quot;storyboard的文件名&quot; bundle:nil];</span><br><span class=\"line\">XXXViewController *vc &#x3D; [storyboard instantiateViewControllerWithIdentifier:“contorller的storyboard Id”];</span><br></pre></td></tr></table></figure>\n<p> 如果是controller类xib，那么就直接 alloc init 一个该xib所绑定的controller就可以了<br> 如果是view类xib</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[[NSBundle mainBundle] loadNibNamed:@&quot;CMBuildingCell&quot; owner:nil options:nil] firstObject]</span><br></pre></td></tr></table></figure></li>\n<li><p>之前曾经遇到过一个bug，从xib拖线到类文件的时候他会报错，原因是如果你的xib绑定的是一个继承UIView的类（比如一个cell），那么File Owner就应该保持为空，父view绑定类；如果绑定的是一个controller类，那父view绑定为空，File Owner绑定类，从以上说明我们可以得知，FileOwner就是这个xib所属的controller,如果他没有所属的controller，那么调用这个xib的controller就是他的File Owner，所以上面的代码里面的owner我们一直保持为nil就可以了</p>\n</li>\n</ol>\n<h3 id=\"关于网络获取与数据本地化\"><a href=\"#关于网络获取与数据本地化\" class=\"headerlink\" title=\"关于网络获取与数据本地化\"></a>关于网络获取与数据本地化</h3><ol>\n<li><p>关于网络方面的话我之前写过一份xmind，大概流程是这样子的</p>\n<ul>\n<li>首先定义一个布尔变量，判断是否有存档</li>\n<li>viewDidLoad 取档并刷新数据</li>\n<li>viewWillAppear 中执行 loadDataFromNet</li>\n<li>loadDataFromNet方法中判断是否有存档，没有存档并且获取网络数据失败的时候才提示数据刷新失败</li>\n</ul>\n<p> 示例如下</p>\n<ul>\n<li>这里用NSCachesDirectory，也就是缓存目录，关于目录的选择看有道云笔记，上面有比较详细的说明 </li>\n</ul>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> #define XXFileName [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:@&quot;xx.data&quot;]</span><br><span class=\"line\">- (void)viewDidLoad &#123;\t</span><br><span class=\"line\">\t [super viewDidLoad];</span><br><span class=\"line\">\t &#x2F;&#x2F; 取档</span><br><span class=\"line\">    \tself.dataArray &#x3D; [NSKeyedUnarchiver unarchiveObjectWithFile:XXFileName];</span><br><span class=\"line\">    </span><br><span class=\"line\">\t if (self.dataArray) &#123;</span><br><span class=\"line\">   \t\t[self.tableView reloadData];</span><br><span class=\"line\">   \t\thasArchive &#x3D; YES;</span><br><span class=\"line\">\t&#125;else&#123;</span><br><span class=\"line\">    \thasArchive &#x3D; NO;</span><br><span class=\"line\">    \t&#x2F;&#x2F; 转菊花  或者 下拉刷新也行 </span><br><span class=\"line\">    \t[SVProgressHUD setDefaultMaskType:SVProgressHUDMaskTypeBlack];</span><br><span class=\"line\"> \t    [SVProgressHUD show];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t[self loadDataFromNet];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)viewWillAppear:(BOOL)animated</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    **如果能保证这个controller每次进来都会经过viewDidLoad(例如本身自己就是子控制器且自己也没有子控制器)则这里就不用写了**</span><br><span class=\"line\">\t[self loadDataFromNet];</span><br><span class=\"line\">&#125;\t</span><br><span class=\"line\">- (void)loadDataFromNet</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[XXTool fetchMsg:^(XXData *data) &#123;</span><br><span class=\"line\">  \t\tself.data &#x3D; data;</span><br><span class=\"line\">    \t&#x2F;&#x2F; 归档</span><br><span class=\"line\">    \t[NSKeyedArchiver archiveRootObject:profile toFile:XXFileName];</span><br><span class=\"line\">    \tdispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    \t\t[SVProgressHUD dismiss];</span><br><span class=\"line\">        \t[self.tableView reloadData];</span><br><span class=\"line\">    \t&#125;);</span><br><span class=\"line\">\t &#125; failure:^(NSError *error) &#123;</span><br><span class=\"line\">    \tNSLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">    \tdispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class=\"line\">    \t    if(!_hasArchive)[SVProgressHUD showErrorWithStatus:@&quot;加载失败&quot;];</span><br><span class=\"line\">    \t&#125;);</span><br><span class=\"line\">\t&#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>不过做项目的时候还是看实际情况进行调整吧，上面所说的只是一般情况下的网络处理</li>\n</ul>\n<p> 近期稍微地研究了一下Runtime框架，加上一点脑洞和MJExtendsion的配合，感觉可以做出一个框架，能够实现获取数据之后直接生成跟远程数据库结构相同的本地数据库，一方面可以避开类似salesForce的SOQL语句无法进行多表查询之类的恶心问题，另一方面做数据筛选功能的时候也会简单很多，这个就待我去看看能不能搞出来</p>\n</li>\n</ol>\n<h3 id=\"关于单例\"><a href=\"#关于单例\" class=\"headerlink\" title=\"关于单例\"></a>关于单例</h3><ol>\n<li><p>在这个项目里面我导入了一个外部框架（应该说是一个文件？）：Singleton.h<br>这个东西使用起来很爽<br>只要在你想单例的类的声明h里加 singleton_interface（类名）<br>实现m里加 singleton_implementation（类名)<br>就可以了<br>之后你想调用这个类的时候就直接 [ClassName sharedClassName] 就可以直接获得到这个类的单例</p>\n</li>\n<li><p>什么情况下要用到单例？<br>以案场这个为例子，我每次获取数据都需要加上限制条件，筛选当前项目下和当前登录用户的数据<br>那么我就会频繁使用到projectId 和 userId ，<strong>并且这两个值基本不变</strong><br>所以我就给这个单例写了两个方法</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSString *)currentProjectId;</span><br><span class=\"line\">- (NSString *)userId;</span><br><span class=\"line\">- (CMProject *)currentProject</span><br><span class=\"line\">&#123;\t</span><br><span class=\"line\"> CMProject*currentProject &#x3D; [NSKeyedUnarchiverunarchiveObjectWithFile:CMSelectProjectFileName];</span><br><span class=\"line\">   \treturn currentProject;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)userId&#123; </span><br><span class=\"line\">return [SFUserAccountManager sharedInstance].currentUser.credentials.userId;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;使用</span><br><span class=\"line\">[[CMUserTool sharedCMUserTool] userId];</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"关于传值\"><a href=\"#关于传值\" class=\"headerlink\" title=\"关于传值\"></a>关于传值</h3><ol>\n<li><p>传值有三宝：代理、通知、block 另外还有storyboard专用segue传值和成员属性传值等，因为前三个比较重要所以我就说说前三个的使用</p>\n<ul>\n<li>代理用来两个视图之间的传值，最常用的就是自定义view上面的点击事件通过代理告诉调用它的controller，因为一个界面只能有一个controller，一般我们都是抽出另一个controller的view添加到这个controller上面，所以这时候就要用代理进行两个controller之间的数据传递<br>通知，先说说使用方法</li>\n</ul>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**消息接收方**</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(方法名) name:消息名 object:nil];</span><br><span class=\"line\"></span><br><span class=\"line\">**消息发送方**</span><br><span class=\"line\">&#x2F;&#x2F;创建一个消息对象</span><br><span class=\"line\">NSNotification * notice &#x3D; [NSNotification notificationWithName:消息名 object:nil userInfo:nil];</span><br><span class=\"line\">&#x2F;&#x2F;发送消息</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter]postNotification:notice];</span><br><span class=\"line\">移除通知 </span><br><span class=\"line\"></span><br><span class=\"line\">移除单个通知</span><br><span class=\"line\">[[NSNotificationCenter defaultCenter] removeObserver:self name:消息名 object:self];</span><br><span class=\"line\"></span><br><span class=\"line\">移除当前所有通知:[[NSNotificationCenterdefaultCenter]removeObserver:self];</span><br></pre></td></tr></table></figure>\n\n<p> 但是优缺点并存</p>\n<blockquote>\n<p>优势：</p>\n<ol>\n<li>不需要编写多少代码，实现比较简单</li>\n<li>对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单</li>\n<li>controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>缺点：</p>\n<ol>\n<li>在编译期不会检查通知是否能够被观察者正确的处理； </li>\n<li>在释放注册的对象时，需要在通知中心取消注册；</li>\n<li>在调试的时候应用的工作以及控制过程难跟踪；</li>\n<li>需要第三方对象来管理controller与观察者对象之间的联系；</li>\n<li>controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；</li>\n<li>通知发出后，controller不能从观察者获得任何的反馈信息。</li>\n</ol>\n</blockquote>\n<ul>\n<li>block 用于反向传值，就是在子控制器操作数据后传值回到父控制器，这时候我们用block，不过block传值也有坑，很容易引起循环引用然后烧内存。解决方法就是用weak修饰对象比如 <code>weak typeof(self) weakSelf = self</code><br>这样子我们用weakSelf.对象就不会引起循环引用<ul>\n<li>还有block有一个小地方要注意，如果要在block里面调用外部变量的话，要给外部变量加一个__block修饰符</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"关于枚举\"><a href=\"#关于枚举\" class=\"headerlink\" title=\"关于枚举\"></a>关于枚举</h3><p>枚举不用讲太多，枚举就是为了方便判断而已，但是命名规范还是要说的,举个栗子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef enum : NSUInteger &#123;</span><br><span class=\"line\">     CMRelatedTypeOpportunity,</span><br><span class=\"line\">     CMRelatedTypeBooking,</span><br><span class=\"line\">     CMRelatedTypeSalesOrder,</span><br><span class=\"line\">     CMRelatedTypeContract,</span><br><span class=\"line\">     CMRelatedTypeCollection,</span><br><span class=\"line\">     CMRelatedTypeTrade</span><br><span class=\"line\"> &#125; CMRelatedType;</span><br></pre></td></tr></table></figure>\n<p>枚举的成员名 = 枚举名 + 类型名</p>\n<h3 id=\"关于案场的客户界面-——-复杂的逻辑-TO-一个Controller\"><a href=\"#关于案场的客户界面-——-复杂的逻辑-TO-一个Controller\" class=\"headerlink\" title=\"关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller\"></a>关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller</h3><p>案场那个客户界是这个app中逻辑最复杂的一个界面，虽然通过了枚举的判断方便了一个代码的阅读，但总的来说上千行代码着实还是恶心。<br>类似的场景应该以后应该还会经常发生，但是虽然开发的时候可能方便了但是维护起来也太费劲了，并且之前项目的种种维护的体验也告诉了我们一个事实：MVC框架不够用了</p>\n<p>所以——我们还是换个架构吧~</p>\n<p>我大概考虑了一下，逻辑层还是尽可能的细分，多几个类都行，然后耦合性应该低<br>之前我们就已经习惯了把业务层从controller中抽取出来,这种方式应该保留<br>然后我们可以尝试引入MVCS架构以及MVVM架构等，具体的demo应该会在近期实现</p>"},{"title":"发现一个api","author":"Arclin","abbrlink":"54b26395","date":"2016-10-16T16:00:00.000Z","_content":"发现一个好用的api，用于找出selectedItem 在 dataSource 里面的位置，适用于tableView和collectionView\n\n```\nNSIndexSet *indexSet = [self.photos indexesOfObjectsPassingTest:^BOOL(DKPhoto * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n    if ([self.selectedPhotoArray containsObject:obj]) {\n        return YES;\n    }\n    return NO;\n}];\n```","source":"_posts/发现一个api.md","raw":"---\ntitle: 发现一个api\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 54b26395\ndate: 2016-10-17 00:00:00\n---\n发现一个好用的api，用于找出selectedItem 在 dataSource 里面的位置，适用于tableView和collectionView\n\n```\nNSIndexSet *indexSet = [self.photos indexesOfObjectsPassingTest:^BOOL(DKPhoto * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n    if ([self.selectedPhotoArray containsObject:obj]) {\n        return YES;\n    }\n    return NO;\n}];\n```","slug":"发现一个api","published":1,"updated":"2021-04-12T06:07:04.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog60004q45n018gq9nl6","content":"<p>发现一个好用的api，用于找出selectedItem 在 dataSource 里面的位置，适用于tableView和collectionView</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSIndexSet *indexSet &#x3D; [self.photos indexesOfObjectsPassingTest:^BOOL(DKPhoto * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">    if ([self.selectedPhotoArray containsObject:obj]) &#123;</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>发现一个好用的api，用于找出selectedItem 在 dataSource 里面的位置，适用于tableView和collectionView</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSIndexSet *indexSet &#x3D; [self.photos indexesOfObjectsPassingTest:^BOOL(DKPhoto * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">    if ([self.selectedPhotoArray containsObject:obj]) &#123;</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return NO;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>"},{"title":"关于第三方单元测试框架的简单说明","author":"Arclin","abbrlink":"7daa41d8","date":"2018-05-23T05:12:00.000Z","_content":"关于第三方单元测试框架的简单说明\n\n<!-- more -->\n\n\n## Pod安装\n\nPodfile编写（框架只能安装在UnitTest的Target中）\n\n```\ntarget 'BaZiPaiPanSDK' do\n    ...\n    target 'BaZiPaiPanSDKTests' do\n        inherit! :search_paths\n        pod 'Specta'\n        pod 'Expecta'\n        pod 'OCMock'\n    end\nend\n```\n\n## Specta\n\n- Specta是一个BDD（行为驱动开发）框架\n\n```\n#import <OCMock/OCMock.h>\n#import <Specta/Specta.h>\n#import <Expecta/Expecta.h>\n#import <ReactiveCocoa/ReactiveCocoa.h>\n#import \"BZPPCaiYunViewModel.h\"\n\nSpecBegin(BZPPCaiYunViewModel)\t// 声明了一个测试类\n\n    __block BZPPCaiYunViewModel *viewModel; // 我们要测试这个类\n\n    beforeEach(^{ \t\t\t\t\t// 通过beforeEach 首先先初始化 \n        viewModel = [[BZPPCaiYunViewModel alloc] init];\n    });\n\n    describe(@\"BZPPCaiYunViewModel\", ^{  // 声明一组用例\n    \n        it(@\"refresh when data isn't empty\", ^{ // 通过 it 声明一个用例，前面的字符串是一个描述\n            __block id result;\n            waitUntil(^(DoneCallback done) { // 假设这里有网络请求，所以需要异步，有点像GCD的信号量\n                [[viewModel.loadDataCommand execute:nil] subscribeNext:^(id x) {\n                    result = x;\n                    done(); // 请求结束，告知框架可以继续往下走\n                }];\n            });\n            expect(result).notTo.beNull(); // 这里是Expecta框架的内容，后面解释\n        });\n    });\n\n    afterEach(^{\n        viewModel = nil; // 测试结束，清空\n    });\n\nSpecEnd // 类的结束，相当于 @end\n```\n\n\n## OCMock\n\n- OCMock一般用来构造伪数据，比如说有时候我们一个方法内部需要通过很多数据才能完成，但是这些数据需要其他复杂的实现去获取，这时候我们用OCMock就可以方便地创造这些数据\n\n- OCMock可以做的事情大概如下\n\t- 指定一个方法的返回值\n\t- 验证某个方法是否有被调用 (比如说指定了错误的数据会不会调用处理异常的方法)\n\t- 验证方法block传出来的参数是否符合预期\n\t- 模拟UI和验证UI的显示\n\n```\nSpecBegin(BZPPCaiYunViewModel)\n\n    __block BZPPCaiYunViewModel *viewModel;\n\n    beforeEach(^{\n    \n    });\n\n    describe(@\"Test OCMock\", ^{\n        it(@\"It should not to be null\", ^{\n            id mockManager = OCMClassMock([BZPPHunLianManager class]); // 因为是单例所以要用这种方法mock一个对象\n            OCMStub([mockManager sharedInstance]).andReturn([BZPPHunLianManager class]); // 同上，调用单例方法返回一个单例对象, OCMStub意思就是模拟执行某个方法, 用andReturn返回指定的值\n            OCMVerify([mockManager getGanQingHunYinData:OCMOCK_ANY isMale:YES]); // 验证这个方法是否在上面的过程中被调用了，结果是没有被调用，测试失败\n        });\n    });\n\n    afterEach(^{\n        \n    });\n\nSpecEnd\n```\n\n## Expecta\n\n- Expecta是一个断言框架, 语法十分地通俗易懂, 很接近自然语言\n- Expecta的用法比较简单\n\n```\nexpect(obj).to.beNull(); // 期望某对象应该是空值\nexpect(obj).toNot.beNull(); // 期望某对象不应该是空值\nexpect(obj).equal(xxx); // 期望等于某个值\n```\n\n诸如此类比较多可以去看Github官方文档","source":"_posts/关于第三方单元测试框架的简单说明.md","raw":"title: 关于第三方单元测试框架的简单说明\nauthor: Arclin\nabbrlink: 7daa41d8\ntags:\n  - iOS\ncategories:\n  - iOS\ndate: 2018-05-23 13:12:00\n---\n关于第三方单元测试框架的简单说明\n\n<!-- more -->\n\n\n## Pod安装\n\nPodfile编写（框架只能安装在UnitTest的Target中）\n\n```\ntarget 'BaZiPaiPanSDK' do\n    ...\n    target 'BaZiPaiPanSDKTests' do\n        inherit! :search_paths\n        pod 'Specta'\n        pod 'Expecta'\n        pod 'OCMock'\n    end\nend\n```\n\n## Specta\n\n- Specta是一个BDD（行为驱动开发）框架\n\n```\n#import <OCMock/OCMock.h>\n#import <Specta/Specta.h>\n#import <Expecta/Expecta.h>\n#import <ReactiveCocoa/ReactiveCocoa.h>\n#import \"BZPPCaiYunViewModel.h\"\n\nSpecBegin(BZPPCaiYunViewModel)\t// 声明了一个测试类\n\n    __block BZPPCaiYunViewModel *viewModel; // 我们要测试这个类\n\n    beforeEach(^{ \t\t\t\t\t// 通过beforeEach 首先先初始化 \n        viewModel = [[BZPPCaiYunViewModel alloc] init];\n    });\n\n    describe(@\"BZPPCaiYunViewModel\", ^{  // 声明一组用例\n    \n        it(@\"refresh when data isn't empty\", ^{ // 通过 it 声明一个用例，前面的字符串是一个描述\n            __block id result;\n            waitUntil(^(DoneCallback done) { // 假设这里有网络请求，所以需要异步，有点像GCD的信号量\n                [[viewModel.loadDataCommand execute:nil] subscribeNext:^(id x) {\n                    result = x;\n                    done(); // 请求结束，告知框架可以继续往下走\n                }];\n            });\n            expect(result).notTo.beNull(); // 这里是Expecta框架的内容，后面解释\n        });\n    });\n\n    afterEach(^{\n        viewModel = nil; // 测试结束，清空\n    });\n\nSpecEnd // 类的结束，相当于 @end\n```\n\n\n## OCMock\n\n- OCMock一般用来构造伪数据，比如说有时候我们一个方法内部需要通过很多数据才能完成，但是这些数据需要其他复杂的实现去获取，这时候我们用OCMock就可以方便地创造这些数据\n\n- OCMock可以做的事情大概如下\n\t- 指定一个方法的返回值\n\t- 验证某个方法是否有被调用 (比如说指定了错误的数据会不会调用处理异常的方法)\n\t- 验证方法block传出来的参数是否符合预期\n\t- 模拟UI和验证UI的显示\n\n```\nSpecBegin(BZPPCaiYunViewModel)\n\n    __block BZPPCaiYunViewModel *viewModel;\n\n    beforeEach(^{\n    \n    });\n\n    describe(@\"Test OCMock\", ^{\n        it(@\"It should not to be null\", ^{\n            id mockManager = OCMClassMock([BZPPHunLianManager class]); // 因为是单例所以要用这种方法mock一个对象\n            OCMStub([mockManager sharedInstance]).andReturn([BZPPHunLianManager class]); // 同上，调用单例方法返回一个单例对象, OCMStub意思就是模拟执行某个方法, 用andReturn返回指定的值\n            OCMVerify([mockManager getGanQingHunYinData:OCMOCK_ANY isMale:YES]); // 验证这个方法是否在上面的过程中被调用了，结果是没有被调用，测试失败\n        });\n    });\n\n    afterEach(^{\n        \n    });\n\nSpecEnd\n```\n\n## Expecta\n\n- Expecta是一个断言框架, 语法十分地通俗易懂, 很接近自然语言\n- Expecta的用法比较简单\n\n```\nexpect(obj).to.beNull(); // 期望某对象应该是空值\nexpect(obj).toNot.beNull(); // 期望某对象不应该是空值\nexpect(obj).equal(xxx); // 期望等于某个值\n```\n\n诸如此类比较多可以去看Github官方文档","slug":"关于第三方单元测试框架的简单说明","published":1,"updated":"2021-04-12T06:07:04.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog61004u45n01f8rhr2i","content":"<p>关于第三方单元测试框架的简单说明</p>\n<span id=\"more\"></span>\n\n\n<h2 id=\"Pod安装\"><a href=\"#Pod安装\" class=\"headerlink\" title=\"Pod安装\"></a>Pod安装</h2><p>Podfile编写（框架只能安装在UnitTest的Target中）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target &#39;BaZiPaiPanSDK&#39; do</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    target &#39;BaZiPaiPanSDKTests&#39; do</span><br><span class=\"line\">        inherit! :search_paths</span><br><span class=\"line\">        pod &#39;Specta&#39;</span><br><span class=\"line\">        pod &#39;Expecta&#39;</span><br><span class=\"line\">        pod &#39;OCMock&#39;</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Specta\"><a href=\"#Specta\" class=\"headerlink\" title=\"Specta\"></a>Specta</h2><ul>\n<li>Specta是一个BDD（行为驱动开发）框架</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;OCMock&#x2F;OCMock.h&gt;</span><br><span class=\"line\">#import &lt;Specta&#x2F;Specta.h&gt;</span><br><span class=\"line\">#import &lt;Expecta&#x2F;Expecta.h&gt;</span><br><span class=\"line\">#import &lt;ReactiveCocoa&#x2F;ReactiveCocoa.h&gt;</span><br><span class=\"line\">#import &quot;BZPPCaiYunViewModel.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">SpecBegin(BZPPCaiYunViewModel)\t&#x2F;&#x2F; 声明了一个测试类</span><br><span class=\"line\"></span><br><span class=\"line\">    __block BZPPCaiYunViewModel *viewModel; &#x2F;&#x2F; 我们要测试这个类</span><br><span class=\"line\"></span><br><span class=\"line\">    beforeEach(^&#123; \t\t\t\t\t&#x2F;&#x2F; 通过beforeEach 首先先初始化 </span><br><span class=\"line\">        viewModel &#x3D; [[BZPPCaiYunViewModel alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    describe(@&quot;BZPPCaiYunViewModel&quot;, ^&#123;  &#x2F;&#x2F; 声明一组用例</span><br><span class=\"line\">    </span><br><span class=\"line\">        it(@&quot;refresh when data isn&#39;t empty&quot;, ^&#123; &#x2F;&#x2F; 通过 it 声明一个用例，前面的字符串是一个描述</span><br><span class=\"line\">            __block id result;</span><br><span class=\"line\">            waitUntil(^(DoneCallback done) &#123; &#x2F;&#x2F; 假设这里有网络请求，所以需要异步，有点像GCD的信号量</span><br><span class=\"line\">                [[viewModel.loadDataCommand execute:nil] subscribeNext:^(id x) &#123;</span><br><span class=\"line\">                    result &#x3D; x;</span><br><span class=\"line\">                    done(); &#x2F;&#x2F; 请求结束，告知框架可以继续往下走</span><br><span class=\"line\">                &#125;];</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            expect(result).notTo.beNull(); &#x2F;&#x2F; 这里是Expecta框架的内容，后面解释</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    afterEach(^&#123;</span><br><span class=\"line\">        viewModel &#x3D; nil; &#x2F;&#x2F; 测试结束，清空</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">SpecEnd &#x2F;&#x2F; 类的结束，相当于 @end</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"OCMock\"><a href=\"#OCMock\" class=\"headerlink\" title=\"OCMock\"></a>OCMock</h2><ul>\n<li><p>OCMock一般用来构造伪数据，比如说有时候我们一个方法内部需要通过很多数据才能完成，但是这些数据需要其他复杂的实现去获取，这时候我们用OCMock就可以方便地创造这些数据</p>\n</li>\n<li><p>OCMock可以做的事情大概如下</p>\n<ul>\n<li>指定一个方法的返回值</li>\n<li>验证某个方法是否有被调用 (比如说指定了错误的数据会不会调用处理异常的方法)</li>\n<li>验证方法block传出来的参数是否符合预期</li>\n<li>模拟UI和验证UI的显示</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SpecBegin(BZPPCaiYunViewModel)</span><br><span class=\"line\"></span><br><span class=\"line\">    __block BZPPCaiYunViewModel *viewModel;</span><br><span class=\"line\"></span><br><span class=\"line\">    beforeEach(^&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    describe(@&quot;Test OCMock&quot;, ^&#123;</span><br><span class=\"line\">        it(@&quot;It should not to be null&quot;, ^&#123;</span><br><span class=\"line\">            id mockManager &#x3D; OCMClassMock([BZPPHunLianManager class]); &#x2F;&#x2F; 因为是单例所以要用这种方法mock一个对象</span><br><span class=\"line\">            OCMStub([mockManager sharedInstance]).andReturn([BZPPHunLianManager class]); &#x2F;&#x2F; 同上，调用单例方法返回一个单例对象, OCMStub意思就是模拟执行某个方法, 用andReturn返回指定的值</span><br><span class=\"line\">            OCMVerify([mockManager getGanQingHunYinData:OCMOCK_ANY isMale:YES]); &#x2F;&#x2F; 验证这个方法是否在上面的过程中被调用了，结果是没有被调用，测试失败</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    afterEach(^&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">SpecEnd</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Expecta\"><a href=\"#Expecta\" class=\"headerlink\" title=\"Expecta\"></a>Expecta</h2><ul>\n<li>Expecta是一个断言框架, 语法十分地通俗易懂, 很接近自然语言</li>\n<li>Expecta的用法比较简单</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(obj).to.beNull(); &#x2F;&#x2F; 期望某对象应该是空值</span><br><span class=\"line\">expect(obj).toNot.beNull(); &#x2F;&#x2F; 期望某对象不应该是空值</span><br><span class=\"line\">expect(obj).equal(xxx); &#x2F;&#x2F; 期望等于某个值</span><br></pre></td></tr></table></figure>\n\n<p>诸如此类比较多可以去看Github官方文档</p>\n","site":{"data":{}},"excerpt":"<p>关于第三方单元测试框架的简单说明</p>","more":"<h2 id=\"Pod安装\"><a href=\"#Pod安装\" class=\"headerlink\" title=\"Pod安装\"></a>Pod安装</h2><p>Podfile编写（框架只能安装在UnitTest的Target中）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target &#39;BaZiPaiPanSDK&#39; do</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    target &#39;BaZiPaiPanSDKTests&#39; do</span><br><span class=\"line\">        inherit! :search_paths</span><br><span class=\"line\">        pod &#39;Specta&#39;</span><br><span class=\"line\">        pod &#39;Expecta&#39;</span><br><span class=\"line\">        pod &#39;OCMock&#39;</span><br><span class=\"line\">    end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Specta\"><a href=\"#Specta\" class=\"headerlink\" title=\"Specta\"></a>Specta</h2><ul>\n<li>Specta是一个BDD（行为驱动开发）框架</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;OCMock&#x2F;OCMock.h&gt;</span><br><span class=\"line\">#import &lt;Specta&#x2F;Specta.h&gt;</span><br><span class=\"line\">#import &lt;Expecta&#x2F;Expecta.h&gt;</span><br><span class=\"line\">#import &lt;ReactiveCocoa&#x2F;ReactiveCocoa.h&gt;</span><br><span class=\"line\">#import &quot;BZPPCaiYunViewModel.h&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">SpecBegin(BZPPCaiYunViewModel)\t&#x2F;&#x2F; 声明了一个测试类</span><br><span class=\"line\"></span><br><span class=\"line\">    __block BZPPCaiYunViewModel *viewModel; &#x2F;&#x2F; 我们要测试这个类</span><br><span class=\"line\"></span><br><span class=\"line\">    beforeEach(^&#123; \t\t\t\t\t&#x2F;&#x2F; 通过beforeEach 首先先初始化 </span><br><span class=\"line\">        viewModel &#x3D; [[BZPPCaiYunViewModel alloc] init];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    describe(@&quot;BZPPCaiYunViewModel&quot;, ^&#123;  &#x2F;&#x2F; 声明一组用例</span><br><span class=\"line\">    </span><br><span class=\"line\">        it(@&quot;refresh when data isn&#39;t empty&quot;, ^&#123; &#x2F;&#x2F; 通过 it 声明一个用例，前面的字符串是一个描述</span><br><span class=\"line\">            __block id result;</span><br><span class=\"line\">            waitUntil(^(DoneCallback done) &#123; &#x2F;&#x2F; 假设这里有网络请求，所以需要异步，有点像GCD的信号量</span><br><span class=\"line\">                [[viewModel.loadDataCommand execute:nil] subscribeNext:^(id x) &#123;</span><br><span class=\"line\">                    result &#x3D; x;</span><br><span class=\"line\">                    done(); &#x2F;&#x2F; 请求结束，告知框架可以继续往下走</span><br><span class=\"line\">                &#125;];</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            expect(result).notTo.beNull(); &#x2F;&#x2F; 这里是Expecta框架的内容，后面解释</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    afterEach(^&#123;</span><br><span class=\"line\">        viewModel &#x3D; nil; &#x2F;&#x2F; 测试结束，清空</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">SpecEnd &#x2F;&#x2F; 类的结束，相当于 @end</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"OCMock\"><a href=\"#OCMock\" class=\"headerlink\" title=\"OCMock\"></a>OCMock</h2><ul>\n<li><p>OCMock一般用来构造伪数据，比如说有时候我们一个方法内部需要通过很多数据才能完成，但是这些数据需要其他复杂的实现去获取，这时候我们用OCMock就可以方便地创造这些数据</p>\n</li>\n<li><p>OCMock可以做的事情大概如下</p>\n<ul>\n<li>指定一个方法的返回值</li>\n<li>验证某个方法是否有被调用 (比如说指定了错误的数据会不会调用处理异常的方法)</li>\n<li>验证方法block传出来的参数是否符合预期</li>\n<li>模拟UI和验证UI的显示</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SpecBegin(BZPPCaiYunViewModel)</span><br><span class=\"line\"></span><br><span class=\"line\">    __block BZPPCaiYunViewModel *viewModel;</span><br><span class=\"line\"></span><br><span class=\"line\">    beforeEach(^&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    describe(@&quot;Test OCMock&quot;, ^&#123;</span><br><span class=\"line\">        it(@&quot;It should not to be null&quot;, ^&#123;</span><br><span class=\"line\">            id mockManager &#x3D; OCMClassMock([BZPPHunLianManager class]); &#x2F;&#x2F; 因为是单例所以要用这种方法mock一个对象</span><br><span class=\"line\">            OCMStub([mockManager sharedInstance]).andReturn([BZPPHunLianManager class]); &#x2F;&#x2F; 同上，调用单例方法返回一个单例对象, OCMStub意思就是模拟执行某个方法, 用andReturn返回指定的值</span><br><span class=\"line\">            OCMVerify([mockManager getGanQingHunYinData:OCMOCK_ANY isMale:YES]); &#x2F;&#x2F; 验证这个方法是否在上面的过程中被调用了，结果是没有被调用，测试失败</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    afterEach(^&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">SpecEnd</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Expecta\"><a href=\"#Expecta\" class=\"headerlink\" title=\"Expecta\"></a>Expecta</h2><ul>\n<li>Expecta是一个断言框架, 语法十分地通俗易懂, 很接近自然语言</li>\n<li>Expecta的用法比较简单</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expect(obj).to.beNull(); &#x2F;&#x2F; 期望某对象应该是空值</span><br><span class=\"line\">expect(obj).toNot.beNull(); &#x2F;&#x2F; 期望某对象不应该是空值</span><br><span class=\"line\">expect(obj).equal(xxx); &#x2F;&#x2F; 期望等于某个值</span><br></pre></td></tr></table></figure>\n\n<p>诸如此类比较多可以去看Github官方文档</p>"},{"title":"在 iCloud Drive中显示 App的iCloud文件夹","author":"Arclin","abbrlink":"3eb7dc04","date":"2016-10-28T16:00:00.000Z","_content":"1. 修改 info.plist\n\n  ```\n  <key>NSUbiquitousContainers</key>\n      <dict>\n          <key>iCloud.com.example.app</key>\n          <dict>\n              <key>NSUbiquitousContainerIsDocumentScopePublic</key>\n              <true/>\n              <key>NSUbiquitousContainerName</key>\n              <string>App name to display in iCloud Drive</string>\n              <key>NSUbiquitousContainerSupportedFolderLevels</key>\n              <string>None</string>\n          </dict>\n      </dict>\n  ```\n\n2. 修改版本构件号(必改)","source":"_posts/在-iCloud-Drive中显示-App的iCloud文件夹.md","raw":"---\ntitle: 在 iCloud Drive中显示 App的iCloud文件夹\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 3eb7dc04\ndate: 2016-10-29 00:00:00\n---\n1. 修改 info.plist\n\n  ```\n  <key>NSUbiquitousContainers</key>\n      <dict>\n          <key>iCloud.com.example.app</key>\n          <dict>\n              <key>NSUbiquitousContainerIsDocumentScopePublic</key>\n              <true/>\n              <key>NSUbiquitousContainerName</key>\n              <string>App name to display in iCloud Drive</string>\n              <key>NSUbiquitousContainerSupportedFolderLevels</key>\n              <string>None</string>\n          </dict>\n      </dict>\n  ```\n\n2. 修改版本构件号(必改)","slug":"在-iCloud-Drive中显示-App的iCloud文件夹","published":1,"updated":"2021-04-12T06:07:04.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog62004x45n0chyohdhu","content":"<ol>\n<li>修改 info.plist</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;NSUbiquitousContainers&lt;&#x2F;key&gt;</span><br><span class=\"line\">    &lt;dict&gt;</span><br><span class=\"line\">        &lt;key&gt;iCloud.com.example.app&lt;&#x2F;key&gt;</span><br><span class=\"line\">        &lt;dict&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerIsDocumentScopePublic&lt;&#x2F;key&gt;</span><br><span class=\"line\">            &lt;true&#x2F;&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerName&lt;&#x2F;key&gt;</span><br><span class=\"line\">            &lt;string&gt;App name to display in iCloud Drive&lt;&#x2F;string&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerSupportedFolderLevels&lt;&#x2F;key&gt;</span><br><span class=\"line\">            &lt;string&gt;None&lt;&#x2F;string&gt;</span><br><span class=\"line\">        &lt;&#x2F;dict&gt;</span><br><span class=\"line\">    &lt;&#x2F;dict&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>修改版本构件号(必改)</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>修改 info.plist</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;NSUbiquitousContainers&lt;&#x2F;key&gt;</span><br><span class=\"line\">    &lt;dict&gt;</span><br><span class=\"line\">        &lt;key&gt;iCloud.com.example.app&lt;&#x2F;key&gt;</span><br><span class=\"line\">        &lt;dict&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerIsDocumentScopePublic&lt;&#x2F;key&gt;</span><br><span class=\"line\">            &lt;true&#x2F;&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerName&lt;&#x2F;key&gt;</span><br><span class=\"line\">            &lt;string&gt;App name to display in iCloud Drive&lt;&#x2F;string&gt;</span><br><span class=\"line\">            &lt;key&gt;NSUbiquitousContainerSupportedFolderLevels&lt;&#x2F;key&gt;</span><br><span class=\"line\">            &lt;string&gt;None&lt;&#x2F;string&gt;</span><br><span class=\"line\">        &lt;&#x2F;dict&gt;</span><br><span class=\"line\">    &lt;&#x2F;dict&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>修改版本构件号(必改)</li>\n</ol>\n"},{"title":"使用PHP进行webhook的注意点","author":"Arclin","abbrlink":"f8291fcc","date":"2018-02-18T13:55:00.000Z","_content":"有时会编写PHP脚本进行webhook, 这里有些地方需要注意一下, 否则会导致脚本执行失败\n\n<!-- more -->\n\n允许某些敏感方法的执行\n编辑`php.ini`\n\n```\ndisable_functions = scandir,passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,\nini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,\nstream_socket_server,fsocket,fsockopen\n```\n\n把`exec`去掉\n\n检查`apache`用户的目录权限\n\napache用户公钥要配置在项目里面\n也就是项目里会有两个公钥\n一个是root的一个是apache的","source":"_posts/使用php的exec方法进行webhook的注意点.md","raw":"---\ntitle: 使用PHP进行webhook的注意点\nauthor: Arclin\ntags:\n  - php\n  - webhook\ncategories:\n  - PHP\nabbrlink: f8291fcc\ndate: 2018-02-18 21:55:00\n---\n有时会编写PHP脚本进行webhook, 这里有些地方需要注意一下, 否则会导致脚本执行失败\n\n<!-- more -->\n\n允许某些敏感方法的执行\n编辑`php.ini`\n\n```\ndisable_functions = scandir,passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,\nini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,\nstream_socket_server,fsocket,fsockopen\n```\n\n把`exec`去掉\n\n检查`apache`用户的目录权限\n\napache用户公钥要配置在项目里面\n也就是项目里会有两个公钥\n一个是root的一个是apache的","slug":"使用php的exec方法进行webhook的注意点","published":1,"updated":"2021-04-12T06:07:04.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog62005045n089644yge","content":"<p>有时会编写PHP脚本进行webhook, 这里有些地方需要注意一下, 否则会导致脚本执行失败</p>\n<span id=\"more\"></span>\n\n<p>允许某些敏感方法的执行<br>编辑<code>php.ini</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">disable_functions &#x3D; scandir,passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,</span><br><span class=\"line\">ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,</span><br><span class=\"line\">stream_socket_server,fsocket,fsockopen</span><br></pre></td></tr></table></figure>\n\n<p>把<code>exec</code>去掉</p>\n<p>检查<code>apache</code>用户的目录权限</p>\n<p>apache用户公钥要配置在项目里面<br>也就是项目里会有两个公钥<br>一个是root的一个是apache的</p>\n","site":{"data":{}},"excerpt":"<p>有时会编写PHP脚本进行webhook, 这里有些地方需要注意一下, 否则会导致脚本执行失败</p>","more":"<p>允许某些敏感方法的执行<br>编辑<code>php.ini</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">disable_functions &#x3D; scandir,passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,</span><br><span class=\"line\">ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,</span><br><span class=\"line\">stream_socket_server,fsocket,fsockopen</span><br></pre></td></tr></table></figure>\n\n<p>把<code>exec</code>去掉</p>\n<p>检查<code>apache</code>用户的目录权限</p>\n<p>apache用户公钥要配置在项目里面<br>也就是项目里会有两个公钥<br>一个是root的一个是apache的</p>"},{"title":"基于DKHTTPTool的业务层设计_尝试版","author":"Arclin","abbrlink":"838ddddd","date":"2016-11-29T16:00:00.000Z","_content":"基于DKHTTPTool的业务层设计_尝试版\n\n由于是尝试版,所以这里只是简单讲下思路.\n\n<!-- more -->\n\n- 首先 DKHTTPTool提供了缓存策略的选择,让方法调用和缓存可以进行统一的处理\n然后业务层进行缓存策略的选择, 但由于 ViewModel实际需要的是一个模型(数组) ,而 `DKHTTPTool`返回的是一个 `DKResponse` 对象,所以业务层除了进行缓存策略的选择外,还需要进行对 `DKResponse`的处理.\n\n- DKResponse 里面有一个成员属性result用来储存后台返回的 json 数据,所以业务层(以下称 Service)需要去对这个属性值进行封装 , 封装的方法我们选择使用 MJExtension 的方法就可以了\n\n- 对于一些数据量比较大,数据结构比较复杂的模型, `MJExtension` 处理之后应该还需要存入数据库,便于日后的筛选,排序等操作.那么,此时逻辑就出现了变化\n\n\t- 对于简单的数据,处理流程是 VM调用Service方法 -> Service 调用 HTTP方法 -> 返回原始数据 -> `MJExtension`处理数据 -> 返回给 VM\n\t- 对于复杂的数据,处理流程是 VM调用Service方法 -> Service 调用 HTTP方法 -> 返回原始数据 -> `MJExtension`处理数据 -> 插入 or 更新 数据库表 - -> 同时返回处理好的数据给 VM\n- 当然第一种是最好处理的,只要套一层方法就可以把数组返回回去了(如果要进行比较简单的数据筛选操作,用 `NSPredicate`,排序用`NSSortDescriptor`也是可以实现的),但是对于第二种方法,那就需要我们新增一个 Service基类去统一处理取数据库数据的操作,包括条件筛选,排序 ,去重的等等的操作","source":"_posts/基于DKHTTPTool的业务层设计-尝试版.md","raw":"---\ntitle: 基于DKHTTPTool的业务层设计_尝试版\nauthor: Arclin\ntags:\n  - iOS\n  - 杂谈\ncategories:\n  - iOS\nabbrlink: 838ddddd\ndate: 2016-11-30 00:00:00\n---\n基于DKHTTPTool的业务层设计_尝试版\n\n由于是尝试版,所以这里只是简单讲下思路.\n\n<!-- more -->\n\n- 首先 DKHTTPTool提供了缓存策略的选择,让方法调用和缓存可以进行统一的处理\n然后业务层进行缓存策略的选择, 但由于 ViewModel实际需要的是一个模型(数组) ,而 `DKHTTPTool`返回的是一个 `DKResponse` 对象,所以业务层除了进行缓存策略的选择外,还需要进行对 `DKResponse`的处理.\n\n- DKResponse 里面有一个成员属性result用来储存后台返回的 json 数据,所以业务层(以下称 Service)需要去对这个属性值进行封装 , 封装的方法我们选择使用 MJExtension 的方法就可以了\n\n- 对于一些数据量比较大,数据结构比较复杂的模型, `MJExtension` 处理之后应该还需要存入数据库,便于日后的筛选,排序等操作.那么,此时逻辑就出现了变化\n\n\t- 对于简单的数据,处理流程是 VM调用Service方法 -> Service 调用 HTTP方法 -> 返回原始数据 -> `MJExtension`处理数据 -> 返回给 VM\n\t- 对于复杂的数据,处理流程是 VM调用Service方法 -> Service 调用 HTTP方法 -> 返回原始数据 -> `MJExtension`处理数据 -> 插入 or 更新 数据库表 - -> 同时返回处理好的数据给 VM\n- 当然第一种是最好处理的,只要套一层方法就可以把数组返回回去了(如果要进行比较简单的数据筛选操作,用 `NSPredicate`,排序用`NSSortDescriptor`也是可以实现的),但是对于第二种方法,那就需要我们新增一个 Service基类去统一处理取数据库数据的操作,包括条件筛选,排序 ,去重的等等的操作","slug":"基于DKHTTPTool的业务层设计-尝试版","published":1,"updated":"2021-04-12T06:07:04.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog65005445n03b9sepgl","content":"<p>基于DKHTTPTool的业务层设计_尝试版</p>\n<p>由于是尝试版,所以这里只是简单讲下思路.</p>\n<span id=\"more\"></span>\n\n<ul>\n<li><p>首先 DKHTTPTool提供了缓存策略的选择,让方法调用和缓存可以进行统一的处理<br>然后业务层进行缓存策略的选择, 但由于 ViewModel实际需要的是一个模型(数组) ,而 <code>DKHTTPTool</code>返回的是一个 <code>DKResponse</code> 对象,所以业务层除了进行缓存策略的选择外,还需要进行对 <code>DKResponse</code>的处理.</p>\n</li>\n<li><p>DKResponse 里面有一个成员属性result用来储存后台返回的 json 数据,所以业务层(以下称 Service)需要去对这个属性值进行封装 , 封装的方法我们选择使用 MJExtension 的方法就可以了</p>\n</li>\n<li><p>对于一些数据量比较大,数据结构比较复杂的模型, <code>MJExtension</code> 处理之后应该还需要存入数据库,便于日后的筛选,排序等操作.那么,此时逻辑就出现了变化</p>\n<ul>\n<li>对于简单的数据,处理流程是 VM调用Service方法 -&gt; Service 调用 HTTP方法 -&gt; 返回原始数据 -&gt; <code>MJExtension</code>处理数据 -&gt; 返回给 VM</li>\n<li>对于复杂的数据,处理流程是 VM调用Service方法 -&gt; Service 调用 HTTP方法 -&gt; 返回原始数据 -&gt; <code>MJExtension</code>处理数据 -&gt; 插入 or 更新 数据库表 - -&gt; 同时返回处理好的数据给 VM</li>\n</ul>\n</li>\n<li><p>当然第一种是最好处理的,只要套一层方法就可以把数组返回回去了(如果要进行比较简单的数据筛选操作,用 <code>NSPredicate</code>,排序用<code>NSSortDescriptor</code>也是可以实现的),但是对于第二种方法,那就需要我们新增一个 Service基类去统一处理取数据库数据的操作,包括条件筛选,排序 ,去重的等等的操作</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>基于DKHTTPTool的业务层设计_尝试版</p>\n<p>由于是尝试版,所以这里只是简单讲下思路.</p>","more":"<ul>\n<li><p>首先 DKHTTPTool提供了缓存策略的选择,让方法调用和缓存可以进行统一的处理<br>然后业务层进行缓存策略的选择, 但由于 ViewModel实际需要的是一个模型(数组) ,而 <code>DKHTTPTool</code>返回的是一个 <code>DKResponse</code> 对象,所以业务层除了进行缓存策略的选择外,还需要进行对 <code>DKResponse</code>的处理.</p>\n</li>\n<li><p>DKResponse 里面有一个成员属性result用来储存后台返回的 json 数据,所以业务层(以下称 Service)需要去对这个属性值进行封装 , 封装的方法我们选择使用 MJExtension 的方法就可以了</p>\n</li>\n<li><p>对于一些数据量比较大,数据结构比较复杂的模型, <code>MJExtension</code> 处理之后应该还需要存入数据库,便于日后的筛选,排序等操作.那么,此时逻辑就出现了变化</p>\n<ul>\n<li>对于简单的数据,处理流程是 VM调用Service方法 -&gt; Service 调用 HTTP方法 -&gt; 返回原始数据 -&gt; <code>MJExtension</code>处理数据 -&gt; 返回给 VM</li>\n<li>对于复杂的数据,处理流程是 VM调用Service方法 -&gt; Service 调用 HTTP方法 -&gt; 返回原始数据 -&gt; <code>MJExtension</code>处理数据 -&gt; 插入 or 更新 数据库表 - -&gt; 同时返回处理好的数据给 VM</li>\n</ul>\n</li>\n<li><p>当然第一种是最好处理的,只要套一层方法就可以把数组返回回去了(如果要进行比较简单的数据筛选操作,用 <code>NSPredicate</code>,排序用<code>NSSortDescriptor</code>也是可以实现的),但是对于第二种方法,那就需要我们新增一个 Service基类去统一处理取数据库数据的操作,包括条件筛选,排序 ,去重的等等的操作</p>\n</li>\n</ul>"},{"title":"如何开发/管理一个项目","author":"Arclin","abbrlink":"3c7b026b","date":"2019-10-20T07:20:00.000Z","_content":"如何管理一个项目，这是个沉重的话题。实际上，目前很多人都是凭借经验进行项目管理和开发，事实上管理项目是有着大量的方法论，这些方法论整理起来被人归纳成了一个学科，名字叫做`软件工程`，接下来的内容将会归纳总结里面的一些要点，如果你有意成为一个项目管理者，请必须了解一下这些基础知识。\n\n<!--more-->\n\n## 软件系统模型\n\n开始一个项目之前，你需要做好准备，那就是建立系统模型，有了抽象的模型，才会有具像的实现。\n - 在软件开发中，软件系统模型大体可分为两类：`概念模型`和`软件模型`。\n - 概念模型是创建在需求层上的，它描述了系统是什么。\n - 软件模型是建立在抽象层上的，它描述了实现概念模型的软件解决方案。\n - 软件模型可进一步分为`设计模型`、`实现模型`和`部署模型`。\n \n \n## 需求\n\n### 特征\n 一个完整的需求需要有以下特征：\n 1. 必要的：该需求是用户所要求的（产品经常会提一些伪需求，比如说在帖子列表添加个一键评价，点击了就回复666，但实际上没有用户想毫无感情地666，所以这是伪需求，不满足该条件的请拒绝）；\n 2. 无歧义的：该需求只能用一种方式解释（这个就不用解释了，遇到有歧义的需求请问清楚）；\n 3. 可测的：该需求可以进行测试；\n 4. 可跟踪的：该需求可以从一个开发阶段跟踪到另一个开发阶段（意思就是这个需求不会因为开发的进行变得模糊、不清晰）；\n 5. 可测量的：该需求是可测量的（意思就是实现这个需求不能无限耗费人力物力，说好这个需求两个人一天能做完，就两个人一天真的能做完）。\n \n### 类别\n\n 1. 功能需求：系统或系统构件必须执行的功能\n 2. 非功能需求：分为性能需求、外部接口需求、设计约束需求、质量属性需求。\n \n### 怎么发现需求\n\n  |名称|情况|成功条件|风险|\n  |:---:|:---:|:---:|:---:|\n  |自悟|自己想|要比你的最终客户拥有更多的一样弄领域和过程方面的知识和丰富的想象力，也就是你要比你的用户更加清楚用户要啥|无法验证你想出来的东西是不是你的用户想要的|\n  |交谈|跟你的客户聊|你能提出正确的问题，回答人能揭示需求本质的能力|可能会获得一堆需求，而且越来越多，不断增长，可能还会推翻你之前的需求，可能导致超出项目成本和进度的限制<s>（甚至可能被你的开发揍一顿）</s>|\n  |观察|你去看你的用户怎么用你的软件|你需要有洞察事物本质的能力|1. 你的用户会抵触你的观察（很明显侵犯隐私了）2. 用户会觉得你是不是这软件没做好或者哪里需求不到位所以老是来看我，对你的软件产生怀疑 |\n  |小组会|项目组的人全部叫出来开会讨论需求|你小组的人有不同观点，并且有良好的发现需求的能力，能揭示需求中存在的问题，最重要的是需求能跟用户达成共识|会议组织不到位就凉了，而且天天开会你的项目组的人也受不了，可能会提出矛盾需求|\n  |提炼|针对已有的部分需求文档，看线上反馈情况，进行提炼|你需要有想象力和需求标识能力，包括熟悉相关的技术标准|跟自悟一样，你不能知道你发现的需求是否是对的|\n \n### 需求规约\n\n需求规约就是怎么写一个需求表，因为形式很多，所以最好就根据实际情况进行，这里不做规定，但是必须包含以下几个特征\n1. 重要性和稳定性：需求要根据重要程度和稳定程度分优先级，例如：基本需求、可选需求和期望需求。\n2. 可修改的：在不过多地影响其他需求的情况下，可以容易地修改一个单一需求。\n3. 完整的：没有被遗漏的需求。\n4. 一致的：不存在互斥的需求。\n\n为什么需求规约很重要？（概念性东西）\n1. 是软件开发组织和用户之间一份事实上的技术合同书，是产品功能及其环境的体现。\n2. 对于项目的其余大多数工作，需求规约是一个管理控制点。\n3. 对于产品/系统的设计，需求规约是一个正式的、受控的起点。\n\n## 结构化方法\n\n### 结构化需求分析\n\n1. 为什么要这么做？\n\n\t为了应对三大挑战：\n\t\t- 问题空间理解。（假如让你开发一个八字排盘App，但是你又不懂八字，所以要开发出一个高质量、满足用户要求的App，就不容易了）\n\t\t- 人与人之间的通信。（开发过程长、活动多、任务重，项目组成员多，直接面对面沟通起来难免有遗漏、误解等，所以这也是一个挑战）\n\t\t- 需求的变化性。（需求是不断变化的，所以这是软件开发人员面临的挑战）\n\n\t一种好的需求技术应该具有以下基本特征：\n\n\t\t1. 提供方便通信的机子，例如，在不同开发阶段，使用对相关人员易于理解的语言。\n\t\t2. 鼓励需求分析人员使用问题空间的术语思考问题，编写文档。\n\t\t3. 提供定义系统边界的方法。\n\t\t4. 提供支持抽象的基本机制，例如，\"划分\"，\"功能抽象\"，\"结构抽象\"等。\n\t\t5. 为需求分析人员提供多种可供选择的方案。\n\t\t6. 提供特定的技术，适应需求的变化等。\n\n2. 几种基本术语的解释\n\n\t(1) 数据流：数据流是数据的流动，用于表达在分析中所要使用的、用于表达\"客体\"的信息，用箭头表示。\n\t大概长这样：\n\t<img width=50px src='https://i.loli.net/2019/10/21/wM2SkZXGDY46lQh.png'>\n\t(2) 加工：加工是数据变换的单元，即它接受输入的数据，对其进行处理，并产生输出。\n\t大概长这样\n\t<img width=50px src='https://i.loli.net/2019/10/21/mcfwVCaJI1Sn8kZ.png'>\n\t(3) 数据存储：数据存储是数据的静态结构。\n\t大概长这样(可以是横的或者竖的)\n\t<img width=50px src='https://i.loli.net/2019/10/21/xbXKc45RlYpnNB9.png'>\n\t(4) 数据源和数据潭: 数据源是数据流的起点，数据潭是数据流的归宿地。数据源和数据潭是系统之外的实体，可以是人、物或其他软件系统。\n\t大概长这样\n\t<img width=50px src='https://i.loli.net/2019/10/21/LiwWbnSAs7Pqzoh.png'>\n\n3. 数据流图\n\n\t把上面的元素组成起来就是数据流图了\n\t大概长这样\n\t<img width=70% src=\"https://i.loli.net/2019/10/21/wDdaFiLe9Ps6UzA.png\">\n\n\t几个要点：1）数据流起到连接其他实体的作用，实体可以是加工、数据存储、数据源和数据潭；2）加工之间可以有多个数据流，这些数据流之间可以没有任何关系，数据流图也不表明他们的先后次序；3）对于一个比较大的软件系统，往往需要采用多层次的数据流图。\n\t\n4. 建模过程\n\n\t1. 建立系统环境图，确立系统语境\n\t2. 自顶向下，逐步求精，建立系统的层次数据流图\n\t3. 定义数据字典。数据字典有3种基本结构表示：顺序结构，选择结构，重复结构。\n\t\t- 顺序结构是指数据A由数据B和数据C顺序构成的，并记为\"+\"。例如：学生成绩=姓名+性别+学号+科目+成绩，其中\"=\"号表达的是\"定义为\".\n\t\t- 选择结构是指由数据A是由数据B或数据C定义的，即数据B不可能同时是B和C，并记为“|”，例如：性别=男|女\n\t\t- 重复结构是指数据A是由多个重复出现的数据B构成的，并记为\"| |\"，例如：学生成绩表=|学生成绩|\n\t\t<img width=\"50%\" src=\"https://i.loli.net/2019/10/21/43hSWgZPmVirHfA.png\">\n\t4. 描述加工：该步的目标为依据系统的数据流图，给出其中每一加工的小说明。加工可以有3种表达工具。\n\t\t1. 结构化自然语言（自然语言描述）\n\t\t2. 判定表: 由条件类别，条件组合，操作，操作执行构成。举例如图<img width=50% src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D22%2C0%2C590%2C389%3Bc0%3Dbaike80%2C5%2C5%2C80%2C26/sign=d64b6fc508087bf469a30da9cfe16500/42166d224f4a20a48dfd6c499a529822730ed059.jpg\">\n\t\t3. 判定树。举例如图<img width=60%  src=\"https://i.loli.net/2019/10/21/COmGSet5I61lFsH.png\">\n\t\t\n5. 注意事项：\n\t1. 模型平衡问题\n\t2. 信息复杂性控制问题\n6. 需求验证\n\t验证需求规格说明书中的每一单一需求是否满足5个性质，即必要性、无歧义性、可测性、可跟踪性、可测量性；验证需求规格说明是否满足4个性质，即重要性和稳定程度、可修改性、完整性和一致性。在必要时还需要验证其他特性，如设计无关性。\n\t\n### 结构化设计\n\n#### 总体设计步骤\n\n结构化设计方法基于`自顶向下，功能分解`的基本原则，针对两种不同类型的数据流图，分别提出了变换设计和事务设计。其中，变换设计的目标是将变换型数据流图映射为模块结构图，而事务设计的目标是将事务型数据流图映射为模块结构图。\n\n1. 变换型数据流图和事务性和数据流图\n（1）变换型数据流图：具有比较明显的输入部分和变换部分之间的界面、变换部分和输出部分之间界面的数据流图，称为变换型数据流图；\n![](https://www.sytm.net/ueditor/net/upload/2013-12-31/bdae1434-8b79-4209-b818-2502c7ea3bee.png)\n（2）事务型数据流图：数据到达一个加工T，该加工T根据输入的值，在其后若干动作序列中选出一个来执行，这类数据流图成为事务型数据流图。\n![](https://www.sytm.net/ueditor/net/upload/2013-12-31/142b2c91-a9ad-4c6e-b075-ecd6a900ee63.png)\n\n2. 总体设计分为3个阶段。第一阶段为初始设计，在对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。第二阶段为精化设计，依据模块“高内聚低耦合”的原则精化初始的模块结构图，并设计其中的全局数据结构和每一模块的接口。第三阶段为复审阶段，对前两个阶段所得到的高层软件结构进行复审，必要时还可能需要对该软件结构做一些精化工作，这对软件的一些性质，特别是对软件质量的提高，将产生非常大的影响。\n\n3. 天天扯着嗓子喊高内聚低耦合，到底什么是内聚什么是耦合？\n\n\t- 耦合：耦合是指不同模块之间相互依赖程度的度量\n\t\t- 内容耦合：当一个模块直接修改或操作另一个模块的数据，\u001d或当一个模块直接修改或操作，另一个模块的数据或一个模块不通过正常入口转入到一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该尽量避免使用。\n\t\t- 公共耦合：两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。\n\t\t- 控制耦合：一个模块通过接口向另一个模块传递一个控制信号，接收信号的模块根据信号值进行适当的动作，这种耦合被成为控制耦合。\n\t\t- 标记耦合：若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。\n\t\t- 数据耦合：模块之间通过参数来传递数据，则称为数据耦合。数据耦合是最低的一种耦合形式。\n\t- 内聚：内聚是指一个模块内部各成分之间相互关联程度的度量\n\t\t- 偶然内聚：如果一个模块的各成分之间基本不存在任何关系，则称为偶然内聚\n\t\t- 逻辑内聚：几个逻辑上相关的功能被放在同一模块中，则称为逻辑内聚。\n\t\t- 时间内聚：如果一个模块完成的功能必须在同一时间内执行（例如，初始化系统或一组变量），但这些功能只是因为时间因素关联在一起，则称为时间内聚。\n\t\t- 过程内聚：如果一个模块内部的处理成分是相关的，而且这些处理必须以特定的次序执行，则称为过程内聚。\n\t\t- 通信内聚：如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚\n\t\t- 顺序内聚：如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚\n\t\t- 功能内聚：最理想的内聚是功能内聚，模块所有的成分对于完成单一的功能都是基本的。功能内聚的模块对完成其功能而言是充分必要的。\n\t\t\n\t- 启发式规则：无论是变换设计还是事务设计，都涉一个共同的问题，即“基于高内聚低耦合的原理，采用一些经验性的启发式规则，对初始的模块结构图进行精化，形成最终的模块结构图”。\n\t\n\t- 怎么做？\n\t\t1. 改进软件结构，提高模块独立性。\n\t\t2. 力求模块规模适中。\n\t\t3. 力求深度、宽度、扇出和扇入适中。深度：表示其控制的`层数`(不包括自身)；宽度：同一层次上模块总数的`最大值`；扇出：一个模块`直接`控制（调用）的下级模块数目；扇入：一个模块有多少个上级模块`直接`调用它。\n\t\t4. 尽力使模块的作用域在其控制域之内。作用域：受该模块内`一个判定`所影响的所有模块的集合；控制域：模块本身以及所有`直接或间接`从属于它的模块的集合。\n\t\t\n#### 详细设计步骤\n\n1. 结构化程序设计\n\t包含三种基本控制结构：顺序结构、选择结构、循环结构\n2. 详细设计工具\n\t1. 程序流程图\n\t\t<img width=20% src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945069712&di=74b11092aae0042569e80dc22ee83438&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F09%2F17%2F02%2F27798515%2F15.files%2Ffile0001.jpg\">\n\t\t缺点：不是一种逐步求精的工具，过早地考虑程序的流程，不去考虑程序的全局结构；所表达的控制流，往往不受任何约束可随意转移，从而会影响甚至破坏好的系统结构设计；不易表示数据结构。\n\t2. 盒图（N-S图）\n\t\t<img width=40% src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945228461&di=10908d6d12f9c8984356e884b3c0aeb5&imgtype=0&src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fzhidao%2Fwh%253D450%252C600%2Fsign%3Da401ed95523d26972e86005960cb9ecd%2Fd833c895d143ad4bd5fe969f81025aafa50f0698.jpg\">\n\t3. PAD图（Problem Analysis Diagram）\n\t\t<img width=\"40%\" src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945326054&di=d66d2f92c755db3f26640c2bbb6bc338&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F12%2F15%2F14%2F51872755%2F6.files%2Ffile0001.jpeg\">\n\t\n\tN-S图和PAD图支持“自顶向下逐步求精”的设计。可节省人工编码工作，有利于提高软件的可靠性和软件生产率\n\t\n\t4. 类程序设计语言（伪码/PDL）\n\t\t是一种用正文形式表示数据结构和处理过程的设计工具，PDL是一种“混合”的语言。\n3. 设计规约\n\t完成软件设计后，应产生设计规约，完整准确地描述满足系统需求规约所要求的的所有功能模块，以及伴随功能模块而出现的非功能机制。设计规约通常包括`概要设计规约`和`详细设计规约`。\n\t\n\t`概要设计规约`指明高层软件体系结构，其主要功能如下：\n\t\n\t1.系统环境等与设计有关的限定条件 2. 软件模块的结构（模块之间的接口及设计的数据流和主要数据结构）3. 模块描述（接口定义，模块处理逻辑，必要的注释等）4. 文件结构和全局数据文件的逻辑结构 5.测试需求\n\t\n\t`详细设计规约`（包括各处理过程的算法和算法所涉及的全部数据结构的描述）主要作为软件设计人员与程序员之间交流的媒体。\n\t\n## UML\n\n### UML是一种图形化建模语言（Unified Modeling Language）\n\n为了支持抽象分析和设计中的事物，UML给了八个基本术语，即类、接口、协作、用况、主动类、构件、制品、节点、\n- 类： 类是一组拥有相同属性、操作、关系和语义的对象的描述。类主要用于抽象客观世界中的事物。\n- 接口：每个操作描述了类、构件或子系统的一个服务，接口就是操作的一个集合。接口是对系统/产品的“接缝”予以模型化，表明了一个类、构件、子系统所需要得到的、且与实现无关的行为。\n- 用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的、可观察的结果。\n- 协作：协作是一个交互，涉及交互的三要素：交互各方、交互方式以及交互内容\n- 用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的，可观察的结果。\n- 主动类：主动类是一种至少具有一个进程或线程的类。\n- 构件：构件是系统设计中的一种模块化部件，通过外部接口隐藏了它的内部实现。\n- 制品：制品是系统中包含物理信息（比特）的、可替代的物理部件。\n- 节点：节点是运行时存在的物理元素，通常表示一种具有记忆能力和处理能力的计算机资源。\n\t\n类在建模中的主要用途：\n1. 模型化问题域中的概念\n2. 建立系统的职责分布模型\n3. 模型化建模中使用的基本类型\n\n使用接口应注意的问题\n1. 接口只可以被其他类目使用，而本身不能访问其他类目\n2. 接口描述类的外部可见操作，通常是该类的一个特有限定行为。这些操作可以使用可见性、并发性、衍型、标记值和约束来修饰。\n3. 接口不描述其中操作的实现，也没有属性和状态。据此可见，接口在形式上等价于一个没有属性、没有方法而只有抽象操作的抽象类\n4. 接口之间没有关联、泛化、实现和依赖。但可以参与泛化、实现和依赖\n\t\n### 表达关系的术语\n\n\t关联：关联是一组具有相同结构、相同链的描述，是类目之间的一种结构关系。关联可以用一条连接两个类目的线段表示，并可对其命名，其结构可以具有方向性，用一个实心三角形来指示关联的方向。\n\t\t1. 关联名 。\n\t\t2. 导航：对于一个给定的类目，可以找到与之关联的另一个类目，这称为导航。\n\t\t3. 角色：角色是关联一端的类目对另一端的类目的一种呈现。\n\t\t4. 可见性：通过导航可以找到另一类目的实例，有时候需要限制访问。\n\t\t5. 多重性：类中对象参与一个关联的数目，成为该关联的多重性\n\t\t6. 限定符：限定符是一个关联的属性或属性表。\n\t\t7. 聚合：分类是增强客观实际问题语义的一种手段。聚合是对象之间（不是类之间）的一种结构关系。\n\t\t8. 组合：组合是聚合的一种特殊形式\n\t泛化：泛化是一般性类目和它的较为特殊类目之间的一种关系。子类可以继承父类的属性和操作，同时也可以替换父类的声明。\n\t\t泛化的四种约束：完整、不完整、互斥、重叠\n\t细化：细化是类目之间的语义关系，其中一个类目规约保证了另一个类目执行的契约。\n\t依赖：依赖用于描述一个类目使用另一个类目的信息和服务，是一种使用关系。\n\t\t依赖的分类：绑定、导出、允许、示例、实例化、幂类型、精化、使用。\n\t\t\n\t关联、泛化和细化都是一类特地类型的依赖。\n\t\n\t使用这四种术语，可以模型化以下各种关系：\n\t1. 结构关系（静态结构和动态结构）\n\t\t进行模型化时两种驱动方式：1.以数据驱动 2. 以行为驱动\n\t2. 继承关系\n\t3. 精化关系\n\t4. 依赖关系\n\t\n### 表达组合信息的术语————包\n\n为了控制信息组织的复杂性，UML提供了组织信息的一种通用机制————包，支持形成一些可管理的部分。换言之，包可以作为“模块化”和“构件化”的一种机制。\n\n包是模型元素的一个分组。一个包本身可以被嵌套在其他包中，并且可以含有子包和其他种类的模型元素。\n\n通过在包的名字前加上一个可见性符号（+，-，#），来指示该包的可见性。\n\n```\n+ 表示对其他包而言都是可见的\n# 表示对子孙包而言是可见的\n- 表示对其他包而言都是不可见的\n```\n\n为了模型化包之间的关系，UML给出了两种依赖，即访问和引入。\n- 访问：表明目标包中的内容可以被源包所引用，或被那些递归嵌套在源包中的其他包所引用。\n- 引入：表明目标包中具有适当可见性的内容（名字）被加入到源包的公共命名空间中。\n\nUML中用虚线加箭头的方式表示源包到目标包的依赖（访问和引入）。\n\n### UML术语的作用\n\n1. 类用于抽象客观事物\n2. 接口用于抽象事物之间的缝隙\n3. 协作用于抽象协作性行为\n4. 用况用于抽象功能\n5. 主动类用于抽象并发行为\n6. 构件用于抽象软件解中标识的成分\n7. 制品用于抽象工作产品\n8. 节点用于抽象计算单元\n9. 关联用于抽象结构关系\n10. 泛化用于抽象“一般/特殊”关系\n11. 实现用于抽象精化关系\n12. 依赖用于抽象使用关系\n\n### UML的模型表达式\n\n1. 结构图和行为图\n\t结构图用于表达系统或系统成分的静态结构模型，给出系统或系统成分的一些说明性信息\n\t行为图用于表系统或系统成分的动态结构模型，给出系统或系统成分的一些行为信息\n2. 类图、用况图、顺序图及状态图\n\t- 类图是可视化地表达系统静态结构功能模型的工具，使用类图所表达的系统静态结构模型，给出的是一些关于系统的说明性信息。\n\t![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176025075&di=1875f9ac829f33a38a45131069ee3e4a&imgtype=0&src=http%3A%2F%2Fimages.cnblogs.com%2Fcnblogs_com%2Fa-i%2FUml2.JPG)\n\t- 用况图是一种表达系统功能模型的图形化工具，它包含六个模型元素，分别是主题、用况、参与者、关联、泛化、依赖\n\t![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176303343&di=4146dfc9badef7bc95f4c750ab149eb0&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F09%2F24%2F23%2F28839740%2F23.files%2Ffile0001.png)\n\t- 顺序图由一组对象以及按时序组织的对象之间的关系组成，是一种交互图，包含对象之间传递的信息。控制操作包括`选择执行操作`、`条件操作`、`并发迭代操作`、`迭代执行操作`。\n\t![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176439921&di=d592e65ae4a1bc1c2e65a98e415a897a&imgtype=0&src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fpng%2F20180615101636402475.png)\n\t- 状态图强调了从一个状态到另一个状态的控制流，是显示一个状态机的图。状态图由状态、事件和状态转移构成。使用状态图的作用有两个：一是创建一个系统的动态模型，二是创建一个场景的模型\n\t![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176576658&di=70e3de58666cf1d7315cf56a05ec0d35&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F12%2F07%2F08%2F48638362%2F25.files%2Ffile0001.png)\n\t-\n3. 创建一个系统的类图的步骤\n\t- 模型化代建系统中的概念，形成类图中的基本元素\n\t- 模型化代建系统中的各种关系，形成该系统的初始类图\n\t- 模型化系统中的协作，给出该系统的最终类图\n\t- 模型化逻辑数据库模式\n4. 信号事件、调用事件、时间事件和变化事件\n\t- 信号事件是一种异步事件，信号通常由状态机处理。如果没有定义对该事件的响应，那么事件均可能丢失。事件的丢失，就有可能引发接受者——状态机的一个错误的状态转移。\n5. 状态转移所涉及的内容\n\t描述一个状态转换，一般涉及五个部分：\n\t1. 源状态：发生状态转移的那个状态\n\t2. 转移触发器：在源状态中由对象识别的事件，并且一旦满足其监护条件，则使状态发生转移。\n\t3. 监护条件：一个布尔表达式，当某个事件触发器接受一个事件时，如果该表达式有值为真，则触发一个转移；若有值为假，则不发生状态转移。\n\t4. 效应：一种可执行的行为\n\t5. 目标状态：转移完成后所处的状态\n6. 最常用的控制操作子\n\t选择执行操作子：该操作子由两部分组成：一是监护条件，二是控制体\n\t条件执行操作子：控制体通过水平线将其分为一些部分，每一部分表示一个条件分支，每一分支有一个监护条件。\n\t并发执行操作子：该控制操作子的体通过水平线将其分为多个部分，每一部分表示一个并行计算。该控制操作子表明，当进入该控制操作子是，所有部分并发执行。\n\t迭代执行操作子：该控制操作子表明，只要在每一次迭代之前该监护条件为真，那么该控制体就反复执行，当该控制体上面的监护条件为假时，控制绕过该控制操作子。\n7. 子状态机、简单状态和组合状态的概念\n\t子状态机：为了有效地组织状态、控制对象状态的复杂性，UML提供了组合状态，在一个状态机中引入了另一个状态机。被引入的状态机就称为子状态机。\n\t简单状态：子状态是被嵌套到另一状态中的状态。相对地，被引入的状态机就称为子状态机。\n\t组合状态：把含子状态的状态称为组合状态，组合状态可包含两种类型的子状态机，即非正交（顺序）子状态机和正交（并发）子状态机。\n## RUP\n\n### RUP(Rational Unified Process)的特点\nRUP的突出特点是，它是一种以用况（Use Case）为驱动的、以体系结构为中心的迭代、增量式开发。\n1. 以用况为驱动\n以用况为驱动是指在系统的生存周期中，以用况作为基础，驱动系统有关人员对所要建立系统的功能需求进行交流，驱动系统分析、设计、实现和测试等活动。\n2. 以体系结构为中心\n以体系结构为中心是指在系统的生存周期中，开发的任何阶段都要给出相关模型视角下有关体系结构的描述，作为构思、构造、管理和改善系统的主要标准。\n3. 迭代、增量式开发\n迭代、增量式开发是指通过开发活动的迭代，不断地产生相应的增量。在RUP中，规定了四个开发阶段：初始阶段、精化阶段、构造阶段和移交阶段。\n\n### 核心工作流\n核心工作流：需求获取、分析、设计、实现和测试\n#### 需求获取\n\n|基本步骤|产生的制品|\n|:---:|:---:|\n|列出候选的特征|特征表|\n|理解系统语境|领域模型或业务模型|\n|捕获功能需求|用况模型|\n|捕获非功能需求|补充需求或针对特殊需求的用况|\n\n### 业务用况模型和业务对象模型\n\n1. 业务用况模型。业务用况模型是以用框图予以表达的\n2. 业务对象模型。为了精化业务用况模型中的每一个业务用况，RUP引入了三个术语，用于表达参与业务的业务对象：`工作人员`、`业务实体`和`工作单元`。业务对象模型可通过交互图和活动图予以表达。\n\n### 标识用况应注意的问题\n\n1. 建立用况的结构中，应尽可能反映用况的实际情况。\n2. 在用况的结构化中，不论是施加什么结构，新引入的用况都不应该太小或太大\n3. 在建立用况的结构是，应尽量避免对用况模型中的用况功能进行分解。\n\n#### 需求分析\n\n1. 分析类是类的一种衍型，分为边界类、实体类和控制类\n2. 用况细化时一个协作，针对一个用况，其行为可用多个分析类之间的相互作用来细化，并记为用况细化。用况细化对用况模型中的一个特定的用况提供了一种直接跟踪的方式。\n3. 分析包是一种控制信息组织复杂性的机制，提供了分析制品的一种组织手段。其主要特征为：体现问题的分离；高内聚、低耦合；尽可能体现一个系统的完整顶层设计，尽可能成为一些子系统或者成为一些子系统的组成部分。\n\t\n#### 具有良好结构的分析包的特征\n\n1. 体现问题分离\n2. 高内聚、低耦合。\n3. 尽可能提现一个系统的完整顶层设计。\n\n#### 软件设计层上的术语\n\n软件设计是满足需求规约所需要的软件结构。RUP为了满足系统/产品分析模型规约需求的软件结构，为设计层提供了是个术语：设计类、用况细化、设计子系统和接口，用于表达软件结构中的基本元素。\n\n1. 设计类：一个设计类是对系统中实现一个类或类似构造的一个无缝抽象\n2. 用况细化：用况细化是设计模型的一个协作，其中使用设计类及其对象，描述一个特定用况是如何予以细化的，是如何执行的\n3. 设计子系统：设计子系统可以包含设计类、用况细化、接口，以及其他子系统，通过对其操作来显示其功能。\n4. 接口：接口用于规约由设计类和设计子系统，必须提供与该接口操作对应的实现方法。\n\n#### 创建系统/产品用况模型的活动和任务\n\n创建系统/产品用况模型的活动和任务如下\n1. 活动一：发现并描述参与者\n任务1：发现参与者，即直接发现一些候选的参与者\n任务2：描述参与者，即对参与者进行命名并描述\n2. 活动二：发现用况并对用况进行描述\n任务1：发现用况\n任务2：描述用况，即确定用况后对其进行描述\n3. 活动三：确定用况的优先级，目的是在寻找参与者并对其进行描述和发现用况的并对用况进行描述的基础上确定哪些用况适合在早期的迭代中开发，哪些适合在后期的迭代中开发。\n4. 活动四：精化用况。这一活动的目的是详细描述出每一用况的事件流，包括用况是怎样开始的，是怎样结束的，是怎样与参与者进行交互的，最终形成一系列精化的用况\n5. 活动五：构造用户界面原型。这一活动的目的在于建造用户界面原型，使用户可以有效地执行用况。\n6. 活动六：用况模型的结构化。需要进行以下工作。\n\t1. 抽取用况描述中的那些一般性的和共享的功能并使用泛化关系标识和描述那些共享功能\n\t2. 抽取用况描述附加的或可选的功能\n\t3. 标识用况之间的包含关系。通过用况模型的结构化，最终形成一个系统/产品的精化用户模型\n\t\n#### 创建系统/产品需求分析模型的活动和任务\n1. 活动1：体系结构分析。该活动的目标是通过标识分析包和分析类，建立分析模型和体系结构“骨架”，并标识有关分析包和分析类的特定需求。\n任务1：标识分析包。该任务的基本输入是系统的用况模型\n任务2：处理分析包之间的共性\n任务3：标识服务包\n任务4：定义分析包的依赖，该任务的目标是发现相对独立的包，实现包的高内聚和低耦合\n任务5：标识重要的实体类，该任务的目标是标识在体系结构方面具有意义的实体类。\n任务6：标识分析包和重要实体类的公共特定需求，该任务的目标是依据需求获取阶段所标识的非功能需求，针对在分析期间所标识的包和分析类，标识它们的一些公共的特定要求。\n2. 活动2：用况分析。该活动的目标是：一是标识那些在用况事件流执行中所需要的分析类和对象；二是将用况的行为分布到参与交互的各个分析对象；三是捕获用况细化上的特定需求。\n任务1：标识分析类，该任务的目标是标识在细化一个用况中所需要实体类、控制类和边界类，给出它们的名字、责任、属性和关系。\n任务2：描述分析类对象之间的交互。首先确定细化该用况所必要的交互，其次分派该用况的功能，最后根据其责任，发现该交互图中的各个链。\n3. 活动3：类的分析。该活动的目标：一是标识并维护分析类的属性和关系；二是捕获分析类细化中的特殊需求。\n任务1：标识责任，通过组合一个类在不同用况细化中所扮演的角色来完成。\n任务2：标识属性\n任务3：标识关联和聚合\n4. 活动4：包的分析。该活的目标是：一是确保分析包尽可能与其他包相对独立；而是确保分析包实现了它的目标；三是描述依赖，以益于可以估计未来的变化。\n\n###  创建系统/产品设计模型的活动和任务\n创建系统/产品设计模型的活动和任务如下：\n1. 活动1：体系结构设计，该活动的目标是创建设计模型和部署模型，以及它们视角下的体系结构描述\n任务1：标识节点和它们的网络配置，网络配置通常使用一种三元模式：客户端、数据库功能、业务/应用逻辑\n任务2：标识子系统和它们的接口，目的是为了寻求一些复用的可能，而后随着设计模型的开发，在形成子系统结构中不断发现并烟花。\n任务3：标识在体系结构方面有意义的设计类和它们的接口。标识在体系结构方面有意义的设计类的基本思想是：初始可以依据在体系结构方面有意义的分析类来标识一些体系结构上具有重要意义的设计类。标识在系统体系结构方面有意义的设计类时，应注意主动类往往是一类在体系结构方面具有重要意义的类。\n2. 活动2：用况的设计。其中分析模型用况细化分析是活动的输入、对应输出用况细化设计。\n为了实现用况设计的输入/输出，一般采用两种方法：\n\t1. 标识参与用况细化的设计类，首先基于分析模型研究相应用况细化分析中的分析类，来标识为细化这些分类所需要的设计类，然后基于用况的功能对每一个标识的设计类赋予相应的责任，最后为该细化创建一个类图，汇聚参与该用况细化的设计类，并给出类之间的关系。\n\t2. 标识参与用况细化的子系统和接口。\n3. 活动3：类的设计。该活动的目标是完成用况细化设计中每一个类的角色设计，并完成有关每一类的非功能需求的设计。\n任务1：概括描述设计类，该任务的输入为分析类/接口。\n任务2：标识的操作，一般应依据分析类来标识设计类所提供的、所需要的操作，其中需要使用程序设计语言的语法来描述说标识的操作。\n任务3：标识属性，该任务的目标是标识设计类所需要的属性，并使用程序设计语言的语法给出属性的描述。\n任务4：标识关联和聚合。\n任务5：标识泛化，基于分析模型中分析类之间的泛化，可以发现设计模型中的很多泛化。\n任务6：描述方法，在设计期间一般用自然语言或适当的使用伪码对方法进行规约，但是在实现期间直接使用程序设计语言对方法进行规约。\n任务7：描述状态，有些设计对象是受状态控制的，即它们的状态确定了它们接受一个消息的行为。在这种情况下，使用一个状态图描述一个对象的不同状态转移是有意义的。\n4. 活动4：子系统的设计。该活动的目标是：确保子系统尽可能独立于其他子系统或它们的接口；确保子系统提供正确的接口；确保子系统实现了它的目标，即给出了该子系统提供的那些接口所定义的操作的细化。\n\n### 设计模型包含的元素\n\nRUP设计的主要结果是设计模型，它尽量保持该系统具有分析模型的结构，并作为系统实现的输入，包含以下四个元素：\n\n1. 设计子系统和服务子系统，以及它们的接口、依赖和内容。\n2. 设计类以及它们具有的操作、属性、关系及其实现的需求。\n3. 用况细化设计。\n4. 设计模型视角下的体系结构描述。\n\n### 用况模型与分析模型的比较\n\n|用况模型|分析模型|\n|:----:|:---:|\n|使用客户语言来描述 |使用开发者语言来描述 |\n|给出的是系统对外的视图 | 给出的是系统对内的视图 |\n|使用用况予以结构化，但给出的是外部视角下的系统结构 | 使用衍型类予以结构化，当给出的是内部视角下的系统结构 |\n|可以作为客户与开发者之间关于“系统应该做什么，不应该做什么”的契约 |可以作为开发者理解系统如何勾画、如何设计和如何实现的基础|\n|在需求之间可能存在一些冗余、不一致和冲突等问题|在需求之间不应存在冗余、不一致和冲突问题|\n|捕获的是系统的功能，包括在体系结构方面有意义的功能|给出的是细化的系统功能，包括在体系结构方面具有意义的功能|\n|定义了一些进一步需要在分析模型中予以分析的|定义了用况模型中每一个用况的细化|\n\n### RUP实现活动\n\n目标：基于设计类和子系统生成构件；对构件进行单元测试，进行集成和连接；把可执行的构件映射到部署模型。\n\n|输入|活动|执行者|输出|\n|:----:|:---:|:---:|:---:|\n|设计模型、部署模型、体系结构描述【设计模型、部署模型角度】|实现体系结构|体系结构设计者|构件【概述】、体系结构描述【实现模型、部署模型角度】|\n|补充需求、用况模型、设计模型、实现模型【当前建造】|集成系统|系统集成者|集成建造计划、实现模型【连续的建造】|\n|集成建造计划、体系结构描述【实现模型角度】、设计子系统【已设计】、接口【已设计】|实现子接口|构件工程师|实现子系统【建造完成】、接口【建造完成】|\n|设计类【已设计】、接口【由设计类提供】|实现类|构件工程师|构件【完成】|\n|构件【完成】、接口|完成单元测试|构件工程师|构件【已完成单元测试】|\n\n### RUP测试活动\n\nRUP的测试包括内部测试、中间测试和最终测试\n\n|输入|活动|输出|\n|:----:|:---:|:---:|\n|补充需求、用况模型、分析模型、设计模型、实现模型、体系结构的描述|计划测试|测试计划|\n|补充需求、用况模型、分析模型、设计模型、实现模型、体系结构描述、测试计划|设计测试|测试用况 测试过程|\n|测试用况、测试过程、实现模型|实现测试|测试构件|\n|测试用况、测试过程、测试构件、实现模型|执行集成测试|缺陷|\n|测试用况、测试过程、测试构件、实现模型|执行系统测试|缺陷|\n|测试用况、测试模型、缺陷|评价测试|测试评价|\n\n## 软件测试\n\n### 软件测试目标与软件测试过程模型\n\n#### 软件测试及目标\n\n软件测试的定义为：按照特定规程发现软件错误的过程。其目的是检验它是否满足规定的需求，或清楚了解预期结构与实际结果之间的差异\n\n#### 软件测试与软件调试之间的区别\n\n软件测试与软件调试相比，在目的、技术和方法等方面都存在很大区别，主要表现在以下几个方面。\n1. 测试从一个侧面证明程序员的\"失败\".调试是为了证明程序员的正确。\n2. 测试以已知条件开始，使用预先定义的程序且有预知的结果，不可预见的仅是程序是否通过。调试一般是以不可知的内部条件开始，除统计性调试外，结果是不可预见的。\n3. 测试是有计划的，并要进行测试设计。调试是不受时间约束的。\n4. 测试是一个发现错误、改正错误、重新测试的过程。调试是一个推理过程。\n5. 测试的执行是有规程的。调试的执行往往要求程序员进行必要推理。\n6. 测试经常是由独立的测试组在不了解软件设计的条件下完成的。调试必须由了解详细设计的程序员完成。\n7. 大多数测试的执行和设计可由工具支持。调试时，程序员能利用的主要工具是调试器。\n\n#### 测试过程模型\n\n软件测试是一个有程序的过程，包括测试设计、测试执行以及测试结果比较。测试过程模型可分为三类：环境模型、被测对象模型和错误模型。\n\n1. 环境模型：是对程序运行环境的抽象。程序运行环境又包括支持其运行的硬件、固件和软件，如计算机、终端设备、网卡、操作系统、编译系统、实用程序等。在软件测试过程中，建立环境模型的主要目的是，确定所发现的错误是否为环境造成的。\n2. 被测对象模型：该模型是从测试的角度对程序的抽象。为了测试，必须简化程序，形成被测程序的抽象版本、即对象模型。\n3. 错误模型：该模型是对程序中的错误及其分类的抽象。在软件测试中，往往需要定义“什么是错误”、“什么是一般性错误”、“什么是严重性错误”等，即要给出“错误模型”。\n\n### 软件测试技术\n\n1. 测试覆盖及其他们之间的基本关系\n软件测试技术大体上可分为两大类：一类是白盒测试技术，又称为结构测试技术，典型的是路径测试技术；另一种是黑盒测试技术，又称为功能测试技术，包括事务处理流程技术、状态测试技术、定义域测试技术等。白盒测试技术依据的是程序的逻辑结构，而黑盒测试技术依据的是软件行为的描述。\n2. 路径测试技术的分类\n\n\t测试覆盖包括路径覆盖、分支覆盖、条件覆盖与条件组合覆盖。\n\n\t1. 路径覆盖：执行所以有可能穿过程序控制流程的路径。在路径测试中，该度量是最强的，一般是不可实现的。\n\t2. 语句覆盖：至少执行程序中所有语句一次\n\t3. 分支覆盖：至少将程序中的每一个分支执行一次\n\t4. 条件覆盖与条件组合覆盖：条件覆盖是指每个判定中所有的可能的条件的取值至少执行一次；条件组合覆盖是指设计足够的测试用例，使每个判定中所有可能的条件取值组合至少执行一次。\n\t\n\t这四种测试覆盖的测试覆盖率由弱到强的顺序是：语句覆盖 < 分支覆盖 < 条件组合覆盖 < 路径覆盖\n\n3. 事务流测试步骤\n\n\t事务流测试步骤具体如下。\n\t第一步：获得事务流程图。\n\t第二步：浏览、复审。\n\t第三步：用例设计。\n\t第四步：测试执行。\n\t\n4. 运用等价类划分技术进行测试的步骤\n\n\t具体测试步骤如下。\n\t第一步：建立等价类表\n\t第二步：为有效等价类设计测试用例\n\t第三步：为无效等价类至少设计一个测试用例\n\t\n5. 边界值分析的使用原则\n\n\t边界值分析是一种常用的黑盒测试技术。使用边界值分析在设计测试用例时，可以遵循以下原则。\n\t\n\t1. 如果某个输入条件规定了输入值的范围，则应该选择正好等于边界值的数据，以及刚刚超过边界值的数据作为测试数据。\n\t2. 如果某个输入条件规定了值的个数，则可用最大个数、最小个数、比最大个数多1、比最小个数少1的数据作为测试数据\n\t3. 根据规格说明的每个输出条件，使用前面的原则1\n\t4. 根据规格说明的每个输出条件，使用前面的原则2\n\t5. 如果程序的规格说明中，输入域或输出域是有序集合，在实践中则经常选取集合的第一个元素、最后一个元素以及典型元素作为测试用例。\n\t6. 如果程序中使用了内部数据结构，则应该选择这个内部数据结构的边界上的值作为测试用例。\n\t7. 分析规格说明，找出其他可能的边界条件。\n\t\n6. 使用因果图生成测试用例的步骤\n\n\t因果图技术是通过为判定表的每一列设计一个测试用例，从而实现测试用例的设计与选择的。该方法生成测试用例的基本步骤如下。\n\n\t1. 通过软件规格说明书的分析，找出一个模块的原因和结果，并给每个原因和结果赋予一个标识符\n\t2. 分析原因与结果之间以及原因之间对应的关系，并画出因果图。\n\t3. 在因果图上标识出一些特定的约束或限制条件。\n\t4. 把因果图转换成判定表。\n\t5. 把判定表的每一列拿出来作为依据，设计测试用例。\n\t\n### 软件测试步骤\n\n1. 单元测试\n\t单元测试主要检验软件设计的最小单元---模块。该测试以详细设计文档为指导，测试模块内的重要控制路径。一般来说，单元测试往往采用白盒测试技术。\n\t\n2. 集成测试\n\t集成测试是软件组装的一个系统化技术，其目标是发现与接口有关的错误，将经过单元测的模块构成一个满足设计要求的软件结构。集成测试集中于模块组合的功能和软件结构检验。集成测试可“自顶向下”地进行，称为自顶向下的集成测试；也可以“自底向上”地进行测试，称为自底向上的集成测试\n\n3. 有效性测试\n\t有效性测试的目标是发现软件实现的功能与需求规格说明书不一致的错误。因此有效性测试通常采用黑盒测试技术。\n\t\n4. 系统测试\n\t系统测试验证将软件融于更大系统中时整个系统的有效性。\n\n## 软件生存周期过程与管理\n\n### 软件生存周期过程概述\n\n1. 过程分类\n\n\t按过程主体把软件生存周期过程分为以下几个过程。\n\t1. 基本过程：是指那些与软件生产直接相关的活动集。该过程又可分为获取过程、供应过程、开发过程、运行过程和维护过程。\n\t2. 支持过程：是指有关各方按他们的目标所从事的一系列相关支持活动集。该过程又可分为文档过程、配置管理过程、质量保证过程、验证过程、确认过程、联合评审过程、审计过程和问题解决过程。\n\t3. 组织过程：是指那些与软件生产组织有关的活动集。该过程又可分为设计过程、基础设施过程、培训过程和改进过程。\n\t\n2. 系统语境的过程类\n\t系统语境的过程类包含四个过程组，分别是协议过程组、项目过程组、技术过程组和组织上项目使能过程组。\n\t1. 协议过程组包含两个过程：获取过程和供应过程。\n\t2. 项目过程组包含七个过程：项目规划过程、项目评价过程、决策管理过程、风险管理过程、配置管理过程、信息管理过程和测量过程。\n\t3. 技术过程组包含11个过程：利益攸关方需求定义过程、系统需求分析过程、系统体系结构设计过程、实现过程、系统集成过程、系统测试过程、软件安装过程、软件接受支持过程、软件运行过程、软件维护过程和软件销毁过程。\n\t4. 组织上使能过程组包含五个过程：生存周期模型管理过程、基础设施管理过程、项目包管理过程、人力资源管理过程和质量管理过程。\n\t\n3. 组织上使能过程的作用。\n\t组织上使能的过程一般来说是组织层面上的工作，为项目的执行提供基本保障。该过程包含五个子过程。\n\t1. 生存周期模型管理过程：其任务为过程建立、过程评估、过程改进。\n\t2. 基础设施管理过程：其任务为过程实现、基础设施的建立、基础设施的维护。\n\t3. 项目包管理过程：项目初始化、项目包评估、项目结束处理。\n\t4. 人力资源管理过程：其任务为技能标识、技能开发、技能获取和供给、知识管理。\n\t5. 质量管理过程：其任务为质量管理、质量管理纠正措施。\n\n### 过程描述\n\n软件验证过程包括两个活动：过程实现和验证。其中验证活动有五个任务：需求验证、设计验证、代码验证，集成验证和文档验证。\n\n一个过程可通过过程意图，期望的结果以及到达过程结果需要执行的活动和任务来描述。对于一个过程的完整技术上的描述，还应包括：达到过程意图和实现过程结果的方法或规程，以及过程和活动文档。\n\n### 应用说明\n\n1. 系统和软件的关系\n\n\t在《ISO/IEC系统与软件工程-软件生产周期过程12207-2008》标准中，把软件认为是整个系统的一个组成从部分，执行系统中所确定的功能主要包括三大功能：控制功能、耦合功能以及软件本身提供的功能。由于软件通常存在与一个系统的上下文中，因此软件产品或服务一般可被认为是系统的一个项或称为系统元素。\n\t\n2. 剪裁过程及应用\n\n\t剪裁过程是使剪裁这一标准过程慢速以下特定情况或因素。\n\t1. 围绕一个组织，其中该组织在一个协议中使用了这一标准\n\t2. 影响一个项目，其中要求该项目满足一个引用该标准的协议\n\t3. 反映一个组织的需要，其中该组织要供给产品或服务\n\t\n### 软件生存周期模型\n\n1. 瀑布模型\n\n\t瀑布模型是将软件生存周期各个活动规定为按固定顺序链接的若干阶段的模型。这一模型规定了个开发阶段的活动：系统需求、软件需求、需求分析、设计、编码、测试和运行，并且自上而下具有相互衔接的固定顺序；还规定了每一个阶段的输入，即工作对象以及本阶段的工作成果，作为输出传送到下一阶段。\n\n\t瀑布模型的提出，对软件工程的主要贡献如下。\n\t1. 在决定系统怎样做之前存在一个需求阶段，它鼓励对系统做什么进行规约。\n\t2. 在系统构造之前存在一个需求阶段，它鼓励规划系统结构。\n\t3. 在每一阶段结束时进行评审，从而允许获取方和用户的参与。\n\t4. 前一步可以作为下一步被认可的、文档化的基线，并允许基线和配置早期接受控制。\n\n\t瀑布模型的主要问题是：\n\n\t1. 要求客户能完整、正确和清晰地表达他们的需求；并要求开发人员一开始就要理解这一应用。\n\t2. 由于需求的不稳定性，使设计、编码和测试阶段都可能发生延期；并且当项目接近结束时，出现了大量的集成和测试工作。\n\t3. 在开始的阶段中，很难评估真正的进度状态；并且直到项目结束之前都不能演示系统的能力。\n\t4. 在一个项目的早期开发阶段，过分地强调了基线和里程碑处的文档；并可能需要花费更多的时间用于建立一些用处不大的文档。\n\t\n2. 增量模型\n\n\t增量模型是一种非整体开发的模型。软件在该模型中逐渐开发出来，开发出一部分，向用户展示一部分，可让用户及早看到部分软件，及早发现问题。该模型具有较大的灵活性，适合软件需求不明确、设计方案有一定风险的软件项目。\n\n3. 演化模型\n\n\t该模型主要针对事先不能完整定义需求的软件开发在用户提出待开发系统的核心需求的基础上，软件开发人员按照这一要求，首先开发一个核心系统并投入运行，以便用户能够有效地提出反馈，即精化系统、增强系统能力的需求；接着，软件开发人员根据用户反馈，实施开发的迭代过程；每一迭代过程均由需求、设计、编码、测试、集成等阶段组成，为整个系统增加一个可定义的，可管理的子集；如果在一次迭代中，有的需求不能满足用户的要求，可在下一次迭代中予以修正。\n\n\t主要特征：该模型显式地把需求获取扩展到需求阶段，既为了第二个构造增量，使用了第一个构造增量来精化需求。演化模型在一定程度上可以减少软件开发活动的盲目性。\n不足之处：在演化模型的使用中，即使很好地理解了需求或设计，也很容易弱化需求分析阶段的工作。\n\n4. 螺旋模型\n\n\t螺旋模型将瀑布模型与增量模型结合起来，加入了两种模型均忽略了的风险分析，弥补了这两种模型的不足。因而它是一种风险驱动的模型。螺旋模型将开放过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合。\n\n\t螺旋模型关注解决问题的基本步骤，即标识问题，标识一些可选方案，选择一个最佳方案，遵循动作步骤并实施后续工作。其一个突出特征是，在开发的迭代中实际上只有一个迭代过程真正开发了可交付的软件。螺旋模型与演化模型和增量模型相比，同样适用了瀑布模型作为一个嵌入的过程，但螺旋模型所关注的阶段以及它们的活动是不同的。如果项目的开发风险很大或客户不能确定系统需求，在更广泛的意义上来讲，还包括一个系统或系统类型的要求，这时螺旋模型就是一个很好的生存周期模型。\n\n5. 喷泉模型\n\n\t喷泉模型体现了软件创建所固有的迭代和无间隙的特征。该模型主要用于支持面向对象技术的软件开发。由于对象概念的引入，使分析、设计、实现之间的表达没有明显间隙。\n\n### 过程规划与管理\n\n1. 创建一个软件项目生存周期过程的步骤\n\n\t1. 选择软件生存周期模型\n\t2. 细化所选择的生存周期模型\n\t3. 为每一个活动或任务标识合适的实例数目\n\t4. 确定活动的时序关系，并检查信息流\n\t5. 建立过程计划的文档\n\t\n2. 软件评估中应考虑的影响因素\n\n\t1. 不管做怎么样的决策，都必须对所采取的的措施对生存周期过程所产生的影响进行评审，以便保证项目获得好的结果。在这一评估中，应考虑以下几方面的影响。\n\t\t1. 所要求的的“返工”\n\t\t2. 资源需求\n\t\t3. 实施时间\n\t\t4. 对项目和用户的益处\n\t\t5. 员工情绪\n\n## 集成化能力成熟度模型（CMMI）\n\n### 背景和原理\n\n1. 过程改善\n\n\t历史过程改善，是指人为设计的一个活动程序，其目的是改进组织的过程性能和成熟度，并改进这一程序的结果\n\n2. 过程域、专用目标和共用目标\n\n\t过程域是一个业务域中一束相关的实践，当它们一起得以实现时，就满足被认为对该过程域的改善具有重要作用的一组条件\n\t专用目标是用于描述满足该过程域必须呈现的一些独有特征。经可以用于帮助确定一个过程域是否得以满足。\n\t共用目标用于描述产现制度化的该过程必须呈现的特征，仅用于确定一个过程域是否得以满足。\n\n### CMMI的模型部件\n\n|过程域类名|包括的过程域|\n|:---:|:---|\n|项目管理类|项目规划<br/>项目监控<br/>定量项目管理<br/>集成项目管理<br/>风险管理<br/>提供方协议管理|\n|工程类|需求开发<br/>需求管理<br/>技术解决方案<br/>产品集成<br/>确认<br/>验证|\n|支持类|配置管理<br/>过程和产品质量保证<br/>测量与分析<br/>原因分析与解决<br/>决策分析与解决|\n|过程管理类|组织过程定义<br/>组织过程性能<br/>组织过程培训<br/>组织过程关注<br/>组织创新与部署|\n\n### CMMI的等级\n\n1. 能力等级的组成\n\n\t能力等级是用来表征组织对一个过程域的改善，是不断改善一个给定过程域的一种手段。在CMMI中，针对每个过程域设定了6个能力等级，即0级：未完成级；1级：已执行级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：待续优化级。\n\t\n2. 成熟度等级的组成\n\t\n\t在CMMI中，应用于一个组织过程改善的成熟度等级有5个。即1级：初始级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：持续优化级\n\t\n3. 能力等级与成熟度等级之间的基本关系\n\n\t1. 能力等级与成熟度等级是互补的关系，两者都是一种过程改善路径，即表征组织对单一过程域的改进。\n\t2. 成熟度等级的路径可使组织针对单一过程域不断改善一组相关过程域，即表征组织对一组过程域的改进。\n\t3. 两种等级的2-5级使用了同样的名字\n\t\n4. 达到各共用目标要实施的共同实践\n\n\t达到公用目标2、共用目标3、共用目标4和共用目标5所要实施的共同实践如下表所示\n\t\n||所要实施的共用实践|\n|:---:|:---:|\n|共用目标2：把过程制度化为一个管理过程|GP2.1 建立组织策略<br/>GP2.2 规划过程<br/>GP2.3 提供资源<br/>GP2.4 指派责任<br/>GP2.5 培训人员<br/>GP2.6 管理配置<br/>GP2.7 标识相关利益方的参与<br/>GP2.8 监控过程<br/>GP2.9 客观地评估符合性<br/>GP2.10 从高层管理的视觉评审状态<br/>|\n|共用目标3：把过程制度化为一个已定义过程|GP3.1 建立一个已定义的过程<br/>GP3.2 收信进信息 所要实施的共用实践|\n|共用目标4：把过程制度化为一个已定量管理过程|GP4.1 为该过程建立定量目的<br/>GP4.2 使子过程性能达到稳定|\n|共用目标5：把过程制度化为一个持续优化过程|GP5.1 确保不断进行过程改善<br/>GP5.2 收集问题的根本原因|\n\n完结\n","source":"_posts/如何开发-管理一个项目.md","raw":"title: 如何开发/管理一个项目\nauthor: Arclin\nabbrlink: 3c7b026b\ntags: []\ncategories:\n  - 杂谈\ndate: 2019-10-20 15:20:00\n---\n如何管理一个项目，这是个沉重的话题。实际上，目前很多人都是凭借经验进行项目管理和开发，事实上管理项目是有着大量的方法论，这些方法论整理起来被人归纳成了一个学科，名字叫做`软件工程`，接下来的内容将会归纳总结里面的一些要点，如果你有意成为一个项目管理者，请必须了解一下这些基础知识。\n\n<!--more-->\n\n## 软件系统模型\n\n开始一个项目之前，你需要做好准备，那就是建立系统模型，有了抽象的模型，才会有具像的实现。\n - 在软件开发中，软件系统模型大体可分为两类：`概念模型`和`软件模型`。\n - 概念模型是创建在需求层上的，它描述了系统是什么。\n - 软件模型是建立在抽象层上的，它描述了实现概念模型的软件解决方案。\n - 软件模型可进一步分为`设计模型`、`实现模型`和`部署模型`。\n \n \n## 需求\n\n### 特征\n 一个完整的需求需要有以下特征：\n 1. 必要的：该需求是用户所要求的（产品经常会提一些伪需求，比如说在帖子列表添加个一键评价，点击了就回复666，但实际上没有用户想毫无感情地666，所以这是伪需求，不满足该条件的请拒绝）；\n 2. 无歧义的：该需求只能用一种方式解释（这个就不用解释了，遇到有歧义的需求请问清楚）；\n 3. 可测的：该需求可以进行测试；\n 4. 可跟踪的：该需求可以从一个开发阶段跟踪到另一个开发阶段（意思就是这个需求不会因为开发的进行变得模糊、不清晰）；\n 5. 可测量的：该需求是可测量的（意思就是实现这个需求不能无限耗费人力物力，说好这个需求两个人一天能做完，就两个人一天真的能做完）。\n \n### 类别\n\n 1. 功能需求：系统或系统构件必须执行的功能\n 2. 非功能需求：分为性能需求、外部接口需求、设计约束需求、质量属性需求。\n \n### 怎么发现需求\n\n  |名称|情况|成功条件|风险|\n  |:---:|:---:|:---:|:---:|\n  |自悟|自己想|要比你的最终客户拥有更多的一样弄领域和过程方面的知识和丰富的想象力，也就是你要比你的用户更加清楚用户要啥|无法验证你想出来的东西是不是你的用户想要的|\n  |交谈|跟你的客户聊|你能提出正确的问题，回答人能揭示需求本质的能力|可能会获得一堆需求，而且越来越多，不断增长，可能还会推翻你之前的需求，可能导致超出项目成本和进度的限制<s>（甚至可能被你的开发揍一顿）</s>|\n  |观察|你去看你的用户怎么用你的软件|你需要有洞察事物本质的能力|1. 你的用户会抵触你的观察（很明显侵犯隐私了）2. 用户会觉得你是不是这软件没做好或者哪里需求不到位所以老是来看我，对你的软件产生怀疑 |\n  |小组会|项目组的人全部叫出来开会讨论需求|你小组的人有不同观点，并且有良好的发现需求的能力，能揭示需求中存在的问题，最重要的是需求能跟用户达成共识|会议组织不到位就凉了，而且天天开会你的项目组的人也受不了，可能会提出矛盾需求|\n  |提炼|针对已有的部分需求文档，看线上反馈情况，进行提炼|你需要有想象力和需求标识能力，包括熟悉相关的技术标准|跟自悟一样，你不能知道你发现的需求是否是对的|\n \n### 需求规约\n\n需求规约就是怎么写一个需求表，因为形式很多，所以最好就根据实际情况进行，这里不做规定，但是必须包含以下几个特征\n1. 重要性和稳定性：需求要根据重要程度和稳定程度分优先级，例如：基本需求、可选需求和期望需求。\n2. 可修改的：在不过多地影响其他需求的情况下，可以容易地修改一个单一需求。\n3. 完整的：没有被遗漏的需求。\n4. 一致的：不存在互斥的需求。\n\n为什么需求规约很重要？（概念性东西）\n1. 是软件开发组织和用户之间一份事实上的技术合同书，是产品功能及其环境的体现。\n2. 对于项目的其余大多数工作，需求规约是一个管理控制点。\n3. 对于产品/系统的设计，需求规约是一个正式的、受控的起点。\n\n## 结构化方法\n\n### 结构化需求分析\n\n1. 为什么要这么做？\n\n\t为了应对三大挑战：\n\t\t- 问题空间理解。（假如让你开发一个八字排盘App，但是你又不懂八字，所以要开发出一个高质量、满足用户要求的App，就不容易了）\n\t\t- 人与人之间的通信。（开发过程长、活动多、任务重，项目组成员多，直接面对面沟通起来难免有遗漏、误解等，所以这也是一个挑战）\n\t\t- 需求的变化性。（需求是不断变化的，所以这是软件开发人员面临的挑战）\n\n\t一种好的需求技术应该具有以下基本特征：\n\n\t\t1. 提供方便通信的机子，例如，在不同开发阶段，使用对相关人员易于理解的语言。\n\t\t2. 鼓励需求分析人员使用问题空间的术语思考问题，编写文档。\n\t\t3. 提供定义系统边界的方法。\n\t\t4. 提供支持抽象的基本机制，例如，\"划分\"，\"功能抽象\"，\"结构抽象\"等。\n\t\t5. 为需求分析人员提供多种可供选择的方案。\n\t\t6. 提供特定的技术，适应需求的变化等。\n\n2. 几种基本术语的解释\n\n\t(1) 数据流：数据流是数据的流动，用于表达在分析中所要使用的、用于表达\"客体\"的信息，用箭头表示。\n\t大概长这样：\n\t<img width=50px src='https://i.loli.net/2019/10/21/wM2SkZXGDY46lQh.png'>\n\t(2) 加工：加工是数据变换的单元，即它接受输入的数据，对其进行处理，并产生输出。\n\t大概长这样\n\t<img width=50px src='https://i.loli.net/2019/10/21/mcfwVCaJI1Sn8kZ.png'>\n\t(3) 数据存储：数据存储是数据的静态结构。\n\t大概长这样(可以是横的或者竖的)\n\t<img width=50px src='https://i.loli.net/2019/10/21/xbXKc45RlYpnNB9.png'>\n\t(4) 数据源和数据潭: 数据源是数据流的起点，数据潭是数据流的归宿地。数据源和数据潭是系统之外的实体，可以是人、物或其他软件系统。\n\t大概长这样\n\t<img width=50px src='https://i.loli.net/2019/10/21/LiwWbnSAs7Pqzoh.png'>\n\n3. 数据流图\n\n\t把上面的元素组成起来就是数据流图了\n\t大概长这样\n\t<img width=70% src=\"https://i.loli.net/2019/10/21/wDdaFiLe9Ps6UzA.png\">\n\n\t几个要点：1）数据流起到连接其他实体的作用，实体可以是加工、数据存储、数据源和数据潭；2）加工之间可以有多个数据流，这些数据流之间可以没有任何关系，数据流图也不表明他们的先后次序；3）对于一个比较大的软件系统，往往需要采用多层次的数据流图。\n\t\n4. 建模过程\n\n\t1. 建立系统环境图，确立系统语境\n\t2. 自顶向下，逐步求精，建立系统的层次数据流图\n\t3. 定义数据字典。数据字典有3种基本结构表示：顺序结构，选择结构，重复结构。\n\t\t- 顺序结构是指数据A由数据B和数据C顺序构成的，并记为\"+\"。例如：学生成绩=姓名+性别+学号+科目+成绩，其中\"=\"号表达的是\"定义为\".\n\t\t- 选择结构是指由数据A是由数据B或数据C定义的，即数据B不可能同时是B和C，并记为“|”，例如：性别=男|女\n\t\t- 重复结构是指数据A是由多个重复出现的数据B构成的，并记为\"| |\"，例如：学生成绩表=|学生成绩|\n\t\t<img width=\"50%\" src=\"https://i.loli.net/2019/10/21/43hSWgZPmVirHfA.png\">\n\t4. 描述加工：该步的目标为依据系统的数据流图，给出其中每一加工的小说明。加工可以有3种表达工具。\n\t\t1. 结构化自然语言（自然语言描述）\n\t\t2. 判定表: 由条件类别，条件组合，操作，操作执行构成。举例如图<img width=50% src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D22%2C0%2C590%2C389%3Bc0%3Dbaike80%2C5%2C5%2C80%2C26/sign=d64b6fc508087bf469a30da9cfe16500/42166d224f4a20a48dfd6c499a529822730ed059.jpg\">\n\t\t3. 判定树。举例如图<img width=60%  src=\"https://i.loli.net/2019/10/21/COmGSet5I61lFsH.png\">\n\t\t\n5. 注意事项：\n\t1. 模型平衡问题\n\t2. 信息复杂性控制问题\n6. 需求验证\n\t验证需求规格说明书中的每一单一需求是否满足5个性质，即必要性、无歧义性、可测性、可跟踪性、可测量性；验证需求规格说明是否满足4个性质，即重要性和稳定程度、可修改性、完整性和一致性。在必要时还需要验证其他特性，如设计无关性。\n\t\n### 结构化设计\n\n#### 总体设计步骤\n\n结构化设计方法基于`自顶向下，功能分解`的基本原则，针对两种不同类型的数据流图，分别提出了变换设计和事务设计。其中，变换设计的目标是将变换型数据流图映射为模块结构图，而事务设计的目标是将事务型数据流图映射为模块结构图。\n\n1. 变换型数据流图和事务性和数据流图\n（1）变换型数据流图：具有比较明显的输入部分和变换部分之间的界面、变换部分和输出部分之间界面的数据流图，称为变换型数据流图；\n![](https://www.sytm.net/ueditor/net/upload/2013-12-31/bdae1434-8b79-4209-b818-2502c7ea3bee.png)\n（2）事务型数据流图：数据到达一个加工T，该加工T根据输入的值，在其后若干动作序列中选出一个来执行，这类数据流图成为事务型数据流图。\n![](https://www.sytm.net/ueditor/net/upload/2013-12-31/142b2c91-a9ad-4c6e-b075-ecd6a900ee63.png)\n\n2. 总体设计分为3个阶段。第一阶段为初始设计，在对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。第二阶段为精化设计，依据模块“高内聚低耦合”的原则精化初始的模块结构图，并设计其中的全局数据结构和每一模块的接口。第三阶段为复审阶段，对前两个阶段所得到的高层软件结构进行复审，必要时还可能需要对该软件结构做一些精化工作，这对软件的一些性质，特别是对软件质量的提高，将产生非常大的影响。\n\n3. 天天扯着嗓子喊高内聚低耦合，到底什么是内聚什么是耦合？\n\n\t- 耦合：耦合是指不同模块之间相互依赖程度的度量\n\t\t- 内容耦合：当一个模块直接修改或操作另一个模块的数据，\u001d或当一个模块直接修改或操作，另一个模块的数据或一个模块不通过正常入口转入到一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该尽量避免使用。\n\t\t- 公共耦合：两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。\n\t\t- 控制耦合：一个模块通过接口向另一个模块传递一个控制信号，接收信号的模块根据信号值进行适当的动作，这种耦合被成为控制耦合。\n\t\t- 标记耦合：若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。\n\t\t- 数据耦合：模块之间通过参数来传递数据，则称为数据耦合。数据耦合是最低的一种耦合形式。\n\t- 内聚：内聚是指一个模块内部各成分之间相互关联程度的度量\n\t\t- 偶然内聚：如果一个模块的各成分之间基本不存在任何关系，则称为偶然内聚\n\t\t- 逻辑内聚：几个逻辑上相关的功能被放在同一模块中，则称为逻辑内聚。\n\t\t- 时间内聚：如果一个模块完成的功能必须在同一时间内执行（例如，初始化系统或一组变量），但这些功能只是因为时间因素关联在一起，则称为时间内聚。\n\t\t- 过程内聚：如果一个模块内部的处理成分是相关的，而且这些处理必须以特定的次序执行，则称为过程内聚。\n\t\t- 通信内聚：如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚\n\t\t- 顺序内聚：如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚\n\t\t- 功能内聚：最理想的内聚是功能内聚，模块所有的成分对于完成单一的功能都是基本的。功能内聚的模块对完成其功能而言是充分必要的。\n\t\t\n\t- 启发式规则：无论是变换设计还是事务设计，都涉一个共同的问题，即“基于高内聚低耦合的原理，采用一些经验性的启发式规则，对初始的模块结构图进行精化，形成最终的模块结构图”。\n\t\n\t- 怎么做？\n\t\t1. 改进软件结构，提高模块独立性。\n\t\t2. 力求模块规模适中。\n\t\t3. 力求深度、宽度、扇出和扇入适中。深度：表示其控制的`层数`(不包括自身)；宽度：同一层次上模块总数的`最大值`；扇出：一个模块`直接`控制（调用）的下级模块数目；扇入：一个模块有多少个上级模块`直接`调用它。\n\t\t4. 尽力使模块的作用域在其控制域之内。作用域：受该模块内`一个判定`所影响的所有模块的集合；控制域：模块本身以及所有`直接或间接`从属于它的模块的集合。\n\t\t\n#### 详细设计步骤\n\n1. 结构化程序设计\n\t包含三种基本控制结构：顺序结构、选择结构、循环结构\n2. 详细设计工具\n\t1. 程序流程图\n\t\t<img width=20% src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945069712&di=74b11092aae0042569e80dc22ee83438&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F09%2F17%2F02%2F27798515%2F15.files%2Ffile0001.jpg\">\n\t\t缺点：不是一种逐步求精的工具，过早地考虑程序的流程，不去考虑程序的全局结构；所表达的控制流，往往不受任何约束可随意转移，从而会影响甚至破坏好的系统结构设计；不易表示数据结构。\n\t2. 盒图（N-S图）\n\t\t<img width=40% src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945228461&di=10908d6d12f9c8984356e884b3c0aeb5&imgtype=0&src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fzhidao%2Fwh%253D450%252C600%2Fsign%3Da401ed95523d26972e86005960cb9ecd%2Fd833c895d143ad4bd5fe969f81025aafa50f0698.jpg\">\n\t3. PAD图（Problem Analysis Diagram）\n\t\t<img width=\"40%\" src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945326054&di=d66d2f92c755db3f26640c2bbb6bc338&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F12%2F15%2F14%2F51872755%2F6.files%2Ffile0001.jpeg\">\n\t\n\tN-S图和PAD图支持“自顶向下逐步求精”的设计。可节省人工编码工作，有利于提高软件的可靠性和软件生产率\n\t\n\t4. 类程序设计语言（伪码/PDL）\n\t\t是一种用正文形式表示数据结构和处理过程的设计工具，PDL是一种“混合”的语言。\n3. 设计规约\n\t完成软件设计后，应产生设计规约，完整准确地描述满足系统需求规约所要求的的所有功能模块，以及伴随功能模块而出现的非功能机制。设计规约通常包括`概要设计规约`和`详细设计规约`。\n\t\n\t`概要设计规约`指明高层软件体系结构，其主要功能如下：\n\t\n\t1.系统环境等与设计有关的限定条件 2. 软件模块的结构（模块之间的接口及设计的数据流和主要数据结构）3. 模块描述（接口定义，模块处理逻辑，必要的注释等）4. 文件结构和全局数据文件的逻辑结构 5.测试需求\n\t\n\t`详细设计规约`（包括各处理过程的算法和算法所涉及的全部数据结构的描述）主要作为软件设计人员与程序员之间交流的媒体。\n\t\n## UML\n\n### UML是一种图形化建模语言（Unified Modeling Language）\n\n为了支持抽象分析和设计中的事物，UML给了八个基本术语，即类、接口、协作、用况、主动类、构件、制品、节点、\n- 类： 类是一组拥有相同属性、操作、关系和语义的对象的描述。类主要用于抽象客观世界中的事物。\n- 接口：每个操作描述了类、构件或子系统的一个服务，接口就是操作的一个集合。接口是对系统/产品的“接缝”予以模型化，表明了一个类、构件、子系统所需要得到的、且与实现无关的行为。\n- 用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的、可观察的结果。\n- 协作：协作是一个交互，涉及交互的三要素：交互各方、交互方式以及交互内容\n- 用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的，可观察的结果。\n- 主动类：主动类是一种至少具有一个进程或线程的类。\n- 构件：构件是系统设计中的一种模块化部件，通过外部接口隐藏了它的内部实现。\n- 制品：制品是系统中包含物理信息（比特）的、可替代的物理部件。\n- 节点：节点是运行时存在的物理元素，通常表示一种具有记忆能力和处理能力的计算机资源。\n\t\n类在建模中的主要用途：\n1. 模型化问题域中的概念\n2. 建立系统的职责分布模型\n3. 模型化建模中使用的基本类型\n\n使用接口应注意的问题\n1. 接口只可以被其他类目使用，而本身不能访问其他类目\n2. 接口描述类的外部可见操作，通常是该类的一个特有限定行为。这些操作可以使用可见性、并发性、衍型、标记值和约束来修饰。\n3. 接口不描述其中操作的实现，也没有属性和状态。据此可见，接口在形式上等价于一个没有属性、没有方法而只有抽象操作的抽象类\n4. 接口之间没有关联、泛化、实现和依赖。但可以参与泛化、实现和依赖\n\t\n### 表达关系的术语\n\n\t关联：关联是一组具有相同结构、相同链的描述，是类目之间的一种结构关系。关联可以用一条连接两个类目的线段表示，并可对其命名，其结构可以具有方向性，用一个实心三角形来指示关联的方向。\n\t\t1. 关联名 。\n\t\t2. 导航：对于一个给定的类目，可以找到与之关联的另一个类目，这称为导航。\n\t\t3. 角色：角色是关联一端的类目对另一端的类目的一种呈现。\n\t\t4. 可见性：通过导航可以找到另一类目的实例，有时候需要限制访问。\n\t\t5. 多重性：类中对象参与一个关联的数目，成为该关联的多重性\n\t\t6. 限定符：限定符是一个关联的属性或属性表。\n\t\t7. 聚合：分类是增强客观实际问题语义的一种手段。聚合是对象之间（不是类之间）的一种结构关系。\n\t\t8. 组合：组合是聚合的一种特殊形式\n\t泛化：泛化是一般性类目和它的较为特殊类目之间的一种关系。子类可以继承父类的属性和操作，同时也可以替换父类的声明。\n\t\t泛化的四种约束：完整、不完整、互斥、重叠\n\t细化：细化是类目之间的语义关系，其中一个类目规约保证了另一个类目执行的契约。\n\t依赖：依赖用于描述一个类目使用另一个类目的信息和服务，是一种使用关系。\n\t\t依赖的分类：绑定、导出、允许、示例、实例化、幂类型、精化、使用。\n\t\t\n\t关联、泛化和细化都是一类特地类型的依赖。\n\t\n\t使用这四种术语，可以模型化以下各种关系：\n\t1. 结构关系（静态结构和动态结构）\n\t\t进行模型化时两种驱动方式：1.以数据驱动 2. 以行为驱动\n\t2. 继承关系\n\t3. 精化关系\n\t4. 依赖关系\n\t\n### 表达组合信息的术语————包\n\n为了控制信息组织的复杂性，UML提供了组织信息的一种通用机制————包，支持形成一些可管理的部分。换言之，包可以作为“模块化”和“构件化”的一种机制。\n\n包是模型元素的一个分组。一个包本身可以被嵌套在其他包中，并且可以含有子包和其他种类的模型元素。\n\n通过在包的名字前加上一个可见性符号（+，-，#），来指示该包的可见性。\n\n```\n+ 表示对其他包而言都是可见的\n# 表示对子孙包而言是可见的\n- 表示对其他包而言都是不可见的\n```\n\n为了模型化包之间的关系，UML给出了两种依赖，即访问和引入。\n- 访问：表明目标包中的内容可以被源包所引用，或被那些递归嵌套在源包中的其他包所引用。\n- 引入：表明目标包中具有适当可见性的内容（名字）被加入到源包的公共命名空间中。\n\nUML中用虚线加箭头的方式表示源包到目标包的依赖（访问和引入）。\n\n### UML术语的作用\n\n1. 类用于抽象客观事物\n2. 接口用于抽象事物之间的缝隙\n3. 协作用于抽象协作性行为\n4. 用况用于抽象功能\n5. 主动类用于抽象并发行为\n6. 构件用于抽象软件解中标识的成分\n7. 制品用于抽象工作产品\n8. 节点用于抽象计算单元\n9. 关联用于抽象结构关系\n10. 泛化用于抽象“一般/特殊”关系\n11. 实现用于抽象精化关系\n12. 依赖用于抽象使用关系\n\n### UML的模型表达式\n\n1. 结构图和行为图\n\t结构图用于表达系统或系统成分的静态结构模型，给出系统或系统成分的一些说明性信息\n\t行为图用于表系统或系统成分的动态结构模型，给出系统或系统成分的一些行为信息\n2. 类图、用况图、顺序图及状态图\n\t- 类图是可视化地表达系统静态结构功能模型的工具，使用类图所表达的系统静态结构模型，给出的是一些关于系统的说明性信息。\n\t![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176025075&di=1875f9ac829f33a38a45131069ee3e4a&imgtype=0&src=http%3A%2F%2Fimages.cnblogs.com%2Fcnblogs_com%2Fa-i%2FUml2.JPG)\n\t- 用况图是一种表达系统功能模型的图形化工具，它包含六个模型元素，分别是主题、用况、参与者、关联、泛化、依赖\n\t![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176303343&di=4146dfc9badef7bc95f4c750ab149eb0&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F09%2F24%2F23%2F28839740%2F23.files%2Ffile0001.png)\n\t- 顺序图由一组对象以及按时序组织的对象之间的关系组成，是一种交互图，包含对象之间传递的信息。控制操作包括`选择执行操作`、`条件操作`、`并发迭代操作`、`迭代执行操作`。\n\t![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176439921&di=d592e65ae4a1bc1c2e65a98e415a897a&imgtype=0&src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fpng%2F20180615101636402475.png)\n\t- 状态图强调了从一个状态到另一个状态的控制流，是显示一个状态机的图。状态图由状态、事件和状态转移构成。使用状态图的作用有两个：一是创建一个系统的动态模型，二是创建一个场景的模型\n\t![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176576658&di=70e3de58666cf1d7315cf56a05ec0d35&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F12%2F07%2F08%2F48638362%2F25.files%2Ffile0001.png)\n\t-\n3. 创建一个系统的类图的步骤\n\t- 模型化代建系统中的概念，形成类图中的基本元素\n\t- 模型化代建系统中的各种关系，形成该系统的初始类图\n\t- 模型化系统中的协作，给出该系统的最终类图\n\t- 模型化逻辑数据库模式\n4. 信号事件、调用事件、时间事件和变化事件\n\t- 信号事件是一种异步事件，信号通常由状态机处理。如果没有定义对该事件的响应，那么事件均可能丢失。事件的丢失，就有可能引发接受者——状态机的一个错误的状态转移。\n5. 状态转移所涉及的内容\n\t描述一个状态转换，一般涉及五个部分：\n\t1. 源状态：发生状态转移的那个状态\n\t2. 转移触发器：在源状态中由对象识别的事件，并且一旦满足其监护条件，则使状态发生转移。\n\t3. 监护条件：一个布尔表达式，当某个事件触发器接受一个事件时，如果该表达式有值为真，则触发一个转移；若有值为假，则不发生状态转移。\n\t4. 效应：一种可执行的行为\n\t5. 目标状态：转移完成后所处的状态\n6. 最常用的控制操作子\n\t选择执行操作子：该操作子由两部分组成：一是监护条件，二是控制体\n\t条件执行操作子：控制体通过水平线将其分为一些部分，每一部分表示一个条件分支，每一分支有一个监护条件。\n\t并发执行操作子：该控制操作子的体通过水平线将其分为多个部分，每一部分表示一个并行计算。该控制操作子表明，当进入该控制操作子是，所有部分并发执行。\n\t迭代执行操作子：该控制操作子表明，只要在每一次迭代之前该监护条件为真，那么该控制体就反复执行，当该控制体上面的监护条件为假时，控制绕过该控制操作子。\n7. 子状态机、简单状态和组合状态的概念\n\t子状态机：为了有效地组织状态、控制对象状态的复杂性，UML提供了组合状态，在一个状态机中引入了另一个状态机。被引入的状态机就称为子状态机。\n\t简单状态：子状态是被嵌套到另一状态中的状态。相对地，被引入的状态机就称为子状态机。\n\t组合状态：把含子状态的状态称为组合状态，组合状态可包含两种类型的子状态机，即非正交（顺序）子状态机和正交（并发）子状态机。\n## RUP\n\n### RUP(Rational Unified Process)的特点\nRUP的突出特点是，它是一种以用况（Use Case）为驱动的、以体系结构为中心的迭代、增量式开发。\n1. 以用况为驱动\n以用况为驱动是指在系统的生存周期中，以用况作为基础，驱动系统有关人员对所要建立系统的功能需求进行交流，驱动系统分析、设计、实现和测试等活动。\n2. 以体系结构为中心\n以体系结构为中心是指在系统的生存周期中，开发的任何阶段都要给出相关模型视角下有关体系结构的描述，作为构思、构造、管理和改善系统的主要标准。\n3. 迭代、增量式开发\n迭代、增量式开发是指通过开发活动的迭代，不断地产生相应的增量。在RUP中，规定了四个开发阶段：初始阶段、精化阶段、构造阶段和移交阶段。\n\n### 核心工作流\n核心工作流：需求获取、分析、设计、实现和测试\n#### 需求获取\n\n|基本步骤|产生的制品|\n|:---:|:---:|\n|列出候选的特征|特征表|\n|理解系统语境|领域模型或业务模型|\n|捕获功能需求|用况模型|\n|捕获非功能需求|补充需求或针对特殊需求的用况|\n\n### 业务用况模型和业务对象模型\n\n1. 业务用况模型。业务用况模型是以用框图予以表达的\n2. 业务对象模型。为了精化业务用况模型中的每一个业务用况，RUP引入了三个术语，用于表达参与业务的业务对象：`工作人员`、`业务实体`和`工作单元`。业务对象模型可通过交互图和活动图予以表达。\n\n### 标识用况应注意的问题\n\n1. 建立用况的结构中，应尽可能反映用况的实际情况。\n2. 在用况的结构化中，不论是施加什么结构，新引入的用况都不应该太小或太大\n3. 在建立用况的结构是，应尽量避免对用况模型中的用况功能进行分解。\n\n#### 需求分析\n\n1. 分析类是类的一种衍型，分为边界类、实体类和控制类\n2. 用况细化时一个协作，针对一个用况，其行为可用多个分析类之间的相互作用来细化，并记为用况细化。用况细化对用况模型中的一个特定的用况提供了一种直接跟踪的方式。\n3. 分析包是一种控制信息组织复杂性的机制，提供了分析制品的一种组织手段。其主要特征为：体现问题的分离；高内聚、低耦合；尽可能体现一个系统的完整顶层设计，尽可能成为一些子系统或者成为一些子系统的组成部分。\n\t\n#### 具有良好结构的分析包的特征\n\n1. 体现问题分离\n2. 高内聚、低耦合。\n3. 尽可能提现一个系统的完整顶层设计。\n\n#### 软件设计层上的术语\n\n软件设计是满足需求规约所需要的软件结构。RUP为了满足系统/产品分析模型规约需求的软件结构，为设计层提供了是个术语：设计类、用况细化、设计子系统和接口，用于表达软件结构中的基本元素。\n\n1. 设计类：一个设计类是对系统中实现一个类或类似构造的一个无缝抽象\n2. 用况细化：用况细化是设计模型的一个协作，其中使用设计类及其对象，描述一个特定用况是如何予以细化的，是如何执行的\n3. 设计子系统：设计子系统可以包含设计类、用况细化、接口，以及其他子系统，通过对其操作来显示其功能。\n4. 接口：接口用于规约由设计类和设计子系统，必须提供与该接口操作对应的实现方法。\n\n#### 创建系统/产品用况模型的活动和任务\n\n创建系统/产品用况模型的活动和任务如下\n1. 活动一：发现并描述参与者\n任务1：发现参与者，即直接发现一些候选的参与者\n任务2：描述参与者，即对参与者进行命名并描述\n2. 活动二：发现用况并对用况进行描述\n任务1：发现用况\n任务2：描述用况，即确定用况后对其进行描述\n3. 活动三：确定用况的优先级，目的是在寻找参与者并对其进行描述和发现用况的并对用况进行描述的基础上确定哪些用况适合在早期的迭代中开发，哪些适合在后期的迭代中开发。\n4. 活动四：精化用况。这一活动的目的是详细描述出每一用况的事件流，包括用况是怎样开始的，是怎样结束的，是怎样与参与者进行交互的，最终形成一系列精化的用况\n5. 活动五：构造用户界面原型。这一活动的目的在于建造用户界面原型，使用户可以有效地执行用况。\n6. 活动六：用况模型的结构化。需要进行以下工作。\n\t1. 抽取用况描述中的那些一般性的和共享的功能并使用泛化关系标识和描述那些共享功能\n\t2. 抽取用况描述附加的或可选的功能\n\t3. 标识用况之间的包含关系。通过用况模型的结构化，最终形成一个系统/产品的精化用户模型\n\t\n#### 创建系统/产品需求分析模型的活动和任务\n1. 活动1：体系结构分析。该活动的目标是通过标识分析包和分析类，建立分析模型和体系结构“骨架”，并标识有关分析包和分析类的特定需求。\n任务1：标识分析包。该任务的基本输入是系统的用况模型\n任务2：处理分析包之间的共性\n任务3：标识服务包\n任务4：定义分析包的依赖，该任务的目标是发现相对独立的包，实现包的高内聚和低耦合\n任务5：标识重要的实体类，该任务的目标是标识在体系结构方面具有意义的实体类。\n任务6：标识分析包和重要实体类的公共特定需求，该任务的目标是依据需求获取阶段所标识的非功能需求，针对在分析期间所标识的包和分析类，标识它们的一些公共的特定要求。\n2. 活动2：用况分析。该活动的目标是：一是标识那些在用况事件流执行中所需要的分析类和对象；二是将用况的行为分布到参与交互的各个分析对象；三是捕获用况细化上的特定需求。\n任务1：标识分析类，该任务的目标是标识在细化一个用况中所需要实体类、控制类和边界类，给出它们的名字、责任、属性和关系。\n任务2：描述分析类对象之间的交互。首先确定细化该用况所必要的交互，其次分派该用况的功能，最后根据其责任，发现该交互图中的各个链。\n3. 活动3：类的分析。该活动的目标：一是标识并维护分析类的属性和关系；二是捕获分析类细化中的特殊需求。\n任务1：标识责任，通过组合一个类在不同用况细化中所扮演的角色来完成。\n任务2：标识属性\n任务3：标识关联和聚合\n4. 活动4：包的分析。该活的目标是：一是确保分析包尽可能与其他包相对独立；而是确保分析包实现了它的目标；三是描述依赖，以益于可以估计未来的变化。\n\n###  创建系统/产品设计模型的活动和任务\n创建系统/产品设计模型的活动和任务如下：\n1. 活动1：体系结构设计，该活动的目标是创建设计模型和部署模型，以及它们视角下的体系结构描述\n任务1：标识节点和它们的网络配置，网络配置通常使用一种三元模式：客户端、数据库功能、业务/应用逻辑\n任务2：标识子系统和它们的接口，目的是为了寻求一些复用的可能，而后随着设计模型的开发，在形成子系统结构中不断发现并烟花。\n任务3：标识在体系结构方面有意义的设计类和它们的接口。标识在体系结构方面有意义的设计类的基本思想是：初始可以依据在体系结构方面有意义的分析类来标识一些体系结构上具有重要意义的设计类。标识在系统体系结构方面有意义的设计类时，应注意主动类往往是一类在体系结构方面具有重要意义的类。\n2. 活动2：用况的设计。其中分析模型用况细化分析是活动的输入、对应输出用况细化设计。\n为了实现用况设计的输入/输出，一般采用两种方法：\n\t1. 标识参与用况细化的设计类，首先基于分析模型研究相应用况细化分析中的分析类，来标识为细化这些分类所需要的设计类，然后基于用况的功能对每一个标识的设计类赋予相应的责任，最后为该细化创建一个类图，汇聚参与该用况细化的设计类，并给出类之间的关系。\n\t2. 标识参与用况细化的子系统和接口。\n3. 活动3：类的设计。该活动的目标是完成用况细化设计中每一个类的角色设计，并完成有关每一类的非功能需求的设计。\n任务1：概括描述设计类，该任务的输入为分析类/接口。\n任务2：标识的操作，一般应依据分析类来标识设计类所提供的、所需要的操作，其中需要使用程序设计语言的语法来描述说标识的操作。\n任务3：标识属性，该任务的目标是标识设计类所需要的属性，并使用程序设计语言的语法给出属性的描述。\n任务4：标识关联和聚合。\n任务5：标识泛化，基于分析模型中分析类之间的泛化，可以发现设计模型中的很多泛化。\n任务6：描述方法，在设计期间一般用自然语言或适当的使用伪码对方法进行规约，但是在实现期间直接使用程序设计语言对方法进行规约。\n任务7：描述状态，有些设计对象是受状态控制的，即它们的状态确定了它们接受一个消息的行为。在这种情况下，使用一个状态图描述一个对象的不同状态转移是有意义的。\n4. 活动4：子系统的设计。该活动的目标是：确保子系统尽可能独立于其他子系统或它们的接口；确保子系统提供正确的接口；确保子系统实现了它的目标，即给出了该子系统提供的那些接口所定义的操作的细化。\n\n### 设计模型包含的元素\n\nRUP设计的主要结果是设计模型，它尽量保持该系统具有分析模型的结构，并作为系统实现的输入，包含以下四个元素：\n\n1. 设计子系统和服务子系统，以及它们的接口、依赖和内容。\n2. 设计类以及它们具有的操作、属性、关系及其实现的需求。\n3. 用况细化设计。\n4. 设计模型视角下的体系结构描述。\n\n### 用况模型与分析模型的比较\n\n|用况模型|分析模型|\n|:----:|:---:|\n|使用客户语言来描述 |使用开发者语言来描述 |\n|给出的是系统对外的视图 | 给出的是系统对内的视图 |\n|使用用况予以结构化，但给出的是外部视角下的系统结构 | 使用衍型类予以结构化，当给出的是内部视角下的系统结构 |\n|可以作为客户与开发者之间关于“系统应该做什么，不应该做什么”的契约 |可以作为开发者理解系统如何勾画、如何设计和如何实现的基础|\n|在需求之间可能存在一些冗余、不一致和冲突等问题|在需求之间不应存在冗余、不一致和冲突问题|\n|捕获的是系统的功能，包括在体系结构方面有意义的功能|给出的是细化的系统功能，包括在体系结构方面具有意义的功能|\n|定义了一些进一步需要在分析模型中予以分析的|定义了用况模型中每一个用况的细化|\n\n### RUP实现活动\n\n目标：基于设计类和子系统生成构件；对构件进行单元测试，进行集成和连接；把可执行的构件映射到部署模型。\n\n|输入|活动|执行者|输出|\n|:----:|:---:|:---:|:---:|\n|设计模型、部署模型、体系结构描述【设计模型、部署模型角度】|实现体系结构|体系结构设计者|构件【概述】、体系结构描述【实现模型、部署模型角度】|\n|补充需求、用况模型、设计模型、实现模型【当前建造】|集成系统|系统集成者|集成建造计划、实现模型【连续的建造】|\n|集成建造计划、体系结构描述【实现模型角度】、设计子系统【已设计】、接口【已设计】|实现子接口|构件工程师|实现子系统【建造完成】、接口【建造完成】|\n|设计类【已设计】、接口【由设计类提供】|实现类|构件工程师|构件【完成】|\n|构件【完成】、接口|完成单元测试|构件工程师|构件【已完成单元测试】|\n\n### RUP测试活动\n\nRUP的测试包括内部测试、中间测试和最终测试\n\n|输入|活动|输出|\n|:----:|:---:|:---:|\n|补充需求、用况模型、分析模型、设计模型、实现模型、体系结构的描述|计划测试|测试计划|\n|补充需求、用况模型、分析模型、设计模型、实现模型、体系结构描述、测试计划|设计测试|测试用况 测试过程|\n|测试用况、测试过程、实现模型|实现测试|测试构件|\n|测试用况、测试过程、测试构件、实现模型|执行集成测试|缺陷|\n|测试用况、测试过程、测试构件、实现模型|执行系统测试|缺陷|\n|测试用况、测试模型、缺陷|评价测试|测试评价|\n\n## 软件测试\n\n### 软件测试目标与软件测试过程模型\n\n#### 软件测试及目标\n\n软件测试的定义为：按照特定规程发现软件错误的过程。其目的是检验它是否满足规定的需求，或清楚了解预期结构与实际结果之间的差异\n\n#### 软件测试与软件调试之间的区别\n\n软件测试与软件调试相比，在目的、技术和方法等方面都存在很大区别，主要表现在以下几个方面。\n1. 测试从一个侧面证明程序员的\"失败\".调试是为了证明程序员的正确。\n2. 测试以已知条件开始，使用预先定义的程序且有预知的结果，不可预见的仅是程序是否通过。调试一般是以不可知的内部条件开始，除统计性调试外，结果是不可预见的。\n3. 测试是有计划的，并要进行测试设计。调试是不受时间约束的。\n4. 测试是一个发现错误、改正错误、重新测试的过程。调试是一个推理过程。\n5. 测试的执行是有规程的。调试的执行往往要求程序员进行必要推理。\n6. 测试经常是由独立的测试组在不了解软件设计的条件下完成的。调试必须由了解详细设计的程序员完成。\n7. 大多数测试的执行和设计可由工具支持。调试时，程序员能利用的主要工具是调试器。\n\n#### 测试过程模型\n\n软件测试是一个有程序的过程，包括测试设计、测试执行以及测试结果比较。测试过程模型可分为三类：环境模型、被测对象模型和错误模型。\n\n1. 环境模型：是对程序运行环境的抽象。程序运行环境又包括支持其运行的硬件、固件和软件，如计算机、终端设备、网卡、操作系统、编译系统、实用程序等。在软件测试过程中，建立环境模型的主要目的是，确定所发现的错误是否为环境造成的。\n2. 被测对象模型：该模型是从测试的角度对程序的抽象。为了测试，必须简化程序，形成被测程序的抽象版本、即对象模型。\n3. 错误模型：该模型是对程序中的错误及其分类的抽象。在软件测试中，往往需要定义“什么是错误”、“什么是一般性错误”、“什么是严重性错误”等，即要给出“错误模型”。\n\n### 软件测试技术\n\n1. 测试覆盖及其他们之间的基本关系\n软件测试技术大体上可分为两大类：一类是白盒测试技术，又称为结构测试技术，典型的是路径测试技术；另一种是黑盒测试技术，又称为功能测试技术，包括事务处理流程技术、状态测试技术、定义域测试技术等。白盒测试技术依据的是程序的逻辑结构，而黑盒测试技术依据的是软件行为的描述。\n2. 路径测试技术的分类\n\n\t测试覆盖包括路径覆盖、分支覆盖、条件覆盖与条件组合覆盖。\n\n\t1. 路径覆盖：执行所以有可能穿过程序控制流程的路径。在路径测试中，该度量是最强的，一般是不可实现的。\n\t2. 语句覆盖：至少执行程序中所有语句一次\n\t3. 分支覆盖：至少将程序中的每一个分支执行一次\n\t4. 条件覆盖与条件组合覆盖：条件覆盖是指每个判定中所有的可能的条件的取值至少执行一次；条件组合覆盖是指设计足够的测试用例，使每个判定中所有可能的条件取值组合至少执行一次。\n\t\n\t这四种测试覆盖的测试覆盖率由弱到强的顺序是：语句覆盖 < 分支覆盖 < 条件组合覆盖 < 路径覆盖\n\n3. 事务流测试步骤\n\n\t事务流测试步骤具体如下。\n\t第一步：获得事务流程图。\n\t第二步：浏览、复审。\n\t第三步：用例设计。\n\t第四步：测试执行。\n\t\n4. 运用等价类划分技术进行测试的步骤\n\n\t具体测试步骤如下。\n\t第一步：建立等价类表\n\t第二步：为有效等价类设计测试用例\n\t第三步：为无效等价类至少设计一个测试用例\n\t\n5. 边界值分析的使用原则\n\n\t边界值分析是一种常用的黑盒测试技术。使用边界值分析在设计测试用例时，可以遵循以下原则。\n\t\n\t1. 如果某个输入条件规定了输入值的范围，则应该选择正好等于边界值的数据，以及刚刚超过边界值的数据作为测试数据。\n\t2. 如果某个输入条件规定了值的个数，则可用最大个数、最小个数、比最大个数多1、比最小个数少1的数据作为测试数据\n\t3. 根据规格说明的每个输出条件，使用前面的原则1\n\t4. 根据规格说明的每个输出条件，使用前面的原则2\n\t5. 如果程序的规格说明中，输入域或输出域是有序集合，在实践中则经常选取集合的第一个元素、最后一个元素以及典型元素作为测试用例。\n\t6. 如果程序中使用了内部数据结构，则应该选择这个内部数据结构的边界上的值作为测试用例。\n\t7. 分析规格说明，找出其他可能的边界条件。\n\t\n6. 使用因果图生成测试用例的步骤\n\n\t因果图技术是通过为判定表的每一列设计一个测试用例，从而实现测试用例的设计与选择的。该方法生成测试用例的基本步骤如下。\n\n\t1. 通过软件规格说明书的分析，找出一个模块的原因和结果，并给每个原因和结果赋予一个标识符\n\t2. 分析原因与结果之间以及原因之间对应的关系，并画出因果图。\n\t3. 在因果图上标识出一些特定的约束或限制条件。\n\t4. 把因果图转换成判定表。\n\t5. 把判定表的每一列拿出来作为依据，设计测试用例。\n\t\n### 软件测试步骤\n\n1. 单元测试\n\t单元测试主要检验软件设计的最小单元---模块。该测试以详细设计文档为指导，测试模块内的重要控制路径。一般来说，单元测试往往采用白盒测试技术。\n\t\n2. 集成测试\n\t集成测试是软件组装的一个系统化技术，其目标是发现与接口有关的错误，将经过单元测的模块构成一个满足设计要求的软件结构。集成测试集中于模块组合的功能和软件结构检验。集成测试可“自顶向下”地进行，称为自顶向下的集成测试；也可以“自底向上”地进行测试，称为自底向上的集成测试\n\n3. 有效性测试\n\t有效性测试的目标是发现软件实现的功能与需求规格说明书不一致的错误。因此有效性测试通常采用黑盒测试技术。\n\t\n4. 系统测试\n\t系统测试验证将软件融于更大系统中时整个系统的有效性。\n\n## 软件生存周期过程与管理\n\n### 软件生存周期过程概述\n\n1. 过程分类\n\n\t按过程主体把软件生存周期过程分为以下几个过程。\n\t1. 基本过程：是指那些与软件生产直接相关的活动集。该过程又可分为获取过程、供应过程、开发过程、运行过程和维护过程。\n\t2. 支持过程：是指有关各方按他们的目标所从事的一系列相关支持活动集。该过程又可分为文档过程、配置管理过程、质量保证过程、验证过程、确认过程、联合评审过程、审计过程和问题解决过程。\n\t3. 组织过程：是指那些与软件生产组织有关的活动集。该过程又可分为设计过程、基础设施过程、培训过程和改进过程。\n\t\n2. 系统语境的过程类\n\t系统语境的过程类包含四个过程组，分别是协议过程组、项目过程组、技术过程组和组织上项目使能过程组。\n\t1. 协议过程组包含两个过程：获取过程和供应过程。\n\t2. 项目过程组包含七个过程：项目规划过程、项目评价过程、决策管理过程、风险管理过程、配置管理过程、信息管理过程和测量过程。\n\t3. 技术过程组包含11个过程：利益攸关方需求定义过程、系统需求分析过程、系统体系结构设计过程、实现过程、系统集成过程、系统测试过程、软件安装过程、软件接受支持过程、软件运行过程、软件维护过程和软件销毁过程。\n\t4. 组织上使能过程组包含五个过程：生存周期模型管理过程、基础设施管理过程、项目包管理过程、人力资源管理过程和质量管理过程。\n\t\n3. 组织上使能过程的作用。\n\t组织上使能的过程一般来说是组织层面上的工作，为项目的执行提供基本保障。该过程包含五个子过程。\n\t1. 生存周期模型管理过程：其任务为过程建立、过程评估、过程改进。\n\t2. 基础设施管理过程：其任务为过程实现、基础设施的建立、基础设施的维护。\n\t3. 项目包管理过程：项目初始化、项目包评估、项目结束处理。\n\t4. 人力资源管理过程：其任务为技能标识、技能开发、技能获取和供给、知识管理。\n\t5. 质量管理过程：其任务为质量管理、质量管理纠正措施。\n\n### 过程描述\n\n软件验证过程包括两个活动：过程实现和验证。其中验证活动有五个任务：需求验证、设计验证、代码验证，集成验证和文档验证。\n\n一个过程可通过过程意图，期望的结果以及到达过程结果需要执行的活动和任务来描述。对于一个过程的完整技术上的描述，还应包括：达到过程意图和实现过程结果的方法或规程，以及过程和活动文档。\n\n### 应用说明\n\n1. 系统和软件的关系\n\n\t在《ISO/IEC系统与软件工程-软件生产周期过程12207-2008》标准中，把软件认为是整个系统的一个组成从部分，执行系统中所确定的功能主要包括三大功能：控制功能、耦合功能以及软件本身提供的功能。由于软件通常存在与一个系统的上下文中，因此软件产品或服务一般可被认为是系统的一个项或称为系统元素。\n\t\n2. 剪裁过程及应用\n\n\t剪裁过程是使剪裁这一标准过程慢速以下特定情况或因素。\n\t1. 围绕一个组织，其中该组织在一个协议中使用了这一标准\n\t2. 影响一个项目，其中要求该项目满足一个引用该标准的协议\n\t3. 反映一个组织的需要，其中该组织要供给产品或服务\n\t\n### 软件生存周期模型\n\n1. 瀑布模型\n\n\t瀑布模型是将软件生存周期各个活动规定为按固定顺序链接的若干阶段的模型。这一模型规定了个开发阶段的活动：系统需求、软件需求、需求分析、设计、编码、测试和运行，并且自上而下具有相互衔接的固定顺序；还规定了每一个阶段的输入，即工作对象以及本阶段的工作成果，作为输出传送到下一阶段。\n\n\t瀑布模型的提出，对软件工程的主要贡献如下。\n\t1. 在决定系统怎样做之前存在一个需求阶段，它鼓励对系统做什么进行规约。\n\t2. 在系统构造之前存在一个需求阶段，它鼓励规划系统结构。\n\t3. 在每一阶段结束时进行评审，从而允许获取方和用户的参与。\n\t4. 前一步可以作为下一步被认可的、文档化的基线，并允许基线和配置早期接受控制。\n\n\t瀑布模型的主要问题是：\n\n\t1. 要求客户能完整、正确和清晰地表达他们的需求；并要求开发人员一开始就要理解这一应用。\n\t2. 由于需求的不稳定性，使设计、编码和测试阶段都可能发生延期；并且当项目接近结束时，出现了大量的集成和测试工作。\n\t3. 在开始的阶段中，很难评估真正的进度状态；并且直到项目结束之前都不能演示系统的能力。\n\t4. 在一个项目的早期开发阶段，过分地强调了基线和里程碑处的文档；并可能需要花费更多的时间用于建立一些用处不大的文档。\n\t\n2. 增量模型\n\n\t增量模型是一种非整体开发的模型。软件在该模型中逐渐开发出来，开发出一部分，向用户展示一部分，可让用户及早看到部分软件，及早发现问题。该模型具有较大的灵活性，适合软件需求不明确、设计方案有一定风险的软件项目。\n\n3. 演化模型\n\n\t该模型主要针对事先不能完整定义需求的软件开发在用户提出待开发系统的核心需求的基础上，软件开发人员按照这一要求，首先开发一个核心系统并投入运行，以便用户能够有效地提出反馈，即精化系统、增强系统能力的需求；接着，软件开发人员根据用户反馈，实施开发的迭代过程；每一迭代过程均由需求、设计、编码、测试、集成等阶段组成，为整个系统增加一个可定义的，可管理的子集；如果在一次迭代中，有的需求不能满足用户的要求，可在下一次迭代中予以修正。\n\n\t主要特征：该模型显式地把需求获取扩展到需求阶段，既为了第二个构造增量，使用了第一个构造增量来精化需求。演化模型在一定程度上可以减少软件开发活动的盲目性。\n不足之处：在演化模型的使用中，即使很好地理解了需求或设计，也很容易弱化需求分析阶段的工作。\n\n4. 螺旋模型\n\n\t螺旋模型将瀑布模型与增量模型结合起来，加入了两种模型均忽略了的风险分析，弥补了这两种模型的不足。因而它是一种风险驱动的模型。螺旋模型将开放过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合。\n\n\t螺旋模型关注解决问题的基本步骤，即标识问题，标识一些可选方案，选择一个最佳方案，遵循动作步骤并实施后续工作。其一个突出特征是，在开发的迭代中实际上只有一个迭代过程真正开发了可交付的软件。螺旋模型与演化模型和增量模型相比，同样适用了瀑布模型作为一个嵌入的过程，但螺旋模型所关注的阶段以及它们的活动是不同的。如果项目的开发风险很大或客户不能确定系统需求，在更广泛的意义上来讲，还包括一个系统或系统类型的要求，这时螺旋模型就是一个很好的生存周期模型。\n\n5. 喷泉模型\n\n\t喷泉模型体现了软件创建所固有的迭代和无间隙的特征。该模型主要用于支持面向对象技术的软件开发。由于对象概念的引入，使分析、设计、实现之间的表达没有明显间隙。\n\n### 过程规划与管理\n\n1. 创建一个软件项目生存周期过程的步骤\n\n\t1. 选择软件生存周期模型\n\t2. 细化所选择的生存周期模型\n\t3. 为每一个活动或任务标识合适的实例数目\n\t4. 确定活动的时序关系，并检查信息流\n\t5. 建立过程计划的文档\n\t\n2. 软件评估中应考虑的影响因素\n\n\t1. 不管做怎么样的决策，都必须对所采取的的措施对生存周期过程所产生的影响进行评审，以便保证项目获得好的结果。在这一评估中，应考虑以下几方面的影响。\n\t\t1. 所要求的的“返工”\n\t\t2. 资源需求\n\t\t3. 实施时间\n\t\t4. 对项目和用户的益处\n\t\t5. 员工情绪\n\n## 集成化能力成熟度模型（CMMI）\n\n### 背景和原理\n\n1. 过程改善\n\n\t历史过程改善，是指人为设计的一个活动程序，其目的是改进组织的过程性能和成熟度，并改进这一程序的结果\n\n2. 过程域、专用目标和共用目标\n\n\t过程域是一个业务域中一束相关的实践，当它们一起得以实现时，就满足被认为对该过程域的改善具有重要作用的一组条件\n\t专用目标是用于描述满足该过程域必须呈现的一些独有特征。经可以用于帮助确定一个过程域是否得以满足。\n\t共用目标用于描述产现制度化的该过程必须呈现的特征，仅用于确定一个过程域是否得以满足。\n\n### CMMI的模型部件\n\n|过程域类名|包括的过程域|\n|:---:|:---|\n|项目管理类|项目规划<br/>项目监控<br/>定量项目管理<br/>集成项目管理<br/>风险管理<br/>提供方协议管理|\n|工程类|需求开发<br/>需求管理<br/>技术解决方案<br/>产品集成<br/>确认<br/>验证|\n|支持类|配置管理<br/>过程和产品质量保证<br/>测量与分析<br/>原因分析与解决<br/>决策分析与解决|\n|过程管理类|组织过程定义<br/>组织过程性能<br/>组织过程培训<br/>组织过程关注<br/>组织创新与部署|\n\n### CMMI的等级\n\n1. 能力等级的组成\n\n\t能力等级是用来表征组织对一个过程域的改善，是不断改善一个给定过程域的一种手段。在CMMI中，针对每个过程域设定了6个能力等级，即0级：未完成级；1级：已执行级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：待续优化级。\n\t\n2. 成熟度等级的组成\n\t\n\t在CMMI中，应用于一个组织过程改善的成熟度等级有5个。即1级：初始级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：持续优化级\n\t\n3. 能力等级与成熟度等级之间的基本关系\n\n\t1. 能力等级与成熟度等级是互补的关系，两者都是一种过程改善路径，即表征组织对单一过程域的改进。\n\t2. 成熟度等级的路径可使组织针对单一过程域不断改善一组相关过程域，即表征组织对一组过程域的改进。\n\t3. 两种等级的2-5级使用了同样的名字\n\t\n4. 达到各共用目标要实施的共同实践\n\n\t达到公用目标2、共用目标3、共用目标4和共用目标5所要实施的共同实践如下表所示\n\t\n||所要实施的共用实践|\n|:---:|:---:|\n|共用目标2：把过程制度化为一个管理过程|GP2.1 建立组织策略<br/>GP2.2 规划过程<br/>GP2.3 提供资源<br/>GP2.4 指派责任<br/>GP2.5 培训人员<br/>GP2.6 管理配置<br/>GP2.7 标识相关利益方的参与<br/>GP2.8 监控过程<br/>GP2.9 客观地评估符合性<br/>GP2.10 从高层管理的视觉评审状态<br/>|\n|共用目标3：把过程制度化为一个已定义过程|GP3.1 建立一个已定义的过程<br/>GP3.2 收信进信息 所要实施的共用实践|\n|共用目标4：把过程制度化为一个已定量管理过程|GP4.1 为该过程建立定量目的<br/>GP4.2 使子过程性能达到稳定|\n|共用目标5：把过程制度化为一个持续优化过程|GP5.1 确保不断进行过程改善<br/>GP5.2 收集问题的根本原因|\n\n完结\n","slug":"如何开发-管理一个项目","published":1,"updated":"2021-04-18T17:08:56.221Z","_id":"cknndog67005745n038bc1y7q","comments":1,"layout":"post","photos":[],"link":"","content":"<p>如何管理一个项目，这是个沉重的话题。实际上，目前很多人都是凭借经验进行项目管理和开发，事实上管理项目是有着大量的方法论，这些方法论整理起来被人归纳成了一个学科，名字叫做<code>软件工程</code>，接下来的内容将会归纳总结里面的一些要点，如果你有意成为一个项目管理者，请必须了解一下这些基础知识。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"软件系统模型\"><a href=\"#软件系统模型\" class=\"headerlink\" title=\"软件系统模型\"></a>软件系统模型</h2><p>开始一个项目之前，你需要做好准备，那就是建立系统模型，有了抽象的模型，才会有具像的实现。</p>\n<ul>\n<li>在软件开发中，软件系统模型大体可分为两类：<code>概念模型</code>和<code>软件模型</code>。</li>\n<li>概念模型是创建在需求层上的，它描述了系统是什么。</li>\n<li>软件模型是建立在抽象层上的，它描述了实现概念模型的软件解决方案。</li>\n<li>软件模型可进一步分为<code>设计模型</code>、<code>实现模型</code>和<code>部署模型</code>。</li>\n</ul>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h3><p> 一个完整的需求需要有以下特征：</p>\n<ol>\n<li>必要的：该需求是用户所要求的（产品经常会提一些伪需求，比如说在帖子列表添加个一键评价，点击了就回复666，但实际上没有用户想毫无感情地666，所以这是伪需求，不满足该条件的请拒绝）；</li>\n<li>无歧义的：该需求只能用一种方式解释（这个就不用解释了，遇到有歧义的需求请问清楚）；</li>\n<li>可测的：该需求可以进行测试；</li>\n<li>可跟踪的：该需求可以从一个开发阶段跟踪到另一个开发阶段（意思就是这个需求不会因为开发的进行变得模糊、不清晰）；</li>\n<li>可测量的：该需求是可测量的（意思就是实现这个需求不能无限耗费人力物力，说好这个需求两个人一天能做完，就两个人一天真的能做完）。</li>\n</ol>\n<h3 id=\"类别\"><a href=\"#类别\" class=\"headerlink\" title=\"类别\"></a>类别</h3><ol>\n<li>功能需求：系统或系统构件必须执行的功能</li>\n<li>非功能需求：分为性能需求、外部接口需求、设计约束需求、质量属性需求。</li>\n</ol>\n<h3 id=\"怎么发现需求\"><a href=\"#怎么发现需求\" class=\"headerlink\" title=\"怎么发现需求\"></a>怎么发现需求</h3><table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">情况</th>\n<th align=\"center\">成功条件</th>\n<th align=\"center\">风险</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">自悟</td>\n<td align=\"center\">自己想</td>\n<td align=\"center\">要比你的最终客户拥有更多的一样弄领域和过程方面的知识和丰富的想象力，也就是你要比你的用户更加清楚用户要啥</td>\n<td align=\"center\">无法验证你想出来的东西是不是你的用户想要的</td>\n</tr>\n<tr>\n<td align=\"center\">交谈</td>\n<td align=\"center\">跟你的客户聊</td>\n<td align=\"center\">你能提出正确的问题，回答人能揭示需求本质的能力</td>\n<td align=\"center\">可能会获得一堆需求，而且越来越多，不断增长，可能还会推翻你之前的需求，可能导致超出项目成本和进度的限制<s>（甚至可能被你的开发揍一顿）</s></td>\n</tr>\n<tr>\n<td align=\"center\">观察</td>\n<td align=\"center\">你去看你的用户怎么用你的软件</td>\n<td align=\"center\">你需要有洞察事物本质的能力</td>\n<td align=\"center\">1. 你的用户会抵触你的观察（很明显侵犯隐私了）2. 用户会觉得你是不是这软件没做好或者哪里需求不到位所以老是来看我，对你的软件产生怀疑</td>\n</tr>\n<tr>\n<td align=\"center\">小组会</td>\n<td align=\"center\">项目组的人全部叫出来开会讨论需求</td>\n<td align=\"center\">你小组的人有不同观点，并且有良好的发现需求的能力，能揭示需求中存在的问题，最重要的是需求能跟用户达成共识</td>\n<td align=\"center\">会议组织不到位就凉了，而且天天开会你的项目组的人也受不了，可能会提出矛盾需求</td>\n</tr>\n<tr>\n<td align=\"center\">提炼</td>\n<td align=\"center\">针对已有的部分需求文档，看线上反馈情况，进行提炼</td>\n<td align=\"center\">你需要有想象力和需求标识能力，包括熟悉相关的技术标准</td>\n<td align=\"center\">跟自悟一样，你不能知道你发现的需求是否是对的</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"需求规约\"><a href=\"#需求规约\" class=\"headerlink\" title=\"需求规约\"></a>需求规约</h3><p>需求规约就是怎么写一个需求表，因为形式很多，所以最好就根据实际情况进行，这里不做规定，但是必须包含以下几个特征</p>\n<ol>\n<li>重要性和稳定性：需求要根据重要程度和稳定程度分优先级，例如：基本需求、可选需求和期望需求。</li>\n<li>可修改的：在不过多地影响其他需求的情况下，可以容易地修改一个单一需求。</li>\n<li>完整的：没有被遗漏的需求。</li>\n<li>一致的：不存在互斥的需求。</li>\n</ol>\n<p>为什么需求规约很重要？（概念性东西）</p>\n<ol>\n<li>是软件开发组织和用户之间一份事实上的技术合同书，是产品功能及其环境的体现。</li>\n<li>对于项目的其余大多数工作，需求规约是一个管理控制点。</li>\n<li>对于产品/系统的设计，需求规约是一个正式的、受控的起点。</li>\n</ol>\n<h2 id=\"结构化方法\"><a href=\"#结构化方法\" class=\"headerlink\" title=\"结构化方法\"></a>结构化方法</h2><h3 id=\"结构化需求分析\"><a href=\"#结构化需求分析\" class=\"headerlink\" title=\"结构化需求分析\"></a>结构化需求分析</h3><ol>\n<li><p>为什么要这么做？</p>\n<p> 为了应对三大挑战：</p>\n<pre><code> - 问题空间理解。（假如让你开发一个八字排盘App，但是你又不懂八字，所以要开发出一个高质量、满足用户要求的App，就不容易了）\n - 人与人之间的通信。（开发过程长、活动多、任务重，项目组成员多，直接面对面沟通起来难免有遗漏、误解等，所以这也是一个挑战）\n - 需求的变化性。（需求是不断变化的，所以这是软件开发人员面临的挑战）\n</code></pre>\n<p> 一种好的需求技术应该具有以下基本特征：</p>\n<pre><code> 1. 提供方便通信的机子，例如，在不同开发阶段，使用对相关人员易于理解的语言。\n 2. 鼓励需求分析人员使用问题空间的术语思考问题，编写文档。\n 3. 提供定义系统边界的方法。\n 4. 提供支持抽象的基本机制，例如，&quot;划分&quot;，&quot;功能抽象&quot;，&quot;结构抽象&quot;等。\n 5. 为需求分析人员提供多种可供选择的方案。\n 6. 提供特定的技术，适应需求的变化等。\n</code></pre>\n</li>\n<li><p>几种基本术语的解释</p>\n<p> (1) 数据流：数据流是数据的流动，用于表达在分析中所要使用的、用于表达”客体”的信息，用箭头表示。<br> 大概长这样：</p>\n <img width=50px src='https://i.loli.net/2019/10/21/wM2SkZXGDY46lQh.png'>\n (2) 加工：加工是数据变换的单元，即它接受输入的数据，对其进行处理，并产生输出。\n 大概长这样\n <img width=50px src='https://i.loli.net/2019/10/21/mcfwVCaJI1Sn8kZ.png'>\n (3) 数据存储：数据存储是数据的静态结构。\n 大概长这样(可以是横的或者竖的)\n <img width=50px src='https://i.loli.net/2019/10/21/xbXKc45RlYpnNB9.png'>\n (4) 数据源和数据潭: 数据源是数据流的起点，数据潭是数据流的归宿地。数据源和数据潭是系统之外的实体，可以是人、物或其他软件系统。\n 大概长这样\n <img width=50px src='https://i.loli.net/2019/10/21/LiwWbnSAs7Pqzoh.png'></li>\n<li><p>数据流图</p>\n<p> 把上面的元素组成起来就是数据流图了<br> 大概长这样</p>\n <img width=70% src=\"https://i.loli.net/2019/10/21/wDdaFiLe9Ps6UzA.png\">\n\n<p> 几个要点：1）数据流起到连接其他实体的作用，实体可以是加工、数据存储、数据源和数据潭；2）加工之间可以有多个数据流，这些数据流之间可以没有任何关系，数据流图也不表明他们的先后次序；3）对于一个比较大的软件系统，往往需要采用多层次的数据流图。</p>\n</li>\n<li><p>建模过程</p>\n<ol>\n<li>建立系统环境图，确立系统语境</li>\n<li>自顶向下，逐步求精，建立系统的层次数据流图</li>\n<li>定义数据字典。数据字典有3种基本结构表示：顺序结构，选择结构，重复结构。<ul>\n<li>顺序结构是指数据A由数据B和数据C顺序构成的，并记为”+”。例如：学生成绩=姓名+性别+学号+科目+成绩，其中”=”号表达的是”定义为”.</li>\n<li>选择结构是指由数据A是由数据B或数据C定义的，即数据B不可能同时是B和C，并记为“|”，例如：性别=男|女</li>\n<li>重复结构是指数据A是由多个重复出现的数据B构成的，并记为”| |”，例如：学生成绩表=|学生成绩|<img width=\"50%\" src=\"https://i.loli.net/2019/10/21/43hSWgZPmVirHfA.png\"></li>\n</ul>\n</li>\n<li>描述加工：该步的目标为依据系统的数据流图，给出其中每一加工的小说明。加工可以有3种表达工具。<ol>\n<li>结构化自然语言（自然语言描述）</li>\n<li>判定表: 由条件类别，条件组合，操作，操作执行构成。举例如图<img width=50% src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D22%2C0%2C590%2C389%3Bc0%3Dbaike80%2C5%2C5%2C80%2C26/sign=d64b6fc508087bf469a30da9cfe16500/42166d224f4a20a48dfd6c499a529822730ed059.jpg\"></li>\n<li>判定树。举例如图<img width=60%  src=\"https://i.loli.net/2019/10/21/COmGSet5I61lFsH.png\"></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>注意事项：</p>\n<ol>\n<li>模型平衡问题</li>\n<li>信息复杂性控制问题</li>\n</ol>\n</li>\n<li><p>需求验证<br> 验证需求规格说明书中的每一单一需求是否满足5个性质，即必要性、无歧义性、可测性、可跟踪性、可测量性；验证需求规格说明是否满足4个性质，即重要性和稳定程度、可修改性、完整性和一致性。在必要时还需要验证其他特性，如设计无关性。</p>\n</li>\n</ol>\n<h3 id=\"结构化设计\"><a href=\"#结构化设计\" class=\"headerlink\" title=\"结构化设计\"></a>结构化设计</h3><h4 id=\"总体设计步骤\"><a href=\"#总体设计步骤\" class=\"headerlink\" title=\"总体设计步骤\"></a>总体设计步骤</h4><p>结构化设计方法基于<code>自顶向下，功能分解</code>的基本原则，针对两种不同类型的数据流图，分别提出了变换设计和事务设计。其中，变换设计的目标是将变换型数据流图映射为模块结构图，而事务设计的目标是将事务型数据流图映射为模块结构图。</p>\n<ol>\n<li><p>变换型数据流图和事务性和数据流图<br>（1）变换型数据流图：具有比较明显的输入部分和变换部分之间的界面、变换部分和输出部分之间界面的数据流图，称为变换型数据流图；<br><img src=\"https://www.sytm.net/ueditor/net/upload/2013-12-31/bdae1434-8b79-4209-b818-2502c7ea3bee.png\"><br>（2）事务型数据流图：数据到达一个加工T，该加工T根据输入的值，在其后若干动作序列中选出一个来执行，这类数据流图成为事务型数据流图。<br><img src=\"https://www.sytm.net/ueditor/net/upload/2013-12-31/142b2c91-a9ad-4c6e-b075-ecd6a900ee63.png\"></p>\n</li>\n<li><p>总体设计分为3个阶段。第一阶段为初始设计，在对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。第二阶段为精化设计，依据模块“高内聚低耦合”的原则精化初始的模块结构图，并设计其中的全局数据结构和每一模块的接口。第三阶段为复审阶段，对前两个阶段所得到的高层软件结构进行复审，必要时还可能需要对该软件结构做一些精化工作，这对软件的一些性质，特别是对软件质量的提高，将产生非常大的影响。</p>\n</li>\n<li><p>天天扯着嗓子喊高内聚低耦合，到底什么是内聚什么是耦合？</p>\n<ul>\n<li>耦合：耦合是指不同模块之间相互依赖程度的度量<ul>\n<li>内容耦合：当一个模块直接修改或操作另一个模块的数据，\u001d或当一个模块直接修改或操作，另一个模块的数据或一个模块不通过正常入口转入到一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该尽量避免使用。</li>\n<li>公共耦合：两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。</li>\n<li>控制耦合：一个模块通过接口向另一个模块传递一个控制信号，接收信号的模块根据信号值进行适当的动作，这种耦合被成为控制耦合。</li>\n<li>标记耦合：若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。</li>\n<li>数据耦合：模块之间通过参数来传递数据，则称为数据耦合。数据耦合是最低的一种耦合形式。</li>\n</ul>\n</li>\n<li>内聚：内聚是指一个模块内部各成分之间相互关联程度的度量<ul>\n<li>偶然内聚：如果一个模块的各成分之间基本不存在任何关系，则称为偶然内聚</li>\n<li>逻辑内聚：几个逻辑上相关的功能被放在同一模块中，则称为逻辑内聚。</li>\n<li>时间内聚：如果一个模块完成的功能必须在同一时间内执行（例如，初始化系统或一组变量），但这些功能只是因为时间因素关联在一起，则称为时间内聚。</li>\n<li>过程内聚：如果一个模块内部的处理成分是相关的，而且这些处理必须以特定的次序执行，则称为过程内聚。</li>\n<li>通信内聚：如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚</li>\n<li>顺序内聚：如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚</li>\n<li>功能内聚：最理想的内聚是功能内聚，模块所有的成分对于完成单一的功能都是基本的。功能内聚的模块对完成其功能而言是充分必要的。</li>\n</ul>\n</li>\n<li>启发式规则：无论是变换设计还是事务设计，都涉一个共同的问题，即“基于高内聚低耦合的原理，采用一些经验性的启发式规则，对初始的模块结构图进行精化，形成最终的模块结构图”。</li>\n<li>怎么做？<ol>\n<li>改进软件结构，提高模块独立性。</li>\n<li>力求模块规模适中。</li>\n<li>力求深度、宽度、扇出和扇入适中。深度：表示其控制的<code>层数</code>(不包括自身)；宽度：同一层次上模块总数的<code>最大值</code>；扇出：一个模块<code>直接</code>控制（调用）的下级模块数目；扇入：一个模块有多少个上级模块<code>直接</code>调用它。</li>\n<li>尽力使模块的作用域在其控制域之内。作用域：受该模块内<code>一个判定</code>所影响的所有模块的集合；控制域：模块本身以及所有<code>直接或间接</code>从属于它的模块的集合。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"详细设计步骤\"><a href=\"#详细设计步骤\" class=\"headerlink\" title=\"详细设计步骤\"></a>详细设计步骤</h4><ol>\n<li>结构化程序设计<br> 包含三种基本控制结构：顺序结构、选择结构、循环结构</li>\n<li>详细设计工具<ol>\n<li>程序流程图 <img width=20% src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945069712&di=74b11092aae0042569e80dc22ee83438&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F09%2F17%2F02%2F27798515%2F15.files%2Ffile0001.jpg\">\n 缺点：不是一种逐步求精的工具，过早地考虑程序的流程，不去考虑程序的全局结构；所表达的控制流，往往不受任何约束可随意转移，从而会影响甚至破坏好的系统结构设计；不易表示数据结构。</li>\n<li>盒图（N-S图） <img width=40% src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945228461&di=10908d6d12f9c8984356e884b3c0aeb5&imgtype=0&src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fzhidao%2Fwh%253D450%252C600%2Fsign%3Da401ed95523d26972e86005960cb9ecd%2Fd833c895d143ad4bd5fe969f81025aafa50f0698.jpg\"></li>\n<li>PAD图（Problem Analysis Diagram） <img width=\"40%\" src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945326054&di=d66d2f92c755db3f26640c2bbb6bc338&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F12%2F15%2F14%2F51872755%2F6.files%2Ffile0001.jpeg\"></li>\n</ol>\n N-S图和PAD图支持“自顶向下逐步求精”的设计。可节省人工编码工作，有利于提高软件的可靠性和软件生产率<ol start=\"4\">\n<li>类程序设计语言（伪码/PDL）<br> 是一种用正文形式表示数据结构和处理过程的设计工具，PDL是一种“混合”的语言。</li>\n</ol>\n</li>\n<li>设计规约<br> 完成软件设计后，应产生设计规约，完整准确地描述满足系统需求规约所要求的的所有功能模块，以及伴随功能模块而出现的非功能机制。设计规约通常包括<code>概要设计规约</code>和<code>详细设计规约</code>。 <code>概要设计规约</code>指明高层软件体系结构，其主要功能如下： 1.系统环境等与设计有关的限定条件 2. 软件模块的结构（模块之间的接口及设计的数据流和主要数据结构）3. 模块描述（接口定义，模块处理逻辑，必要的注释等）4. 文件结构和全局数据文件的逻辑结构 5.测试需求 <code>详细设计规约</code>（包括各处理过程的算法和算法所涉及的全部数据结构的描述）主要作为软件设计人员与程序员之间交流的媒体。</li>\n</ol>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><h3 id=\"UML是一种图形化建模语言（Unified-Modeling-Language）\"><a href=\"#UML是一种图形化建模语言（Unified-Modeling-Language）\" class=\"headerlink\" title=\"UML是一种图形化建模语言（Unified Modeling Language）\"></a>UML是一种图形化建模语言（Unified Modeling Language）</h3><p>为了支持抽象分析和设计中的事物，UML给了八个基本术语，即类、接口、协作、用况、主动类、构件、制品、节点、</p>\n<ul>\n<li>类： 类是一组拥有相同属性、操作、关系和语义的对象的描述。类主要用于抽象客观世界中的事物。</li>\n<li>接口：每个操作描述了类、构件或子系统的一个服务，接口就是操作的一个集合。接口是对系统/产品的“接缝”予以模型化，表明了一个类、构件、子系统所需要得到的、且与实现无关的行为。</li>\n<li>用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的、可观察的结果。</li>\n<li>协作：协作是一个交互，涉及交互的三要素：交互各方、交互方式以及交互内容</li>\n<li>用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的，可观察的结果。</li>\n<li>主动类：主动类是一种至少具有一个进程或线程的类。</li>\n<li>构件：构件是系统设计中的一种模块化部件，通过外部接口隐藏了它的内部实现。</li>\n<li>制品：制品是系统中包含物理信息（比特）的、可替代的物理部件。</li>\n<li>节点：节点是运行时存在的物理元素，通常表示一种具有记忆能力和处理能力的计算机资源。</li>\n</ul>\n<p>类在建模中的主要用途：</p>\n<ol>\n<li>模型化问题域中的概念</li>\n<li>建立系统的职责分布模型</li>\n<li>模型化建模中使用的基本类型</li>\n</ol>\n<p>使用接口应注意的问题</p>\n<ol>\n<li>接口只可以被其他类目使用，而本身不能访问其他类目</li>\n<li>接口描述类的外部可见操作，通常是该类的一个特有限定行为。这些操作可以使用可见性、并发性、衍型、标记值和约束来修饰。</li>\n<li>接口不描述其中操作的实现，也没有属性和状态。据此可见，接口在形式上等价于一个没有属性、没有方法而只有抽象操作的抽象类</li>\n<li>接口之间没有关联、泛化、实现和依赖。但可以参与泛化、实现和依赖</li>\n</ol>\n<h3 id=\"表达关系的术语\"><a href=\"#表达关系的术语\" class=\"headerlink\" title=\"表达关系的术语\"></a>表达关系的术语</h3><pre><code>关联：关联是一组具有相同结构、相同链的描述，是类目之间的一种结构关系。关联可以用一条连接两个类目的线段表示，并可对其命名，其结构可以具有方向性，用一个实心三角形来指示关联的方向。\n    1. 关联名 。\n    2. 导航：对于一个给定的类目，可以找到与之关联的另一个类目，这称为导航。\n    3. 角色：角色是关联一端的类目对另一端的类目的一种呈现。\n    4. 可见性：通过导航可以找到另一类目的实例，有时候需要限制访问。\n    5. 多重性：类中对象参与一个关联的数目，成为该关联的多重性\n    6. 限定符：限定符是一个关联的属性或属性表。\n    7. 聚合：分类是增强客观实际问题语义的一种手段。聚合是对象之间（不是类之间）的一种结构关系。\n    8. 组合：组合是聚合的一种特殊形式\n泛化：泛化是一般性类目和它的较为特殊类目之间的一种关系。子类可以继承父类的属性和操作，同时也可以替换父类的声明。\n    泛化的四种约束：完整、不完整、互斥、重叠\n细化：细化是类目之间的语义关系，其中一个类目规约保证了另一个类目执行的契约。\n依赖：依赖用于描述一个类目使用另一个类目的信息和服务，是一种使用关系。\n    依赖的分类：绑定、导出、允许、示例、实例化、幂类型、精化、使用。\n    \n关联、泛化和细化都是一类特地类型的依赖。\n\n使用这四种术语，可以模型化以下各种关系：\n1. 结构关系（静态结构和动态结构）\n    进行模型化时两种驱动方式：1.以数据驱动 2. 以行为驱动\n2. 继承关系\n3. 精化关系\n4. 依赖关系\n</code></pre>\n<h3 id=\"表达组合信息的术语————包\"><a href=\"#表达组合信息的术语————包\" class=\"headerlink\" title=\"表达组合信息的术语————包\"></a>表达组合信息的术语————包</h3><p>为了控制信息组织的复杂性，UML提供了组织信息的一种通用机制————包，支持形成一些可管理的部分。换言之，包可以作为“模块化”和“构件化”的一种机制。</p>\n<p>包是模型元素的一个分组。一个包本身可以被嵌套在其他包中，并且可以含有子包和其他种类的模型元素。</p>\n<p>通过在包的名字前加上一个可见性符号（+，-，#），来指示该包的可见性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ 表示对其他包而言都是可见的</span><br><span class=\"line\"># 表示对子孙包而言是可见的</span><br><span class=\"line\">- 表示对其他包而言都是不可见的</span><br></pre></td></tr></table></figure>\n\n<p>为了模型化包之间的关系，UML给出了两种依赖，即访问和引入。</p>\n<ul>\n<li>访问：表明目标包中的内容可以被源包所引用，或被那些递归嵌套在源包中的其他包所引用。</li>\n<li>引入：表明目标包中具有适当可见性的内容（名字）被加入到源包的公共命名空间中。</li>\n</ul>\n<p>UML中用虚线加箭头的方式表示源包到目标包的依赖（访问和引入）。</p>\n<h3 id=\"UML术语的作用\"><a href=\"#UML术语的作用\" class=\"headerlink\" title=\"UML术语的作用\"></a>UML术语的作用</h3><ol>\n<li>类用于抽象客观事物</li>\n<li>接口用于抽象事物之间的缝隙</li>\n<li>协作用于抽象协作性行为</li>\n<li>用况用于抽象功能</li>\n<li>主动类用于抽象并发行为</li>\n<li>构件用于抽象软件解中标识的成分</li>\n<li>制品用于抽象工作产品</li>\n<li>节点用于抽象计算单元</li>\n<li>关联用于抽象结构关系</li>\n<li>泛化用于抽象“一般/特殊”关系</li>\n<li>实现用于抽象精化关系</li>\n<li>依赖用于抽象使用关系</li>\n</ol>\n<h3 id=\"UML的模型表达式\"><a href=\"#UML的模型表达式\" class=\"headerlink\" title=\"UML的模型表达式\"></a>UML的模型表达式</h3><ol>\n<li>结构图和行为图<br> 结构图用于表达系统或系统成分的静态结构模型，给出系统或系统成分的一些说明性信息<br> 行为图用于表系统或系统成分的动态结构模型，给出系统或系统成分的一些行为信息</li>\n<li>类图、用况图、顺序图及状态图<ul>\n<li>类图是可视化地表达系统静态结构功能模型的工具，使用类图所表达的系统静态结构模型，给出的是一些关于系统的说明性信息。<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176025075&di=1875f9ac829f33a38a45131069ee3e4a&imgtype=0&src=http://images.cnblogs.com/cnblogs_com/a-i/Uml2.JPG\"></li>\n<li>用况图是一种表达系统功能模型的图形化工具，它包含六个模型元素，分别是主题、用况、参与者、关联、泛化、依赖<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176303343&di=4146dfc9badef7bc95f4c750ab149eb0&imgtype=0&src=http://yzhtml01.book118.com/2016/09/24/23/28839740/23.files/file0001.png\"></li>\n<li>顺序图由一组对象以及按时序组织的对象之间的关系组成，是一种交互图，包含对象之间传递的信息。控制操作包括<code>选择执行操作</code>、<code>条件操作</code>、<code>并发迭代操作</code>、<code>迭代执行操作</code>。<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176439921&di=d592e65ae4a1bc1c2e65a98e415a897a&imgtype=0&src=http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/png/20180615101636402475.png\"></li>\n<li>状态图强调了从一个状态到另一个状态的控制流，是显示一个状态机的图。状态图由状态、事件和状态转移构成。使用状态图的作用有两个：一是创建一个系统的动态模型，二是创建一个场景的模型<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176576658&di=70e3de58666cf1d7315cf56a05ec0d35&imgtype=0&src=http://yzhtml01.book118.com/2016/12/07/08/48638362/25.files/file0001.png\"></li>\n<li></li>\n</ul>\n</li>\n<li>创建一个系统的类图的步骤<ul>\n<li>模型化代建系统中的概念，形成类图中的基本元素</li>\n<li>模型化代建系统中的各种关系，形成该系统的初始类图</li>\n<li>模型化系统中的协作，给出该系统的最终类图</li>\n<li>模型化逻辑数据库模式</li>\n</ul>\n</li>\n<li>信号事件、调用事件、时间事件和变化事件<ul>\n<li>信号事件是一种异步事件，信号通常由状态机处理。如果没有定义对该事件的响应，那么事件均可能丢失。事件的丢失，就有可能引发接受者——状态机的一个错误的状态转移。</li>\n</ul>\n</li>\n<li>状态转移所涉及的内容<br> 描述一个状态转换，一般涉及五个部分：<ol>\n<li>源状态：发生状态转移的那个状态</li>\n<li>转移触发器：在源状态中由对象识别的事件，并且一旦满足其监护条件，则使状态发生转移。</li>\n<li>监护条件：一个布尔表达式，当某个事件触发器接受一个事件时，如果该表达式有值为真，则触发一个转移；若有值为假，则不发生状态转移。</li>\n<li>效应：一种可执行的行为</li>\n<li>目标状态：转移完成后所处的状态</li>\n</ol>\n</li>\n<li>最常用的控制操作子<br> 选择执行操作子：该操作子由两部分组成：一是监护条件，二是控制体<br> 条件执行操作子：控制体通过水平线将其分为一些部分，每一部分表示一个条件分支，每一分支有一个监护条件。<br> 并发执行操作子：该控制操作子的体通过水平线将其分为多个部分，每一部分表示一个并行计算。该控制操作子表明，当进入该控制操作子是，所有部分并发执行。<br> 迭代执行操作子：该控制操作子表明，只要在每一次迭代之前该监护条件为真，那么该控制体就反复执行，当该控制体上面的监护条件为假时，控制绕过该控制操作子。</li>\n<li>子状态机、简单状态和组合状态的概念<br> 子状态机：为了有效地组织状态、控制对象状态的复杂性，UML提供了组合状态，在一个状态机中引入了另一个状态机。被引入的状态机就称为子状态机。<br> 简单状态：子状态是被嵌套到另一状态中的状态。相对地，被引入的状态机就称为子状态机。<br> 组合状态：把含子状态的状态称为组合状态，组合状态可包含两种类型的子状态机，即非正交（顺序）子状态机和正交（并发）子状态机。<h2 id=\"RUP\"><a href=\"#RUP\" class=\"headerlink\" title=\"RUP\"></a>RUP</h2></li>\n</ol>\n<h3 id=\"RUP-Rational-Unified-Process-的特点\"><a href=\"#RUP-Rational-Unified-Process-的特点\" class=\"headerlink\" title=\"RUP(Rational Unified Process)的特点\"></a>RUP(Rational Unified Process)的特点</h3><p>RUP的突出特点是，它是一种以用况（Use Case）为驱动的、以体系结构为中心的迭代、增量式开发。</p>\n<ol>\n<li>以用况为驱动<br>以用况为驱动是指在系统的生存周期中，以用况作为基础，驱动系统有关人员对所要建立系统的功能需求进行交流，驱动系统分析、设计、实现和测试等活动。</li>\n<li>以体系结构为中心<br>以体系结构为中心是指在系统的生存周期中，开发的任何阶段都要给出相关模型视角下有关体系结构的描述，作为构思、构造、管理和改善系统的主要标准。</li>\n<li>迭代、增量式开发<br>迭代、增量式开发是指通过开发活动的迭代，不断地产生相应的增量。在RUP中，规定了四个开发阶段：初始阶段、精化阶段、构造阶段和移交阶段。</li>\n</ol>\n<h3 id=\"核心工作流\"><a href=\"#核心工作流\" class=\"headerlink\" title=\"核心工作流\"></a>核心工作流</h3><p>核心工作流：需求获取、分析、设计、实现和测试</p>\n<h4 id=\"需求获取\"><a href=\"#需求获取\" class=\"headerlink\" title=\"需求获取\"></a>需求获取</h4><table>\n<thead>\n<tr>\n<th align=\"center\">基本步骤</th>\n<th align=\"center\">产生的制品</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">列出候选的特征</td>\n<td align=\"center\">特征表</td>\n</tr>\n<tr>\n<td align=\"center\">理解系统语境</td>\n<td align=\"center\">领域模型或业务模型</td>\n</tr>\n<tr>\n<td align=\"center\">捕获功能需求</td>\n<td align=\"center\">用况模型</td>\n</tr>\n<tr>\n<td align=\"center\">捕获非功能需求</td>\n<td align=\"center\">补充需求或针对特殊需求的用况</td>\n</tr>\n</tbody></table>\n<h3 id=\"业务用况模型和业务对象模型\"><a href=\"#业务用况模型和业务对象模型\" class=\"headerlink\" title=\"业务用况模型和业务对象模型\"></a>业务用况模型和业务对象模型</h3><ol>\n<li>业务用况模型。业务用况模型是以用框图予以表达的</li>\n<li>业务对象模型。为了精化业务用况模型中的每一个业务用况，RUP引入了三个术语，用于表达参与业务的业务对象：<code>工作人员</code>、<code>业务实体</code>和<code>工作单元</code>。业务对象模型可通过交互图和活动图予以表达。</li>\n</ol>\n<h3 id=\"标识用况应注意的问题\"><a href=\"#标识用况应注意的问题\" class=\"headerlink\" title=\"标识用况应注意的问题\"></a>标识用况应注意的问题</h3><ol>\n<li>建立用况的结构中，应尽可能反映用况的实际情况。</li>\n<li>在用况的结构化中，不论是施加什么结构，新引入的用况都不应该太小或太大</li>\n<li>在建立用况的结构是，应尽量避免对用况模型中的用况功能进行分解。</li>\n</ol>\n<h4 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h4><ol>\n<li>分析类是类的一种衍型，分为边界类、实体类和控制类</li>\n<li>用况细化时一个协作，针对一个用况，其行为可用多个分析类之间的相互作用来细化，并记为用况细化。用况细化对用况模型中的一个特定的用况提供了一种直接跟踪的方式。</li>\n<li>分析包是一种控制信息组织复杂性的机制，提供了分析制品的一种组织手段。其主要特征为：体现问题的分离；高内聚、低耦合；尽可能体现一个系统的完整顶层设计，尽可能成为一些子系统或者成为一些子系统的组成部分。</li>\n</ol>\n<h4 id=\"具有良好结构的分析包的特征\"><a href=\"#具有良好结构的分析包的特征\" class=\"headerlink\" title=\"具有良好结构的分析包的特征\"></a>具有良好结构的分析包的特征</h4><ol>\n<li>体现问题分离</li>\n<li>高内聚、低耦合。</li>\n<li>尽可能提现一个系统的完整顶层设计。</li>\n</ol>\n<h4 id=\"软件设计层上的术语\"><a href=\"#软件设计层上的术语\" class=\"headerlink\" title=\"软件设计层上的术语\"></a>软件设计层上的术语</h4><p>软件设计是满足需求规约所需要的软件结构。RUP为了满足系统/产品分析模型规约需求的软件结构，为设计层提供了是个术语：设计类、用况细化、设计子系统和接口，用于表达软件结构中的基本元素。</p>\n<ol>\n<li>设计类：一个设计类是对系统中实现一个类或类似构造的一个无缝抽象</li>\n<li>用况细化：用况细化是设计模型的一个协作，其中使用设计类及其对象，描述一个特定用况是如何予以细化的，是如何执行的</li>\n<li>设计子系统：设计子系统可以包含设计类、用况细化、接口，以及其他子系统，通过对其操作来显示其功能。</li>\n<li>接口：接口用于规约由设计类和设计子系统，必须提供与该接口操作对应的实现方法。</li>\n</ol>\n<h4 id=\"创建系统-产品用况模型的活动和任务\"><a href=\"#创建系统-产品用况模型的活动和任务\" class=\"headerlink\" title=\"创建系统/产品用况模型的活动和任务\"></a>创建系统/产品用况模型的活动和任务</h4><p>创建系统/产品用况模型的活动和任务如下</p>\n<ol>\n<li>活动一：发现并描述参与者<br>任务1：发现参与者，即直接发现一些候选的参与者<br>任务2：描述参与者，即对参与者进行命名并描述</li>\n<li>活动二：发现用况并对用况进行描述<br>任务1：发现用况<br>任务2：描述用况，即确定用况后对其进行描述</li>\n<li>活动三：确定用况的优先级，目的是在寻找参与者并对其进行描述和发现用况的并对用况进行描述的基础上确定哪些用况适合在早期的迭代中开发，哪些适合在后期的迭代中开发。</li>\n<li>活动四：精化用况。这一活动的目的是详细描述出每一用况的事件流，包括用况是怎样开始的，是怎样结束的，是怎样与参与者进行交互的，最终形成一系列精化的用况</li>\n<li>活动五：构造用户界面原型。这一活动的目的在于建造用户界面原型，使用户可以有效地执行用况。</li>\n<li>活动六：用况模型的结构化。需要进行以下工作。<ol>\n<li>抽取用况描述中的那些一般性的和共享的功能并使用泛化关系标识和描述那些共享功能</li>\n<li>抽取用况描述附加的或可选的功能</li>\n<li>标识用况之间的包含关系。通过用况模型的结构化，最终形成一个系统/产品的精化用户模型</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"创建系统-产品需求分析模型的活动和任务\"><a href=\"#创建系统-产品需求分析模型的活动和任务\" class=\"headerlink\" title=\"创建系统/产品需求分析模型的活动和任务\"></a>创建系统/产品需求分析模型的活动和任务</h4><ol>\n<li>活动1：体系结构分析。该活动的目标是通过标识分析包和分析类，建立分析模型和体系结构“骨架”，并标识有关分析包和分析类的特定需求。<br>任务1：标识分析包。该任务的基本输入是系统的用况模型<br>任务2：处理分析包之间的共性<br>任务3：标识服务包<br>任务4：定义分析包的依赖，该任务的目标是发现相对独立的包，实现包的高内聚和低耦合<br>任务5：标识重要的实体类，该任务的目标是标识在体系结构方面具有意义的实体类。<br>任务6：标识分析包和重要实体类的公共特定需求，该任务的目标是依据需求获取阶段所标识的非功能需求，针对在分析期间所标识的包和分析类，标识它们的一些公共的特定要求。</li>\n<li>活动2：用况分析。该活动的目标是：一是标识那些在用况事件流执行中所需要的分析类和对象；二是将用况的行为分布到参与交互的各个分析对象；三是捕获用况细化上的特定需求。<br>任务1：标识分析类，该任务的目标是标识在细化一个用况中所需要实体类、控制类和边界类，给出它们的名字、责任、属性和关系。<br>任务2：描述分析类对象之间的交互。首先确定细化该用况所必要的交互，其次分派该用况的功能，最后根据其责任，发现该交互图中的各个链。</li>\n<li>活动3：类的分析。该活动的目标：一是标识并维护分析类的属性和关系；二是捕获分析类细化中的特殊需求。<br>任务1：标识责任，通过组合一个类在不同用况细化中所扮演的角色来完成。<br>任务2：标识属性<br>任务3：标识关联和聚合</li>\n<li>活动4：包的分析。该活的目标是：一是确保分析包尽可能与其他包相对独立；而是确保分析包实现了它的目标；三是描述依赖，以益于可以估计未来的变化。</li>\n</ol>\n<h3 id=\"创建系统-产品设计模型的活动和任务\"><a href=\"#创建系统-产品设计模型的活动和任务\" class=\"headerlink\" title=\"创建系统/产品设计模型的活动和任务\"></a>创建系统/产品设计模型的活动和任务</h3><p>创建系统/产品设计模型的活动和任务如下：</p>\n<ol>\n<li>活动1：体系结构设计，该活动的目标是创建设计模型和部署模型，以及它们视角下的体系结构描述<br>任务1：标识节点和它们的网络配置，网络配置通常使用一种三元模式：客户端、数据库功能、业务/应用逻辑<br>任务2：标识子系统和它们的接口，目的是为了寻求一些复用的可能，而后随着设计模型的开发，在形成子系统结构中不断发现并烟花。<br>任务3：标识在体系结构方面有意义的设计类和它们的接口。标识在体系结构方面有意义的设计类的基本思想是：初始可以依据在体系结构方面有意义的分析类来标识一些体系结构上具有重要意义的设计类。标识在系统体系结构方面有意义的设计类时，应注意主动类往往是一类在体系结构方面具有重要意义的类。</li>\n<li>活动2：用况的设计。其中分析模型用况细化分析是活动的输入、对应输出用况细化设计。<br>为了实现用况设计的输入/输出，一般采用两种方法：<ol>\n<li>标识参与用况细化的设计类，首先基于分析模型研究相应用况细化分析中的分析类，来标识为细化这些分类所需要的设计类，然后基于用况的功能对每一个标识的设计类赋予相应的责任，最后为该细化创建一个类图，汇聚参与该用况细化的设计类，并给出类之间的关系。</li>\n<li>标识参与用况细化的子系统和接口。</li>\n</ol>\n</li>\n<li>活动3：类的设计。该活动的目标是完成用况细化设计中每一个类的角色设计，并完成有关每一类的非功能需求的设计。<br>任务1：概括描述设计类，该任务的输入为分析类/接口。<br>任务2：标识的操作，一般应依据分析类来标识设计类所提供的、所需要的操作，其中需要使用程序设计语言的语法来描述说标识的操作。<br>任务3：标识属性，该任务的目标是标识设计类所需要的属性，并使用程序设计语言的语法给出属性的描述。<br>任务4：标识关联和聚合。<br>任务5：标识泛化，基于分析模型中分析类之间的泛化，可以发现设计模型中的很多泛化。<br>任务6：描述方法，在设计期间一般用自然语言或适当的使用伪码对方法进行规约，但是在实现期间直接使用程序设计语言对方法进行规约。<br>任务7：描述状态，有些设计对象是受状态控制的，即它们的状态确定了它们接受一个消息的行为。在这种情况下，使用一个状态图描述一个对象的不同状态转移是有意义的。</li>\n<li>活动4：子系统的设计。该活动的目标是：确保子系统尽可能独立于其他子系统或它们的接口；确保子系统提供正确的接口；确保子系统实现了它的目标，即给出了该子系统提供的那些接口所定义的操作的细化。</li>\n</ol>\n<h3 id=\"设计模型包含的元素\"><a href=\"#设计模型包含的元素\" class=\"headerlink\" title=\"设计模型包含的元素\"></a>设计模型包含的元素</h3><p>RUP设计的主要结果是设计模型，它尽量保持该系统具有分析模型的结构，并作为系统实现的输入，包含以下四个元素：</p>\n<ol>\n<li>设计子系统和服务子系统，以及它们的接口、依赖和内容。</li>\n<li>设计类以及它们具有的操作、属性、关系及其实现的需求。</li>\n<li>用况细化设计。</li>\n<li>设计模型视角下的体系结构描述。</li>\n</ol>\n<h3 id=\"用况模型与分析模型的比较\"><a href=\"#用况模型与分析模型的比较\" class=\"headerlink\" title=\"用况模型与分析模型的比较\"></a>用况模型与分析模型的比较</h3><table>\n<thead>\n<tr>\n<th align=\"center\">用况模型</th>\n<th align=\"center\">分析模型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">使用客户语言来描述</td>\n<td align=\"center\">使用开发者语言来描述</td>\n</tr>\n<tr>\n<td align=\"center\">给出的是系统对外的视图</td>\n<td align=\"center\">给出的是系统对内的视图</td>\n</tr>\n<tr>\n<td align=\"center\">使用用况予以结构化，但给出的是外部视角下的系统结构</td>\n<td align=\"center\">使用衍型类予以结构化，当给出的是内部视角下的系统结构</td>\n</tr>\n<tr>\n<td align=\"center\">可以作为客户与开发者之间关于“系统应该做什么，不应该做什么”的契约</td>\n<td align=\"center\">可以作为开发者理解系统如何勾画、如何设计和如何实现的基础</td>\n</tr>\n<tr>\n<td align=\"center\">在需求之间可能存在一些冗余、不一致和冲突等问题</td>\n<td align=\"center\">在需求之间不应存在冗余、不一致和冲突问题</td>\n</tr>\n<tr>\n<td align=\"center\">捕获的是系统的功能，包括在体系结构方面有意义的功能</td>\n<td align=\"center\">给出的是细化的系统功能，包括在体系结构方面具有意义的功能</td>\n</tr>\n<tr>\n<td align=\"center\">定义了一些进一步需要在分析模型中予以分析的</td>\n<td align=\"center\">定义了用况模型中每一个用况的细化</td>\n</tr>\n</tbody></table>\n<h3 id=\"RUP实现活动\"><a href=\"#RUP实现活动\" class=\"headerlink\" title=\"RUP实现活动\"></a>RUP实现活动</h3><p>目标：基于设计类和子系统生成构件；对构件进行单元测试，进行集成和连接；把可执行的构件映射到部署模型。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">输入</th>\n<th align=\"center\">活动</th>\n<th align=\"center\">执行者</th>\n<th align=\"center\">输出</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">设计模型、部署模型、体系结构描述【设计模型、部署模型角度】</td>\n<td align=\"center\">实现体系结构</td>\n<td align=\"center\">体系结构设计者</td>\n<td align=\"center\">构件【概述】、体系结构描述【实现模型、部署模型角度】</td>\n</tr>\n<tr>\n<td align=\"center\">补充需求、用况模型、设计模型、实现模型【当前建造】</td>\n<td align=\"center\">集成系统</td>\n<td align=\"center\">系统集成者</td>\n<td align=\"center\">集成建造计划、实现模型【连续的建造】</td>\n</tr>\n<tr>\n<td align=\"center\">集成建造计划、体系结构描述【实现模型角度】、设计子系统【已设计】、接口【已设计】</td>\n<td align=\"center\">实现子接口</td>\n<td align=\"center\">构件工程师</td>\n<td align=\"center\">实现子系统【建造完成】、接口【建造完成】</td>\n</tr>\n<tr>\n<td align=\"center\">设计类【已设计】、接口【由设计类提供】</td>\n<td align=\"center\">实现类</td>\n<td align=\"center\">构件工程师</td>\n<td align=\"center\">构件【完成】</td>\n</tr>\n<tr>\n<td align=\"center\">构件【完成】、接口</td>\n<td align=\"center\">完成单元测试</td>\n<td align=\"center\">构件工程师</td>\n<td align=\"center\">构件【已完成单元测试】</td>\n</tr>\n</tbody></table>\n<h3 id=\"RUP测试活动\"><a href=\"#RUP测试活动\" class=\"headerlink\" title=\"RUP测试活动\"></a>RUP测试活动</h3><p>RUP的测试包括内部测试、中间测试和最终测试</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">输入</th>\n<th align=\"center\">活动</th>\n<th align=\"center\">输出</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">补充需求、用况模型、分析模型、设计模型、实现模型、体系结构的描述</td>\n<td align=\"center\">计划测试</td>\n<td align=\"center\">测试计划</td>\n</tr>\n<tr>\n<td align=\"center\">补充需求、用况模型、分析模型、设计模型、实现模型、体系结构描述、测试计划</td>\n<td align=\"center\">设计测试</td>\n<td align=\"center\">测试用况 测试过程</td>\n</tr>\n<tr>\n<td align=\"center\">测试用况、测试过程、实现模型</td>\n<td align=\"center\">实现测试</td>\n<td align=\"center\">测试构件</td>\n</tr>\n<tr>\n<td align=\"center\">测试用况、测试过程、测试构件、实现模型</td>\n<td align=\"center\">执行集成测试</td>\n<td align=\"center\">缺陷</td>\n</tr>\n<tr>\n<td align=\"center\">测试用况、测试过程、测试构件、实现模型</td>\n<td align=\"center\">执行系统测试</td>\n<td align=\"center\">缺陷</td>\n</tr>\n<tr>\n<td align=\"center\">测试用况、测试模型、缺陷</td>\n<td align=\"center\">评价测试</td>\n<td align=\"center\">测试评价</td>\n</tr>\n</tbody></table>\n<h2 id=\"软件测试\"><a href=\"#软件测试\" class=\"headerlink\" title=\"软件测试\"></a>软件测试</h2><h3 id=\"软件测试目标与软件测试过程模型\"><a href=\"#软件测试目标与软件测试过程模型\" class=\"headerlink\" title=\"软件测试目标与软件测试过程模型\"></a>软件测试目标与软件测试过程模型</h3><h4 id=\"软件测试及目标\"><a href=\"#软件测试及目标\" class=\"headerlink\" title=\"软件测试及目标\"></a>软件测试及目标</h4><p>软件测试的定义为：按照特定规程发现软件错误的过程。其目的是检验它是否满足规定的需求，或清楚了解预期结构与实际结果之间的差异</p>\n<h4 id=\"软件测试与软件调试之间的区别\"><a href=\"#软件测试与软件调试之间的区别\" class=\"headerlink\" title=\"软件测试与软件调试之间的区别\"></a>软件测试与软件调试之间的区别</h4><p>软件测试与软件调试相比，在目的、技术和方法等方面都存在很大区别，主要表现在以下几个方面。</p>\n<ol>\n<li>测试从一个侧面证明程序员的”失败”.调试是为了证明程序员的正确。</li>\n<li>测试以已知条件开始，使用预先定义的程序且有预知的结果，不可预见的仅是程序是否通过。调试一般是以不可知的内部条件开始，除统计性调试外，结果是不可预见的。</li>\n<li>测试是有计划的，并要进行测试设计。调试是不受时间约束的。</li>\n<li>测试是一个发现错误、改正错误、重新测试的过程。调试是一个推理过程。</li>\n<li>测试的执行是有规程的。调试的执行往往要求程序员进行必要推理。</li>\n<li>测试经常是由独立的测试组在不了解软件设计的条件下完成的。调试必须由了解详细设计的程序员完成。</li>\n<li>大多数测试的执行和设计可由工具支持。调试时，程序员能利用的主要工具是调试器。</li>\n</ol>\n<h4 id=\"测试过程模型\"><a href=\"#测试过程模型\" class=\"headerlink\" title=\"测试过程模型\"></a>测试过程模型</h4><p>软件测试是一个有程序的过程，包括测试设计、测试执行以及测试结果比较。测试过程模型可分为三类：环境模型、被测对象模型和错误模型。</p>\n<ol>\n<li>环境模型：是对程序运行环境的抽象。程序运行环境又包括支持其运行的硬件、固件和软件，如计算机、终端设备、网卡、操作系统、编译系统、实用程序等。在软件测试过程中，建立环境模型的主要目的是，确定所发现的错误是否为环境造成的。</li>\n<li>被测对象模型：该模型是从测试的角度对程序的抽象。为了测试，必须简化程序，形成被测程序的抽象版本、即对象模型。</li>\n<li>错误模型：该模型是对程序中的错误及其分类的抽象。在软件测试中，往往需要定义“什么是错误”、“什么是一般性错误”、“什么是严重性错误”等，即要给出“错误模型”。</li>\n</ol>\n<h3 id=\"软件测试技术\"><a href=\"#软件测试技术\" class=\"headerlink\" title=\"软件测试技术\"></a>软件测试技术</h3><ol>\n<li><p>测试覆盖及其他们之间的基本关系<br>软件测试技术大体上可分为两大类：一类是白盒测试技术，又称为结构测试技术，典型的是路径测试技术；另一种是黑盒测试技术，又称为功能测试技术，包括事务处理流程技术、状态测试技术、定义域测试技术等。白盒测试技术依据的是程序的逻辑结构，而黑盒测试技术依据的是软件行为的描述。</p>\n</li>\n<li><p>路径测试技术的分类</p>\n<p> 测试覆盖包括路径覆盖、分支覆盖、条件覆盖与条件组合覆盖。</p>\n<ol>\n<li>路径覆盖：执行所以有可能穿过程序控制流程的路径。在路径测试中，该度量是最强的，一般是不可实现的。</li>\n<li>语句覆盖：至少执行程序中所有语句一次</li>\n<li>分支覆盖：至少将程序中的每一个分支执行一次</li>\n<li>条件覆盖与条件组合覆盖：条件覆盖是指每个判定中所有的可能的条件的取值至少执行一次；条件组合覆盖是指设计足够的测试用例，使每个判定中所有可能的条件取值组合至少执行一次。</li>\n</ol>\n<p> 这四种测试覆盖的测试覆盖率由弱到强的顺序是：语句覆盖 &lt; 分支覆盖 &lt; 条件组合覆盖 &lt; 路径覆盖</p>\n</li>\n<li><p>事务流测试步骤</p>\n<p> 事务流测试步骤具体如下。<br> 第一步：获得事务流程图。<br> 第二步：浏览、复审。<br> 第三步：用例设计。<br> 第四步：测试执行。</p>\n</li>\n<li><p>运用等价类划分技术进行测试的步骤</p>\n<p> 具体测试步骤如下。<br> 第一步：建立等价类表<br> 第二步：为有效等价类设计测试用例<br> 第三步：为无效等价类至少设计一个测试用例</p>\n</li>\n<li><p>边界值分析的使用原则</p>\n<p> 边界值分析是一种常用的黑盒测试技术。使用边界值分析在设计测试用例时，可以遵循以下原则。</p>\n<ol>\n<li>如果某个输入条件规定了输入值的范围，则应该选择正好等于边界值的数据，以及刚刚超过边界值的数据作为测试数据。</li>\n<li>如果某个输入条件规定了值的个数，则可用最大个数、最小个数、比最大个数多1、比最小个数少1的数据作为测试数据</li>\n<li>根据规格说明的每个输出条件，使用前面的原则1</li>\n<li>根据规格说明的每个输出条件，使用前面的原则2</li>\n<li>如果程序的规格说明中，输入域或输出域是有序集合，在实践中则经常选取集合的第一个元素、最后一个元素以及典型元素作为测试用例。</li>\n<li>如果程序中使用了内部数据结构，则应该选择这个内部数据结构的边界上的值作为测试用例。</li>\n<li>分析规格说明，找出其他可能的边界条件。</li>\n</ol>\n</li>\n<li><p>使用因果图生成测试用例的步骤</p>\n<p> 因果图技术是通过为判定表的每一列设计一个测试用例，从而实现测试用例的设计与选择的。该方法生成测试用例的基本步骤如下。</p>\n<ol>\n<li>通过软件规格说明书的分析，找出一个模块的原因和结果，并给每个原因和结果赋予一个标识符</li>\n<li>分析原因与结果之间以及原因之间对应的关系，并画出因果图。</li>\n<li>在因果图上标识出一些特定的约束或限制条件。</li>\n<li>把因果图转换成判定表。</li>\n<li>把判定表的每一列拿出来作为依据，设计测试用例。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"软件测试步骤\"><a href=\"#软件测试步骤\" class=\"headerlink\" title=\"软件测试步骤\"></a>软件测试步骤</h3><ol>\n<li><p>单元测试<br> 单元测试主要检验软件设计的最小单元—模块。该测试以详细设计文档为指导，测试模块内的重要控制路径。一般来说，单元测试往往采用白盒测试技术。</p>\n</li>\n<li><p>集成测试<br> 集成测试是软件组装的一个系统化技术，其目标是发现与接口有关的错误，将经过单元测的模块构成一个满足设计要求的软件结构。集成测试集中于模块组合的功能和软件结构检验。集成测试可“自顶向下”地进行，称为自顶向下的集成测试；也可以“自底向上”地进行测试，称为自底向上的集成测试</p>\n</li>\n<li><p>有效性测试<br> 有效性测试的目标是发现软件实现的功能与需求规格说明书不一致的错误。因此有效性测试通常采用黑盒测试技术。</p>\n</li>\n<li><p>系统测试<br> 系统测试验证将软件融于更大系统中时整个系统的有效性。</p>\n</li>\n</ol>\n<h2 id=\"软件生存周期过程与管理\"><a href=\"#软件生存周期过程与管理\" class=\"headerlink\" title=\"软件生存周期过程与管理\"></a>软件生存周期过程与管理</h2><h3 id=\"软件生存周期过程概述\"><a href=\"#软件生存周期过程概述\" class=\"headerlink\" title=\"软件生存周期过程概述\"></a>软件生存周期过程概述</h3><ol>\n<li><p>过程分类</p>\n<p> 按过程主体把软件生存周期过程分为以下几个过程。</p>\n<ol>\n<li>基本过程：是指那些与软件生产直接相关的活动集。该过程又可分为获取过程、供应过程、开发过程、运行过程和维护过程。</li>\n<li>支持过程：是指有关各方按他们的目标所从事的一系列相关支持活动集。该过程又可分为文档过程、配置管理过程、质量保证过程、验证过程、确认过程、联合评审过程、审计过程和问题解决过程。</li>\n<li>组织过程：是指那些与软件生产组织有关的活动集。该过程又可分为设计过程、基础设施过程、培训过程和改进过程。</li>\n</ol>\n</li>\n<li><p>系统语境的过程类<br> 系统语境的过程类包含四个过程组，分别是协议过程组、项目过程组、技术过程组和组织上项目使能过程组。</p>\n<ol>\n<li>协议过程组包含两个过程：获取过程和供应过程。</li>\n<li>项目过程组包含七个过程：项目规划过程、项目评价过程、决策管理过程、风险管理过程、配置管理过程、信息管理过程和测量过程。</li>\n<li>技术过程组包含11个过程：利益攸关方需求定义过程、系统需求分析过程、系统体系结构设计过程、实现过程、系统集成过程、系统测试过程、软件安装过程、软件接受支持过程、软件运行过程、软件维护过程和软件销毁过程。</li>\n<li>组织上使能过程组包含五个过程：生存周期模型管理过程、基础设施管理过程、项目包管理过程、人力资源管理过程和质量管理过程。</li>\n</ol>\n</li>\n<li><p>组织上使能过程的作用。<br> 组织上使能的过程一般来说是组织层面上的工作，为项目的执行提供基本保障。该过程包含五个子过程。</p>\n<ol>\n<li>生存周期模型管理过程：其任务为过程建立、过程评估、过程改进。</li>\n<li>基础设施管理过程：其任务为过程实现、基础设施的建立、基础设施的维护。</li>\n<li>项目包管理过程：项目初始化、项目包评估、项目结束处理。</li>\n<li>人力资源管理过程：其任务为技能标识、技能开发、技能获取和供给、知识管理。</li>\n<li>质量管理过程：其任务为质量管理、质量管理纠正措施。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"过程描述\"><a href=\"#过程描述\" class=\"headerlink\" title=\"过程描述\"></a>过程描述</h3><p>软件验证过程包括两个活动：过程实现和验证。其中验证活动有五个任务：需求验证、设计验证、代码验证，集成验证和文档验证。</p>\n<p>一个过程可通过过程意图，期望的结果以及到达过程结果需要执行的活动和任务来描述。对于一个过程的完整技术上的描述，还应包括：达到过程意图和实现过程结果的方法或规程，以及过程和活动文档。</p>\n<h3 id=\"应用说明\"><a href=\"#应用说明\" class=\"headerlink\" title=\"应用说明\"></a>应用说明</h3><ol>\n<li><p>系统和软件的关系</p>\n<p> 在《ISO/IEC系统与软件工程-软件生产周期过程12207-2008》标准中，把软件认为是整个系统的一个组成从部分，执行系统中所确定的功能主要包括三大功能：控制功能、耦合功能以及软件本身提供的功能。由于软件通常存在与一个系统的上下文中，因此软件产品或服务一般可被认为是系统的一个项或称为系统元素。</p>\n</li>\n<li><p>剪裁过程及应用</p>\n<p> 剪裁过程是使剪裁这一标准过程慢速以下特定情况或因素。</p>\n<ol>\n<li>围绕一个组织，其中该组织在一个协议中使用了这一标准</li>\n<li>影响一个项目，其中要求该项目满足一个引用该标准的协议</li>\n<li>反映一个组织的需要，其中该组织要供给产品或服务</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"软件生存周期模型\"><a href=\"#软件生存周期模型\" class=\"headerlink\" title=\"软件生存周期模型\"></a>软件生存周期模型</h3><ol>\n<li><p>瀑布模型</p>\n<p> 瀑布模型是将软件生存周期各个活动规定为按固定顺序链接的若干阶段的模型。这一模型规定了个开发阶段的活动：系统需求、软件需求、需求分析、设计、编码、测试和运行，并且自上而下具有相互衔接的固定顺序；还规定了每一个阶段的输入，即工作对象以及本阶段的工作成果，作为输出传送到下一阶段。</p>\n<p> 瀑布模型的提出，对软件工程的主要贡献如下。</p>\n<ol>\n<li>在决定系统怎样做之前存在一个需求阶段，它鼓励对系统做什么进行规约。</li>\n<li>在系统构造之前存在一个需求阶段，它鼓励规划系统结构。</li>\n<li>在每一阶段结束时进行评审，从而允许获取方和用户的参与。</li>\n<li>前一步可以作为下一步被认可的、文档化的基线，并允许基线和配置早期接受控制。</li>\n</ol>\n<p> 瀑布模型的主要问题是：</p>\n<ol>\n<li>要求客户能完整、正确和清晰地表达他们的需求；并要求开发人员一开始就要理解这一应用。</li>\n<li>由于需求的不稳定性，使设计、编码和测试阶段都可能发生延期；并且当项目接近结束时，出现了大量的集成和测试工作。</li>\n<li>在开始的阶段中，很难评估真正的进度状态；并且直到项目结束之前都不能演示系统的能力。</li>\n<li>在一个项目的早期开发阶段，过分地强调了基线和里程碑处的文档；并可能需要花费更多的时间用于建立一些用处不大的文档。</li>\n</ol>\n</li>\n<li><p>增量模型</p>\n<p> 增量模型是一种非整体开发的模型。软件在该模型中逐渐开发出来，开发出一部分，向用户展示一部分，可让用户及早看到部分软件，及早发现问题。该模型具有较大的灵活性，适合软件需求不明确、设计方案有一定风险的软件项目。</p>\n</li>\n<li><p>演化模型</p>\n<p> 该模型主要针对事先不能完整定义需求的软件开发在用户提出待开发系统的核心需求的基础上，软件开发人员按照这一要求，首先开发一个核心系统并投入运行，以便用户能够有效地提出反馈，即精化系统、增强系统能力的需求；接着，软件开发人员根据用户反馈，实施开发的迭代过程；每一迭代过程均由需求、设计、编码、测试、集成等阶段组成，为整个系统增加一个可定义的，可管理的子集；如果在一次迭代中，有的需求不能满足用户的要求，可在下一次迭代中予以修正。</p>\n<p> 主要特征：该模型显式地把需求获取扩展到需求阶段，既为了第二个构造增量，使用了第一个构造增量来精化需求。演化模型在一定程度上可以减少软件开发活动的盲目性。<br>不足之处：在演化模型的使用中，即使很好地理解了需求或设计，也很容易弱化需求分析阶段的工作。</p>\n</li>\n<li><p>螺旋模型</p>\n<p> 螺旋模型将瀑布模型与增量模型结合起来，加入了两种模型均忽略了的风险分析，弥补了这两种模型的不足。因而它是一种风险驱动的模型。螺旋模型将开放过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合。</p>\n<p> 螺旋模型关注解决问题的基本步骤，即标识问题，标识一些可选方案，选择一个最佳方案，遵循动作步骤并实施后续工作。其一个突出特征是，在开发的迭代中实际上只有一个迭代过程真正开发了可交付的软件。螺旋模型与演化模型和增量模型相比，同样适用了瀑布模型作为一个嵌入的过程，但螺旋模型所关注的阶段以及它们的活动是不同的。如果项目的开发风险很大或客户不能确定系统需求，在更广泛的意义上来讲，还包括一个系统或系统类型的要求，这时螺旋模型就是一个很好的生存周期模型。</p>\n</li>\n<li><p>喷泉模型</p>\n<p> 喷泉模型体现了软件创建所固有的迭代和无间隙的特征。该模型主要用于支持面向对象技术的软件开发。由于对象概念的引入，使分析、设计、实现之间的表达没有明显间隙。</p>\n</li>\n</ol>\n<h3 id=\"过程规划与管理\"><a href=\"#过程规划与管理\" class=\"headerlink\" title=\"过程规划与管理\"></a>过程规划与管理</h3><ol>\n<li><p>创建一个软件项目生存周期过程的步骤</p>\n<ol>\n<li>选择软件生存周期模型</li>\n<li>细化所选择的生存周期模型</li>\n<li>为每一个活动或任务标识合适的实例数目</li>\n<li>确定活动的时序关系，并检查信息流</li>\n<li>建立过程计划的文档</li>\n</ol>\n</li>\n<li><p>软件评估中应考虑的影响因素</p>\n<ol>\n<li>不管做怎么样的决策，都必须对所采取的的措施对生存周期过程所产生的影响进行评审，以便保证项目获得好的结果。在这一评估中，应考虑以下几方面的影响。<ol>\n<li>所要求的的“返工”</li>\n<li>资源需求</li>\n<li>实施时间</li>\n<li>对项目和用户的益处</li>\n<li>员工情绪</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"集成化能力成熟度模型（CMMI）\"><a href=\"#集成化能力成熟度模型（CMMI）\" class=\"headerlink\" title=\"集成化能力成熟度模型（CMMI）\"></a>集成化能力成熟度模型（CMMI）</h2><h3 id=\"背景和原理\"><a href=\"#背景和原理\" class=\"headerlink\" title=\"背景和原理\"></a>背景和原理</h3><ol>\n<li><p>过程改善</p>\n<p> 历史过程改善，是指人为设计的一个活动程序，其目的是改进组织的过程性能和成熟度，并改进这一程序的结果</p>\n</li>\n<li><p>过程域、专用目标和共用目标</p>\n<p> 过程域是一个业务域中一束相关的实践，当它们一起得以实现时，就满足被认为对该过程域的改善具有重要作用的一组条件<br> 专用目标是用于描述满足该过程域必须呈现的一些独有特征。经可以用于帮助确定一个过程域是否得以满足。<br> 共用目标用于描述产现制度化的该过程必须呈现的特征，仅用于确定一个过程域是否得以满足。</p>\n</li>\n</ol>\n<h3 id=\"CMMI的模型部件\"><a href=\"#CMMI的模型部件\" class=\"headerlink\" title=\"CMMI的模型部件\"></a>CMMI的模型部件</h3><table>\n<thead>\n<tr>\n<th align=\"center\">过程域类名</th>\n<th align=\"left\">包括的过程域</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">项目管理类</td>\n<td align=\"left\">项目规划<br/>项目监控<br/>定量项目管理<br/>集成项目管理<br/>风险管理<br/>提供方协议管理</td>\n</tr>\n<tr>\n<td align=\"center\">工程类</td>\n<td align=\"left\">需求开发<br/>需求管理<br/>技术解决方案<br/>产品集成<br/>确认<br/>验证</td>\n</tr>\n<tr>\n<td align=\"center\">支持类</td>\n<td align=\"left\">配置管理<br/>过程和产品质量保证<br/>测量与分析<br/>原因分析与解决<br/>决策分析与解决</td>\n</tr>\n<tr>\n<td align=\"center\">过程管理类</td>\n<td align=\"left\">组织过程定义<br/>组织过程性能<br/>组织过程培训<br/>组织过程关注<br/>组织创新与部署</td>\n</tr>\n</tbody></table>\n<h3 id=\"CMMI的等级\"><a href=\"#CMMI的等级\" class=\"headerlink\" title=\"CMMI的等级\"></a>CMMI的等级</h3><ol>\n<li><p>能力等级的组成</p>\n<p> 能力等级是用来表征组织对一个过程域的改善，是不断改善一个给定过程域的一种手段。在CMMI中，针对每个过程域设定了6个能力等级，即0级：未完成级；1级：已执行级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：待续优化级。</p>\n</li>\n<li><p>成熟度等级的组成</p>\n<p> 在CMMI中，应用于一个组织过程改善的成熟度等级有5个。即1级：初始级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：持续优化级</p>\n</li>\n<li><p>能力等级与成熟度等级之间的基本关系</p>\n<ol>\n<li>能力等级与成熟度等级是互补的关系，两者都是一种过程改善路径，即表征组织对单一过程域的改进。</li>\n<li>成熟度等级的路径可使组织针对单一过程域不断改善一组相关过程域，即表征组织对一组过程域的改进。</li>\n<li>两种等级的2-5级使用了同样的名字</li>\n</ol>\n</li>\n<li><p>达到各共用目标要实施的共同实践</p>\n<p> 达到公用目标2、共用目标3、共用目标4和共用目标5所要实施的共同实践如下表所示</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">所要实施的共用实践</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">共用目标2：把过程制度化为一个管理过程</td>\n<td align=\"center\">GP2.1 建立组织策略<br/>GP2.2 规划过程<br/>GP2.3 提供资源<br/>GP2.4 指派责任<br/>GP2.5 培训人员<br/>GP2.6 管理配置<br/>GP2.7 标识相关利益方的参与<br/>GP2.8 监控过程<br/>GP2.9 客观地评估符合性<br/>GP2.10 从高层管理的视觉评审状态<br/></td>\n</tr>\n<tr>\n<td align=\"center\">共用目标3：把过程制度化为一个已定义过程</td>\n<td align=\"center\">GP3.1 建立一个已定义的过程<br/>GP3.2 收信进信息 所要实施的共用实践</td>\n</tr>\n<tr>\n<td align=\"center\">共用目标4：把过程制度化为一个已定量管理过程</td>\n<td align=\"center\">GP4.1 为该过程建立定量目的<br/>GP4.2 使子过程性能达到稳定</td>\n</tr>\n<tr>\n<td align=\"center\">共用目标5：把过程制度化为一个持续优化过程</td>\n<td align=\"center\">GP5.1 确保不断进行过程改善<br/>GP5.2 收集问题的根本原因</td>\n</tr>\n</tbody></table>\n<p>完结</p>\n","site":{"data":{}},"excerpt":"<p>如何管理一个项目，这是个沉重的话题。实际上，目前很多人都是凭借经验进行项目管理和开发，事实上管理项目是有着大量的方法论，这些方法论整理起来被人归纳成了一个学科，名字叫做<code>软件工程</code>，接下来的内容将会归纳总结里面的一些要点，如果你有意成为一个项目管理者，请必须了解一下这些基础知识。</p>","more":"<h2 id=\"软件系统模型\"><a href=\"#软件系统模型\" class=\"headerlink\" title=\"软件系统模型\"></a>软件系统模型</h2><p>开始一个项目之前，你需要做好准备，那就是建立系统模型，有了抽象的模型，才会有具像的实现。</p>\n<ul>\n<li>在软件开发中，软件系统模型大体可分为两类：<code>概念模型</code>和<code>软件模型</code>。</li>\n<li>概念模型是创建在需求层上的，它描述了系统是什么。</li>\n<li>软件模型是建立在抽象层上的，它描述了实现概念模型的软件解决方案。</li>\n<li>软件模型可进一步分为<code>设计模型</code>、<code>实现模型</code>和<code>部署模型</code>。</li>\n</ul>\n<h2 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h2><h3 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h3><p> 一个完整的需求需要有以下特征：</p>\n<ol>\n<li>必要的：该需求是用户所要求的（产品经常会提一些伪需求，比如说在帖子列表添加个一键评价，点击了就回复666，但实际上没有用户想毫无感情地666，所以这是伪需求，不满足该条件的请拒绝）；</li>\n<li>无歧义的：该需求只能用一种方式解释（这个就不用解释了，遇到有歧义的需求请问清楚）；</li>\n<li>可测的：该需求可以进行测试；</li>\n<li>可跟踪的：该需求可以从一个开发阶段跟踪到另一个开发阶段（意思就是这个需求不会因为开发的进行变得模糊、不清晰）；</li>\n<li>可测量的：该需求是可测量的（意思就是实现这个需求不能无限耗费人力物力，说好这个需求两个人一天能做完，就两个人一天真的能做完）。</li>\n</ol>\n<h3 id=\"类别\"><a href=\"#类别\" class=\"headerlink\" title=\"类别\"></a>类别</h3><ol>\n<li>功能需求：系统或系统构件必须执行的功能</li>\n<li>非功能需求：分为性能需求、外部接口需求、设计约束需求、质量属性需求。</li>\n</ol>\n<h3 id=\"怎么发现需求\"><a href=\"#怎么发现需求\" class=\"headerlink\" title=\"怎么发现需求\"></a>怎么发现需求</h3><table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">情况</th>\n<th align=\"center\">成功条件</th>\n<th align=\"center\">风险</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">自悟</td>\n<td align=\"center\">自己想</td>\n<td align=\"center\">要比你的最终客户拥有更多的一样弄领域和过程方面的知识和丰富的想象力，也就是你要比你的用户更加清楚用户要啥</td>\n<td align=\"center\">无法验证你想出来的东西是不是你的用户想要的</td>\n</tr>\n<tr>\n<td align=\"center\">交谈</td>\n<td align=\"center\">跟你的客户聊</td>\n<td align=\"center\">你能提出正确的问题，回答人能揭示需求本质的能力</td>\n<td align=\"center\">可能会获得一堆需求，而且越来越多，不断增长，可能还会推翻你之前的需求，可能导致超出项目成本和进度的限制<s>（甚至可能被你的开发揍一顿）</s></td>\n</tr>\n<tr>\n<td align=\"center\">观察</td>\n<td align=\"center\">你去看你的用户怎么用你的软件</td>\n<td align=\"center\">你需要有洞察事物本质的能力</td>\n<td align=\"center\">1. 你的用户会抵触你的观察（很明显侵犯隐私了）2. 用户会觉得你是不是这软件没做好或者哪里需求不到位所以老是来看我，对你的软件产生怀疑</td>\n</tr>\n<tr>\n<td align=\"center\">小组会</td>\n<td align=\"center\">项目组的人全部叫出来开会讨论需求</td>\n<td align=\"center\">你小组的人有不同观点，并且有良好的发现需求的能力，能揭示需求中存在的问题，最重要的是需求能跟用户达成共识</td>\n<td align=\"center\">会议组织不到位就凉了，而且天天开会你的项目组的人也受不了，可能会提出矛盾需求</td>\n</tr>\n<tr>\n<td align=\"center\">提炼</td>\n<td align=\"center\">针对已有的部分需求文档，看线上反馈情况，进行提炼</td>\n<td align=\"center\">你需要有想象力和需求标识能力，包括熟悉相关的技术标准</td>\n<td align=\"center\">跟自悟一样，你不能知道你发现的需求是否是对的</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"需求规约\"><a href=\"#需求规约\" class=\"headerlink\" title=\"需求规约\"></a>需求规约</h3><p>需求规约就是怎么写一个需求表，因为形式很多，所以最好就根据实际情况进行，这里不做规定，但是必须包含以下几个特征</p>\n<ol>\n<li>重要性和稳定性：需求要根据重要程度和稳定程度分优先级，例如：基本需求、可选需求和期望需求。</li>\n<li>可修改的：在不过多地影响其他需求的情况下，可以容易地修改一个单一需求。</li>\n<li>完整的：没有被遗漏的需求。</li>\n<li>一致的：不存在互斥的需求。</li>\n</ol>\n<p>为什么需求规约很重要？（概念性东西）</p>\n<ol>\n<li>是软件开发组织和用户之间一份事实上的技术合同书，是产品功能及其环境的体现。</li>\n<li>对于项目的其余大多数工作，需求规约是一个管理控制点。</li>\n<li>对于产品/系统的设计，需求规约是一个正式的、受控的起点。</li>\n</ol>\n<h2 id=\"结构化方法\"><a href=\"#结构化方法\" class=\"headerlink\" title=\"结构化方法\"></a>结构化方法</h2><h3 id=\"结构化需求分析\"><a href=\"#结构化需求分析\" class=\"headerlink\" title=\"结构化需求分析\"></a>结构化需求分析</h3><ol>\n<li><p>为什么要这么做？</p>\n<p> 为了应对三大挑战：</p>\n<pre><code> - 问题空间理解。（假如让你开发一个八字排盘App，但是你又不懂八字，所以要开发出一个高质量、满足用户要求的App，就不容易了）\n - 人与人之间的通信。（开发过程长、活动多、任务重，项目组成员多，直接面对面沟通起来难免有遗漏、误解等，所以这也是一个挑战）\n - 需求的变化性。（需求是不断变化的，所以这是软件开发人员面临的挑战）\n</code></pre>\n<p> 一种好的需求技术应该具有以下基本特征：</p>\n<pre><code> 1. 提供方便通信的机子，例如，在不同开发阶段，使用对相关人员易于理解的语言。\n 2. 鼓励需求分析人员使用问题空间的术语思考问题，编写文档。\n 3. 提供定义系统边界的方法。\n 4. 提供支持抽象的基本机制，例如，&quot;划分&quot;，&quot;功能抽象&quot;，&quot;结构抽象&quot;等。\n 5. 为需求分析人员提供多种可供选择的方案。\n 6. 提供特定的技术，适应需求的变化等。\n</code></pre>\n</li>\n<li><p>几种基本术语的解释</p>\n<p> (1) 数据流：数据流是数据的流动，用于表达在分析中所要使用的、用于表达”客体”的信息，用箭头表示。<br> 大概长这样：</p>\n <img width=50px src='https://i.loli.net/2019/10/21/wM2SkZXGDY46lQh.png'>\n (2) 加工：加工是数据变换的单元，即它接受输入的数据，对其进行处理，并产生输出。\n 大概长这样\n <img width=50px src='https://i.loli.net/2019/10/21/mcfwVCaJI1Sn8kZ.png'>\n (3) 数据存储：数据存储是数据的静态结构。\n 大概长这样(可以是横的或者竖的)\n <img width=50px src='https://i.loli.net/2019/10/21/xbXKc45RlYpnNB9.png'>\n (4) 数据源和数据潭: 数据源是数据流的起点，数据潭是数据流的归宿地。数据源和数据潭是系统之外的实体，可以是人、物或其他软件系统。\n 大概长这样\n <img width=50px src='https://i.loli.net/2019/10/21/LiwWbnSAs7Pqzoh.png'></li>\n<li><p>数据流图</p>\n<p> 把上面的元素组成起来就是数据流图了<br> 大概长这样</p>\n <img width=70% src=\"https://i.loli.net/2019/10/21/wDdaFiLe9Ps6UzA.png\">\n\n<p> 几个要点：1）数据流起到连接其他实体的作用，实体可以是加工、数据存储、数据源和数据潭；2）加工之间可以有多个数据流，这些数据流之间可以没有任何关系，数据流图也不表明他们的先后次序；3）对于一个比较大的软件系统，往往需要采用多层次的数据流图。</p>\n</li>\n<li><p>建模过程</p>\n<ol>\n<li>建立系统环境图，确立系统语境</li>\n<li>自顶向下，逐步求精，建立系统的层次数据流图</li>\n<li>定义数据字典。数据字典有3种基本结构表示：顺序结构，选择结构，重复结构。<ul>\n<li>顺序结构是指数据A由数据B和数据C顺序构成的，并记为”+”。例如：学生成绩=姓名+性别+学号+科目+成绩，其中”=”号表达的是”定义为”.</li>\n<li>选择结构是指由数据A是由数据B或数据C定义的，即数据B不可能同时是B和C，并记为“|”，例如：性别=男|女</li>\n<li>重复结构是指数据A是由多个重复出现的数据B构成的，并记为”| |”，例如：学生成绩表=|学生成绩|<img width=\"50%\" src=\"https://i.loli.net/2019/10/21/43hSWgZPmVirHfA.png\"></li>\n</ul>\n</li>\n<li>描述加工：该步的目标为依据系统的数据流图，给出其中每一加工的小说明。加工可以有3种表达工具。<ol>\n<li>结构化自然语言（自然语言描述）</li>\n<li>判定表: 由条件类别，条件组合，操作，操作执行构成。举例如图<img width=50% src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D22%2C0%2C590%2C389%3Bc0%3Dbaike80%2C5%2C5%2C80%2C26/sign=d64b6fc508087bf469a30da9cfe16500/42166d224f4a20a48dfd6c499a529822730ed059.jpg\"></li>\n<li>判定树。举例如图<img width=60%  src=\"https://i.loli.net/2019/10/21/COmGSet5I61lFsH.png\"></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>注意事项：</p>\n<ol>\n<li>模型平衡问题</li>\n<li>信息复杂性控制问题</li>\n</ol>\n</li>\n<li><p>需求验证<br> 验证需求规格说明书中的每一单一需求是否满足5个性质，即必要性、无歧义性、可测性、可跟踪性、可测量性；验证需求规格说明是否满足4个性质，即重要性和稳定程度、可修改性、完整性和一致性。在必要时还需要验证其他特性，如设计无关性。</p>\n</li>\n</ol>\n<h3 id=\"结构化设计\"><a href=\"#结构化设计\" class=\"headerlink\" title=\"结构化设计\"></a>结构化设计</h3><h4 id=\"总体设计步骤\"><a href=\"#总体设计步骤\" class=\"headerlink\" title=\"总体设计步骤\"></a>总体设计步骤</h4><p>结构化设计方法基于<code>自顶向下，功能分解</code>的基本原则，针对两种不同类型的数据流图，分别提出了变换设计和事务设计。其中，变换设计的目标是将变换型数据流图映射为模块结构图，而事务设计的目标是将事务型数据流图映射为模块结构图。</p>\n<ol>\n<li><p>变换型数据流图和事务性和数据流图<br>（1）变换型数据流图：具有比较明显的输入部分和变换部分之间的界面、变换部分和输出部分之间界面的数据流图，称为变换型数据流图；<br><img src=\"https://www.sytm.net/ueditor/net/upload/2013-12-31/bdae1434-8b79-4209-b818-2502c7ea3bee.png\"><br>（2）事务型数据流图：数据到达一个加工T，该加工T根据输入的值，在其后若干动作序列中选出一个来执行，这类数据流图成为事务型数据流图。<br><img src=\"https://www.sytm.net/ueditor/net/upload/2013-12-31/142b2c91-a9ad-4c6e-b075-ecd6a900ee63.png\"></p>\n</li>\n<li><p>总体设计分为3个阶段。第一阶段为初始设计，在对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。第二阶段为精化设计，依据模块“高内聚低耦合”的原则精化初始的模块结构图，并设计其中的全局数据结构和每一模块的接口。第三阶段为复审阶段，对前两个阶段所得到的高层软件结构进行复审，必要时还可能需要对该软件结构做一些精化工作，这对软件的一些性质，特别是对软件质量的提高，将产生非常大的影响。</p>\n</li>\n<li><p>天天扯着嗓子喊高内聚低耦合，到底什么是内聚什么是耦合？</p>\n<ul>\n<li>耦合：耦合是指不同模块之间相互依赖程度的度量<ul>\n<li>内容耦合：当一个模块直接修改或操作另一个模块的数据，\u001d或当一个模块直接修改或操作，另一个模块的数据或一个模块不通过正常入口转入到一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该尽量避免使用。</li>\n<li>公共耦合：两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。</li>\n<li>控制耦合：一个模块通过接口向另一个模块传递一个控制信号，接收信号的模块根据信号值进行适当的动作，这种耦合被成为控制耦合。</li>\n<li>标记耦合：若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。</li>\n<li>数据耦合：模块之间通过参数来传递数据，则称为数据耦合。数据耦合是最低的一种耦合形式。</li>\n</ul>\n</li>\n<li>内聚：内聚是指一个模块内部各成分之间相互关联程度的度量<ul>\n<li>偶然内聚：如果一个模块的各成分之间基本不存在任何关系，则称为偶然内聚</li>\n<li>逻辑内聚：几个逻辑上相关的功能被放在同一模块中，则称为逻辑内聚。</li>\n<li>时间内聚：如果一个模块完成的功能必须在同一时间内执行（例如，初始化系统或一组变量），但这些功能只是因为时间因素关联在一起，则称为时间内聚。</li>\n<li>过程内聚：如果一个模块内部的处理成分是相关的，而且这些处理必须以特定的次序执行，则称为过程内聚。</li>\n<li>通信内聚：如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚</li>\n<li>顺序内聚：如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚</li>\n<li>功能内聚：最理想的内聚是功能内聚，模块所有的成分对于完成单一的功能都是基本的。功能内聚的模块对完成其功能而言是充分必要的。</li>\n</ul>\n</li>\n<li>启发式规则：无论是变换设计还是事务设计，都涉一个共同的问题，即“基于高内聚低耦合的原理，采用一些经验性的启发式规则，对初始的模块结构图进行精化，形成最终的模块结构图”。</li>\n<li>怎么做？<ol>\n<li>改进软件结构，提高模块独立性。</li>\n<li>力求模块规模适中。</li>\n<li>力求深度、宽度、扇出和扇入适中。深度：表示其控制的<code>层数</code>(不包括自身)；宽度：同一层次上模块总数的<code>最大值</code>；扇出：一个模块<code>直接</code>控制（调用）的下级模块数目；扇入：一个模块有多少个上级模块<code>直接</code>调用它。</li>\n<li>尽力使模块的作用域在其控制域之内。作用域：受该模块内<code>一个判定</code>所影响的所有模块的集合；控制域：模块本身以及所有<code>直接或间接</code>从属于它的模块的集合。</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"详细设计步骤\"><a href=\"#详细设计步骤\" class=\"headerlink\" title=\"详细设计步骤\"></a>详细设计步骤</h4><ol>\n<li>结构化程序设计<br> 包含三种基本控制结构：顺序结构、选择结构、循环结构</li>\n<li>详细设计工具<ol>\n<li>程序流程图 <img width=20% src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945069712&di=74b11092aae0042569e80dc22ee83438&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F09%2F17%2F02%2F27798515%2F15.files%2Ffile0001.jpg\">\n 缺点：不是一种逐步求精的工具，过早地考虑程序的流程，不去考虑程序的全局结构；所表达的控制流，往往不受任何约束可随意转移，从而会影响甚至破坏好的系统结构设计；不易表示数据结构。</li>\n<li>盒图（N-S图） <img width=40% src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945228461&di=10908d6d12f9c8984356e884b3c0aeb5&imgtype=0&src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fzhidao%2Fwh%253D450%252C600%2Fsign%3Da401ed95523d26972e86005960cb9ecd%2Fd833c895d143ad4bd5fe969f81025aafa50f0698.jpg\"></li>\n<li>PAD图（Problem Analysis Diagram） <img width=\"40%\" src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945326054&di=d66d2f92c755db3f26640c2bbb6bc338&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F12%2F15%2F14%2F51872755%2F6.files%2Ffile0001.jpeg\"></li>\n</ol>\n N-S图和PAD图支持“自顶向下逐步求精”的设计。可节省人工编码工作，有利于提高软件的可靠性和软件生产率<ol start=\"4\">\n<li>类程序设计语言（伪码/PDL）<br> 是一种用正文形式表示数据结构和处理过程的设计工具，PDL是一种“混合”的语言。</li>\n</ol>\n</li>\n<li>设计规约<br> 完成软件设计后，应产生设计规约，完整准确地描述满足系统需求规约所要求的的所有功能模块，以及伴随功能模块而出现的非功能机制。设计规约通常包括<code>概要设计规约</code>和<code>详细设计规约</code>。 <code>概要设计规约</code>指明高层软件体系结构，其主要功能如下： 1.系统环境等与设计有关的限定条件 2. 软件模块的结构（模块之间的接口及设计的数据流和主要数据结构）3. 模块描述（接口定义，模块处理逻辑，必要的注释等）4. 文件结构和全局数据文件的逻辑结构 5.测试需求 <code>详细设计规约</code>（包括各处理过程的算法和算法所涉及的全部数据结构的描述）主要作为软件设计人员与程序员之间交流的媒体。</li>\n</ol>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><h3 id=\"UML是一种图形化建模语言（Unified-Modeling-Language）\"><a href=\"#UML是一种图形化建模语言（Unified-Modeling-Language）\" class=\"headerlink\" title=\"UML是一种图形化建模语言（Unified Modeling Language）\"></a>UML是一种图形化建模语言（Unified Modeling Language）</h3><p>为了支持抽象分析和设计中的事物，UML给了八个基本术语，即类、接口、协作、用况、主动类、构件、制品、节点、</p>\n<ul>\n<li>类： 类是一组拥有相同属性、操作、关系和语义的对象的描述。类主要用于抽象客观世界中的事物。</li>\n<li>接口：每个操作描述了类、构件或子系统的一个服务，接口就是操作的一个集合。接口是对系统/产品的“接缝”予以模型化，表明了一个类、构件、子系统所需要得到的、且与实现无关的行为。</li>\n<li>用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的、可观察的结果。</li>\n<li>协作：协作是一个交互，涉及交互的三要素：交互各方、交互方式以及交互内容</li>\n<li>用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的，可观察的结果。</li>\n<li>主动类：主动类是一种至少具有一个进程或线程的类。</li>\n<li>构件：构件是系统设计中的一种模块化部件，通过外部接口隐藏了它的内部实现。</li>\n<li>制品：制品是系统中包含物理信息（比特）的、可替代的物理部件。</li>\n<li>节点：节点是运行时存在的物理元素，通常表示一种具有记忆能力和处理能力的计算机资源。</li>\n</ul>\n<p>类在建模中的主要用途：</p>\n<ol>\n<li>模型化问题域中的概念</li>\n<li>建立系统的职责分布模型</li>\n<li>模型化建模中使用的基本类型</li>\n</ol>\n<p>使用接口应注意的问题</p>\n<ol>\n<li>接口只可以被其他类目使用，而本身不能访问其他类目</li>\n<li>接口描述类的外部可见操作，通常是该类的一个特有限定行为。这些操作可以使用可见性、并发性、衍型、标记值和约束来修饰。</li>\n<li>接口不描述其中操作的实现，也没有属性和状态。据此可见，接口在形式上等价于一个没有属性、没有方法而只有抽象操作的抽象类</li>\n<li>接口之间没有关联、泛化、实现和依赖。但可以参与泛化、实现和依赖</li>\n</ol>\n<h3 id=\"表达关系的术语\"><a href=\"#表达关系的术语\" class=\"headerlink\" title=\"表达关系的术语\"></a>表达关系的术语</h3><pre><code>关联：关联是一组具有相同结构、相同链的描述，是类目之间的一种结构关系。关联可以用一条连接两个类目的线段表示，并可对其命名，其结构可以具有方向性，用一个实心三角形来指示关联的方向。\n    1. 关联名 。\n    2. 导航：对于一个给定的类目，可以找到与之关联的另一个类目，这称为导航。\n    3. 角色：角色是关联一端的类目对另一端的类目的一种呈现。\n    4. 可见性：通过导航可以找到另一类目的实例，有时候需要限制访问。\n    5. 多重性：类中对象参与一个关联的数目，成为该关联的多重性\n    6. 限定符：限定符是一个关联的属性或属性表。\n    7. 聚合：分类是增强客观实际问题语义的一种手段。聚合是对象之间（不是类之间）的一种结构关系。\n    8. 组合：组合是聚合的一种特殊形式\n泛化：泛化是一般性类目和它的较为特殊类目之间的一种关系。子类可以继承父类的属性和操作，同时也可以替换父类的声明。\n    泛化的四种约束：完整、不完整、互斥、重叠\n细化：细化是类目之间的语义关系，其中一个类目规约保证了另一个类目执行的契约。\n依赖：依赖用于描述一个类目使用另一个类目的信息和服务，是一种使用关系。\n    依赖的分类：绑定、导出、允许、示例、实例化、幂类型、精化、使用。\n    \n关联、泛化和细化都是一类特地类型的依赖。\n\n使用这四种术语，可以模型化以下各种关系：\n1. 结构关系（静态结构和动态结构）\n    进行模型化时两种驱动方式：1.以数据驱动 2. 以行为驱动\n2. 继承关系\n3. 精化关系\n4. 依赖关系\n</code></pre>\n<h3 id=\"表达组合信息的术语————包\"><a href=\"#表达组合信息的术语————包\" class=\"headerlink\" title=\"表达组合信息的术语————包\"></a>表达组合信息的术语————包</h3><p>为了控制信息组织的复杂性，UML提供了组织信息的一种通用机制————包，支持形成一些可管理的部分。换言之，包可以作为“模块化”和“构件化”的一种机制。</p>\n<p>包是模型元素的一个分组。一个包本身可以被嵌套在其他包中，并且可以含有子包和其他种类的模型元素。</p>\n<p>通过在包的名字前加上一个可见性符号（+，-，#），来指示该包的可见性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ 表示对其他包而言都是可见的</span><br><span class=\"line\"># 表示对子孙包而言是可见的</span><br><span class=\"line\">- 表示对其他包而言都是不可见的</span><br></pre></td></tr></table></figure>\n\n<p>为了模型化包之间的关系，UML给出了两种依赖，即访问和引入。</p>\n<ul>\n<li>访问：表明目标包中的内容可以被源包所引用，或被那些递归嵌套在源包中的其他包所引用。</li>\n<li>引入：表明目标包中具有适当可见性的内容（名字）被加入到源包的公共命名空间中。</li>\n</ul>\n<p>UML中用虚线加箭头的方式表示源包到目标包的依赖（访问和引入）。</p>\n<h3 id=\"UML术语的作用\"><a href=\"#UML术语的作用\" class=\"headerlink\" title=\"UML术语的作用\"></a>UML术语的作用</h3><ol>\n<li>类用于抽象客观事物</li>\n<li>接口用于抽象事物之间的缝隙</li>\n<li>协作用于抽象协作性行为</li>\n<li>用况用于抽象功能</li>\n<li>主动类用于抽象并发行为</li>\n<li>构件用于抽象软件解中标识的成分</li>\n<li>制品用于抽象工作产品</li>\n<li>节点用于抽象计算单元</li>\n<li>关联用于抽象结构关系</li>\n<li>泛化用于抽象“一般/特殊”关系</li>\n<li>实现用于抽象精化关系</li>\n<li>依赖用于抽象使用关系</li>\n</ol>\n<h3 id=\"UML的模型表达式\"><a href=\"#UML的模型表达式\" class=\"headerlink\" title=\"UML的模型表达式\"></a>UML的模型表达式</h3><ol>\n<li>结构图和行为图<br> 结构图用于表达系统或系统成分的静态结构模型，给出系统或系统成分的一些说明性信息<br> 行为图用于表系统或系统成分的动态结构模型，给出系统或系统成分的一些行为信息</li>\n<li>类图、用况图、顺序图及状态图<ul>\n<li>类图是可视化地表达系统静态结构功能模型的工具，使用类图所表达的系统静态结构模型，给出的是一些关于系统的说明性信息。<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176025075&di=1875f9ac829f33a38a45131069ee3e4a&imgtype=0&src=http://images.cnblogs.com/cnblogs_com/a-i/Uml2.JPG\"></li>\n<li>用况图是一种表达系统功能模型的图形化工具，它包含六个模型元素，分别是主题、用况、参与者、关联、泛化、依赖<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176303343&di=4146dfc9badef7bc95f4c750ab149eb0&imgtype=0&src=http://yzhtml01.book118.com/2016/09/24/23/28839740/23.files/file0001.png\"></li>\n<li>顺序图由一组对象以及按时序组织的对象之间的关系组成，是一种交互图，包含对象之间传递的信息。控制操作包括<code>选择执行操作</code>、<code>条件操作</code>、<code>并发迭代操作</code>、<code>迭代执行操作</code>。<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176439921&di=d592e65ae4a1bc1c2e65a98e415a897a&imgtype=0&src=http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/png/20180615101636402475.png\"></li>\n<li>状态图强调了从一个状态到另一个状态的控制流，是显示一个状态机的图。状态图由状态、事件和状态转移构成。使用状态图的作用有两个：一是创建一个系统的动态模型，二是创建一个场景的模型<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176576658&di=70e3de58666cf1d7315cf56a05ec0d35&imgtype=0&src=http://yzhtml01.book118.com/2016/12/07/08/48638362/25.files/file0001.png\"></li>\n<li></li>\n</ul>\n</li>\n<li>创建一个系统的类图的步骤<ul>\n<li>模型化代建系统中的概念，形成类图中的基本元素</li>\n<li>模型化代建系统中的各种关系，形成该系统的初始类图</li>\n<li>模型化系统中的协作，给出该系统的最终类图</li>\n<li>模型化逻辑数据库模式</li>\n</ul>\n</li>\n<li>信号事件、调用事件、时间事件和变化事件<ul>\n<li>信号事件是一种异步事件，信号通常由状态机处理。如果没有定义对该事件的响应，那么事件均可能丢失。事件的丢失，就有可能引发接受者——状态机的一个错误的状态转移。</li>\n</ul>\n</li>\n<li>状态转移所涉及的内容<br> 描述一个状态转换，一般涉及五个部分：<ol>\n<li>源状态：发生状态转移的那个状态</li>\n<li>转移触发器：在源状态中由对象识别的事件，并且一旦满足其监护条件，则使状态发生转移。</li>\n<li>监护条件：一个布尔表达式，当某个事件触发器接受一个事件时，如果该表达式有值为真，则触发一个转移；若有值为假，则不发生状态转移。</li>\n<li>效应：一种可执行的行为</li>\n<li>目标状态：转移完成后所处的状态</li>\n</ol>\n</li>\n<li>最常用的控制操作子<br> 选择执行操作子：该操作子由两部分组成：一是监护条件，二是控制体<br> 条件执行操作子：控制体通过水平线将其分为一些部分，每一部分表示一个条件分支，每一分支有一个监护条件。<br> 并发执行操作子：该控制操作子的体通过水平线将其分为多个部分，每一部分表示一个并行计算。该控制操作子表明，当进入该控制操作子是，所有部分并发执行。<br> 迭代执行操作子：该控制操作子表明，只要在每一次迭代之前该监护条件为真，那么该控制体就反复执行，当该控制体上面的监护条件为假时，控制绕过该控制操作子。</li>\n<li>子状态机、简单状态和组合状态的概念<br> 子状态机：为了有效地组织状态、控制对象状态的复杂性，UML提供了组合状态，在一个状态机中引入了另一个状态机。被引入的状态机就称为子状态机。<br> 简单状态：子状态是被嵌套到另一状态中的状态。相对地，被引入的状态机就称为子状态机。<br> 组合状态：把含子状态的状态称为组合状态，组合状态可包含两种类型的子状态机，即非正交（顺序）子状态机和正交（并发）子状态机。<h2 id=\"RUP\"><a href=\"#RUP\" class=\"headerlink\" title=\"RUP\"></a>RUP</h2></li>\n</ol>\n<h3 id=\"RUP-Rational-Unified-Process-的特点\"><a href=\"#RUP-Rational-Unified-Process-的特点\" class=\"headerlink\" title=\"RUP(Rational Unified Process)的特点\"></a>RUP(Rational Unified Process)的特点</h3><p>RUP的突出特点是，它是一种以用况（Use Case）为驱动的、以体系结构为中心的迭代、增量式开发。</p>\n<ol>\n<li>以用况为驱动<br>以用况为驱动是指在系统的生存周期中，以用况作为基础，驱动系统有关人员对所要建立系统的功能需求进行交流，驱动系统分析、设计、实现和测试等活动。</li>\n<li>以体系结构为中心<br>以体系结构为中心是指在系统的生存周期中，开发的任何阶段都要给出相关模型视角下有关体系结构的描述，作为构思、构造、管理和改善系统的主要标准。</li>\n<li>迭代、增量式开发<br>迭代、增量式开发是指通过开发活动的迭代，不断地产生相应的增量。在RUP中，规定了四个开发阶段：初始阶段、精化阶段、构造阶段和移交阶段。</li>\n</ol>\n<h3 id=\"核心工作流\"><a href=\"#核心工作流\" class=\"headerlink\" title=\"核心工作流\"></a>核心工作流</h3><p>核心工作流：需求获取、分析、设计、实现和测试</p>\n<h4 id=\"需求获取\"><a href=\"#需求获取\" class=\"headerlink\" title=\"需求获取\"></a>需求获取</h4><table>\n<thead>\n<tr>\n<th align=\"center\">基本步骤</th>\n<th align=\"center\">产生的制品</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">列出候选的特征</td>\n<td align=\"center\">特征表</td>\n</tr>\n<tr>\n<td align=\"center\">理解系统语境</td>\n<td align=\"center\">领域模型或业务模型</td>\n</tr>\n<tr>\n<td align=\"center\">捕获功能需求</td>\n<td align=\"center\">用况模型</td>\n</tr>\n<tr>\n<td align=\"center\">捕获非功能需求</td>\n<td align=\"center\">补充需求或针对特殊需求的用况</td>\n</tr>\n</tbody></table>\n<h3 id=\"业务用况模型和业务对象模型\"><a href=\"#业务用况模型和业务对象模型\" class=\"headerlink\" title=\"业务用况模型和业务对象模型\"></a>业务用况模型和业务对象模型</h3><ol>\n<li>业务用况模型。业务用况模型是以用框图予以表达的</li>\n<li>业务对象模型。为了精化业务用况模型中的每一个业务用况，RUP引入了三个术语，用于表达参与业务的业务对象：<code>工作人员</code>、<code>业务实体</code>和<code>工作单元</code>。业务对象模型可通过交互图和活动图予以表达。</li>\n</ol>\n<h3 id=\"标识用况应注意的问题\"><a href=\"#标识用况应注意的问题\" class=\"headerlink\" title=\"标识用况应注意的问题\"></a>标识用况应注意的问题</h3><ol>\n<li>建立用况的结构中，应尽可能反映用况的实际情况。</li>\n<li>在用况的结构化中，不论是施加什么结构，新引入的用况都不应该太小或太大</li>\n<li>在建立用况的结构是，应尽量避免对用况模型中的用况功能进行分解。</li>\n</ol>\n<h4 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h4><ol>\n<li>分析类是类的一种衍型，分为边界类、实体类和控制类</li>\n<li>用况细化时一个协作，针对一个用况，其行为可用多个分析类之间的相互作用来细化，并记为用况细化。用况细化对用况模型中的一个特定的用况提供了一种直接跟踪的方式。</li>\n<li>分析包是一种控制信息组织复杂性的机制，提供了分析制品的一种组织手段。其主要特征为：体现问题的分离；高内聚、低耦合；尽可能体现一个系统的完整顶层设计，尽可能成为一些子系统或者成为一些子系统的组成部分。</li>\n</ol>\n<h4 id=\"具有良好结构的分析包的特征\"><a href=\"#具有良好结构的分析包的特征\" class=\"headerlink\" title=\"具有良好结构的分析包的特征\"></a>具有良好结构的分析包的特征</h4><ol>\n<li>体现问题分离</li>\n<li>高内聚、低耦合。</li>\n<li>尽可能提现一个系统的完整顶层设计。</li>\n</ol>\n<h4 id=\"软件设计层上的术语\"><a href=\"#软件设计层上的术语\" class=\"headerlink\" title=\"软件设计层上的术语\"></a>软件设计层上的术语</h4><p>软件设计是满足需求规约所需要的软件结构。RUP为了满足系统/产品分析模型规约需求的软件结构，为设计层提供了是个术语：设计类、用况细化、设计子系统和接口，用于表达软件结构中的基本元素。</p>\n<ol>\n<li>设计类：一个设计类是对系统中实现一个类或类似构造的一个无缝抽象</li>\n<li>用况细化：用况细化是设计模型的一个协作，其中使用设计类及其对象，描述一个特定用况是如何予以细化的，是如何执行的</li>\n<li>设计子系统：设计子系统可以包含设计类、用况细化、接口，以及其他子系统，通过对其操作来显示其功能。</li>\n<li>接口：接口用于规约由设计类和设计子系统，必须提供与该接口操作对应的实现方法。</li>\n</ol>\n<h4 id=\"创建系统-产品用况模型的活动和任务\"><a href=\"#创建系统-产品用况模型的活动和任务\" class=\"headerlink\" title=\"创建系统/产品用况模型的活动和任务\"></a>创建系统/产品用况模型的活动和任务</h4><p>创建系统/产品用况模型的活动和任务如下</p>\n<ol>\n<li>活动一：发现并描述参与者<br>任务1：发现参与者，即直接发现一些候选的参与者<br>任务2：描述参与者，即对参与者进行命名并描述</li>\n<li>活动二：发现用况并对用况进行描述<br>任务1：发现用况<br>任务2：描述用况，即确定用况后对其进行描述</li>\n<li>活动三：确定用况的优先级，目的是在寻找参与者并对其进行描述和发现用况的并对用况进行描述的基础上确定哪些用况适合在早期的迭代中开发，哪些适合在后期的迭代中开发。</li>\n<li>活动四：精化用况。这一活动的目的是详细描述出每一用况的事件流，包括用况是怎样开始的，是怎样结束的，是怎样与参与者进行交互的，最终形成一系列精化的用况</li>\n<li>活动五：构造用户界面原型。这一活动的目的在于建造用户界面原型，使用户可以有效地执行用况。</li>\n<li>活动六：用况模型的结构化。需要进行以下工作。<ol>\n<li>抽取用况描述中的那些一般性的和共享的功能并使用泛化关系标识和描述那些共享功能</li>\n<li>抽取用况描述附加的或可选的功能</li>\n<li>标识用况之间的包含关系。通过用况模型的结构化，最终形成一个系统/产品的精化用户模型</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"创建系统-产品需求分析模型的活动和任务\"><a href=\"#创建系统-产品需求分析模型的活动和任务\" class=\"headerlink\" title=\"创建系统/产品需求分析模型的活动和任务\"></a>创建系统/产品需求分析模型的活动和任务</h4><ol>\n<li>活动1：体系结构分析。该活动的目标是通过标识分析包和分析类，建立分析模型和体系结构“骨架”，并标识有关分析包和分析类的特定需求。<br>任务1：标识分析包。该任务的基本输入是系统的用况模型<br>任务2：处理分析包之间的共性<br>任务3：标识服务包<br>任务4：定义分析包的依赖，该任务的目标是发现相对独立的包，实现包的高内聚和低耦合<br>任务5：标识重要的实体类，该任务的目标是标识在体系结构方面具有意义的实体类。<br>任务6：标识分析包和重要实体类的公共特定需求，该任务的目标是依据需求获取阶段所标识的非功能需求，针对在分析期间所标识的包和分析类，标识它们的一些公共的特定要求。</li>\n<li>活动2：用况分析。该活动的目标是：一是标识那些在用况事件流执行中所需要的分析类和对象；二是将用况的行为分布到参与交互的各个分析对象；三是捕获用况细化上的特定需求。<br>任务1：标识分析类，该任务的目标是标识在细化一个用况中所需要实体类、控制类和边界类，给出它们的名字、责任、属性和关系。<br>任务2：描述分析类对象之间的交互。首先确定细化该用况所必要的交互，其次分派该用况的功能，最后根据其责任，发现该交互图中的各个链。</li>\n<li>活动3：类的分析。该活动的目标：一是标识并维护分析类的属性和关系；二是捕获分析类细化中的特殊需求。<br>任务1：标识责任，通过组合一个类在不同用况细化中所扮演的角色来完成。<br>任务2：标识属性<br>任务3：标识关联和聚合</li>\n<li>活动4：包的分析。该活的目标是：一是确保分析包尽可能与其他包相对独立；而是确保分析包实现了它的目标；三是描述依赖，以益于可以估计未来的变化。</li>\n</ol>\n<h3 id=\"创建系统-产品设计模型的活动和任务\"><a href=\"#创建系统-产品设计模型的活动和任务\" class=\"headerlink\" title=\"创建系统/产品设计模型的活动和任务\"></a>创建系统/产品设计模型的活动和任务</h3><p>创建系统/产品设计模型的活动和任务如下：</p>\n<ol>\n<li>活动1：体系结构设计，该活动的目标是创建设计模型和部署模型，以及它们视角下的体系结构描述<br>任务1：标识节点和它们的网络配置，网络配置通常使用一种三元模式：客户端、数据库功能、业务/应用逻辑<br>任务2：标识子系统和它们的接口，目的是为了寻求一些复用的可能，而后随着设计模型的开发，在形成子系统结构中不断发现并烟花。<br>任务3：标识在体系结构方面有意义的设计类和它们的接口。标识在体系结构方面有意义的设计类的基本思想是：初始可以依据在体系结构方面有意义的分析类来标识一些体系结构上具有重要意义的设计类。标识在系统体系结构方面有意义的设计类时，应注意主动类往往是一类在体系结构方面具有重要意义的类。</li>\n<li>活动2：用况的设计。其中分析模型用况细化分析是活动的输入、对应输出用况细化设计。<br>为了实现用况设计的输入/输出，一般采用两种方法：<ol>\n<li>标识参与用况细化的设计类，首先基于分析模型研究相应用况细化分析中的分析类，来标识为细化这些分类所需要的设计类，然后基于用况的功能对每一个标识的设计类赋予相应的责任，最后为该细化创建一个类图，汇聚参与该用况细化的设计类，并给出类之间的关系。</li>\n<li>标识参与用况细化的子系统和接口。</li>\n</ol>\n</li>\n<li>活动3：类的设计。该活动的目标是完成用况细化设计中每一个类的角色设计，并完成有关每一类的非功能需求的设计。<br>任务1：概括描述设计类，该任务的输入为分析类/接口。<br>任务2：标识的操作，一般应依据分析类来标识设计类所提供的、所需要的操作，其中需要使用程序设计语言的语法来描述说标识的操作。<br>任务3：标识属性，该任务的目标是标识设计类所需要的属性，并使用程序设计语言的语法给出属性的描述。<br>任务4：标识关联和聚合。<br>任务5：标识泛化，基于分析模型中分析类之间的泛化，可以发现设计模型中的很多泛化。<br>任务6：描述方法，在设计期间一般用自然语言或适当的使用伪码对方法进行规约，但是在实现期间直接使用程序设计语言对方法进行规约。<br>任务7：描述状态，有些设计对象是受状态控制的，即它们的状态确定了它们接受一个消息的行为。在这种情况下，使用一个状态图描述一个对象的不同状态转移是有意义的。</li>\n<li>活动4：子系统的设计。该活动的目标是：确保子系统尽可能独立于其他子系统或它们的接口；确保子系统提供正确的接口；确保子系统实现了它的目标，即给出了该子系统提供的那些接口所定义的操作的细化。</li>\n</ol>\n<h3 id=\"设计模型包含的元素\"><a href=\"#设计模型包含的元素\" class=\"headerlink\" title=\"设计模型包含的元素\"></a>设计模型包含的元素</h3><p>RUP设计的主要结果是设计模型，它尽量保持该系统具有分析模型的结构，并作为系统实现的输入，包含以下四个元素：</p>\n<ol>\n<li>设计子系统和服务子系统，以及它们的接口、依赖和内容。</li>\n<li>设计类以及它们具有的操作、属性、关系及其实现的需求。</li>\n<li>用况细化设计。</li>\n<li>设计模型视角下的体系结构描述。</li>\n</ol>\n<h3 id=\"用况模型与分析模型的比较\"><a href=\"#用况模型与分析模型的比较\" class=\"headerlink\" title=\"用况模型与分析模型的比较\"></a>用况模型与分析模型的比较</h3><table>\n<thead>\n<tr>\n<th align=\"center\">用况模型</th>\n<th align=\"center\">分析模型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">使用客户语言来描述</td>\n<td align=\"center\">使用开发者语言来描述</td>\n</tr>\n<tr>\n<td align=\"center\">给出的是系统对外的视图</td>\n<td align=\"center\">给出的是系统对内的视图</td>\n</tr>\n<tr>\n<td align=\"center\">使用用况予以结构化，但给出的是外部视角下的系统结构</td>\n<td align=\"center\">使用衍型类予以结构化，当给出的是内部视角下的系统结构</td>\n</tr>\n<tr>\n<td align=\"center\">可以作为客户与开发者之间关于“系统应该做什么，不应该做什么”的契约</td>\n<td align=\"center\">可以作为开发者理解系统如何勾画、如何设计和如何实现的基础</td>\n</tr>\n<tr>\n<td align=\"center\">在需求之间可能存在一些冗余、不一致和冲突等问题</td>\n<td align=\"center\">在需求之间不应存在冗余、不一致和冲突问题</td>\n</tr>\n<tr>\n<td align=\"center\">捕获的是系统的功能，包括在体系结构方面有意义的功能</td>\n<td align=\"center\">给出的是细化的系统功能，包括在体系结构方面具有意义的功能</td>\n</tr>\n<tr>\n<td align=\"center\">定义了一些进一步需要在分析模型中予以分析的</td>\n<td align=\"center\">定义了用况模型中每一个用况的细化</td>\n</tr>\n</tbody></table>\n<h3 id=\"RUP实现活动\"><a href=\"#RUP实现活动\" class=\"headerlink\" title=\"RUP实现活动\"></a>RUP实现活动</h3><p>目标：基于设计类和子系统生成构件；对构件进行单元测试，进行集成和连接；把可执行的构件映射到部署模型。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">输入</th>\n<th align=\"center\">活动</th>\n<th align=\"center\">执行者</th>\n<th align=\"center\">输出</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">设计模型、部署模型、体系结构描述【设计模型、部署模型角度】</td>\n<td align=\"center\">实现体系结构</td>\n<td align=\"center\">体系结构设计者</td>\n<td align=\"center\">构件【概述】、体系结构描述【实现模型、部署模型角度】</td>\n</tr>\n<tr>\n<td align=\"center\">补充需求、用况模型、设计模型、实现模型【当前建造】</td>\n<td align=\"center\">集成系统</td>\n<td align=\"center\">系统集成者</td>\n<td align=\"center\">集成建造计划、实现模型【连续的建造】</td>\n</tr>\n<tr>\n<td align=\"center\">集成建造计划、体系结构描述【实现模型角度】、设计子系统【已设计】、接口【已设计】</td>\n<td align=\"center\">实现子接口</td>\n<td align=\"center\">构件工程师</td>\n<td align=\"center\">实现子系统【建造完成】、接口【建造完成】</td>\n</tr>\n<tr>\n<td align=\"center\">设计类【已设计】、接口【由设计类提供】</td>\n<td align=\"center\">实现类</td>\n<td align=\"center\">构件工程师</td>\n<td align=\"center\">构件【完成】</td>\n</tr>\n<tr>\n<td align=\"center\">构件【完成】、接口</td>\n<td align=\"center\">完成单元测试</td>\n<td align=\"center\">构件工程师</td>\n<td align=\"center\">构件【已完成单元测试】</td>\n</tr>\n</tbody></table>\n<h3 id=\"RUP测试活动\"><a href=\"#RUP测试活动\" class=\"headerlink\" title=\"RUP测试活动\"></a>RUP测试活动</h3><p>RUP的测试包括内部测试、中间测试和最终测试</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">输入</th>\n<th align=\"center\">活动</th>\n<th align=\"center\">输出</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">补充需求、用况模型、分析模型、设计模型、实现模型、体系结构的描述</td>\n<td align=\"center\">计划测试</td>\n<td align=\"center\">测试计划</td>\n</tr>\n<tr>\n<td align=\"center\">补充需求、用况模型、分析模型、设计模型、实现模型、体系结构描述、测试计划</td>\n<td align=\"center\">设计测试</td>\n<td align=\"center\">测试用况 测试过程</td>\n</tr>\n<tr>\n<td align=\"center\">测试用况、测试过程、实现模型</td>\n<td align=\"center\">实现测试</td>\n<td align=\"center\">测试构件</td>\n</tr>\n<tr>\n<td align=\"center\">测试用况、测试过程、测试构件、实现模型</td>\n<td align=\"center\">执行集成测试</td>\n<td align=\"center\">缺陷</td>\n</tr>\n<tr>\n<td align=\"center\">测试用况、测试过程、测试构件、实现模型</td>\n<td align=\"center\">执行系统测试</td>\n<td align=\"center\">缺陷</td>\n</tr>\n<tr>\n<td align=\"center\">测试用况、测试模型、缺陷</td>\n<td align=\"center\">评价测试</td>\n<td align=\"center\">测试评价</td>\n</tr>\n</tbody></table>\n<h2 id=\"软件测试\"><a href=\"#软件测试\" class=\"headerlink\" title=\"软件测试\"></a>软件测试</h2><h3 id=\"软件测试目标与软件测试过程模型\"><a href=\"#软件测试目标与软件测试过程模型\" class=\"headerlink\" title=\"软件测试目标与软件测试过程模型\"></a>软件测试目标与软件测试过程模型</h3><h4 id=\"软件测试及目标\"><a href=\"#软件测试及目标\" class=\"headerlink\" title=\"软件测试及目标\"></a>软件测试及目标</h4><p>软件测试的定义为：按照特定规程发现软件错误的过程。其目的是检验它是否满足规定的需求，或清楚了解预期结构与实际结果之间的差异</p>\n<h4 id=\"软件测试与软件调试之间的区别\"><a href=\"#软件测试与软件调试之间的区别\" class=\"headerlink\" title=\"软件测试与软件调试之间的区别\"></a>软件测试与软件调试之间的区别</h4><p>软件测试与软件调试相比，在目的、技术和方法等方面都存在很大区别，主要表现在以下几个方面。</p>\n<ol>\n<li>测试从一个侧面证明程序员的”失败”.调试是为了证明程序员的正确。</li>\n<li>测试以已知条件开始，使用预先定义的程序且有预知的结果，不可预见的仅是程序是否通过。调试一般是以不可知的内部条件开始，除统计性调试外，结果是不可预见的。</li>\n<li>测试是有计划的，并要进行测试设计。调试是不受时间约束的。</li>\n<li>测试是一个发现错误、改正错误、重新测试的过程。调试是一个推理过程。</li>\n<li>测试的执行是有规程的。调试的执行往往要求程序员进行必要推理。</li>\n<li>测试经常是由独立的测试组在不了解软件设计的条件下完成的。调试必须由了解详细设计的程序员完成。</li>\n<li>大多数测试的执行和设计可由工具支持。调试时，程序员能利用的主要工具是调试器。</li>\n</ol>\n<h4 id=\"测试过程模型\"><a href=\"#测试过程模型\" class=\"headerlink\" title=\"测试过程模型\"></a>测试过程模型</h4><p>软件测试是一个有程序的过程，包括测试设计、测试执行以及测试结果比较。测试过程模型可分为三类：环境模型、被测对象模型和错误模型。</p>\n<ol>\n<li>环境模型：是对程序运行环境的抽象。程序运行环境又包括支持其运行的硬件、固件和软件，如计算机、终端设备、网卡、操作系统、编译系统、实用程序等。在软件测试过程中，建立环境模型的主要目的是，确定所发现的错误是否为环境造成的。</li>\n<li>被测对象模型：该模型是从测试的角度对程序的抽象。为了测试，必须简化程序，形成被测程序的抽象版本、即对象模型。</li>\n<li>错误模型：该模型是对程序中的错误及其分类的抽象。在软件测试中，往往需要定义“什么是错误”、“什么是一般性错误”、“什么是严重性错误”等，即要给出“错误模型”。</li>\n</ol>\n<h3 id=\"软件测试技术\"><a href=\"#软件测试技术\" class=\"headerlink\" title=\"软件测试技术\"></a>软件测试技术</h3><ol>\n<li><p>测试覆盖及其他们之间的基本关系<br>软件测试技术大体上可分为两大类：一类是白盒测试技术，又称为结构测试技术，典型的是路径测试技术；另一种是黑盒测试技术，又称为功能测试技术，包括事务处理流程技术、状态测试技术、定义域测试技术等。白盒测试技术依据的是程序的逻辑结构，而黑盒测试技术依据的是软件行为的描述。</p>\n</li>\n<li><p>路径测试技术的分类</p>\n<p> 测试覆盖包括路径覆盖、分支覆盖、条件覆盖与条件组合覆盖。</p>\n<ol>\n<li>路径覆盖：执行所以有可能穿过程序控制流程的路径。在路径测试中，该度量是最强的，一般是不可实现的。</li>\n<li>语句覆盖：至少执行程序中所有语句一次</li>\n<li>分支覆盖：至少将程序中的每一个分支执行一次</li>\n<li>条件覆盖与条件组合覆盖：条件覆盖是指每个判定中所有的可能的条件的取值至少执行一次；条件组合覆盖是指设计足够的测试用例，使每个判定中所有可能的条件取值组合至少执行一次。</li>\n</ol>\n<p> 这四种测试覆盖的测试覆盖率由弱到强的顺序是：语句覆盖 &lt; 分支覆盖 &lt; 条件组合覆盖 &lt; 路径覆盖</p>\n</li>\n<li><p>事务流测试步骤</p>\n<p> 事务流测试步骤具体如下。<br> 第一步：获得事务流程图。<br> 第二步：浏览、复审。<br> 第三步：用例设计。<br> 第四步：测试执行。</p>\n</li>\n<li><p>运用等价类划分技术进行测试的步骤</p>\n<p> 具体测试步骤如下。<br> 第一步：建立等价类表<br> 第二步：为有效等价类设计测试用例<br> 第三步：为无效等价类至少设计一个测试用例</p>\n</li>\n<li><p>边界值分析的使用原则</p>\n<p> 边界值分析是一种常用的黑盒测试技术。使用边界值分析在设计测试用例时，可以遵循以下原则。</p>\n<ol>\n<li>如果某个输入条件规定了输入值的范围，则应该选择正好等于边界值的数据，以及刚刚超过边界值的数据作为测试数据。</li>\n<li>如果某个输入条件规定了值的个数，则可用最大个数、最小个数、比最大个数多1、比最小个数少1的数据作为测试数据</li>\n<li>根据规格说明的每个输出条件，使用前面的原则1</li>\n<li>根据规格说明的每个输出条件，使用前面的原则2</li>\n<li>如果程序的规格说明中，输入域或输出域是有序集合，在实践中则经常选取集合的第一个元素、最后一个元素以及典型元素作为测试用例。</li>\n<li>如果程序中使用了内部数据结构，则应该选择这个内部数据结构的边界上的值作为测试用例。</li>\n<li>分析规格说明，找出其他可能的边界条件。</li>\n</ol>\n</li>\n<li><p>使用因果图生成测试用例的步骤</p>\n<p> 因果图技术是通过为判定表的每一列设计一个测试用例，从而实现测试用例的设计与选择的。该方法生成测试用例的基本步骤如下。</p>\n<ol>\n<li>通过软件规格说明书的分析，找出一个模块的原因和结果，并给每个原因和结果赋予一个标识符</li>\n<li>分析原因与结果之间以及原因之间对应的关系，并画出因果图。</li>\n<li>在因果图上标识出一些特定的约束或限制条件。</li>\n<li>把因果图转换成判定表。</li>\n<li>把判定表的每一列拿出来作为依据，设计测试用例。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"软件测试步骤\"><a href=\"#软件测试步骤\" class=\"headerlink\" title=\"软件测试步骤\"></a>软件测试步骤</h3><ol>\n<li><p>单元测试<br> 单元测试主要检验软件设计的最小单元—模块。该测试以详细设计文档为指导，测试模块内的重要控制路径。一般来说，单元测试往往采用白盒测试技术。</p>\n</li>\n<li><p>集成测试<br> 集成测试是软件组装的一个系统化技术，其目标是发现与接口有关的错误，将经过单元测的模块构成一个满足设计要求的软件结构。集成测试集中于模块组合的功能和软件结构检验。集成测试可“自顶向下”地进行，称为自顶向下的集成测试；也可以“自底向上”地进行测试，称为自底向上的集成测试</p>\n</li>\n<li><p>有效性测试<br> 有效性测试的目标是发现软件实现的功能与需求规格说明书不一致的错误。因此有效性测试通常采用黑盒测试技术。</p>\n</li>\n<li><p>系统测试<br> 系统测试验证将软件融于更大系统中时整个系统的有效性。</p>\n</li>\n</ol>\n<h2 id=\"软件生存周期过程与管理\"><a href=\"#软件生存周期过程与管理\" class=\"headerlink\" title=\"软件生存周期过程与管理\"></a>软件生存周期过程与管理</h2><h3 id=\"软件生存周期过程概述\"><a href=\"#软件生存周期过程概述\" class=\"headerlink\" title=\"软件生存周期过程概述\"></a>软件生存周期过程概述</h3><ol>\n<li><p>过程分类</p>\n<p> 按过程主体把软件生存周期过程分为以下几个过程。</p>\n<ol>\n<li>基本过程：是指那些与软件生产直接相关的活动集。该过程又可分为获取过程、供应过程、开发过程、运行过程和维护过程。</li>\n<li>支持过程：是指有关各方按他们的目标所从事的一系列相关支持活动集。该过程又可分为文档过程、配置管理过程、质量保证过程、验证过程、确认过程、联合评审过程、审计过程和问题解决过程。</li>\n<li>组织过程：是指那些与软件生产组织有关的活动集。该过程又可分为设计过程、基础设施过程、培训过程和改进过程。</li>\n</ol>\n</li>\n<li><p>系统语境的过程类<br> 系统语境的过程类包含四个过程组，分别是协议过程组、项目过程组、技术过程组和组织上项目使能过程组。</p>\n<ol>\n<li>协议过程组包含两个过程：获取过程和供应过程。</li>\n<li>项目过程组包含七个过程：项目规划过程、项目评价过程、决策管理过程、风险管理过程、配置管理过程、信息管理过程和测量过程。</li>\n<li>技术过程组包含11个过程：利益攸关方需求定义过程、系统需求分析过程、系统体系结构设计过程、实现过程、系统集成过程、系统测试过程、软件安装过程、软件接受支持过程、软件运行过程、软件维护过程和软件销毁过程。</li>\n<li>组织上使能过程组包含五个过程：生存周期模型管理过程、基础设施管理过程、项目包管理过程、人力资源管理过程和质量管理过程。</li>\n</ol>\n</li>\n<li><p>组织上使能过程的作用。<br> 组织上使能的过程一般来说是组织层面上的工作，为项目的执行提供基本保障。该过程包含五个子过程。</p>\n<ol>\n<li>生存周期模型管理过程：其任务为过程建立、过程评估、过程改进。</li>\n<li>基础设施管理过程：其任务为过程实现、基础设施的建立、基础设施的维护。</li>\n<li>项目包管理过程：项目初始化、项目包评估、项目结束处理。</li>\n<li>人力资源管理过程：其任务为技能标识、技能开发、技能获取和供给、知识管理。</li>\n<li>质量管理过程：其任务为质量管理、质量管理纠正措施。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"过程描述\"><a href=\"#过程描述\" class=\"headerlink\" title=\"过程描述\"></a>过程描述</h3><p>软件验证过程包括两个活动：过程实现和验证。其中验证活动有五个任务：需求验证、设计验证、代码验证，集成验证和文档验证。</p>\n<p>一个过程可通过过程意图，期望的结果以及到达过程结果需要执行的活动和任务来描述。对于一个过程的完整技术上的描述，还应包括：达到过程意图和实现过程结果的方法或规程，以及过程和活动文档。</p>\n<h3 id=\"应用说明\"><a href=\"#应用说明\" class=\"headerlink\" title=\"应用说明\"></a>应用说明</h3><ol>\n<li><p>系统和软件的关系</p>\n<p> 在《ISO/IEC系统与软件工程-软件生产周期过程12207-2008》标准中，把软件认为是整个系统的一个组成从部分，执行系统中所确定的功能主要包括三大功能：控制功能、耦合功能以及软件本身提供的功能。由于软件通常存在与一个系统的上下文中，因此软件产品或服务一般可被认为是系统的一个项或称为系统元素。</p>\n</li>\n<li><p>剪裁过程及应用</p>\n<p> 剪裁过程是使剪裁这一标准过程慢速以下特定情况或因素。</p>\n<ol>\n<li>围绕一个组织，其中该组织在一个协议中使用了这一标准</li>\n<li>影响一个项目，其中要求该项目满足一个引用该标准的协议</li>\n<li>反映一个组织的需要，其中该组织要供给产品或服务</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"软件生存周期模型\"><a href=\"#软件生存周期模型\" class=\"headerlink\" title=\"软件生存周期模型\"></a>软件生存周期模型</h3><ol>\n<li><p>瀑布模型</p>\n<p> 瀑布模型是将软件生存周期各个活动规定为按固定顺序链接的若干阶段的模型。这一模型规定了个开发阶段的活动：系统需求、软件需求、需求分析、设计、编码、测试和运行，并且自上而下具有相互衔接的固定顺序；还规定了每一个阶段的输入，即工作对象以及本阶段的工作成果，作为输出传送到下一阶段。</p>\n<p> 瀑布模型的提出，对软件工程的主要贡献如下。</p>\n<ol>\n<li>在决定系统怎样做之前存在一个需求阶段，它鼓励对系统做什么进行规约。</li>\n<li>在系统构造之前存在一个需求阶段，它鼓励规划系统结构。</li>\n<li>在每一阶段结束时进行评审，从而允许获取方和用户的参与。</li>\n<li>前一步可以作为下一步被认可的、文档化的基线，并允许基线和配置早期接受控制。</li>\n</ol>\n<p> 瀑布模型的主要问题是：</p>\n<ol>\n<li>要求客户能完整、正确和清晰地表达他们的需求；并要求开发人员一开始就要理解这一应用。</li>\n<li>由于需求的不稳定性，使设计、编码和测试阶段都可能发生延期；并且当项目接近结束时，出现了大量的集成和测试工作。</li>\n<li>在开始的阶段中，很难评估真正的进度状态；并且直到项目结束之前都不能演示系统的能力。</li>\n<li>在一个项目的早期开发阶段，过分地强调了基线和里程碑处的文档；并可能需要花费更多的时间用于建立一些用处不大的文档。</li>\n</ol>\n</li>\n<li><p>增量模型</p>\n<p> 增量模型是一种非整体开发的模型。软件在该模型中逐渐开发出来，开发出一部分，向用户展示一部分，可让用户及早看到部分软件，及早发现问题。该模型具有较大的灵活性，适合软件需求不明确、设计方案有一定风险的软件项目。</p>\n</li>\n<li><p>演化模型</p>\n<p> 该模型主要针对事先不能完整定义需求的软件开发在用户提出待开发系统的核心需求的基础上，软件开发人员按照这一要求，首先开发一个核心系统并投入运行，以便用户能够有效地提出反馈，即精化系统、增强系统能力的需求；接着，软件开发人员根据用户反馈，实施开发的迭代过程；每一迭代过程均由需求、设计、编码、测试、集成等阶段组成，为整个系统增加一个可定义的，可管理的子集；如果在一次迭代中，有的需求不能满足用户的要求，可在下一次迭代中予以修正。</p>\n<p> 主要特征：该模型显式地把需求获取扩展到需求阶段，既为了第二个构造增量，使用了第一个构造增量来精化需求。演化模型在一定程度上可以减少软件开发活动的盲目性。<br>不足之处：在演化模型的使用中，即使很好地理解了需求或设计，也很容易弱化需求分析阶段的工作。</p>\n</li>\n<li><p>螺旋模型</p>\n<p> 螺旋模型将瀑布模型与增量模型结合起来，加入了两种模型均忽略了的风险分析，弥补了这两种模型的不足。因而它是一种风险驱动的模型。螺旋模型将开放过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合。</p>\n<p> 螺旋模型关注解决问题的基本步骤，即标识问题，标识一些可选方案，选择一个最佳方案，遵循动作步骤并实施后续工作。其一个突出特征是，在开发的迭代中实际上只有一个迭代过程真正开发了可交付的软件。螺旋模型与演化模型和增量模型相比，同样适用了瀑布模型作为一个嵌入的过程，但螺旋模型所关注的阶段以及它们的活动是不同的。如果项目的开发风险很大或客户不能确定系统需求，在更广泛的意义上来讲，还包括一个系统或系统类型的要求，这时螺旋模型就是一个很好的生存周期模型。</p>\n</li>\n<li><p>喷泉模型</p>\n<p> 喷泉模型体现了软件创建所固有的迭代和无间隙的特征。该模型主要用于支持面向对象技术的软件开发。由于对象概念的引入，使分析、设计、实现之间的表达没有明显间隙。</p>\n</li>\n</ol>\n<h3 id=\"过程规划与管理\"><a href=\"#过程规划与管理\" class=\"headerlink\" title=\"过程规划与管理\"></a>过程规划与管理</h3><ol>\n<li><p>创建一个软件项目生存周期过程的步骤</p>\n<ol>\n<li>选择软件生存周期模型</li>\n<li>细化所选择的生存周期模型</li>\n<li>为每一个活动或任务标识合适的实例数目</li>\n<li>确定活动的时序关系，并检查信息流</li>\n<li>建立过程计划的文档</li>\n</ol>\n</li>\n<li><p>软件评估中应考虑的影响因素</p>\n<ol>\n<li>不管做怎么样的决策，都必须对所采取的的措施对生存周期过程所产生的影响进行评审，以便保证项目获得好的结果。在这一评估中，应考虑以下几方面的影响。<ol>\n<li>所要求的的“返工”</li>\n<li>资源需求</li>\n<li>实施时间</li>\n<li>对项目和用户的益处</li>\n<li>员工情绪</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"集成化能力成熟度模型（CMMI）\"><a href=\"#集成化能力成熟度模型（CMMI）\" class=\"headerlink\" title=\"集成化能力成熟度模型（CMMI）\"></a>集成化能力成熟度模型（CMMI）</h2><h3 id=\"背景和原理\"><a href=\"#背景和原理\" class=\"headerlink\" title=\"背景和原理\"></a>背景和原理</h3><ol>\n<li><p>过程改善</p>\n<p> 历史过程改善，是指人为设计的一个活动程序，其目的是改进组织的过程性能和成熟度，并改进这一程序的结果</p>\n</li>\n<li><p>过程域、专用目标和共用目标</p>\n<p> 过程域是一个业务域中一束相关的实践，当它们一起得以实现时，就满足被认为对该过程域的改善具有重要作用的一组条件<br> 专用目标是用于描述满足该过程域必须呈现的一些独有特征。经可以用于帮助确定一个过程域是否得以满足。<br> 共用目标用于描述产现制度化的该过程必须呈现的特征，仅用于确定一个过程域是否得以满足。</p>\n</li>\n</ol>\n<h3 id=\"CMMI的模型部件\"><a href=\"#CMMI的模型部件\" class=\"headerlink\" title=\"CMMI的模型部件\"></a>CMMI的模型部件</h3><table>\n<thead>\n<tr>\n<th align=\"center\">过程域类名</th>\n<th align=\"left\">包括的过程域</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">项目管理类</td>\n<td align=\"left\">项目规划<br/>项目监控<br/>定量项目管理<br/>集成项目管理<br/>风险管理<br/>提供方协议管理</td>\n</tr>\n<tr>\n<td align=\"center\">工程类</td>\n<td align=\"left\">需求开发<br/>需求管理<br/>技术解决方案<br/>产品集成<br/>确认<br/>验证</td>\n</tr>\n<tr>\n<td align=\"center\">支持类</td>\n<td align=\"left\">配置管理<br/>过程和产品质量保证<br/>测量与分析<br/>原因分析与解决<br/>决策分析与解决</td>\n</tr>\n<tr>\n<td align=\"center\">过程管理类</td>\n<td align=\"left\">组织过程定义<br/>组织过程性能<br/>组织过程培训<br/>组织过程关注<br/>组织创新与部署</td>\n</tr>\n</tbody></table>\n<h3 id=\"CMMI的等级\"><a href=\"#CMMI的等级\" class=\"headerlink\" title=\"CMMI的等级\"></a>CMMI的等级</h3><ol>\n<li><p>能力等级的组成</p>\n<p> 能力等级是用来表征组织对一个过程域的改善，是不断改善一个给定过程域的一种手段。在CMMI中，针对每个过程域设定了6个能力等级，即0级：未完成级；1级：已执行级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：待续优化级。</p>\n</li>\n<li><p>成熟度等级的组成</p>\n<p> 在CMMI中，应用于一个组织过程改善的成熟度等级有5个。即1级：初始级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：持续优化级</p>\n</li>\n<li><p>能力等级与成熟度等级之间的基本关系</p>\n<ol>\n<li>能力等级与成熟度等级是互补的关系，两者都是一种过程改善路径，即表征组织对单一过程域的改进。</li>\n<li>成熟度等级的路径可使组织针对单一过程域不断改善一组相关过程域，即表征组织对一组过程域的改进。</li>\n<li>两种等级的2-5级使用了同样的名字</li>\n</ol>\n</li>\n<li><p>达到各共用目标要实施的共同实践</p>\n<p> 达到公用目标2、共用目标3、共用目标4和共用目标5所要实施的共同实践如下表所示</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">所要实施的共用实践</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">共用目标2：把过程制度化为一个管理过程</td>\n<td align=\"center\">GP2.1 建立组织策略<br/>GP2.2 规划过程<br/>GP2.3 提供资源<br/>GP2.4 指派责任<br/>GP2.5 培训人员<br/>GP2.6 管理配置<br/>GP2.7 标识相关利益方的参与<br/>GP2.8 监控过程<br/>GP2.9 客观地评估符合性<br/>GP2.10 从高层管理的视觉评审状态<br/></td>\n</tr>\n<tr>\n<td align=\"center\">共用目标3：把过程制度化为一个已定义过程</td>\n<td align=\"center\">GP3.1 建立一个已定义的过程<br/>GP3.2 收信进信息 所要实施的共用实践</td>\n</tr>\n<tr>\n<td align=\"center\">共用目标4：把过程制度化为一个已定量管理过程</td>\n<td align=\"center\">GP4.1 为该过程建立定量目的<br/>GP4.2 使子过程性能达到稳定</td>\n</tr>\n<tr>\n<td align=\"center\">共用目标5：把过程制度化为一个持续优化过程</td>\n<td align=\"center\">GP5.1 确保不断进行过程改善<br/>GP5.2 收集问题的根本原因</td>\n</tr>\n</tbody></table>\n<p>完结</p>"},{"title":"建造者模式","author":"Arclin","abbrlink":"fe816c3c","date":"2016-10-29T16:00:00.000Z","_content":"关于建造者模式的个人理解\n建造者模式适用于一个复杂的对象,但是他有多种构建方式,而且每种构建方式都不简单,写在一起不方便维护.建造者模式可以帮助分离对象和它的构建,使得调用相同的一个方法可以创建不同的表示.\n<!-- more -->\n比如说 蛋糕 对象,使用者需要通过调用一个方法,只要传入不同的参数,就可以返回草莓蛋糕,黑森林蛋糕,芝士蛋糕(懒得写了)等.\n\n举蛋糕的例子:\n怎么做蛋糕\n\n```\n- (void)viewDidLoad\n{\n\t[super viewDidLoad];\n\t// 想要什么蛋糕就只要实例化这个蛋糕(下订单)\n\tCakeBulider *bulider = [[StraberryCakeBulider alloc] init];\t\n\t\n\t// 然后让蛋糕店去做蛋糕\n\tCake *cake = [CakeStore createCake:bulider];\n\t\n\t// 看看蛋糕长什么样子\n\tNSLog(@\"%@\",cake.description);\n}\n```\n\nCake.m 蛋糕实体\n\n```\n@interface Cake : NSObject\n\n@property (nonatomic, assign)NSInteger *self.scream;// 奶油分量\n@property (nonatomic, copy)NSString *self.ingredients;// 配料\n@property (nonatomic, assign)NSInteger *self.bakeTime;// 烘焙时间\n// 还有等等好多好多参数，但是我只关心这些\n\n@end\n\n@implementation Cake\n\n// 让它做自我介绍\n- (NSString *)description{\n   return [NSString stringWithFormat:@\"我是一个蛋糕:奶油分量%zd 配料%@ 烘焙时间是:%zd\",self.scream,self.ingredients,self.bakeTime];\n}\n```\n\nCakeStore.m 卖蛋糕的店铺\n\n```\n+ (Cake *)createCake:(CakeBulider *)bulider\n{\n\tCake *cake = [bulider bakeCake];\n\treturn cake;\n}\n```\n\nCakeBulider.m 蛋糕自动烘焙机\n\n```\n- (Cake *)bakeCake\n{\n\tCake *cake = [[Cake alloc] init];\n\tcake.scream = self.scream;\n\tcake.ingredients = self.ingredients;\n\tcake.bakeTime = self.bakeTime;\n\tretrn cake;\n}\n```\n\nStrawberryCakeBulider.m 草莓蛋糕\n\n```\n@interface StrawberryCakeBulider():Cake\n@end\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.scream = 10;\n        self.ingredients = @\"strawberry\";\n        self.bakeTime = 10;\n    }\n    return self;\n}\n```\n\nBlackForestCakeBulider.m 黑森林蛋糕\n\n```\n@interface BlackForestCakeBulider():Cake\n@end\n\n- (instancetype)init\n{\n\tself = [super init];\n\tif(self){\n\t\tself.scream = 11;\n\t\tself.ingredients = @\"cholocate\";\n\t\tself.bakeTime = 5;\n\t}\n\treturn self;\n}\n```\n\n(话说大半夜的写蛋糕真的好吗)\n其实QCCloud那个项目说不定就会用到这个模式,所以在这里稍微复习一下,回忆之前的知识.\n\n(明天再去复习别的即将会用到的设计模式)","source":"_posts/建造者模式.md","raw":"---\ntitle: 建造者模式\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: fe816c3c\ndate: 2016-10-30 00:00:00\n---\n关于建造者模式的个人理解\n建造者模式适用于一个复杂的对象,但是他有多种构建方式,而且每种构建方式都不简单,写在一起不方便维护.建造者模式可以帮助分离对象和它的构建,使得调用相同的一个方法可以创建不同的表示.\n<!-- more -->\n比如说 蛋糕 对象,使用者需要通过调用一个方法,只要传入不同的参数,就可以返回草莓蛋糕,黑森林蛋糕,芝士蛋糕(懒得写了)等.\n\n举蛋糕的例子:\n怎么做蛋糕\n\n```\n- (void)viewDidLoad\n{\n\t[super viewDidLoad];\n\t// 想要什么蛋糕就只要实例化这个蛋糕(下订单)\n\tCakeBulider *bulider = [[StraberryCakeBulider alloc] init];\t\n\t\n\t// 然后让蛋糕店去做蛋糕\n\tCake *cake = [CakeStore createCake:bulider];\n\t\n\t// 看看蛋糕长什么样子\n\tNSLog(@\"%@\",cake.description);\n}\n```\n\nCake.m 蛋糕实体\n\n```\n@interface Cake : NSObject\n\n@property (nonatomic, assign)NSInteger *self.scream;// 奶油分量\n@property (nonatomic, copy)NSString *self.ingredients;// 配料\n@property (nonatomic, assign)NSInteger *self.bakeTime;// 烘焙时间\n// 还有等等好多好多参数，但是我只关心这些\n\n@end\n\n@implementation Cake\n\n// 让它做自我介绍\n- (NSString *)description{\n   return [NSString stringWithFormat:@\"我是一个蛋糕:奶油分量%zd 配料%@ 烘焙时间是:%zd\",self.scream,self.ingredients,self.bakeTime];\n}\n```\n\nCakeStore.m 卖蛋糕的店铺\n\n```\n+ (Cake *)createCake:(CakeBulider *)bulider\n{\n\tCake *cake = [bulider bakeCake];\n\treturn cake;\n}\n```\n\nCakeBulider.m 蛋糕自动烘焙机\n\n```\n- (Cake *)bakeCake\n{\n\tCake *cake = [[Cake alloc] init];\n\tcake.scream = self.scream;\n\tcake.ingredients = self.ingredients;\n\tcake.bakeTime = self.bakeTime;\n\tretrn cake;\n}\n```\n\nStrawberryCakeBulider.m 草莓蛋糕\n\n```\n@interface StrawberryCakeBulider():Cake\n@end\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.scream = 10;\n        self.ingredients = @\"strawberry\";\n        self.bakeTime = 10;\n    }\n    return self;\n}\n```\n\nBlackForestCakeBulider.m 黑森林蛋糕\n\n```\n@interface BlackForestCakeBulider():Cake\n@end\n\n- (instancetype)init\n{\n\tself = [super init];\n\tif(self){\n\t\tself.scream = 11;\n\t\tself.ingredients = @\"cholocate\";\n\t\tself.bakeTime = 5;\n\t}\n\treturn self;\n}\n```\n\n(话说大半夜的写蛋糕真的好吗)\n其实QCCloud那个项目说不定就会用到这个模式,所以在这里稍微复习一下,回忆之前的知识.\n\n(明天再去复习别的即将会用到的设计模式)","slug":"建造者模式","published":1,"updated":"2021-04-12T06:07:04.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog67005b45n079mzewzr","content":"<p>关于建造者模式的个人理解<br>建造者模式适用于一个复杂的对象,但是他有多种构建方式,而且每种构建方式都不简单,写在一起不方便维护.建造者模式可以帮助分离对象和它的构建,使得调用相同的一个方法可以创建不同的表示.</p>\n<span id=\"more\"></span>\n<p>比如说 蛋糕 对象,使用者需要通过调用一个方法,只要传入不同的参数,就可以返回草莓蛋糕,黑森林蛋糕,芝士蛋糕(懒得写了)等.</p>\n<p>举蛋糕的例子:<br>怎么做蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[super viewDidLoad];</span><br><span class=\"line\">\t&#x2F;&#x2F; 想要什么蛋糕就只要实例化这个蛋糕(下订单)</span><br><span class=\"line\">\tCakeBulider *bulider &#x3D; [[StraberryCakeBulider alloc] init];\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F; 然后让蛋糕店去做蛋糕</span><br><span class=\"line\">\tCake *cake &#x3D; [CakeStore createCake:bulider];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F; 看看蛋糕长什么样子</span><br><span class=\"line\">\tNSLog(@&quot;%@&quot;,cake.description);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Cake.m 蛋糕实体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Cake : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, assign)NSInteger *self.scream;&#x2F;&#x2F; 奶油分量</span><br><span class=\"line\">@property (nonatomic, copy)NSString *self.ingredients;&#x2F;&#x2F; 配料</span><br><span class=\"line\">@property (nonatomic, assign)NSInteger *self.bakeTime;&#x2F;&#x2F; 烘焙时间</span><br><span class=\"line\">&#x2F;&#x2F; 还有等等好多好多参数，但是我只关心这些</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Cake</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 让它做自我介绍</span><br><span class=\"line\">- (NSString *)description&#123;</span><br><span class=\"line\">   return [NSString stringWithFormat:@&quot;我是一个蛋糕:奶油分量%zd 配料%@ 烘焙时间是:%zd&quot;,self.scream,self.ingredients,self.bakeTime];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>CakeStore.m 卖蛋糕的店铺</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (Cake *)createCake:(CakeBulider *)bulider</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tCake *cake &#x3D; [bulider bakeCake];</span><br><span class=\"line\">\treturn cake;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>CakeBulider.m 蛋糕自动烘焙机</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (Cake *)bakeCake</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tCake *cake &#x3D; [[Cake alloc] init];</span><br><span class=\"line\">\tcake.scream &#x3D; self.scream;</span><br><span class=\"line\">\tcake.ingredients &#x3D; self.ingredients;</span><br><span class=\"line\">\tcake.bakeTime &#x3D; self.bakeTime;</span><br><span class=\"line\">\tretrn cake;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>StrawberryCakeBulider.m 草莓蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface StrawberryCakeBulider():Cake</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self &#x3D; [super init];</span><br><span class=\"line\">    if (self) &#123;</span><br><span class=\"line\">        self.scream &#x3D; 10;</span><br><span class=\"line\">        self.ingredients &#x3D; @&quot;strawberry&quot;;</span><br><span class=\"line\">        self.bakeTime &#x3D; 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>BlackForestCakeBulider.m 黑森林蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface BlackForestCakeBulider():Cake</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tself &#x3D; [super init];</span><br><span class=\"line\">\tif(self)&#123;</span><br><span class=\"line\">\t\tself.scream &#x3D; 11;</span><br><span class=\"line\">\t\tself.ingredients &#x3D; @&quot;cholocate&quot;;</span><br><span class=\"line\">\t\tself.bakeTime &#x3D; 5;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(话说大半夜的写蛋糕真的好吗)<br>其实QCCloud那个项目说不定就会用到这个模式,所以在这里稍微复习一下,回忆之前的知识.</p>\n<p>(明天再去复习别的即将会用到的设计模式)</p>\n","site":{"data":{}},"excerpt":"<p>关于建造者模式的个人理解<br>建造者模式适用于一个复杂的对象,但是他有多种构建方式,而且每种构建方式都不简单,写在一起不方便维护.建造者模式可以帮助分离对象和它的构建,使得调用相同的一个方法可以创建不同的表示.</p>","more":"<p>比如说 蛋糕 对象,使用者需要通过调用一个方法,只要传入不同的参数,就可以返回草莓蛋糕,黑森林蛋糕,芝士蛋糕(懒得写了)等.</p>\n<p>举蛋糕的例子:<br>怎么做蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)viewDidLoad</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[super viewDidLoad];</span><br><span class=\"line\">\t&#x2F;&#x2F; 想要什么蛋糕就只要实例化这个蛋糕(下订单)</span><br><span class=\"line\">\tCakeBulider *bulider &#x3D; [[StraberryCakeBulider alloc] init];\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F; 然后让蛋糕店去做蛋糕</span><br><span class=\"line\">\tCake *cake &#x3D; [CakeStore createCake:bulider];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t&#x2F;&#x2F; 看看蛋糕长什么样子</span><br><span class=\"line\">\tNSLog(@&quot;%@&quot;,cake.description);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Cake.m 蛋糕实体</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Cake : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">@property (nonatomic, assign)NSInteger *self.scream;&#x2F;&#x2F; 奶油分量</span><br><span class=\"line\">@property (nonatomic, copy)NSString *self.ingredients;&#x2F;&#x2F; 配料</span><br><span class=\"line\">@property (nonatomic, assign)NSInteger *self.bakeTime;&#x2F;&#x2F; 烘焙时间</span><br><span class=\"line\">&#x2F;&#x2F; 还有等等好多好多参数，但是我只关心这些</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Cake</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 让它做自我介绍</span><br><span class=\"line\">- (NSString *)description&#123;</span><br><span class=\"line\">   return [NSString stringWithFormat:@&quot;我是一个蛋糕:奶油分量%zd 配料%@ 烘焙时间是:%zd&quot;,self.scream,self.ingredients,self.bakeTime];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>CakeStore.m 卖蛋糕的店铺</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (Cake *)createCake:(CakeBulider *)bulider</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tCake *cake &#x3D; [bulider bakeCake];</span><br><span class=\"line\">\treturn cake;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>CakeBulider.m 蛋糕自动烘焙机</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (Cake *)bakeCake</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tCake *cake &#x3D; [[Cake alloc] init];</span><br><span class=\"line\">\tcake.scream &#x3D; self.scream;</span><br><span class=\"line\">\tcake.ingredients &#x3D; self.ingredients;</span><br><span class=\"line\">\tcake.bakeTime &#x3D; self.bakeTime;</span><br><span class=\"line\">\tretrn cake;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>StrawberryCakeBulider.m 草莓蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface StrawberryCakeBulider():Cake</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self &#x3D; [super init];</span><br><span class=\"line\">    if (self) &#123;</span><br><span class=\"line\">        self.scream &#x3D; 10;</span><br><span class=\"line\">        self.ingredients &#x3D; @&quot;strawberry&quot;;</span><br><span class=\"line\">        self.bakeTime &#x3D; 10;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>BlackForestCakeBulider.m 黑森林蛋糕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface BlackForestCakeBulider():Cake</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)init</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tself &#x3D; [super init];</span><br><span class=\"line\">\tif(self)&#123;</span><br><span class=\"line\">\t\tself.scream &#x3D; 11;</span><br><span class=\"line\">\t\tself.ingredients &#x3D; @&quot;cholocate&quot;;</span><br><span class=\"line\">\t\tself.bakeTime &#x3D; 5;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>(话说大半夜的写蛋糕真的好吗)<br>其实QCCloud那个项目说不定就会用到这个模式,所以在这里稍微复习一下,回忆之前的知识.</p>\n<p>(明天再去复习别的即将会用到的设计模式)</p>"},{"title":"安装shadowsocks服务端","author":"Arclin","abbrlink":"eb81866c","date":"2018-02-18T14:15:00.000Z","_content":"安装shadowsocks服务端\n\n<!-- more -->\n\n```\nsudo yum install python-pip\nsudo pip install shadowsocks\n```\n\n配置文件\n\n```\n{\n \"server”:”172.93.xx.xx”, # 服务器IP \n \"server_port\":8388, # 端口号\n \"local_address\": \"127.0.0.1\",\n \"local_port”:1080,\n \"password\":\"gtPtAb)Wsss\", # 密码\n \"timeout\":300,\n \"method\":\"aes-256-cfb\",# 加密类型\n \"fast_open\": false\n}\n```","source":"_posts/安装shadowsocks服务端.md","raw":"---\ntitle: 安装shadowsocks服务端\nauthor: Arclin\ntags:\n  - Shadowsocks\ncategories:\n  - Linux\nabbrlink: eb81866c\ndate: 2018-02-18 22:15:00\n---\n安装shadowsocks服务端\n\n<!-- more -->\n\n```\nsudo yum install python-pip\nsudo pip install shadowsocks\n```\n\n配置文件\n\n```\n{\n \"server”:”172.93.xx.xx”, # 服务器IP \n \"server_port\":8388, # 端口号\n \"local_address\": \"127.0.0.1\",\n \"local_port”:1080,\n \"password\":\"gtPtAb)Wsss\", # 密码\n \"timeout\":300,\n \"method\":\"aes-256-cfb\",# 加密类型\n \"fast_open\": false\n}\n```","slug":"安装shadowsocks服务端","published":1,"updated":"2021-04-12T06:07:04.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog6c005e45n0ecle2brk","content":"<p>安装shadowsocks服务端</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install python-pip</span><br><span class=\"line\">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure>\n\n<p>配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> &quot;server”:”172.93.xx.xx”, # 服务器IP </span><br><span class=\"line\"> &quot;server_port&quot;:8388, # 端口号</span><br><span class=\"line\"> &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\"> &quot;local_port”:1080,</span><br><span class=\"line\"> &quot;password&quot;:&quot;gtPtAb)Wsss&quot;, # 密码</span><br><span class=\"line\"> &quot;timeout&quot;:300,</span><br><span class=\"line\"> &quot;method&quot;:&quot;aes-256-cfb&quot;,# 加密类型</span><br><span class=\"line\"> &quot;fast_open&quot;: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>安装shadowsocks服务端</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo yum install python-pip</span><br><span class=\"line\">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure>\n\n<p>配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> &quot;server”:”172.93.xx.xx”, # 服务器IP </span><br><span class=\"line\"> &quot;server_port&quot;:8388, # 端口号</span><br><span class=\"line\"> &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class=\"line\"> &quot;local_port”:1080,</span><br><span class=\"line\"> &quot;password&quot;:&quot;gtPtAb)Wsss&quot;, # 密码</span><br><span class=\"line\"> &quot;timeout&quot;:300,</span><br><span class=\"line\"> &quot;method&quot;:&quot;aes-256-cfb&quot;,# 加密类型</span><br><span class=\"line\"> &quot;fast_open&quot;: false</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"利用MJExtension取出模型数组中的某个属性组成数组","author":"Arclin","abbrlink":"8e2ebfdf","date":"2016-10-16T16:00:00.000Z","_content":"利用MJExtension取出模型数组中的某个属性组成数组\n\n<!-- more -->\n\n在做otg的时候想做这么一件事，就是遍历模型数组然后取出里面的属性值然后再保存到数组里，后来翻了翻MJExtension好像有类似的方法声明，试了一下果然可以\n\n```\nMJProperty *p = [[MJProperty alloc] init];\n[p setValue:@\"text\" forKey:@\"name\"]; \\\\ 因为name是readonly，所以我就只能用keyValue的方式去给他赋值了\nNSArray *arr = [p valueForObject:self.topics];\nNSLog(@\"%@\",arr);\n```\n\n如果包装一下大概就是这样子\n\n```\n- (NSArray *)fetchPropertys:(NSString *)propertyName fromObjects:(NSArray *)objects{\n\tMJProperty *p = [[MJProperty alloc] init];\n\t[p setValue:propertyName forKey:@\"name\"]; \n\treturn [p valueForObject:objects];\n}\n```\n\n弄个分类可能会比较方便吧\n\n```\n- (NSArray *)fetchPropertys:(NSString *)propertyName{\n\tMJProperty *p = [[MJProperty alloc] init];\n\t[p setValue:propertyName forKey:@\"name\"]; \n\treturn [p valueForObject:self];\n}\n```","source":"_posts/利用MJExtension取出模型数组中的某个属性组成数组.md","raw":"---\ntitle: 利用MJExtension取出模型数组中的某个属性组成数组\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 8e2ebfdf\ndate: 2016-10-17 00:00:00\n---\n利用MJExtension取出模型数组中的某个属性组成数组\n\n<!-- more -->\n\n在做otg的时候想做这么一件事，就是遍历模型数组然后取出里面的属性值然后再保存到数组里，后来翻了翻MJExtension好像有类似的方法声明，试了一下果然可以\n\n```\nMJProperty *p = [[MJProperty alloc] init];\n[p setValue:@\"text\" forKey:@\"name\"]; \\\\ 因为name是readonly，所以我就只能用keyValue的方式去给他赋值了\nNSArray *arr = [p valueForObject:self.topics];\nNSLog(@\"%@\",arr);\n```\n\n如果包装一下大概就是这样子\n\n```\n- (NSArray *)fetchPropertys:(NSString *)propertyName fromObjects:(NSArray *)objects{\n\tMJProperty *p = [[MJProperty alloc] init];\n\t[p setValue:propertyName forKey:@\"name\"]; \n\treturn [p valueForObject:objects];\n}\n```\n\n弄个分类可能会比较方便吧\n\n```\n- (NSArray *)fetchPropertys:(NSString *)propertyName{\n\tMJProperty *p = [[MJProperty alloc] init];\n\t[p setValue:propertyName forKey:@\"name\"]; \n\treturn [p valueForObject:self];\n}\n```","slug":"利用MJExtension取出模型数组中的某个属性组成数组","published":1,"updated":"2021-04-12T06:07:04.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog6h005i45n08ock0m6i","content":"<p>利用MJExtension取出模型数组中的某个属性组成数组</p>\n<span id=\"more\"></span>\n\n<p>在做otg的时候想做这么一件事，就是遍历模型数组然后取出里面的属性值然后再保存到数组里，后来翻了翻MJExtension好像有类似的方法声明，试了一下果然可以</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MJProperty *p &#x3D; [[MJProperty alloc] init];</span><br><span class=\"line\">[p setValue:@&quot;text&quot; forKey:@&quot;name&quot;]; \\\\ 因为name是readonly，所以我就只能用keyValue的方式去给他赋值了</span><br><span class=\"line\">NSArray *arr &#x3D; [p valueForObject:self.topics];</span><br><span class=\"line\">NSLog(@&quot;%@&quot;,arr);</span><br></pre></td></tr></table></figure>\n\n<p>如果包装一下大概就是这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)fetchPropertys:(NSString *)propertyName fromObjects:(NSArray *)objects&#123;</span><br><span class=\"line\">\tMJProperty *p &#x3D; [[MJProperty alloc] init];</span><br><span class=\"line\">\t[p setValue:propertyName forKey:@&quot;name&quot;]; </span><br><span class=\"line\">\treturn [p valueForObject:objects];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>弄个分类可能会比较方便吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)fetchPropertys:(NSString *)propertyName&#123;</span><br><span class=\"line\">\tMJProperty *p &#x3D; [[MJProperty alloc] init];</span><br><span class=\"line\">\t[p setValue:propertyName forKey:@&quot;name&quot;]; </span><br><span class=\"line\">\treturn [p valueForObject:self];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>利用MJExtension取出模型数组中的某个属性组成数组</p>","more":"<p>在做otg的时候想做这么一件事，就是遍历模型数组然后取出里面的属性值然后再保存到数组里，后来翻了翻MJExtension好像有类似的方法声明，试了一下果然可以</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MJProperty *p &#x3D; [[MJProperty alloc] init];</span><br><span class=\"line\">[p setValue:@&quot;text&quot; forKey:@&quot;name&quot;]; \\\\ 因为name是readonly，所以我就只能用keyValue的方式去给他赋值了</span><br><span class=\"line\">NSArray *arr &#x3D; [p valueForObject:self.topics];</span><br><span class=\"line\">NSLog(@&quot;%@&quot;,arr);</span><br></pre></td></tr></table></figure>\n\n<p>如果包装一下大概就是这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)fetchPropertys:(NSString *)propertyName fromObjects:(NSArray *)objects&#123;</span><br><span class=\"line\">\tMJProperty *p &#x3D; [[MJProperty alloc] init];</span><br><span class=\"line\">\t[p setValue:propertyName forKey:@&quot;name&quot;]; </span><br><span class=\"line\">\treturn [p valueForObject:objects];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>弄个分类可能会比较方便吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)fetchPropertys:(NSString *)propertyName&#123;</span><br><span class=\"line\">\tMJProperty *p &#x3D; [[MJProperty alloc] init];</span><br><span class=\"line\">\t[p setValue:propertyName forKey:@&quot;name&quot;]; </span><br><span class=\"line\">\treturn [p valueForObject:self];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"用flow.ci做iOS的持续化集成","author":"Arclin","abbrlink":"2281692e","date":"2017-02-23T16:00:00.000Z","_content":"听说flow.ci上线公测了,赶紧拿着一把限时免费资格玩一玩体验一下.\n\n<!-- more -->\n\n结论: 一套下来行云流水,配置上基本没啥大问题,感觉还是挺好用的.可以支持简单的项目\n\n官方中文文档在这里\n\n里面讲的相当详细,在这里我就讲点注意点就好\n\n1. 如果你想达到的功能除了编译打包外,还想上传到fir,并且想拿最新的git commit 信息作为fir版本更新备注,那么你的工作流可以这么配\n![](https://github.com/Arc-lin/BlogImage/blob/master/1012.png?raw=true)\n2. ‘自定义脚本’里面写的是export CHANGE_LOG=$(git log --pretty=format:\"%s\" -1 $describe) 然后 fir.im 上传插件 中 FIR_CHANGELOG就直接写$CHANGE_LOG这样子就可以做到拿最新的git commit 信息作为fir版本更新备注, $FIR_APP_PATH里面就直接写$FIR_APP_PATH就好了\n3. ‘缓存’那里启用一下安装速度会快些\n4. 如果你的git的根目录不是你项目的根目录的话,你要添加一个’环境变量’(就像上面的图),详情看这里\n5. ‘编译’那里的’Workspace’,填的时候记得把’.xcworkspace’后缀带上\n6. ‘编译’那里的’Workspace’和’Project’两个选一个填,不能一起填\n7. 大概就这么多,以后我遇到啥再补充","source":"_posts/用flow-ci做iOS的持续化集成.md","raw":"---\ntitle: 用flow.ci做iOS的持续化集成\nauthor: Arclin\ntags:\n  - Flow.ci\n  - iOS\ncategories:\n  - iOS\nabbrlink: 2281692e\ndate: 2017-02-24 00:00:00\n---\n听说flow.ci上线公测了,赶紧拿着一把限时免费资格玩一玩体验一下.\n\n<!-- more -->\n\n结论: 一套下来行云流水,配置上基本没啥大问题,感觉还是挺好用的.可以支持简单的项目\n\n官方中文文档在这里\n\n里面讲的相当详细,在这里我就讲点注意点就好\n\n1. 如果你想达到的功能除了编译打包外,还想上传到fir,并且想拿最新的git commit 信息作为fir版本更新备注,那么你的工作流可以这么配\n![](https://github.com/Arc-lin/BlogImage/blob/master/1012.png?raw=true)\n2. ‘自定义脚本’里面写的是export CHANGE_LOG=$(git log --pretty=format:\"%s\" -1 $describe) 然后 fir.im 上传插件 中 FIR_CHANGELOG就直接写$CHANGE_LOG这样子就可以做到拿最新的git commit 信息作为fir版本更新备注, $FIR_APP_PATH里面就直接写$FIR_APP_PATH就好了\n3. ‘缓存’那里启用一下安装速度会快些\n4. 如果你的git的根目录不是你项目的根目录的话,你要添加一个’环境变量’(就像上面的图),详情看这里\n5. ‘编译’那里的’Workspace’,填的时候记得把’.xcworkspace’后缀带上\n6. ‘编译’那里的’Workspace’和’Project’两个选一个填,不能一起填\n7. 大概就这么多,以后我遇到啥再补充","slug":"用flow-ci做iOS的持续化集成","published":1,"updated":"2021-04-12T06:07:04.041Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog6j005l45n012vud8j3","content":"<p>听说flow.ci上线公测了,赶紧拿着一把限时免费资格玩一玩体验一下.</p>\n<span id=\"more\"></span>\n\n<p>结论: 一套下来行云流水,配置上基本没啥大问题,感觉还是挺好用的.可以支持简单的项目</p>\n<p>官方中文文档在这里</p>\n<p>里面讲的相当详细,在这里我就讲点注意点就好</p>\n<ol>\n<li>如果你想达到的功能除了编译打包外,还想上传到fir,并且想拿最新的git commit 信息作为fir版本更新备注,那么你的工作流可以这么配<br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/1012.png?raw=true\"></li>\n<li>‘自定义脚本’里面写的是export CHANGE_LOG=$(git log –pretty=format:”%s” -1 $describe) 然后 fir.im 上传插件 中 FIR_CHANGELOG就直接写$CHANGE_LOG这样子就可以做到拿最新的git commit 信息作为fir版本更新备注, $FIR_APP_PATH里面就直接写$FIR_APP_PATH就好了</li>\n<li>‘缓存’那里启用一下安装速度会快些</li>\n<li>如果你的git的根目录不是你项目的根目录的话,你要添加一个’环境变量’(就像上面的图),详情看这里</li>\n<li>‘编译’那里的’Workspace’,填的时候记得把’.xcworkspace’后缀带上</li>\n<li>‘编译’那里的’Workspace’和’Project’两个选一个填,不能一起填</li>\n<li>大概就这么多,以后我遇到啥再补充</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>听说flow.ci上线公测了,赶紧拿着一把限时免费资格玩一玩体验一下.</p>","more":"<p>结论: 一套下来行云流水,配置上基本没啥大问题,感觉还是挺好用的.可以支持简单的项目</p>\n<p>官方中文文档在这里</p>\n<p>里面讲的相当详细,在这里我就讲点注意点就好</p>\n<ol>\n<li>如果你想达到的功能除了编译打包外,还想上传到fir,并且想拿最新的git commit 信息作为fir版本更新备注,那么你的工作流可以这么配<br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/1012.png?raw=true\"></li>\n<li>‘自定义脚本’里面写的是export CHANGE_LOG=$(git log –pretty=format:”%s” -1 $describe) 然后 fir.im 上传插件 中 FIR_CHANGELOG就直接写$CHANGE_LOG这样子就可以做到拿最新的git commit 信息作为fir版本更新备注, $FIR_APP_PATH里面就直接写$FIR_APP_PATH就好了</li>\n<li>‘缓存’那里启用一下安装速度会快些</li>\n<li>如果你的git的根目录不是你项目的根目录的话,你要添加一个’环境变量’(就像上面的图),详情看这里</li>\n<li>‘编译’那里的’Workspace’,填的时候记得把’.xcworkspace’后缀带上</li>\n<li>‘编译’那里的’Workspace’和’Project’两个选一个填,不能一起填</li>\n<li>大概就这么多,以后我遇到啥再补充</li>\n</ol>"},{"title":"用Swift的框架Vapor写服务端初体验","author":"Arclin","abbrlink":"73291e5a","date":"2017-03-15T16:00:00.000Z","_content":"咦? 用Swift写后端? 一开始听到的时候懵逼了一秒,一秒自后想了想感觉也没毛病,那就试试看咯.(没看WWDC的后果)\n\n<!-- more -->\n\n## 安装Vapor\n\n`curl -sL toolbox.vapor.sh | bash`\n\n## 创建项目\n\n`vapor new Hello --template=light`\n\n`--template=light` 意思是使用light-template模板,如果不指定模板的话默认使用base-template模板\n\n下载依赖并编译项目\n`vapor build`\n\n50多M的包,好久…\n\n配置服务器\n创建Config文件夹,新建servers.json文件, 指定host地址和端口号\n\n```\n{\n  \"http\": {\n    \"host\": \"0.0.0.0\",\n    \"port\": 8000\n  }\n}\n```\n\n`0.0.0.0` 和 `127.0.0.1` 都表示本机，使用 `0.0.0.0` 的原因是，一个机器可能有多个 IP 地址，`0.0.0.0` 表示监听每个 IP `8000` 端口收到的请求。\n\n`127.0.0.1` 则表示只接受本机发给本机的请求，从网络上其他电脑发过来的请求，不论是请求的哪个 IP，都是不被处理的。\n\n## 打包成一个XCode项目\n`vapor xcode -y` 这样子打包之后就会自动打开了\n\n## 启动服务器\n`vapor run` 或者在XCode运行\n\n看到了控制台输出了\n\n```\nNo command supplied, defaulting to serve...\nNo preparations.\nServer 'http' starting at 0.0.0.0:8000\n```\n\n就可以了\n\n如果说什么`Can not bind to xxxx` 就应该是端口占用的问题,可以用`lsof -i tcp:端口号` 和 `kill -9` 端口号解决这个问题\n\n如果你在浏览器输入`http://localhost:8000`可以看到以下信息就证明服务器启动成功了\n\n```\nRequest  \n- GET / HTTP/1.1\n- Headers:\n    Host: 0.0.0.0:8000\n    Upgrade-Insecure-Requests: 1\n    Connection: keep-alive\n    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36\n    Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2\n    Accept-Encoding: gzip, deflate, sdch\n    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n- Body:\n```\n\n会出现这串东西是因为他执行了`Sources/App/main.swift`的内容,把请求体返回回来.\n\n修改`Sources/App/main.swift`\n把文件改成这样子\n\n```\nimport Vapor\n\nlet drop = Droplet()\n\ndrop.get { _ in\n    return try JSON(node: [\n            \"message\":\"Hello Vapor\"\n        ])\n}\n\ndrop.get(\"Hello\",\"There\") { request in\n    return try JSON (node:[\n            \"message\":\"Hello There\"\n        ])\n}\n\ndrop.get(\"TEST\") { request in\n    return try JSON (node:[\n            \"message\":\"Hello Test\"\n        ])\n}\n\ndrop.run()\n```\n\n然后我们使用Postman测试一下三个地址\n\n`http://localhost:8000/`\n\n![WX20170316-105233@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe803b931.png)\n\n`http://localhost:8000/Hello/There\n\n![WX20170316-105315@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe7f92afc.png)\n\n`http://localhost:8000/TEST`\n\n![WX20170316-105336@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe7fca399.png)\n\n接下来试试接受参数并返回\n\n继续在`drop.run()` 上面补充\n\n```\ndrop.post(\"post\") { request in\n    guard let name = request.data[\"name\"]?.string else {\n        throw Abort.badRequest\n    }\n    return try JSON(node: [\n        \"name\": \"Hello \\(name)!\"\n        ])\n}\n```\n\n> guard近似的看做是Assert，但是你可以优雅的退出而非崩溃。\n\n判断如果没有接收到’name’参数的话就会抛出异常Invalid request,有的话就返回Hello + 参数值 + !\n\n测试一下\n\n![WX20170316-110133@2x.png](https://ooo.0o0.ooo/2017/03/16/58ca001f306a5.png)\n\n部署服务器\nVapor支持Heroku,Ubuntu,Digital Ocean,AWS等等服务器,具体怎么做我还没试过,有时间再去试试看\n\n为什么要用Swift写服务器?\n额,看了一下资料,也没发现有谁说这东西有什么特别突出的优点,不过没试过,觉得挺新鲜,就试试嘛.\n\n> 学习资料 :\n\n> [服务端 Swift - Vapor 篇 （一）](http://www.jianshu.com/p/3fc28570d951)\n\n> [用 Swift 的框架 Vapor 写服务器这事儿怎么样？](http://tips.producter.io/yong-swift-de-kuang-jia-vapor-xie-fu-wu-qi-zhe-shi-er-zen-yao-yang/)","source":"_posts/用Swift的框架Vapor写服务端初体验.md","raw":"---\ntitle: 用Swift的框架Vapor写服务端初体验\nauthor: Arclin\ntags:\n  - Swift\ncategories:\n  - Swift\nabbrlink: 73291e5a\ndate: 2017-03-16 00:00:00\n---\n咦? 用Swift写后端? 一开始听到的时候懵逼了一秒,一秒自后想了想感觉也没毛病,那就试试看咯.(没看WWDC的后果)\n\n<!-- more -->\n\n## 安装Vapor\n\n`curl -sL toolbox.vapor.sh | bash`\n\n## 创建项目\n\n`vapor new Hello --template=light`\n\n`--template=light` 意思是使用light-template模板,如果不指定模板的话默认使用base-template模板\n\n下载依赖并编译项目\n`vapor build`\n\n50多M的包,好久…\n\n配置服务器\n创建Config文件夹,新建servers.json文件, 指定host地址和端口号\n\n```\n{\n  \"http\": {\n    \"host\": \"0.0.0.0\",\n    \"port\": 8000\n  }\n}\n```\n\n`0.0.0.0` 和 `127.0.0.1` 都表示本机，使用 `0.0.0.0` 的原因是，一个机器可能有多个 IP 地址，`0.0.0.0` 表示监听每个 IP `8000` 端口收到的请求。\n\n`127.0.0.1` 则表示只接受本机发给本机的请求，从网络上其他电脑发过来的请求，不论是请求的哪个 IP，都是不被处理的。\n\n## 打包成一个XCode项目\n`vapor xcode -y` 这样子打包之后就会自动打开了\n\n## 启动服务器\n`vapor run` 或者在XCode运行\n\n看到了控制台输出了\n\n```\nNo command supplied, defaulting to serve...\nNo preparations.\nServer 'http' starting at 0.0.0.0:8000\n```\n\n就可以了\n\n如果说什么`Can not bind to xxxx` 就应该是端口占用的问题,可以用`lsof -i tcp:端口号` 和 `kill -9` 端口号解决这个问题\n\n如果你在浏览器输入`http://localhost:8000`可以看到以下信息就证明服务器启动成功了\n\n```\nRequest  \n- GET / HTTP/1.1\n- Headers:\n    Host: 0.0.0.0:8000\n    Upgrade-Insecure-Requests: 1\n    Connection: keep-alive\n    User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36\n    Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4,zh-TW;q=0.2\n    Accept-Encoding: gzip, deflate, sdch\n    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\n- Body:\n```\n\n会出现这串东西是因为他执行了`Sources/App/main.swift`的内容,把请求体返回回来.\n\n修改`Sources/App/main.swift`\n把文件改成这样子\n\n```\nimport Vapor\n\nlet drop = Droplet()\n\ndrop.get { _ in\n    return try JSON(node: [\n            \"message\":\"Hello Vapor\"\n        ])\n}\n\ndrop.get(\"Hello\",\"There\") { request in\n    return try JSON (node:[\n            \"message\":\"Hello There\"\n        ])\n}\n\ndrop.get(\"TEST\") { request in\n    return try JSON (node:[\n            \"message\":\"Hello Test\"\n        ])\n}\n\ndrop.run()\n```\n\n然后我们使用Postman测试一下三个地址\n\n`http://localhost:8000/`\n\n![WX20170316-105233@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe803b931.png)\n\n`http://localhost:8000/Hello/There\n\n![WX20170316-105315@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe7f92afc.png)\n\n`http://localhost:8000/TEST`\n\n![WX20170316-105336@2x.png](https://ooo.0o0.ooo/2017/03/16/58c9fe7fca399.png)\n\n接下来试试接受参数并返回\n\n继续在`drop.run()` 上面补充\n\n```\ndrop.post(\"post\") { request in\n    guard let name = request.data[\"name\"]?.string else {\n        throw Abort.badRequest\n    }\n    return try JSON(node: [\n        \"name\": \"Hello \\(name)!\"\n        ])\n}\n```\n\n> guard近似的看做是Assert，但是你可以优雅的退出而非崩溃。\n\n判断如果没有接收到’name’参数的话就会抛出异常Invalid request,有的话就返回Hello + 参数值 + !\n\n测试一下\n\n![WX20170316-110133@2x.png](https://ooo.0o0.ooo/2017/03/16/58ca001f306a5.png)\n\n部署服务器\nVapor支持Heroku,Ubuntu,Digital Ocean,AWS等等服务器,具体怎么做我还没试过,有时间再去试试看\n\n为什么要用Swift写服务器?\n额,看了一下资料,也没发现有谁说这东西有什么特别突出的优点,不过没试过,觉得挺新鲜,就试试嘛.\n\n> 学习资料 :\n\n> [服务端 Swift - Vapor 篇 （一）](http://www.jianshu.com/p/3fc28570d951)\n\n> [用 Swift 的框架 Vapor 写服务器这事儿怎么样？](http://tips.producter.io/yong-swift-de-kuang-jia-vapor-xie-fu-wu-qi-zhe-shi-er-zen-yao-yang/)","slug":"用Swift的框架Vapor写服务端初体验","published":1,"updated":"2021-04-12T06:07:04.041Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog6j005p45n049ya1f6q","content":"<p>咦? 用Swift写后端? 一开始听到的时候懵逼了一秒,一秒自后想了想感觉也没毛病,那就试试看咯.(没看WWDC的后果)</p>\n<span id=\"more\"></span>\n\n<h2 id=\"安装Vapor\"><a href=\"#安装Vapor\" class=\"headerlink\" title=\"安装Vapor\"></a>安装Vapor</h2><p><code>curl -sL toolbox.vapor.sh | bash</code></p>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><p><code>vapor new Hello --template=light</code></p>\n<p><code>--template=light</code> 意思是使用light-template模板,如果不指定模板的话默认使用base-template模板</p>\n<p>下载依赖并编译项目<br><code>vapor build</code></p>\n<p>50多M的包,好久…</p>\n<p>配置服务器<br>创建Config文件夹,新建servers.json文件, 指定host地址和端口号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;http&quot;: &#123;</span><br><span class=\"line\">    &quot;host&quot;: &quot;0.0.0.0&quot;,</span><br><span class=\"line\">    &quot;port&quot;: 8000</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>0.0.0.0</code> 和 <code>127.0.0.1</code> 都表示本机，使用 <code>0.0.0.0</code> 的原因是，一个机器可能有多个 IP 地址，<code>0.0.0.0</code> 表示监听每个 IP <code>8000</code> 端口收到的请求。</p>\n<p><code>127.0.0.1</code> 则表示只接受本机发给本机的请求，从网络上其他电脑发过来的请求，不论是请求的哪个 IP，都是不被处理的。</p>\n<h2 id=\"打包成一个XCode项目\"><a href=\"#打包成一个XCode项目\" class=\"headerlink\" title=\"打包成一个XCode项目\"></a>打包成一个XCode项目</h2><p><code>vapor xcode -y</code> 这样子打包之后就会自动打开了</p>\n<h2 id=\"启动服务器\"><a href=\"#启动服务器\" class=\"headerlink\" title=\"启动服务器\"></a>启动服务器</h2><p><code>vapor run</code> 或者在XCode运行</p>\n<p>看到了控制台输出了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No command supplied, defaulting to serve...</span><br><span class=\"line\">No preparations.</span><br><span class=\"line\">Server &#39;http&#39; starting at 0.0.0.0:8000</span><br></pre></td></tr></table></figure>\n\n<p>就可以了</p>\n<p>如果说什么<code>Can not bind to xxxx</code> 就应该是端口占用的问题,可以用<code>lsof -i tcp:端口号</code> 和 <code>kill -9</code> 端口号解决这个问题</p>\n<p>如果你在浏览器输入<code>http://localhost:8000</code>可以看到以下信息就证明服务器启动成功了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Request  </span><br><span class=\"line\">- GET &#x2F; HTTP&#x2F;1.1</span><br><span class=\"line\">- Headers:</span><br><span class=\"line\">    Host: 0.0.0.0:8000</span><br><span class=\"line\">    Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">    Connection: keep-alive</span><br><span class=\"line\">    User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;57.0.2987.98 Safari&#x2F;537.36</span><br><span class=\"line\">    Accept-Language: en-US,en;q&#x3D;0.8,zh-CN;q&#x3D;0.6,zh;q&#x3D;0.4,zh-TW;q&#x3D;0.2</span><br><span class=\"line\">    Accept-Encoding: gzip, deflate, sdch</span><br><span class=\"line\">    Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8</span><br><span class=\"line\">- Body:</span><br></pre></td></tr></table></figure>\n\n<p>会出现这串东西是因为他执行了<code>Sources/App/main.swift</code>的内容,把请求体返回回来.</p>\n<p>修改<code>Sources/App/main.swift</code><br>把文件改成这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vapor</span><br><span class=\"line\"></span><br><span class=\"line\">let drop &#x3D; Droplet()</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get &#123; _ in</span><br><span class=\"line\">    return try JSON(node: [</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello Vapor&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get(&quot;Hello&quot;,&quot;There&quot;) &#123; request in</span><br><span class=\"line\">    return try JSON (node:[</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello There&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get(&quot;TEST&quot;) &#123; request in</span><br><span class=\"line\">    return try JSON (node:[</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello Test&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.run()</span><br></pre></td></tr></table></figure>\n\n<p>然后我们使用Postman测试一下三个地址</p>\n<p><code>http://localhost:8000/</code></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe803b931.png\" alt=\"WX20170316-105233@2x.png\"></p>\n<p>`<a href=\"http://localhost:8000/Hello/There\">http://localhost:8000/Hello/There</a></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe7f92afc.png\" alt=\"WX20170316-105315@2x.png\"></p>\n<p><code>http://localhost:8000/TEST</code></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe7fca399.png\" alt=\"WX20170316-105336@2x.png\"></p>\n<p>接下来试试接受参数并返回</p>\n<p>继续在<code>drop.run()</code> 上面补充</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drop.post(&quot;post&quot;) &#123; request in</span><br><span class=\"line\">    guard let name &#x3D; request.data[&quot;name&quot;]?.string else &#123;</span><br><span class=\"line\">        throw Abort.badRequest</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return try JSON(node: [</span><br><span class=\"line\">        &quot;name&quot;: &quot;Hello \\(name)!&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>guard近似的看做是Assert，但是你可以优雅的退出而非崩溃。</p>\n</blockquote>\n<p>判断如果没有接收到’name’参数的话就会抛出异常Invalid request,有的话就返回Hello + 参数值 + !</p>\n<p>测试一下</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58ca001f306a5.png\" alt=\"WX20170316-110133@2x.png\"></p>\n<p>部署服务器<br>Vapor支持Heroku,Ubuntu,Digital Ocean,AWS等等服务器,具体怎么做我还没试过,有时间再去试试看</p>\n<p>为什么要用Swift写服务器?<br>额,看了一下资料,也没发现有谁说这东西有什么特别突出的优点,不过没试过,觉得挺新鲜,就试试嘛.</p>\n<blockquote>\n<p>学习资料 :</p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://www.jianshu.com/p/3fc28570d951\">服务端 Swift - Vapor 篇 （一）</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://tips.producter.io/yong-swift-de-kuang-jia-vapor-xie-fu-wu-qi-zhe-shi-er-zen-yao-yang/\">用 Swift 的框架 Vapor 写服务器这事儿怎么样？</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>咦? 用Swift写后端? 一开始听到的时候懵逼了一秒,一秒自后想了想感觉也没毛病,那就试试看咯.(没看WWDC的后果)</p>","more":"<h2 id=\"安装Vapor\"><a href=\"#安装Vapor\" class=\"headerlink\" title=\"安装Vapor\"></a>安装Vapor</h2><p><code>curl -sL toolbox.vapor.sh | bash</code></p>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><p><code>vapor new Hello --template=light</code></p>\n<p><code>--template=light</code> 意思是使用light-template模板,如果不指定模板的话默认使用base-template模板</p>\n<p>下载依赖并编译项目<br><code>vapor build</code></p>\n<p>50多M的包,好久…</p>\n<p>配置服务器<br>创建Config文件夹,新建servers.json文件, 指定host地址和端口号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;http&quot;: &#123;</span><br><span class=\"line\">    &quot;host&quot;: &quot;0.0.0.0&quot;,</span><br><span class=\"line\">    &quot;port&quot;: 8000</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>0.0.0.0</code> 和 <code>127.0.0.1</code> 都表示本机，使用 <code>0.0.0.0</code> 的原因是，一个机器可能有多个 IP 地址，<code>0.0.0.0</code> 表示监听每个 IP <code>8000</code> 端口收到的请求。</p>\n<p><code>127.0.0.1</code> 则表示只接受本机发给本机的请求，从网络上其他电脑发过来的请求，不论是请求的哪个 IP，都是不被处理的。</p>\n<h2 id=\"打包成一个XCode项目\"><a href=\"#打包成一个XCode项目\" class=\"headerlink\" title=\"打包成一个XCode项目\"></a>打包成一个XCode项目</h2><p><code>vapor xcode -y</code> 这样子打包之后就会自动打开了</p>\n<h2 id=\"启动服务器\"><a href=\"#启动服务器\" class=\"headerlink\" title=\"启动服务器\"></a>启动服务器</h2><p><code>vapor run</code> 或者在XCode运行</p>\n<p>看到了控制台输出了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">No command supplied, defaulting to serve...</span><br><span class=\"line\">No preparations.</span><br><span class=\"line\">Server &#39;http&#39; starting at 0.0.0.0:8000</span><br></pre></td></tr></table></figure>\n\n<p>就可以了</p>\n<p>如果说什么<code>Can not bind to xxxx</code> 就应该是端口占用的问题,可以用<code>lsof -i tcp:端口号</code> 和 <code>kill -9</code> 端口号解决这个问题</p>\n<p>如果你在浏览器输入<code>http://localhost:8000</code>可以看到以下信息就证明服务器启动成功了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Request  </span><br><span class=\"line\">- GET &#x2F; HTTP&#x2F;1.1</span><br><span class=\"line\">- Headers:</span><br><span class=\"line\">    Host: 0.0.0.0:8000</span><br><span class=\"line\">    Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">    Connection: keep-alive</span><br><span class=\"line\">    User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;57.0.2987.98 Safari&#x2F;537.36</span><br><span class=\"line\">    Accept-Language: en-US,en;q&#x3D;0.8,zh-CN;q&#x3D;0.6,zh;q&#x3D;0.4,zh-TW;q&#x3D;0.2</span><br><span class=\"line\">    Accept-Encoding: gzip, deflate, sdch</span><br><span class=\"line\">    Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8</span><br><span class=\"line\">- Body:</span><br></pre></td></tr></table></figure>\n\n<p>会出现这串东西是因为他执行了<code>Sources/App/main.swift</code>的内容,把请求体返回回来.</p>\n<p>修改<code>Sources/App/main.swift</code><br>把文件改成这样子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vapor</span><br><span class=\"line\"></span><br><span class=\"line\">let drop &#x3D; Droplet()</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get &#123; _ in</span><br><span class=\"line\">    return try JSON(node: [</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello Vapor&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get(&quot;Hello&quot;,&quot;There&quot;) &#123; request in</span><br><span class=\"line\">    return try JSON (node:[</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello There&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.get(&quot;TEST&quot;) &#123; request in</span><br><span class=\"line\">    return try JSON (node:[</span><br><span class=\"line\">            &quot;message&quot;:&quot;Hello Test&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drop.run()</span><br></pre></td></tr></table></figure>\n\n<p>然后我们使用Postman测试一下三个地址</p>\n<p><code>http://localhost:8000/</code></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe803b931.png\" alt=\"WX20170316-105233@2x.png\"></p>\n<p>`<a href=\"http://localhost:8000/Hello/There\">http://localhost:8000/Hello/There</a></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe7f92afc.png\" alt=\"WX20170316-105315@2x.png\"></p>\n<p><code>http://localhost:8000/TEST</code></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58c9fe7fca399.png\" alt=\"WX20170316-105336@2x.png\"></p>\n<p>接下来试试接受参数并返回</p>\n<p>继续在<code>drop.run()</code> 上面补充</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drop.post(&quot;post&quot;) &#123; request in</span><br><span class=\"line\">    guard let name &#x3D; request.data[&quot;name&quot;]?.string else &#123;</span><br><span class=\"line\">        throw Abort.badRequest</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return try JSON(node: [</span><br><span class=\"line\">        &quot;name&quot;: &quot;Hello \\(name)!&quot;</span><br><span class=\"line\">        ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>guard近似的看做是Assert，但是你可以优雅的退出而非崩溃。</p>\n</blockquote>\n<p>判断如果没有接收到’name’参数的话就会抛出异常Invalid request,有的话就返回Hello + 参数值 + !</p>\n<p>测试一下</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/03/16/58ca001f306a5.png\" alt=\"WX20170316-110133@2x.png\"></p>\n<p>部署服务器<br>Vapor支持Heroku,Ubuntu,Digital Ocean,AWS等等服务器,具体怎么做我还没试过,有时间再去试试看</p>\n<p>为什么要用Swift写服务器?<br>额,看了一下资料,也没发现有谁说这东西有什么特别突出的优点,不过没试过,觉得挺新鲜,就试试嘛.</p>\n<blockquote>\n<p>学习资料 :</p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://www.jianshu.com/p/3fc28570d951\">服务端 Swift - Vapor 篇 （一）</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://tips.producter.io/yong-swift-de-kuang-jia-vapor-xie-fu-wu-qi-zhe-shi-er-zen-yao-yang/\">用 Swift 的框架 Vapor 写服务器这事儿怎么样？</a></p>\n</blockquote>"},{"title":"简易架构设计","author":"Arclin","abbrlink":"4948514e","date":"2016-10-28T16:00:00.000Z","_content":"### 继承关系：\n- UIViewController\n\n\t- DKViewContrller\n\n\t\t- DKLoginBaseViewCotroller\n\n\t\t\t- DKLoginViewController\n\t\t\t- DKRegisterViewController\n\t\t\t- DKFoundPswViewController\n\t\t- DKModuleABaseViewCotroller\n\t\t\t- DKAViewController\n\t\t- DKModuleBBaseViewCotroller\n\t\t\t- DKBViewController\n\n### 常量配置\n\n - DKLoginBaseViewController : DKLoginConfig.h\n\n - DKLoginConfig 里面定义常量\n\n\t相关的常量使用UIKIT_EXTERN / FOUNDATION_EXTERA，并且UIKIT_EXTERN / FOUNDATION_EXTERA建议写在模块外的全局DKConfig.h(会在pch里引入)\n - ps: pch建议只写宏，宏之外的其他东西，写在DKConfig.h里面，然后导入pch\n\n - DKModuelABaseViewController : DKModuelAConfig.h\n\n### 调用(import)\n\n```\nDKHomeViewController\n    |-DKLoginViewController\n        |-DKRegisterViewController\n        |-DKLoginBaseViewController\n            |—DKViewController\n                |_ UIKit\n```","source":"_posts/简易架构设计.md","raw":"---\ntitle: 简易架构设计\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 4948514e\ndate: 2016-10-29 00:00:00\n---\n### 继承关系：\n- UIViewController\n\n\t- DKViewContrller\n\n\t\t- DKLoginBaseViewCotroller\n\n\t\t\t- DKLoginViewController\n\t\t\t- DKRegisterViewController\n\t\t\t- DKFoundPswViewController\n\t\t- DKModuleABaseViewCotroller\n\t\t\t- DKAViewController\n\t\t- DKModuleBBaseViewCotroller\n\t\t\t- DKBViewController\n\n### 常量配置\n\n - DKLoginBaseViewController : DKLoginConfig.h\n\n - DKLoginConfig 里面定义常量\n\n\t相关的常量使用UIKIT_EXTERN / FOUNDATION_EXTERA，并且UIKIT_EXTERN / FOUNDATION_EXTERA建议写在模块外的全局DKConfig.h(会在pch里引入)\n - ps: pch建议只写宏，宏之外的其他东西，写在DKConfig.h里面，然后导入pch\n\n - DKModuelABaseViewController : DKModuelAConfig.h\n\n### 调用(import)\n\n```\nDKHomeViewController\n    |-DKLoginViewController\n        |-DKRegisterViewController\n        |-DKLoginBaseViewController\n            |—DKViewController\n                |_ UIKit\n```","slug":"简易架构设计","published":1,"updated":"2021-04-12T06:07:04.041Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog6k005s45n07hfnacyf","content":"<h3 id=\"继承关系：\"><a href=\"#继承关系：\" class=\"headerlink\" title=\"继承关系：\"></a>继承关系：</h3><ul>\n<li><p>UIViewController</p>\n<ul>\n<li><p>DKViewContrller</p>\n<ul>\n<li><p>DKLoginBaseViewCotroller</p>\n<ul>\n<li>DKLoginViewController</li>\n<li>DKRegisterViewController</li>\n<li>DKFoundPswViewController</li>\n</ul>\n</li>\n<li><p>DKModuleABaseViewCotroller</p>\n<ul>\n<li>DKAViewController</li>\n</ul>\n</li>\n<li><p>DKModuleBBaseViewCotroller</p>\n<ul>\n<li>DKBViewController</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常量配置\"><a href=\"#常量配置\" class=\"headerlink\" title=\"常量配置\"></a>常量配置</h3><ul>\n<li><p>DKLoginBaseViewController : DKLoginConfig.h</p>\n</li>\n<li><p>DKLoginConfig 里面定义常量</p>\n<p> 相关的常量使用UIKIT_EXTERN / FOUNDATION_EXTERA，并且UIKIT_EXTERN / FOUNDATION_EXTERA建议写在模块外的全局DKConfig.h(会在pch里引入)</p>\n</li>\n<li><p>ps: pch建议只写宏，宏之外的其他东西，写在DKConfig.h里面，然后导入pch</p>\n</li>\n<li><p>DKModuelABaseViewController : DKModuelAConfig.h</p>\n</li>\n</ul>\n<h3 id=\"调用-import\"><a href=\"#调用-import\" class=\"headerlink\" title=\"调用(import)\"></a>调用(import)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHomeViewController</span><br><span class=\"line\">    |-DKLoginViewController</span><br><span class=\"line\">        |-DKRegisterViewController</span><br><span class=\"line\">        |-DKLoginBaseViewController</span><br><span class=\"line\">            |—DKViewController</span><br><span class=\"line\">                |_ UIKit</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"继承关系：\"><a href=\"#继承关系：\" class=\"headerlink\" title=\"继承关系：\"></a>继承关系：</h3><ul>\n<li><p>UIViewController</p>\n<ul>\n<li><p>DKViewContrller</p>\n<ul>\n<li><p>DKLoginBaseViewCotroller</p>\n<ul>\n<li>DKLoginViewController</li>\n<li>DKRegisterViewController</li>\n<li>DKFoundPswViewController</li>\n</ul>\n</li>\n<li><p>DKModuleABaseViewCotroller</p>\n<ul>\n<li>DKAViewController</li>\n</ul>\n</li>\n<li><p>DKModuleBBaseViewCotroller</p>\n<ul>\n<li>DKBViewController</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常量配置\"><a href=\"#常量配置\" class=\"headerlink\" title=\"常量配置\"></a>常量配置</h3><ul>\n<li><p>DKLoginBaseViewController : DKLoginConfig.h</p>\n</li>\n<li><p>DKLoginConfig 里面定义常量</p>\n<p> 相关的常量使用UIKIT_EXTERN / FOUNDATION_EXTERA，并且UIKIT_EXTERN / FOUNDATION_EXTERA建议写在模块外的全局DKConfig.h(会在pch里引入)</p>\n</li>\n<li><p>ps: pch建议只写宏，宏之外的其他东西，写在DKConfig.h里面，然后导入pch</p>\n</li>\n<li><p>DKModuelABaseViewController : DKModuelAConfig.h</p>\n</li>\n</ul>\n<h3 id=\"调用-import\"><a href=\"#调用-import\" class=\"headerlink\" title=\"调用(import)\"></a>调用(import)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHomeViewController</span><br><span class=\"line\">    |-DKLoginViewController</span><br><span class=\"line\">        |-DKRegisterViewController</span><br><span class=\"line\">        |-DKLoginBaseViewController</span><br><span class=\"line\">            |—DKViewController</span><br><span class=\"line\">                |_ UIKit</span><br></pre></td></tr></table></figure>"},{"title":"组合模式","author":"Arclin","abbrlink":"df879792","date":"2016-10-31T16:00:00.000Z","_content":"其实组合模式就是为了便于管理一个树形结构（抽象的）的对象，能让客户端统一处理这个对象的一种设计模式\n\n<!-- more -->\n\n举个例子\n\n```\n帽子\n  |_贝雷帽\n  |_鸭舌帽\n      |_黑色鸭舌\n衣服\n  |_衬衫\n      |_蓝色衬衫\n      |_白色衬衫\n  |_T恤\n裤子\n  |_牛仔裤\n      |_蓝色牛仔裤\n  |_短裤\n\n```\n\n那么这时候如果客户端要拿到一顶黑色鸭舌帽，一件白色衬衫和一条蓝色牛仔裤，那么应该怎么取到呢？或者想从对象中删除这些东西呢？\n\n首先我们需要有一个衣柜\n\n```\nWardrobe *wardrobe = [[Wardrobe alloc] init];\n```\n\n然后为其我们添加子节点\n\n```\n[wardrobe addDress:hat];\n[wardrobe addDress:clothes];\n[wardrobe addDress:trousers];\n```\n\n那 `hat` 和 `clothes` 和 `trousers` 怎么来 (以 hat 举例)\n\n```\nHat *hat = [[Hat alloc] init];\nHat *yashe_hat = [[Hat alloc] initWithType:@\"Yashe\"];\nHat *beilei_hat = [[Hat alloc] initWithType:@\"Beilei\"];\nHat *black_hat = [[Hat alloc] initWithColor:@\"Black Yashe\"];\n\n[hat addDress:beilei_hat];\n\n[yashe_hat addDress:black_hat];\n[hat addDress:yashe_hat];\n```\n\n现在我们需要注意一下\n· 上面的三个对象，必须遵守一个协议，我们姑且命名为 DressProtocol (服饰）\n\n```\n@protocol DressProtocol\n\n- (void)addDress:(id<DressProtocol>)dress;\n- (void)removeDress:(id<DressProtocol>)dress;\n\n- (void)showDresses;\n@end\n\n```\n\n上面经过一轮 AddDress:之后，帽子那块应该就会生成这样子的结构\n\n```\n衣橱\n|_帽子\n  |_贝雷帽\n  |_鸭舌帽\n    |_黑色鸭舌帽\n```\n然后我们来看看里面代理方法的实现\n\n```\n- (void)addDress:(id<DressProtocol>)dress\n{\n\t// 有一个数组成员属性用来储存这些对象\n\t[_child addObject:dress];\n}\n- (void)removeDress:(id<DressProtocol>)dress\n{\n\t[_child removeObject:dress];\n}\n- (void)showDresses\n{\n\tNSLog(@\"%@\",_child);\n}\n```\n\n顺便看看 Init的时候我们使用的两个方法\n\n```\n- (instancetype)initWithType:(NSString *)type\n{\n\tif(self = [super init]){\n\t\tself.type = type;\n\t\tself.color = nil;\n\t}\n\treturn self;\n}\n\n- (instancetype)initWithColor:(NSString *)color\n{\n\tif(self = [super init]){\n\t\tself.type = nil;\n\t\tself.color = color;\n\t}\n\treturn self;\n}\n\n```\n\n大概就是这种感觉\n\n如果不是很清楚的话，可以想想 `UIView`的 `addSubView:`\n`addSubView:`就是把一个新的 View加入到子节点，如果 subView 还有 subView，那就在 subView 上面继续添加 `addSubView:` 最后我们打印 subViews的时候就可以得到该View的所有的subview\n\n","source":"_posts/组合模式.md","raw":"---\ntitle: 组合模式\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: df879792\ndate: 2016-11-01 00:00:00\n---\n其实组合模式就是为了便于管理一个树形结构（抽象的）的对象，能让客户端统一处理这个对象的一种设计模式\n\n<!-- more -->\n\n举个例子\n\n```\n帽子\n  |_贝雷帽\n  |_鸭舌帽\n      |_黑色鸭舌\n衣服\n  |_衬衫\n      |_蓝色衬衫\n      |_白色衬衫\n  |_T恤\n裤子\n  |_牛仔裤\n      |_蓝色牛仔裤\n  |_短裤\n\n```\n\n那么这时候如果客户端要拿到一顶黑色鸭舌帽，一件白色衬衫和一条蓝色牛仔裤，那么应该怎么取到呢？或者想从对象中删除这些东西呢？\n\n首先我们需要有一个衣柜\n\n```\nWardrobe *wardrobe = [[Wardrobe alloc] init];\n```\n\n然后为其我们添加子节点\n\n```\n[wardrobe addDress:hat];\n[wardrobe addDress:clothes];\n[wardrobe addDress:trousers];\n```\n\n那 `hat` 和 `clothes` 和 `trousers` 怎么来 (以 hat 举例)\n\n```\nHat *hat = [[Hat alloc] init];\nHat *yashe_hat = [[Hat alloc] initWithType:@\"Yashe\"];\nHat *beilei_hat = [[Hat alloc] initWithType:@\"Beilei\"];\nHat *black_hat = [[Hat alloc] initWithColor:@\"Black Yashe\"];\n\n[hat addDress:beilei_hat];\n\n[yashe_hat addDress:black_hat];\n[hat addDress:yashe_hat];\n```\n\n现在我们需要注意一下\n· 上面的三个对象，必须遵守一个协议，我们姑且命名为 DressProtocol (服饰）\n\n```\n@protocol DressProtocol\n\n- (void)addDress:(id<DressProtocol>)dress;\n- (void)removeDress:(id<DressProtocol>)dress;\n\n- (void)showDresses;\n@end\n\n```\n\n上面经过一轮 AddDress:之后，帽子那块应该就会生成这样子的结构\n\n```\n衣橱\n|_帽子\n  |_贝雷帽\n  |_鸭舌帽\n    |_黑色鸭舌帽\n```\n然后我们来看看里面代理方法的实现\n\n```\n- (void)addDress:(id<DressProtocol>)dress\n{\n\t// 有一个数组成员属性用来储存这些对象\n\t[_child addObject:dress];\n}\n- (void)removeDress:(id<DressProtocol>)dress\n{\n\t[_child removeObject:dress];\n}\n- (void)showDresses\n{\n\tNSLog(@\"%@\",_child);\n}\n```\n\n顺便看看 Init的时候我们使用的两个方法\n\n```\n- (instancetype)initWithType:(NSString *)type\n{\n\tif(self = [super init]){\n\t\tself.type = type;\n\t\tself.color = nil;\n\t}\n\treturn self;\n}\n\n- (instancetype)initWithColor:(NSString *)color\n{\n\tif(self = [super init]){\n\t\tself.type = nil;\n\t\tself.color = color;\n\t}\n\treturn self;\n}\n\n```\n\n大概就是这种感觉\n\n如果不是很清楚的话，可以想想 `UIView`的 `addSubView:`\n`addSubView:`就是把一个新的 View加入到子节点，如果 subView 还有 subView，那就在 subView 上面继续添加 `addSubView:` 最后我们打印 subViews的时候就可以得到该View的所有的subview\n\n","slug":"组合模式","published":1,"updated":"2021-04-12T06:07:04.041Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog6l005w45n0cobm9gyk","content":"<p>其实组合模式就是为了便于管理一个树形结构（抽象的）的对象，能让客户端统一处理这个对象的一种设计模式</p>\n<span id=\"more\"></span>\n\n<p>举个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">帽子</span><br><span class=\"line\">  |_贝雷帽</span><br><span class=\"line\">  |_鸭舌帽</span><br><span class=\"line\">      |_黑色鸭舌</span><br><span class=\"line\">衣服</span><br><span class=\"line\">  |_衬衫</span><br><span class=\"line\">      |_蓝色衬衫</span><br><span class=\"line\">      |_白色衬衫</span><br><span class=\"line\">  |_T恤</span><br><span class=\"line\">裤子</span><br><span class=\"line\">  |_牛仔裤</span><br><span class=\"line\">      |_蓝色牛仔裤</span><br><span class=\"line\">  |_短裤</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>那么这时候如果客户端要拿到一顶黑色鸭舌帽，一件白色衬衫和一条蓝色牛仔裤，那么应该怎么取到呢？或者想从对象中删除这些东西呢？</p>\n<p>首先我们需要有一个衣柜</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Wardrobe *wardrobe &#x3D; [[Wardrobe alloc] init];</span><br></pre></td></tr></table></figure>\n\n<p>然后为其我们添加子节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[wardrobe addDress:hat];</span><br><span class=\"line\">[wardrobe addDress:clothes];</span><br><span class=\"line\">[wardrobe addDress:trousers];</span><br></pre></td></tr></table></figure>\n\n<p>那 <code>hat</code> 和 <code>clothes</code> 和 <code>trousers</code> 怎么来 (以 hat 举例)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hat *hat &#x3D; [[Hat alloc] init];</span><br><span class=\"line\">Hat *yashe_hat &#x3D; [[Hat alloc] initWithType:@&quot;Yashe&quot;];</span><br><span class=\"line\">Hat *beilei_hat &#x3D; [[Hat alloc] initWithType:@&quot;Beilei&quot;];</span><br><span class=\"line\">Hat *black_hat &#x3D; [[Hat alloc] initWithColor:@&quot;Black Yashe&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">[hat addDress:beilei_hat];</span><br><span class=\"line\"></span><br><span class=\"line\">[yashe_hat addDress:black_hat];</span><br><span class=\"line\">[hat addDress:yashe_hat];</span><br></pre></td></tr></table></figure>\n\n<p>现在我们需要注意一下<br>· 上面的三个对象，必须遵守一个协议，我们姑且命名为 DressProtocol (服饰）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@protocol DressProtocol</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)addDress:(id&lt;DressProtocol&gt;)dress;</span><br><span class=\"line\">- (void)removeDress:(id&lt;DressProtocol&gt;)dress;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)showDresses;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面经过一轮 AddDress:之后，帽子那块应该就会生成这样子的结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">衣橱</span><br><span class=\"line\">|_帽子</span><br><span class=\"line\">  |_贝雷帽</span><br><span class=\"line\">  |_鸭舌帽</span><br><span class=\"line\">    |_黑色鸭舌帽</span><br></pre></td></tr></table></figure>\n<p>然后我们来看看里面代理方法的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addDress:(id&lt;DressProtocol&gt;)dress</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 有一个数组成员属性用来储存这些对象</span><br><span class=\"line\">\t[_child addObject:dress];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)removeDress:(id&lt;DressProtocol&gt;)dress</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[_child removeObject:dress];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)showDresses</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNSLog(@&quot;%@&quot;,_child);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>顺便看看 Init的时候我们使用的两个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithType:(NSString *)type</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(self &#x3D; [super init])&#123;</span><br><span class=\"line\">\t\tself.type &#x3D; type;</span><br><span class=\"line\">\t\tself.color &#x3D; nil;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithColor:(NSString *)color</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(self &#x3D; [super init])&#123;</span><br><span class=\"line\">\t\tself.type &#x3D; nil;</span><br><span class=\"line\">\t\tself.color &#x3D; color;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>大概就是这种感觉</p>\n<p>如果不是很清楚的话，可以想想 <code>UIView</code>的 <code>addSubView:</code><br><code>addSubView:</code>就是把一个新的 View加入到子节点，如果 subView 还有 subView，那就在 subView 上面继续添加 <code>addSubView:</code> 最后我们打印 subViews的时候就可以得到该View的所有的subview</p>\n","site":{"data":{}},"excerpt":"<p>其实组合模式就是为了便于管理一个树形结构（抽象的）的对象，能让客户端统一处理这个对象的一种设计模式</p>","more":"<p>举个例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">帽子</span><br><span class=\"line\">  |_贝雷帽</span><br><span class=\"line\">  |_鸭舌帽</span><br><span class=\"line\">      |_黑色鸭舌</span><br><span class=\"line\">衣服</span><br><span class=\"line\">  |_衬衫</span><br><span class=\"line\">      |_蓝色衬衫</span><br><span class=\"line\">      |_白色衬衫</span><br><span class=\"line\">  |_T恤</span><br><span class=\"line\">裤子</span><br><span class=\"line\">  |_牛仔裤</span><br><span class=\"line\">      |_蓝色牛仔裤</span><br><span class=\"line\">  |_短裤</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>那么这时候如果客户端要拿到一顶黑色鸭舌帽，一件白色衬衫和一条蓝色牛仔裤，那么应该怎么取到呢？或者想从对象中删除这些东西呢？</p>\n<p>首先我们需要有一个衣柜</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Wardrobe *wardrobe &#x3D; [[Wardrobe alloc] init];</span><br></pre></td></tr></table></figure>\n\n<p>然后为其我们添加子节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[wardrobe addDress:hat];</span><br><span class=\"line\">[wardrobe addDress:clothes];</span><br><span class=\"line\">[wardrobe addDress:trousers];</span><br></pre></td></tr></table></figure>\n\n<p>那 <code>hat</code> 和 <code>clothes</code> 和 <code>trousers</code> 怎么来 (以 hat 举例)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hat *hat &#x3D; [[Hat alloc] init];</span><br><span class=\"line\">Hat *yashe_hat &#x3D; [[Hat alloc] initWithType:@&quot;Yashe&quot;];</span><br><span class=\"line\">Hat *beilei_hat &#x3D; [[Hat alloc] initWithType:@&quot;Beilei&quot;];</span><br><span class=\"line\">Hat *black_hat &#x3D; [[Hat alloc] initWithColor:@&quot;Black Yashe&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">[hat addDress:beilei_hat];</span><br><span class=\"line\"></span><br><span class=\"line\">[yashe_hat addDress:black_hat];</span><br><span class=\"line\">[hat addDress:yashe_hat];</span><br></pre></td></tr></table></figure>\n\n<p>现在我们需要注意一下<br>· 上面的三个对象，必须遵守一个协议，我们姑且命名为 DressProtocol (服饰）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@protocol DressProtocol</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)addDress:(id&lt;DressProtocol&gt;)dress;</span><br><span class=\"line\">- (void)removeDress:(id&lt;DressProtocol&gt;)dress;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)showDresses;</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面经过一轮 AddDress:之后，帽子那块应该就会生成这样子的结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">衣橱</span><br><span class=\"line\">|_帽子</span><br><span class=\"line\">  |_贝雷帽</span><br><span class=\"line\">  |_鸭舌帽</span><br><span class=\"line\">    |_黑色鸭舌帽</span><br></pre></td></tr></table></figure>\n<p>然后我们来看看里面代理方法的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)addDress:(id&lt;DressProtocol&gt;)dress</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 有一个数组成员属性用来储存这些对象</span><br><span class=\"line\">\t[_child addObject:dress];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)removeDress:(id&lt;DressProtocol&gt;)dress</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t[_child removeObject:dress];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)showDresses</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tNSLog(@&quot;%@&quot;,_child);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>顺便看看 Init的时候我们使用的两个方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (instancetype)initWithType:(NSString *)type</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(self &#x3D; [super init])&#123;</span><br><span class=\"line\">\t\tself.type &#x3D; type;</span><br><span class=\"line\">\t\tself.color &#x3D; nil;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (instancetype)initWithColor:(NSString *)color</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(self &#x3D; [super init])&#123;</span><br><span class=\"line\">\t\tself.type &#x3D; nil;</span><br><span class=\"line\">\t\tself.color &#x3D; color;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn self;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>大概就是这种感觉</p>\n<p>如果不是很清楚的话，可以想想 <code>UIView</code>的 <code>addSubView:</code><br><code>addSubView:</code>就是把一个新的 View加入到子节点，如果 subView 还有 subView，那就在 subView 上面继续添加 <code>addSubView:</code> 最后我们打印 subViews的时候就可以得到该View的所有的subview</p>"},{"title":"给 APP添加外部文件导入功能","author":"Arclin","abbrlink":"d2301e87","date":"2016-10-29T16:00:00.000Z","_content":"给 APP添加外部文件导入功能\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/333.jpeg)\n\n<!-- more -->\n\n修改 info.plist(这里是允许所有文件类型,如果要特定某种类型的文件,那么就得添加多个CFBundleTypeName CFBundleTypeRole LSHandlerRank LSItemContentTypes 具体见百度)\n\n```\n<key>CFBundleDocumentTypes</key>\n   <array>\n       <dict>\n           <key>CFBundleTypeIconFiles</key>\n           <array/>\n           <key>CFBundleTypeName</key>\n           <string>data</string>\n           <key>CFBundleTypeRole</key>\n           <string>Viewer</string>\n           <key>LSHandlerRank</key>\n           <string>Default</string>\n           <key>LSItemContentTypes</key>\n           <array>\n               <string>public.data</string>\n           </array>\n       </dict>\n   </array>\n ```\n \nAPPDelegate.h\n\n获取到根控制器,执行复制到Document文件夹方法\n源路径:url.path\n\n```\n@property (strong, nonatomic) NSURL *sharedURL;\n\n- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary<NSString *,id> *)options\n{\n\tif(url.fileURL){\n        self.sharedURL = url;\n        UIViewController *vc = self.window.rootViewController;\n        if ([vc isKindOfClass:[UINavigationController class]]) {\n            UINavigationController * nav = (UINavigationController *)self.window.rootViewController;\n            UIViewController *topVC = nav.childViewControllers.firstObject;\n            if ([topVC respondsToSelector:@selector(handleSharedFile)]) {\n                [topVC performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];\n            }\n        } else {\n            if ([vc respondsToSelector:@selector(handleSharedFile)]) {\n                [vc performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];\n            }\n        }\n    }\n}\n```\n\n根控制器方法(头文件需要声明方法)\n\n```\n- (void)handleSharedFile {\n    AppDelegate *app = (AppDelegate *)[UIApplication sharedApplication].delegate;\n    if (app.sharedURL != nil) {\n        self.sharedURL = [app.sharedURL copy];\n        app.sharedURL = nil;\n        [self saveSharedFile:self.sharedURL];\n    }\n}\n- (void)saveSharedFile:(NSURL *)url {\n    MBProgressHUD *hud = [MBProgressHUD showButtonHUDAddedTo:self.view animated:YES];\n    DKFile *file = [[DKFile alloc] init];\n    file.fullPath = url.path;\n    file.fileName = url.path.lastPathComponent;\n    [[DKFileManager sharedInstance] copyItemsOfSelectFiles:@[file] fromStorage:DKFileStorageTypeInternal toStorage:DKFileStorageTypeInternal toPath:[DKFileManager defaultPath:kShareDirectory storage:DKFileStorageTypeInternal] progressHUD:hud complete:^{\n        [SVProgressHUD showSuccessWithStatus:@\"已保存到 iPhone -> SharedFiles\"];\n    } failure:^(NSError *errors) {\n        \n    }];\n}\n```","source":"_posts/给-APP添加外部文件导入功能.md","raw":"---\ntitle: 给 APP添加外部文件导入功能\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: d2301e87\ndate: 2016-10-30 00:00:00\n---\n给 APP添加外部文件导入功能\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/333.jpeg)\n\n<!-- more -->\n\n修改 info.plist(这里是允许所有文件类型,如果要特定某种类型的文件,那么就得添加多个CFBundleTypeName CFBundleTypeRole LSHandlerRank LSItemContentTypes 具体见百度)\n\n```\n<key>CFBundleDocumentTypes</key>\n   <array>\n       <dict>\n           <key>CFBundleTypeIconFiles</key>\n           <array/>\n           <key>CFBundleTypeName</key>\n           <string>data</string>\n           <key>CFBundleTypeRole</key>\n           <string>Viewer</string>\n           <key>LSHandlerRank</key>\n           <string>Default</string>\n           <key>LSItemContentTypes</key>\n           <array>\n               <string>public.data</string>\n           </array>\n       </dict>\n   </array>\n ```\n \nAPPDelegate.h\n\n获取到根控制器,执行复制到Document文件夹方法\n源路径:url.path\n\n```\n@property (strong, nonatomic) NSURL *sharedURL;\n\n- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary<NSString *,id> *)options\n{\n\tif(url.fileURL){\n        self.sharedURL = url;\n        UIViewController *vc = self.window.rootViewController;\n        if ([vc isKindOfClass:[UINavigationController class]]) {\n            UINavigationController * nav = (UINavigationController *)self.window.rootViewController;\n            UIViewController *topVC = nav.childViewControllers.firstObject;\n            if ([topVC respondsToSelector:@selector(handleSharedFile)]) {\n                [topVC performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];\n            }\n        } else {\n            if ([vc respondsToSelector:@selector(handleSharedFile)]) {\n                [vc performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];\n            }\n        }\n    }\n}\n```\n\n根控制器方法(头文件需要声明方法)\n\n```\n- (void)handleSharedFile {\n    AppDelegate *app = (AppDelegate *)[UIApplication sharedApplication].delegate;\n    if (app.sharedURL != nil) {\n        self.sharedURL = [app.sharedURL copy];\n        app.sharedURL = nil;\n        [self saveSharedFile:self.sharedURL];\n    }\n}\n- (void)saveSharedFile:(NSURL *)url {\n    MBProgressHUD *hud = [MBProgressHUD showButtonHUDAddedTo:self.view animated:YES];\n    DKFile *file = [[DKFile alloc] init];\n    file.fullPath = url.path;\n    file.fileName = url.path.lastPathComponent;\n    [[DKFileManager sharedInstance] copyItemsOfSelectFiles:@[file] fromStorage:DKFileStorageTypeInternal toStorage:DKFileStorageTypeInternal toPath:[DKFileManager defaultPath:kShareDirectory storage:DKFileStorageTypeInternal] progressHUD:hud complete:^{\n        [SVProgressHUD showSuccessWithStatus:@\"已保存到 iPhone -> SharedFiles\"];\n    } failure:^(NSError *errors) {\n        \n    }];\n}\n```","slug":"给-APP添加外部文件导入功能","published":1,"updated":"2021-04-12T06:07:04.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog6p006045n04rfd5buk","content":"<p>给 APP添加外部文件导入功能</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/333.jpeg\"></p>\n<span id=\"more\"></span>\n\n<p>修改 info.plist(这里是允许所有文件类型,如果要特定某种类型的文件,那么就得添加多个CFBundleTypeName CFBundleTypeRole LSHandlerRank LSItemContentTypes 具体见百度)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;CFBundleDocumentTypes&lt;&#x2F;key&gt;</span><br><span class=\"line\">   &lt;array&gt;</span><br><span class=\"line\">       &lt;dict&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeIconFiles&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;array&#x2F;&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeName&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;string&gt;data&lt;&#x2F;string&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeRole&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;string&gt;Viewer&lt;&#x2F;string&gt;</span><br><span class=\"line\">           &lt;key&gt;LSHandlerRank&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;string&gt;Default&lt;&#x2F;string&gt;</span><br><span class=\"line\">           &lt;key&gt;LSItemContentTypes&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;array&gt;</span><br><span class=\"line\">               &lt;string&gt;public.data&lt;&#x2F;string&gt;</span><br><span class=\"line\">           &lt;&#x2F;array&gt;</span><br><span class=\"line\">       &lt;&#x2F;dict&gt;</span><br><span class=\"line\">   &lt;&#x2F;array&gt;</span><br></pre></td></tr></table></figure>\n<p>APPDelegate.h</p>\n<p>获取到根控制器,执行复制到Document文件夹方法<br>源路径:url.path</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property (strong, nonatomic) NSURL *sharedURL;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(url.fileURL)&#123;</span><br><span class=\"line\">        self.sharedURL &#x3D; url;</span><br><span class=\"line\">        UIViewController *vc &#x3D; self.window.rootViewController;</span><br><span class=\"line\">        if ([vc isKindOfClass:[UINavigationController class]]) &#123;</span><br><span class=\"line\">            UINavigationController * nav &#x3D; (UINavigationController *)self.window.rootViewController;</span><br><span class=\"line\">            UIViewController *topVC &#x3D; nav.childViewControllers.firstObject;</span><br><span class=\"line\">            if ([topVC respondsToSelector:@selector(handleSharedFile)]) &#123;</span><br><span class=\"line\">                [topVC performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if ([vc respondsToSelector:@selector(handleSharedFile)]) &#123;</span><br><span class=\"line\">                [vc performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>根控制器方法(头文件需要声明方法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)handleSharedFile &#123;</span><br><span class=\"line\">    AppDelegate *app &#x3D; (AppDelegate *)[UIApplication sharedApplication].delegate;</span><br><span class=\"line\">    if (app.sharedURL !&#x3D; nil) &#123;</span><br><span class=\"line\">        self.sharedURL &#x3D; [app.sharedURL copy];</span><br><span class=\"line\">        app.sharedURL &#x3D; nil;</span><br><span class=\"line\">        [self saveSharedFile:self.sharedURL];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)saveSharedFile:(NSURL *)url &#123;</span><br><span class=\"line\">    MBProgressHUD *hud &#x3D; [MBProgressHUD showButtonHUDAddedTo:self.view animated:YES];</span><br><span class=\"line\">    DKFile *file &#x3D; [[DKFile alloc] init];</span><br><span class=\"line\">    file.fullPath &#x3D; url.path;</span><br><span class=\"line\">    file.fileName &#x3D; url.path.lastPathComponent;</span><br><span class=\"line\">    [[DKFileManager sharedInstance] copyItemsOfSelectFiles:@[file] fromStorage:DKFileStorageTypeInternal toStorage:DKFileStorageTypeInternal toPath:[DKFileManager defaultPath:kShareDirectory storage:DKFileStorageTypeInternal] progressHUD:hud complete:^&#123;</span><br><span class=\"line\">        [SVProgressHUD showSuccessWithStatus:@&quot;已保存到 iPhone -&gt; SharedFiles&quot;];</span><br><span class=\"line\">    &#125; failure:^(NSError *errors) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>给 APP添加外部文件导入功能</p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/333.jpeg\"></p>","more":"<p>修改 info.plist(这里是允许所有文件类型,如果要特定某种类型的文件,那么就得添加多个CFBundleTypeName CFBundleTypeRole LSHandlerRank LSItemContentTypes 具体见百度)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;CFBundleDocumentTypes&lt;&#x2F;key&gt;</span><br><span class=\"line\">   &lt;array&gt;</span><br><span class=\"line\">       &lt;dict&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeIconFiles&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;array&#x2F;&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeName&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;string&gt;data&lt;&#x2F;string&gt;</span><br><span class=\"line\">           &lt;key&gt;CFBundleTypeRole&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;string&gt;Viewer&lt;&#x2F;string&gt;</span><br><span class=\"line\">           &lt;key&gt;LSHandlerRank&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;string&gt;Default&lt;&#x2F;string&gt;</span><br><span class=\"line\">           &lt;key&gt;LSItemContentTypes&lt;&#x2F;key&gt;</span><br><span class=\"line\">           &lt;array&gt;</span><br><span class=\"line\">               &lt;string&gt;public.data&lt;&#x2F;string&gt;</span><br><span class=\"line\">           &lt;&#x2F;array&gt;</span><br><span class=\"line\">       &lt;&#x2F;dict&gt;</span><br><span class=\"line\">   &lt;&#x2F;array&gt;</span><br></pre></td></tr></table></figure>\n<p>APPDelegate.h</p>\n<p>获取到根控制器,执行复制到Document文件夹方法<br>源路径:url.path</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@property (strong, nonatomic) NSURL *sharedURL;</span><br><span class=\"line\"></span><br><span class=\"line\">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif(url.fileURL)&#123;</span><br><span class=\"line\">        self.sharedURL &#x3D; url;</span><br><span class=\"line\">        UIViewController *vc &#x3D; self.window.rootViewController;</span><br><span class=\"line\">        if ([vc isKindOfClass:[UINavigationController class]]) &#123;</span><br><span class=\"line\">            UINavigationController * nav &#x3D; (UINavigationController *)self.window.rootViewController;</span><br><span class=\"line\">            UIViewController *topVC &#x3D; nav.childViewControllers.firstObject;</span><br><span class=\"line\">            if ([topVC respondsToSelector:@selector(handleSharedFile)]) &#123;</span><br><span class=\"line\">                [topVC performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if ([vc respondsToSelector:@selector(handleSharedFile)]) &#123;</span><br><span class=\"line\">                [vc performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>根控制器方法(头文件需要声明方法)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)handleSharedFile &#123;</span><br><span class=\"line\">    AppDelegate *app &#x3D; (AppDelegate *)[UIApplication sharedApplication].delegate;</span><br><span class=\"line\">    if (app.sharedURL !&#x3D; nil) &#123;</span><br><span class=\"line\">        self.sharedURL &#x3D; [app.sharedURL copy];</span><br><span class=\"line\">        app.sharedURL &#x3D; nil;</span><br><span class=\"line\">        [self saveSharedFile:self.sharedURL];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">- (void)saveSharedFile:(NSURL *)url &#123;</span><br><span class=\"line\">    MBProgressHUD *hud &#x3D; [MBProgressHUD showButtonHUDAddedTo:self.view animated:YES];</span><br><span class=\"line\">    DKFile *file &#x3D; [[DKFile alloc] init];</span><br><span class=\"line\">    file.fullPath &#x3D; url.path;</span><br><span class=\"line\">    file.fileName &#x3D; url.path.lastPathComponent;</span><br><span class=\"line\">    [[DKFileManager sharedInstance] copyItemsOfSelectFiles:@[file] fromStorage:DKFileStorageTypeInternal toStorage:DKFileStorageTypeInternal toPath:[DKFileManager defaultPath:kShareDirectory storage:DKFileStorageTypeInternal] progressHUD:hud complete:^&#123;</span><br><span class=\"line\">        [SVProgressHUD showSuccessWithStatus:@&quot;已保存到 iPhone -&gt; SharedFiles&quot;];</span><br><span class=\"line\">    &#125; failure:^(NSError *errors) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"网络层方法封装3","author":"Arclin","abbrlink":"fee6ede8","date":"2016-11-20T16:00:00.000Z","_content":"网络层方法封装3.1\n\n<!-- more -->\n\n** 其实很久之前就想写写这个东西,不过因为项目的原因一直没时间去整理出来,所以决定还是分开几天去写完这个东西吧\n\n- 新增特性:\n\t- 3.0\n\t\t- 多缓存策略\n\t\t- 用宏定义减少代码量\n\t\t- 使用 plist统一错误信息设置\n\t- 3.1\n\t\t- 输出一个漂亮的Log\n\n- 先讲讲本地持久化策略的选择\n\n\t- 数据量小,单一的时候(比如一个模型数组,数组不大而且模型的成员属性不是很多),可以使用 `NSKeyArchive` 归档\n\n\t- `NSUserDefault` 用于储存用户首选项\n\n\t- `KeyChain`储存一些密码之类的东西\n\n\t- 数据库储存数据量比较大,字段比较多的模型数组\n\n- 缓存策略\n\n```\ntypedef NS_ENUM(NSInteger,DKCacheStrategy){\n    DKCacheStrategy_CACHE_ONLY, // 只从本地取数据\n    DKCacheStrategy_NETWORK_ONLY, // 只从网络取数据(不缓存)\n    DKCacheStrategy_NETWORK_AND_CACHE, // 从网络取数据后缓存(缓存结束不回调)\n    DKCacheStrategy_CACHE_ELSE_NETWORK, // 先取缓存,如果没有数据的话,才从网络取数据\n    DKCacheStrategy_CACHE_THEN_NETWORK // 先取缓存,再加载网络数据,网络数据加载完会更新缓存,这个选择会有两次回调\n    DKCacheStrategy_AUTOMATIC // 根据当前网络环境自动选择,如果有网络(WIFI/WLAN)就取网络数据,没网络就取缓存数据\n};\n```\n\n- Demo 说明\n   - github地址:没有\n   - 下载地址: NetworkDemo\n   - 选择本地持久化方式: `YYCache`,如果有更适合的缓存机制,那改一改也挺简单\n \n- 方法接口设计\n\n```\n/**\n *  发送HTTP请求\n *\n *  @param method 请求方法,你可以写@\"get\"或者@\"post\"(不区分大小写)或者已经定义好的 kGET 或 kPOST\n *  @param strategy  缓存策略\n *  @param header 请求头,可为空\n *  @param params 请求参数,可为空\n *  @param block  返回回调,这个就不要空啦\n *\n *  @return 请求标示 id 可以用来取消请求\n */\n- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block;\n```\n\n之前两个方法继续保留,在这里就不说明了\n\n```\n- (void)cancelAllRequest;\n- (void)cancelRequestWithRequestIds:(NSArray *)requestIds;\n```\n\n然后写两个内部方法,分别是取缓存和取网络数据\n\n```\n#pragma mark - 仅本地\n- (NSInteger)requestWithCacheOnlyStrategyWithUrl:(NSString *)URLString params:(NSDictionary *)params requestBlock:(DKHTTPResponseBlock)block\n{\n    DKResponse *response = (DKResponse *)[self.cache objectForKey:[self cacheKeyForRequestUrl:URLString params:params]];\n    if (block) {\n        if (response) {\n            block(response);\n        }else{\n            block(KERROR_RESPONSE(-1));\n        }\n    }\n    return 0;\n}\n\n#pragma mark - 仅网络\n- (NSInteger)requestWithNetworkOnlyStrategyForMethod:(NSString *)method url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block\n{\n    NSNumber *taskIdentifier = 0;\n    if ([method.uppercaseString isEqualToString:@\"GET\"]) {\n        DKCALLAPI(GET, taskIdentifier);\n    }else if([method.uppercaseString isEqualToString:@\"POST\"]){\n        DKCALLAPI(POST, taskIdentifier);\n    }else{\n        return 0;\n    }\n    return taskIdentifier.integerValue;\n}\n```\n\n这里的宏DKCALLAPI 定义 主要是为了不想写 POST和 GET两个方法,在这里写一次就够了\n\n```\n#define DKCALLAPI(REQUEST_METHOD,REQUEST_ID) \\\n{\\\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\\\n    AFHTTPRequestSerializer *requestSerializer = mgr.requestSerializer;\\\n    if (header) {\\\n        [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id obj, BOOL * _Nonnull stop) {\\\n            [requestSerializer setValue:obj forHTTPHeaderField:key];\\\n        }];\\\n    }\\\n    requestSerializer.timeoutInterval = kTimeOutInterval;\\\n    NSURLSessionTask *task = [mgr REQUEST_METHOD:URLString parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\\\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\\\n        resp.rawData = responseObject;\\\n        resp.taskIdentifier = task.taskIdentifier;\\\n        if(block){\\\n            block(resp);\\\n        }\\\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\\\n        DKResponse *resp = [DKResponse responseWithErrorOnly:error.description code:error.code];\\\n        if (block) {\\\n            block(resp);\\\n        }\\\n    }];\\\n    REQUEST_ID = @(task.taskIdentifier);\\\n    [self.dispatchTable setObject:task forKey:REQUEST_ID];\\\n}\n```\n\n然后 就可以实现我们的接口了 switch 里面的东西就就根据注释写吧\n\n```\n- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block\n{\n    __weak typeof(self) weakSelf = self;\n    NSInteger requestId;\n    switch (strategy) {\n        case DKCacheStrategy_CACHE_ONLY:\n        // 调用获取缓存方法\n            break;\n        case DKCacheStrategy_NETWORK_ONLY:\n        // 调用获取网络方法\n            break;\n        case DKCacheStrategy_NETWORK_AND_CACHE:\n        // 调用网络方法,回调后写入本地缓存\n            break;\n        case DKCacheStrategy_CACHE_ELSE_NETWORK:\n        // 调用本地缓存方法,在回调中判断是否有缓存,如果没有的话调用网络方法\n            break;\n        case DKCacheStrategy_CACHE_THEN_NETWORK:\n        // 调用本地方法接着调用网络方法 \n            break;\n        case DKCacheStrategy_AUTOMATICALLY:\n         // 调用网络方法,回调中如果返回错误则调用本地缓存方法\n            break;\n        default:\n            break;\n    }\n    return requestId;\n}\n```\n\n统一错误表处理\n-建立一个plist 文件\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>-2</key>\n\t<string>网络连接失败</string>\n\t<key>-1</key>\n\t<string>没有缓存</string>\n</dict>\n</plist>\n```\n\n一个成员属性加一个方法去调用\n\n```\n- (NSDictionary *)errorDic\n{\n    if (!_errorDic) {\n        NSString *path = [[NSBundle mainBundle] pathForResource:@\"DKError\" ofType:@\"plist\"];\n        _errorDic = [NSDictionary dictionaryWithContentsOfFile:path];\n    }\n    return _errorDic;\n}\n\n- (NSString *)errorDescriptionWithCode:(NSInteger)code\n{\n    NSString *codeStr = [NSString stringWithFormat:@\"%zd\",code];\n    if ([self.errorDic.allKeys containsObject:codeStr]) {\n        return self.errorDic[codeStr];\n    }else{\n        NSLog(@\"没有定义该类型错误\");\n        return nil;\n    }\n}\n```\n\n包装成宏方便调用\n\n```\n#define KERROR_RESPONSE(errCode) [DKResponse responseWithErrorOnly:[self errorDescriptionWithCode:errCode] code:errCode]\n```\n\n3.1 输出一个漂亮的 Log\n\n```\n/**\n *  打印一个漂亮的 log\n *\n *  @param method              请求方法\n *  @param url                 接口地址\n *  @param params              参数\n *  @param response            响应对象\n *  @param showRequestContent  是否显示响应数据\n */\n+ (void)logDebugInfoWithMethod:(NSString *)method URL:(NSString *)url params:(NSDictionary *)params response:(DKResponse *)response showRequestContent:(BOOL)showRequestContent;\n```\n\n里面主要是字符串拼接.要看详细的话就去下载 Demo吧!\n\n","source":"_posts/网络层方法封装3.md","raw":"---\ntitle: 网络层方法封装3\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: fee6ede8\ndate: 2016-11-21 00:00:00\n---\n网络层方法封装3.1\n\n<!-- more -->\n\n** 其实很久之前就想写写这个东西,不过因为项目的原因一直没时间去整理出来,所以决定还是分开几天去写完这个东西吧\n\n- 新增特性:\n\t- 3.0\n\t\t- 多缓存策略\n\t\t- 用宏定义减少代码量\n\t\t- 使用 plist统一错误信息设置\n\t- 3.1\n\t\t- 输出一个漂亮的Log\n\n- 先讲讲本地持久化策略的选择\n\n\t- 数据量小,单一的时候(比如一个模型数组,数组不大而且模型的成员属性不是很多),可以使用 `NSKeyArchive` 归档\n\n\t- `NSUserDefault` 用于储存用户首选项\n\n\t- `KeyChain`储存一些密码之类的东西\n\n\t- 数据库储存数据量比较大,字段比较多的模型数组\n\n- 缓存策略\n\n```\ntypedef NS_ENUM(NSInteger,DKCacheStrategy){\n    DKCacheStrategy_CACHE_ONLY, // 只从本地取数据\n    DKCacheStrategy_NETWORK_ONLY, // 只从网络取数据(不缓存)\n    DKCacheStrategy_NETWORK_AND_CACHE, // 从网络取数据后缓存(缓存结束不回调)\n    DKCacheStrategy_CACHE_ELSE_NETWORK, // 先取缓存,如果没有数据的话,才从网络取数据\n    DKCacheStrategy_CACHE_THEN_NETWORK // 先取缓存,再加载网络数据,网络数据加载完会更新缓存,这个选择会有两次回调\n    DKCacheStrategy_AUTOMATIC // 根据当前网络环境自动选择,如果有网络(WIFI/WLAN)就取网络数据,没网络就取缓存数据\n};\n```\n\n- Demo 说明\n   - github地址:没有\n   - 下载地址: NetworkDemo\n   - 选择本地持久化方式: `YYCache`,如果有更适合的缓存机制,那改一改也挺简单\n \n- 方法接口设计\n\n```\n/**\n *  发送HTTP请求\n *\n *  @param method 请求方法,你可以写@\"get\"或者@\"post\"(不区分大小写)或者已经定义好的 kGET 或 kPOST\n *  @param strategy  缓存策略\n *  @param header 请求头,可为空\n *  @param params 请求参数,可为空\n *  @param block  返回回调,这个就不要空啦\n *\n *  @return 请求标示 id 可以用来取消请求\n */\n- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block;\n```\n\n之前两个方法继续保留,在这里就不说明了\n\n```\n- (void)cancelAllRequest;\n- (void)cancelRequestWithRequestIds:(NSArray *)requestIds;\n```\n\n然后写两个内部方法,分别是取缓存和取网络数据\n\n```\n#pragma mark - 仅本地\n- (NSInteger)requestWithCacheOnlyStrategyWithUrl:(NSString *)URLString params:(NSDictionary *)params requestBlock:(DKHTTPResponseBlock)block\n{\n    DKResponse *response = (DKResponse *)[self.cache objectForKey:[self cacheKeyForRequestUrl:URLString params:params]];\n    if (block) {\n        if (response) {\n            block(response);\n        }else{\n            block(KERROR_RESPONSE(-1));\n        }\n    }\n    return 0;\n}\n\n#pragma mark - 仅网络\n- (NSInteger)requestWithNetworkOnlyStrategyForMethod:(NSString *)method url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block\n{\n    NSNumber *taskIdentifier = 0;\n    if ([method.uppercaseString isEqualToString:@\"GET\"]) {\n        DKCALLAPI(GET, taskIdentifier);\n    }else if([method.uppercaseString isEqualToString:@\"POST\"]){\n        DKCALLAPI(POST, taskIdentifier);\n    }else{\n        return 0;\n    }\n    return taskIdentifier.integerValue;\n}\n```\n\n这里的宏DKCALLAPI 定义 主要是为了不想写 POST和 GET两个方法,在这里写一次就够了\n\n```\n#define DKCALLAPI(REQUEST_METHOD,REQUEST_ID) \\\n{\\\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\\\n    AFHTTPRequestSerializer *requestSerializer = mgr.requestSerializer;\\\n    if (header) {\\\n        [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id obj, BOOL * _Nonnull stop) {\\\n            [requestSerializer setValue:obj forHTTPHeaderField:key];\\\n        }];\\\n    }\\\n    requestSerializer.timeoutInterval = kTimeOutInterval;\\\n    NSURLSessionTask *task = [mgr REQUEST_METHOD:URLString parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\\\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\\\n        resp.rawData = responseObject;\\\n        resp.taskIdentifier = task.taskIdentifier;\\\n        if(block){\\\n            block(resp);\\\n        }\\\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\\\n        DKResponse *resp = [DKResponse responseWithErrorOnly:error.description code:error.code];\\\n        if (block) {\\\n            block(resp);\\\n        }\\\n    }];\\\n    REQUEST_ID = @(task.taskIdentifier);\\\n    [self.dispatchTable setObject:task forKey:REQUEST_ID];\\\n}\n```\n\n然后 就可以实现我们的接口了 switch 里面的东西就就根据注释写吧\n\n```\n- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block\n{\n    __weak typeof(self) weakSelf = self;\n    NSInteger requestId;\n    switch (strategy) {\n        case DKCacheStrategy_CACHE_ONLY:\n        // 调用获取缓存方法\n            break;\n        case DKCacheStrategy_NETWORK_ONLY:\n        // 调用获取网络方法\n            break;\n        case DKCacheStrategy_NETWORK_AND_CACHE:\n        // 调用网络方法,回调后写入本地缓存\n            break;\n        case DKCacheStrategy_CACHE_ELSE_NETWORK:\n        // 调用本地缓存方法,在回调中判断是否有缓存,如果没有的话调用网络方法\n            break;\n        case DKCacheStrategy_CACHE_THEN_NETWORK:\n        // 调用本地方法接着调用网络方法 \n            break;\n        case DKCacheStrategy_AUTOMATICALLY:\n         // 调用网络方法,回调中如果返回错误则调用本地缓存方法\n            break;\n        default:\n            break;\n    }\n    return requestId;\n}\n```\n\n统一错误表处理\n-建立一个plist 文件\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n\t<key>-2</key>\n\t<string>网络连接失败</string>\n\t<key>-1</key>\n\t<string>没有缓存</string>\n</dict>\n</plist>\n```\n\n一个成员属性加一个方法去调用\n\n```\n- (NSDictionary *)errorDic\n{\n    if (!_errorDic) {\n        NSString *path = [[NSBundle mainBundle] pathForResource:@\"DKError\" ofType:@\"plist\"];\n        _errorDic = [NSDictionary dictionaryWithContentsOfFile:path];\n    }\n    return _errorDic;\n}\n\n- (NSString *)errorDescriptionWithCode:(NSInteger)code\n{\n    NSString *codeStr = [NSString stringWithFormat:@\"%zd\",code];\n    if ([self.errorDic.allKeys containsObject:codeStr]) {\n        return self.errorDic[codeStr];\n    }else{\n        NSLog(@\"没有定义该类型错误\");\n        return nil;\n    }\n}\n```\n\n包装成宏方便调用\n\n```\n#define KERROR_RESPONSE(errCode) [DKResponse responseWithErrorOnly:[self errorDescriptionWithCode:errCode] code:errCode]\n```\n\n3.1 输出一个漂亮的 Log\n\n```\n/**\n *  打印一个漂亮的 log\n *\n *  @param method              请求方法\n *  @param url                 接口地址\n *  @param params              参数\n *  @param response            响应对象\n *  @param showRequestContent  是否显示响应数据\n */\n+ (void)logDebugInfoWithMethod:(NSString *)method URL:(NSString *)url params:(NSDictionary *)params response:(DKResponse *)response showRequestContent:(BOOL)showRequestContent;\n```\n\n里面主要是字符串拼接.要看详细的话就去下载 Demo吧!\n\n","slug":"网络层方法封装3","published":1,"updated":"2021-04-12T06:07:04.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog6q006345n0bprm3wi2","content":"<p>网络层方法封装3.1</p>\n<span id=\"more\"></span>\n\n<p>** 其实很久之前就想写写这个东西,不过因为项目的原因一直没时间去整理出来,所以决定还是分开几天去写完这个东西吧</p>\n<ul>\n<li><p>新增特性:</p>\n<ul>\n<li>3.0<ul>\n<li>多缓存策略</li>\n<li>用宏定义减少代码量</li>\n<li>使用 plist统一错误信息设置</li>\n</ul>\n</li>\n<li>3.1<ul>\n<li>输出一个漂亮的Log</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>先讲讲本地持久化策略的选择</p>\n<ul>\n<li><p>数据量小,单一的时候(比如一个模型数组,数组不大而且模型的成员属性不是很多),可以使用 <code>NSKeyArchive</code> 归档</p>\n</li>\n<li><p><code>NSUserDefault</code> 用于储存用户首选项</p>\n</li>\n<li><p><code>KeyChain</code>储存一些密码之类的东西</p>\n</li>\n<li><p>数据库储存数据量比较大,字段比较多的模型数组</p>\n</li>\n</ul>\n</li>\n<li><p>缓存策略</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_ENUM(NSInteger,DKCacheStrategy)&#123;</span><br><span class=\"line\">    DKCacheStrategy_CACHE_ONLY, &#x2F;&#x2F; 只从本地取数据</span><br><span class=\"line\">    DKCacheStrategy_NETWORK_ONLY, &#x2F;&#x2F; 只从网络取数据(不缓存)</span><br><span class=\"line\">    DKCacheStrategy_NETWORK_AND_CACHE, &#x2F;&#x2F; 从网络取数据后缓存(缓存结束不回调)</span><br><span class=\"line\">    DKCacheStrategy_CACHE_ELSE_NETWORK, &#x2F;&#x2F; 先取缓存,如果没有数据的话,才从网络取数据</span><br><span class=\"line\">    DKCacheStrategy_CACHE_THEN_NETWORK &#x2F;&#x2F; 先取缓存,再加载网络数据,网络数据加载完会更新缓存,这个选择会有两次回调</span><br><span class=\"line\">    DKCacheStrategy_AUTOMATIC &#x2F;&#x2F; 根据当前网络环境自动选择,如果有网络(WIFI&#x2F;WLAN)就取网络数据,没网络就取缓存数据</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Demo 说明<ul>\n<li>github地址:没有</li>\n<li>下载地址: NetworkDemo</li>\n<li>选择本地持久化方式: <code>YYCache</code>,如果有更适合的缓存机制,那改一改也挺简单</li>\n</ul>\n</li>\n<li>方法接口设计</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> *  发送HTTP请求</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param method 请求方法,你可以写@&quot;get&quot;或者@&quot;post&quot;(不区分大小写)或者已经定义好的 kGET 或 kPOST</span><br><span class=\"line\"> *  @param strategy  缓存策略</span><br><span class=\"line\"> *  @param header 请求头,可为空</span><br><span class=\"line\"> *  @param params 请求参数,可为空</span><br><span class=\"line\"> *  @param block  返回回调,这个就不要空啦</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @return 请求标示 id 可以用来取消请求</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n\n<p>之前两个方法继续保留,在这里就不说明了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)cancelAllRequest;</span><br><span class=\"line\">- (void)cancelRequestWithRequestIds:(NSArray *)requestIds;</span><br></pre></td></tr></table></figure>\n\n<p>然后写两个内部方法,分别是取缓存和取网络数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - 仅本地</span><br><span class=\"line\">- (NSInteger)requestWithCacheOnlyStrategyWithUrl:(NSString *)URLString params:(NSDictionary *)params requestBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DKResponse *response &#x3D; (DKResponse *)[self.cache objectForKey:[self cacheKeyForRequestUrl:URLString params:params]];</span><br><span class=\"line\">    if (block) &#123;</span><br><span class=\"line\">        if (response) &#123;</span><br><span class=\"line\">            block(response);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            block(KERROR_RESPONSE(-1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - 仅网络</span><br><span class=\"line\">- (NSInteger)requestWithNetworkOnlyStrategyForMethod:(NSString *)method url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSNumber *taskIdentifier &#x3D; 0;</span><br><span class=\"line\">    if ([method.uppercaseString isEqualToString:@&quot;GET&quot;]) &#123;</span><br><span class=\"line\">        DKCALLAPI(GET, taskIdentifier);</span><br><span class=\"line\">    &#125;else if([method.uppercaseString isEqualToString:@&quot;POST&quot;])&#123;</span><br><span class=\"line\">        DKCALLAPI(POST, taskIdentifier);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return taskIdentifier.integerValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的宏DKCALLAPI 定义 主要是为了不想写 POST和 GET两个方法,在这里写一次就够了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKCALLAPI(REQUEST_METHOD,REQUEST_ID) \\</span><br><span class=\"line\">&#123;\\</span><br><span class=\"line\">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];\\</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer &#x3D; mgr.requestSerializer;\\</span><br><span class=\"line\">    if (header) &#123;\\</span><br><span class=\"line\">        [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id obj, BOOL * _Nonnull stop) &#123;\\</span><br><span class=\"line\">            [requestSerializer setValue:obj forHTTPHeaderField:key];\\</span><br><span class=\"line\">        &#125;];\\</span><br><span class=\"line\">    &#125;\\</span><br><span class=\"line\">    requestSerializer.timeoutInterval &#x3D; kTimeOutInterval;\\</span><br><span class=\"line\">    NSURLSessionTask *task &#x3D; [mgr REQUEST_METHOD:URLString parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;\\</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject];\\</span><br><span class=\"line\">        resp.rawData &#x3D; responseObject;\\</span><br><span class=\"line\">        resp.taskIdentifier &#x3D; task.taskIdentifier;\\</span><br><span class=\"line\">        if(block)&#123;\\</span><br><span class=\"line\">            block(resp);\\</span><br><span class=\"line\">        &#125;\\</span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;\\</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse responseWithErrorOnly:error.description code:error.code];\\</span><br><span class=\"line\">        if (block) &#123;\\</span><br><span class=\"line\">            block(resp);\\</span><br><span class=\"line\">        &#125;\\</span><br><span class=\"line\">    &#125;];\\</span><br><span class=\"line\">    REQUEST_ID &#x3D; @(task.taskIdentifier);\\</span><br><span class=\"line\">    [self.dispatchTable setObject:task forKey:REQUEST_ID];\\</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后 就可以实现我们的接口了 switch 里面的东西就就根据注释写吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __weak typeof(self) weakSelf &#x3D; self;</span><br><span class=\"line\">    NSInteger requestId;</span><br><span class=\"line\">    switch (strategy) &#123;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_ONLY:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用获取缓存方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_NETWORK_ONLY:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用获取网络方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_NETWORK_AND_CACHE:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用网络方法,回调后写入本地缓存</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_ELSE_NETWORK:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用本地缓存方法,在回调中判断是否有缓存,如果没有的话调用网络方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_THEN_NETWORK:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用本地方法接着调用网络方法 </span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_AUTOMATICALLY:</span><br><span class=\"line\">         &#x2F;&#x2F; 调用网络方法,回调中如果返回错误则调用本地缓存方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return requestId;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>统一错误表处理<br>-建立一个plist 文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class=\"line\">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class=\"line\">&lt;dict&gt;</span><br><span class=\"line\">\t&lt;key&gt;-2&lt;&#x2F;key&gt;</span><br><span class=\"line\">\t&lt;string&gt;网络连接失败&lt;&#x2F;string&gt;</span><br><span class=\"line\">\t&lt;key&gt;-1&lt;&#x2F;key&gt;</span><br><span class=\"line\">\t&lt;string&gt;没有缓存&lt;&#x2F;string&gt;</span><br><span class=\"line\">&lt;&#x2F;dict&gt;</span><br><span class=\"line\">&lt;&#x2F;plist&gt;</span><br></pre></td></tr></table></figure>\n\n<p>一个成员属性加一个方法去调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSDictionary *)errorDic</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!_errorDic) &#123;</span><br><span class=\"line\">        NSString *path &#x3D; [[NSBundle mainBundle] pathForResource:@&quot;DKError&quot; ofType:@&quot;plist&quot;];</span><br><span class=\"line\">        _errorDic &#x3D; [NSDictionary dictionaryWithContentsOfFile:path];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _errorDic;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)errorDescriptionWithCode:(NSInteger)code</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSString *codeStr &#x3D; [NSString stringWithFormat:@&quot;%zd&quot;,code];</span><br><span class=\"line\">    if ([self.errorDic.allKeys containsObject:codeStr]) &#123;</span><br><span class=\"line\">        return self.errorDic[codeStr];</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        NSLog(@&quot;没有定义该类型错误&quot;);</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>包装成宏方便调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define KERROR_RESPONSE(errCode) [DKResponse responseWithErrorOnly:[self errorDescriptionWithCode:errCode] code:errCode]</span><br></pre></td></tr></table></figure>\n\n<p>3.1 输出一个漂亮的 Log</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> *  打印一个漂亮的 log</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param method              请求方法</span><br><span class=\"line\"> *  @param url                 接口地址</span><br><span class=\"line\"> *  @param params              参数</span><br><span class=\"line\"> *  @param response            响应对象</span><br><span class=\"line\"> *  @param showRequestContent  是否显示响应数据</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">+ (void)logDebugInfoWithMethod:(NSString *)method URL:(NSString *)url params:(NSDictionary *)params response:(DKResponse *)response showRequestContent:(BOOL)showRequestContent;</span><br></pre></td></tr></table></figure>\n\n<p>里面主要是字符串拼接.要看详细的话就去下载 Demo吧!</p>\n","site":{"data":{}},"excerpt":"<p>网络层方法封装3.1</p>","more":"<p>** 其实很久之前就想写写这个东西,不过因为项目的原因一直没时间去整理出来,所以决定还是分开几天去写完这个东西吧</p>\n<ul>\n<li><p>新增特性:</p>\n<ul>\n<li>3.0<ul>\n<li>多缓存策略</li>\n<li>用宏定义减少代码量</li>\n<li>使用 plist统一错误信息设置</li>\n</ul>\n</li>\n<li>3.1<ul>\n<li>输出一个漂亮的Log</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>先讲讲本地持久化策略的选择</p>\n<ul>\n<li><p>数据量小,单一的时候(比如一个模型数组,数组不大而且模型的成员属性不是很多),可以使用 <code>NSKeyArchive</code> 归档</p>\n</li>\n<li><p><code>NSUserDefault</code> 用于储存用户首选项</p>\n</li>\n<li><p><code>KeyChain</code>储存一些密码之类的东西</p>\n</li>\n<li><p>数据库储存数据量比较大,字段比较多的模型数组</p>\n</li>\n</ul>\n</li>\n<li><p>缓存策略</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_ENUM(NSInteger,DKCacheStrategy)&#123;</span><br><span class=\"line\">    DKCacheStrategy_CACHE_ONLY, &#x2F;&#x2F; 只从本地取数据</span><br><span class=\"line\">    DKCacheStrategy_NETWORK_ONLY, &#x2F;&#x2F; 只从网络取数据(不缓存)</span><br><span class=\"line\">    DKCacheStrategy_NETWORK_AND_CACHE, &#x2F;&#x2F; 从网络取数据后缓存(缓存结束不回调)</span><br><span class=\"line\">    DKCacheStrategy_CACHE_ELSE_NETWORK, &#x2F;&#x2F; 先取缓存,如果没有数据的话,才从网络取数据</span><br><span class=\"line\">    DKCacheStrategy_CACHE_THEN_NETWORK &#x2F;&#x2F; 先取缓存,再加载网络数据,网络数据加载完会更新缓存,这个选择会有两次回调</span><br><span class=\"line\">    DKCacheStrategy_AUTOMATIC &#x2F;&#x2F; 根据当前网络环境自动选择,如果有网络(WIFI&#x2F;WLAN)就取网络数据,没网络就取缓存数据</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Demo 说明<ul>\n<li>github地址:没有</li>\n<li>下载地址: NetworkDemo</li>\n<li>选择本地持久化方式: <code>YYCache</code>,如果有更适合的缓存机制,那改一改也挺简单</li>\n</ul>\n</li>\n<li>方法接口设计</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> *  发送HTTP请求</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param method 请求方法,你可以写@&quot;get&quot;或者@&quot;post&quot;(不区分大小写)或者已经定义好的 kGET 或 kPOST</span><br><span class=\"line\"> *  @param strategy  缓存策略</span><br><span class=\"line\"> *  @param header 请求头,可为空</span><br><span class=\"line\"> *  @param params 请求参数,可为空</span><br><span class=\"line\"> *  @param block  返回回调,这个就不要空啦</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @return 请求标示 id 可以用来取消请求</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n\n<p>之前两个方法继续保留,在这里就不说明了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)cancelAllRequest;</span><br><span class=\"line\">- (void)cancelRequestWithRequestIds:(NSArray *)requestIds;</span><br></pre></td></tr></table></figure>\n\n<p>然后写两个内部方法,分别是取缓存和取网络数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - 仅本地</span><br><span class=\"line\">- (NSInteger)requestWithCacheOnlyStrategyWithUrl:(NSString *)URLString params:(NSDictionary *)params requestBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DKResponse *response &#x3D; (DKResponse *)[self.cache objectForKey:[self cacheKeyForRequestUrl:URLString params:params]];</span><br><span class=\"line\">    if (block) &#123;</span><br><span class=\"line\">        if (response) &#123;</span><br><span class=\"line\">            block(response);</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            block(KERROR_RESPONSE(-1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#pragma mark - 仅网络</span><br><span class=\"line\">- (NSInteger)requestWithNetworkOnlyStrategyForMethod:(NSString *)method url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSNumber *taskIdentifier &#x3D; 0;</span><br><span class=\"line\">    if ([method.uppercaseString isEqualToString:@&quot;GET&quot;]) &#123;</span><br><span class=\"line\">        DKCALLAPI(GET, taskIdentifier);</span><br><span class=\"line\">    &#125;else if([method.uppercaseString isEqualToString:@&quot;POST&quot;])&#123;</span><br><span class=\"line\">        DKCALLAPI(POST, taskIdentifier);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return taskIdentifier.integerValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的宏DKCALLAPI 定义 主要是为了不想写 POST和 GET两个方法,在这里写一次就够了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKCALLAPI(REQUEST_METHOD,REQUEST_ID) \\</span><br><span class=\"line\">&#123;\\</span><br><span class=\"line\">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];\\</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer &#x3D; mgr.requestSerializer;\\</span><br><span class=\"line\">    if (header) &#123;\\</span><br><span class=\"line\">        [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id obj, BOOL * _Nonnull stop) &#123;\\</span><br><span class=\"line\">            [requestSerializer setValue:obj forHTTPHeaderField:key];\\</span><br><span class=\"line\">        &#125;];\\</span><br><span class=\"line\">    &#125;\\</span><br><span class=\"line\">    requestSerializer.timeoutInterval &#x3D; kTimeOutInterval;\\</span><br><span class=\"line\">    NSURLSessionTask *task &#x3D; [mgr REQUEST_METHOD:URLString parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;\\</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject];\\</span><br><span class=\"line\">        resp.rawData &#x3D; responseObject;\\</span><br><span class=\"line\">        resp.taskIdentifier &#x3D; task.taskIdentifier;\\</span><br><span class=\"line\">        if(block)&#123;\\</span><br><span class=\"line\">            block(resp);\\</span><br><span class=\"line\">        &#125;\\</span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;\\</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse responseWithErrorOnly:error.description code:error.code];\\</span><br><span class=\"line\">        if (block) &#123;\\</span><br><span class=\"line\">            block(resp);\\</span><br><span class=\"line\">        &#125;\\</span><br><span class=\"line\">    &#125;];\\</span><br><span class=\"line\">    REQUEST_ID &#x3D; @(task.taskIdentifier);\\</span><br><span class=\"line\">    [self.dispatchTable setObject:task forKey:REQUEST_ID];\\</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后 就可以实现我们的接口了 switch 里面的东西就就根据注释写吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __weak typeof(self) weakSelf &#x3D; self;</span><br><span class=\"line\">    NSInteger requestId;</span><br><span class=\"line\">    switch (strategy) &#123;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_ONLY:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用获取缓存方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_NETWORK_ONLY:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用获取网络方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_NETWORK_AND_CACHE:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用网络方法,回调后写入本地缓存</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_ELSE_NETWORK:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用本地缓存方法,在回调中判断是否有缓存,如果没有的话调用网络方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_CACHE_THEN_NETWORK:</span><br><span class=\"line\">        &#x2F;&#x2F; 调用本地方法接着调用网络方法 </span><br><span class=\"line\">            break;</span><br><span class=\"line\">        case DKCacheStrategy_AUTOMATICALLY:</span><br><span class=\"line\">         &#x2F;&#x2F; 调用网络方法,回调中如果返回错误则调用本地缓存方法</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        default:</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return requestId;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>统一错误表处理<br>-建立一个plist 文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class=\"line\">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class=\"line\">&lt;dict&gt;</span><br><span class=\"line\">\t&lt;key&gt;-2&lt;&#x2F;key&gt;</span><br><span class=\"line\">\t&lt;string&gt;网络连接失败&lt;&#x2F;string&gt;</span><br><span class=\"line\">\t&lt;key&gt;-1&lt;&#x2F;key&gt;</span><br><span class=\"line\">\t&lt;string&gt;没有缓存&lt;&#x2F;string&gt;</span><br><span class=\"line\">&lt;&#x2F;dict&gt;</span><br><span class=\"line\">&lt;&#x2F;plist&gt;</span><br></pre></td></tr></table></figure>\n\n<p>一个成员属性加一个方法去调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSDictionary *)errorDic</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!_errorDic) &#123;</span><br><span class=\"line\">        NSString *path &#x3D; [[NSBundle mainBundle] pathForResource:@&quot;DKError&quot; ofType:@&quot;plist&quot;];</span><br><span class=\"line\">        _errorDic &#x3D; [NSDictionary dictionaryWithContentsOfFile:path];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _errorDic;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSString *)errorDescriptionWithCode:(NSInteger)code</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSString *codeStr &#x3D; [NSString stringWithFormat:@&quot;%zd&quot;,code];</span><br><span class=\"line\">    if ([self.errorDic.allKeys containsObject:codeStr]) &#123;</span><br><span class=\"line\">        return self.errorDic[codeStr];</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        NSLog(@&quot;没有定义该类型错误&quot;);</span><br><span class=\"line\">        return nil;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>包装成宏方便调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define KERROR_RESPONSE(errCode) [DKResponse responseWithErrorOnly:[self errorDescriptionWithCode:errCode] code:errCode]</span><br></pre></td></tr></table></figure>\n\n<p>3.1 输出一个漂亮的 Log</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> *  打印一个漂亮的 log</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param method              请求方法</span><br><span class=\"line\"> *  @param url                 接口地址</span><br><span class=\"line\"> *  @param params              参数</span><br><span class=\"line\"> *  @param response            响应对象</span><br><span class=\"line\"> *  @param showRequestContent  是否显示响应数据</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">+ (void)logDebugInfoWithMethod:(NSString *)method URL:(NSString *)url params:(NSDictionary *)params response:(DKResponse *)response showRequestContent:(BOOL)showRequestContent;</span><br></pre></td></tr></table></figure>\n\n<p>里面主要是字符串拼接.要看详细的话就去下载 Demo吧!</p>"},{"title":"网络层方法封装2","author":"Arclin","abbrlink":"89e1dd7e","date":"2016-11-02T16:00:00.000Z","_content":"网络层方法封装2\n\n<!-- more -->\n - 为了便于进行请求的管理，特地对之前的网络层方法封装加以改进，为了就是避免请求发送出去之后就管理不了的问题。\n - 其中最为重要的就是请求的取消\n \n> 当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。-Casa\n\n - 另外还添加了请求头，有需求的话就调用有添加请求头的方法\n\n - 接下来说说改造\n\n   1. 添加单例方法，使用 sharedTool 管理请求\n   2. 改原先的类方法为实例方法，并添加 NSInteger的返回值\n   3. 添加取消请求和取消全部请求的方法\n   4. DKResponse 添加 taskIdentifier（NSInteger）属性\n\n- 声明部分\n\n```\n/** 请求头 */\n@property (nonatomic,strong)  NSDictionary *header;\n\n+ (instancetype)sharedTool;\n\n- (NSInteger)GET:(NSString *)URLString parameters:(id)parameters\nresponseBlock:(DKHTTPResponseBlock)block;\n\n- (NSInteger)POST:(NSString *)URLString parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block;\n```\n\n- 方法实现\n\n```\nstatic DKHTTPTool *_tool;\n\n+ (id)allocWithZone:(struct _NSZone *)zone\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        _tool = [super allocWithZone:zone];\n    });\n    return _tool;\n}\n\n+ (instancetype)sharedTool\n{\n    if (_tool == nil) {\n        _tool = [[DKHTTPTool alloc] init];\n    }\n    return _tool;\n}\n```\n\n- GET请求添加请求头\n\n```\n- (NSInteger)GET:(NSString *)URLString header:(NSDictionary *)header parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block\n{\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n    AFHTTPRequestSerializer *requestSerializer = mgr.requestSerializer;\n    [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        [requestSerializer setValue:obj forHTTPHeaderField:key];\n    }];\n    requestSerializer.timeoutInterval = kTimeOutInterval;\n    NSURLSessionTask *task = [mgr GET:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\n        resp.rawData = responseObject;\n        resp.taskIdentifier = task.taskIdentifier;\n        if(block){\n            block(resp);\n        }\n        \n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        DKResponse *resp = [[DKResponse alloc] init];\n        resp.error = error;\n        if (block) {\n            block(resp);\n        }\n    }];\n    NSNumber *requestId = @(task.taskIdentifier);\n    [self.dispatchTable setObject:task forKey:requestId];\n    return task.taskIdentifier;\n}\n```\n\n- 取消请求\n\n```\n- (void)cancelRequestWithRequestIds:(NSArray *)requestIds\n{\n    for (NSInteger i = 0; i < requestIds.count ; i++) {\n        NSInteger requestId = [requestIds[i] integerValue];\n        NSURLSessionTask *task = [self.dispatchTable objectForKey:@(requestId)];\n        [task cancel];\n        [self.dispatchTable removeObjectForKey:@(requestId)];\n    }\n}\n\n- (void)cancelAllRequest\n{\n    [self.dispatchTable enumerateKeysAndObjectsUsingBlock:^(NSNumber * _Nonnull key, NSURLSessionTask * _Nonnull obj, BOOL * _Nonnull stop) {\n        [obj cancel];\n    }];\n}\n```\n\n- 其他方法\n\n```\n#pragma mark - seter & getter\n- (NSMutableDictionary<NSNumber *,NSURLSessionTask *> *)dispatchTable\n{\n    if (!_dispatchTable) {\n        _dispatchTable = [NSMutableDictionary dictionary];\n    }\n    return _dispatchTable;\n}\n```","source":"_posts/网络层方法封装2.md","raw":"---\ntitle: 网络层方法封装2\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 89e1dd7e\ndate: 2016-11-03 00:00:00\n---\n网络层方法封装2\n\n<!-- more -->\n - 为了便于进行请求的管理，特地对之前的网络层方法封装加以改进，为了就是避免请求发送出去之后就管理不了的问题。\n - 其中最为重要的就是请求的取消\n \n> 当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。-Casa\n\n - 另外还添加了请求头，有需求的话就调用有添加请求头的方法\n\n - 接下来说说改造\n\n   1. 添加单例方法，使用 sharedTool 管理请求\n   2. 改原先的类方法为实例方法，并添加 NSInteger的返回值\n   3. 添加取消请求和取消全部请求的方法\n   4. DKResponse 添加 taskIdentifier（NSInteger）属性\n\n- 声明部分\n\n```\n/** 请求头 */\n@property (nonatomic,strong)  NSDictionary *header;\n\n+ (instancetype)sharedTool;\n\n- (NSInteger)GET:(NSString *)URLString parameters:(id)parameters\nresponseBlock:(DKHTTPResponseBlock)block;\n\n- (NSInteger)POST:(NSString *)URLString parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block;\n```\n\n- 方法实现\n\n```\nstatic DKHTTPTool *_tool;\n\n+ (id)allocWithZone:(struct _NSZone *)zone\n{\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        _tool = [super allocWithZone:zone];\n    });\n    return _tool;\n}\n\n+ (instancetype)sharedTool\n{\n    if (_tool == nil) {\n        _tool = [[DKHTTPTool alloc] init];\n    }\n    return _tool;\n}\n```\n\n- GET请求添加请求头\n\n```\n- (NSInteger)GET:(NSString *)URLString header:(NSDictionary *)header parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block\n{\n    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n    AFHTTPRequestSerializer *requestSerializer = mgr.requestSerializer;\n    [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) {\n        [requestSerializer setValue:obj forHTTPHeaderField:key];\n    }];\n    requestSerializer.timeoutInterval = kTimeOutInterval;\n    NSURLSessionTask *task = [mgr GET:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject];\n        resp.rawData = responseObject;\n        resp.taskIdentifier = task.taskIdentifier;\n        if(block){\n            block(resp);\n        }\n        \n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        DKResponse *resp = [[DKResponse alloc] init];\n        resp.error = error;\n        if (block) {\n            block(resp);\n        }\n    }];\n    NSNumber *requestId = @(task.taskIdentifier);\n    [self.dispatchTable setObject:task forKey:requestId];\n    return task.taskIdentifier;\n}\n```\n\n- 取消请求\n\n```\n- (void)cancelRequestWithRequestIds:(NSArray *)requestIds\n{\n    for (NSInteger i = 0; i < requestIds.count ; i++) {\n        NSInteger requestId = [requestIds[i] integerValue];\n        NSURLSessionTask *task = [self.dispatchTable objectForKey:@(requestId)];\n        [task cancel];\n        [self.dispatchTable removeObjectForKey:@(requestId)];\n    }\n}\n\n- (void)cancelAllRequest\n{\n    [self.dispatchTable enumerateKeysAndObjectsUsingBlock:^(NSNumber * _Nonnull key, NSURLSessionTask * _Nonnull obj, BOOL * _Nonnull stop) {\n        [obj cancel];\n    }];\n}\n```\n\n- 其他方法\n\n```\n#pragma mark - seter & getter\n- (NSMutableDictionary<NSNumber *,NSURLSessionTask *> *)dispatchTable\n{\n    if (!_dispatchTable) {\n        _dispatchTable = [NSMutableDictionary dictionary];\n    }\n    return _dispatchTable;\n}\n```","slug":"网络层方法封装2","published":1,"updated":"2021-04-12T06:07:04.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog6r006745n03c1c88go","content":"<p>网络层方法封装2</p>\n<span id=\"more\"></span>\n<ul>\n<li>为了便于进行请求的管理，特地对之前的网络层方法封装加以改进，为了就是避免请求发送出去之后就管理不了的问题。</li>\n<li>其中最为重要的就是请求的取消</li>\n</ul>\n<blockquote>\n<p>当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。-Casa</p>\n</blockquote>\n<ul>\n<li><p>另外还添加了请求头，有需求的话就调用有添加请求头的方法</p>\n</li>\n<li><p>接下来说说改造</p>\n<ol>\n<li>添加单例方法，使用 sharedTool 管理请求</li>\n<li>改原先的类方法为实例方法，并添加 NSInteger的返回值</li>\n<li>添加取消请求和取消全部请求的方法</li>\n<li>DKResponse 添加 taskIdentifier（NSInteger）属性</li>\n</ol>\n</li>\n<li><p>声明部分</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 请求头 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,strong)  NSDictionary *header;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)sharedTool;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSInteger)GET:(NSString *)URLString parameters:(id)parameters</span><br><span class=\"line\">responseBlock:(DKHTTPResponseBlock)block;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSInteger)POST:(NSString *)URLString parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方法实现</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static DKHTTPTool *_tool;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (id)allocWithZone:(struct _NSZone *)zone</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        _tool &#x3D; [super allocWithZone:zone];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return _tool;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)sharedTool</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (_tool &#x3D;&#x3D; nil) &#123;</span><br><span class=\"line\">        _tool &#x3D; [[DKHTTPTool alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _tool;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>GET请求添加请求头</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)GET:(NSString *)URLString header:(NSDictionary *)header parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer &#x3D; mgr.requestSerializer;</span><br><span class=\"line\">    [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [requestSerializer setValue:obj forHTTPHeaderField:key];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    requestSerializer.timeoutInterval &#x3D; kTimeOutInterval;</span><br><span class=\"line\">    NSURLSessionTask *task &#x3D; [mgr GET:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject];</span><br><span class=\"line\">        resp.rawData &#x3D; responseObject;</span><br><span class=\"line\">        resp.taskIdentifier &#x3D; task.taskIdentifier;</span><br><span class=\"line\">        if(block)&#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [[DKResponse alloc] init];</span><br><span class=\"line\">        resp.error &#x3D; error;</span><br><span class=\"line\">        if (block) &#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    NSNumber *requestId &#x3D; @(task.taskIdentifier);</span><br><span class=\"line\">    [self.dispatchTable setObject:task forKey:requestId];</span><br><span class=\"line\">    return task.taskIdentifier;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>取消请求</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)cancelRequestWithRequestIds:(NSArray *)requestIds</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (NSInteger i &#x3D; 0; i &lt; requestIds.count ; i++) &#123;</span><br><span class=\"line\">        NSInteger requestId &#x3D; [requestIds[i] integerValue];</span><br><span class=\"line\">        NSURLSessionTask *task &#x3D; [self.dispatchTable objectForKey:@(requestId)];</span><br><span class=\"line\">        [task cancel];</span><br><span class=\"line\">        [self.dispatchTable removeObjectForKey:@(requestId)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)cancelAllRequest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.dispatchTable enumerateKeysAndObjectsUsingBlock:^(NSNumber * _Nonnull key, NSURLSessionTask * _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [obj cancel];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其他方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - seter &amp; getter</span><br><span class=\"line\">- (NSMutableDictionary&lt;NSNumber *,NSURLSessionTask *&gt; *)dispatchTable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!_dispatchTable) &#123;</span><br><span class=\"line\">        _dispatchTable &#x3D; [NSMutableDictionary dictionary];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _dispatchTable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>网络层方法封装2</p>","more":"<ul>\n<li>为了便于进行请求的管理，特地对之前的网络层方法封装加以改进，为了就是避免请求发送出去之后就管理不了的问题。</li>\n<li>其中最为重要的就是请求的取消</li>\n</ul>\n<blockquote>\n<p>当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。-Casa</p>\n</blockquote>\n<ul>\n<li><p>另外还添加了请求头，有需求的话就调用有添加请求头的方法</p>\n</li>\n<li><p>接下来说说改造</p>\n<ol>\n<li>添加单例方法，使用 sharedTool 管理请求</li>\n<li>改原先的类方法为实例方法，并添加 NSInteger的返回值</li>\n<li>添加取消请求和取消全部请求的方法</li>\n<li>DKResponse 添加 taskIdentifier（NSInteger）属性</li>\n</ol>\n</li>\n<li><p>声明部分</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 请求头 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,strong)  NSDictionary *header;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)sharedTool;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSInteger)GET:(NSString *)URLString parameters:(id)parameters</span><br><span class=\"line\">responseBlock:(DKHTTPResponseBlock)block;</span><br><span class=\"line\"></span><br><span class=\"line\">- (NSInteger)POST:(NSString *)URLString parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>方法实现</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static DKHTTPTool *_tool;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (id)allocWithZone:(struct _NSZone *)zone</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        _tool &#x3D; [super allocWithZone:zone];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    return _tool;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)sharedTool</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (_tool &#x3D;&#x3D; nil) &#123;</span><br><span class=\"line\">        _tool &#x3D; [[DKHTTPTool alloc] init];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _tool;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>GET请求添加请求头</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSInteger)GET:(NSString *)URLString header:(NSDictionary *)header parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];</span><br><span class=\"line\">    AFHTTPRequestSerializer *requestSerializer &#x3D; mgr.requestSerializer;</span><br><span class=\"line\">    [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [requestSerializer setValue:obj forHTTPHeaderField:key];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    requestSerializer.timeoutInterval &#x3D; kTimeOutInterval;</span><br><span class=\"line\">    NSURLSessionTask *task &#x3D; [mgr GET:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject];</span><br><span class=\"line\">        resp.rawData &#x3D; responseObject;</span><br><span class=\"line\">        resp.taskIdentifier &#x3D; task.taskIdentifier;</span><br><span class=\"line\">        if(block)&#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [[DKResponse alloc] init];</span><br><span class=\"line\">        resp.error &#x3D; error;</span><br><span class=\"line\">        if (block) &#123;</span><br><span class=\"line\">            block(resp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    NSNumber *requestId &#x3D; @(task.taskIdentifier);</span><br><span class=\"line\">    [self.dispatchTable setObject:task forKey:requestId];</span><br><span class=\"line\">    return task.taskIdentifier;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>取消请求</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)cancelRequestWithRequestIds:(NSArray *)requestIds</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    for (NSInteger i &#x3D; 0; i &lt; requestIds.count ; i++) &#123;</span><br><span class=\"line\">        NSInteger requestId &#x3D; [requestIds[i] integerValue];</span><br><span class=\"line\">        NSURLSessionTask *task &#x3D; [self.dispatchTable objectForKey:@(requestId)];</span><br><span class=\"line\">        [task cancel];</span><br><span class=\"line\">        [self.dispatchTable removeObjectForKey:@(requestId)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)cancelAllRequest</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [self.dispatchTable enumerateKeysAndObjectsUsingBlock:^(NSNumber * _Nonnull key, NSURLSessionTask * _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class=\"line\">        [obj cancel];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>其他方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#pragma mark - seter &amp; getter</span><br><span class=\"line\">- (NSMutableDictionary&lt;NSNumber *,NSURLSessionTask *&gt; *)dispatchTable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (!_dispatchTable) &#123;</span><br><span class=\"line\">        _dispatchTable &#x3D; [NSMutableDictionary dictionary];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return _dispatchTable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"网络层方法封装5","author":"Arclin","abbrlink":"178548dd","date":"2016-12-14T19:00:00.000Z","_content":"网络层方法封装5.2.1\n\n- 特性\n\t- 添加链式调用方法\n- 5.1\n\t- 开启/关闭 Log\n\t- 自定义 Logger\n\t- RAC支持\n- 5.2.1\n\t- 修复了一些 bug\n\t- 由于服务器异常而返回的 NSData 转为 HTML 页面并展示出来（需要打开 DebugMode）\n\t- 把链式调用方法抽出为一个 DKHTTPChainTool 类\n    \n<!-- more -->\n    \n1. 添加链式调用方法\n\n链式调用的好处就是要啥参数就添加啥,方便快捷,不用担心代码不够漂亮！\n\n```\n#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]\n\n/** 链式调用 */\n- (DKHTTPChainTool * (^)(NSString *method))method;\n- (DKHTTPChainTool * (^)(NSString *url))url;\n- (DKHTTPChainTool * (^)(NSDictionary *header))header;\n- (DKHTTPChainTool * (^)(DKCacheStrategy strategy))cacheStrategy;\n- (DKHTTPChainTool * (^)(DKHTTPParamsVarifyBlock paramsVerify))verifyParams;\n- (DKHTTPChainTool * (^)(DKHTTPRequestFilterBlock resultFilter))requestFilter;\n- (DKHTTPChainTool * (^)(NSDictionary *params))params;\n/** block返回请求Id */\n- (NSInteger (^)(DKHTTPResponseBlock responseBlock))execute;\n```\n\n使用起来感觉是这样子的\n\n```\nDKHTTPChainInstance.method(@\"POST\")\n           .url(@\"\")\n           .params(@{@\"account\":@\"m13643046965@163.com\",@\"password\":@\"123456\"})\n           .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)\n           .verifyParams(^NSString *(NSDictionary *params){\n               return nil;\n           })\n           .requestFilter(^DKRequest *(DKRequest *request){\n               return request;\n           })\n           .execute(^(DKResponse *response){\n               NSLog(@\"%@\",response.rawData);\n           });\n```\n\n- 5.1\n\n开启/关闭 Log\n\n```\nDKHTTPSharedTool.showLog = YES/NO;\n```\n\n自定义 Logger\n\n```\n#define DKLog(...) NSLog(@\"%s %zd行 %@\",__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])\n\n[DKHTTPTool setLogger:^(NSString *msg) {\n  DKLog(@\"%@\",msg);\n}];\n```\n\nRAC支持\n\n```\n- (RACSignal *(^)())executeSignal;\n```\n\n使用\n```\nRACSignal *signal = DKHTTPChainInstance.method(@\"POST\")\n                                        .url()\n                                        .header(@{@\"token\":@\"0e83179ac83741416e50b0ea12113f6e\"})\n                                        .params(@{@\"account\":@\"\",@\"password\":@\"123456\"})\n                                        .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)\n                                        .verifyParams(^NSString *(NSDictionary *params){\n                                        return nil;\n                                        })\n                                      .requestFilter(^DKRequest *(DKRequest *request){\n                                        return request;\n                                        })\n                                      .executeSignal();\n[signal subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n}];\n```\n\n- 5.2.1\n\n1.DKHTTPTool的链式调用\n\n```\n#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]\n```\n\n使用方法和上面说的一样\n\n2.调试模式\n\n```\nDKHTTPSharedTool.debugMode = YES; // 开启 Log 和 服务器异常弹窗\n如果服务器发生异常，那么就会发生如图情况\n```\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/555.png?raw=true)\n![](https://github.com/Arc-lin/BlogImage/blob/master/666.png?raw=true)\n![](https://github.com/Arc-lin/BlogImage/blob/master/777.png?raw=true)\n\n\n","source":"_posts/网络层方法封装5.md","raw":"---\ntitle: 网络层方法封装5\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 178548dd\ndate: 2016-12-15 03:00:00\n---\n网络层方法封装5.2.1\n\n- 特性\n\t- 添加链式调用方法\n- 5.1\n\t- 开启/关闭 Log\n\t- 自定义 Logger\n\t- RAC支持\n- 5.2.1\n\t- 修复了一些 bug\n\t- 由于服务器异常而返回的 NSData 转为 HTML 页面并展示出来（需要打开 DebugMode）\n\t- 把链式调用方法抽出为一个 DKHTTPChainTool 类\n    \n<!-- more -->\n    \n1. 添加链式调用方法\n\n链式调用的好处就是要啥参数就添加啥,方便快捷,不用担心代码不够漂亮！\n\n```\n#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]\n\n/** 链式调用 */\n- (DKHTTPChainTool * (^)(NSString *method))method;\n- (DKHTTPChainTool * (^)(NSString *url))url;\n- (DKHTTPChainTool * (^)(NSDictionary *header))header;\n- (DKHTTPChainTool * (^)(DKCacheStrategy strategy))cacheStrategy;\n- (DKHTTPChainTool * (^)(DKHTTPParamsVarifyBlock paramsVerify))verifyParams;\n- (DKHTTPChainTool * (^)(DKHTTPRequestFilterBlock resultFilter))requestFilter;\n- (DKHTTPChainTool * (^)(NSDictionary *params))params;\n/** block返回请求Id */\n- (NSInteger (^)(DKHTTPResponseBlock responseBlock))execute;\n```\n\n使用起来感觉是这样子的\n\n```\nDKHTTPChainInstance.method(@\"POST\")\n           .url(@\"\")\n           .params(@{@\"account\":@\"m13643046965@163.com\",@\"password\":@\"123456\"})\n           .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)\n           .verifyParams(^NSString *(NSDictionary *params){\n               return nil;\n           })\n           .requestFilter(^DKRequest *(DKRequest *request){\n               return request;\n           })\n           .execute(^(DKResponse *response){\n               NSLog(@\"%@\",response.rawData);\n           });\n```\n\n- 5.1\n\n开启/关闭 Log\n\n```\nDKHTTPSharedTool.showLog = YES/NO;\n```\n\n自定义 Logger\n\n```\n#define DKLog(...) NSLog(@\"%s %zd行 %@\",__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])\n\n[DKHTTPTool setLogger:^(NSString *msg) {\n  DKLog(@\"%@\",msg);\n}];\n```\n\nRAC支持\n\n```\n- (RACSignal *(^)())executeSignal;\n```\n\n使用\n```\nRACSignal *signal = DKHTTPChainInstance.method(@\"POST\")\n                                        .url()\n                                        .header(@{@\"token\":@\"0e83179ac83741416e50b0ea12113f6e\"})\n                                        .params(@{@\"account\":@\"\",@\"password\":@\"123456\"})\n                                        .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)\n                                        .verifyParams(^NSString *(NSDictionary *params){\n                                        return nil;\n                                        })\n                                      .requestFilter(^DKRequest *(DKRequest *request){\n                                        return request;\n                                        })\n                                      .executeSignal();\n[signal subscribeNext:^(id x) {\n    NSLog(@\"%@\",x);\n}];\n```\n\n- 5.2.1\n\n1.DKHTTPTool的链式调用\n\n```\n#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]\n```\n\n使用方法和上面说的一样\n\n2.调试模式\n\n```\nDKHTTPSharedTool.debugMode = YES; // 开启 Log 和 服务器异常弹窗\n如果服务器发生异常，那么就会发生如图情况\n```\n\n![](https://github.com/Arc-lin/BlogImage/blob/master/555.png?raw=true)\n![](https://github.com/Arc-lin/BlogImage/blob/master/666.png?raw=true)\n![](https://github.com/Arc-lin/BlogImage/blob/master/777.png?raw=true)\n\n\n","slug":"网络层方法封装5","published":1,"updated":"2021-04-12T06:07:04.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog6r006a45n0995ufi6n","content":"<p>网络层方法封装5.2.1</p>\n<ul>\n<li>特性<ul>\n<li>添加链式调用方法</li>\n</ul>\n</li>\n<li>5.1<ul>\n<li>开启/关闭 Log</li>\n<li>自定义 Logger</li>\n<li>RAC支持</li>\n</ul>\n</li>\n<li>5.2.1<ul>\n<li>修复了一些 bug</li>\n<li>由于服务器异常而返回的 NSData 转为 HTML 页面并展示出来（需要打开 DebugMode）</li>\n<li>把链式调用方法抽出为一个 DKHTTPChainTool 类</li>\n</ul>\n</li>\n</ul>\n<span id=\"more\"></span>\n<ol>\n<li>添加链式调用方法</li>\n</ol>\n<p>链式调用的好处就是要啥参数就添加啥,方便快捷,不用担心代码不够漂亮！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 链式调用 *&#x2F;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSString *method))method;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSString *url))url;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSDictionary *header))header;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKCacheStrategy strategy))cacheStrategy;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKHTTPParamsVarifyBlock paramsVerify))verifyParams;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKHTTPRequestFilterBlock resultFilter))requestFilter;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSDictionary *params))params;</span><br><span class=\"line\">&#x2F;** block返回请求Id *&#x2F;</span><br><span class=\"line\">- (NSInteger (^)(DKHTTPResponseBlock responseBlock))execute;</span><br></pre></td></tr></table></figure>\n\n<p>使用起来感觉是这样子的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">           .url(@&quot;&quot;)</span><br><span class=\"line\">           .params(@&#123;@&quot;account&quot;:@&quot;m13643046965@163.com&quot;,@&quot;password&quot;:@&quot;123456&quot;&#125;)</span><br><span class=\"line\">           .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)</span><br><span class=\"line\">           .verifyParams(^NSString *(NSDictionary *params)&#123;</span><br><span class=\"line\">               return nil;</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">           .requestFilter(^DKRequest *(DKRequest *request)&#123;</span><br><span class=\"line\">               return request;</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">           .execute(^(DKResponse *response)&#123;</span><br><span class=\"line\">               NSLog(@&quot;%@&quot;,response.rawData);</span><br><span class=\"line\">           &#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>5.1</li>\n</ul>\n<p>开启/关闭 Log</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPSharedTool.showLog &#x3D; YES&#x2F;NO;</span><br></pre></td></tr></table></figure>\n\n<p>自定义 Logger</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKLog(...) NSLog(@&quot;%s %zd行 %@&quot;,__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])</span><br><span class=\"line\"></span><br><span class=\"line\">[DKHTTPTool setLogger:^(NSString *msg) &#123;</span><br><span class=\"line\">  DKLog(@&quot;%@&quot;,msg);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>RAC支持</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (RACSignal *(^)())executeSignal;</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *signal &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url()</span><br><span class=\"line\">                                        .header(@&#123;@&quot;token&quot;:@&quot;0e83179ac83741416e50b0ea12113f6e&quot;&#125;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;account&quot;:@&quot;&quot;,@&quot;password&quot;:@&quot;123456&quot;&#125;)</span><br><span class=\"line\">                                        .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)</span><br><span class=\"line\">                                        .verifyParams(^NSString *(NSDictionary *params)&#123;</span><br><span class=\"line\">                                        return nil;</span><br><span class=\"line\">                                        &#125;)</span><br><span class=\"line\">                                      .requestFilter(^DKRequest *(DKRequest *request)&#123;</span><br><span class=\"line\">                                        return request;</span><br><span class=\"line\">                                        &#125;)</span><br><span class=\"line\">                                      .executeSignal();</span><br><span class=\"line\">[signal subscribeNext:^(id x) &#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>5.2.1</li>\n</ul>\n<p>1.DKHTTPTool的链式调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]</span><br></pre></td></tr></table></figure>\n\n<p>使用方法和上面说的一样</p>\n<p>2.调试模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPSharedTool.debugMode &#x3D; YES; &#x2F;&#x2F; 开启 Log 和 服务器异常弹窗</span><br><span class=\"line\">如果服务器发生异常，那么就会发生如图情况</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/555.png?raw=true\"><br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/666.png?raw=true\"><br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/777.png?raw=true\"></p>\n","site":{"data":{}},"excerpt":"<p>网络层方法封装5.2.1</p>\n<ul>\n<li>特性<ul>\n<li>添加链式调用方法</li>\n</ul>\n</li>\n<li>5.1<ul>\n<li>开启/关闭 Log</li>\n<li>自定义 Logger</li>\n<li>RAC支持</li>\n</ul>\n</li>\n<li>5.2.1<ul>\n<li>修复了一些 bug</li>\n<li>由于服务器异常而返回的 NSData 转为 HTML 页面并展示出来（需要打开 DebugMode）</li>\n<li>把链式调用方法抽出为一个 DKHTTPChainTool 类</li>\n</ul>\n</li>\n</ul>","more":"<ol>\n<li>添加链式调用方法</li>\n</ol>\n<p>链式调用的好处就是要啥参数就添加啥,方便快捷,不用担心代码不够漂亮！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 链式调用 *&#x2F;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSString *method))method;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSString *url))url;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSDictionary *header))header;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKCacheStrategy strategy))cacheStrategy;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKHTTPParamsVarifyBlock paramsVerify))verifyParams;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(DKHTTPRequestFilterBlock resultFilter))requestFilter;</span><br><span class=\"line\">- (DKHTTPChainTool * (^)(NSDictionary *params))params;</span><br><span class=\"line\">&#x2F;** block返回请求Id *&#x2F;</span><br><span class=\"line\">- (NSInteger (^)(DKHTTPResponseBlock responseBlock))execute;</span><br></pre></td></tr></table></figure>\n\n<p>使用起来感觉是这样子的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">           .url(@&quot;&quot;)</span><br><span class=\"line\">           .params(@&#123;@&quot;account&quot;:@&quot;m13643046965@163.com&quot;,@&quot;password&quot;:@&quot;123456&quot;&#125;)</span><br><span class=\"line\">           .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)</span><br><span class=\"line\">           .verifyParams(^NSString *(NSDictionary *params)&#123;</span><br><span class=\"line\">               return nil;</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">           .requestFilter(^DKRequest *(DKRequest *request)&#123;</span><br><span class=\"line\">               return request;</span><br><span class=\"line\">           &#125;)</span><br><span class=\"line\">           .execute(^(DKResponse *response)&#123;</span><br><span class=\"line\">               NSLog(@&quot;%@&quot;,response.rawData);</span><br><span class=\"line\">           &#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>5.1</li>\n</ul>\n<p>开启/关闭 Log</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPSharedTool.showLog &#x3D; YES&#x2F;NO;</span><br></pre></td></tr></table></figure>\n\n<p>自定义 Logger</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKLog(...) NSLog(@&quot;%s %zd行 %@&quot;,__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])</span><br><span class=\"line\"></span><br><span class=\"line\">[DKHTTPTool setLogger:^(NSString *msg) &#123;</span><br><span class=\"line\">  DKLog(@&quot;%@&quot;,msg);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<p>RAC支持</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (RACSignal *(^)())executeSignal;</span><br></pre></td></tr></table></figure>\n\n<p>使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RACSignal *signal &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class=\"line\">                                        .url()</span><br><span class=\"line\">                                        .header(@&#123;@&quot;token&quot;:@&quot;0e83179ac83741416e50b0ea12113f6e&quot;&#125;)</span><br><span class=\"line\">                                        .params(@&#123;@&quot;account&quot;:@&quot;&quot;,@&quot;password&quot;:@&quot;123456&quot;&#125;)</span><br><span class=\"line\">                                        .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)</span><br><span class=\"line\">                                        .verifyParams(^NSString *(NSDictionary *params)&#123;</span><br><span class=\"line\">                                        return nil;</span><br><span class=\"line\">                                        &#125;)</span><br><span class=\"line\">                                      .requestFilter(^DKRequest *(DKRequest *request)&#123;</span><br><span class=\"line\">                                        return request;</span><br><span class=\"line\">                                        &#125;)</span><br><span class=\"line\">                                      .executeSignal();</span><br><span class=\"line\">[signal subscribeNext:^(id x) &#123;</span><br><span class=\"line\">    NSLog(@&quot;%@&quot;,x);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>5.2.1</li>\n</ul>\n<p>1.DKHTTPTool的链式调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]</span><br></pre></td></tr></table></figure>\n\n<p>使用方法和上面说的一样</p>\n<p>2.调试模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DKHTTPSharedTool.debugMode &#x3D; YES; &#x2F;&#x2F; 开启 Log 和 服务器异常弹窗</span><br><span class=\"line\">如果服务器发生异常，那么就会发生如图情况</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/555.png?raw=true\"><br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/666.png?raw=true\"><br><img src=\"https://github.com/Arc-lin/BlogImage/blob/master/777.png?raw=true\"></p>"},{"title":"网络层方法封装","author":"Arclin","abbrlink":"3d9cee8d","date":"2016-10-28T16:00:00.000Z","_content":"网络层的方法封装\n<!-- more -->\n\n## 特点\n - 集成AFNetworking\n - 集成MJExtension\n - 统一回调\n - 方便顶层调用\n - 统一错误处理\n - 适应接口设计\n\n## 设计（以POST和退出登录接口举例）\n1. 接口设计\n  ```\n  typedef void (^DKResponseBlock)(DKResponse *response);\n\n  + (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters success:(nonnull DKResponseBlock)callBack;\n  1.1 DKResponse 回调模型设计（根据接口进行设计）\n\n\n   #import <Foundation/Foundation.h>\n\n  @interface DKResponse : NSObject\n\n  /** state */\n  @property (nonatomic,copy) NSString *state;\n\n  /** result */\n  @property (nonatomic,copy) NSDictionary *result;\n\n  /** message */\n  @property (nonatomic,copy) NSString *message;\n\n  /** 纯数据 */\n  @property (nonatomic, strong) id rawData;\n\n  /** error */\n  @property (nonatomic,copy) NSError *error;\n\n  @end\n  ```\n2. 底层方法实现\n  ```\n  (DKConfiguration.h 或者使用 plist)\n   static NSString *kDKTimeoutInterval = 10.0f;\n   static NSString *kDKSuccessMessage = @\"success\";\n\n  + (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters callBack:(nonnull DKResponseBlock)callBack {\n      AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n      mgr.requestSerializer.timeoutInterval = kDKTimeoutInterval;\n      [mgr POST:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n          DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject]; // 转为响应信息模型\n          resp.rawData = responseObject; // 储存源数据\n          if(callBack){\n              if (![resp.message isEqualToString:kDKSuccessMessage]) { // 判断是否是成功的\n                  resp.error = [NSError errorWithDomain:@\"dankal.cn\" code:[resp.state integerValue] userInfo:@{@\"message\":resp.message}]; // 生成错误对象\n                  callBack(resp);\n              }else{\n                  callBack(resp); // 没有错误直接返回\n              }\n          }\n\n      } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n          DKLog(@\"%@\",error);\n          DKResponse *response = [[DKResponse alloc] init]; // 随便看看\n          response.error = error;\n          if(callBack){\n              callBack(response);\n          }\n      }];\n  }\n  ```\n3. 业务层接口设计\n  ```\n  (DKLogin.h)\n  typedef void (^DKBlockSuccessOrError)(BOOL isSuccessful,NSError *error);\n  // 其他需求可以定制其他回调，如下\n  typedef void (^DKArrayResultBlock)(NSArray *result,NSError *error);\n  typedef void (^DKIntegerResultBlock)(NSInteger number, NSError *error) ;\n  typedef void (^DKUserResultBlock)(DKUser *user, NSError *error); // DKUser为模型\n\n  + (void)logout:(DKBlockSuccessOrError)callBack;\n  ```\n4. 业务层接口实现\n  ```\n  + (void)logout:(DKBlockSuccessOrError)callBack\n  {\n      NSString *url = @\"xxxx\";\n      NSDictionary *params = @{@\"xxx\":@\"xxx\"};\n      [DKHTTPTool POST:url parameters:params success:^(DKResponse *response) {\n          if (callBack) {\n            response.error ? callBack(NO,response.error) : callBack(YES,nil);\n          }\n       }];\n   }\n  ```\n5. ViewModel 或 ViewController 调用\n  ```\n  [DKLoginService logout:^(BOOL isSuccess,NSError *error){\n      if(isSuccess){\n\n      }else{\n\n      }\n  }];\n  ```","source":"_posts/网络层方法封装.md","raw":"---\ntitle: 网络层方法封装\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 3d9cee8d\ndate: 2016-10-29 00:00:00\n---\n网络层的方法封装\n<!-- more -->\n\n## 特点\n - 集成AFNetworking\n - 集成MJExtension\n - 统一回调\n - 方便顶层调用\n - 统一错误处理\n - 适应接口设计\n\n## 设计（以POST和退出登录接口举例）\n1. 接口设计\n  ```\n  typedef void (^DKResponseBlock)(DKResponse *response);\n\n  + (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters success:(nonnull DKResponseBlock)callBack;\n  1.1 DKResponse 回调模型设计（根据接口进行设计）\n\n\n   #import <Foundation/Foundation.h>\n\n  @interface DKResponse : NSObject\n\n  /** state */\n  @property (nonatomic,copy) NSString *state;\n\n  /** result */\n  @property (nonatomic,copy) NSDictionary *result;\n\n  /** message */\n  @property (nonatomic,copy) NSString *message;\n\n  /** 纯数据 */\n  @property (nonatomic, strong) id rawData;\n\n  /** error */\n  @property (nonatomic,copy) NSError *error;\n\n  @end\n  ```\n2. 底层方法实现\n  ```\n  (DKConfiguration.h 或者使用 plist)\n   static NSString *kDKTimeoutInterval = 10.0f;\n   static NSString *kDKSuccessMessage = @\"success\";\n\n  + (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters callBack:(nonnull DKResponseBlock)callBack {\n      AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];\n      mgr.requestSerializer.timeoutInterval = kDKTimeoutInterval;\n      [mgr POST:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n          DKResponse *resp = [DKResponse mj_objectWithKeyValues:responseObject]; // 转为响应信息模型\n          resp.rawData = responseObject; // 储存源数据\n          if(callBack){\n              if (![resp.message isEqualToString:kDKSuccessMessage]) { // 判断是否是成功的\n                  resp.error = [NSError errorWithDomain:@\"dankal.cn\" code:[resp.state integerValue] userInfo:@{@\"message\":resp.message}]; // 生成错误对象\n                  callBack(resp);\n              }else{\n                  callBack(resp); // 没有错误直接返回\n              }\n          }\n\n      } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n          DKLog(@\"%@\",error);\n          DKResponse *response = [[DKResponse alloc] init]; // 随便看看\n          response.error = error;\n          if(callBack){\n              callBack(response);\n          }\n      }];\n  }\n  ```\n3. 业务层接口设计\n  ```\n  (DKLogin.h)\n  typedef void (^DKBlockSuccessOrError)(BOOL isSuccessful,NSError *error);\n  // 其他需求可以定制其他回调，如下\n  typedef void (^DKArrayResultBlock)(NSArray *result,NSError *error);\n  typedef void (^DKIntegerResultBlock)(NSInteger number, NSError *error) ;\n  typedef void (^DKUserResultBlock)(DKUser *user, NSError *error); // DKUser为模型\n\n  + (void)logout:(DKBlockSuccessOrError)callBack;\n  ```\n4. 业务层接口实现\n  ```\n  + (void)logout:(DKBlockSuccessOrError)callBack\n  {\n      NSString *url = @\"xxxx\";\n      NSDictionary *params = @{@\"xxx\":@\"xxx\"};\n      [DKHTTPTool POST:url parameters:params success:^(DKResponse *response) {\n          if (callBack) {\n            response.error ? callBack(NO,response.error) : callBack(YES,nil);\n          }\n       }];\n   }\n  ```\n5. ViewModel 或 ViewController 调用\n  ```\n  [DKLoginService logout:^(BOOL isSuccess,NSError *error){\n      if(isSuccess){\n\n      }else{\n\n      }\n  }];\n  ```","slug":"网络层方法封装","published":1,"updated":"2021-04-12T06:07:04.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog6s006e45n0634764mp","content":"<p>网络层的方法封装</p>\n<span id=\"more\"></span>\n\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>集成AFNetworking</li>\n<li>集成MJExtension</li>\n<li>统一回调</li>\n<li>方便顶层调用</li>\n<li>统一错误处理</li>\n<li>适应接口设计</li>\n</ul>\n<h2 id=\"设计（以POST和退出登录接口举例）\"><a href=\"#设计（以POST和退出登录接口举例）\" class=\"headerlink\" title=\"设计（以POST和退出登录接口举例）\"></a>设计（以POST和退出登录接口举例）</h2><ol>\n<li>接口设计<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef void (^DKResponseBlock)(DKResponse *response);</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters success:(nonnull DKResponseBlock)callBack;</span><br><span class=\"line\">1.1 DKResponse 回调模型设计（根据接口进行设计）</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> #import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface DKResponse : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** state *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSString *state;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** result *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSDictionary *result;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** message *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSString *message;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 纯数据 *&#x2F;</span><br><span class=\"line\">@property (nonatomic, strong) id rawData;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** error *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSError *error;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></li>\n<li>底层方法实现<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(DKConfiguration.h 或者使用 plist)</span><br><span class=\"line\"> static NSString *kDKTimeoutInterval &#x3D; 10.0f;</span><br><span class=\"line\"> static NSString *kDKSuccessMessage &#x3D; @&quot;success&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters callBack:(nonnull DKResponseBlock)callBack &#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];</span><br><span class=\"line\">    mgr.requestSerializer.timeoutInterval &#x3D; kDKTimeoutInterval;</span><br><span class=\"line\">    [mgr POST:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject]; &#x2F;&#x2F; 转为响应信息模型</span><br><span class=\"line\">        resp.rawData &#x3D; responseObject; &#x2F;&#x2F; 储存源数据</span><br><span class=\"line\">        if(callBack)&#123;</span><br><span class=\"line\">            if (![resp.message isEqualToString:kDKSuccessMessage]) &#123; &#x2F;&#x2F; 判断是否是成功的</span><br><span class=\"line\">                resp.error &#x3D; [NSError errorWithDomain:@&quot;dankal.cn&quot; code:[resp.state integerValue] userInfo:@&#123;@&quot;message&quot;:resp.message&#125;]; &#x2F;&#x2F; 生成错误对象</span><br><span class=\"line\">                callBack(resp);</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                callBack(resp); &#x2F;&#x2F; 没有错误直接返回</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">        DKResponse *response &#x3D; [[DKResponse alloc] init]; &#x2F;&#x2F; 随便看看</span><br><span class=\"line\">        response.error &#x3D; error;</span><br><span class=\"line\">        if(callBack)&#123;</span><br><span class=\"line\">            callBack(response);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>业务层接口设计<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(DKLogin.h)</span><br><span class=\"line\">typedef void (^DKBlockSuccessOrError)(BOOL isSuccessful,NSError *error);</span><br><span class=\"line\">&#x2F;&#x2F; 其他需求可以定制其他回调，如下</span><br><span class=\"line\">typedef void (^DKArrayResultBlock)(NSArray *result,NSError *error);</span><br><span class=\"line\">typedef void (^DKIntegerResultBlock)(NSInteger number, NSError *error) ;</span><br><span class=\"line\">typedef void (^DKUserResultBlock)(DKUser *user, NSError *error); &#x2F;&#x2F; DKUser为模型</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)logout:(DKBlockSuccessOrError)callBack;</span><br></pre></td></tr></table></figure></li>\n<li>业务层接口实现<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)logout:(DKBlockSuccessOrError)callBack</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSString *url &#x3D; @&quot;xxxx&quot;;</span><br><span class=\"line\">    NSDictionary *params &#x3D; @&#123;@&quot;xxx&quot;:@&quot;xxx&quot;&#125;;</span><br><span class=\"line\">    [DKHTTPTool POST:url parameters:params success:^(DKResponse *response) &#123;</span><br><span class=\"line\">        if (callBack) &#123;</span><br><span class=\"line\">          response.error ? callBack(NO,response.error) : callBack(YES,nil);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;];</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></li>\n<li>ViewModel 或 ViewController 调用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKLoginService logout:^(BOOL isSuccess,NSError *error)&#123;</span><br><span class=\"line\">    if(isSuccess)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>网络层的方法封装</p>","more":"<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>集成AFNetworking</li>\n<li>集成MJExtension</li>\n<li>统一回调</li>\n<li>方便顶层调用</li>\n<li>统一错误处理</li>\n<li>适应接口设计</li>\n</ul>\n<h2 id=\"设计（以POST和退出登录接口举例）\"><a href=\"#设计（以POST和退出登录接口举例）\" class=\"headerlink\" title=\"设计（以POST和退出登录接口举例）\"></a>设计（以POST和退出登录接口举例）</h2><ol>\n<li>接口设计<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef void (^DKResponseBlock)(DKResponse *response);</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters success:(nonnull DKResponseBlock)callBack;</span><br><span class=\"line\">1.1 DKResponse 回调模型设计（根据接口进行设计）</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"> #import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">@interface DKResponse : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** state *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSString *state;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** result *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSDictionary *result;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** message *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSString *message;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 纯数据 *&#x2F;</span><br><span class=\"line\">@property (nonatomic, strong) id rawData;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** error *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSError *error;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure></li>\n<li>底层方法实现<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(DKConfiguration.h 或者使用 plist)</span><br><span class=\"line\"> static NSString *kDKTimeoutInterval &#x3D; 10.0f;</span><br><span class=\"line\"> static NSString *kDKSuccessMessage &#x3D; @&quot;success&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters callBack:(nonnull DKResponseBlock)callBack &#123;</span><br><span class=\"line\">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];</span><br><span class=\"line\">    mgr.requestSerializer.timeoutInterval &#x3D; kDKTimeoutInterval;</span><br><span class=\"line\">    [mgr POST:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class=\"line\">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject]; &#x2F;&#x2F; 转为响应信息模型</span><br><span class=\"line\">        resp.rawData &#x3D; responseObject; &#x2F;&#x2F; 储存源数据</span><br><span class=\"line\">        if(callBack)&#123;</span><br><span class=\"line\">            if (![resp.message isEqualToString:kDKSuccessMessage]) &#123; &#x2F;&#x2F; 判断是否是成功的</span><br><span class=\"line\">                resp.error &#x3D; [NSError errorWithDomain:@&quot;dankal.cn&quot; code:[resp.state integerValue] userInfo:@&#123;@&quot;message&quot;:resp.message&#125;]; &#x2F;&#x2F; 生成错误对象</span><br><span class=\"line\">                callBack(resp);</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                callBack(resp); &#x2F;&#x2F; 没有错误直接返回</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class=\"line\">        DKLog(@&quot;%@&quot;,error);</span><br><span class=\"line\">        DKResponse *response &#x3D; [[DKResponse alloc] init]; &#x2F;&#x2F; 随便看看</span><br><span class=\"line\">        response.error &#x3D; error;</span><br><span class=\"line\">        if(callBack)&#123;</span><br><span class=\"line\">            callBack(response);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>业务层接口设计<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(DKLogin.h)</span><br><span class=\"line\">typedef void (^DKBlockSuccessOrError)(BOOL isSuccessful,NSError *error);</span><br><span class=\"line\">&#x2F;&#x2F; 其他需求可以定制其他回调，如下</span><br><span class=\"line\">typedef void (^DKArrayResultBlock)(NSArray *result,NSError *error);</span><br><span class=\"line\">typedef void (^DKIntegerResultBlock)(NSInteger number, NSError *error) ;</span><br><span class=\"line\">typedef void (^DKUserResultBlock)(DKUser *user, NSError *error); &#x2F;&#x2F; DKUser为模型</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)logout:(DKBlockSuccessOrError)callBack;</span><br></pre></td></tr></table></figure></li>\n<li>业务层接口实现<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)logout:(DKBlockSuccessOrError)callBack</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSString *url &#x3D; @&quot;xxxx&quot;;</span><br><span class=\"line\">    NSDictionary *params &#x3D; @&#123;@&quot;xxx&quot;:@&quot;xxx&quot;&#125;;</span><br><span class=\"line\">    [DKHTTPTool POST:url parameters:params success:^(DKResponse *response) &#123;</span><br><span class=\"line\">        if (callBack) &#123;</span><br><span class=\"line\">          response.error ? callBack(NO,response.error) : callBack(YES,nil);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;];</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></li>\n<li>ViewModel 或 ViewController 调用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[DKLoginService logout:^(BOOL isSuccess,NSError *error)&#123;</span><br><span class=\"line\">    if(isSuccess)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure></li>\n</ol>"},{"title":"解决git status中文问题","author":"Arclin","abbrlink":"93da1b70","date":"2017-08-07T16:00:00.000Z","_content":"在中文情况下`git status`是 `\\344\\272\\247\\345\\223\\201\\351\\234\\200\\346\\261\\202` 差不多这样的。\n\n解决这个问题方法是：\n\n`git config --global core.quotepath false`","source":"_posts/解决git-status中文问题.md","raw":"---\ntitle: 解决git status中文问题\nauthor: Arclin\ntags:\n  - 技巧\n  - Git\ncategories:\n  - Git\nabbrlink: 93da1b70\ndate: 2017-08-08 00:00:00\n---\n在中文情况下`git status`是 `\\344\\272\\247\\345\\223\\201\\351\\234\\200\\346\\261\\202` 差不多这样的。\n\n解决这个问题方法是：\n\n`git config --global core.quotepath false`","slug":"解决git-status中文问题","published":1,"updated":"2021-04-19T02:19:24.821Z","_id":"cknndog6s006h45n03a297u3s","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在中文情况下<code>git status</code>是 <code>\\344\\272\\247\\345\\223\\201\\351\\234\\200\\346\\261\\202</code> 差不多这样的。</p>\n<p>解决这个问题方法是：</p>\n<p><code>git config --global core.quotepath false</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在中文情况下<code>git status</code>是 <code>\\344\\272\\247\\345\\223\\201\\351\\234\\200\\346\\261\\202</code> 差不多这样的。</p>\n<p>解决这个问题方法是：</p>\n<p><code>git config --global core.quotepath false</code></p>\n"},{"title":"网络层方法封装4","author":"Arclin","abbrlink":"6082784b","date":"2016-12-14T16:00:00.000Z","_content":"网络层方法封装4\n<!-- more -->\n\n- 新增特性:\n   - 拦截器和验证器\n   - 封装请求对象\n   \n1. 说明\n\n  拦截器顾名思义就是在请求发送之前拦截请求，拦截到的请求可以进行修改之后进行发送，或者阻止请求的发送。可以用于添加分页参数之类的需求。\n\n  验证器指的是验证参数（验证结果的方法后面再补充），验证参数主要用于判断输入参数的合法性，如果验证不通过则可以返回一个错误信息，由请求方法抛出错误，如果验证通过那就返回一个 nil就可以了。\n\n2. 代码\n\n  先说说请求对象模型\n\n  ```\n  @interface DKRequest : NSObject\n\n  /** 请求地址 */\n  @property (nonatomic,copy) NSString * urlStr;\n\n  /** 请求方法 */\n  @property (nonatomic,copy) NSString * method;\n\n  /** 请求参数 */\n  @property (nonatomic,strong) NSDictionary *params;\n\n  /** 请求头 */\n  @property (nonatomic,strong) NSDictionary *header;\n\n  /** 缓存策略 */\n  @property (nonatomic,assign) DKCacheStrategy cacheStrategy;\n\n  /** 请求回调 */\n  @property (nonatomic,copy) DKHTTPResponseBlock responseBlock;\n\n  + (instancetype)requestWithUrlStr:(NSString *)urlStr method:(NSString *)method header:(NSDictionary *)header params:(NSDictionary *)params strategy:(DKCacheStrategy)strategy;\n  @end\n  ```\n\n  完整的接口示例\n\n  ```\n  /**\n   发送HTTP请求\n\n   @param method 请求方法,你可以写@\"get\"或者@\"post\"(不区分大小写)或者已经定义好的 kGET 或 kPOST\n   @param strategy 缓存策略\n   @param URLString 请求地址\n   @param header 请求头,可为空\n   @param params 请求参数,可为空\n   @param filterBlock  拦截器\n   @param verifyBlock 验证参数\n   @param block 回调\n   @return 请求 Id\n   */\n  - (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params filter:(DKHTTPRequestFilterBlock)filterBlock verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock responseBlock:(DKHTTPResponseBlock)block;\n  ```\n\n  拦截器的 block\n  给你一个对象，你可以修改这个对象然后返回回去\n\n  ```\n  typedef DKRequest *(^DKHTTPRequestFilterBlock)(DKRequest *request);\n  ```\n\n  验证器的 block\n  给你参数，验证参数后你可以返回一个验证不通过的错误信息，也可以返回空表示验证通过\n\n  ```\n  typedef NSString *(^DKHTTPParamsVarifyBlock)(NSDictionary *params);\n  ```\n\n3. 关于验证参数\n\n\t如果只是想单纯地验证参数是否是全部不为空(这里指空字符串，并不是nil,因为nil根本插不进字典)，那这里也提供了一个宏可以快速实现。\n    ```\n    /** 验证参数是否全部不为空 有空值的话会返回错误 */\n    @property (nonatomic,copy) DKHTTPParamsVarifyBlock verifyIsAllNonNullBlock;\n    ```\n  \n4. 关于过滤（验证）响应体\n  过滤响应体主要是为了防止错误的数据传回到 Service层，比如一些JSON 串解析后会传回 NSNull之类的恶心东西，如果误当做字符串操作的话会导致程序崩溃。不过因为 MJExtension 框架里面已经做了之类的处理，所以如果使用了MJExtension 框架的话，一般来说是不会出现问题，所以这个过滤方法作为单例的成员属性加入,设计为全局作用！\n  传给你一个 DKResponse, 你可以经过处理之后返回一个想要的 DKResponse\n\n  ```\n  /** 过滤响应体 */\n  @property (nonatomic,copy) DKHTTPResultFilterBlock resultFilterBlock;\n  ```\n\n今天逼哥放我假，所以我就写了这个.就这样子,demo我还是放在这里\n\n","source":"_posts/网络层方法封装4.md","raw":"---\ntitle: 网络层方法封装4\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 6082784b\ndate: 2016-12-15 00:00:00\n---\n网络层方法封装4\n<!-- more -->\n\n- 新增特性:\n   - 拦截器和验证器\n   - 封装请求对象\n   \n1. 说明\n\n  拦截器顾名思义就是在请求发送之前拦截请求，拦截到的请求可以进行修改之后进行发送，或者阻止请求的发送。可以用于添加分页参数之类的需求。\n\n  验证器指的是验证参数（验证结果的方法后面再补充），验证参数主要用于判断输入参数的合法性，如果验证不通过则可以返回一个错误信息，由请求方法抛出错误，如果验证通过那就返回一个 nil就可以了。\n\n2. 代码\n\n  先说说请求对象模型\n\n  ```\n  @interface DKRequest : NSObject\n\n  /** 请求地址 */\n  @property (nonatomic,copy) NSString * urlStr;\n\n  /** 请求方法 */\n  @property (nonatomic,copy) NSString * method;\n\n  /** 请求参数 */\n  @property (nonatomic,strong) NSDictionary *params;\n\n  /** 请求头 */\n  @property (nonatomic,strong) NSDictionary *header;\n\n  /** 缓存策略 */\n  @property (nonatomic,assign) DKCacheStrategy cacheStrategy;\n\n  /** 请求回调 */\n  @property (nonatomic,copy) DKHTTPResponseBlock responseBlock;\n\n  + (instancetype)requestWithUrlStr:(NSString *)urlStr method:(NSString *)method header:(NSDictionary *)header params:(NSDictionary *)params strategy:(DKCacheStrategy)strategy;\n  @end\n  ```\n\n  完整的接口示例\n\n  ```\n  /**\n   发送HTTP请求\n\n   @param method 请求方法,你可以写@\"get\"或者@\"post\"(不区分大小写)或者已经定义好的 kGET 或 kPOST\n   @param strategy 缓存策略\n   @param URLString 请求地址\n   @param header 请求头,可为空\n   @param params 请求参数,可为空\n   @param filterBlock  拦截器\n   @param verifyBlock 验证参数\n   @param block 回调\n   @return 请求 Id\n   */\n  - (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params filter:(DKHTTPRequestFilterBlock)filterBlock verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock responseBlock:(DKHTTPResponseBlock)block;\n  ```\n\n  拦截器的 block\n  给你一个对象，你可以修改这个对象然后返回回去\n\n  ```\n  typedef DKRequest *(^DKHTTPRequestFilterBlock)(DKRequest *request);\n  ```\n\n  验证器的 block\n  给你参数，验证参数后你可以返回一个验证不通过的错误信息，也可以返回空表示验证通过\n\n  ```\n  typedef NSString *(^DKHTTPParamsVarifyBlock)(NSDictionary *params);\n  ```\n\n3. 关于验证参数\n\n\t如果只是想单纯地验证参数是否是全部不为空(这里指空字符串，并不是nil,因为nil根本插不进字典)，那这里也提供了一个宏可以快速实现。\n    ```\n    /** 验证参数是否全部不为空 有空值的话会返回错误 */\n    @property (nonatomic,copy) DKHTTPParamsVarifyBlock verifyIsAllNonNullBlock;\n    ```\n  \n4. 关于过滤（验证）响应体\n  过滤响应体主要是为了防止错误的数据传回到 Service层，比如一些JSON 串解析后会传回 NSNull之类的恶心东西，如果误当做字符串操作的话会导致程序崩溃。不过因为 MJExtension 框架里面已经做了之类的处理，所以如果使用了MJExtension 框架的话，一般来说是不会出现问题，所以这个过滤方法作为单例的成员属性加入,设计为全局作用！\n  传给你一个 DKResponse, 你可以经过处理之后返回一个想要的 DKResponse\n\n  ```\n  /** 过滤响应体 */\n  @property (nonatomic,copy) DKHTTPResultFilterBlock resultFilterBlock;\n  ```\n\n今天逼哥放我假，所以我就写了这个.就这样子,demo我还是放在这里\n\n","slug":"网络层方法封装4","published":1,"updated":"2021-04-12T06:07:04.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog6t006l45n004le55zr","content":"<p>网络层方法封装4</p>\n<span id=\"more\"></span>\n\n<ul>\n<li>新增特性:<ul>\n<li>拦截器和验证器</li>\n<li>封装请求对象</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>说明</li>\n</ol>\n<p>  拦截器顾名思义就是在请求发送之前拦截请求，拦截到的请求可以进行修改之后进行发送，或者阻止请求的发送。可以用于添加分页参数之类的需求。</p>\n<p>  验证器指的是验证参数（验证结果的方法后面再补充），验证参数主要用于判断输入参数的合法性，如果验证不通过则可以返回一个错误信息，由请求方法抛出错误，如果验证通过那就返回一个 nil就可以了。</p>\n<ol start=\"2\">\n<li>代码</li>\n</ol>\n<p>  先说说请求对象模型</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface DKRequest : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求地址 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSString * urlStr;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求方法 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSString * method;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求参数 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,strong) NSDictionary *params;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求头 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,strong) NSDictionary *header;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 缓存策略 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,assign) DKCacheStrategy cacheStrategy;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求回调 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPResponseBlock responseBlock;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)requestWithUrlStr:(NSString *)urlStr method:(NSString *)method header:(NSDictionary *)header params:(NSDictionary *)params strategy:(DKCacheStrategy)strategy;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>  完整的接口示例</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> 发送HTTP请求</span><br><span class=\"line\"></span><br><span class=\"line\"> @param method 请求方法,你可以写@&quot;get&quot;或者@&quot;post&quot;(不区分大小写)或者已经定义好的 kGET 或 kPOST</span><br><span class=\"line\"> @param strategy 缓存策略</span><br><span class=\"line\"> @param URLString 请求地址</span><br><span class=\"line\"> @param header 请求头,可为空</span><br><span class=\"line\"> @param params 请求参数,可为空</span><br><span class=\"line\"> @param filterBlock  拦截器</span><br><span class=\"line\"> @param verifyBlock 验证参数</span><br><span class=\"line\"> @param block 回调</span><br><span class=\"line\"> @return 请求 Id</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params filter:(DKHTTPRequestFilterBlock)filterBlock verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n\n<p>  拦截器的 block<br>  给你一个对象，你可以修改这个对象然后返回回去</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef DKRequest *(^DKHTTPRequestFilterBlock)(DKRequest *request);</span><br></pre></td></tr></table></figure>\n\n<p>  验证器的 block<br>  给你参数，验证参数后你可以返回一个验证不通过的错误信息，也可以返回空表示验证通过</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NSString *(^DKHTTPParamsVarifyBlock)(NSDictionary *params);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>关于验证参数</p>\n<p> 如果只是想单纯地验证参数是否是全部不为空(这里指空字符串，并不是nil,因为nil根本插不进字典)，那这里也提供了一个宏可以快速实现。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 验证参数是否全部不为空 有空值的话会返回错误 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPParamsVarifyBlock verifyIsAllNonNullBlock;</span><br></pre></td></tr></table></figure></li>\n<li><p>关于过滤（验证）响应体<br>过滤响应体主要是为了防止错误的数据传回到 Service层，比如一些JSON 串解析后会传回 NSNull之类的恶心东西，如果误当做字符串操作的话会导致程序崩溃。不过因为 MJExtension 框架里面已经做了之类的处理，所以如果使用了MJExtension 框架的话，一般来说是不会出现问题，所以这个过滤方法作为单例的成员属性加入,设计为全局作用！<br>传给你一个 DKResponse, 你可以经过处理之后返回一个想要的 DKResponse</p>\n</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 过滤响应体 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPResultFilterBlock resultFilterBlock;</span><br></pre></td></tr></table></figure>\n\n<p>今天逼哥放我假，所以我就写了这个.就这样子,demo我还是放在这里</p>\n","site":{"data":{}},"excerpt":"<p>网络层方法封装4</p>","more":"<ul>\n<li>新增特性:<ul>\n<li>拦截器和验证器</li>\n<li>封装请求对象</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>说明</li>\n</ol>\n<p>  拦截器顾名思义就是在请求发送之前拦截请求，拦截到的请求可以进行修改之后进行发送，或者阻止请求的发送。可以用于添加分页参数之类的需求。</p>\n<p>  验证器指的是验证参数（验证结果的方法后面再补充），验证参数主要用于判断输入参数的合法性，如果验证不通过则可以返回一个错误信息，由请求方法抛出错误，如果验证通过那就返回一个 nil就可以了。</p>\n<ol start=\"2\">\n<li>代码</li>\n</ol>\n<p>  先说说请求对象模型</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface DKRequest : NSObject</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求地址 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSString * urlStr;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求方法 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) NSString * method;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求参数 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,strong) NSDictionary *params;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求头 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,strong) NSDictionary *header;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 缓存策略 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,assign) DKCacheStrategy cacheStrategy;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;** 请求回调 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPResponseBlock responseBlock;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (instancetype)requestWithUrlStr:(NSString *)urlStr method:(NSString *)method header:(NSDictionary *)header params:(NSDictionary *)params strategy:(DKCacheStrategy)strategy;</span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n\n<p>  完整的接口示例</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> 发送HTTP请求</span><br><span class=\"line\"></span><br><span class=\"line\"> @param method 请求方法,你可以写@&quot;get&quot;或者@&quot;post&quot;(不区分大小写)或者已经定义好的 kGET 或 kPOST</span><br><span class=\"line\"> @param strategy 缓存策略</span><br><span class=\"line\"> @param URLString 请求地址</span><br><span class=\"line\"> @param header 请求头,可为空</span><br><span class=\"line\"> @param params 请求参数,可为空</span><br><span class=\"line\"> @param filterBlock  拦截器</span><br><span class=\"line\"> @param verifyBlock 验证参数</span><br><span class=\"line\"> @param block 回调</span><br><span class=\"line\"> @return 请求 Id</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params filter:(DKHTTPRequestFilterBlock)filterBlock verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>\n\n<p>  拦截器的 block<br>  给你一个对象，你可以修改这个对象然后返回回去</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef DKRequest *(^DKHTTPRequestFilterBlock)(DKRequest *request);</span><br></pre></td></tr></table></figure>\n\n<p>  验证器的 block<br>  给你参数，验证参数后你可以返回一个验证不通过的错误信息，也可以返回空表示验证通过</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NSString *(^DKHTTPParamsVarifyBlock)(NSDictionary *params);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>关于验证参数</p>\n<p> 如果只是想单纯地验证参数是否是全部不为空(这里指空字符串，并不是nil,因为nil根本插不进字典)，那这里也提供了一个宏可以快速实现。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 验证参数是否全部不为空 有空值的话会返回错误 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPParamsVarifyBlock verifyIsAllNonNullBlock;</span><br></pre></td></tr></table></figure></li>\n<li><p>关于过滤（验证）响应体<br>过滤响应体主要是为了防止错误的数据传回到 Service层，比如一些JSON 串解析后会传回 NSNull之类的恶心东西，如果误当做字符串操作的话会导致程序崩溃。不过因为 MJExtension 框架里面已经做了之类的处理，所以如果使用了MJExtension 框架的话，一般来说是不会出现问题，所以这个过滤方法作为单例的成员属性加入,设计为全局作用！<br>传给你一个 DKResponse, 你可以经过处理之后返回一个想要的 DKResponse</p>\n</li>\n</ol>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;** 过滤响应体 *&#x2F;</span><br><span class=\"line\">@property (nonatomic,copy) DKHTTPResultFilterBlock resultFilterBlock;</span><br></pre></td></tr></table></figure>\n\n<p>今天逼哥放我假，所以我就写了这个.就这样子,demo我还是放在这里</p>"},{"title":"记录一些关于iOS的一些小技巧","author":"Arclin","abbrlink":"1b8f24c7","date":"2016-06-11T16:30:00.000Z","_content":"记录一些关于iOS的一些小技巧\n\n<!-- more -->\n\nXCode Profile 的路径\nxcode5 provisioning profile path： \n`~/Library/MobileDevice/Provisioning Profiles`\n\n在升级XCode7.0使用UICollectionViewLayout进行自定义布局时，调试台会出现以下的警告打印。\n\n```\nUICollectionViewFlowLayout has cached frame mismatch for index path {length = 2, path = 0 - 0} - cached value: {{122, 15}, {170, 170}}; expected value: {{157, 50}, {100, 100}} \nThis is likely occurring because the flow layout subclass LineLayout is modifying attributes returned by UICollectionViewFlowLayout without copying them\n```\n\n这个警告来源主要是在使用layoutAttributesForElementsInRect：方法返回的数组时，没有使用该数组的拷贝对象，而是直接使用了该数组。解决办法对该数组进行拷贝，并且是深拷贝。拷贝代码如下：\n\n```\n- (NSArray *)deepCopyWithArray:(NSArray *)array\n{\n    NSMutableArray *copys = [NSMutableArray arrayWithCapacity:array.count];\n\n    for (UICollectionViewLayoutAttributes *attris in array) {\n        [copys addObject:[attris copy]];\n    }\n    return copys;\n}\n```\n\n将layoutAttributesForElementsInRect：方法返回的数组扔到这个方法中，并且使用返回后的数组就行了。\n\n- 在navigationController中插入ScrollView后，scrollView的ContentInset的值发生了变化\n\n\t- 解决： self.automaticallyAdjustsScrollViewInsets = NO;\n\t- 原因： self.automaticallyAdjustsScrollViewInsets 默认值是YES，选择YES表示你允许视图控制器调整它内部插入的滑动视图来应对状态栏，导航栏，工具栏，和标签栏所消耗的屏幕区域。如果你设置为NO呢，就代表呀你要自己调整你插入的滑动视图，比如你的视图层次里面有多于一个的滑动视图。\n这大概是个什么意思呢，就是你的视图控制器在没经你允许的情况下调整你的控件位置了","source":"_posts/记录一些关于iOS的一些小技巧.md","raw":"---\ntitle: 记录一些关于iOS的一些小技巧\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: 1b8f24c7\ndate: 2016-06-12 00:30:00\n---\n记录一些关于iOS的一些小技巧\n\n<!-- more -->\n\nXCode Profile 的路径\nxcode5 provisioning profile path： \n`~/Library/MobileDevice/Provisioning Profiles`\n\n在升级XCode7.0使用UICollectionViewLayout进行自定义布局时，调试台会出现以下的警告打印。\n\n```\nUICollectionViewFlowLayout has cached frame mismatch for index path {length = 2, path = 0 - 0} - cached value: {{122, 15}, {170, 170}}; expected value: {{157, 50}, {100, 100}} \nThis is likely occurring because the flow layout subclass LineLayout is modifying attributes returned by UICollectionViewFlowLayout without copying them\n```\n\n这个警告来源主要是在使用layoutAttributesForElementsInRect：方法返回的数组时，没有使用该数组的拷贝对象，而是直接使用了该数组。解决办法对该数组进行拷贝，并且是深拷贝。拷贝代码如下：\n\n```\n- (NSArray *)deepCopyWithArray:(NSArray *)array\n{\n    NSMutableArray *copys = [NSMutableArray arrayWithCapacity:array.count];\n\n    for (UICollectionViewLayoutAttributes *attris in array) {\n        [copys addObject:[attris copy]];\n    }\n    return copys;\n}\n```\n\n将layoutAttributesForElementsInRect：方法返回的数组扔到这个方法中，并且使用返回后的数组就行了。\n\n- 在navigationController中插入ScrollView后，scrollView的ContentInset的值发生了变化\n\n\t- 解决： self.automaticallyAdjustsScrollViewInsets = NO;\n\t- 原因： self.automaticallyAdjustsScrollViewInsets 默认值是YES，选择YES表示你允许视图控制器调整它内部插入的滑动视图来应对状态栏，导航栏，工具栏，和标签栏所消耗的屏幕区域。如果你设置为NO呢，就代表呀你要自己调整你插入的滑动视图，比如你的视图层次里面有多于一个的滑动视图。\n这大概是个什么意思呢，就是你的视图控制器在没经你允许的情况下调整你的控件位置了","slug":"记录一些关于iOS的一些小技巧","published":1,"updated":"2021-04-12T06:07:04.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog6t006p45n06rxy2meg","content":"<p>记录一些关于iOS的一些小技巧</p>\n<span id=\"more\"></span>\n\n<p>XCode Profile 的路径<br>xcode5 provisioning profile path：<br><code>~/Library/MobileDevice/Provisioning Profiles</code></p>\n<p>在升级XCode7.0使用UICollectionViewLayout进行自定义布局时，调试台会出现以下的警告打印。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UICollectionViewFlowLayout has cached frame mismatch for index path &#123;length &#x3D; 2, path &#x3D; 0 - 0&#125; - cached value: &#123;&#123;122, 15&#125;, &#123;170, 170&#125;&#125;; expected value: &#123;&#123;157, 50&#125;, &#123;100, 100&#125;&#125; </span><br><span class=\"line\">This is likely occurring because the flow layout subclass LineLayout is modifying attributes returned by UICollectionViewFlowLayout without copying them</span><br></pre></td></tr></table></figure>\n\n<p>这个警告来源主要是在使用layoutAttributesForElementsInRect：方法返回的数组时，没有使用该数组的拷贝对象，而是直接使用了该数组。解决办法对该数组进行拷贝，并且是深拷贝。拷贝代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)deepCopyWithArray:(NSArray *)array</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSMutableArray *copys &#x3D; [NSMutableArray arrayWithCapacity:array.count];</span><br><span class=\"line\"></span><br><span class=\"line\">    for (UICollectionViewLayoutAttributes *attris in array) &#123;</span><br><span class=\"line\">        [copys addObject:[attris copy]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return copys;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将layoutAttributesForElementsInRect：方法返回的数组扔到这个方法中，并且使用返回后的数组就行了。</p>\n<ul>\n<li><p>在navigationController中插入ScrollView后，scrollView的ContentInset的值发生了变化</p>\n<ul>\n<li>解决： self.automaticallyAdjustsScrollViewInsets = NO;</li>\n<li>原因： self.automaticallyAdjustsScrollViewInsets 默认值是YES，选择YES表示你允许视图控制器调整它内部插入的滑动视图来应对状态栏，导航栏，工具栏，和标签栏所消耗的屏幕区域。如果你设置为NO呢，就代表呀你要自己调整你插入的滑动视图，比如你的视图层次里面有多于一个的滑动视图。<br>这大概是个什么意思呢，就是你的视图控制器在没经你允许的情况下调整你的控件位置了</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>记录一些关于iOS的一些小技巧</p>","more":"<p>XCode Profile 的路径<br>xcode5 provisioning profile path：<br><code>~/Library/MobileDevice/Provisioning Profiles</code></p>\n<p>在升级XCode7.0使用UICollectionViewLayout进行自定义布局时，调试台会出现以下的警告打印。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UICollectionViewFlowLayout has cached frame mismatch for index path &#123;length &#x3D; 2, path &#x3D; 0 - 0&#125; - cached value: &#123;&#123;122, 15&#125;, &#123;170, 170&#125;&#125;; expected value: &#123;&#123;157, 50&#125;, &#123;100, 100&#125;&#125; </span><br><span class=\"line\">This is likely occurring because the flow layout subclass LineLayout is modifying attributes returned by UICollectionViewFlowLayout without copying them</span><br></pre></td></tr></table></figure>\n\n<p>这个警告来源主要是在使用layoutAttributesForElementsInRect：方法返回的数组时，没有使用该数组的拷贝对象，而是直接使用了该数组。解决办法对该数组进行拷贝，并且是深拷贝。拷贝代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSArray *)deepCopyWithArray:(NSArray *)array</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSMutableArray *copys &#x3D; [NSMutableArray arrayWithCapacity:array.count];</span><br><span class=\"line\"></span><br><span class=\"line\">    for (UICollectionViewLayoutAttributes *attris in array) &#123;</span><br><span class=\"line\">        [copys addObject:[attris copy]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return copys;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将layoutAttributesForElementsInRect：方法返回的数组扔到这个方法中，并且使用返回后的数组就行了。</p>\n<ul>\n<li><p>在navigationController中插入ScrollView后，scrollView的ContentInset的值发生了变化</p>\n<ul>\n<li>解决： self.automaticallyAdjustsScrollViewInsets = NO;</li>\n<li>原因： self.automaticallyAdjustsScrollViewInsets 默认值是YES，选择YES表示你允许视图控制器调整它内部插入的滑动视图来应对状态栏，导航栏，工具栏，和标签栏所消耗的屏幕区域。如果你设置为NO呢，就代表呀你要自己调整你插入的滑动视图，比如你的视图层次里面有多于一个的滑动视图。<br>这大概是个什么意思呢，就是你的视图控制器在没经你允许的情况下调整你的控件位置了</li>\n</ul>\n</li>\n</ul>"},{"layout":"application","title":"Application Loader / Fastlane pilot 通过代理上传方案","date":"2018-08-03T08:10:07.000Z","_content":"\n## Application Loader / Fastlane pilot 通过代理上传方案\n\n### 需求分析\n\n为了避免苹果审核马甲包情况, 我们需要通过其他IP去上传包, 这里提供几种方案并记录踩坑过程.\n\n<!-- more -->\n\n### 问题解决思路\n\n1. 用Application Loader(后面简称uploader)上传包, 电脑使用SS, VPN会导致上传失败, 原因是uploader内部自带开启代理配置, 但是默认是关闭的,  所以需要修改内部代理配置, 路径是`/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/java/lib/net.properties`, 配置如下(1086是本地ss的端口)\n\t\n\t```\n\tjava.net.useSystemProxies=true\n\thttp.proxyHost=127.0.0.1\n\thttp.proxyPort=1086\n\thttps.proxyHost=127.0.0.1\n\thttps.proxyPort=1086\n\tjdk.http.auth.tunneling.disabledSchemes=Basic\n\t```\n\t\n2. 本来`net.properties`内是有socks代理的配置的, Shadowsocks开启socks代理后, 在配置文件中配置好ip(127.0.0.1)和端口(1086)之后测试发现无法连接到苹果服务器, 故只能选用`http/https`代理\n\t> 查询shadowsocks本地端口的方法, 执行`lsof -iTCP -sTCP:LISTEN -n -P | grep ss-local`, 就可以查到\n\t\n3. 现在问题在于怎么将socks代理转成http/https代理, 通过查阅资料得知可以通过安装`privoxy`解决, 安装之后配置`/usr/local/etc/privoxy/config`文件, 把`forward-socks5t`那行注释掉, 加上本地socks ip和端口, 就像下面那段一样, 然后把`listen-address  127.0.0.1:8118` 改成 `listen-address  0.0.0.0:8118`就可以实现给局域网内共享你的代理.\n\n\t```\n\tforward           /               127.0.0.1:1086 .\n\tforward-socks4    /               127.0.0.1:1086 .\n\tforward-socks4a   /               127.0.0.1:1086 .\n\tforward-socks5    /               127.0.0.1:1086 .\n\tforward-socks5t   /               127.0.0.1:1086 .\n\t```\n\t\n4. 打开`系统偏好设置-网络-高级-代理`, 把网页代理和安全网页代理勾上, 填上ip `127.0.0.1` 端口 `8118` , 就可以了.  这里的`8118`是刚刚说到的`listen-address  0.0.0.0:8118`里面的端口号, 要改也可以改, 记得同步就行.\n\n### 校验\n\n1. 校验`privoxy`是否代理成功可以通过浏览器访问`http://config.privoxy.org/`这个网址就能看到成功与否了\n\n2. 执行`netstat -an | grep 8118` 查看`8188`是否全局监听着, 如果是就会看到\n\t`tcp4       0      0  *.8118                 *.*                    LISTEN  `执行`ps aux | grep privoxy`, 则可以看到`privoxy`进程是否正在运行中. 可以通过`sudo /Applications/Privoxy/stopPrivoxy.sh`停止`privoxy`和`sudo /Applications/Privoxy/startPrivoxy.sh`启动`privoxy`\n\t\n3. 浏览器访问`https://ip.cn`,就可以得知网页代理是否成功了\n\t\n4. fastlane上传包实际上是调用了`/Applications/Xcode.app/Contents/Applications/Application\\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool`, 也就是Xcode自带的命令行工具 , uploader就不用说了, 反正殊途同归, 最后都会根据`net.properties`去走代理,  那么问题来了 , 如何验证命令行和桌面应用uploader走的都是代理方式呢. 很遗憾苹果并不会弄出一个界面或者打印出一行log告诉你现在是用哪个ip上传, 我现在能想到的办法是通过工具查看上传过程中的流量波动, 通过实验, 两种方式再上传过程中, `ss-local`进程有过较大数据上传的流量波动(会有100k/s以上的上传流量速度), 因此我判定确实是走了代理上传包的.  如果要再证据确凿的话, 只能想办法抓包查看他的信息收集了, 但是`Charles`抓包的原理是再开一个代理, 会造成混乱....所以这就很头疼了.\n\n5. 开启了网页代理之后, 影响的只是网页, 实际上只是为了验证`Privoxy`的可用性, 开启之后你如果在命令行中使用`curl ip.cn`得到的结果会是你真实网络的出网ip, 而不是你想要的代理的ip, 实际上`uploader`和`fastlane pilot`命令行是否真正走了代理, 目前我只能通过`ss-local`这个代理的进程查看他的上传流量去判断, 具有一定风险. 或者通过安装命令行工具`proxychains`, 然后执行`proxychains4 fastlane pilot upload`传包, 但是这种方式100%上传失败 , 原因猜想是`net.properties`的配置没改, `proxychains`怎么转发请求都没用.  所以这是不是从某种意义上证明了`fastlane pilot`是走`net.properties`配置的呢, 至少我觉得按照目前情况可以这么认为,  后续如果有想法我会进行更多实验去证明的.","source":"_posts/通过代理上传方案.md","raw":"---\nlayout: application\ntitle:  Application Loader / Fastlane pilot 通过代理上传方案\ndate: 2018-08-03 16:10:07\ntags: iOS\n---\n\n## Application Loader / Fastlane pilot 通过代理上传方案\n\n### 需求分析\n\n为了避免苹果审核马甲包情况, 我们需要通过其他IP去上传包, 这里提供几种方案并记录踩坑过程.\n\n<!-- more -->\n\n### 问题解决思路\n\n1. 用Application Loader(后面简称uploader)上传包, 电脑使用SS, VPN会导致上传失败, 原因是uploader内部自带开启代理配置, 但是默认是关闭的,  所以需要修改内部代理配置, 路径是`/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/java/lib/net.properties`, 配置如下(1086是本地ss的端口)\n\t\n\t```\n\tjava.net.useSystemProxies=true\n\thttp.proxyHost=127.0.0.1\n\thttp.proxyPort=1086\n\thttps.proxyHost=127.0.0.1\n\thttps.proxyPort=1086\n\tjdk.http.auth.tunneling.disabledSchemes=Basic\n\t```\n\t\n2. 本来`net.properties`内是有socks代理的配置的, Shadowsocks开启socks代理后, 在配置文件中配置好ip(127.0.0.1)和端口(1086)之后测试发现无法连接到苹果服务器, 故只能选用`http/https`代理\n\t> 查询shadowsocks本地端口的方法, 执行`lsof -iTCP -sTCP:LISTEN -n -P | grep ss-local`, 就可以查到\n\t\n3. 现在问题在于怎么将socks代理转成http/https代理, 通过查阅资料得知可以通过安装`privoxy`解决, 安装之后配置`/usr/local/etc/privoxy/config`文件, 把`forward-socks5t`那行注释掉, 加上本地socks ip和端口, 就像下面那段一样, 然后把`listen-address  127.0.0.1:8118` 改成 `listen-address  0.0.0.0:8118`就可以实现给局域网内共享你的代理.\n\n\t```\n\tforward           /               127.0.0.1:1086 .\n\tforward-socks4    /               127.0.0.1:1086 .\n\tforward-socks4a   /               127.0.0.1:1086 .\n\tforward-socks5    /               127.0.0.1:1086 .\n\tforward-socks5t   /               127.0.0.1:1086 .\n\t```\n\t\n4. 打开`系统偏好设置-网络-高级-代理`, 把网页代理和安全网页代理勾上, 填上ip `127.0.0.1` 端口 `8118` , 就可以了.  这里的`8118`是刚刚说到的`listen-address  0.0.0.0:8118`里面的端口号, 要改也可以改, 记得同步就行.\n\n### 校验\n\n1. 校验`privoxy`是否代理成功可以通过浏览器访问`http://config.privoxy.org/`这个网址就能看到成功与否了\n\n2. 执行`netstat -an | grep 8118` 查看`8188`是否全局监听着, 如果是就会看到\n\t`tcp4       0      0  *.8118                 *.*                    LISTEN  `执行`ps aux | grep privoxy`, 则可以看到`privoxy`进程是否正在运行中. 可以通过`sudo /Applications/Privoxy/stopPrivoxy.sh`停止`privoxy`和`sudo /Applications/Privoxy/startPrivoxy.sh`启动`privoxy`\n\t\n3. 浏览器访问`https://ip.cn`,就可以得知网页代理是否成功了\n\t\n4. fastlane上传包实际上是调用了`/Applications/Xcode.app/Contents/Applications/Application\\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool`, 也就是Xcode自带的命令行工具 , uploader就不用说了, 反正殊途同归, 最后都会根据`net.properties`去走代理,  那么问题来了 , 如何验证命令行和桌面应用uploader走的都是代理方式呢. 很遗憾苹果并不会弄出一个界面或者打印出一行log告诉你现在是用哪个ip上传, 我现在能想到的办法是通过工具查看上传过程中的流量波动, 通过实验, 两种方式再上传过程中, `ss-local`进程有过较大数据上传的流量波动(会有100k/s以上的上传流量速度), 因此我判定确实是走了代理上传包的.  如果要再证据确凿的话, 只能想办法抓包查看他的信息收集了, 但是`Charles`抓包的原理是再开一个代理, 会造成混乱....所以这就很头疼了.\n\n5. 开启了网页代理之后, 影响的只是网页, 实际上只是为了验证`Privoxy`的可用性, 开启之后你如果在命令行中使用`curl ip.cn`得到的结果会是你真实网络的出网ip, 而不是你想要的代理的ip, 实际上`uploader`和`fastlane pilot`命令行是否真正走了代理, 目前我只能通过`ss-local`这个代理的进程查看他的上传流量去判断, 具有一定风险. 或者通过安装命令行工具`proxychains`, 然后执行`proxychains4 fastlane pilot upload`传包, 但是这种方式100%上传失败 , 原因猜想是`net.properties`的配置没改, `proxychains`怎么转发请求都没用.  所以这是不是从某种意义上证明了`fastlane pilot`是走`net.properties`配置的呢, 至少我觉得按照目前情况可以这么认为,  后续如果有想法我会进行更多实验去证明的.","slug":"通过代理上传方案","published":1,"updated":"2021-04-12T06:07:04.047Z","comments":1,"photos":[],"link":"","_id":"cknndog6u006s45n0agapectq","content":"<h2 id=\"Application-Loader-Fastlane-pilot-通过代理上传方案\"><a href=\"#Application-Loader-Fastlane-pilot-通过代理上传方案\" class=\"headerlink\" title=\"Application Loader / Fastlane pilot 通过代理上传方案\"></a>Application Loader / Fastlane pilot 通过代理上传方案</h2><h3 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h3><p>为了避免苹果审核马甲包情况, 我们需要通过其他IP去上传包, 这里提供几种方案并记录踩坑过程.</p>\n<span id=\"more\"></span>\n\n<h3 id=\"问题解决思路\"><a href=\"#问题解决思路\" class=\"headerlink\" title=\"问题解决思路\"></a>问题解决思路</h3><ol>\n<li><p>用Application Loader(后面简称uploader)上传包, 电脑使用SS, VPN会导致上传失败, 原因是uploader内部自带开启代理配置, 但是默认是关闭的,  所以需要修改内部代理配置, 路径是<code>/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/java/lib/net.properties</code>, 配置如下(1086是本地ss的端口)</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.net.useSystemProxies&#x3D;true</span><br><span class=\"line\">http.proxyHost&#x3D;127.0.0.1</span><br><span class=\"line\">http.proxyPort&#x3D;1086</span><br><span class=\"line\">https.proxyHost&#x3D;127.0.0.1</span><br><span class=\"line\">https.proxyPort&#x3D;1086</span><br><span class=\"line\">jdk.http.auth.tunneling.disabledSchemes&#x3D;Basic</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本来<code>net.properties</code>内是有socks代理的配置的, Shadowsocks开启socks代理后, 在配置文件中配置好ip(127.0.0.1)和端口(1086)之后测试发现无法连接到苹果服务器, 故只能选用<code>http/https</code>代理</p>\n<blockquote>\n<p>查询shadowsocks本地端口的方法, 执行<code>lsof -iTCP -sTCP:LISTEN -n -P | grep ss-local</code>, 就可以查到</p>\n</blockquote>\n</li>\n<li><p>现在问题在于怎么将socks代理转成http/https代理, 通过查阅资料得知可以通过安装<code>privoxy</code>解决, 安装之后配置<code>/usr/local/etc/privoxy/config</code>文件, 把<code>forward-socks5t</code>那行注释掉, 加上本地socks ip和端口, 就像下面那段一样, 然后把<code>listen-address  127.0.0.1:8118</code> 改成 <code>listen-address  0.0.0.0:8118</code>就可以实现给局域网内共享你的代理.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">forward           &#x2F;               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks4    &#x2F;               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks4a   &#x2F;               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks5    &#x2F;               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks5t   &#x2F;               127.0.0.1:1086 .</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打开<code>系统偏好设置-网络-高级-代理</code>, 把网页代理和安全网页代理勾上, 填上ip <code>127.0.0.1</code> 端口 <code>8118</code> , 就可以了.  这里的<code>8118</code>是刚刚说到的<code>listen-address  0.0.0.0:8118</code>里面的端口号, 要改也可以改, 记得同步就行.</p>\n</li>\n</ol>\n<h3 id=\"校验\"><a href=\"#校验\" class=\"headerlink\" title=\"校验\"></a>校验</h3><ol>\n<li><p>校验<code>privoxy</code>是否代理成功可以通过浏览器访问<code>http://config.privoxy.org/</code>这个网址就能看到成功与否了</p>\n</li>\n<li><p>执行<code>netstat -an | grep 8118</code> 查看<code>8188</code>是否全局监听着, 如果是就会看到<br> <code>tcp4       0      0  *.8118                 *.*                    LISTEN  </code>执行<code>ps aux | grep privoxy</code>, 则可以看到<code>privoxy</code>进程是否正在运行中. 可以通过<code>sudo /Applications/Privoxy/stopPrivoxy.sh</code>停止<code>privoxy</code>和<code>sudo /Applications/Privoxy/startPrivoxy.sh</code>启动<code>privoxy</code></p>\n</li>\n<li><p>浏览器访问<code>https://ip.cn</code>,就可以得知网页代理是否成功了</p>\n</li>\n<li><p>fastlane上传包实际上是调用了<code>/Applications/Xcode.app/Contents/Applications/Application\\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool</code>, 也就是Xcode自带的命令行工具 , uploader就不用说了, 反正殊途同归, 最后都会根据<code>net.properties</code>去走代理,  那么问题来了 , 如何验证命令行和桌面应用uploader走的都是代理方式呢. 很遗憾苹果并不会弄出一个界面或者打印出一行log告诉你现在是用哪个ip上传, 我现在能想到的办法是通过工具查看上传过程中的流量波动, 通过实验, 两种方式再上传过程中, <code>ss-local</code>进程有过较大数据上传的流量波动(会有100k/s以上的上传流量速度), 因此我判定确实是走了代理上传包的.  如果要再证据确凿的话, 只能想办法抓包查看他的信息收集了, 但是<code>Charles</code>抓包的原理是再开一个代理, 会造成混乱….所以这就很头疼了.</p>\n</li>\n<li><p>开启了网页代理之后, 影响的只是网页, 实际上只是为了验证<code>Privoxy</code>的可用性, 开启之后你如果在命令行中使用<code>curl ip.cn</code>得到的结果会是你真实网络的出网ip, 而不是你想要的代理的ip, 实际上<code>uploader</code>和<code>fastlane pilot</code>命令行是否真正走了代理, 目前我只能通过<code>ss-local</code>这个代理的进程查看他的上传流量去判断, 具有一定风险. 或者通过安装命令行工具<code>proxychains</code>, 然后执行<code>proxychains4 fastlane pilot upload</code>传包, 但是这种方式100%上传失败 , 原因猜想是<code>net.properties</code>的配置没改, <code>proxychains</code>怎么转发请求都没用.  所以这是不是从某种意义上证明了<code>fastlane pilot</code>是走<code>net.properties</code>配置的呢, 至少我觉得按照目前情况可以这么认为,  后续如果有想法我会进行更多实验去证明的.</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"Application-Loader-Fastlane-pilot-通过代理上传方案\"><a href=\"#Application-Loader-Fastlane-pilot-通过代理上传方案\" class=\"headerlink\" title=\"Application Loader / Fastlane pilot 通过代理上传方案\"></a>Application Loader / Fastlane pilot 通过代理上传方案</h2><h3 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h3><p>为了避免苹果审核马甲包情况, 我们需要通过其他IP去上传包, 这里提供几种方案并记录踩坑过程.</p>","more":"<h3 id=\"问题解决思路\"><a href=\"#问题解决思路\" class=\"headerlink\" title=\"问题解决思路\"></a>问题解决思路</h3><ol>\n<li><p>用Application Loader(后面简称uploader)上传包, 电脑使用SS, VPN会导致上传失败, 原因是uploader内部自带开启代理配置, 但是默认是关闭的,  所以需要修改内部代理配置, 路径是<code>/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/java/lib/net.properties</code>, 配置如下(1086是本地ss的端口)</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.net.useSystemProxies&#x3D;true</span><br><span class=\"line\">http.proxyHost&#x3D;127.0.0.1</span><br><span class=\"line\">http.proxyPort&#x3D;1086</span><br><span class=\"line\">https.proxyHost&#x3D;127.0.0.1</span><br><span class=\"line\">https.proxyPort&#x3D;1086</span><br><span class=\"line\">jdk.http.auth.tunneling.disabledSchemes&#x3D;Basic</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本来<code>net.properties</code>内是有socks代理的配置的, Shadowsocks开启socks代理后, 在配置文件中配置好ip(127.0.0.1)和端口(1086)之后测试发现无法连接到苹果服务器, 故只能选用<code>http/https</code>代理</p>\n<blockquote>\n<p>查询shadowsocks本地端口的方法, 执行<code>lsof -iTCP -sTCP:LISTEN -n -P | grep ss-local</code>, 就可以查到</p>\n</blockquote>\n</li>\n<li><p>现在问题在于怎么将socks代理转成http/https代理, 通过查阅资料得知可以通过安装<code>privoxy</code>解决, 安装之后配置<code>/usr/local/etc/privoxy/config</code>文件, 把<code>forward-socks5t</code>那行注释掉, 加上本地socks ip和端口, 就像下面那段一样, 然后把<code>listen-address  127.0.0.1:8118</code> 改成 <code>listen-address  0.0.0.0:8118</code>就可以实现给局域网内共享你的代理.</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">forward           &#x2F;               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks4    &#x2F;               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks4a   &#x2F;               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks5    &#x2F;               127.0.0.1:1086 .</span><br><span class=\"line\">forward-socks5t   &#x2F;               127.0.0.1:1086 .</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>打开<code>系统偏好设置-网络-高级-代理</code>, 把网页代理和安全网页代理勾上, 填上ip <code>127.0.0.1</code> 端口 <code>8118</code> , 就可以了.  这里的<code>8118</code>是刚刚说到的<code>listen-address  0.0.0.0:8118</code>里面的端口号, 要改也可以改, 记得同步就行.</p>\n</li>\n</ol>\n<h3 id=\"校验\"><a href=\"#校验\" class=\"headerlink\" title=\"校验\"></a>校验</h3><ol>\n<li><p>校验<code>privoxy</code>是否代理成功可以通过浏览器访问<code>http://config.privoxy.org/</code>这个网址就能看到成功与否了</p>\n</li>\n<li><p>执行<code>netstat -an | grep 8118</code> 查看<code>8188</code>是否全局监听着, 如果是就会看到<br> <code>tcp4       0      0  *.8118                 *.*                    LISTEN  </code>执行<code>ps aux | grep privoxy</code>, 则可以看到<code>privoxy</code>进程是否正在运行中. 可以通过<code>sudo /Applications/Privoxy/stopPrivoxy.sh</code>停止<code>privoxy</code>和<code>sudo /Applications/Privoxy/startPrivoxy.sh</code>启动<code>privoxy</code></p>\n</li>\n<li><p>浏览器访问<code>https://ip.cn</code>,就可以得知网页代理是否成功了</p>\n</li>\n<li><p>fastlane上传包实际上是调用了<code>/Applications/Xcode.app/Contents/Applications/Application\\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool</code>, 也就是Xcode自带的命令行工具 , uploader就不用说了, 反正殊途同归, 最后都会根据<code>net.properties</code>去走代理,  那么问题来了 , 如何验证命令行和桌面应用uploader走的都是代理方式呢. 很遗憾苹果并不会弄出一个界面或者打印出一行log告诉你现在是用哪个ip上传, 我现在能想到的办法是通过工具查看上传过程中的流量波动, 通过实验, 两种方式再上传过程中, <code>ss-local</code>进程有过较大数据上传的流量波动(会有100k/s以上的上传流量速度), 因此我判定确实是走了代理上传包的.  如果要再证据确凿的话, 只能想办法抓包查看他的信息收集了, 但是<code>Charles</code>抓包的原理是再开一个代理, 会造成混乱….所以这就很头疼了.</p>\n</li>\n<li><p>开启了网页代理之后, 影响的只是网页, 实际上只是为了验证<code>Privoxy</code>的可用性, 开启之后你如果在命令行中使用<code>curl ip.cn</code>得到的结果会是你真实网络的出网ip, 而不是你想要的代理的ip, 实际上<code>uploader</code>和<code>fastlane pilot</code>命令行是否真正走了代理, 目前我只能通过<code>ss-local</code>这个代理的进程查看他的上传流量去判断, 具有一定风险. 或者通过安装命令行工具<code>proxychains</code>, 然后执行<code>proxychains4 fastlane pilot upload</code>传包, 但是这种方式100%上传失败 , 原因猜想是<code>net.properties</code>的配置没改, <code>proxychains</code>怎么转发请求都没用.  所以这是不是从某种意义上证明了<code>fastlane pilot</code>是走<code>net.properties</code>配置的呢, 至少我觉得按照目前情况可以这么认为,  后续如果有想法我会进行更多实验去证明的.</p>\n</li>\n</ol>"},{"title":"项目里面的库和框架里面的库冲突问题","author":"Arclin","abbrlink":"b072216a","date":"2016-10-28T16:00:00.000Z","_content":"项目里面有一个libFat.a 然后项目里面的KxMovie.framework 里面也有一个libFat.a，编译时会冲突\n如果有用Cocopods,那么只要删掉-ObjC编译选项就可以\n\n<!-- more -->\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/111.png)\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/222.png)","source":"_posts/项目里面的库和框架里面的库冲突问题.md","raw":"---\ntitle: 项目里面的库和框架里面的库冲突问题\nauthor: Arclin\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: b072216a\ndate: 2016-10-29 00:00:00\n---\n项目里面有一个libFat.a 然后项目里面的KxMovie.framework 里面也有一个libFat.a，编译时会冲突\n如果有用Cocopods,那么只要删掉-ObjC编译选项就可以\n\n<!-- more -->\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/111.png)\n\n![](https://raw.githubusercontent.com/Arc-lin/BlogImage/master/222.png)","slug":"项目里面的库和框架里面的库冲突问题","published":1,"updated":"2021-04-12T06:07:04.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknndog6v006w45n0fpwnhs6z","content":"<p>项目里面有一个libFat.a 然后项目里面的KxMovie.framework 里面也有一个libFat.a，编译时会冲突<br>如果有用Cocopods,那么只要删掉-ObjC编译选项就可以</p>\n<span id=\"more\"></span>\n\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/111.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/222.png\"></p>\n","site":{"data":{}},"excerpt":"<p>项目里面有一个libFat.a 然后项目里面的KxMovie.framework 里面也有一个libFat.a，编译时会冲突<br>如果有用Cocopods,那么只要删掉-ObjC编译选项就可以</p>","more":"<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/111.png\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Arc-lin/BlogImage/master/222.png\"></p>"},{"title":"iOS14 App Clips","author":"Arclin","abbrlink":"a44df9c3","date":"2020-11-25T02:08:18.000Z","_content":"\n> 本文将主要探讨App Clips开发流程 和 组件化、非组件化两种开发方式下如何复用代码的问题。\n\n<!-- more -->\n\nApp Clips是iOS14系统的新特性之一，类似于小程序，用户可以在不下载App的情况下体验到App的部分功能，如网易严选的商品详情功能（[https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw](https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw)），该功能适合做一些推广和引流的运营工作，另外苹果也提供的原生的浮窗样式，可以引导用户下载完整版App。\n\n苹果官方文档：[https://developer.apple.com/app-clips/](https://developer.apple.com/app-clips/)\n\n### 目前已知的触发方式\n\n- 二维码\n\t\n\t必须使用iOS 14系统相机或者使用控制中心的读取二维码组件来扫码才能触发App Clips。\n\n- NFC Tags\n\t\n\tNFC标签感应，比如星巴克桌面内嵌的NFC Tags。\n\n- Safari App Banner\n\t\n\t当用户用iOS的Safari浏览器浏览相应的网址后，页面顶部会出现一个横幅，提示用户有App Clips可以用。\n\n- 信息\n\t\n\tiOS系统自带的iMessage，当你在iMessage发送一个App Clips链接时，系统会自动把信息显示成一个App Clips的卡片。\n    \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a13d29c7a17d471dbc551c416ce2ed57~tplv-k3u1fbpfcp-watermark.image)\n\n### 开发前置工作\n\n#### 申请证书\n\n##### 创建App Clips ID\n\n1. 点击新增APP ID\n\t\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d62145df226549428f600ace6f1b44cb~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n2. 选择App Clip\n\t\n\t<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f93a07c34f7249b982f0cbca84bfcafe~tplv-k3u1fbpfcp-zoom-1.image\" >\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da0c96044db46bb897aab6f71543c8d~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n\n3. 输入一串英文名，用于拼接在主工程的bundle id的后面，生成该clip的bundle id\n\t<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2ae0fb422f149d98589f36c80123315~tplv-k3u1fbpfcp-zoom-1.image\" >\n\t\n4. 在Description内输入描述（不能使用特殊符号），并且在下方勾选App Clip能力，比如Apple Pay，Sign in with Apple，Push等等，**Associated Domains必须勾选**\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33e78440190242efaa8dac9b47004393~tplv-k3u1fbpfcp-zoom-1.image\" >\n\t\n5. 最后确认并点击右上方Register即可\n\n##### 创建Profiles\n\n流程跟创建App的Profiles一样，就是选择bundle id的时候改成Clip的bundle id 即可，同样有Development、AdHoc、Distribution三种类型\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68bfe6ee218047b7a3232058dcc2e006~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n##### 其他配置\n\n如果需要其他NFC、地点等等的一些方式触发App Clip配置的话，参考这个苹果的文档[https://help.apple.com/app-store-connect/#/dev5b665db74](https://help.apple.com/app-store-connect/#/dev5b665db74)\n\n#### Apple Store Connect 配置图片和标题，描述\n\n1. 需要一张1800 * 1200 的图片，用于显示在Clip的卡片上\n2. 副标题用于显示在卡片标题下的小字，如图所示<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b3e18f56f6d49219fc46f77dab1cef2~tplv-k3u1fbpfcp-zoom-1.image\" width=30%>\n3. 操作包括“打开”“查看”“开始游戏”，体现在卡片右边的蓝色按钮内的文案，根据你的产品类型进行选择就好\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c14c35967084886bc3f4fce6e985fcb~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n\n#### 配置apple-app-site-association.json\n\n假设你的开发者账号的Team Id是`A123`，Clips的bundle id是`com.abc.def.clips`，主工程的bundle id 是`com.abc.def`，则配置如下\n\n```\n{\n    \"appclips\":{\n        \"apps\":[\"A123.com.abc.def.clips\"]\n    },\n    \"applinks\":{\n        \"apps\":[\n        ],\n        \"details\":{\n            \"A123.com.abc.def\":{\n                \"paths\":[\n                    \"*\" // 这里的Path根据实际情况配置即可\n                ]\n            }\n        }\n    },\n    \"webcredentials\":{\n        \"apps\":[\n            \"A123.com.abc.def\",\n        ]\n    },\n    \"activitycontinuation\":{\n        \"apps\":[\n            \"A123.com.abc.def\",\n        ]\n    }\n}\n```\n\n配置完成后部署到你自己域名的根目录下，配置方法网上很多教程，这里贴上[苹果官方文档](https://developer.apple.com/documentation/safariservices/supporting_associated_domains?language=objc)\n\n如果配置错了，那么上传包到苹果后台之后，就会显示无效域名\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05ddb4d106a349d28c1504762697a9eb~tplv-k3u1fbpfcp-zoom-1.image)\n\n如果是json配置错误，那么配置正确后不用重新传包，等待苹果那边刷新缓存就好。\n\nApp Clip支持最多在三个域名的网页显示入口，到后面的工程配置那里会说明。\n\n#### 前端页面添加meta标签\n\n如果要在H5页面显示Clips入口，加上一段meta标签即可\n\n如果你的应用市场App id是 `123456`, Clips的bundle id 是 `com.abc.clips` 则应该配置\n\n```\n<meta name=\"apple-itunes-app\" content=\"app-id=123456,app-clip-bundle-id=com.abc.clips\">\n```\n\n### 开发工作\n\n#### 新建App Clip Target\n\n这里以OC工程为例\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9edc6108c0b64885b708ef5c9de8e1d0~tplv-k3u1fbpfcp-zoom-1.image\" >\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa5c9c1032174d77a4db0518029b78dd~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n#### 配置证书和Associated Domains\n\n用刚才生成的证书去配置一下即可\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fbccb4eee1445ca9b680200358535e0~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n添加Associated Domains，目的是打开对应域名网页后，页面上方能够出现Clip的入口。\n\n**这里可以添加多个域名，注意每个域名都需要配置apple-app-site-association！！！**\n\n**主工程的Target和Clip的Target都需要配置！！！**\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5125ca96f15433b8205294e48906e13~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n#### 编写代码\n\n创建完之后就会生成一个文件夹，里面就是我们熟悉的AppDelegate、SecneDelegate、Main.storyboard、Info.plist等文件，如果你不使用Storyboard进行界面搭建，那么也是跟之前的开发模式一样，删除info.plist内Application Scene Manifest，修改General-Deployment info - Main interface 为空，修改AppDelegate.m，在里面创建根控制器。\n\n之后的操作就跟普通开发一样了，调试的话可以直接在Xcode上左上角选择Clip的target，然后就可以跑起来了。\n\n另外，AppIcon是需要独立配置的，同样也是在Clip项目工程文件夹内Assets.xcassets。\n\n##### 非组件化开发模式\n\n一般情况下我们是需要复用代码的，将代码内某些模块功能进行复用，然后直接用在Clip，这时候我们只需要在右侧Target Membership勾选新建的Clip Target即可。\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2847eb910740229f410d0aa29f7bb5~tplv-k3u1fbpfcp-zoom-1.image\" width=30%>\n\n同样的 相关的依赖到的文件也需要勾选Clip Target\n\n##### 组件化开发模式 和 Podfile的配置\n\n如果是在组件化开发模式下，那么就需要配置Podfile\n\n在Podfile 底部新增代码\n\n```\nsource 'https://github.com/CocoaPods/Specs.git'\n# 你的私有pod仓库\nsource 'https://git.xxx.com/yourprivatepodspec/Podspec.git'\n\ntarget 'YourApp’ do\n    platform :ios, '10.3'\n    pod \"AFNetworking\"\n    pod \"SDWebImage\"\n    # 等等\nend\n\ntarget 'YourApp_Clips' do\n    platform :ios, '10.3'\n    pod 'ComponentA',           :path=> '../ComponentA'\n    pod \"ComponentB\",           :path=>\"../ComponentB\"\n    pod \"AFNetworking\"\n    pod \"SDWebImage\"\n    # 等等\nend\n\n```\n\n但是这样子相同的第三方pod会写两遍，所以我们可以优化成\n\n```\nsource 'https://github.com/CocoaPods/Specs.git'\n# 你的私有pod仓库\nsource 'https://git.xxx.com/yourprivatepodspec/Podspec.git'\n\ndef common_pods\n    pod \"AFNetworking\"\n    pod \"SDWebImage\"\nend\n\ntarget 'YourApp’ do\n    platform :ios, '10.3'\n    common_pods\nend\n\ntarget 'YourApp_Clips' do\n    platform :ios, '14.0'\n    pod 'ComponentA',           :path=> '../ComponentA'\n    pod \"ComponentB\",           :path=>\"../ComponentB\"\n    common_pods\nend\n\n```\n\n##### 抽离模块时不同环境的代码复用问题\n\n假如说A功能需要抽离出来放到Clip，但是A模块里面有需求是会跳转到B模块的，但是我并不希望Clip引入B模块，希望他能在这个地方提示用户下载完整App，那应该怎么做呢？\n\n首先第一个事情，苹果提供了一个Api可以引导弹窗引导用户下载APP\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fec69fde9e64618819b1b526034d23b~tplv-k3u1fbpfcp-zoom-1.image\" width=40%>\n\n```\nUIWindowScene *scene = (UIWindowScene *)[[UIApplication sharedApplication].connectedScenes.allObjects firstObject];\nSKOverlayAppConfiguration *config = [[SKOverlayAppConfiguration alloc] initWithAppIdentifier:@\"你的AppID\" position:SKOverlayPositionBottomRaised];\nSKOverlay *overlay = [[SKOverlay alloc] initWithConfiguration:config];\noverlay.delegate = self; // 添加代理后可以监听弹窗的弹出和消失，可以在代理内添加埋点。\n[overlay presentInScene:scene];\n\n// 主动让弹窗消失\n// [SKOverlay dismissOverlayInScene:scene];\n```\n\n第二. 如何在模块内划分环境，区分是主App还是Clip\n\n方法一：设计一个单例，添加一个枚举属性，分别在`主工程`的AppDelegate和`Clip`的AppDelegate内给单例的属性赋值，标记当前环境。然后在业务代码中获取单例的环境属性后进行判断。\n\n方法二：有时候我们在Clip复用的模块代码内不需要import某些头文件，因为我们不需要这个功能，这时候单例的方法就不管用了，我们需要通过宏去判断。\n\n如果代码不在pod组件内的话，只需要在Clip Target的`Build Settings` - `Preprocessor Macros`添加`APP_CLIPS`宏即可。\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7708c16f9c4247a9ab9ec393d01420b1~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n如果是组件化的开发模式，代码在pod内部，那么就稍微有点麻烦，需要在对应podspec新增一个subspec，专门提供给clip使用，然后配置上宏定义\n\n`ComponentA.podspec`\n\n```\n\ns.subspec \"App\" do |ss|\n    ss.source_files = \"xxxxxx\"\nend\n\ns.subspec \"AppClip\" do |ss|\n    ss.source_files = \"xxxxxx\"\n    ss.pod_target_xcconfig = { 'GCC_PREPROCESSOR_DEFINITIONS' => 'APP_CLIPS=1'}\nend\n```\n\n> 这里为什么要弄多一个App的subspec，因为如果主工程直接`pod ComponentA`的话，所有的subspec都会被引入，所以这里为了区分开，就加多了一个专门给主工程用的subspec\n\n`Podfile`\n\n```\ndef common_pods\n    pod \"AFNetworking\"\n    pod \"SDWebImage\"\nend\n\ntarget 'YourApp’ do\n    platform :ios, '10.3'\n    common_pods\n    pod 'ComponentA/App',           :path=> '../ComponentA'\nend\n\ntarget 'YourApp_Clips' do\n    platform :ios, '14.0'\n    pod 'ComponentA/AppClip',   :path=> '../ComponentA'\n    pod \"ComponentB\",           :path=>\"../ComponentB\"\n    common_pods\nend\n```\n\n通过以上方法，就可以用如下方式进行宏判断，区分当前环境\n\n```\n#ifdef APP_CLIPS\n\n#else\n\n#endif\n```\n\n### 测试工作\n\n#### 开发调试\n\n- 可以选择Clip Target直接使用Xcode编译运行\n\n- 可以使用真机扫描二维码，调起Clip卡片，但是前提是Clip要先在真机跑一遍。\n\t\n\t1. 手机点击`设置-开发者-Local Experiences-Register Local Experience`\n\t2. 输入域名、Clip的bundle id、标题、子标题，选择按钮标题、选择Clip弹出的卡片上的图片，然后点击存储即可。\n\t3. 将刚才输入的域名，去草料二维码等二维码生成网站生成一个二维码，然后手机相机扫描即可弹出卡片样式。\n\t4. 具体内容可以参考[官方文档](https://developer.apple.com/documentation/app_clips/testing_your_app_clip_s_launch_experience?language=objc)\n\t\n\n#### 外部测试\n\n1. 可以通过Archive打Release环境的包（Debug状态下没有选择导出Clip ipa的选项，不知道是哪里配置问题，如果有知道的小伙伴可以评论区分享一下），然后单独导出Clip的ipa，上传到蒲公英或者Fir等分发平台，测试同事就可以下载安装测试了。\n2. 如果已经传到了TestFlight，那么也可以在TestFlight上直接点击打开小程序进行测试。\n\n### 苹果官方提及的产品要求\n\n原文：[https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/](https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/)\n\n划重点：\n\n1. 请勿仅将App Clip用作营销用途，不能显示广告。\n \n2. 避免登录，避免不了的话尽可能使用Apple id登录\n\n3. Clips启动后只有在8小时内才能接收推送\n\n### Q&A\n\n1. 苹果文档说的App Clips 10M限制指的是哪个文件的10M\n\t\n\t经过测试后发现，应该是Release环境下Archive后，导出的Clips的ipa的大小，如果有误欢迎评论区指正。\n\t\n2. Clips可以有登录功能吗？\n\n\t可以，但是苹果希望用户能不登录就使用App，如果要登录也首选Sign in with Apple登录的方式(iOS13特性)，但是我们可以学网易严选那样子苹果ID登录之后再弹出手机验证码绑定功能。\n\t\n3. 可以有内购吗？\n\n\t可以。\n\t\n4. 用户使用完Clips后，如果想再次进入，入口在哪儿？\n\n\t假如是网页打开的Clips，那么离开网页后，在桌面的\"资源库\"里可以找到这个Clips并重新打开。如果找不到就搜索资源库，总能搜到的。","source":"_posts/iOS14-App-Clips.md","raw":"---\ntitle: iOS14 App Clips\nauthor: Arclin\nabbrlink: a44df9c3\ndate: 2020-11-25 10:08:18\ntags:\n  - iOS\n  - feature\ncategories:\n  - iOS\n---\n\n> 本文将主要探讨App Clips开发流程 和 组件化、非组件化两种开发方式下如何复用代码的问题。\n\n<!-- more -->\n\nApp Clips是iOS14系统的新特性之一，类似于小程序，用户可以在不下载App的情况下体验到App的部分功能，如网易严选的商品详情功能（[https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw](https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw)），该功能适合做一些推广和引流的运营工作，另外苹果也提供的原生的浮窗样式，可以引导用户下载完整版App。\n\n苹果官方文档：[https://developer.apple.com/app-clips/](https://developer.apple.com/app-clips/)\n\n### 目前已知的触发方式\n\n- 二维码\n\t\n\t必须使用iOS 14系统相机或者使用控制中心的读取二维码组件来扫码才能触发App Clips。\n\n- NFC Tags\n\t\n\tNFC标签感应，比如星巴克桌面内嵌的NFC Tags。\n\n- Safari App Banner\n\t\n\t当用户用iOS的Safari浏览器浏览相应的网址后，页面顶部会出现一个横幅，提示用户有App Clips可以用。\n\n- 信息\n\t\n\tiOS系统自带的iMessage，当你在iMessage发送一个App Clips链接时，系统会自动把信息显示成一个App Clips的卡片。\n    \n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a13d29c7a17d471dbc551c416ce2ed57~tplv-k3u1fbpfcp-watermark.image)\n\n### 开发前置工作\n\n#### 申请证书\n\n##### 创建App Clips ID\n\n1. 点击新增APP ID\n\t\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d62145df226549428f600ace6f1b44cb~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n2. 选择App Clip\n\t\n\t<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f93a07c34f7249b982f0cbca84bfcafe~tplv-k3u1fbpfcp-zoom-1.image\" >\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da0c96044db46bb897aab6f71543c8d~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n\n3. 输入一串英文名，用于拼接在主工程的bundle id的后面，生成该clip的bundle id\n\t<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2ae0fb422f149d98589f36c80123315~tplv-k3u1fbpfcp-zoom-1.image\" >\n\t\n4. 在Description内输入描述（不能使用特殊符号），并且在下方勾选App Clip能力，比如Apple Pay，Sign in with Apple，Push等等，**Associated Domains必须勾选**\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33e78440190242efaa8dac9b47004393~tplv-k3u1fbpfcp-zoom-1.image\" >\n\t\n5. 最后确认并点击右上方Register即可\n\n##### 创建Profiles\n\n流程跟创建App的Profiles一样，就是选择bundle id的时候改成Clip的bundle id 即可，同样有Development、AdHoc、Distribution三种类型\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68bfe6ee218047b7a3232058dcc2e006~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n##### 其他配置\n\n如果需要其他NFC、地点等等的一些方式触发App Clip配置的话，参考这个苹果的文档[https://help.apple.com/app-store-connect/#/dev5b665db74](https://help.apple.com/app-store-connect/#/dev5b665db74)\n\n#### Apple Store Connect 配置图片和标题，描述\n\n1. 需要一张1800 * 1200 的图片，用于显示在Clip的卡片上\n2. 副标题用于显示在卡片标题下的小字，如图所示<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b3e18f56f6d49219fc46f77dab1cef2~tplv-k3u1fbpfcp-zoom-1.image\" width=30%>\n3. 操作包括“打开”“查看”“开始游戏”，体现在卡片右边的蓝色按钮内的文案，根据你的产品类型进行选择就好\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c14c35967084886bc3f4fce6e985fcb~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n\n#### 配置apple-app-site-association.json\n\n假设你的开发者账号的Team Id是`A123`，Clips的bundle id是`com.abc.def.clips`，主工程的bundle id 是`com.abc.def`，则配置如下\n\n```\n{\n    \"appclips\":{\n        \"apps\":[\"A123.com.abc.def.clips\"]\n    },\n    \"applinks\":{\n        \"apps\":[\n        ],\n        \"details\":{\n            \"A123.com.abc.def\":{\n                \"paths\":[\n                    \"*\" // 这里的Path根据实际情况配置即可\n                ]\n            }\n        }\n    },\n    \"webcredentials\":{\n        \"apps\":[\n            \"A123.com.abc.def\",\n        ]\n    },\n    \"activitycontinuation\":{\n        \"apps\":[\n            \"A123.com.abc.def\",\n        ]\n    }\n}\n```\n\n配置完成后部署到你自己域名的根目录下，配置方法网上很多教程，这里贴上[苹果官方文档](https://developer.apple.com/documentation/safariservices/supporting_associated_domains?language=objc)\n\n如果配置错了，那么上传包到苹果后台之后，就会显示无效域名\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05ddb4d106a349d28c1504762697a9eb~tplv-k3u1fbpfcp-zoom-1.image)\n\n如果是json配置错误，那么配置正确后不用重新传包，等待苹果那边刷新缓存就好。\n\nApp Clip支持最多在三个域名的网页显示入口，到后面的工程配置那里会说明。\n\n#### 前端页面添加meta标签\n\n如果要在H5页面显示Clips入口，加上一段meta标签即可\n\n如果你的应用市场App id是 `123456`, Clips的bundle id 是 `com.abc.clips` 则应该配置\n\n```\n<meta name=\"apple-itunes-app\" content=\"app-id=123456,app-clip-bundle-id=com.abc.clips\">\n```\n\n### 开发工作\n\n#### 新建App Clip Target\n\n这里以OC工程为例\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9edc6108c0b64885b708ef5c9de8e1d0~tplv-k3u1fbpfcp-zoom-1.image\" >\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa5c9c1032174d77a4db0518029b78dd~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n#### 配置证书和Associated Domains\n\n用刚才生成的证书去配置一下即可\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fbccb4eee1445ca9b680200358535e0~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n添加Associated Domains，目的是打开对应域名网页后，页面上方能够出现Clip的入口。\n\n**这里可以添加多个域名，注意每个域名都需要配置apple-app-site-association！！！**\n\n**主工程的Target和Clip的Target都需要配置！！！**\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5125ca96f15433b8205294e48906e13~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n#### 编写代码\n\n创建完之后就会生成一个文件夹，里面就是我们熟悉的AppDelegate、SecneDelegate、Main.storyboard、Info.plist等文件，如果你不使用Storyboard进行界面搭建，那么也是跟之前的开发模式一样，删除info.plist内Application Scene Manifest，修改General-Deployment info - Main interface 为空，修改AppDelegate.m，在里面创建根控制器。\n\n之后的操作就跟普通开发一样了，调试的话可以直接在Xcode上左上角选择Clip的target，然后就可以跑起来了。\n\n另外，AppIcon是需要独立配置的，同样也是在Clip项目工程文件夹内Assets.xcassets。\n\n##### 非组件化开发模式\n\n一般情况下我们是需要复用代码的，将代码内某些模块功能进行复用，然后直接用在Clip，这时候我们只需要在右侧Target Membership勾选新建的Clip Target即可。\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2847eb910740229f410d0aa29f7bb5~tplv-k3u1fbpfcp-zoom-1.image\" width=30%>\n\n同样的 相关的依赖到的文件也需要勾选Clip Target\n\n##### 组件化开发模式 和 Podfile的配置\n\n如果是在组件化开发模式下，那么就需要配置Podfile\n\n在Podfile 底部新增代码\n\n```\nsource 'https://github.com/CocoaPods/Specs.git'\n# 你的私有pod仓库\nsource 'https://git.xxx.com/yourprivatepodspec/Podspec.git'\n\ntarget 'YourApp’ do\n    platform :ios, '10.3'\n    pod \"AFNetworking\"\n    pod \"SDWebImage\"\n    # 等等\nend\n\ntarget 'YourApp_Clips' do\n    platform :ios, '10.3'\n    pod 'ComponentA',           :path=> '../ComponentA'\n    pod \"ComponentB\",           :path=>\"../ComponentB\"\n    pod \"AFNetworking\"\n    pod \"SDWebImage\"\n    # 等等\nend\n\n```\n\n但是这样子相同的第三方pod会写两遍，所以我们可以优化成\n\n```\nsource 'https://github.com/CocoaPods/Specs.git'\n# 你的私有pod仓库\nsource 'https://git.xxx.com/yourprivatepodspec/Podspec.git'\n\ndef common_pods\n    pod \"AFNetworking\"\n    pod \"SDWebImage\"\nend\n\ntarget 'YourApp’ do\n    platform :ios, '10.3'\n    common_pods\nend\n\ntarget 'YourApp_Clips' do\n    platform :ios, '14.0'\n    pod 'ComponentA',           :path=> '../ComponentA'\n    pod \"ComponentB\",           :path=>\"../ComponentB\"\n    common_pods\nend\n\n```\n\n##### 抽离模块时不同环境的代码复用问题\n\n假如说A功能需要抽离出来放到Clip，但是A模块里面有需求是会跳转到B模块的，但是我并不希望Clip引入B模块，希望他能在这个地方提示用户下载完整App，那应该怎么做呢？\n\n首先第一个事情，苹果提供了一个Api可以引导弹窗引导用户下载APP\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fec69fde9e64618819b1b526034d23b~tplv-k3u1fbpfcp-zoom-1.image\" width=40%>\n\n```\nUIWindowScene *scene = (UIWindowScene *)[[UIApplication sharedApplication].connectedScenes.allObjects firstObject];\nSKOverlayAppConfiguration *config = [[SKOverlayAppConfiguration alloc] initWithAppIdentifier:@\"你的AppID\" position:SKOverlayPositionBottomRaised];\nSKOverlay *overlay = [[SKOverlay alloc] initWithConfiguration:config];\noverlay.delegate = self; // 添加代理后可以监听弹窗的弹出和消失，可以在代理内添加埋点。\n[overlay presentInScene:scene];\n\n// 主动让弹窗消失\n// [SKOverlay dismissOverlayInScene:scene];\n```\n\n第二. 如何在模块内划分环境，区分是主App还是Clip\n\n方法一：设计一个单例，添加一个枚举属性，分别在`主工程`的AppDelegate和`Clip`的AppDelegate内给单例的属性赋值，标记当前环境。然后在业务代码中获取单例的环境属性后进行判断。\n\n方法二：有时候我们在Clip复用的模块代码内不需要import某些头文件，因为我们不需要这个功能，这时候单例的方法就不管用了，我们需要通过宏去判断。\n\n如果代码不在pod组件内的话，只需要在Clip Target的`Build Settings` - `Preprocessor Macros`添加`APP_CLIPS`宏即可。\n\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7708c16f9c4247a9ab9ec393d01420b1~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n如果是组件化的开发模式，代码在pod内部，那么就稍微有点麻烦，需要在对应podspec新增一个subspec，专门提供给clip使用，然后配置上宏定义\n\n`ComponentA.podspec`\n\n```\n\ns.subspec \"App\" do |ss|\n    ss.source_files = \"xxxxxx\"\nend\n\ns.subspec \"AppClip\" do |ss|\n    ss.source_files = \"xxxxxx\"\n    ss.pod_target_xcconfig = { 'GCC_PREPROCESSOR_DEFINITIONS' => 'APP_CLIPS=1'}\nend\n```\n\n> 这里为什么要弄多一个App的subspec，因为如果主工程直接`pod ComponentA`的话，所有的subspec都会被引入，所以这里为了区分开，就加多了一个专门给主工程用的subspec\n\n`Podfile`\n\n```\ndef common_pods\n    pod \"AFNetworking\"\n    pod \"SDWebImage\"\nend\n\ntarget 'YourApp’ do\n    platform :ios, '10.3'\n    common_pods\n    pod 'ComponentA/App',           :path=> '../ComponentA'\nend\n\ntarget 'YourApp_Clips' do\n    platform :ios, '14.0'\n    pod 'ComponentA/AppClip',   :path=> '../ComponentA'\n    pod \"ComponentB\",           :path=>\"../ComponentB\"\n    common_pods\nend\n```\n\n通过以上方法，就可以用如下方式进行宏判断，区分当前环境\n\n```\n#ifdef APP_CLIPS\n\n#else\n\n#endif\n```\n\n### 测试工作\n\n#### 开发调试\n\n- 可以选择Clip Target直接使用Xcode编译运行\n\n- 可以使用真机扫描二维码，调起Clip卡片，但是前提是Clip要先在真机跑一遍。\n\t\n\t1. 手机点击`设置-开发者-Local Experiences-Register Local Experience`\n\t2. 输入域名、Clip的bundle id、标题、子标题，选择按钮标题、选择Clip弹出的卡片上的图片，然后点击存储即可。\n\t3. 将刚才输入的域名，去草料二维码等二维码生成网站生成一个二维码，然后手机相机扫描即可弹出卡片样式。\n\t4. 具体内容可以参考[官方文档](https://developer.apple.com/documentation/app_clips/testing_your_app_clip_s_launch_experience?language=objc)\n\t\n\n#### 外部测试\n\n1. 可以通过Archive打Release环境的包（Debug状态下没有选择导出Clip ipa的选项，不知道是哪里配置问题，如果有知道的小伙伴可以评论区分享一下），然后单独导出Clip的ipa，上传到蒲公英或者Fir等分发平台，测试同事就可以下载安装测试了。\n2. 如果已经传到了TestFlight，那么也可以在TestFlight上直接点击打开小程序进行测试。\n\n### 苹果官方提及的产品要求\n\n原文：[https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/](https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/)\n\n划重点：\n\n1. 请勿仅将App Clip用作营销用途，不能显示广告。\n \n2. 避免登录，避免不了的话尽可能使用Apple id登录\n\n3. Clips启动后只有在8小时内才能接收推送\n\n### Q&A\n\n1. 苹果文档说的App Clips 10M限制指的是哪个文件的10M\n\t\n\t经过测试后发现，应该是Release环境下Archive后，导出的Clips的ipa的大小，如果有误欢迎评论区指正。\n\t\n2. Clips可以有登录功能吗？\n\n\t可以，但是苹果希望用户能不登录就使用App，如果要登录也首选Sign in with Apple登录的方式(iOS13特性)，但是我们可以学网易严选那样子苹果ID登录之后再弹出手机验证码绑定功能。\n\t\n3. 可以有内购吗？\n\n\t可以。\n\t\n4. 用户使用完Clips后，如果想再次进入，入口在哪儿？\n\n\t假如是网页打开的Clips，那么离开网页后，在桌面的\"资源库\"里可以找到这个Clips并重新打开。如果找不到就搜索资源库，总能搜到的。","slug":"iOS14-App-Clips","published":1,"updated":"2021-04-19T02:25:36.312Z","_id":"cknnynpk30000yl0613zx3w59","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>本文将主要探讨App Clips开发流程 和 组件化、非组件化两种开发方式下如何复用代码的问题。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>App Clips是iOS14系统的新特性之一，类似于小程序，用户可以在不下载App的情况下体验到App的部分功能，如网易严选的商品详情功能（<a href=\"https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw\">https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw</a>），该功能适合做一些推广和引流的运营工作，另外苹果也提供的原生的浮窗样式，可以引导用户下载完整版App。</p>\n<p>苹果官方文档：<a href=\"https://developer.apple.com/app-clips/\">https://developer.apple.com/app-clips/</a></p>\n<h3 id=\"目前已知的触发方式\"><a href=\"#目前已知的触发方式\" class=\"headerlink\" title=\"目前已知的触发方式\"></a>目前已知的触发方式</h3><ul>\n<li><p>二维码</p>\n<p>  必须使用iOS 14系统相机或者使用控制中心的读取二维码组件来扫码才能触发App Clips。</p>\n</li>\n<li><p>NFC Tags</p>\n<p>  NFC标签感应，比如星巴克桌面内嵌的NFC Tags。</p>\n</li>\n<li><p>Safari App Banner</p>\n<p>  当用户用iOS的Safari浏览器浏览相应的网址后，页面顶部会出现一个横幅，提示用户有App Clips可以用。</p>\n</li>\n<li><p>信息</p>\n<p>  iOS系统自带的iMessage，当你在iMessage发送一个App Clips链接时，系统会自动把信息显示成一个App Clips的卡片。</p>\n</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a13d29c7a17d471dbc551c416ce2ed57~tplv-k3u1fbpfcp-watermark.image\"></p>\n<h3 id=\"开发前置工作\"><a href=\"#开发前置工作\" class=\"headerlink\" title=\"开发前置工作\"></a>开发前置工作</h3><h4 id=\"申请证书\"><a href=\"#申请证书\" class=\"headerlink\" title=\"申请证书\"></a>申请证书</h4><h5 id=\"创建App-Clips-ID\"><a href=\"#创建App-Clips-ID\" class=\"headerlink\" title=\"创建App Clips ID\"></a>创建App Clips ID</h5><ol>\n<li>点击新增APP ID</li>\n</ol>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d62145df226549428f600ace6f1b44cb~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<ol start=\"2\">\n<li>选择App Clip <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f93a07c34f7249b982f0cbca84bfcafe~tplv-k3u1fbpfcp-zoom-1.image\" >\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da0c96044db46bb897aab6f71543c8d~tplv-k3u1fbpfcp-zoom-1.image\" ></li>\n</ol>\n<ol start=\"3\">\n<li>输入一串英文名，用于拼接在主工程的bundle id的后面，生成该clip的bundle id <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2ae0fb422f149d98589f36c80123315~tplv-k3u1fbpfcp-zoom-1.image\" >\n </li>\n<li>在Description内输入描述（不能使用特殊符号），并且在下方勾选App Clip能力，比如Apple Pay，Sign in with Apple，Push等等，<strong>Associated Domains必须勾选</strong><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33e78440190242efaa8dac9b47004393~tplv-k3u1fbpfcp-zoom-1.image\" >\n </li>\n<li>最后确认并点击右上方Register即可</li>\n</ol>\n<h5 id=\"创建Profiles\"><a href=\"#创建Profiles\" class=\"headerlink\" title=\"创建Profiles\"></a>创建Profiles</h5><p>流程跟创建App的Profiles一样，就是选择bundle id的时候改成Clip的bundle id 即可，同样有Development、AdHoc、Distribution三种类型</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68bfe6ee218047b7a3232058dcc2e006~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<h5 id=\"其他配置\"><a href=\"#其他配置\" class=\"headerlink\" title=\"其他配置\"></a>其他配置</h5><p>如果需要其他NFC、地点等等的一些方式触发App Clip配置的话，参考这个苹果的文档<a href=\"https://help.apple.com/app-store-connect/#/dev5b665db74\">https://help.apple.com/app-store-connect/#/dev5b665db74</a></p>\n<h4 id=\"Apple-Store-Connect-配置图片和标题，描述\"><a href=\"#Apple-Store-Connect-配置图片和标题，描述\" class=\"headerlink\" title=\"Apple Store Connect 配置图片和标题，描述\"></a>Apple Store Connect 配置图片和标题，描述</h4><ol>\n<li>需要一张1800 * 1200 的图片，用于显示在Clip的卡片上</li>\n<li>副标题用于显示在卡片标题下的小字，如图所示<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b3e18f56f6d49219fc46f77dab1cef2~tplv-k3u1fbpfcp-zoom-1.image\" width=30%></li>\n<li>操作包括“打开”“查看”“开始游戏”，体现在卡片右边的蓝色按钮内的文案，根据你的产品类型进行选择就好</li>\n</ol>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c14c35967084886bc3f4fce6e985fcb~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n\n<h4 id=\"配置apple-app-site-association-json\"><a href=\"#配置apple-app-site-association-json\" class=\"headerlink\" title=\"配置apple-app-site-association.json\"></a>配置apple-app-site-association.json</h4><p>假设你的开发者账号的Team Id是<code>A123</code>，Clips的bundle id是<code>com.abc.def.clips</code>，主工程的bundle id 是<code>com.abc.def</code>，则配置如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;appclips&quot;:&#123;</span><br><span class=\"line\">        &quot;apps&quot;:[&quot;A123.com.abc.def.clips&quot;]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;applinks&quot;:&#123;</span><br><span class=\"line\">        &quot;apps&quot;:[</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        &quot;details&quot;:&#123;</span><br><span class=\"line\">            &quot;A123.com.abc.def&quot;:&#123;</span><br><span class=\"line\">                &quot;paths&quot;:[</span><br><span class=\"line\">                    &quot;*&quot; &#x2F;&#x2F; 这里的Path根据实际情况配置即可</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;webcredentials&quot;:&#123;</span><br><span class=\"line\">        &quot;apps&quot;:[</span><br><span class=\"line\">            &quot;A123.com.abc.def&quot;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;activitycontinuation&quot;:&#123;</span><br><span class=\"line\">        &quot;apps&quot;:[</span><br><span class=\"line\">            &quot;A123.com.abc.def&quot;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配置完成后部署到你自己域名的根目录下，配置方法网上很多教程，这里贴上<a href=\"https://developer.apple.com/documentation/safariservices/supporting_associated_domains?language=objc\">苹果官方文档</a></p>\n<p>如果配置错了，那么上传包到苹果后台之后，就会显示无效域名<br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05ddb4d106a349d28c1504762697a9eb~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>如果是json配置错误，那么配置正确后不用重新传包，等待苹果那边刷新缓存就好。</p>\n<p>App Clip支持最多在三个域名的网页显示入口，到后面的工程配置那里会说明。</p>\n<h4 id=\"前端页面添加meta标签\"><a href=\"#前端页面添加meta标签\" class=\"headerlink\" title=\"前端页面添加meta标签\"></a>前端页面添加meta标签</h4><p>如果要在H5页面显示Clips入口，加上一段meta标签即可</p>\n<p>如果你的应用市场App id是 <code>123456</code>, Clips的bundle id 是 <code>com.abc.clips</code> 则应该配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name&#x3D;&quot;apple-itunes-app&quot; content&#x3D;&quot;app-id&#x3D;123456,app-clip-bundle-id&#x3D;com.abc.clips&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"开发工作\"><a href=\"#开发工作\" class=\"headerlink\" title=\"开发工作\"></a>开发工作</h3><h4 id=\"新建App-Clip-Target\"><a href=\"#新建App-Clip-Target\" class=\"headerlink\" title=\"新建App Clip Target\"></a>新建App Clip Target</h4><p>这里以OC工程为例</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9edc6108c0b64885b708ef5c9de8e1d0~tplv-k3u1fbpfcp-zoom-1.image\" >\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa5c9c1032174d77a4db0518029b78dd~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<h4 id=\"配置证书和Associated-Domains\"><a href=\"#配置证书和Associated-Domains\" class=\"headerlink\" title=\"配置证书和Associated Domains\"></a>配置证书和Associated Domains</h4><p>用刚才生成的证书去配置一下即可</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fbccb4eee1445ca9b680200358535e0~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<p>添加Associated Domains，目的是打开对应域名网页后，页面上方能够出现Clip的入口。</p>\n<p><strong>这里可以添加多个域名，注意每个域名都需要配置apple-app-site-association！！！</strong></p>\n<p><strong>主工程的Target和Clip的Target都需要配置！！！</strong></p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5125ca96f15433b8205294e48906e13~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<h4 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h4><p>创建完之后就会生成一个文件夹，里面就是我们熟悉的AppDelegate、SecneDelegate、Main.storyboard、Info.plist等文件，如果你不使用Storyboard进行界面搭建，那么也是跟之前的开发模式一样，删除info.plist内Application Scene Manifest，修改General-Deployment info - Main interface 为空，修改AppDelegate.m，在里面创建根控制器。</p>\n<p>之后的操作就跟普通开发一样了，调试的话可以直接在Xcode上左上角选择Clip的target，然后就可以跑起来了。</p>\n<p>另外，AppIcon是需要独立配置的，同样也是在Clip项目工程文件夹内Assets.xcassets。</p>\n<h5 id=\"非组件化开发模式\"><a href=\"#非组件化开发模式\" class=\"headerlink\" title=\"非组件化开发模式\"></a>非组件化开发模式</h5><p>一般情况下我们是需要复用代码的，将代码内某些模块功能进行复用，然后直接用在Clip，这时候我们只需要在右侧Target Membership勾选新建的Clip Target即可。</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2847eb910740229f410d0aa29f7bb5~tplv-k3u1fbpfcp-zoom-1.image\" width=30%>\n\n<p>同样的 相关的依赖到的文件也需要勾选Clip Target</p>\n<h5 id=\"组件化开发模式-和-Podfile的配置\"><a href=\"#组件化开发模式-和-Podfile的配置\" class=\"headerlink\" title=\"组件化开发模式 和 Podfile的配置\"></a>组件化开发模式 和 Podfile的配置</h5><p>如果是在组件化开发模式下，那么就需要配置Podfile</p>\n<p>在Podfile 底部新增代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class=\"line\"># 你的私有pod仓库</span><br><span class=\"line\">source &#39;https:&#x2F;&#x2F;git.xxx.com&#x2F;yourprivatepodspec&#x2F;Podspec.git&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp’ do</span><br><span class=\"line\">    platform :ios, &#39;10.3&#39;</span><br><span class=\"line\">    pod &quot;AFNetworking&quot;</span><br><span class=\"line\">    pod &quot;SDWebImage&quot;</span><br><span class=\"line\">    # 等等</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp_Clips&#39; do</span><br><span class=\"line\">    platform :ios, &#39;10.3&#39;</span><br><span class=\"line\">    pod &#39;ComponentA&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class=\"line\">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class=\"line\">    pod &quot;AFNetworking&quot;</span><br><span class=\"line\">    pod &quot;SDWebImage&quot;</span><br><span class=\"line\">    # 等等</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>但是这样子相同的第三方pod会写两遍，所以我们可以优化成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class=\"line\"># 你的私有pod仓库</span><br><span class=\"line\">source &#39;https:&#x2F;&#x2F;git.xxx.com&#x2F;yourprivatepodspec&#x2F;Podspec.git&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">def common_pods</span><br><span class=\"line\">    pod &quot;AFNetworking&quot;</span><br><span class=\"line\">    pod &quot;SDWebImage&quot;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp’ do</span><br><span class=\"line\">    platform :ios, &#39;10.3&#39;</span><br><span class=\"line\">    common_pods</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp_Clips&#39; do</span><br><span class=\"line\">    platform :ios, &#39;14.0&#39;</span><br><span class=\"line\">    pod &#39;ComponentA&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class=\"line\">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class=\"line\">    common_pods</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"抽离模块时不同环境的代码复用问题\"><a href=\"#抽离模块时不同环境的代码复用问题\" class=\"headerlink\" title=\"抽离模块时不同环境的代码复用问题\"></a>抽离模块时不同环境的代码复用问题</h5><p>假如说A功能需要抽离出来放到Clip，但是A模块里面有需求是会跳转到B模块的，但是我并不希望Clip引入B模块，希望他能在这个地方提示用户下载完整App，那应该怎么做呢？</p>\n<p>首先第一个事情，苹果提供了一个Api可以引导弹窗引导用户下载APP</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fec69fde9e64618819b1b526034d23b~tplv-k3u1fbpfcp-zoom-1.image\" width=40%>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIWindowScene *scene &#x3D; (UIWindowScene *)[[UIApplication sharedApplication].connectedScenes.allObjects firstObject];</span><br><span class=\"line\">SKOverlayAppConfiguration *config &#x3D; [[SKOverlayAppConfiguration alloc] initWithAppIdentifier:@&quot;你的AppID&quot; position:SKOverlayPositionBottomRaised];</span><br><span class=\"line\">SKOverlay *overlay &#x3D; [[SKOverlay alloc] initWithConfiguration:config];</span><br><span class=\"line\">overlay.delegate &#x3D; self; &#x2F;&#x2F; 添加代理后可以监听弹窗的弹出和消失，可以在代理内添加埋点。</span><br><span class=\"line\">[overlay presentInScene:scene];</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 主动让弹窗消失</span><br><span class=\"line\">&#x2F;&#x2F; [SKOverlay dismissOverlayInScene:scene];</span><br></pre></td></tr></table></figure>\n\n<p>第二. 如何在模块内划分环境，区分是主App还是Clip</p>\n<p>方法一：设计一个单例，添加一个枚举属性，分别在<code>主工程</code>的AppDelegate和<code>Clip</code>的AppDelegate内给单例的属性赋值，标记当前环境。然后在业务代码中获取单例的环境属性后进行判断。</p>\n<p>方法二：有时候我们在Clip复用的模块代码内不需要import某些头文件，因为我们不需要这个功能，这时候单例的方法就不管用了，我们需要通过宏去判断。</p>\n<p>如果代码不在pod组件内的话，只需要在Clip Target的<code>Build Settings</code> - <code>Preprocessor Macros</code>添加<code>APP_CLIPS</code>宏即可。</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7708c16f9c4247a9ab9ec393d01420b1~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<p>如果是组件化的开发模式，代码在pod内部，那么就稍微有点麻烦，需要在对应podspec新增一个subspec，专门提供给clip使用，然后配置上宏定义</p>\n<p><code>ComponentA.podspec</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">s.subspec &quot;App&quot; do |ss|</span><br><span class=\"line\">    ss.source_files &#x3D; &quot;xxxxxx&quot;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec &quot;AppClip&quot; do |ss|</span><br><span class=\"line\">    ss.source_files &#x3D; &quot;xxxxxx&quot;</span><br><span class=\"line\">    ss.pod_target_xcconfig &#x3D; &#123; &#39;GCC_PREPROCESSOR_DEFINITIONS&#39; &#x3D;&gt; &#39;APP_CLIPS&#x3D;1&#39;&#125;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里为什么要弄多一个App的subspec，因为如果主工程直接<code>pod ComponentA</code>的话，所有的subspec都会被引入，所以这里为了区分开，就加多了一个专门给主工程用的subspec</p>\n</blockquote>\n<p><code>Podfile</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def common_pods</span><br><span class=\"line\">    pod &quot;AFNetworking&quot;</span><br><span class=\"line\">    pod &quot;SDWebImage&quot;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp’ do</span><br><span class=\"line\">    platform :ios, &#39;10.3&#39;</span><br><span class=\"line\">    common_pods</span><br><span class=\"line\">    pod &#39;ComponentA&#x2F;App&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp_Clips&#39; do</span><br><span class=\"line\">    platform :ios, &#39;14.0&#39;</span><br><span class=\"line\">    pod &#39;ComponentA&#x2F;AppClip&#39;,   :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class=\"line\">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class=\"line\">    common_pods</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>通过以上方法，就可以用如下方式进行宏判断，区分当前环境</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#ifdef APP_CLIPS</span><br><span class=\"line\"></span><br><span class=\"line\">#else</span><br><span class=\"line\"></span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试工作\"><a href=\"#测试工作\" class=\"headerlink\" title=\"测试工作\"></a>测试工作</h3><h4 id=\"开发调试\"><a href=\"#开发调试\" class=\"headerlink\" title=\"开发调试\"></a>开发调试</h4><ul>\n<li><p>可以选择Clip Target直接使用Xcode编译运行</p>\n</li>\n<li><p>可以使用真机扫描二维码，调起Clip卡片，但是前提是Clip要先在真机跑一遍。</p>\n<ol>\n<li>手机点击<code>设置-开发者-Local Experiences-Register Local Experience</code></li>\n<li>输入域名、Clip的bundle id、标题、子标题，选择按钮标题、选择Clip弹出的卡片上的图片，然后点击存储即可。</li>\n<li>将刚才输入的域名，去草料二维码等二维码生成网站生成一个二维码，然后手机相机扫描即可弹出卡片样式。</li>\n<li>具体内容可以参考<a href=\"https://developer.apple.com/documentation/app_clips/testing_your_app_clip_s_launch_experience?language=objc\">官方文档</a></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"外部测试\"><a href=\"#外部测试\" class=\"headerlink\" title=\"外部测试\"></a>外部测试</h4><ol>\n<li>可以通过Archive打Release环境的包（Debug状态下没有选择导出Clip ipa的选项，不知道是哪里配置问题，如果有知道的小伙伴可以评论区分享一下），然后单独导出Clip的ipa，上传到蒲公英或者Fir等分发平台，测试同事就可以下载安装测试了。</li>\n<li>如果已经传到了TestFlight，那么也可以在TestFlight上直接点击打开小程序进行测试。</li>\n</ol>\n<h3 id=\"苹果官方提及的产品要求\"><a href=\"#苹果官方提及的产品要求\" class=\"headerlink\" title=\"苹果官方提及的产品要求\"></a>苹果官方提及的产品要求</h3><p>原文：<a href=\"https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/\">https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/</a></p>\n<p>划重点：</p>\n<ol>\n<li><p>请勿仅将App Clip用作营销用途，不能显示广告。</p>\n</li>\n<li><p>避免登录，避免不了的话尽可能使用Apple id登录</p>\n</li>\n<li><p>Clips启动后只有在8小时内才能接收推送</p>\n</li>\n</ol>\n<h3 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h3><ol>\n<li><p>苹果文档说的App Clips 10M限制指的是哪个文件的10M</p>\n<p> 经过测试后发现，应该是Release环境下Archive后，导出的Clips的ipa的大小，如果有误欢迎评论区指正。</p>\n</li>\n<li><p>Clips可以有登录功能吗？</p>\n<p> 可以，但是苹果希望用户能不登录就使用App，如果要登录也首选Sign in with Apple登录的方式(iOS13特性)，但是我们可以学网易严选那样子苹果ID登录之后再弹出手机验证码绑定功能。</p>\n</li>\n<li><p>可以有内购吗？</p>\n<p> 可以。</p>\n</li>\n<li><p>用户使用完Clips后，如果想再次进入，入口在哪儿？</p>\n<p> 假如是网页打开的Clips，那么离开网页后，在桌面的”资源库”里可以找到这个Clips并重新打开。如果找不到就搜索资源库，总能搜到的。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>本文将主要探讨App Clips开发流程 和 组件化、非组件化两种开发方式下如何复用代码的问题。</p>\n</blockquote>","more":"<p>App Clips是iOS14系统的新特性之一，类似于小程序，用户可以在不下载App的情况下体验到App的部分功能，如网易严选的商品详情功能（<a href=\"https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw\">https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw</a>），该功能适合做一些推广和引流的运营工作，另外苹果也提供的原生的浮窗样式，可以引导用户下载完整版App。</p>\n<p>苹果官方文档：<a href=\"https://developer.apple.com/app-clips/\">https://developer.apple.com/app-clips/</a></p>\n<h3 id=\"目前已知的触发方式\"><a href=\"#目前已知的触发方式\" class=\"headerlink\" title=\"目前已知的触发方式\"></a>目前已知的触发方式</h3><ul>\n<li><p>二维码</p>\n<p>  必须使用iOS 14系统相机或者使用控制中心的读取二维码组件来扫码才能触发App Clips。</p>\n</li>\n<li><p>NFC Tags</p>\n<p>  NFC标签感应，比如星巴克桌面内嵌的NFC Tags。</p>\n</li>\n<li><p>Safari App Banner</p>\n<p>  当用户用iOS的Safari浏览器浏览相应的网址后，页面顶部会出现一个横幅，提示用户有App Clips可以用。</p>\n</li>\n<li><p>信息</p>\n<p>  iOS系统自带的iMessage，当你在iMessage发送一个App Clips链接时，系统会自动把信息显示成一个App Clips的卡片。</p>\n</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a13d29c7a17d471dbc551c416ce2ed57~tplv-k3u1fbpfcp-watermark.image\"></p>\n<h3 id=\"开发前置工作\"><a href=\"#开发前置工作\" class=\"headerlink\" title=\"开发前置工作\"></a>开发前置工作</h3><h4 id=\"申请证书\"><a href=\"#申请证书\" class=\"headerlink\" title=\"申请证书\"></a>申请证书</h4><h5 id=\"创建App-Clips-ID\"><a href=\"#创建App-Clips-ID\" class=\"headerlink\" title=\"创建App Clips ID\"></a>创建App Clips ID</h5><ol>\n<li>点击新增APP ID</li>\n</ol>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d62145df226549428f600ace6f1b44cb~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<ol start=\"2\">\n<li>选择App Clip <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f93a07c34f7249b982f0cbca84bfcafe~tplv-k3u1fbpfcp-zoom-1.image\" >\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da0c96044db46bb897aab6f71543c8d~tplv-k3u1fbpfcp-zoom-1.image\" ></li>\n</ol>\n<ol start=\"3\">\n<li>输入一串英文名，用于拼接在主工程的bundle id的后面，生成该clip的bundle id <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2ae0fb422f149d98589f36c80123315~tplv-k3u1fbpfcp-zoom-1.image\" >\n </li>\n<li>在Description内输入描述（不能使用特殊符号），并且在下方勾选App Clip能力，比如Apple Pay，Sign in with Apple，Push等等，<strong>Associated Domains必须勾选</strong><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33e78440190242efaa8dac9b47004393~tplv-k3u1fbpfcp-zoom-1.image\" >\n </li>\n<li>最后确认并点击右上方Register即可</li>\n</ol>\n<h5 id=\"创建Profiles\"><a href=\"#创建Profiles\" class=\"headerlink\" title=\"创建Profiles\"></a>创建Profiles</h5><p>流程跟创建App的Profiles一样，就是选择bundle id的时候改成Clip的bundle id 即可，同样有Development、AdHoc、Distribution三种类型</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68bfe6ee218047b7a3232058dcc2e006~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<h5 id=\"其他配置\"><a href=\"#其他配置\" class=\"headerlink\" title=\"其他配置\"></a>其他配置</h5><p>如果需要其他NFC、地点等等的一些方式触发App Clip配置的话，参考这个苹果的文档<a href=\"https://help.apple.com/app-store-connect/#/dev5b665db74\">https://help.apple.com/app-store-connect/#/dev5b665db74</a></p>\n<h4 id=\"Apple-Store-Connect-配置图片和标题，描述\"><a href=\"#Apple-Store-Connect-配置图片和标题，描述\" class=\"headerlink\" title=\"Apple Store Connect 配置图片和标题，描述\"></a>Apple Store Connect 配置图片和标题，描述</h4><ol>\n<li>需要一张1800 * 1200 的图片，用于显示在Clip的卡片上</li>\n<li>副标题用于显示在卡片标题下的小字，如图所示<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b3e18f56f6d49219fc46f77dab1cef2~tplv-k3u1fbpfcp-zoom-1.image\" width=30%></li>\n<li>操作包括“打开”“查看”“开始游戏”，体现在卡片右边的蓝色按钮内的文案，根据你的产品类型进行选择就好</li>\n</ol>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c14c35967084886bc3f4fce6e985fcb~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n\n<h4 id=\"配置apple-app-site-association-json\"><a href=\"#配置apple-app-site-association-json\" class=\"headerlink\" title=\"配置apple-app-site-association.json\"></a>配置apple-app-site-association.json</h4><p>假设你的开发者账号的Team Id是<code>A123</code>，Clips的bundle id是<code>com.abc.def.clips</code>，主工程的bundle id 是<code>com.abc.def</code>，则配置如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;appclips&quot;:&#123;</span><br><span class=\"line\">        &quot;apps&quot;:[&quot;A123.com.abc.def.clips&quot;]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;applinks&quot;:&#123;</span><br><span class=\"line\">        &quot;apps&quot;:[</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        &quot;details&quot;:&#123;</span><br><span class=\"line\">            &quot;A123.com.abc.def&quot;:&#123;</span><br><span class=\"line\">                &quot;paths&quot;:[</span><br><span class=\"line\">                    &quot;*&quot; &#x2F;&#x2F; 这里的Path根据实际情况配置即可</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;webcredentials&quot;:&#123;</span><br><span class=\"line\">        &quot;apps&quot;:[</span><br><span class=\"line\">            &quot;A123.com.abc.def&quot;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;activitycontinuation&quot;:&#123;</span><br><span class=\"line\">        &quot;apps&quot;:[</span><br><span class=\"line\">            &quot;A123.com.abc.def&quot;,</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>配置完成后部署到你自己域名的根目录下，配置方法网上很多教程，这里贴上<a href=\"https://developer.apple.com/documentation/safariservices/supporting_associated_domains?language=objc\">苹果官方文档</a></p>\n<p>如果配置错了，那么上传包到苹果后台之后，就会显示无效域名<br><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05ddb4d106a349d28c1504762697a9eb~tplv-k3u1fbpfcp-zoom-1.image\"></p>\n<p>如果是json配置错误，那么配置正确后不用重新传包，等待苹果那边刷新缓存就好。</p>\n<p>App Clip支持最多在三个域名的网页显示入口，到后面的工程配置那里会说明。</p>\n<h4 id=\"前端页面添加meta标签\"><a href=\"#前端页面添加meta标签\" class=\"headerlink\" title=\"前端页面添加meta标签\"></a>前端页面添加meta标签</h4><p>如果要在H5页面显示Clips入口，加上一段meta标签即可</p>\n<p>如果你的应用市场App id是 <code>123456</code>, Clips的bundle id 是 <code>com.abc.clips</code> 则应该配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name&#x3D;&quot;apple-itunes-app&quot; content&#x3D;&quot;app-id&#x3D;123456,app-clip-bundle-id&#x3D;com.abc.clips&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"开发工作\"><a href=\"#开发工作\" class=\"headerlink\" title=\"开发工作\"></a>开发工作</h3><h4 id=\"新建App-Clip-Target\"><a href=\"#新建App-Clip-Target\" class=\"headerlink\" title=\"新建App Clip Target\"></a>新建App Clip Target</h4><p>这里以OC工程为例</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9edc6108c0b64885b708ef5c9de8e1d0~tplv-k3u1fbpfcp-zoom-1.image\" >\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa5c9c1032174d77a4db0518029b78dd~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<h4 id=\"配置证书和Associated-Domains\"><a href=\"#配置证书和Associated-Domains\" class=\"headerlink\" title=\"配置证书和Associated Domains\"></a>配置证书和Associated Domains</h4><p>用刚才生成的证书去配置一下即可</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fbccb4eee1445ca9b680200358535e0~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<p>添加Associated Domains，目的是打开对应域名网页后，页面上方能够出现Clip的入口。</p>\n<p><strong>这里可以添加多个域名，注意每个域名都需要配置apple-app-site-association！！！</strong></p>\n<p><strong>主工程的Target和Clip的Target都需要配置！！！</strong></p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5125ca96f15433b8205294e48906e13~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<h4 id=\"编写代码\"><a href=\"#编写代码\" class=\"headerlink\" title=\"编写代码\"></a>编写代码</h4><p>创建完之后就会生成一个文件夹，里面就是我们熟悉的AppDelegate、SecneDelegate、Main.storyboard、Info.plist等文件，如果你不使用Storyboard进行界面搭建，那么也是跟之前的开发模式一样，删除info.plist内Application Scene Manifest，修改General-Deployment info - Main interface 为空，修改AppDelegate.m，在里面创建根控制器。</p>\n<p>之后的操作就跟普通开发一样了，调试的话可以直接在Xcode上左上角选择Clip的target，然后就可以跑起来了。</p>\n<p>另外，AppIcon是需要独立配置的，同样也是在Clip项目工程文件夹内Assets.xcassets。</p>\n<h5 id=\"非组件化开发模式\"><a href=\"#非组件化开发模式\" class=\"headerlink\" title=\"非组件化开发模式\"></a>非组件化开发模式</h5><p>一般情况下我们是需要复用代码的，将代码内某些模块功能进行复用，然后直接用在Clip，这时候我们只需要在右侧Target Membership勾选新建的Clip Target即可。</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2847eb910740229f410d0aa29f7bb5~tplv-k3u1fbpfcp-zoom-1.image\" width=30%>\n\n<p>同样的 相关的依赖到的文件也需要勾选Clip Target</p>\n<h5 id=\"组件化开发模式-和-Podfile的配置\"><a href=\"#组件化开发模式-和-Podfile的配置\" class=\"headerlink\" title=\"组件化开发模式 和 Podfile的配置\"></a>组件化开发模式 和 Podfile的配置</h5><p>如果是在组件化开发模式下，那么就需要配置Podfile</p>\n<p>在Podfile 底部新增代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class=\"line\"># 你的私有pod仓库</span><br><span class=\"line\">source &#39;https:&#x2F;&#x2F;git.xxx.com&#x2F;yourprivatepodspec&#x2F;Podspec.git&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp’ do</span><br><span class=\"line\">    platform :ios, &#39;10.3&#39;</span><br><span class=\"line\">    pod &quot;AFNetworking&quot;</span><br><span class=\"line\">    pod &quot;SDWebImage&quot;</span><br><span class=\"line\">    # 等等</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp_Clips&#39; do</span><br><span class=\"line\">    platform :ios, &#39;10.3&#39;</span><br><span class=\"line\">    pod &#39;ComponentA&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class=\"line\">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class=\"line\">    pod &quot;AFNetworking&quot;</span><br><span class=\"line\">    pod &quot;SDWebImage&quot;</span><br><span class=\"line\">    # 等等</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>但是这样子相同的第三方pod会写两遍，所以我们可以优化成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class=\"line\"># 你的私有pod仓库</span><br><span class=\"line\">source &#39;https:&#x2F;&#x2F;git.xxx.com&#x2F;yourprivatepodspec&#x2F;Podspec.git&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">def common_pods</span><br><span class=\"line\">    pod &quot;AFNetworking&quot;</span><br><span class=\"line\">    pod &quot;SDWebImage&quot;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp’ do</span><br><span class=\"line\">    platform :ios, &#39;10.3&#39;</span><br><span class=\"line\">    common_pods</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp_Clips&#39; do</span><br><span class=\"line\">    platform :ios, &#39;14.0&#39;</span><br><span class=\"line\">    pod &#39;ComponentA&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class=\"line\">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class=\"line\">    common_pods</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"抽离模块时不同环境的代码复用问题\"><a href=\"#抽离模块时不同环境的代码复用问题\" class=\"headerlink\" title=\"抽离模块时不同环境的代码复用问题\"></a>抽离模块时不同环境的代码复用问题</h5><p>假如说A功能需要抽离出来放到Clip，但是A模块里面有需求是会跳转到B模块的，但是我并不希望Clip引入B模块，希望他能在这个地方提示用户下载完整App，那应该怎么做呢？</p>\n<p>首先第一个事情，苹果提供了一个Api可以引导弹窗引导用户下载APP</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fec69fde9e64618819b1b526034d23b~tplv-k3u1fbpfcp-zoom-1.image\" width=40%>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UIWindowScene *scene &#x3D; (UIWindowScene *)[[UIApplication sharedApplication].connectedScenes.allObjects firstObject];</span><br><span class=\"line\">SKOverlayAppConfiguration *config &#x3D; [[SKOverlayAppConfiguration alloc] initWithAppIdentifier:@&quot;你的AppID&quot; position:SKOverlayPositionBottomRaised];</span><br><span class=\"line\">SKOverlay *overlay &#x3D; [[SKOverlay alloc] initWithConfiguration:config];</span><br><span class=\"line\">overlay.delegate &#x3D; self; &#x2F;&#x2F; 添加代理后可以监听弹窗的弹出和消失，可以在代理内添加埋点。</span><br><span class=\"line\">[overlay presentInScene:scene];</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 主动让弹窗消失</span><br><span class=\"line\">&#x2F;&#x2F; [SKOverlay dismissOverlayInScene:scene];</span><br></pre></td></tr></table></figure>\n\n<p>第二. 如何在模块内划分环境，区分是主App还是Clip</p>\n<p>方法一：设计一个单例，添加一个枚举属性，分别在<code>主工程</code>的AppDelegate和<code>Clip</code>的AppDelegate内给单例的属性赋值，标记当前环境。然后在业务代码中获取单例的环境属性后进行判断。</p>\n<p>方法二：有时候我们在Clip复用的模块代码内不需要import某些头文件，因为我们不需要这个功能，这时候单例的方法就不管用了，我们需要通过宏去判断。</p>\n<p>如果代码不在pod组件内的话，只需要在Clip Target的<code>Build Settings</code> - <code>Preprocessor Macros</code>添加<code>APP_CLIPS</code>宏即可。</p>\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7708c16f9c4247a9ab9ec393d01420b1~tplv-k3u1fbpfcp-zoom-1.image\" >\n\n<p>如果是组件化的开发模式，代码在pod内部，那么就稍微有点麻烦，需要在对应podspec新增一个subspec，专门提供给clip使用，然后配置上宏定义</p>\n<p><code>ComponentA.podspec</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">s.subspec &quot;App&quot; do |ss|</span><br><span class=\"line\">    ss.source_files &#x3D; &quot;xxxxxx&quot;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">s.subspec &quot;AppClip&quot; do |ss|</span><br><span class=\"line\">    ss.source_files &#x3D; &quot;xxxxxx&quot;</span><br><span class=\"line\">    ss.pod_target_xcconfig &#x3D; &#123; &#39;GCC_PREPROCESSOR_DEFINITIONS&#39; &#x3D;&gt; &#39;APP_CLIPS&#x3D;1&#39;&#125;</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里为什么要弄多一个App的subspec，因为如果主工程直接<code>pod ComponentA</code>的话，所有的subspec都会被引入，所以这里为了区分开，就加多了一个专门给主工程用的subspec</p>\n</blockquote>\n<p><code>Podfile</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def common_pods</span><br><span class=\"line\">    pod &quot;AFNetworking&quot;</span><br><span class=\"line\">    pod &quot;SDWebImage&quot;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp’ do</span><br><span class=\"line\">    platform :ios, &#39;10.3&#39;</span><br><span class=\"line\">    common_pods</span><br><span class=\"line\">    pod &#39;ComponentA&#x2F;App&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br><span class=\"line\">target &#39;YourApp_Clips&#39; do</span><br><span class=\"line\">    platform :ios, &#39;14.0&#39;</span><br><span class=\"line\">    pod &#39;ComponentA&#x2F;AppClip&#39;,   :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class=\"line\">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class=\"line\">    common_pods</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<p>通过以上方法，就可以用如下方式进行宏判断，区分当前环境</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#ifdef APP_CLIPS</span><br><span class=\"line\"></span><br><span class=\"line\">#else</span><br><span class=\"line\"></span><br><span class=\"line\">#endif</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试工作\"><a href=\"#测试工作\" class=\"headerlink\" title=\"测试工作\"></a>测试工作</h3><h4 id=\"开发调试\"><a href=\"#开发调试\" class=\"headerlink\" title=\"开发调试\"></a>开发调试</h4><ul>\n<li><p>可以选择Clip Target直接使用Xcode编译运行</p>\n</li>\n<li><p>可以使用真机扫描二维码，调起Clip卡片，但是前提是Clip要先在真机跑一遍。</p>\n<ol>\n<li>手机点击<code>设置-开发者-Local Experiences-Register Local Experience</code></li>\n<li>输入域名、Clip的bundle id、标题、子标题，选择按钮标题、选择Clip弹出的卡片上的图片，然后点击存储即可。</li>\n<li>将刚才输入的域名，去草料二维码等二维码生成网站生成一个二维码，然后手机相机扫描即可弹出卡片样式。</li>\n<li>具体内容可以参考<a href=\"https://developer.apple.com/documentation/app_clips/testing_your_app_clip_s_launch_experience?language=objc\">官方文档</a></li>\n</ol>\n</li>\n</ul>\n<h4 id=\"外部测试\"><a href=\"#外部测试\" class=\"headerlink\" title=\"外部测试\"></a>外部测试</h4><ol>\n<li>可以通过Archive打Release环境的包（Debug状态下没有选择导出Clip ipa的选项，不知道是哪里配置问题，如果有知道的小伙伴可以评论区分享一下），然后单独导出Clip的ipa，上传到蒲公英或者Fir等分发平台，测试同事就可以下载安装测试了。</li>\n<li>如果已经传到了TestFlight，那么也可以在TestFlight上直接点击打开小程序进行测试。</li>\n</ol>\n<h3 id=\"苹果官方提及的产品要求\"><a href=\"#苹果官方提及的产品要求\" class=\"headerlink\" title=\"苹果官方提及的产品要求\"></a>苹果官方提及的产品要求</h3><p>原文：<a href=\"https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/\">https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/</a></p>\n<p>划重点：</p>\n<ol>\n<li><p>请勿仅将App Clip用作营销用途，不能显示广告。</p>\n</li>\n<li><p>避免登录，避免不了的话尽可能使用Apple id登录</p>\n</li>\n<li><p>Clips启动后只有在8小时内才能接收推送</p>\n</li>\n</ol>\n<h3 id=\"Q-amp-A\"><a href=\"#Q-amp-A\" class=\"headerlink\" title=\"Q&amp;A\"></a>Q&amp;A</h3><ol>\n<li><p>苹果文档说的App Clips 10M限制指的是哪个文件的10M</p>\n<p> 经过测试后发现，应该是Release环境下Archive后，导出的Clips的ipa的大小，如果有误欢迎评论区指正。</p>\n</li>\n<li><p>Clips可以有登录功能吗？</p>\n<p> 可以，但是苹果希望用户能不登录就使用App，如果要登录也首选Sign in with Apple登录的方式(iOS13特性)，但是我们可以学网易严选那样子苹果ID登录之后再弹出手机验证码绑定功能。</p>\n</li>\n<li><p>可以有内购吗？</p>\n<p> 可以。</p>\n</li>\n<li><p>用户使用完Clips后，如果想再次进入，入口在哪儿？</p>\n<p> 假如是网页打开的Clips，那么离开网页后，在桌面的”资源库”里可以找到这个Clips并重新打开。如果找不到就搜索资源库，总能搜到的。</p>\n</li>\n</ol>"},{"title":"iOS14新API","abbrlink":"36f1cd4f","date":"2020-06-29T03:08:18.000Z","_content":"\niOS 14 新API\n\n<!-- more -->\n\n### Control Appearance update\n\n控件外观更新，比如UISlider、 UIProgressView、UIActivityIndicatorView，长得稍微有点不一样，不影响适配。\n\n![](https://s1.ax1x.com/2020/06/29/NfJ6zt.png)\n\nUIPageControl样式改变并且可以自定义icon\n\n![](https://s1.ax1x.com/2020/06/29/NfYs7F.png)\n\n自定义小心心icon和书签icon\n\n![](https://s1.ax1x.com/2020/06/29/NfYO1I.png)\n\n\n### Color Picker\n\n新增颜色选择器`UIColorPickerViewController`\n\n支持取色器 收藏常用颜色等等\n\n可以配置是否支持调整透明度等等，具体配置项目参考api文档\n\n建议Present弹出\n\n<a href=\"https://sm.ms/image/iz1WnGFImlUvkty\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/iz1WnGFImlUvkty.png\" width=50% ></a>\n\n### Date Picker\n\nUIDatePicker更新UI\n\n两种样式\n\n支持农历\n\n<a href=\"https://sm.ms/image/wMmTIykghRNqWQn\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/wMmTIykghRNqWQn.png\" width=50% ></a>\n\n<a href=\"https://sm.ms/image/uF3WonxPAsDyXaO\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/uF3WonxPAsDyXaO.png\" width=50% ></a>\n\n### Menus \n\n貌似可以替代我们常有的角标弹窗列表按钮需求\n\n基于`UIButton`和`UIBarButtonItem`的新增的`menu`属性，可以配置长按或者单击(配置 `button.showsMenuAsPrimaryAction = true`)弹出菜单列表\n\n<a href=\"https://sm.ms/image/L1XmoD2d7EKj49Y\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/L1XmoD2d7EKj49Y.png\" width=50% ></a>\n\n<a href=\"https://sm.ms/image/ZflMaksQFDuKp3T\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/ZflMaksQFDuKp3T.png\" width=50% ></a>\n\n\nUINavigationBar 的原生返回按钮长按会弹出菜单，可以跳回导航栏栈中的任意一个页面，按钮标题为前面控制器的标题\n\n\n<a href=\"https://sm.ms/image/FVdgXvpGeTBfYKZ\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/FVdgXvpGeTBfYKZ.png\" width=50% ></a>\n\n\n更新弹出菜单内容，将会实时更新并自带系统动画：\n\n`updateVisibleMenu(_ block: (UIMenu) -> UIMenu)`\n\n### UIActions\n\nUIBarButtonItem 新增 fixedSpace(width:) 和 flexibleSpace方法 去调节item之间的间隔，不用像之前那样子创建一个fixedSpace类型的UIBarButtonItem去占位\n\nUIButton新增了一个初始化方法init(type:primaryAction:) type默认为.system 标题为primaryAction.title ，图片为 primaryAction.image\n\n\n### WidgetKit \n\niOS14 重大新特性之一 支持三种宽度的widget，具体内容另外开篇再讲\n<a href=\"https://sm.ms/image/eiXyvjhfgAqQURr\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/eiXyvjhfgAqQURr.png\" width=50% ></a>\n\n\n### 让你的app支持物理键盘\n\n[具体内容查看文档](https://developer.apple.com/documentation/uikit/keyboards_and_input/adding_hardware_keyboard_support_to_your_app)\n\n### Asynchronously Loading Images into Table and Collection Views\n\n[文档](https://developer.apple.com/documentation/uikit/uiimage/asynchronously_loading_images_into_table_and_collection_views)\n\ntableView和CollectionView异步加载网络图片的API\n\n### PHPicker 图片选择器\n\n新的图片选择器，支持多选，不需要用户允许相册访问权限，可以选择图片（包括livePhoto）和视频\n\n<a href=\"https://sm.ms/image/R9fc3SZIlpLhuwB\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/R9fc3SZIlpLhuwB.png\" width=50% ></a>\n\n### 定位权限更新\n\n旧的定位权限弹窗如下：\n\n<a href=\"https://sm.ms/image/kSgBdY3hjRWG21E\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/kSgBdY3hjRWG21E.png\" width=50% ></a>\n\n新的定位权限弹窗如下：\n\n<a href=\"https://sm.ms/image/svo9OnAS1BZdLDP\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/svo9OnAS1BZdLDP.png\" width=50% ></a>\n\n多了个小地图，并且小地图的左上角多了个按钮，点击选择是否允许准确定位。\n\n若不允许的话，开发者获取的定位会变成一个±5公里的范围，并且只能持续定位最多20分钟\n\n通过一个枚举值得知是否用户选择了模糊定位：\n\n<a href=\"https://sm.ms/image/9gh6mbKL7VWe3uH\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/9gh6mbKL7VWe3uH.png\" ></a>\n\n用户可以改变设置，是否允许app获取准确定位\n\n<a href=\"https://sm.ms/image/jsQr4xoevXNa2Ju\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/jsQr4xoevXNa2Ju.png\" ></a>\n\n开发者可以通过在`info.plist`里面配置信息解释为何需要用户选择准确定位\n\n<a href=\"https://sm.ms/image/X5CRUopcnOHG3I2\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/X5CRUopcnOHG3I2.png\" ></a>\n\n让隐私弹窗默认选择模糊定位\n\n<a href=\"https://sm.ms/image/UeLtJhGXOvbKmns\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/UeLtJhGXOvbKmns.png\" width=50%></a>\n\n### UICollectionView重大更新\n\nUICollection从数据源协议到Cell都有了新的API，开发者可以为cell添加各种“附件”，已适配复杂的列表样式，如下第二张图，另外可以在collectionView上使用类似tableView的样式，如下图\n\n<a href=\"https://sm.ms/image/Iaho8TuHE1P4iRx\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/Iaho8TuHE1P4iRx.png\" ></a>\n\n<a href=\"https://sm.ms/image/taEDOVHfAk2LnQe\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/taEDOVHfAk2LnQe.png\"  width=50% ></a>\n\n通过新的配置类，可以做成如下效果\n\n<a href=\"https://sm.ms/image/nlrR8VBkzqy2SdP\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/nlrR8VBkzqy2SdP.png\"  width=50% ></a>\n\n<a href=\"https://sm.ms/image/PhtUgJrCR2OTQwY\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/PhtUgJrCR2OTQwY.png\"  width=50% ></a>\n\n新增一个UICollectionListViewCell，可以做出如下样式的cell\n\n<a href=\"https://sm.ms/image/jlZKFpCybNJPoET\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/jlZKFpCybNJPoET.png\" width=50%  ></a>\n\nCell的注册方式也有所改变，可以看出苹果从API层面已经进入MVVM架构模式了，注册cell需要带上对应的CellViewModel\n\n<a href=\"https://sm.ms/image/2awdL6yOmUzIGrZ\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/2awdL6yOmUzIGrZ.jpg\" width=50% ></a>\n\n另外也支持像UITableViewCell的侧滑操作等等，详细内容将会另外开篇讲述。\n\n具体查看[视频](https://developer.apple.com/videos/play/wwdc2020/10097/)","source":"_posts/iOS14新API.md","raw":"---\ntitle: iOS14新API\nabbrlink: 36f1cd4f\ndate: 2020-06-29 11:08:18\ntags:\n  - iOS\n  - feature\ncategories:\n  - iOS\n---\n\niOS 14 新API\n\n<!-- more -->\n\n### Control Appearance update\n\n控件外观更新，比如UISlider、 UIProgressView、UIActivityIndicatorView，长得稍微有点不一样，不影响适配。\n\n![](https://s1.ax1x.com/2020/06/29/NfJ6zt.png)\n\nUIPageControl样式改变并且可以自定义icon\n\n![](https://s1.ax1x.com/2020/06/29/NfYs7F.png)\n\n自定义小心心icon和书签icon\n\n![](https://s1.ax1x.com/2020/06/29/NfYO1I.png)\n\n\n### Color Picker\n\n新增颜色选择器`UIColorPickerViewController`\n\n支持取色器 收藏常用颜色等等\n\n可以配置是否支持调整透明度等等，具体配置项目参考api文档\n\n建议Present弹出\n\n<a href=\"https://sm.ms/image/iz1WnGFImlUvkty\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/iz1WnGFImlUvkty.png\" width=50% ></a>\n\n### Date Picker\n\nUIDatePicker更新UI\n\n两种样式\n\n支持农历\n\n<a href=\"https://sm.ms/image/wMmTIykghRNqWQn\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/wMmTIykghRNqWQn.png\" width=50% ></a>\n\n<a href=\"https://sm.ms/image/uF3WonxPAsDyXaO\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/uF3WonxPAsDyXaO.png\" width=50% ></a>\n\n### Menus \n\n貌似可以替代我们常有的角标弹窗列表按钮需求\n\n基于`UIButton`和`UIBarButtonItem`的新增的`menu`属性，可以配置长按或者单击(配置 `button.showsMenuAsPrimaryAction = true`)弹出菜单列表\n\n<a href=\"https://sm.ms/image/L1XmoD2d7EKj49Y\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/L1XmoD2d7EKj49Y.png\" width=50% ></a>\n\n<a href=\"https://sm.ms/image/ZflMaksQFDuKp3T\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/ZflMaksQFDuKp3T.png\" width=50% ></a>\n\n\nUINavigationBar 的原生返回按钮长按会弹出菜单，可以跳回导航栏栈中的任意一个页面，按钮标题为前面控制器的标题\n\n\n<a href=\"https://sm.ms/image/FVdgXvpGeTBfYKZ\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/FVdgXvpGeTBfYKZ.png\" width=50% ></a>\n\n\n更新弹出菜单内容，将会实时更新并自带系统动画：\n\n`updateVisibleMenu(_ block: (UIMenu) -> UIMenu)`\n\n### UIActions\n\nUIBarButtonItem 新增 fixedSpace(width:) 和 flexibleSpace方法 去调节item之间的间隔，不用像之前那样子创建一个fixedSpace类型的UIBarButtonItem去占位\n\nUIButton新增了一个初始化方法init(type:primaryAction:) type默认为.system 标题为primaryAction.title ，图片为 primaryAction.image\n\n\n### WidgetKit \n\niOS14 重大新特性之一 支持三种宽度的widget，具体内容另外开篇再讲\n<a href=\"https://sm.ms/image/eiXyvjhfgAqQURr\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/eiXyvjhfgAqQURr.png\" width=50% ></a>\n\n\n### 让你的app支持物理键盘\n\n[具体内容查看文档](https://developer.apple.com/documentation/uikit/keyboards_and_input/adding_hardware_keyboard_support_to_your_app)\n\n### Asynchronously Loading Images into Table and Collection Views\n\n[文档](https://developer.apple.com/documentation/uikit/uiimage/asynchronously_loading_images_into_table_and_collection_views)\n\ntableView和CollectionView异步加载网络图片的API\n\n### PHPicker 图片选择器\n\n新的图片选择器，支持多选，不需要用户允许相册访问权限，可以选择图片（包括livePhoto）和视频\n\n<a href=\"https://sm.ms/image/R9fc3SZIlpLhuwB\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/R9fc3SZIlpLhuwB.png\" width=50% ></a>\n\n### 定位权限更新\n\n旧的定位权限弹窗如下：\n\n<a href=\"https://sm.ms/image/kSgBdY3hjRWG21E\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/kSgBdY3hjRWG21E.png\" width=50% ></a>\n\n新的定位权限弹窗如下：\n\n<a href=\"https://sm.ms/image/svo9OnAS1BZdLDP\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/svo9OnAS1BZdLDP.png\" width=50% ></a>\n\n多了个小地图，并且小地图的左上角多了个按钮，点击选择是否允许准确定位。\n\n若不允许的话，开发者获取的定位会变成一个±5公里的范围，并且只能持续定位最多20分钟\n\n通过一个枚举值得知是否用户选择了模糊定位：\n\n<a href=\"https://sm.ms/image/9gh6mbKL7VWe3uH\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/9gh6mbKL7VWe3uH.png\" ></a>\n\n用户可以改变设置，是否允许app获取准确定位\n\n<a href=\"https://sm.ms/image/jsQr4xoevXNa2Ju\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/jsQr4xoevXNa2Ju.png\" ></a>\n\n开发者可以通过在`info.plist`里面配置信息解释为何需要用户选择准确定位\n\n<a href=\"https://sm.ms/image/X5CRUopcnOHG3I2\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/X5CRUopcnOHG3I2.png\" ></a>\n\n让隐私弹窗默认选择模糊定位\n\n<a href=\"https://sm.ms/image/UeLtJhGXOvbKmns\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/UeLtJhGXOvbKmns.png\" width=50%></a>\n\n### UICollectionView重大更新\n\nUICollection从数据源协议到Cell都有了新的API，开发者可以为cell添加各种“附件”，已适配复杂的列表样式，如下第二张图，另外可以在collectionView上使用类似tableView的样式，如下图\n\n<a href=\"https://sm.ms/image/Iaho8TuHE1P4iRx\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/Iaho8TuHE1P4iRx.png\" ></a>\n\n<a href=\"https://sm.ms/image/taEDOVHfAk2LnQe\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/taEDOVHfAk2LnQe.png\"  width=50% ></a>\n\n通过新的配置类，可以做成如下效果\n\n<a href=\"https://sm.ms/image/nlrR8VBkzqy2SdP\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/nlrR8VBkzqy2SdP.png\"  width=50% ></a>\n\n<a href=\"https://sm.ms/image/PhtUgJrCR2OTQwY\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/PhtUgJrCR2OTQwY.png\"  width=50% ></a>\n\n新增一个UICollectionListViewCell，可以做出如下样式的cell\n\n<a href=\"https://sm.ms/image/jlZKFpCybNJPoET\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/jlZKFpCybNJPoET.png\" width=50%  ></a>\n\nCell的注册方式也有所改变，可以看出苹果从API层面已经进入MVVM架构模式了，注册cell需要带上对应的CellViewModel\n\n<a href=\"https://sm.ms/image/2awdL6yOmUzIGrZ\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/2awdL6yOmUzIGrZ.jpg\" width=50% ></a>\n\n另外也支持像UITableViewCell的侧滑操作等等，详细内容将会另外开篇讲述。\n\n具体查看[视频](https://developer.apple.com/videos/play/wwdc2020/10097/)","slug":"iOS14新API","published":1,"updated":"2021-04-19T02:17:50.694Z","_id":"cknnynpk90001yl065upm6nx9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>iOS 14 新API</p>\n<span id=\"more\"></span>\n\n<h3 id=\"Control-Appearance-update\"><a href=\"#Control-Appearance-update\" class=\"headerlink\" title=\"Control Appearance update\"></a>Control Appearance update</h3><p>控件外观更新，比如UISlider、 UIProgressView、UIActivityIndicatorView，长得稍微有点不一样，不影响适配。</p>\n<p><img src=\"https://s1.ax1x.com/2020/06/29/NfJ6zt.png\"></p>\n<p>UIPageControl样式改变并且可以自定义icon</p>\n<p><img src=\"https://s1.ax1x.com/2020/06/29/NfYs7F.png\"></p>\n<p>自定义小心心icon和书签icon</p>\n<p><img src=\"https://s1.ax1x.com/2020/06/29/NfYO1I.png\"></p>\n<h3 id=\"Color-Picker\"><a href=\"#Color-Picker\" class=\"headerlink\" title=\"Color Picker\"></a>Color Picker</h3><p>新增颜色选择器<code>UIColorPickerViewController</code></p>\n<p>支持取色器 收藏常用颜色等等</p>\n<p>可以配置是否支持调整透明度等等，具体配置项目参考api文档</p>\n<p>建议Present弹出</p>\n<p><a href=\"https://sm.ms/image/iz1WnGFImlUvkty\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/iz1WnGFImlUvkty.png\" width=50% ></a></p>\n<h3 id=\"Date-Picker\"><a href=\"#Date-Picker\" class=\"headerlink\" title=\"Date Picker\"></a>Date Picker</h3><p>UIDatePicker更新UI</p>\n<p>两种样式</p>\n<p>支持农历</p>\n<p><a href=\"https://sm.ms/image/wMmTIykghRNqWQn\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/wMmTIykghRNqWQn.png\" width=50% ></a></p>\n<p><a href=\"https://sm.ms/image/uF3WonxPAsDyXaO\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/uF3WonxPAsDyXaO.png\" width=50% ></a></p>\n<h3 id=\"Menus\"><a href=\"#Menus\" class=\"headerlink\" title=\"Menus\"></a>Menus</h3><p>貌似可以替代我们常有的角标弹窗列表按钮需求</p>\n<p>基于<code>UIButton</code>和<code>UIBarButtonItem</code>的新增的<code>menu</code>属性，可以配置长按或者单击(配置 <code>button.showsMenuAsPrimaryAction = true</code>)弹出菜单列表</p>\n<p><a href=\"https://sm.ms/image/L1XmoD2d7EKj49Y\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/L1XmoD2d7EKj49Y.png\" width=50% ></a></p>\n<p><a href=\"https://sm.ms/image/ZflMaksQFDuKp3T\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/ZflMaksQFDuKp3T.png\" width=50% ></a></p>\n<p>UINavigationBar 的原生返回按钮长按会弹出菜单，可以跳回导航栏栈中的任意一个页面，按钮标题为前面控制器的标题</p>\n<p><a href=\"https://sm.ms/image/FVdgXvpGeTBfYKZ\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/FVdgXvpGeTBfYKZ.png\" width=50% ></a></p>\n<p>更新弹出菜单内容，将会实时更新并自带系统动画：</p>\n<p><code>updateVisibleMenu(_ block: (UIMenu) -&gt; UIMenu)</code></p>\n<h3 id=\"UIActions\"><a href=\"#UIActions\" class=\"headerlink\" title=\"UIActions\"></a>UIActions</h3><p>UIBarButtonItem 新增 fixedSpace(width:) 和 flexibleSpace方法 去调节item之间的间隔，不用像之前那样子创建一个fixedSpace类型的UIBarButtonItem去占位</p>\n<p>UIButton新增了一个初始化方法init(type:primaryAction:) type默认为.system 标题为primaryAction.title ，图片为 primaryAction.image</p>\n<h3 id=\"WidgetKit\"><a href=\"#WidgetKit\" class=\"headerlink\" title=\"WidgetKit\"></a>WidgetKit</h3><p>iOS14 重大新特性之一 支持三种宽度的widget，具体内容另外开篇再讲<br><a href=\"https://sm.ms/image/eiXyvjhfgAqQURr\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/eiXyvjhfgAqQURr.png\" width=50% ></a></p>\n<h3 id=\"让你的app支持物理键盘\"><a href=\"#让你的app支持物理键盘\" class=\"headerlink\" title=\"让你的app支持物理键盘\"></a>让你的app支持物理键盘</h3><p><a href=\"https://developer.apple.com/documentation/uikit/keyboards_and_input/adding_hardware_keyboard_support_to_your_app\">具体内容查看文档</a></p>\n<h3 id=\"Asynchronously-Loading-Images-into-Table-and-Collection-Views\"><a href=\"#Asynchronously-Loading-Images-into-Table-and-Collection-Views\" class=\"headerlink\" title=\"Asynchronously Loading Images into Table and Collection Views\"></a>Asynchronously Loading Images into Table and Collection Views</h3><p><a href=\"https://developer.apple.com/documentation/uikit/uiimage/asynchronously_loading_images_into_table_and_collection_views\">文档</a></p>\n<p>tableView和CollectionView异步加载网络图片的API</p>\n<h3 id=\"PHPicker-图片选择器\"><a href=\"#PHPicker-图片选择器\" class=\"headerlink\" title=\"PHPicker 图片选择器\"></a>PHPicker 图片选择器</h3><p>新的图片选择器，支持多选，不需要用户允许相册访问权限，可以选择图片（包括livePhoto）和视频</p>\n<p><a href=\"https://sm.ms/image/R9fc3SZIlpLhuwB\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/R9fc3SZIlpLhuwB.png\" width=50% ></a></p>\n<h3 id=\"定位权限更新\"><a href=\"#定位权限更新\" class=\"headerlink\" title=\"定位权限更新\"></a>定位权限更新</h3><p>旧的定位权限弹窗如下：</p>\n<p><a href=\"https://sm.ms/image/kSgBdY3hjRWG21E\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/kSgBdY3hjRWG21E.png\" width=50% ></a></p>\n<p>新的定位权限弹窗如下：</p>\n<p><a href=\"https://sm.ms/image/svo9OnAS1BZdLDP\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/svo9OnAS1BZdLDP.png\" width=50% ></a></p>\n<p>多了个小地图，并且小地图的左上角多了个按钮，点击选择是否允许准确定位。</p>\n<p>若不允许的话，开发者获取的定位会变成一个±5公里的范围，并且只能持续定位最多20分钟</p>\n<p>通过一个枚举值得知是否用户选择了模糊定位：</p>\n<p><a href=\"https://sm.ms/image/9gh6mbKL7VWe3uH\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/9gh6mbKL7VWe3uH.png\" ></a></p>\n<p>用户可以改变设置，是否允许app获取准确定位</p>\n<p><a href=\"https://sm.ms/image/jsQr4xoevXNa2Ju\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/jsQr4xoevXNa2Ju.png\" ></a></p>\n<p>开发者可以通过在<code>info.plist</code>里面配置信息解释为何需要用户选择准确定位</p>\n<p><a href=\"https://sm.ms/image/X5CRUopcnOHG3I2\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/X5CRUopcnOHG3I2.png\" ></a></p>\n<p>让隐私弹窗默认选择模糊定位</p>\n<p><a href=\"https://sm.ms/image/UeLtJhGXOvbKmns\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/UeLtJhGXOvbKmns.png\" width=50%></a></p>\n<h3 id=\"UICollectionView重大更新\"><a href=\"#UICollectionView重大更新\" class=\"headerlink\" title=\"UICollectionView重大更新\"></a>UICollectionView重大更新</h3><p>UICollection从数据源协议到Cell都有了新的API，开发者可以为cell添加各种“附件”，已适配复杂的列表样式，如下第二张图，另外可以在collectionView上使用类似tableView的样式，如下图</p>\n<p><a href=\"https://sm.ms/image/Iaho8TuHE1P4iRx\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/Iaho8TuHE1P4iRx.png\" ></a></p>\n<p><a href=\"https://sm.ms/image/taEDOVHfAk2LnQe\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/taEDOVHfAk2LnQe.png\"  width=50% ></a></p>\n<p>通过新的配置类，可以做成如下效果</p>\n<p><a href=\"https://sm.ms/image/nlrR8VBkzqy2SdP\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/nlrR8VBkzqy2SdP.png\"  width=50% ></a></p>\n<p><a href=\"https://sm.ms/image/PhtUgJrCR2OTQwY\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/PhtUgJrCR2OTQwY.png\"  width=50% ></a></p>\n<p>新增一个UICollectionListViewCell，可以做出如下样式的cell</p>\n<p><a href=\"https://sm.ms/image/jlZKFpCybNJPoET\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/jlZKFpCybNJPoET.png\" width=50%  ></a></p>\n<p>Cell的注册方式也有所改变，可以看出苹果从API层面已经进入MVVM架构模式了，注册cell需要带上对应的CellViewModel</p>\n<p><a href=\"https://sm.ms/image/2awdL6yOmUzIGrZ\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/2awdL6yOmUzIGrZ.jpg\" width=50% ></a></p>\n<p>另外也支持像UITableViewCell的侧滑操作等等，详细内容将会另外开篇讲述。</p>\n<p>具体查看<a href=\"https://developer.apple.com/videos/play/wwdc2020/10097/\">视频</a></p>\n","site":{"data":{}},"excerpt":"<p>iOS 14 新API</p>","more":"<h3 id=\"Control-Appearance-update\"><a href=\"#Control-Appearance-update\" class=\"headerlink\" title=\"Control Appearance update\"></a>Control Appearance update</h3><p>控件外观更新，比如UISlider、 UIProgressView、UIActivityIndicatorView，长得稍微有点不一样，不影响适配。</p>\n<p><img src=\"https://s1.ax1x.com/2020/06/29/NfJ6zt.png\"></p>\n<p>UIPageControl样式改变并且可以自定义icon</p>\n<p><img src=\"https://s1.ax1x.com/2020/06/29/NfYs7F.png\"></p>\n<p>自定义小心心icon和书签icon</p>\n<p><img src=\"https://s1.ax1x.com/2020/06/29/NfYO1I.png\"></p>\n<h3 id=\"Color-Picker\"><a href=\"#Color-Picker\" class=\"headerlink\" title=\"Color Picker\"></a>Color Picker</h3><p>新增颜色选择器<code>UIColorPickerViewController</code></p>\n<p>支持取色器 收藏常用颜色等等</p>\n<p>可以配置是否支持调整透明度等等，具体配置项目参考api文档</p>\n<p>建议Present弹出</p>\n<p><a href=\"https://sm.ms/image/iz1WnGFImlUvkty\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/iz1WnGFImlUvkty.png\" width=50% ></a></p>\n<h3 id=\"Date-Picker\"><a href=\"#Date-Picker\" class=\"headerlink\" title=\"Date Picker\"></a>Date Picker</h3><p>UIDatePicker更新UI</p>\n<p>两种样式</p>\n<p>支持农历</p>\n<p><a href=\"https://sm.ms/image/wMmTIykghRNqWQn\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/wMmTIykghRNqWQn.png\" width=50% ></a></p>\n<p><a href=\"https://sm.ms/image/uF3WonxPAsDyXaO\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/uF3WonxPAsDyXaO.png\" width=50% ></a></p>\n<h3 id=\"Menus\"><a href=\"#Menus\" class=\"headerlink\" title=\"Menus\"></a>Menus</h3><p>貌似可以替代我们常有的角标弹窗列表按钮需求</p>\n<p>基于<code>UIButton</code>和<code>UIBarButtonItem</code>的新增的<code>menu</code>属性，可以配置长按或者单击(配置 <code>button.showsMenuAsPrimaryAction = true</code>)弹出菜单列表</p>\n<p><a href=\"https://sm.ms/image/L1XmoD2d7EKj49Y\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/L1XmoD2d7EKj49Y.png\" width=50% ></a></p>\n<p><a href=\"https://sm.ms/image/ZflMaksQFDuKp3T\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/ZflMaksQFDuKp3T.png\" width=50% ></a></p>\n<p>UINavigationBar 的原生返回按钮长按会弹出菜单，可以跳回导航栏栈中的任意一个页面，按钮标题为前面控制器的标题</p>\n<p><a href=\"https://sm.ms/image/FVdgXvpGeTBfYKZ\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/FVdgXvpGeTBfYKZ.png\" width=50% ></a></p>\n<p>更新弹出菜单内容，将会实时更新并自带系统动画：</p>\n<p><code>updateVisibleMenu(_ block: (UIMenu) -&gt; UIMenu)</code></p>\n<h3 id=\"UIActions\"><a href=\"#UIActions\" class=\"headerlink\" title=\"UIActions\"></a>UIActions</h3><p>UIBarButtonItem 新增 fixedSpace(width:) 和 flexibleSpace方法 去调节item之间的间隔，不用像之前那样子创建一个fixedSpace类型的UIBarButtonItem去占位</p>\n<p>UIButton新增了一个初始化方法init(type:primaryAction:) type默认为.system 标题为primaryAction.title ，图片为 primaryAction.image</p>\n<h3 id=\"WidgetKit\"><a href=\"#WidgetKit\" class=\"headerlink\" title=\"WidgetKit\"></a>WidgetKit</h3><p>iOS14 重大新特性之一 支持三种宽度的widget，具体内容另外开篇再讲<br><a href=\"https://sm.ms/image/eiXyvjhfgAqQURr\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/eiXyvjhfgAqQURr.png\" width=50% ></a></p>\n<h3 id=\"让你的app支持物理键盘\"><a href=\"#让你的app支持物理键盘\" class=\"headerlink\" title=\"让你的app支持物理键盘\"></a>让你的app支持物理键盘</h3><p><a href=\"https://developer.apple.com/documentation/uikit/keyboards_and_input/adding_hardware_keyboard_support_to_your_app\">具体内容查看文档</a></p>\n<h3 id=\"Asynchronously-Loading-Images-into-Table-and-Collection-Views\"><a href=\"#Asynchronously-Loading-Images-into-Table-and-Collection-Views\" class=\"headerlink\" title=\"Asynchronously Loading Images into Table and Collection Views\"></a>Asynchronously Loading Images into Table and Collection Views</h3><p><a href=\"https://developer.apple.com/documentation/uikit/uiimage/asynchronously_loading_images_into_table_and_collection_views\">文档</a></p>\n<p>tableView和CollectionView异步加载网络图片的API</p>\n<h3 id=\"PHPicker-图片选择器\"><a href=\"#PHPicker-图片选择器\" class=\"headerlink\" title=\"PHPicker 图片选择器\"></a>PHPicker 图片选择器</h3><p>新的图片选择器，支持多选，不需要用户允许相册访问权限，可以选择图片（包括livePhoto）和视频</p>\n<p><a href=\"https://sm.ms/image/R9fc3SZIlpLhuwB\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/R9fc3SZIlpLhuwB.png\" width=50% ></a></p>\n<h3 id=\"定位权限更新\"><a href=\"#定位权限更新\" class=\"headerlink\" title=\"定位权限更新\"></a>定位权限更新</h3><p>旧的定位权限弹窗如下：</p>\n<p><a href=\"https://sm.ms/image/kSgBdY3hjRWG21E\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/kSgBdY3hjRWG21E.png\" width=50% ></a></p>\n<p>新的定位权限弹窗如下：</p>\n<p><a href=\"https://sm.ms/image/svo9OnAS1BZdLDP\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/svo9OnAS1BZdLDP.png\" width=50% ></a></p>\n<p>多了个小地图，并且小地图的左上角多了个按钮，点击选择是否允许准确定位。</p>\n<p>若不允许的话，开发者获取的定位会变成一个±5公里的范围，并且只能持续定位最多20分钟</p>\n<p>通过一个枚举值得知是否用户选择了模糊定位：</p>\n<p><a href=\"https://sm.ms/image/9gh6mbKL7VWe3uH\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/9gh6mbKL7VWe3uH.png\" ></a></p>\n<p>用户可以改变设置，是否允许app获取准确定位</p>\n<p><a href=\"https://sm.ms/image/jsQr4xoevXNa2Ju\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/jsQr4xoevXNa2Ju.png\" ></a></p>\n<p>开发者可以通过在<code>info.plist</code>里面配置信息解释为何需要用户选择准确定位</p>\n<p><a href=\"https://sm.ms/image/X5CRUopcnOHG3I2\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/X5CRUopcnOHG3I2.png\" ></a></p>\n<p>让隐私弹窗默认选择模糊定位</p>\n<p><a href=\"https://sm.ms/image/UeLtJhGXOvbKmns\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/29/UeLtJhGXOvbKmns.png\" width=50%></a></p>\n<h3 id=\"UICollectionView重大更新\"><a href=\"#UICollectionView重大更新\" class=\"headerlink\" title=\"UICollectionView重大更新\"></a>UICollectionView重大更新</h3><p>UICollection从数据源协议到Cell都有了新的API，开发者可以为cell添加各种“附件”，已适配复杂的列表样式，如下第二张图，另外可以在collectionView上使用类似tableView的样式，如下图</p>\n<p><a href=\"https://sm.ms/image/Iaho8TuHE1P4iRx\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/Iaho8TuHE1P4iRx.png\" ></a></p>\n<p><a href=\"https://sm.ms/image/taEDOVHfAk2LnQe\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/taEDOVHfAk2LnQe.png\"  width=50% ></a></p>\n<p>通过新的配置类，可以做成如下效果</p>\n<p><a href=\"https://sm.ms/image/nlrR8VBkzqy2SdP\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/nlrR8VBkzqy2SdP.png\"  width=50% ></a></p>\n<p><a href=\"https://sm.ms/image/PhtUgJrCR2OTQwY\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/PhtUgJrCR2OTQwY.png\"  width=50% ></a></p>\n<p>新增一个UICollectionListViewCell，可以做出如下样式的cell</p>\n<p><a href=\"https://sm.ms/image/jlZKFpCybNJPoET\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/jlZKFpCybNJPoET.png\" width=50%  ></a></p>\n<p>Cell的注册方式也有所改变，可以看出苹果从API层面已经进入MVVM架构模式了，注册cell需要带上对应的CellViewModel</p>\n<p><a href=\"https://sm.ms/image/2awdL6yOmUzIGrZ\" target=\"_blank\"><img src=\"https://i.loli.net/2020/06/30/2awdL6yOmUzIGrZ.jpg\" width=50% ></a></p>\n<p>另外也支持像UITableViewCell的侧滑操作等等，详细内容将会另外开篇讲述。</p>\n<p>具体查看<a href=\"https://developer.apple.com/videos/play/wwdc2020/10097/\">视频</a></p>"},{"title":"SwiftUI指南","abbrlink":"f6762f39","date":"2019-12-14T02:20:13.000Z","_content":"\niOS 13 SwiftUI 指南\n\n<!--more-->\n\n### 布局方向\n\n#### VStack 垂直布局\n\n默认垂直方向居中布局\n\n```\nVStack {\n\tText(\"默认居中\")\n\tText(\"Hello, World!\")\n\tText(\"Hello, World Again!\")\n}\n```\n\n对齐方向参数可选(`.leading`,`.trailing`,`.center`)\n```\nVStack(alignment:.leading) {\n\tText(\"左对齐\")\n\tText(\"Hello, World!\")\n\tText(\"Hello, World Again!\")\n}\n```\n\t\n\n#### HStack 水平布局\n\n默认水平方向居中布局\n\n```\nHStack {\n\tText(\"默认居中\")\n\tText(\"Hello, World!\")\n\tText(\"Hello, World Again!\")\n}\n```\n\n对齐方向参数可选(`.top`,`.bottom`,`.center`)\n```\nHStack(alignment:.bottom) {\n\tText(\"左对齐\")\n\tText(\"Hello, World!\")\n\tText(\"Hello, World Again!\")\n}\n```\n\n### ZStack 前后布局\n\n代码下面内容的盖住上面的内容\n\n默认水平居中&垂直居中\n\n```\nZStack {\n\tText(\"默认居中\")\n\tText(\"Hello, World!\")\n}\n```\n\n对齐方向参数可选(`.leading`,`.trailing`,`.top`,`.bottom`,`.topLeading`,`.topTrailing`,`.bottomLeading`,`.bottomTrailing`)\n\n```\nZStack(alignment:.bottom) {\n\tText(\"底部对齐\")\n\tText(\"Hello, World!\")\n}\n```\n\n### Padding\n\n内边距，用来撑开你的布局\n\n默认撑开上下左右各16pt\n\n```\nZStack{\n\tText(\"默认居中\").padding()\n}\n```\n\n可以指定哪个位置撑开和数值大小\n\n```\nZStack{\n\tText(\"默认居中\").padding(20) // 上下左右均撑开20\n}\n```\n\n```\nZStack{\n\tText(\"默认居中\").padding(.leading: 20) // 左边撑开20，其他同理\n}\n```\n\n```\nZStack{\n\tText(\"默认居中\").padding([.leading,.trailing],50).fixedSize() // 左边和右边都撑开50，其他同理，fixedSize意思等同于UILabel的sizeToFit\n}\n```\n\n```\nZStack{\n\tText(\"默认居中\").padding(.leading, 10).padding(.top, 20) // 左边10，上边20，其他同理\n}\n```\n\n### Spacer\n\n用来填充空位。\n\n因为SwiftUI不像原来的UI开发，是先设置好frame,再往里面添加东西，相反，他是一种先紧紧包住控件，然后通过padding、spacer等元素去“撑开”视图的思想。所以，Spacer在这里有点类似于UIBarButtonItem里的那个`UIBarButtonSystemItemFlexibleSpace`,就是把东西给撑开。\n\n举个例子\n\n水平界面这时候布局紧紧包裹着Text控件\n```\nHStack {\n\tText(\"Hello, World!\")\n}\n```\n\n如果这时候加一个Spacer,那么Text控件就会靠左，右边部分会被Spacer把剩余空隙填满\n\n```\nHStack {\n\tText(\"Hello, World!\")\n\tSpacer()\n}\n```\n\n同理如果是`VStack`，写在下面的话，自然就会把Text控件往上顶，然后把剩余屏幕部分填满。\n\n### Image\n\n直接输入图片名就可以引用本地图片\n`Image(\"bg_nuanxin_mask\")`\n\n#### resizeable\n\n`Image(\"bg_nuanxin_mask\").resizable()`\n\n把图片撑开\n\n### 隐藏NavigationBar\n\n```\nNavigationView {\n\tZStack {\n\t\t//...\n\t}\n\t.navigationBarHidden(true)\n\t.navigationBarTitle(\"\")\n\t.navigationBarBackButtonHidden(true)\n}\n```\n\n#### 这个界面不显示，下个界面要显示导航栏\n\n当前页面声明一个属性\n```\n @State private var navBarHidden = true\n```\n\n目标页面加一个属性\n\n```\n@Binding var navBarHidden : Bool\n```\n\n传值过去\n```\nNavigationLink(destination:xxxx, navBarHidden: $navBarHidden)) {\n   xxxxx\n}\n```\n\n目标页面处理\n\n```\nvar body: some View {\n\tWebView(webUrl:\"https://www.baidu.com\",title: $title)\n\t.onAppear {\n\t\tself.navBarHidden = false\n\t}\n\t.onDisappear {\n\t\tself.navBarHidden = true\n\t}\n\t.navigationBarTitle(Text(title),displayMode: .inline)\n}\n```\n\n#### 导航栏标题样式\n\n普通\n```\n.navigationBarTitle(Text(title),displayMode: .inline)\n```\n\n特大\n```\n.navigationBarTitle(Text(title),displayMode: .large)\n```\n\n随滚动自动变化\n```\n.navigationBarTitle(Text(title),displayMode: .automatic)\n```\n\n### 需要用到的一些快捷键\n\ncmd + ctrl + 鼠标左键+控件/布局  =  调出菜单\nctrl + i = 代码缩进调整\t\n\n待续","source":"_posts/SwiftUI指南.md","raw":"---\ntitle: SwiftUI指南\ntags:\n  - iOS\ncategories:\n  - iOS\nabbrlink: f6762f39\ndate: 2019-12-14 10:20:13\n---\n\niOS 13 SwiftUI 指南\n\n<!--more-->\n\n### 布局方向\n\n#### VStack 垂直布局\n\n默认垂直方向居中布局\n\n```\nVStack {\n\tText(\"默认居中\")\n\tText(\"Hello, World!\")\n\tText(\"Hello, World Again!\")\n}\n```\n\n对齐方向参数可选(`.leading`,`.trailing`,`.center`)\n```\nVStack(alignment:.leading) {\n\tText(\"左对齐\")\n\tText(\"Hello, World!\")\n\tText(\"Hello, World Again!\")\n}\n```\n\t\n\n#### HStack 水平布局\n\n默认水平方向居中布局\n\n```\nHStack {\n\tText(\"默认居中\")\n\tText(\"Hello, World!\")\n\tText(\"Hello, World Again!\")\n}\n```\n\n对齐方向参数可选(`.top`,`.bottom`,`.center`)\n```\nHStack(alignment:.bottom) {\n\tText(\"左对齐\")\n\tText(\"Hello, World!\")\n\tText(\"Hello, World Again!\")\n}\n```\n\n### ZStack 前后布局\n\n代码下面内容的盖住上面的内容\n\n默认水平居中&垂直居中\n\n```\nZStack {\n\tText(\"默认居中\")\n\tText(\"Hello, World!\")\n}\n```\n\n对齐方向参数可选(`.leading`,`.trailing`,`.top`,`.bottom`,`.topLeading`,`.topTrailing`,`.bottomLeading`,`.bottomTrailing`)\n\n```\nZStack(alignment:.bottom) {\n\tText(\"底部对齐\")\n\tText(\"Hello, World!\")\n}\n```\n\n### Padding\n\n内边距，用来撑开你的布局\n\n默认撑开上下左右各16pt\n\n```\nZStack{\n\tText(\"默认居中\").padding()\n}\n```\n\n可以指定哪个位置撑开和数值大小\n\n```\nZStack{\n\tText(\"默认居中\").padding(20) // 上下左右均撑开20\n}\n```\n\n```\nZStack{\n\tText(\"默认居中\").padding(.leading: 20) // 左边撑开20，其他同理\n}\n```\n\n```\nZStack{\n\tText(\"默认居中\").padding([.leading,.trailing],50).fixedSize() // 左边和右边都撑开50，其他同理，fixedSize意思等同于UILabel的sizeToFit\n}\n```\n\n```\nZStack{\n\tText(\"默认居中\").padding(.leading, 10).padding(.top, 20) // 左边10，上边20，其他同理\n}\n```\n\n### Spacer\n\n用来填充空位。\n\n因为SwiftUI不像原来的UI开发，是先设置好frame,再往里面添加东西，相反，他是一种先紧紧包住控件，然后通过padding、spacer等元素去“撑开”视图的思想。所以，Spacer在这里有点类似于UIBarButtonItem里的那个`UIBarButtonSystemItemFlexibleSpace`,就是把东西给撑开。\n\n举个例子\n\n水平界面这时候布局紧紧包裹着Text控件\n```\nHStack {\n\tText(\"Hello, World!\")\n}\n```\n\n如果这时候加一个Spacer,那么Text控件就会靠左，右边部分会被Spacer把剩余空隙填满\n\n```\nHStack {\n\tText(\"Hello, World!\")\n\tSpacer()\n}\n```\n\n同理如果是`VStack`，写在下面的话，自然就会把Text控件往上顶，然后把剩余屏幕部分填满。\n\n### Image\n\n直接输入图片名就可以引用本地图片\n`Image(\"bg_nuanxin_mask\")`\n\n#### resizeable\n\n`Image(\"bg_nuanxin_mask\").resizable()`\n\n把图片撑开\n\n### 隐藏NavigationBar\n\n```\nNavigationView {\n\tZStack {\n\t\t//...\n\t}\n\t.navigationBarHidden(true)\n\t.navigationBarTitle(\"\")\n\t.navigationBarBackButtonHidden(true)\n}\n```\n\n#### 这个界面不显示，下个界面要显示导航栏\n\n当前页面声明一个属性\n```\n @State private var navBarHidden = true\n```\n\n目标页面加一个属性\n\n```\n@Binding var navBarHidden : Bool\n```\n\n传值过去\n```\nNavigationLink(destination:xxxx, navBarHidden: $navBarHidden)) {\n   xxxxx\n}\n```\n\n目标页面处理\n\n```\nvar body: some View {\n\tWebView(webUrl:\"https://www.baidu.com\",title: $title)\n\t.onAppear {\n\t\tself.navBarHidden = false\n\t}\n\t.onDisappear {\n\t\tself.navBarHidden = true\n\t}\n\t.navigationBarTitle(Text(title),displayMode: .inline)\n}\n```\n\n#### 导航栏标题样式\n\n普通\n```\n.navigationBarTitle(Text(title),displayMode: .inline)\n```\n\n特大\n```\n.navigationBarTitle(Text(title),displayMode: .large)\n```\n\n随滚动自动变化\n```\n.navigationBarTitle(Text(title),displayMode: .automatic)\n```\n\n### 需要用到的一些快捷键\n\ncmd + ctrl + 鼠标左键+控件/布局  =  调出菜单\nctrl + i = 代码缩进调整\t\n\n待续","slug":"SwiftUI指南","published":1,"updated":"2021-04-19T02:22:55.354Z","_id":"cknnz43cq00004x065j7g8r2u","comments":1,"layout":"post","photos":[],"link":"","content":"<p>iOS 13 SwiftUI 指南</p>\n<span id=\"more\"></span>\n\n<h3 id=\"布局方向\"><a href=\"#布局方向\" class=\"headerlink\" title=\"布局方向\"></a>布局方向</h3><h4 id=\"VStack-垂直布局\"><a href=\"#VStack-垂直布局\" class=\"headerlink\" title=\"VStack 垂直布局\"></a>VStack 垂直布局</h4><p>默认垂直方向居中布局</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VStack &#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World Again!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对齐方向参数可选(<code>.leading</code>,<code>.trailing</code>,<code>.center</code>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VStack(alignment:.leading) &#123;</span><br><span class=\"line\">\tText(&quot;左对齐&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World Again!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"HStack-水平布局\"><a href=\"#HStack-水平布局\" class=\"headerlink\" title=\"HStack 水平布局\"></a>HStack 水平布局</h4><p>默认水平方向居中布局</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HStack &#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World Again!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对齐方向参数可选(<code>.top</code>,<code>.bottom</code>,<code>.center</code>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HStack(alignment:.bottom) &#123;</span><br><span class=\"line\">\tText(&quot;左对齐&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World Again!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ZStack-前后布局\"><a href=\"#ZStack-前后布局\" class=\"headerlink\" title=\"ZStack 前后布局\"></a>ZStack 前后布局</h3><p>代码下面内容的盖住上面的内容</p>\n<p>默认水平居中&amp;垂直居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack &#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对齐方向参数可选(<code>.leading</code>,<code>.trailing</code>,<code>.top</code>,<code>.bottom</code>,<code>.topLeading</code>,<code>.topTrailing</code>,<code>.bottomLeading</code>,<code>.bottomTrailing</code>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack(alignment:.bottom) &#123;</span><br><span class=\"line\">\tText(&quot;底部对齐&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Padding\"><a href=\"#Padding\" class=\"headerlink\" title=\"Padding\"></a>Padding</h3><p>内边距，用来撑开你的布局</p>\n<p>默认撑开上下左右各16pt</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以指定哪个位置撑开和数值大小</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding(20) &#x2F;&#x2F; 上下左右均撑开20</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding(.leading: 20) &#x2F;&#x2F; 左边撑开20，其他同理</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding([.leading,.trailing],50).fixedSize() &#x2F;&#x2F; 左边和右边都撑开50，其他同理，fixedSize意思等同于UILabel的sizeToFit</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding(.leading, 10).padding(.top, 20) &#x2F;&#x2F; 左边10，上边20，其他同理</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Spacer\"><a href=\"#Spacer\" class=\"headerlink\" title=\"Spacer\"></a>Spacer</h3><p>用来填充空位。</p>\n<p>因为SwiftUI不像原来的UI开发，是先设置好frame,再往里面添加东西，相反，他是一种先紧紧包住控件，然后通过padding、spacer等元素去“撑开”视图的思想。所以，Spacer在这里有点类似于UIBarButtonItem里的那个<code>UIBarButtonSystemItemFlexibleSpace</code>,就是把东西给撑开。</p>\n<p>举个例子</p>\n<p>水平界面这时候布局紧紧包裹着Text控件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HStack &#123;</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果这时候加一个Spacer,那么Text控件就会靠左，右边部分会被Spacer把剩余空隙填满</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HStack &#123;</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tSpacer()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同理如果是<code>VStack</code>，写在下面的话，自然就会把Text控件往上顶，然后把剩余屏幕部分填满。</p>\n<h3 id=\"Image\"><a href=\"#Image\" class=\"headerlink\" title=\"Image\"></a>Image</h3><p>直接输入图片名就可以引用本地图片<br><code>Image(&quot;bg_nuanxin_mask&quot;)</code></p>\n<h4 id=\"resizeable\"><a href=\"#resizeable\" class=\"headerlink\" title=\"resizeable\"></a>resizeable</h4><p><code>Image(&quot;bg_nuanxin_mask&quot;).resizable()</code></p>\n<p>把图片撑开</p>\n<h3 id=\"隐藏NavigationBar\"><a href=\"#隐藏NavigationBar\" class=\"headerlink\" title=\"隐藏NavigationBar\"></a>隐藏NavigationBar</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NavigationView &#123;</span><br><span class=\"line\">\tZStack &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t.navigationBarHidden(true)</span><br><span class=\"line\">\t.navigationBarTitle(&quot;&quot;)</span><br><span class=\"line\">\t.navigationBarBackButtonHidden(true)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"这个界面不显示，下个界面要显示导航栏\"><a href=\"#这个界面不显示，下个界面要显示导航栏\" class=\"headerlink\" title=\"这个界面不显示，下个界面要显示导航栏\"></a>这个界面不显示，下个界面要显示导航栏</h4><p>当前页面声明一个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@State private var navBarHidden &#x3D; true</span><br></pre></td></tr></table></figure>\n\n<p>目标页面加一个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Binding var navBarHidden : Bool</span><br></pre></td></tr></table></figure>\n\n<p>传值过去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NavigationLink(destination:xxxx, navBarHidden: $navBarHidden)) &#123;</span><br><span class=\"line\">   xxxxx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>目标页面处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var body: some View &#123;</span><br><span class=\"line\">\tWebView(webUrl:&quot;https:&#x2F;&#x2F;www.baidu.com&quot;,title: $title)</span><br><span class=\"line\">\t.onAppear &#123;</span><br><span class=\"line\">\t\tself.navBarHidden &#x3D; false</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t.onDisappear &#123;</span><br><span class=\"line\">\t\tself.navBarHidden &#x3D; true</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t.navigationBarTitle(Text(title),displayMode: .inline)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"导航栏标题样式\"><a href=\"#导航栏标题样式\" class=\"headerlink\" title=\"导航栏标题样式\"></a>导航栏标题样式</h4><p>普通</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.navigationBarTitle(Text(title),displayMode: .inline)</span><br></pre></td></tr></table></figure>\n\n<p>特大</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.navigationBarTitle(Text(title),displayMode: .large)</span><br></pre></td></tr></table></figure>\n\n<p>随滚动自动变化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.navigationBarTitle(Text(title),displayMode: .automatic)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"需要用到的一些快捷键\"><a href=\"#需要用到的一些快捷键\" class=\"headerlink\" title=\"需要用到的一些快捷键\"></a>需要用到的一些快捷键</h3><p>cmd + ctrl + 鼠标左键+控件/布局  =  调出菜单<br>ctrl + i = 代码缩进调整    </p>\n<p>待续</p>\n","site":{"data":{}},"excerpt":"<p>iOS 13 SwiftUI 指南</p>","more":"<h3 id=\"布局方向\"><a href=\"#布局方向\" class=\"headerlink\" title=\"布局方向\"></a>布局方向</h3><h4 id=\"VStack-垂直布局\"><a href=\"#VStack-垂直布局\" class=\"headerlink\" title=\"VStack 垂直布局\"></a>VStack 垂直布局</h4><p>默认垂直方向居中布局</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VStack &#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World Again!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对齐方向参数可选(<code>.leading</code>,<code>.trailing</code>,<code>.center</code>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VStack(alignment:.leading) &#123;</span><br><span class=\"line\">\tText(&quot;左对齐&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World Again!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"HStack-水平布局\"><a href=\"#HStack-水平布局\" class=\"headerlink\" title=\"HStack 水平布局\"></a>HStack 水平布局</h4><p>默认水平方向居中布局</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HStack &#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World Again!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对齐方向参数可选(<code>.top</code>,<code>.bottom</code>,<code>.center</code>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HStack(alignment:.bottom) &#123;</span><br><span class=\"line\">\tText(&quot;左对齐&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World Again!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ZStack-前后布局\"><a href=\"#ZStack-前后布局\" class=\"headerlink\" title=\"ZStack 前后布局\"></a>ZStack 前后布局</h3><p>代码下面内容的盖住上面的内容</p>\n<p>默认水平居中&amp;垂直居中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack &#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对齐方向参数可选(<code>.leading</code>,<code>.trailing</code>,<code>.top</code>,<code>.bottom</code>,<code>.topLeading</code>,<code>.topTrailing</code>,<code>.bottomLeading</code>,<code>.bottomTrailing</code>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack(alignment:.bottom) &#123;</span><br><span class=\"line\">\tText(&quot;底部对齐&quot;)</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Padding\"><a href=\"#Padding\" class=\"headerlink\" title=\"Padding\"></a>Padding</h3><p>内边距，用来撑开你的布局</p>\n<p>默认撑开上下左右各16pt</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以指定哪个位置撑开和数值大小</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding(20) &#x2F;&#x2F; 上下左右均撑开20</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding(.leading: 20) &#x2F;&#x2F; 左边撑开20，其他同理</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding([.leading,.trailing],50).fixedSize() &#x2F;&#x2F; 左边和右边都撑开50，其他同理，fixedSize意思等同于UILabel的sizeToFit</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ZStack&#123;</span><br><span class=\"line\">\tText(&quot;默认居中&quot;).padding(.leading, 10).padding(.top, 20) &#x2F;&#x2F; 左边10，上边20，其他同理</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Spacer\"><a href=\"#Spacer\" class=\"headerlink\" title=\"Spacer\"></a>Spacer</h3><p>用来填充空位。</p>\n<p>因为SwiftUI不像原来的UI开发，是先设置好frame,再往里面添加东西，相反，他是一种先紧紧包住控件，然后通过padding、spacer等元素去“撑开”视图的思想。所以，Spacer在这里有点类似于UIBarButtonItem里的那个<code>UIBarButtonSystemItemFlexibleSpace</code>,就是把东西给撑开。</p>\n<p>举个例子</p>\n<p>水平界面这时候布局紧紧包裹着Text控件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HStack &#123;</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果这时候加一个Spacer,那么Text控件就会靠左，右边部分会被Spacer把剩余空隙填满</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HStack &#123;</span><br><span class=\"line\">\tText(&quot;Hello, World!&quot;)</span><br><span class=\"line\">\tSpacer()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同理如果是<code>VStack</code>，写在下面的话，自然就会把Text控件往上顶，然后把剩余屏幕部分填满。</p>\n<h3 id=\"Image\"><a href=\"#Image\" class=\"headerlink\" title=\"Image\"></a>Image</h3><p>直接输入图片名就可以引用本地图片<br><code>Image(&quot;bg_nuanxin_mask&quot;)</code></p>\n<h4 id=\"resizeable\"><a href=\"#resizeable\" class=\"headerlink\" title=\"resizeable\"></a>resizeable</h4><p><code>Image(&quot;bg_nuanxin_mask&quot;).resizable()</code></p>\n<p>把图片撑开</p>\n<h3 id=\"隐藏NavigationBar\"><a href=\"#隐藏NavigationBar\" class=\"headerlink\" title=\"隐藏NavigationBar\"></a>隐藏NavigationBar</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NavigationView &#123;</span><br><span class=\"line\">\tZStack &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F;...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t.navigationBarHidden(true)</span><br><span class=\"line\">\t.navigationBarTitle(&quot;&quot;)</span><br><span class=\"line\">\t.navigationBarBackButtonHidden(true)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"这个界面不显示，下个界面要显示导航栏\"><a href=\"#这个界面不显示，下个界面要显示导航栏\" class=\"headerlink\" title=\"这个界面不显示，下个界面要显示导航栏\"></a>这个界面不显示，下个界面要显示导航栏</h4><p>当前页面声明一个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@State private var navBarHidden &#x3D; true</span><br></pre></td></tr></table></figure>\n\n<p>目标页面加一个属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Binding var navBarHidden : Bool</span><br></pre></td></tr></table></figure>\n\n<p>传值过去</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NavigationLink(destination:xxxx, navBarHidden: $navBarHidden)) &#123;</span><br><span class=\"line\">   xxxxx</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>目标页面处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var body: some View &#123;</span><br><span class=\"line\">\tWebView(webUrl:&quot;https:&#x2F;&#x2F;www.baidu.com&quot;,title: $title)</span><br><span class=\"line\">\t.onAppear &#123;</span><br><span class=\"line\">\t\tself.navBarHidden &#x3D; false</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t.onDisappear &#123;</span><br><span class=\"line\">\t\tself.navBarHidden &#x3D; true</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t.navigationBarTitle(Text(title),displayMode: .inline)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"导航栏标题样式\"><a href=\"#导航栏标题样式\" class=\"headerlink\" title=\"导航栏标题样式\"></a>导航栏标题样式</h4><p>普通</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.navigationBarTitle(Text(title),displayMode: .inline)</span><br></pre></td></tr></table></figure>\n\n<p>特大</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.navigationBarTitle(Text(title),displayMode: .large)</span><br></pre></td></tr></table></figure>\n\n<p>随滚动自动变化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.navigationBarTitle(Text(title),displayMode: .automatic)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"需要用到的一些快捷键\"><a href=\"#需要用到的一些快捷键\" class=\"headerlink\" title=\"需要用到的一些快捷键\"></a>需要用到的一些快捷键</h3><p>cmd + ctrl + 鼠标左键+控件/布局  =  调出菜单<br>ctrl + i = 代码缩进调整    </p>\n<p>待续</p>"},{"title":"pod install速度慢的终极解决方案","abbrlink":"826fbbdd","date":"2020-04-01T02:13:48.000Z","_content":"\n相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。\n\n<!-- more -->\n\n[原博文](https://blog.csdn.net/iotjin/article/details/81604034)已经被删掉了，所以我自己copy并整理了一份\n\n相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。\n\n使用国内镜像的Specs\n在pod install时使用命令\n`pod install --no-repo-update`\n\n使用proxychains使终端命令走代理\n下面就来说明一下这几种方法为何没有完全解决问题\n\n使用国内镜像的Specs\n这个只是加快了Specs下载更新速度，而且如果使用国内镜像Specs，那么Podfile中就必须指明使用这个Specs。\n\n在pod install时使用命令\n`pod install --no-repo-update`\n\ninstall时不更新本地库，但如果第一次install还是要去github clone代码\n\n使用proxychains使终端命令走代理\n\n这个只是使pod命令走代理，git download的时候不会走代理\n其实真正慢的原因并不在pod命令，而是在于github上的代码库访问速度慢，那么就知道真正的解决方案就是要加快git命令的速度。\n\n我使用Shadowsocks代理，默认代理端口为1080，配置好代理之后去终端输入git配置命令，命令如下\n\n`git config --global http.proxy socks5://127.0.0.1:1080`\n\n> 注意这里的 socks5:// 协议 如果你用的是http/https协议 这里要改成 http:// 或https://\n\n> 这里的http.proxy 一般不用改\n\n> 查看端口号的方式可以在小飞机那里或者其他翻墙软件点击配置信息查看，看本地端口号一项\n\n上面的命令是给git设置全局代理，但是我们并不希望国内git库也走代理，而是只需要github上的代码库走代理，命令如下\n\n`git config --global http.https://github.com.proxy socks5://127.0.0.1:1080`\n\n> 这里的socks5:// 协议 跟上面说的同理\n\n（ps：如果要恢复/移除上面设置的git代理，使用如下命令\n`git config --global --unset http.proxy`\n`git config --global --unset http.https://github.com.proxy`)\n\n（如果不恢复的话，你一旦关掉代理（小飞机），那么之后git命令都跑不了网络了）\n\n> 注意这里的 http.proxy 其实就是上面的`git config --global http.proxy socks5://127.0.0.1:1080`中的 http.proxy, 如果你写的是https.proxy，那么这里unset的时候应该也写https.proxy","source":"_posts/pod-install速度慢的终极解决方案.md","raw":"---\ntitle: pod install速度慢的终极解决方案\ntags:\n  - iOS\n  - Cocoapods\n  - 技巧\ncategories:\n  - iOS\nabbrlink: 826fbbdd\ndate: 2020-04-01 10:13:48\n---\n\n相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。\n\n<!-- more -->\n\n[原博文](https://blog.csdn.net/iotjin/article/details/81604034)已经被删掉了，所以我自己copy并整理了一份\n\n相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。\n\n使用国内镜像的Specs\n在pod install时使用命令\n`pod install --no-repo-update`\n\n使用proxychains使终端命令走代理\n下面就来说明一下这几种方法为何没有完全解决问题\n\n使用国内镜像的Specs\n这个只是加快了Specs下载更新速度，而且如果使用国内镜像Specs，那么Podfile中就必须指明使用这个Specs。\n\n在pod install时使用命令\n`pod install --no-repo-update`\n\ninstall时不更新本地库，但如果第一次install还是要去github clone代码\n\n使用proxychains使终端命令走代理\n\n这个只是使pod命令走代理，git download的时候不会走代理\n其实真正慢的原因并不在pod命令，而是在于github上的代码库访问速度慢，那么就知道真正的解决方案就是要加快git命令的速度。\n\n我使用Shadowsocks代理，默认代理端口为1080，配置好代理之后去终端输入git配置命令，命令如下\n\n`git config --global http.proxy socks5://127.0.0.1:1080`\n\n> 注意这里的 socks5:// 协议 如果你用的是http/https协议 这里要改成 http:// 或https://\n\n> 这里的http.proxy 一般不用改\n\n> 查看端口号的方式可以在小飞机那里或者其他翻墙软件点击配置信息查看，看本地端口号一项\n\n上面的命令是给git设置全局代理，但是我们并不希望国内git库也走代理，而是只需要github上的代码库走代理，命令如下\n\n`git config --global http.https://github.com.proxy socks5://127.0.0.1:1080`\n\n> 这里的socks5:// 协议 跟上面说的同理\n\n（ps：如果要恢复/移除上面设置的git代理，使用如下命令\n`git config --global --unset http.proxy`\n`git config --global --unset http.https://github.com.proxy`)\n\n（如果不恢复的话，你一旦关掉代理（小飞机），那么之后git命令都跑不了网络了）\n\n> 注意这里的 http.proxy 其实就是上面的`git config --global http.proxy socks5://127.0.0.1:1080`中的 http.proxy, 如果你写的是https.proxy，那么这里unset的时候应该也写https.proxy","slug":"pod-install速度慢的终极解决方案","published":1,"updated":"2021-04-19T02:27:15.302Z","_id":"cknnz43d700034x06dvyi6n1s","comments":1,"layout":"post","photos":[],"link":"","content":"<p>相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。</p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://blog.csdn.net/iotjin/article/details/81604034\">原博文</a>已经被删掉了，所以我自己copy并整理了一份</p>\n<p>相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。</p>\n<p>使用国内镜像的Specs<br>在pod install时使用命令<br><code>pod install --no-repo-update</code></p>\n<p>使用proxychains使终端命令走代理<br>下面就来说明一下这几种方法为何没有完全解决问题</p>\n<p>使用国内镜像的Specs<br>这个只是加快了Specs下载更新速度，而且如果使用国内镜像Specs，那么Podfile中就必须指明使用这个Specs。</p>\n<p>在pod install时使用命令<br><code>pod install --no-repo-update</code></p>\n<p>install时不更新本地库，但如果第一次install还是要去github clone代码</p>\n<p>使用proxychains使终端命令走代理</p>\n<p>这个只是使pod命令走代理，git download的时候不会走代理<br>其实真正慢的原因并不在pod命令，而是在于github上的代码库访问速度慢，那么就知道真正的解决方案就是要加快git命令的速度。</p>\n<p>我使用Shadowsocks代理，默认代理端口为1080，配置好代理之后去终端输入git配置命令，命令如下</p>\n<p><code>git config --global http.proxy socks5://127.0.0.1:1080</code></p>\n<blockquote>\n<p>注意这里的 socks5:// 协议 如果你用的是http/https协议 这里要改成 http:// 或https://</p>\n</blockquote>\n<blockquote>\n<p>这里的http.proxy 一般不用改</p>\n</blockquote>\n<blockquote>\n<p>查看端口号的方式可以在小飞机那里或者其他翻墙软件点击配置信息查看，看本地端口号一项</p>\n</blockquote>\n<p>上面的命令是给git设置全局代理，但是我们并不希望国内git库也走代理，而是只需要github上的代码库走代理，命令如下</p>\n<p><code>git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</code></p>\n<blockquote>\n<p>这里的socks5:// 协议 跟上面说的同理</p>\n</blockquote>\n<p>（ps：如果要恢复/移除上面设置的git代理，使用如下命令<br><code>git config --global --unset http.proxy</code><br><code>git config --global --unset http.https://github.com.proxy</code>)</p>\n<p>（如果不恢复的话，你一旦关掉代理（小飞机），那么之后git命令都跑不了网络了）</p>\n<blockquote>\n<p>注意这里的 http.proxy 其实就是上面的<code>git config --global http.proxy socks5://127.0.0.1:1080</code>中的 http.proxy, 如果你写的是https.proxy，那么这里unset的时候应该也写https.proxy</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。</p>","more":"<p><a href=\"https://blog.csdn.net/iotjin/article/details/81604034\">原博文</a>已经被删掉了，所以我自己copy并整理了一份</p>\n<p>相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。</p>\n<p>使用国内镜像的Specs<br>在pod install时使用命令<br><code>pod install --no-repo-update</code></p>\n<p>使用proxychains使终端命令走代理<br>下面就来说明一下这几种方法为何没有完全解决问题</p>\n<p>使用国内镜像的Specs<br>这个只是加快了Specs下载更新速度，而且如果使用国内镜像Specs，那么Podfile中就必须指明使用这个Specs。</p>\n<p>在pod install时使用命令<br><code>pod install --no-repo-update</code></p>\n<p>install时不更新本地库，但如果第一次install还是要去github clone代码</p>\n<p>使用proxychains使终端命令走代理</p>\n<p>这个只是使pod命令走代理，git download的时候不会走代理<br>其实真正慢的原因并不在pod命令，而是在于github上的代码库访问速度慢，那么就知道真正的解决方案就是要加快git命令的速度。</p>\n<p>我使用Shadowsocks代理，默认代理端口为1080，配置好代理之后去终端输入git配置命令，命令如下</p>\n<p><code>git config --global http.proxy socks5://127.0.0.1:1080</code></p>\n<blockquote>\n<p>注意这里的 socks5:// 协议 如果你用的是http/https协议 这里要改成 http:// 或https://</p>\n</blockquote>\n<blockquote>\n<p>这里的http.proxy 一般不用改</p>\n</blockquote>\n<blockquote>\n<p>查看端口号的方式可以在小飞机那里或者其他翻墙软件点击配置信息查看，看本地端口号一项</p>\n</blockquote>\n<p>上面的命令是给git设置全局代理，但是我们并不希望国内git库也走代理，而是只需要github上的代码库走代理，命令如下</p>\n<p><code>git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</code></p>\n<blockquote>\n<p>这里的socks5:// 协议 跟上面说的同理</p>\n</blockquote>\n<p>（ps：如果要恢复/移除上面设置的git代理，使用如下命令<br><code>git config --global --unset http.proxy</code><br><code>git config --global --unset http.https://github.com.proxy</code>)</p>\n<p>（如果不恢复的话，你一旦关掉代理（小飞机），那么之后git命令都跑不了网络了）</p>\n<blockquote>\n<p>注意这里的 http.proxy 其实就是上面的<code>git config --global http.proxy socks5://127.0.0.1:1080</code>中的 http.proxy, 如果你写的是https.proxy，那么这里unset的时候应该也写https.proxy</p>\n</blockquote>"}],"PostAsset":[],"PostCategory":[{"post_id":"cknndog4k000345n0ero73zn8","category_id":"cknndog4o000645n00hu05p7e","_id":"cknndog4t000g45n0b4860t9m"},{"post_id":"cknndog4n000545n02tw0ano0","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog4x000o45n02la23wgl"},{"post_id":"cknndog4t000f45n039k76w3x","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog4x000s45n0blq51gmy"},{"post_id":"cknndog4v000j45n08arj9y1z","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog4y000v45n079knd74l"},{"post_id":"cknndog4p000845n084u349di","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog4z001045n0cvikdekq"},{"post_id":"cknndog4v000l45n08xpgh24l","category_id":"cknndog4o000645n00hu05p7e","_id":"cknndog50001345n07sqv80ng"},{"post_id":"cknndog4p000945n07qtz8j79","category_id":"cknndog4w000n45n0b8691ct9","_id":"cknndog52001745n06cpqfisf"},{"post_id":"cknndog4y000y45n0b8xwhm24","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog53001945n0gl215f0v"},{"post_id":"cknndog4q000a45n00avj47vk","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog53001d45n0cd0024cl"},{"post_id":"cknndog4s000e45n05i2g3yp1","category_id":"cknndog50001445n0go9lbf8b","_id":"cknndog54001h45n07wh4ce84"},{"post_id":"cknndog53001c45n0fui26yh4","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog55001n45n08qerhb32"},{"post_id":"cknndog54001f45n06u3e398p","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog56001q45n047leau7h"},{"post_id":"cknndog4x000q45n0asmre47m","category_id":"cknndog53001a45n01z9nbxqw","_id":"cknndog56001u45n050h942mk"},{"post_id":"cknndog4x000t45n0g3icaq94","category_id":"cknndog53001a45n01z9nbxqw","_id":"cknndog58001y45n0e8l0ansq"},{"post_id":"cknndog56001t45n0gwod5o0h","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog59002345n0fto9hvvd"},{"post_id":"cknndog4z001145n0ccw556ro","category_id":"cknndog50001445n0go9lbf8b","_id":"cknndog5a002845n010ak89z0"},{"post_id":"cknndog58002145n0h67623sd","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog5a002b45n0d2zn8fwb"},{"post_id":"cknndog51001645n0guap55xl","category_id":"cknndog57001x45n039ze8xih","_id":"cknndog5b002f45n04pp045kc"},{"post_id":"cknndog59002745n0aiaw3vyu","category_id":"cknndog53001a45n01z9nbxqw","_id":"cknndog5c002j45n04qlj0ny2"},{"post_id":"cknndog52001845n05fsr0hpy","category_id":"cknndog59002445n0boqz04d4","_id":"cknndog5c002n45n0cro33gqm"},{"post_id":"cknndog5a002a45n012ml5hsl","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog5d002r45n0g958ey9t"},{"post_id":"cknndog55001m45n091id0pww","category_id":"cknndog59002445n0boqz04d4","_id":"cknndog5f002v45n050ax65u3"},{"post_id":"cknndog5b002i45n06e4y5y5y","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog5g002z45n00jjx8jbn"},{"post_id":"cknndog5c002m45n01lknhsof","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog5h003345n024ua690i"},{"post_id":"cknndog55001p45n04uhnb56v","category_id":"cknndog59002445n0boqz04d4","_id":"cknndog5h003745n08dt792a3"},{"post_id":"cknndog5d002q45n0ak3a55c3","category_id":"cknndog53001a45n01z9nbxqw","_id":"cknndog5i003a45n05m6v3ygb"},{"post_id":"cknndog5f002u45n054q476dp","category_id":"cknndog53001a45n01z9nbxqw","_id":"cknndog5l003e45n0avpk8idw"},{"post_id":"cknndog58002245n0fr750fon","category_id":"cknndog5d002s45n022da3a45","_id":"cknndog5o003h45n0258q9ad2"},{"post_id":"cknndog5g002y45n0ar0t5kb0","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog5p003l45n07e327dbu"},{"post_id":"cknndog5g003245n07eh0ea0s","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog5q003o45n0fyl2e2t1"},{"post_id":"cknndog5h003645n0820f43bb","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog5r003s45n08iy05prn"},{"post_id":"cknndog5b002e45n0gas74dex","category_id":"cknndog5g003145n09lyl1wdw","_id":"cknndog5r003v45n0c03896ct"},{"post_id":"cknndog5i003945n00q2tbg8s","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog5s003z45n055xj8941"},{"post_id":"cknndog5j003d45n04tyha92k","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog5s004245n0cflherbc"},{"post_id":"cknndog5m003g45n02as63d8o","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog5u004545n086bv8ezm"},{"post_id":"cknndog5p003k45n07fghgcmb","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog5u004945n0e64e1y3x"},{"post_id":"cknndog5q003n45n03re560ha","category_id":"cknndog53001a45n01z9nbxqw","_id":"cknndog5v004c45n0a87p56k7"},{"post_id":"cknndog5q003r45n0c8kecaik","category_id":"cknndog53001a45n01z9nbxqw","_id":"cknndog5y004g45n02bpwfx8f"},{"post_id":"cknndog5r003u45n028s1a6ha","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog5z004j45n0327h764x"},{"post_id":"cknndog5s003y45n01ccm0bgm","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog5z004n45n07ewr9n8a"},{"post_id":"cknndog5s004145n0gd5pemjc","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog60004r45n07z9d66vb"},{"post_id":"cknndog5t004445n0155eakmv","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog61004v45n0bse92fmx"},{"post_id":"cknndog5u004845n00rxkb5wf","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog62004y45n0ent86ehf"},{"post_id":"cknndog5u004b45n02gy53dou","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog62005145n0gy7j917x"},{"post_id":"cknndog5w004f45n06wb0eusi","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog66005545n0gm0e4dib"},{"post_id":"cknndog5z004m45n0hx4x523j","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog67005845n01ibs4k5h"},{"post_id":"cknndog60004q45n018gq9nl6","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog6b005c45n0cjicbdcp"},{"post_id":"cknndog61004u45n01f8rhr2i","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog6g005f45n09nj4ff9z"},{"post_id":"cknndog5y004i45n0frht3bgc","category_id":"cknndog60004o45n0evvr9s68","_id":"cknndog6i005j45n0cy5xf5zt"},{"post_id":"cknndog62004x45n0chyohdhu","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog6j005m45n08xl99v5i"},{"post_id":"cknndog62005045n089644yge","category_id":"cknndog5g003145n09lyl1wdw","_id":"cknndog6k005q45n02u132pc4"},{"post_id":"cknndog65005445n03b9sepgl","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog6k005t45n04x3dewo5"},{"post_id":"cknndog67005745n038bc1y7q","category_id":"cknndog60004o45n0evvr9s68","_id":"cknndog6n005x45n0apdmbs9b"},{"post_id":"cknndog67005b45n079mzewzr","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog6q006145n01ze6bubj"},{"post_id":"cknndog6c005e45n0ecle2brk","category_id":"cknndog53001a45n01z9nbxqw","_id":"cknndog6q006445n064m7gfrg"},{"post_id":"cknndog6h005i45n08ock0m6i","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog6r006845n0cs5q042q"},{"post_id":"cknndog6j005l45n012vud8j3","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog6s006b45n004enfdpy"},{"post_id":"cknndog6k005s45n07hfnacyf","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog6s006f45n0ecf16eaj"},{"post_id":"cknndog6l005w45n0cobm9gyk","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog6s006i45n09wfga87n"},{"post_id":"cknndog6p006045n04rfd5buk","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog6t006m45n0e9mm0ler"},{"post_id":"cknndog6j005p45n049ya1f6q","category_id":"cknndog6l005u45n09bi2g39r","_id":"cknndog6u006q45n05fwqc344"},{"post_id":"cknndog6q006345n0bprm3wi2","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog6u006t45n0cflob66p"},{"post_id":"cknndog6r006745n03c1c88go","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog6x006x45n0ahau8pw7"},{"post_id":"cknndog6r006a45n0995ufi6n","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog6x006z45n07yq6h6gk"},{"post_id":"cknndog6s006e45n0634764mp","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog6z007245n0cannddes"},{"post_id":"cknndog6t006l45n004le55zr","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog6z007445n0b9pkd3os"},{"post_id":"cknndog6t006p45n06rxy2meg","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog6z007745n0g9hhhlt6"},{"post_id":"cknndog6s006h45n03a297u3s","category_id":"cknndog6t006n45n029r79fzg","_id":"cknndog6z007945n0hbg67ztj"},{"post_id":"cknndog6v006w45n0fpwnhs6z","category_id":"cknndog4q000b45n08zq497ag","_id":"cknndog6z007c45n05vl46q4e"},{"post_id":"cknnz43cq00004x065j7g8r2u","category_id":"cknndog4q000b45n08zq497ag","_id":"cknnz43d800044x066rhsaeaa"},{"post_id":"cknnynpk90001yl065upm6nx9","category_id":"cknndog4q000b45n08zq497ag","_id":"cknnz43db00084x06gt8f3bkh"},{"post_id":"cknnz43d700034x06dvyi6n1s","category_id":"cknndog4q000b45n08zq497ag","_id":"cknnz43dd000b4x06en998su7"},{"post_id":"cknnynpk30000yl0613zx3w59","category_id":"cknndog4q000b45n08zq497ag","_id":"cknnz43de000d4x06dsate675"}],"PostTag":[{"post_id":"cknndog4k000345n0ero73zn8","tag_id":"cknndog4o000745n0dbntbkqw","_id":"cknndog4s000d45n068x081ok"},{"post_id":"cknndog4n000545n02tw0ano0","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog4v000k45n0df9idn8l"},{"post_id":"cknndog4t000f45n039k76w3x","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog4w000m45n02s0pd3vx"},{"post_id":"cknndog4v000j45n08arj9y1z","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog4x000r45n00osg7xx5"},{"post_id":"cknndog4p000845n084u349di","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog4y000u45n06q7d32zp"},{"post_id":"cknndog4v000l45n08xpgh24l","tag_id":"cknndog4o000745n0dbntbkqw","_id":"cknndog4z000z45n08pbh8k0r"},{"post_id":"cknndog4p000945n07qtz8j79","tag_id":"cknndog4x000p45n04zhmgzth","_id":"cknndog4z001245n0bo9ngq5o"},{"post_id":"cknndog4q000a45n00avj47vk","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog53001e45n04y0u8uri"},{"post_id":"cknndog4q000a45n00avj47vk","tag_id":"cknndog50001545n0a4oyhu8p","_id":"cknndog54001g45n0h97eeztv"},{"post_id":"cknndog53001c45n0fui26yh4","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog55001l45n01gm1dcfg"},{"post_id":"cknndog54001f45n06u3e398p","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog55001o45n0f0oyf4s9"},{"post_id":"cknndog4s000e45n05i2g3yp1","tag_id":"cknndog53001b45n08uy810v5","_id":"cknndog56001v45n06ftd36b4"},{"post_id":"cknndog4s000e45n05i2g3yp1","tag_id":"cknndog54001k45n0e1gg9t8h","_id":"cknndog58001z45n0epeu91ii"},{"post_id":"cknndog58002145n0h67623sd","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog59002545n0cagl45ge"},{"post_id":"cknndog4x000q45n0asmre47m","tag_id":"cknndog56001s45n00ggoh2u9","_id":"cknndog5a002945n0hsk70nuu"},{"post_id":"cknndog4x000q45n0asmre47m","tag_id":"cknndog58002045n03p163b1y","_id":"cknndog5a002d45n06g159f6k"},{"post_id":"cknndog59002745n0aiaw3vyu","tag_id":"cknndog58002045n03p163b1y","_id":"cknndog5b002h45n0c73xgg52"},{"post_id":"cknndog5a002a45n012ml5hsl","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog5c002l45n05scy6rn4"},{"post_id":"cknndog4x000t45n0g3icaq94","tag_id":"cknndog59002645n0eaf7dxps","_id":"cknndog5d002p45n0cfqy3ob1"},{"post_id":"cknndog5b002i45n06e4y5y5y","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog5f002t45n0awv71y15"},{"post_id":"cknndog5b002i45n06e4y5y5y","tag_id":"cknndog5b002g45n0cgs19dn5","_id":"cknndog5g002x45n04wbhbx7s"},{"post_id":"cknndog4y000y45n0b8xwhm24","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog5g003045n03l189mlw"},{"post_id":"cknndog4y000y45n0b8xwhm24","tag_id":"cknndog5b002g45n0cgs19dn5","_id":"cknndog5h003545n074upbxpm"},{"post_id":"cknndog5c002m45n01lknhsof","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog5i003845n05uq6ayig"},{"post_id":"cknndog4z001145n0ccw556ro","tag_id":"cknndog53001b45n08uy810v5","_id":"cknndog5i003b45n07c6v9m1b"},{"post_id":"cknndog51001645n0guap55xl","tag_id":"cknndog5f002w45n0d4dh449g","_id":"cknndog5m003f45n0eaz8bq8s"},{"post_id":"cknndog5g003245n07eh0ea0s","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog5p003i45n0fy592sv9"},{"post_id":"cknndog5h003645n0820f43bb","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog5q003m45n0c33u5tbg"},{"post_id":"cknndog52001845n05fsr0hpy","tag_id":"cknndog5h003445n00t0dfzej","_id":"cknndog5q003p45n0ep0de8tp"},{"post_id":"cknndog52001845n05fsr0hpy","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog5r003t45n0giqdaqu1"},{"post_id":"cknndog5i003945n00q2tbg8s","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog5r003w45n081zo9xdx"},{"post_id":"cknndog5j003d45n04tyha92k","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog5s004045n04v293isq"},{"post_id":"cknndog54001i45n00vf0gzx5","tag_id":"cknndog5h003445n00t0dfzej","_id":"cknndog5t004345n0ctluhsp0"},{"post_id":"cknndog5p003k45n07fghgcmb","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog5u004745n00s9g1ekr"},{"post_id":"cknndog55001m45n091id0pww","tag_id":"cknndog5h003445n00t0dfzej","_id":"cknndog5u004a45n0cthic1qg"},{"post_id":"cknndog5q003r45n0c8kecaik","tag_id":"cknndog59002645n0eaf7dxps","_id":"cknndog5w004e45n01aeedadq"},{"post_id":"cknndog55001p45n04uhnb56v","tag_id":"cknndog5h003445n00t0dfzej","_id":"cknndog5y004h45n0dfjsa6d9"},{"post_id":"cknndog5r003u45n028s1a6ha","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog5z004l45n0ds6j01i2"},{"post_id":"cknndog5s003y45n01ccm0bgm","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog60004p45n0e0nd3spy"},{"post_id":"cknndog5s004145n0gd5pemjc","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog60004s45n05ubyg5a1"},{"post_id":"cknndog56001t45n0gwod5o0h","tag_id":"cknndog5r003x45n06ih6e548","_id":"cknndog61004w45n0f9kzfrc2"},{"post_id":"cknndog5u004845n00rxkb5wf","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog62004z45n0478v6p6v"},{"post_id":"cknndog5u004845n00rxkb5wf","tag_id":"cknndog5b002g45n0cgs19dn5","_id":"cknndog65005345n0aqdm9f57"},{"post_id":"cknndog58002245n0fr750fon","tag_id":"cknndog5u004645n08px8f9m3","_id":"cknndog67005645n027do0b40"},{"post_id":"cknndog5u004b45n02gy53dou","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog67005a45n0a6fycu9i"},{"post_id":"cknndog5z004m45n0hx4x523j","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog6c005d45n0321o7cty"},{"post_id":"cknndog5z004m45n0hx4x523j","tag_id":"cknndog50001545n0a4oyhu8p","_id":"cknndog6h005h45n067485cjt"},{"post_id":"cknndog5b002e45n0gas74dex","tag_id":"cknndog5v004d45n0g9mk74zx","_id":"cknndog6j005k45n03i6p8p5k"},{"post_id":"cknndog5b002e45n0gas74dex","tag_id":"cknndog5z004k45n063twfnzq","_id":"cknndog6j005n45n0g7ex7buj"},{"post_id":"cknndog60004q45n018gq9nl6","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog6k005r45n0f74x37ix"},{"post_id":"cknndog61004u45n01f8rhr2i","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog6l005v45n03iucavwx"},{"post_id":"cknndog62004x45n0chyohdhu","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog6p005z45n0gr1d9nrz"},{"post_id":"cknndog5d002q45n0ak3a55c3","tag_id":"cknndog60004t45n07fll4lnf","_id":"cknndog6q006245n0em3dgvch"},{"post_id":"cknndog65005445n03b9sepgl","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog6r006645n06vzuh0fr"},{"post_id":"cknndog65005445n03b9sepgl","tag_id":"cknndog50001545n0a4oyhu8p","_id":"cknndog6r006945n0946z2boj"},{"post_id":"cknndog5f002u45n054q476dp","tag_id":"cknndog63005245n0h34vgz5c","_id":"cknndog6s006d45n01n5k62rg"},{"post_id":"cknndog67005b45n079mzewzr","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog6s006g45n0e4wg2uv3"},{"post_id":"cknndog5g002y45n0ar0t5kb0","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog6t006j45n0bobqbjp3"},{"post_id":"cknndog5g002y45n0ar0t5kb0","tag_id":"cknndog67005945n01f7a0ewx","_id":"cknndog6t006o45n0d0k712fd"},{"post_id":"cknndog6h005i45n08ock0m6i","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog6u006r45n0gxmv5ztp"},{"post_id":"cknndog5m003g45n02as63d8o","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog6v006v45n01xh39ggj"},{"post_id":"cknndog5m003g45n02as63d8o","tag_id":"cknndog6h005g45n0f68qbtfj","_id":"cknndog6x006y45n09xad6b15"},{"post_id":"cknndog6k005s45n07hfnacyf","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog6z007145n02as91fed"},{"post_id":"cknndog5q003n45n03re560ha","tag_id":"cknndog6j005o45n00kip2h9q","_id":"cknndog6z007345n0e04we6rf"},{"post_id":"cknndog6l005w45n0cobm9gyk","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog6z007645n05uf1dsxj"},{"post_id":"cknndog6p006045n04rfd5buk","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog6z007845n08c5ah5el"},{"post_id":"cknndog6q006345n0bprm3wi2","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog6z007b45n01rsmf3n0"},{"post_id":"cknndog6r006745n03c1c88go","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog6z007d45n07lji0mbb"},{"post_id":"cknndog5t004445n0155eakmv","tag_id":"cknndog6o005y45n0f4uq1te3","_id":"cknndog6z007e45n04obo17c0"},{"post_id":"cknndog5t004445n0155eakmv","tag_id":"cknndog6q006545n0avxv5jjq","_id":"cknndog70007g45n09u0sbkqr"},{"post_id":"cknndog6r006a45n0995ufi6n","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog70007h45n04k2w77lw"},{"post_id":"cknndog6s006e45n0634764mp","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog70007j45n0741w3o9m"},{"post_id":"cknndog6t006l45n004le55zr","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog70007k45n064wxfj63"},{"post_id":"cknndog6t006p45n06rxy2meg","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog70007m45n0clte9xev"},{"post_id":"cknndog6u006s45n0agapectq","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog71007n45n0224u6avp"},{"post_id":"cknndog6v006w45n0fpwnhs6z","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog71007p45n0c5lr8e4l"},{"post_id":"cknndog5w004f45n06wb0eusi","tag_id":"cknndog4o000745n0dbntbkqw","_id":"cknndog71007q45n0h75cgtud"},{"post_id":"cknndog5w004f45n06wb0eusi","tag_id":"cknndog6s006c45n06fvig280","_id":"cknndog71007r45n05hb274po"},{"post_id":"cknndog5w004f45n06wb0eusi","tag_id":"cknndog6o005y45n0f4uq1te3","_id":"cknndog71007u45n071goa0m9"},{"post_id":"cknndog5y004i45n0frht3bgc","tag_id":"cknndog5h003445n00t0dfzej","_id":"cknndog71007w45n061959kiv"},{"post_id":"cknndog5y004i45n0frht3bgc","tag_id":"cknndog6x007045n06j5whrdq","_id":"cknndog71007x45n00d8ddm83"},{"post_id":"cknndog5y004i45n0frht3bgc","tag_id":"cknndog6z007545n0hm4pf6q5","_id":"cknndog71007z45n0c7z4en9g"},{"post_id":"cknndog5y004i45n0frht3bgc","tag_id":"cknndog6z007a45n0e74z9ujp","_id":"cknndog71008045n0d681guut"},{"post_id":"cknndog5y004i45n0frht3bgc","tag_id":"cknndog70007f45n0g5txeiqu","_id":"cknndog72008245n0hv5of45j"},{"post_id":"cknndog62005045n089644yge","tag_id":"cknndog70007i45n03x1c0zo3","_id":"cknndog72008345n0hz92aow5"},{"post_id":"cknndog62005045n089644yge","tag_id":"cknndog70007l45n0emqf38t3","_id":"cknndog72008445n0emuo0bm0"},{"post_id":"cknndog6c005e45n0ecle2brk","tag_id":"cknndog71007o45n00yk7c9lp","_id":"cknndog72008545n0f5rd0oqr"},{"post_id":"cknndog6j005l45n012vud8j3","tag_id":"cknndog71007s45n0dy1tg7wo","_id":"cknndog72008645n0et1t9jxx"},{"post_id":"cknndog6j005l45n012vud8j3","tag_id":"cknndog4r000c45n037su8udl","_id":"cknndog72008745n080g099jk"},{"post_id":"cknndog6j005p45n049ya1f6q","tag_id":"cknndog71007v45n0co8ndi3q","_id":"cknndog72008845n07ua75f9f"},{"post_id":"cknndog6s006h45n03a297u3s","tag_id":"cknndog71007y45n0bx726l9g","_id":"cknndog72008945n0dz7jdom8"},{"post_id":"cknnz43cq00004x065j7g8r2u","tag_id":"cknndog4r000c45n037su8udl","_id":"cknnz43d600024x066bn6e0dh"},{"post_id":"cknndog5w004f45n06wb0eusi","tag_id":"cknnz43cs00014x06gx094vkz","_id":"cknnz43d900064x06do7f937t"},{"post_id":"cknnz43d700034x06dvyi6n1s","tag_id":"cknndog4r000c45n037su8udl","_id":"cknnz43da00074x06bg2u7wp1"},{"post_id":"cknnz43d700034x06dvyi6n1s","tag_id":"cknnz43cs00014x06gx094vkz","_id":"cknnz43dd000a4x0674vv5et8"},{"post_id":"cknnz43d700034x06dvyi6n1s","tag_id":"cknndog71007y45n0bx726l9g","_id":"cknnz43de000c4x066c9ld2gl"},{"post_id":"cknnynpk30000yl0613zx3w59","tag_id":"cknndog4r000c45n037su8udl","_id":"cknnz43de000e4x0680lx4q3g"},{"post_id":"cknnynpk30000yl0613zx3w59","tag_id":"cknnz43d800054x060g9b1d3l","_id":"cknnz43de000f4x06705a280c"},{"post_id":"cknndog5h003645n0820f43bb","tag_id":"cknnz43d800054x060g9b1d3l","_id":"cknnz43de000g4x061h7vddvj"},{"post_id":"cknndog6s006h45n03a297u3s","tag_id":"cknndog6s006c45n06fvig280","_id":"cknnz43df000h4x062ehf77dk"},{"post_id":"cknnynpk90001yl065upm6nx9","tag_id":"cknndog4r000c45n037su8udl","_id":"cknnz43df000i4x06dzqp3q18"},{"post_id":"cknnynpk90001yl065upm6nx9","tag_id":"cknnz43d800054x060g9b1d3l","_id":"cknnz43df000j4x065tdr7g7a"}],"Tag":[{"name":"Jenkins","_id":"cknndog4o000745n0dbntbkqw"},{"name":"iOS","_id":"cknndog4r000c45n037su8udl"},{"name":"C++","_id":"cknndog4x000p45n04zhmgzth"},{"name":"杂谈","_id":"cknndog50001545n0a4oyhu8p"},{"name":"Node.js","_id":"cknndog53001b45n08uy810v5"},{"name":"Express","_id":"cknndog54001k45n0e1gg9t8h"},{"name":"Let's Encrypt","_id":"cknndog56001s45n00ggoh2u9"},{"name":"https","_id":"cknndog58002045n03p163b1y"},{"name":"nginx","_id":"cknndog59002645n0eaf7dxps"},{"name":"Reactive Cocoa","_id":"cknndog5b002g45n0cgs19dn5"},{"name":"MongoDB","_id":"cknndog5f002w45n0d4dh449g"},{"name":"React Native","_id":"cknndog5h003445n00t0dfzej"},{"name":"Salesforce","_id":"cknndog5r003x45n06ih6e548"},{"name":"Vue.js","_id":"cknndog5u004645n08px8f9m3"},{"name":"PHP","_id":"cknndog5v004d45n0g9mk74zx"},{"name":"WordPress","_id":"cknndog5z004k45n063twfnzq"},{"name":"docker","_id":"cknndog60004t45n07fll4lnf"},{"name":"frp","_id":"cknndog63005245n0h34vgz5c"},{"name":"XCode","_id":"cknndog67005945n01f7a0ewx"},{"name":"Scene Kit","_id":"cknndog6h005g45n0f68qbtfj"},{"name":"ngrok","_id":"cknndog6j005o45n00kip2h9q"},{"name":"Fir","_id":"cknndog6o005y45n0f4uq1te3"},{"name":"shell","_id":"cknndog6q006545n0avxv5jjq"},{"name":"Git","_id":"cknndog6s006c45n06fvig280"},{"name":"CocoaPods","_id":"cknndog6t006k45n082z02iap"},{"name":"Cordova","_id":"cknndog6x007045n06j5whrdq"},{"name":"AppCan","_id":"cknndog6z007545n0hm4pf6q5"},{"name":"Weex","_id":"cknndog6z007a45n0e74z9ujp"},{"name":"HTML5+","_id":"cknndog70007f45n0g5txeiqu"},{"name":"php","_id":"cknndog70007i45n03x1c0zo3"},{"name":"webhook","_id":"cknndog70007l45n0emqf38t3"},{"name":"Shadowsocks","_id":"cknndog71007o45n00yk7c9lp"},{"name":"Flow.ci","_id":"cknndog71007s45n0dy1tg7wo"},{"name":"Swift","_id":"cknndog71007v45n0co8ndi3q"},{"name":"技巧","_id":"cknndog71007y45n0bx726l9g"},{"name":"git","_id":"cknndog71008145n06dl38w93"},{"name":"Cocoapods","_id":"cknnz43cs00014x06gx094vkz"},{"name":"feature","_id":"cknnz43d800054x060g9b1d3l"}]}}