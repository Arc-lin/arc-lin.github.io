title: iOS 底层原理 --- 多线程
author: Arclin
tags:
  - iOS
  - 底层原理
categories:
  - iOS
abbrlink: f4b0e2bd
date: 2021-07-30 21:49:00
---
本文主要简述iOS中多线程的使用及其原理
<!--more-->

## 常见的多线程方案

|技术方案|简介|语言|线程生命周期|使用频率|
|:---:|:---|:---:|:---:|:---:|
|pthread|<ul><li>一套通用的多线程API</li><li>适用于Unix\Linux\Windows等系统</li><li>跨平台\可移植</li><li>使用难度大</li></ul>|C|程序员管理|几乎不用|
|NSThread|<ul><li>使用更加面向对象</li><li>简单易用，可直接操作线程对象</li></ul>|OC|程序员管理|偶尔使用|
|GCD|<ul><li>旨在替代NSThread等线程技术</li><li>充分利用设备的多核</li></ul>|C|自动管理|经常使用|
|NSOperation|<ul><li>基于GCD</li><li>比GCD多了一些简单实用的功能</li><li>使用更加面向对象</li></ul>|OC|自动管理|经常使用|

### 一些多线程术语

- 同步、异步：能不能开启新的线程
	- 同步：在当前线程中执行任务，不具备开启新线程的能力
    - 异步：在新的线程中执行任务，具备开启新线程的能力
- 并发、串行：任务的执行方式
	- 并发：多个任务并发（同时）执行
    - 串行：一个任务执行完毕后，再执行下一个任务

### 各种队列的执行效果

||并发队列|手动创建的串行队列|主队列|
|---|---|---|---|
|同步（sync）|没有开启新线程<br>串行执行任务|没有开启新线程<br>串行执行任务|没有开启新线程<br>串行执行任务|
|异步（async）|有开启新线程<br>并发执行任务|有开启新线程<br>串行执行任务|没有开启新线程<br>串行执行任务|

- 使用`sync`函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）

- 死锁问题主要产生在串行队列中。由于串行队列的FIFO（First in first out）性质，如果串行队列中有同步函数，那么同步函数要等待串行队列执行完才能执行，又因为同步函数的性质是在当前线程立马执行函数体，所以同步函数后面的代码要等待同步函数执行完才能执行，在这种情况下就会出现死锁

- 因为并发队列允许同时执行多个任务，所以不存在等待队列中其他人完成后才能开始执行的情况，所以一般情况下并发队列不会产生环路等待死锁

## GCD

### GCD的常用函数

- 用同步的方式执行任务

```objective-c
/// queue 队列
/// block 任务
dispatch_sync(dispatch_queue_t queue,dispatch_block_t block);
```

- 用异步的方式执行任务

```objective-c
/// queue 队列
/// block 任务
dispatch_sync(dispatch_queue_t queue,dispatch_block_t block);
```

### GCD 的队列

GCD的队列可以分为2大类型

- 并发队列（Concurrent Dispatch Queue）

	- 可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）
    - 并发功能只有在异步（dispatch_async）函数下才有效
    
- 串行队列（Serial Dispatch Queue）

	- 让任务一个接着一个执行（一个任务执行完毕后，在执行下一个任务）
    
    
  