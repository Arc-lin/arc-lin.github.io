<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arclin</title>
  
  <subtitle>Advocate Technology. Enjoy Technology.</subtitle>
  <link href="https://www.arclin.cn/atom.xml" rel="self"/>
  
  <link href="https://www.arclin.cn/"/>
  <updated>2022-07-12T17:50:45.919Z</updated>
  <id>https://www.arclin.cn/</id>
  
  <author>
    <name>Arclin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Xcode 14 优化</title>
    <link href="https://www.arclin.cn/post/1ff3bfb6.html"/>
    <id>https://www.arclin.cn/post/1ff3bfb6.html</id>
    <published>2022-07-12T16:52:48.000Z</published>
    <updated>2022-07-12T17:50:45.919Z</updated>
    
    <content type="html"><![CDATA[<p>本文简述Xcode 14 的编译优化</p><span id="more"></span><h1 id="Link-fast-Improve-build-and-launch-time"><a href="#Link-fast-Improve-build-and-launch-time" class="headerlink" title="Link fast: Improve build and launch time"></a>Link fast: Improve build and launch time</h1><h2 id="什么是链接"><a href="#什么是链接" class="headerlink" title="什么是链接"></a>什么是链接</h2><p><img src="https://s2.loli.net/2022/07/11/kCstwgSpumHbaeU.jpg" alt="链接过程"></p><p>如图所示，链接将不同的语言，通过前端编译器，编译为中间代码LLVM IR，然后再通过，然后再通过LLVM后端编译器，编译成对应处理器架构的机器语言。</p><p>通过这张图我们可以清晰地看到有了中间代码IR的存在，我们就可以在开发高级语言的时候不用去考虑不同处理器之间的细节，而是统一由LLVM去处理，大大降低了开发成本。</p><p>然后链接这一行为，是发生在LLVM后端编译器上的，因为我们平时写代码的时候，以OC语言为例，每个m代码文件都会被编译成o文件，那多个o文件之间的互相调用，要怎么做呢，这时候就是通过链接把他们都合并成一个文件。比如在iOS中，最后就是产出一个Mach-o文件。</p><p>也就是说，链接将<code>各个模块（各个文件的编译产物）</code>的函数连接起来，产出各个架构的可执行文件。</p><p>然后在iOS中，链接方式有两种</p><ul><li>静态链接（ld64）：影响app的编译时间和包大小，选择性加载</li><li>动态链接（dyld）：影响App的启动耗时</li></ul><p>在iOS中我们制作的一些<code>.a</code>或者<code>.framework</code>这些静态库最后就会经过静态链接过程链接到我们的可执行文件中。</p><p>动态链接一般就是链接一些系统库，在启动的时候按需，动态地加载。</p><h2 id="Mach-0文件"><a href="#Mach-0文件" class="headerlink" title="Mach-0文件"></a>Mach-0文件</h2><p><img src="https://s2.loli.net/2022/07/11/bto5WBdzQ9IGx8E.png" alt="mach-o_format_basic_structure.png"></p><p>首先贴下官方的<a href="https://github.com/aidansteele/osx-abi-macho-file-format-reference/blob/master/Mach-O_File_Format.pdf">文档介绍</a></p><p>一个<code>Mach-O</code>主要包括三个区域</p><ul><li>Header <ul><li>文件类型，目标架构类型等（比如可执行文件、静态库、arm64构架等）</li></ul></li><li>Load commands<ul><li>描述文件在虚拟内存中的逻辑结构、布局（数据段，代码段…都有哪些段，顺序如何，分别是做什么的，怎么做，由<code>Load commands</code>来描述）</li><li>包含着多种命令，包括代码签名命令，符号表命令等</li></ul></li><li>Raw segment data<ul><li>在<code>Load command</code>中定义的<code>Segment</code>的原始数据（在<code>Load command</code>中定义的那些段的原始具体数据）</li></ul></li></ul><h2 id="ld64-优化点"><a href="#ld64-优化点" class="headerlink" title="ld64 优化点"></a>ld64 优化点</h2><p>对于大部分项目来说，速度提升近2倍</p><h3 id="利用多核能力和优化算法加速链接"><a href="#利用多核能力和优化算法加速链接" class="headerlink" title="利用多核能力和优化算法加速链接"></a>利用多核能力和优化算法加速链接</h3><ul><li>与时俱进：利用多核能力，并行计算UUID和签名散列值，类似zld<ul><li>在以往的链接中，一个方法被调用之后，如果里面依赖着另外一个方法，那么链接器就回去找依赖的方法在哪儿，然后找到之后就继续找依赖的方法所依赖的另一个方法，是一串连续的操作。而上面这些操作都是单核串行执行的。Xcode 14优化之后将会利用硬件多核的能力去并行的查找，提高效率。</li></ul></li><li>算法调优：字符串表示（C++ string_view objects）升级</li><li>硬件加速：升级加密库</li><li>配置升级：优化链接配置参数</li></ul><p>静态链接参数 <strong>需要开启<code>all_load</code></strong> 才可以使用上述说明的使用多核能力提升链接速度</p><h3 id="静态链接参数说明"><a href="#静态链接参数说明" class="headerlink" title="静态链接参数说明"></a>静态链接参数说明</h3><ul><li><code>all_load</code>：适用于加载静态库的大部分方法或函数<ul><li>开了了<code>all_load</code>之后，链接器会无差别地把<code>.a</code>或者<code>.framework</code>里面的方法和函数链接起来，不同于以前的选择性加载：发现这个方法会被调用时再去取。</li><li>可以加快链接速度，可以并行解析加载</li><li>缺点：包体积变大，线上环境不建议开启。</li></ul></li><li><code>dead_strip</code>：链接器删除不可访问的代码和数据，配合<code>all_load</code><ul><li>因为<code>all_load</code>会无差别地链接所有方法和函数，导致了包体变大，所以这里开启<code>dead_strip</code>可以删除无用的方法和函数</li><li>注意这里有个风险点：通过runtime调用的方法是检测不到的，所以有可能会被裁掉，编译不会报错，运行时找不到符号才报错。线上环境不建议开启。</li></ul></li><li><code>no_exported_symbols</code>：不导出符号文件，节省时间很短，不考虑<ul><li>线上不能开启，因为我们需要用到符号表去排查问题</li></ul></li><li><code>no_deduplicate</code>：减少重复符号检查来提高链接速度，选择已加载的第一个符号<ul><li>不建议开启，相同的符号可能实现方法会不一样</li></ul></li></ul><p><img src="https://s2.loli.net/2022/07/13/5kwpzPU6rlXZnSC.png" alt="Xcode配置"></p><h2 id="dlyd-优化点"><a href="#dlyd-优化点" class="headerlink" title="dlyd 优化点"></a>dlyd 优化点</h2><p>编译过程中，不需要将主项目中对动态库中的接口的调用，链接到主项目中，而是在主项目中，留下了类似协议的调用，直到启动App，才将真正的实现，关联起来—也就是dlyd过程</p><p>举个例子就是编译链接的时候留一个占位符，表示自己需要这么一个函数，等到启动的时候，系统再从动态库去查找这个符号。</p><ul><li>优势：链接耗时</li><li>劣势：启动耗时，并且因为不同Data pages导致的缺页中断更加凸显</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li><p>dylib chainede fixups(13.4)动态库链式修复：即本身动态库里面方法和函数的地址和app需要用到的地址是不一样的，所以需要动态修复地址，但是需要将部署最低版本设到13.4以上，这样子启动时的动态库加载过程才会得到加速</p></li><li><p>page-in linking：针对DATA端的符号，内核提前加载</p></li></ul><h3 id="pre-main-注意事项"><a href="#pre-main-注意事项" class="headerlink" title="pre-main 注意事项"></a>pre-main 注意事项</h3><ol><li>禁止做I/O和网络操作</li><li>任何超过毫秒级别的操作都不应该放到这</li></ol><h2 id="Xcode-14-新增链接相关命令行工具"><a href="#Xcode-14-新增链接相关命令行工具" class="headerlink" title="Xcode 14 新增链接相关命令行工具"></a>Xcode 14 新增链接相关命令行工具</h2><ul><li><p><code>dyld_usage</code>：获取dyld正在做什么，应用在macos-app或者iOS模拟器</p></li><li><p><code>dyld_info</code>：检查磁盘上和当前dyld缓存中的二进制文件</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文简述Xcode 14 的编译优化&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Xcode" scheme="https://www.arclin.cn/tags/Xcode/"/>
    
    <category term="feature" scheme="https://www.arclin.cn/tags/feature/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s new in Swift 5.7</title>
    <link href="https://www.arclin.cn/post/89a7f98f.html"/>
    <id>https://www.arclin.cn/post/89a7f98f.html</id>
    <published>2022-07-06T08:59:46.000Z</published>
    <updated>2022-07-12T16:51:57.240Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结自WWDC 2022 <a href="https://developer.apple.com/videos/play/wwdc2022/110354/">《What’s new in Swift》</a></p><span id="more"></span><h2 id="Optional-unwrapping"><a href="#Optional-unwrapping" class="headerlink" title="Optional unwrapping"></a>Optional unwrapping</h2><p>在对可选值进行解包的时候，可以用一种更简便的方式</p><p>Swift 5.5</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name : <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;Linda&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name <span class="operator">=</span> name &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(name)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 5.7</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(name)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Multi-statement-closure-type-inference"><a href="#Multi-statement-closure-type-inference" class="headerlink" title="Multi-statement closure type inference"></a>Multi-statement closure type inference</h2><p>当闭包表达式内有多行语句的时候，可以不用显式声明返回值类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scores <span class="operator">=</span> [<span class="number">100</span>,<span class="number">80</span>, <span class="number">85</span>]</span><br></pre></td></tr></table></figure><p>Swift 5.5 </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldResults <span class="operator">=</span> scores.map &#123; score -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">   <span class="keyword">if</span> score <span class="operator">&gt;</span> <span class="number">85</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="string">&quot;<span class="subst">\(score)</span>%: Pass&quot;</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="string">&quot;<span class="subst">\(score)</span>%: Fail&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 5.7</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> results <span class="operator">=</span> scores.map &#123; score <span class="keyword">in</span></span><br><span class="line">   <span class="keyword">if</span> score <span class="operator">&gt;=</span> <span class="number">85</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="string">&quot;<span class="subst">\(score)</span>%: Pass&quot;</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="string">&quot;<span class="subst">\(score)</span>%: Fail&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Regular-expressions"><a href="#Regular-expressions" class="headerlink" title="Regular expressions"></a>Regular expressions</h2><p>新增正则表达式工具 <code>Regex</code>，支持正则语法检查</p><p>举例：取出句子中的”at”的range</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message <span class="operator">=</span> <span class="string">&quot;the cat sat on the mat&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message.range(of:<span class="string">&quot;at&quot;</span>))</span><br></pre></td></tr></table></figure><p>Swift 5.7 使用字符串初始化Regex，若传入不符合语法规则的正则表达式，则会throw error</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> atSearch <span class="operator">=</span> <span class="keyword">try</span> <span class="type">Regex</span>(<span class="string">&quot;[a-z]at&quot;</span>)</span><br><span class="line">   <span class="built_in">print</span>(message.range(of:atSearch))</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Failed to create regex&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外可以使用<code>/ /</code>包裹正则表达式（字面量语法），当传入不符合语法规则的正则表达式的时候，编译器将会报错</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(message.ranges(of: <span class="operator">/</span>[a<span class="operator">-</span>z]at<span class="operator">/</span>))</span><br></pre></td></tr></table></figure><p>此外，Swift  5.7还新增了一种DSL的语法去做类似正则表达式的事情，如下:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> search <span class="operator">=</span> <span class="operator">/</span><span class="type">My</span> name <span class="keyword">is</span> (<span class="operator">.+?</span>) and <span class="type">I</span>&#x27;m (\d<span class="operator">+</span>) years old<span class="operator">./</span></span><br><span class="line"><span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;My name is Taylor and I&#x27;m 26 years old&quot;</span></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> search <span class="operator">=</span> <span class="type">Regex</span> &#123;</span><br><span class="line">   <span class="string">&quot;My name is&quot;</span></span><br><span class="line">   </span><br><span class="line">   <span class="type">Capture</span> &#123;</span><br><span class="line">      <span class="type">OneOrMore</span>(.word)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="string">&quot;and I&#x27;m&quot;</span></span><br><span class="line">   </span><br><span class="line">   <span class="type">Capture</span> &#123;</span><br><span class="line">      <span class="type">OneOrMore</span>(.digit)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="string">&quot; years old.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Protocol-and-generics"><a href="#Protocol-and-generics" class="headerlink" title="Protocol and generics"></a>Protocol and generics</h2><p>针对泛型协议，可以使用<code>any</code>和<code>some</code>关键字来简洁编码</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> size : <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">   <span class="keyword">var</span> name : <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 5.5 </p><p>这里传入的参数可以是任意遵循了<code>Pizza</code>的类或者结构体的实例</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receivePizza</span>(<span class="keyword">_</span> <span class="params">pizza</span>: <span class="type">Pizza</span>)</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Nice <span class="subst">\(pizza.name)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 5.7</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receivePizza</span>(<span class="keyword">_</span> <span class="params">pizza</span>: any <span class="type">Pizza</span>)</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Nice <span class="subst">\(pizza.name)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 5.5 </p><p>这里传入的参数可以是某一个遵循了<code>Pizza</code>的类或者结构体的任意实例，类型T需要确定</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receivePizza</span>&lt;<span class="type">T</span> : <span class="type">Pizza</span>&gt;(<span class="keyword">_</span> <span class="params">pizza</span>: <span class="type">Pizza</span>)</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Nice <span class="subst">\(pizza.name)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 5.7</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receivePizza</span>(<span class="keyword">_</span> <span class="params">pizza</span>: <span class="keyword">some</span> <span class="type">Pizza</span>)</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Nice <span class="subst">\(pizza.name)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Some-和-Any"><a href="#Some-和-Any" class="headerlink" title="Some 和 Any"></a>Some 和 Any</h3><p><code>some</code>和<code>any</code>其实是以前就有的关键字</p><p>some : 指定某种遵循了协议A的类型</p><p>any : 任意遵循了协议A的类型</p><p>举例：</p><p>下面代码会报错，提示Cat不能复制给animal，因为animal已经被指定为Dog类型了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal : <span class="keyword">some</span> <span class="type">Animal</span> <span class="operator">=</span> <span class="type">Dog</span>()</span><br><span class="line">animal <span class="operator">=</span> <span class="type">Cat</span>()</span><br></pre></td></tr></table></figure><p>下面代码不会报错，因为animal可以是任意遵循了Animal协议的类的实例</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal : any <span class="type">Animal</span> <span class="operator">=</span> <span class="type">Dog</span>()</span><br><span class="line">animal <span class="operator">=</span> <span class="type">Cat</span>()</span><br></pre></td></tr></table></figure><p>同理，会报错，因为some只能指定一种类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animals : [<span class="keyword">some</span> <span class="type">Animal</span>] <span class="operator">=</span> [<span class="type">Dog</span>(),<span class="type">Cat</span>()]</span><br></pre></td></tr></table></figure><p>不会报错，因为any能指定任意遵循了Animal协议的类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animals : [<span class="keyword">some</span> <span class="type">Animal</span>] <span class="operator">=</span> [<span class="type">Dog</span>(),<span class="type">Cat</span>()]</span><br></pre></td></tr></table></figure><p>那到底什么时候用<code>some</code>，什么时候用<code>any</code>呢？</p><p>答：当你在设计接口的时候就已经默认是某个类型的时候，就用<code>some</code>，当不符合上述要求的时候就用<code>any</code></p><h2 id="Swift-Package-Plugins"><a href="#Swift-Package-Plugins" class="headerlink" title="Swift Package Plugins"></a>Swift Package Plugins</h2><p>Swift新增的插件，就是可以用swift写脚本，然后可以在Xcode构建的时候运行。比如代码格式化，产出代码统计报告等</p><h2 id="Swift-Concurrency-Instrument"><a href="#Swift-Concurrency-Instrument" class="headerlink" title="Swift Concurrency Instrument"></a>Swift Concurrency Instrument</h2><p>在Instrument里面新增了针对<code>awiat</code>相关代码的性能检测</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文总结自WWDC 2022 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2022/110354/&quot;&gt;《What’s new in Swift》&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="Swift" scheme="https://www.arclin.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>汇编分析Swift inout关键字</title>
    <link href="https://www.arclin.cn/post/4e8bf338.html"/>
    <id>https://www.arclin.cn/post/4e8bf338.html</id>
    <published>2021-10-02T03:24:00.000Z</published>
    <updated>2022-07-12T16:51:57.245Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲述通过汇编分析展示Swift inout的实现原理</p><span id="more"></span><p>首先我们先了解几个汇编指令(AT&amp;T汇编：iOS模拟器汇编，ARM汇编：iOS真机汇编)</p><ul><li><p><code>movq %rax %rdx</code>：将<code>%rax</code>的值赋值给<code>%rdx</code></p></li><li><p><code>leaq -0x18（%rbp）,%rax</code>：将<code>%rbp-0x18</code>的地址值赋值给<code>rax</code></p></li><li><p><code>callq 0x100003f60</code>：调用地址值为<code>0x100003f60</code>的函数</p></li><li><p>寄存器的具体用途</p><ul><li>rax、rdx常作为函数返回值使用</li><li>rdi，rsi，rdx，rcx、r8、r9等寄存器常用于存放函数参数</li><li>rsp、rbp用于栈操作</li><li>rip作为指令指针</li></ul></li></ul><h2 id="函数中的inout"><a href="#函数中的inout" class="headerlink" title="函数中的inout"></a>函数中的inout</h2><p>首先我们看看普通的函数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span>(<span class="keyword">_</span> <span class="params">num</span> : <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(number)</span><br></pre></td></tr></table></figure><p>在函数调用那里打个断点，可以看到汇编指令是这样子的</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x100003f4e</span> &lt;+<span class="number">78</span>&gt;: movq   -<span class="number">0x30</span>(%rbp), %rdi</span><br><span class="line">-&gt;  <span class="number">0x100003f52</span> &lt;+<span class="number">82</span>&gt;: callq  <span class="number">0x100003f60</span>  ; TestSwift.test<span class="function"><span class="params">(Swift.Int)</span> -&gt;</span> () at main.swift:<span class="number">48</span></span><br></pre></td></tr></table></figure><p>分号后面是注释，用于帮助我们理解汇编指令。</p><p>这两行的含义是把寄存器<code>%rbp-0x30</code>地址上的值赋值给寄存器<code>%rdi</code>，将其作为参数然后调用函数地址为<code>0x100003f60</code>的函数。</p><p>所以很明显，这是一个<code>值传递</code>行为</p><p>然后我们再来看看使用inout的函数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span>(<span class="keyword">_</span> <span class="params">num</span> : <span class="keyword">inout</span> <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    num <span class="operator">=</span> <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="operator">&amp;</span>number)</span><br></pre></td></tr></table></figure><p>当然按照预期number的值会被改变成20，这里我们再次在函数调用那里打断点看看效果</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x100003f37</span> &lt;+<span class="number">55</span>&gt;: leaq   <span class="number">0x40da</span>(%rip), %rdi ; TestSwift.number : Swift.Int</span><br><span class="line">-&gt;  <span class="number">0x100003f3e</span> &lt;+<span class="number">62</span>&gt;: callq  <span class="number">0x100003f60</span> ; TestSwift.test(<span class="keyword">inout</span> Swift.Int) -&gt; () at main.swift:<span class="number">40</span></span><br></pre></td></tr></table></figure><p>从这里我们可以看出，系统通过<code>leaq</code>指令，将<code>%rip+0x40da</code>的地址，赋值给了寄存器<code>%rdi</code>，然后将其作为参数调用了地址值为<code>0x100003f60</code>的函数</p><p>所以很明显，这是一个<code>地址传递</code>行为</p><p>总结：在函数调用中，<code>inout</code>修饰的参数是通过地址传递实现修改值的</p><h2 id="属性使用inout"><a href="#属性使用inout" class="headerlink" title="属性使用inout"></a>属性使用inout</h2><p>针对存储属性和计算属性进行<code>inout</code>修饰传参，其实现原理会有所不同，我们看下面的一个例子</p><p>首先先写一个简单的Demo</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width : <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> side : <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;willSetSide&quot;</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;didSetSide&quot;</span>, oldValue, side)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> girth : <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            width <span class="operator">=</span> newValue <span class="operator">/</span> side</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> width <span class="operator">*</span> side</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;width=<span class="subst">\(width)</span>,side=<span class="subst">\(side)</span>,girth=<span class="subst">\(girth)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span>(<span class="keyword">_</span> <span class="params">num</span> : <span class="keyword">inout</span> <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    num <span class="operator">=</span> <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h3><p>先试试存储属性</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="operator">=</span> <span class="type">Shape</span>(width: <span class="number">10</span>, side: <span class="number">4</span>)</span><br><span class="line">test(<span class="operator">&amp;</span>s.width)</span><br><span class="line">s.show()</span><br></pre></td></tr></table></figure><p>结果输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>=<span class="number">20</span>,side=<span class="number">4</span>,girth=<span class="number">80</span></span><br></pre></td></tr></table></figure><p>显然跟我们预想的一样，我们通过<code>test</code>函数把<code>s.width</code>改成了20，然后这时候四边形的边长就变成了20，周长变成了80</p><p>那么这次是不是通过地址传递呢？</p><p>通过断点，我们可以看到如下结果</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x10000308b</span> &lt;+<span class="number">91</span>&gt;:  leaq   <span class="number">0x4fe6</span>(%rip), %rdi        ; TestSwift.s : TestSwift.Shape</span><br><span class="line"><span class="number">0x100003092</span> &lt;+<span class="number">98</span>&gt;:  callq  <span class="number">0x100003a60</span>               ; TestSwift.test(<span class="keyword">inout</span> Swift.Int) -&gt; () at main.swift:<span class="number">34</span></span><br></pre></td></tr></table></figure><p>这里很明显看到是把结构体<code>s</code>的地址值作为参数传进去了。之所以直接传结构体地址进去，是因为<code>width</code>是一个存储属性，属性存在在结构体的内存结构中，而且又是第一个属性，所以第一个属性的地址值就是结构体的地址值。假如不是第一个属性，那么就加上偏移值，把该属性的地址传进去。</p><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>接下来我们传一个计算属性进去试试看</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="operator">=</span> <span class="type">Shape</span>(width: <span class="number">10</span>, side: <span class="number">4</span>)</span><br><span class="line">test(<span class="operator">&amp;</span>s.girth)</span><br><span class="line">s.show()</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>=<span class="number">5</span>,side=<span class="number">4</span>,girth=<span class="number">20</span></span><br></pre></td></tr></table></figure><p>同样也是符合预期的。然后我们分析一下汇编实现</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 第<span class="number">1</span><span class="number">-2</span>步</span><br><span class="line"><span class="number">0x10000307b</span> &lt;+<span class="number">107</span>&gt;: callq  <span class="number">0x1000034d0</span>               <span class="comment">; TestSwift.Shape.girth.getter : Swift.Int at main.swift:24</span></span><br><span class="line"><span class="number">0x100003080</span> &lt;+<span class="number">112</span>&gt;: movq   <span class="variable">%rax</span><span class="punctuation">,</span> <span class="number">-0</span><span class="keyword">x</span><span class="number">28</span>(<span class="variable">%rbp</span>)</span><br><span class="line">    </span><br><span class="line">// 第<span class="number">3</span>步</span><br><span class="line"><span class="number">0x100003084</span> &lt;+<span class="number">116</span>&gt;: leaq   <span class="number">-0</span><span class="keyword">x</span><span class="number">28</span>(<span class="variable">%rbp</span>)<span class="punctuation">,</span> <span class="variable">%rdi</span></span><br><span class="line"><span class="number">0x100003088</span> &lt;+<span class="number">120</span>&gt;: callq  <span class="number">0x100003a60</span>               <span class="comment">; TestSwift.test(inout Swift.Int) -&gt; () at main.swift:34</span></span><br><span class="line">    </span><br><span class="line">// 第<span class="number">4</span>步    </span><br><span class="line"><span class="number">0x10000308d</span> &lt;+<span class="number">125</span>&gt;: movq   <span class="number">-0</span><span class="keyword">x</span><span class="number">28</span>(<span class="variable">%rbp</span>)<span class="punctuation">,</span> <span class="variable">%rdi</span></span><br><span class="line"><span class="number">0x100003091</span> &lt;+<span class="number">129</span>&gt;: leaq   <span class="number">0x4fe0</span>(<span class="variable">%rip</span>)<span class="punctuation">,</span> <span class="variable">%r13</span>        <span class="comment">; TestSwift.s : TestSwift.Shape</span></span><br><span class="line"><span class="number">0x100003098</span> &lt;+<span class="number">136</span>&gt;: callq  <span class="number">0x100003580</span>               <span class="comment">; TestSwift.Shape.girth.setter : Swift.Int at main.swift:21</span></span><br></pre></td></tr></table></figure><p>可以看到：</p><ol><li>首先系统调用了<code>getter</code>方法，拿到计算属性<code>girth</code>的值</li><li>然后通过<code>movq</code>指令把拿出来的值放在了地址<code>%rbp-0x28</code>（一个临时变量）中</li><li>接下来通过传递地址值的形式，把这个临时变量的地址传了进去，把他指向的值改成了20</li><li>然后改完之后拿出结果值调用计算属性<code>girth</code>的setter方法（<code>%rdi</code>是参数）</li><li>最终就实现了修改<code>width</code>属性的结果</li></ol><h3 id="带属性观察器的存储属性"><a href="#带属性观察器的存储属性" class="headerlink" title="带属性观察器的存储属性"></a>带属性观察器的存储属性</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="operator">=</span> <span class="type">Shape</span>(width: <span class="number">10</span>, side: <span class="number">4</span>)</span><br><span class="line">test(<span class="operator">&amp;</span>s.side)</span><br><span class="line">s.show()</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>=<span class="number">10</span>,side=<span class="number">20</span>,girth=<span class="number">200</span></span><br></pre></td></tr></table></figure><p>同样达到预期。然后我们分析一下汇编实现</p><p>为了方便理解，这里拆分为两个部分</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第1步</span></span><br><span class="line"><span class="number">0x10000306d</span> &lt;+<span class="number">93</span>&gt;:  movq   <span class="number">0x500c</span>(%rip), %rax        ; TestSwift.s : TestSwift.Shape + <span class="number">8</span></span><br><span class="line"><span class="number">0x100003074</span> &lt;+<span class="number">100</span>&gt;: movq   %rax, <span class="number">-0x28</span>(%rbp)</span><br><span class="line"><span class="comment">// 第2步</span></span><br><span class="line"><span class="number">0x100003078</span> &lt;+<span class="number">104</span>&gt;: leaq   <span class="number">-0x28</span>(%rbp), %rdi</span><br><span class="line"><span class="number">0x10000307c</span> &lt;+<span class="number">108</span>&gt;: callq  <span class="number">0x100003a60</span>               ; TestSwift.test(<span class="keyword">inout</span> Swift.Int) -&gt; () at main.swift:<span class="number">34</span></span><br><span class="line">...（省略一些setter方法的参数处理）</span><br><span class="line"><span class="comment">// 第3步</span></span><br><span class="line"><span class="number">0x10000308c</span> &lt;+<span class="number">124</span>&gt;: callq  <span class="number">0x100003180</span>               ; TestSwift.Shape.side.setter : Swift.Int at main.swift:<span class="number">12</span></span><br></pre></td></tr></table></figure><ol><li>首先，取出结构体地址值+8的地址值（也就是side属性的地址值），赋值给临时变量地址<code>%rbp-0x28</code></li><li>取出临时变量的地址值作为函数参数，调用<code>test</code>函数，所以<code>inout</code>本质依旧是<code>地址传递</code></li><li>进入属性的<code>setter</code>方法</li></ol><p>然后我们<code>step into</code>看看<code>setter</code>的主要实现</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/// 第<span class="number">1</span>步</span><br><span class="line"><span class="number">0x1000031be</span> &lt;+<span class="number">62</span>&gt;: callq  <span class="number">0x1000031f0</span>               <span class="comment">; TestSwift.Shape.side.willset : Swift.Int at main.swift:13</span></span><br><span class="line"><span class="number">0x1000031c3</span> &lt;+<span class="number">67</span>&gt;: movq   <span class="number">-0</span><span class="keyword">x</span><span class="number">30</span>(<span class="variable">%rbp</span>)<span class="punctuation">,</span> <span class="variable">%rax</span></span><br><span class="line"><span class="number">0x1000031c7</span> &lt;+<span class="number">71</span>&gt;: movq   <span class="number">-0</span><span class="keyword">x</span><span class="number">28</span>(<span class="variable">%rbp</span>)<span class="punctuation">,</span> <span class="variable">%rcx</span></span><br><span class="line">/// 第<span class="number">2</span>步</span><br><span class="line"><span class="number">0x1000031cb</span> &lt;+<span class="number">75</span>&gt;: movq   <span class="variable">%rcx</span><span class="punctuation">,</span> <span class="number">0x8</span>(<span class="variable">%rax</span>)</span><br><span class="line">/// 第<span class="number">3</span>步</span><br><span class="line"><span class="number">0x1000031cf</span> &lt;+<span class="number">79</span>&gt;: movq   <span class="number">-0</span><span class="keyword">x</span><span class="number">38</span>(<span class="variable">%rbp</span>)<span class="punctuation">,</span> <span class="variable">%rdi</span></span><br><span class="line"><span class="number">0x1000031d3</span> &lt;+<span class="number">83</span>&gt;: movq   <span class="variable">%rax</span><span class="punctuation">,</span> <span class="variable">%r13</span></span><br><span class="line"><span class="number">0x1000031d6</span> &lt;+<span class="number">86</span>&gt;: callq  <span class="number">0x100003370</span>               <span class="comment">; TestSwift.Shape.side.didset : Swift.Int at main.swift:16</span></span><br></pre></td></tr></table></figure><ol><li>触发了属性观察器的<code>willset</code>方法</li><li>给真正的<code>side</code>的地址指向的值改为20</li><li>触发了属性观察器的<code>didset</code>方法</li></ol><p>所以跟计算属性类似，也是先拿一个临时变量中转调用了<code>test</code>方法，等到触发了属性观察器，在两个方法之间才真正拿到中转的临时变量再进行赋值操作</p><h2 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h2><ul><li>可变参数不能标记为<code>inout</code></li><li><code>inout</code>参数不能有默认值</li><li><code>inout</code>参数只能传入可以被多次赋值的（var变量，可变数组的元素等）</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要讲述通过汇编分析展示Swift inout的实现原理&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Swift" scheme="https://www.arclin.cn/tags/Swift/"/>
    
    <category term="汇编" scheme="https://www.arclin.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>函数式Swift --- 透镜</title>
    <link href="https://www.arclin.cn/post/c5814bfc.html"/>
    <id>https://www.arclin.cn/post/c5814bfc.html</id>
    <published>2021-09-25T15:29:00.000Z</published>
    <updated>2022-07-12T16:51:57.244Z</updated>
    
    <content type="html"><![CDATA[<p>Swift是实现函数式思想的一门好语言，这里简要讲述一下函数式中透镜的Swift实现</p><span id="more"></span><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>首先我们先创建一个结构体</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x : <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">let</span> y : <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">2</span>)</span><br><span class="line">point.x <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>一般情况下这时候会报错<code>Cannot assign to property: &#39;x&#39; is a &#39;let&#39; constant</code>，因为<code>x</code>是一个常量，所以无法修改</p><p>那么有时候我们如果需要改变一个不可变的属性的值，那么一般我们会选择再创建一个对象去覆盖</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x : <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">let</span> y : <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> tempPoint <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">2</span>, y: point.y)</span><br><span class="line">point <span class="operator">=</span> tempPoint</span><br></pre></td></tr></table></figure><p>但是这样子做未免显得有点麻烦，假如你觉得这样子还能接受，那么我再举个例子</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x : <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">let</span> y : <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start : <span class="type">Point</span></span><br><span class="line">    <span class="keyword">let</span> end : <span class="type">Point</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> line : <span class="type">Line</span> <span class="comment">// 通过线段我们可以计算出正方形的边长</span></span><br><span class="line">    <span class="keyword">let</span> origin : <span class="type">Point</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> start <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> end <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">10</span>, y: <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> line <span class="operator">=</span> <span class="type">Line</span>(start: start, end: end)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> origin <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">5</span>, y: <span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> square <span class="operator">=</span> <span class="type">Square</span>(line: line, origin: origin)</span><br><span class="line"></span><br><span class="line">square.line.start.x <span class="operator">=</span> <span class="number">20</span> <span class="comment">// Error : Cannot assign to property: &#x27;x&#x27; is a &#x27;let&#x27; constant</span></span><br></pre></td></tr></table></figure><p>假如这时候我们希望把<code>square.line.start.x</code>设置为20，那么按照常规的写法就显得很麻烦了，更何况实际开发中可能还存在着更深的嵌套</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>我们可以使用函数式的方案去解决上面的问题，首先我们先把问题简化，先考虑如何把<code>Point</code>的<code>x</code>属性优雅地去进行更改</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>首先我们定义一个函数签名，取名为<code>Lens</code>(透镜)</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt; <span class="operator">=</span> (<span class="keyword">@escaping</span> (<span class="type">Subpart</span>) -&gt; <span class="type">Subpart</span>) -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span></span><br></pre></td></tr></table></figure><p>其中<code>Subpart</code>表示要修改的属性的值，<code>Whole</code>表示被修改的这个对象</p><p>整个定义的含义是</p><ol><li>传入闭包表达式，这个闭包表达式会带入参数，参数值为被修改的属性的当前值，比如<code>x</code>的当前值1，然后闭包表达式修改这个值之后再次返回出去。</li><li>返回一个对象的闭包，这个闭包会带入参数，参数值为当前被修改的对象，闭包表达式返回一个新的对象，比如<code>Point</code></li></ol><p>为了方便构建一个透镜，我们再添加一个方法用于初始化一个透镜</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;(<span class="params">view</span>: <span class="keyword">@escaping</span> (<span class="type">Whole</span>) -&gt; <span class="type">Subpart</span>, <span class="params">set</span>: <span class="keyword">@escaping</span> (<span class="type">Subpart</span>,<span class="type">Whole</span>) -&gt; <span class="type">Whole</span>)</span> -&gt; <span class="type">Lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/// 缩减写法</span></span><br><span class="line">    <span class="keyword">return</span> &#123; mapper <span class="keyword">in</span> &#123; <span class="keyword">set</span>(mapper(view(<span class="variable">$0</span>)), <span class="variable">$0</span>) &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法传入两个参数</p><ol><li>闭包表达式<code>view</code>表示传入一个对象，返回这个对象要被修改的那个属性当前值，比如我们上面提到的<code>x</code>，相当于一个<code>get</code>操作</li><li>闭包表达式<code>set</code>表示传入要被修改属性的新值和要被修改的对象，然后返回包含新值的属性的新对象，相当于一个<code>set</code>操作</li></ol><p>最后把闭包表达式返回出去就是我们所要的透镜，也可以理解为一个修改器。这个修改器内定好了哪个属性要被修改成哪个值，然后这个修改器最后返回一个闭包表达式，传入一个旧对象，返回一个带有新值的新对象</p><p>如果觉得上面的缩减写法有点晦涩，那我们展开来描述</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123; mapper <span class="keyword">in</span> <span class="comment">// mapper是用于修改属性值的一个闭包表达式</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> subpart <span class="operator">=</span> view(<span class="variable">$0</span>) <span class="comment">// 拿到某个属性当前的值</span></span><br><span class="line">        <span class="keyword">let</span> newSubpart <span class="operator">=</span> mapper(subpart) <span class="comment">// 处理成新值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">set</span>(newSubpart, <span class="variable">$0</span>) <span class="comment">// 返回一个新对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>接下来我们就可以用上面定义好的方法来构件我们的<code>x</code>属性透镜和<code>y</code>属性透镜</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> xL : <span class="type">Lens</span>&lt;<span class="type">CGFloat</span>,<span class="type">Point</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.x &#125;,</span><br><span class="line">        set: &#123; <span class="type">Point</span>(x: <span class="variable">$0</span>, y: <span class="variable">$1</span>.y) &#125;</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> yL : <span class="type">Lens</span>&lt;<span class="type">CGFloat</span>,<span class="type">Point</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.y &#125;,<span class="comment">// 即将要被修改的值是y</span></span><br><span class="line">        set: &#123; <span class="type">Point</span>(x: <span class="variable">$1</span>.x, y: <span class="variable">$0</span>) &#125; <span class="comment">// 新值为$0，旧值</span></span><br><span class="line">x依旧还是从原来对象里面取    </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个能把x改成10的透镜</span></span><br><span class="line"><span class="keyword">let</span> xLens <span class="operator">=</span> <span class="type">Point</span>.xL &#123; <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">10</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point1 <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> point2 <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">2</span>, y: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">point1 <span class="operator">=</span> xLens(point1)</span><br><span class="line">point2 <span class="operator">=</span> xLens(point2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(point1) <span class="comment">// Point(x: 10.0, y: 1.0)</span></span><br><span class="line"><span class="built_in">print</span>(point2) <span class="comment">// Point(x: 10.0, y: 2.0)</span></span><br></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>但是这样子的使用方法还是不够方便，所以我们定义多两个方法封装一下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">over</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;(<span class="params">mapper</span>: <span class="keyword">@escaping</span> (<span class="type">Subpart</span>) -&gt; <span class="type">Subpart</span>, <span class="params">lens</span>: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;)</span> -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lens(mapper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;(<span class="params">value</span>: <span class="type">Subpart</span>,<span class="params">lens</span>: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;)</span> -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> over( mapper: &#123; <span class="keyword">_</span> <span class="keyword">in</span> value &#125;, lens: lens)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>over</code>方法传入一个闭包表达式和一个透镜，闭包表达式参数是用来修改属性值，跟透镜结合使用，返回新对象</p><p><code>set</code>方法传入一个新值和一个透镜，新值是用于构建修改属性的闭包，跟传入的透镜结合，调用<code>over</code>方法</p><p>有了这两个方法，我们就可以把之前的写法进行修改</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xLens <span class="operator">=</span> <span class="keyword">set</span>(value: <span class="number">10</span>, lens: <span class="type">Point</span>.xL) <span class="comment">// 等价于下面的写法</span></span><br><span class="line"><span class="comment">// let xLens = Point.xL &#123; _ in 10 &#125; </span></span><br></pre></td></tr></table></figure><p>这么一看貌似只是简单地把闭包表达式变成了函数调用，也就是花括号变成了括号而已</p><p>但实际上变成了函数调用的方式之后我们就可以做更多的事情了</p><p>比如说：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">%~</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> .<span class="title">~</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">%~</span> &lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;(<span class="params">lhs</span>: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;, <span class="params">rhs</span>: <span class="keyword">@escaping</span> (<span class="type">Subpart</span>) -&gt; <span class="type">Subpart</span>)</span> -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> over(mapper: rhs, lens: lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> </span><span class="operator">.~</span> <span class="operator">&lt;</span><span class="type">Subpart</span>, <span class="type">Whole</span><span class="operator">&gt;</span>(lhs: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;, rhs: <span class="type">Subpart</span>) -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">set</span>(value: rhs, lens: lhs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们的调用方式就变成了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xLens <span class="operator">=</span> <span class="type">Point</span>.xL <span class="operator">.~</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>还不够，再加一个定义，我们把对象的修改方式给改了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precedencegroup</span> <span class="title">LensPrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">higherThan</span> : <span class="type">AdditionPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> .<span class="title">~</span> : <span class="type">LensPrecedence</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">%~</span> : <span class="type">LensPrecedence</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">|&gt;</span> : <span class="type">AdditionPrecedence</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">%~</span> &lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;(<span class="params">lhs</span>: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;, <span class="params">rhs</span>: <span class="keyword">@escaping</span> (<span class="type">Subpart</span>) -&gt; <span class="type">Subpart</span>)</span> -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> over(mapper: rhs, lens: lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> </span><span class="operator">.~</span> <span class="operator">&lt;</span><span class="type">Subpart</span>, <span class="type">Whole</span><span class="operator">&gt;</span>(lhs: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;, rhs: <span class="type">Subpart</span>) -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">set</span>(value: rhs, lens: lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">|&gt;</span> &lt;<span class="type">A</span>, <span class="type">B</span>&gt; (<span class="params">lhs</span>: <span class="type">A</span>, <span class="params">rhs</span>: (<span class="type">A</span>) -&gt; <span class="type">B</span>)</span> -&gt; <span class="type">B</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs(lhs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子当我们想要修改一个点的x值和y值的时候，就可以这么写了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">point <span class="operator">=</span> point</span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Point</span>.xL <span class="operator">.~</span> <span class="number">10</span></span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Point</span>.yL <span class="operator">.~</span> <span class="number">20</span></span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Point</span>.xL <span class="operator">%~</span> &#123; <span class="variable">$0</span> <span class="operator">-</span> <span class="number">5</span> &#125;</span><br></pre></td></tr></table></figure><p>看起来就简洁许多</p><h3 id="复杂的情况"><a href="#复杂的情况" class="headerlink" title="复杂的情况"></a>复杂的情况</h3><p>那么刚才我们提及的复杂的情况，除了点之外，还出现了线和面，那应该怎么做呢</p><p>同理可得，我们给线和面也添加透镜</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> startL : <span class="type">Lens</span>&lt;<span class="type">Point</span>,<span class="type">Line</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.start &#125;,</span><br><span class="line">        set: &#123; <span class="type">Line</span>(start: <span class="variable">$0</span>, end: <span class="variable">$1</span>.end ) &#125;</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> endL : <span class="type">Lens</span>&lt;<span class="type">Point</span>,<span class="type">Line</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.end &#125;,</span><br><span class="line">        set: &#123; <span class="type">Line</span>(start: <span class="variable">$1</span>.start, end: <span class="variable">$0</span>) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> lineL : <span class="type">Lens</span>&lt;<span class="type">Line</span>,<span class="type">Square</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.line &#125;,</span><br><span class="line">        set: &#123; <span class="type">Square</span>(line: <span class="variable">$0</span>, origin: <span class="variable">$1</span>.origin) &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> originL : <span class="type">Lens</span>&lt;<span class="type">Point</span>,<span class="type">Square</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.origin &#125;,</span><br><span class="line">        set: &#123; <span class="type">Square</span>(line: <span class="variable">$1</span>.line, origin: <span class="variable">$0</span>) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增一个运算符<code>&lt;&lt;&lt;</code>表示左结合，把右参数（闭包表达式）作为左参数（闭包表达式）的参数，并修改一下运算符之间的优先级</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precedencegroup</span> <span class="title">CombinePrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span> : <span class="keyword">left</span></span><br><span class="line">    <span class="keyword">higherThan</span> : <span class="type">LensPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">precedencegroup</span> <span class="title">LensPrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span>: <span class="keyword">right</span></span><br><span class="line">    <span class="keyword">higherThan</span> : <span class="type">AdditionPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">&lt;&lt;&lt;</span> : <span class="type">CombinePrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">&lt;&lt;&lt;</span> &lt;<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>&gt; (<span class="params">lhs</span>: <span class="keyword">@escaping</span> (<span class="type">B</span>) -&gt; <span class="type">C</span>, <span class="params">rhs</span>: <span class="keyword">@escaping</span> (<span class="type">A</span>) -&gt; <span class="type">B</span>)</span> -&gt; (<span class="type">A</span>) -&gt; <span class="type">C</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; lhs(rhs(<span class="variable">$0</span>)) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用方式如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 线段的起始点设置为20，原点的y值设置为30</span></span><br><span class="line">square <span class="operator">=</span> square</span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Square</span>.lineL <span class="operator">&lt;&lt;&lt;</span> <span class="type">Line</span>.startL <span class="operator">&lt;&lt;&lt;</span> <span class="type">Point</span>.xL <span class="operator">.~</span> <span class="number">20</span></span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Square</span>.originL <span class="operator">&lt;&lt;&lt;</span> <span class="type">Point</span>.yL <span class="operator">.~</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p>看起来也是十分简洁</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>仅供参考</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x : <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">let</span> y : <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start : <span class="type">Point</span></span><br><span class="line">    <span class="keyword">let</span> end : <span class="type">Point</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> line : <span class="type">Line</span></span><br><span class="line">    <span class="keyword">let</span> origin : <span class="type">Point</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt; <span class="operator">=</span> (<span class="keyword">@escaping</span> (<span class="type">Subpart</span>) -&gt; <span class="type">Subpart</span>) -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;(<span class="params">view</span>: <span class="keyword">@escaping</span> (<span class="type">Whole</span>) -&gt; <span class="type">Subpart</span>, <span class="params">set</span>: <span class="keyword">@escaping</span> (<span class="type">Subpart</span>,<span class="type">Whole</span>) -&gt; <span class="type">Whole</span>)</span> -&gt; <span class="type">Lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt; &#123;</span><br><span class="line"><span class="comment">//    return &#123; mapper in</span></span><br><span class="line"><span class="comment">//        return &#123;</span></span><br><span class="line"><span class="comment">//            let subpart = view($0)</span></span><br><span class="line"><span class="comment">//            let newSubpart = mapper(subpart)</span></span><br><span class="line"><span class="comment">//            return set(newSubpart, $0)</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">/// 可以缩减为这种写法</span></span><br><span class="line">    <span class="keyword">return</span> &#123; mapper <span class="keyword">in</span> &#123; <span class="keyword">set</span>(mapper(view(<span class="variable">$0</span>)), <span class="variable">$0</span>) &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">over</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;(<span class="params">mapper</span>: <span class="keyword">@escaping</span> (<span class="type">Subpart</span>) -&gt; <span class="type">Subpart</span>, <span class="params">lens</span>: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;)</span> -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lens(mapper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;(<span class="params">value</span>: <span class="type">Subpart</span>,<span class="params">lens</span>: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;)</span> -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> over( mapper: &#123; <span class="keyword">_</span> <span class="keyword">in</span> value &#125;, lens: lens)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">precedencegroup</span> <span class="title">CombinePrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span> : <span class="keyword">left</span></span><br><span class="line">    <span class="keyword">higherThan</span> : <span class="type">LensPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">precedencegroup</span> <span class="title">LensPrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span>: <span class="keyword">right</span></span><br><span class="line">    <span class="keyword">higherThan</span> : <span class="type">AdditionPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">%~</span>  : <span class="type">LensPrecedence</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> .<span class="title">~</span>  : <span class="type">LensPrecedence</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">|&gt;</span>  : <span class="type">AdditionPrecedence</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">&lt;&lt;&lt;</span> : <span class="type">CombinePrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">%~</span> &lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;(<span class="params">lhs</span>: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;, <span class="params">rhs</span>: <span class="keyword">@escaping</span> (<span class="type">Subpart</span>) -&gt; <span class="type">Subpart</span>)</span> -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> over(mapper: rhs, lens: lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> </span><span class="operator">.~</span> <span class="operator">&lt;</span><span class="type">Subpart</span>, <span class="type">Whole</span><span class="operator">&gt;</span>(lhs: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;, rhs: <span class="type">Subpart</span>) -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">set</span>(value: rhs, lens: lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">|&gt;</span> &lt;<span class="type">A</span>, <span class="type">B</span>&gt; (<span class="params">lhs</span>: <span class="type">A</span>, <span class="params">rhs</span>: (<span class="type">A</span>) -&gt; <span class="type">B</span>)</span> -&gt; <span class="type">B</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs(lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">&lt;&lt;&lt;</span> &lt;<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>&gt; (<span class="params">lhs</span>: <span class="keyword">@escaping</span> (<span class="type">B</span>) -&gt; <span class="type">C</span>, <span class="params">rhs</span>: <span class="keyword">@escaping</span> (<span class="type">A</span>) -&gt; <span class="type">B</span>)</span> -&gt; (<span class="type">A</span>) -&gt; <span class="type">C</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; lhs(rhs(<span class="variable">$0</span>)) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> xL : <span class="type">Lens</span>&lt;<span class="type">CGFloat</span>,<span class="type">Point</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.x &#125;,</span><br><span class="line">        set: &#123; <span class="type">Point</span>(x: <span class="variable">$0</span>, y: <span class="variable">$1</span>.y) &#125;</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> yL : <span class="type">Lens</span>&lt;<span class="type">CGFloat</span>,<span class="type">Point</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.y &#125;,</span><br><span class="line">        set: &#123; <span class="type">Point</span>(x: <span class="variable">$1</span>.x, y: <span class="variable">$0</span>) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> startL : <span class="type">Lens</span>&lt;<span class="type">Point</span>,<span class="type">Line</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.start &#125;,</span><br><span class="line">        set: &#123; <span class="type">Line</span>(start: <span class="variable">$0</span>, end: <span class="variable">$1</span>.end ) &#125;</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> endL : <span class="type">Lens</span>&lt;<span class="type">Point</span>,<span class="type">Line</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.end &#125;,</span><br><span class="line">        set: &#123; <span class="type">Line</span>(start: <span class="variable">$1</span>.start, end: <span class="variable">$0</span>) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> lineL : <span class="type">Lens</span>&lt;<span class="type">Line</span>,<span class="type">Square</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.line &#125;,</span><br><span class="line">        set: &#123; <span class="type">Square</span>(line: <span class="variable">$0</span>, origin: <span class="variable">$1</span>.origin) &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> originL : <span class="type">Lens</span>&lt;<span class="type">Point</span>,<span class="type">Square</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.origin &#125;,</span><br><span class="line">        set: &#123; <span class="type">Square</span>(line: <span class="variable">$1</span>.line, origin: <span class="variable">$0</span>) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//let xLens = Point.xL &#123; _ in 10 &#125;</span></span><br><span class="line"><span class="comment">//let xLens = set(value: 10, lens: Point.xL)</span></span><br><span class="line"><span class="comment">//let xLens = Point.xL .~ 10</span></span><br><span class="line"><span class="keyword">var</span> point1 <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">point1 <span class="operator">=</span> point1</span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Point</span>.xL <span class="operator">.~</span> <span class="number">10</span></span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Point</span>.yL <span class="operator">.~</span> <span class="number">20</span></span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Point</span>.xL <span class="operator">%~</span> &#123; <span class="variable">$0</span> <span class="operator">-</span> <span class="number">5</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> origin <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">5</span>, y: <span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> line <span class="operator">=</span> <span class="type">Line</span>(start: origin, end: point1)</span><br><span class="line"><span class="keyword">var</span> square <span class="operator">=</span> <span class="type">Square</span>(line: line, origin: origin)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改前<span class="subst">\(square)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 线段的起始点设置为20，原点的y值设置为30</span></span><br><span class="line">square <span class="operator">=</span> square</span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Square</span>.lineL <span class="operator">&lt;&lt;&lt;</span> <span class="type">Line</span>.startL <span class="operator">&lt;&lt;&lt;</span> <span class="type">Point</span>.xL <span class="operator">.~</span> <span class="number">20</span></span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Square</span>.originL <span class="operator">&lt;&lt;&lt;</span> <span class="type">Point</span>.yL <span class="operator">.~</span> <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改后<span class="subst">\(square)</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>在这种思想的基础上，我们就可以使用keyPath特性来对我们的编码进行一些改进</p><p>首先我们对keyPath进行拓展，也就是<code>\.xxx</code>这种写法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WritableKeyPath</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> toLens : <span class="type">Lens</span>&lt;<span class="type">Value</span>,<span class="type">Root</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> lens(view: &#123; <span class="variable">$0</span>[keyPath : <span class="keyword">self</span>] &#125;, set: &#123;</span><br><span class="line">            <span class="keyword">var</span> copy <span class="operator">=</span> <span class="variable">$1</span></span><br><span class="line">            copy[keyPath: <span class="keyword">self</span>] <span class="operator">=</span> <span class="variable">$0</span></span><br><span class="line">            <span class="keyword">return</span> copy</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改一下我们先前定义的两个运算符的实现，设置左值为keyPath的键，右值为新值或者生成新值的闭包表达式</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">%~</span> : <span class="type">LensPrecedence</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> .<span class="title">~</span> : <span class="type">LensPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">%~</span> &lt;<span class="type">Value</span>, <span class="type">Root</span>&gt;(<span class="params">lhs</span>: <span class="type">WritableKeyPath</span>&lt;<span class="type">Root</span>, <span class="type">Value</span>&gt;, <span class="params">rhs</span>: <span class="keyword">@escaping</span> (<span class="type">Value</span>) -&gt; <span class="type">Value</span>)</span> -&gt; (<span class="type">Root</span>) -&gt; <span class="type">Root</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> over(mapper: rhs, lens: lhs.toLens)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> </span><span class="operator">.~</span> <span class="operator">&lt;</span><span class="type">Value</span>, <span class="type">Root</span><span class="operator">&gt;</span>(lhs: <span class="type">WritableKeyPath</span>&lt;<span class="type">Root</span>, <span class="type">Value</span>&gt;, rhs: <span class="type">Value</span>) -&gt; (<span class="type">Root</span>) -&gt; <span class="type">Root</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">set</span>(value: rhs, lens: lhs.toLens)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> formatter <span class="operator">=</span> <span class="type">DateFormatter</span>()</span><br><span class="line">    <span class="operator">|&gt;</span> \.dateFormat <span class="operator">.~</span> <span class="string">&quot;yyyy-MM-dd&quot;</span></span><br><span class="line">    <span class="operator">|&gt;</span> \.timeZone <span class="operator">.~</span> <span class="type">TimeZone</span>(secondsFromGMT: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date <span class="operator">=</span> formatter.date(from: <span class="string">&quot;2020-01-01&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(date)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>()</span><br><span class="line">    <span class="operator">|&gt;</span> \.backgroundColor <span class="operator">.~</span> <span class="type">UIColor</span>.white</span><br><span class="line">    <span class="operator">|&gt;</span> \.alpha <span class="operator">%~</span> &#123; <span class="variable">$0</span> <span class="operator">-</span> <span class="number">0.1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(view)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Swift是实现函数式思想的一门好语言，这里简要讲述一下函数式中透镜的Swift实现&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="Swift" scheme="https://www.arclin.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LLVM</title>
    <link href="https://www.arclin.cn/post/6d8a8bc2.html"/>
    <id>https://www.arclin.cn/post/6d8a8bc2.html</id>
    <published>2021-09-12T03:11:00.000Z</published>
    <updated>2022-07-12T16:51:57.237Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述LLVM的概念与Clang插件开发</p><span id="more"></span><h2 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h2><ul><li>官网：<a href="https://llvm.org/">https://llvm.org</a></li><li>LLVM项目是模块化、可重用的<code>编译器</code>以及<code>工具链</code>技术的集合</li><li>”LLVM“这个名称不是缩写，是项目全称</li></ul><h2 id="传统的编译器架构"><a href="#传统的编译器架构" class="headerlink" title="传统的编译器架构"></a>传统的编译器架构</h2><p><img src="https://z3.ax1x.com/2021/09/12/4ppCOx.png" alt="4ppCOx.png"></p><ul><li>Frontend：前端<ul><li>词法分析、语法分析、语义分析、生成中间代码</li></ul></li><li>Optimizer：优化器<ul><li>中间代码优化</li></ul></li><li>Backend：后端<ul><li>生成机器码</li></ul></li></ul><h2 id="LLVM架构"><a href="#LLVM架构" class="headerlink" title="LLVM架构"></a>LLVM架构</h2><p><img src="https://z3.ax1x.com/2021/09/12/4pEhkt.png" alt="4pEhkt.png"></p><ul><li>不同的前端后端使用统一的中间代码<code>LLVM Intermediate Representation(LLVM IR)</code></li><li>如果需要支持一种新的编程语言，那么只需要实现一个新的前端</li><li>如果需要支持一种新的硬件设备，那么只需要实现一个新的后端</li><li>优化阶段是一个通用的阶段，他针对的是统一的<code>LLVM IR</code>，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做需修改</li><li>相比之下，GCC的前端和后端没分得太开，前端后端耦合在了一起。所以GCC为了支持一门新的语言，或者为了支持一个新的目标平台，就变得相当困难</li><li>LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构（GCC家族，Java,.Net,Python,Ruby,Scheme,Haskell,D等）</li></ul><h3 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a>Clang</h3><ul><li><p>Clang是LLVM的一个子项目</p></li><li><p>基于LLVM架构的C/C++/Objective-C编译器前端</p></li><li><p>官网：<a href="http://clang.llvm.org/">http://clang.llvm.org/</a></p></li><li><p>相比于GCC，Clang具有如下优点</p><ul><li>编译速度快：在某些平台上，Clang的编译速度显著地快过GCC(Debug模式下编译OC速度比GCC快3倍)</li><li>占用内存小：Clang生成的AST所占用的内存是GCC的五分之一左右</li><li>模块化设计：Clang采用基于库的模块化设计，易于IDE集成及其他用途的重用</li><li>诊断信息可读性强：在编译过程中，Clang创建并保留了大量详细的元数据（metadata），有利于调试和错误报告</li><li>设计清晰简单，容易理解，易于扩展增强 </li></ul></li></ul><h3 id="Clang与LLVM"><a href="#Clang与LLVM" class="headerlink" title="Clang与LLVM"></a>Clang与LLVM</h3><p> <img src="https://i.loli.net/2021/09/12/P7Z2sTB6ifOt4XM.png" alt="WX20210912-142017.png"></p><p> <img src="https://i.loli.net/2021/09/12/EZ9hnywmdQAX3LK.png" alt="WX20210912-142026.png"></p><p> IR：中间代码</p><h2 id="OC源文件的编译过程"><a href="#OC源文件的编译过程" class="headerlink" title="OC源文件的编译过程"></a>OC源文件的编译过程</h2><ul><li>命令行查看编译的过程：<code>$ clang -ccc-print-phases main.m</code></li></ul> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arclin<span class="keyword">@ArcdeMacBook-Pro</span> TestObjC % clang -ccc-print-phases main.m </span><br><span class="line">               +- <span class="number">0</span>: input, <span class="string">&quot;main.m&quot;</span>, objective-c</span><br><span class="line">            +- <span class="number">1</span>: preprocessor, &#123;<span class="number">0</span>&#125;, objective-c-cpp-output</span><br><span class="line">         +- <span class="number">2</span>: compiler, &#123;<span class="number">1</span>&#125;, ir</span><br><span class="line">      +- <span class="number">3</span>: backend, &#123;<span class="number">2</span>&#125;, assembler</span><br><span class="line">   +- <span class="number">4</span>: assembler, &#123;<span class="number">3</span>&#125;, <span class="selector-tag">object</span></span><br><span class="line">+- <span class="number">5</span>: linker, &#123;<span class="number">4</span>&#125;, image</span><br><span class="line"><span class="number">6</span>: bind-arch, <span class="string">&quot;x86_64&quot;</span>, &#123;<span class="number">5</span>&#125;, image</span><br></pre></td></tr></table></figure><p>  preprocessor: 预处理器，处理宏定义，展开引入的头文件内容等</p><p>  complier: 编译，编译成ir中间代码</p><p>  backend: 后端，转成汇编代码</p><p>  assemler: 汇编，转成目标代码</p><p>  linker: 链接，链接动态库、静态库等</p><p>  bind-arch: 绑定当前处理器架构</p><ul><li><p>查看preprocesser(预处理)的结果：<code>$ clang -E main.m</code></p></li><li><p>词法分析，生成Token：<code>$ clang -fmodules -E -Xlang -dump-tokens main.m</code></p></li><li><p>语法分析，生成语法树（AST，Abstract Syntax Tree）：<code>$ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</code></p></li></ul><h2 id="词法分析、语法树"><a href="#词法分析、语法树" class="headerlink" title="词法分析、语法树"></a>词法分析、语法树</h2><p>词法分析，生成Token： <code>$ clang -fmodules -E -Xclang -dump-tokens main.m</code></p><p><a href="https://imgtu.com/i/483bNR"><img src="https://z3.ax1x.com/2021/09/19/483bNR.png" alt="483bNR.png"></a></p><p>语法分析，生成语法树（AST，Abstract Syntax Tree）： <code>$ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</code></p><p><a href="https://imgtu.com/i/483d9P"><img src="https://z3.ax1x.com/2021/09/19/483d9P.png" alt="483d9P.png"></a></p><h2 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h2><p>LLVM IR 有三种表现形式</p><ul><li><p>text：便于阅读的文本格式，类似于汇编语言，拓展名<code>.ll</code>，<code>$ clang -S -emit-llvm main.m</code></p></li><li><p>memory：内存格式</p></li><li><p>bitcode：二进制格式，拓展名<code>.bc</code>，<code>$ clang -c -emit-llvm main.m</code></p></li></ul><p>IR基本语法</p><ul><li>注释以分号开头</li><li>全局标识以@开头，局部标识符以%开头</li><li>alloca, 在当前函数栈帧中分配内存</li><li>i32，32bit，4个字节的意思</li><li>align，内存对齐</li><li>store，写入数据</li><li>load，读取数据</li></ul><p>官方语法参考</p><p><a href="https://llvm.org/docs/LangRef.html">https://llvm.org/docs/LangRef.html</a></p><h2 id="Clang插件开发"><a href="#Clang插件开发" class="headerlink" title="Clang插件开发"></a>Clang插件开发</h2><p>我们可以通过开发Clang插件来对我们的代码进行静态分析，大概步骤是我们先把LLVM源码和clang源码下载到本地，然后进行编译，编译完之后我们就可以得到我们自己的编译器，然后把我们的clang插件放入指定目录，然后在Xcode里面把Xcode原来的编译器配置为我们自己的编译器，然后就可以使用我们的Clang插件了。</p><p>举个例子，通过Clang我们可以对类名命名进行一些约束，比如NSString不用copy修饰的时候就警告一下。</p><p><a href="https://imgtu.com/i/48lKER"><img src="https://z3.ax1x.com/2021/09/19/48lKER.png" alt="48lKER.png"></a></p><p>接下来我们讲解一下配置和开发步骤</p><h3 id="下载LLVM源码"><a href="#下载LLVM源码" class="headerlink" title="下载LLVM源码"></a>下载LLVM源码</h3><p>可以直接在github上面下载到源码，目前最新版本号为12.0.1，直接点击页面的<code>Source Code</code>下载，<a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.1">github地址</a></p><h3 id="下载Clang源码"><a href="#下载Clang源码" class="headerlink" title="下载Clang源码"></a>下载Clang源码</h3><p>同样也是<a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.1">这个地址</a>，目前的最新版本是12.0.1，点击<code>clang-12.0.1.src.tar.xz</code>下载</p><p>下载后解压，文件夹命名为clang，把文件夹置入LLVM源码目录<code>llvm</code>文件夹的<code>tools</code>文件夹中</p><h3 id="安装cmake和ninja（先安装brew，https-brew-sh）"><a href="#安装cmake和ninja（先安装brew，https-brew-sh）" class="headerlink" title="安装cmake和ninja（先安装brew，https://brew.sh）"></a>安装cmake和ninja（先安装brew，<a href="https://brew.sh)/">https://brew.sh）</a></h3><p>使用cmake和ninja工具是为了让编译速度更快</p><p><code>$ brew install cmake</code><br><code>$ brew install ninja</code></p><p>ninja如果安装失败，可以直接从<a href="https://github.com/ninja-build/ninja/releases">github</a>获取release版（ninja-mac.zip）放入<code>/usr/local/bin</code>中</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><h4 id="使用ninja模板进行编译"><a href="#使用ninja模板进行编译" class="headerlink" title="使用ninja模板进行编译"></a>使用ninja模板进行编译</h4><p>在llvm源码目录内新建一个文件夹命名为<code>llvm_build</code>目录备用，用来放置ninja模板，然后在新建一个<code>llvm_release</code>文件夹，用来放置编译后的成品</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cd</span> llvm_build</span><br><span class="line">$ cmake -G Ninja <span class="string">../llvm</span> -DCMAKE_INSTALL_PREFIX=<span class="string">../llvm_release</span></span><br></pre></td></tr></table></figure><p>命令执行完成后就<code>cd llvm_build</code>进入模板文件夹，然后依次执行以下命令</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ninja</span><br><span class="line"><span class="variable">$ </span>ninja release</span><br></pre></td></tr></table></figure><p>之后就可以在<code>llvm_release</code>内看到编译成品了</p><h4 id="使用Xcode进行编译"><a href="#使用Xcode进行编译" class="headerlink" title="使用Xcode进行编译"></a>使用Xcode进行编译</h4><p>也可以生成Xcode项目再进行编译，但是速度很慢（可能需要1个多小时）</p><p>在llvm源码目录内新建一个文件夹命名为<code>llvm_xcode</code>目录备用</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> llvm_xcode</span><br><span class="line"><span class="variable">$</span> cmake <span class="literal">-G</span> Xcode ../llvm</span><br></pre></td></tr></table></figure><p>生成完之后打开<code>llvm_xcode</code>内的<code>LLVM.xcodeproj</code></p><p>选择自动生成Scheme</p><p><a href="https://imgtu.com/i/430RxA"><img src="https://z3.ax1x.com/2021/09/19/430RxA.png" alt="430RxA.png"></a></p><p>选择<code>ALL_BUILD</code> Scheme 然后就可以Cmd+R开始编译了</p><p><a href="https://imgtu.com/i/43022d"><img src="https://z3.ax1x.com/2021/09/19/43022d.png" alt="43022d.png"></a></p><p>编译后的成品在<code>llvm_xcode/Debug/bin</code>中</p><h3 id="创建Clang插件"><a href="#创建Clang插件" class="headerlink" title="创建Clang插件"></a>创建Clang插件</h3><p>在llvm源码的<code>/llvm/tools/clang/tools</code>文件夹内，新建一个文件夹，命名为<code>my-plugin</code>(举例名字)</p><p>在同目录下打开文件<code>CMakeLists.txt</code>，在最后一行写入<code>add_clang_subdirectory(my-plugin)</code>后保存</p><p>在<code>my-plugin</code>文件夹内新建一个文件命名为<code>MyPlugin.cpp</code>，再新建一个<code>CMakeLists.txt</code>文件到该文件夹内</p><p>编辑<code>CMakeLists.txt</code>文件，写入</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_llvm_library</span><span class="params">(MyPlugin MODULE BUILDTREE_ONLY MyPlugin.cpp)</span></span></span><br></pre></td></tr></table></figure><p>表示可加载模块</p><p>如果有很多cpp文件的话，那么也可以这么写</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_llvm_library( MyPlugin MODULE BUILDTREE_ONLY </span><br><span class="line">MyPlugin.cpp</span><br><span class="line">MyPlugin2.cpp</span><br><span class="line">MyPlugin3.cpp</span><br><span class="line">MyPlugin4.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="编写Clang插件"><a href="#编写Clang插件" class="headerlink" title="编写Clang插件"></a>编写Clang插件</h3><p>因为在文本编辑器中编辑c++代码很麻烦，所以我们一般会生成一个Xcode模板（也就是上面提到那个<code>使用Xcode进行编译</code>的Xcode模板）帮我们辅助编写C++代码</p><p>所以我们在llvm源码目录的<code>llvm_xcode</code>文件夹内执行一下<code>cmake -G Xcode ../llvm</code>命令，就可以得到一个Xcode模板，打开工程之后，就可以看到我们的插件目录</p><p><a href="https://imgtu.com/i/4369gg"><img src="https://z3.ax1x.com/2021/09/19/4369gg.png" alt="4369gg.png"></a></p><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 必要的头文件，主要用来解析语法树</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/AST/AST.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/AST/ASTConsumer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/Frontend/FrontendPluginRegistry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang::ast_matchers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MyPlugin &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyASTConsumer</span> :</span> <span class="keyword">public</span> ASTConsumer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/// 每当生成一棵语法树就会调用这个方法</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">HandleTranslationUnit</span><span class="params">(ASTContext &amp;Ctx)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;MyPlugin-HandleTranslationUnit&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyAction</span> :</span> <span class="keyword">public</span> PluginASTAction &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/// 一定要重写的两个父类方法，指定Consumer</span></span><br><span class="line">        <span class="function">unique_ptr&lt;ASTConsumer&gt; <span class="title">CreateASTConsumer</span><span class="params">(CompilerInstance &amp;ci, StringRef InFile)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> unique_ptr&lt;MyASTConsumer&gt; (<span class="keyword">new</span> MyASTConsumer);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">ParseArgs</span><span class="params">(<span class="keyword">const</span> CompilerInstance &amp;CI, <span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 注册插件</span></span><br><span class="line"><span class="keyword">static</span> FrontendPluginRegistry::Add&lt;MyPlugin::MyAction&gt;</span><br><span class="line"><span class="built_in">X</span>(<span class="string">&quot;MyPlugin&quot;</span>, <span class="string">&quot;The MyPlugin is my first clang-plugin.&quot;</span>);</span><br></pre></td></tr></table></figure><p>编译<code>MyPlugin</code> Scheme</p><p><a href="https://imgtu.com/i/481kdA"><img src="https://z3.ax1x.com/2021/09/19/481kdA.png" alt="481kdA.png"></a></p><p>最后得到成品<code>MyPlugin.dylib</code></p><p><a href="https://imgtu.com/i/481eRf"><img src="https://z3.ax1x.com/2021/09/19/481eRf.png" alt="481eRf.png"></a></p><h3 id="使用Clang插件"><a href="#使用Clang插件" class="headerlink" title="使用Clang插件"></a>使用Clang插件</h3><p><code>Show in finder</code>取出<code>MyPlugin.dylib</code>之后，我们新建一个测试工程</p><p>在新建的Xcode项目中指定加载插件：<code>Build Settings &gt; OTHER_CFLAGS</code>，双击输入框后输入</p><p><code>-Xclang -load -Xclang 动态库路径 -Xclang -add-plugin -Xclang 插件名称</code>，回车</p><p><a href="https://imgtu.com/i/43XojJ"><img src="https://z3.ax1x.com/2021/09/19/43XojJ.png" alt="43XojJ.png"></a></p><p>因为Xcode自带的编译器不允许加载插件，所以我们使用刚才自己编译好的编译器</p><p>首先下载<a href="https://github.com/weizhangCoder/XcodeHacking">Xcode破解插件</a></p><p>进入目录<code>XcodeHacking/HackedClang.xcplugin/Contents/Resources</code></p><p>修改<code>HackedClang.xcspec</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ExecPath</span> = <span class="string">&quot;/opt/llvm/llvm_build/bin/clang&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>改为我们刚才编译好的clang的全路径</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ExecPath</span> = <span class="string">&quot;/Users/arclin/Downloads/llvm-project-llvmorg-12.0.1/llvm-release/bin/clang&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>然后在XcodeHacking目录下进行命令行，</p><p>将XcodeHacking的内容剪切到Xcode内部</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv HackedClang.xcplugin `xcode-select -p`<span class="regexp">/../</span>PlugIns<span class="regexp">/Xcode3Core.ideplugin/</span>Contents<span class="regexp">/SharedSupport/</span>Developer<span class="regexp">/Library/</span>Xcode/Plug-ins</span><br><span class="line">$ sudo mv HackedBuildSystem.xcspec `xcode-select -p`<span class="regexp">/Platforms/i</span>PhoneSimulator.platform<span class="regexp">/Developer/</span>Library<span class="regexp">/Xcode/</span>Specifications</span><br></pre></td></tr></table></figure><p>这时候Xcode就应该有多一个编译器可选项，我们选择<code>Clang LLVM Trunk</code></p><p><a href="https://imgtu.com/i/48lXI1"><img src="https://z3.ax1x.com/2021/09/19/48lXI1.png" alt="48lXI1.png"></a></p><p>然后就可以Clean一下后编译进行测试。</p><p>自己在测试的时候发生了一些报错的问题（可能我是用的M1笔记本的原因），可以修改<code>Build System</code>的值为<code>Legacy Build System</code>解决</p><p><a href="https://imgtu.com/i/48lsxS"><img src="https://z3.ax1x.com/2021/09/19/48lsxS.png" alt="48lsxS.png"></a></p><p>如果发生了<code>CADisplayLink&#39; is unavailable: not available on macOS</code>的问题，那尝试新建一个Mac项目</p><p>最后贴出完整的插件代码仅供参考</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/AST/AST.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/AST/DeclObjC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/AST/ASTConsumer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/Frontend/FrontendPluginRegistry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明使用命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang::ast_matchers;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> MyPlugin &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：扫描完毕回调</span></span><br><span class="line">    <span class="comment">// 4、自定义回调类，继承自MatchCallback</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyMatchCallback</span> :</span> <span class="keyword">public</span> MatchFinder::MatchCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// CI传递路径：MyASTAction类中的CreateASTConsumer方法参数 -&gt; MyASTConsumer的构造函数 -&gt; MyMatchCallback的私有属性，通过构造函数从MyASTConsumer构造函数中获取</span></span><br><span class="line">        CompilerInstance &amp;CI;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否是自己的文件</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isUserSourceCode</span><span class="params">(<span class="keyword">const</span> string fileName)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 文件名不为空</span></span><br><span class="line">            <span class="keyword">if</span> (fileName.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 非Xcode中的代码都认为是用户的</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == fileName.<span class="built_in">find</span>(<span class="string">&quot;/Applications/Xcode.app/&quot;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否应该用copy修饰</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isShouldUseCopy</span><span class="params">(<span class="keyword">const</span> string typeStr)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 判断类型是否是 NSString / NSArray / NSDictionary</span></span><br><span class="line">            <span class="keyword">if</span> (typeStr.<span class="built_in">find</span>(<span class="string">&quot;NSString&quot;</span>) != string::npos ||</span><br><span class="line">                typeStr.<span class="built_in">find</span>(<span class="string">&quot;NSArray&quot;</span>) != string::npos ||</span><br><span class="line">                typeStr.<span class="built_in">find</span>(<span class="string">&quot;NSDictionary&quot;</span>) != string::npos) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="built_in">MyMatchCallback</span>(CompilerInstance &amp;CI):<span class="built_in">CI</span>(CI) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载run方法</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">const</span> MatchFinder::MatchResult &amp;Result)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 通过Result获取节点对象，根据节点id(&quot;objcPropertyDecl&quot;)获取(此id需要与MyASTConsumer构造方法中bind的id一致)</span></span><br><span class="line">            <span class="keyword">const</span> ObjCPropertyDecl *propertyDecl = Result.Nodes.getNodeAs&lt;ObjCPropertyDecl&gt;(<span class="string">&quot;objcPropertyDecl&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取文件名称（包含路径）</span></span><br><span class="line">            string fileName = CI.<span class="built_in">getSourceManager</span>().<span class="built_in">getFilename</span>(propertyDecl-&gt;<span class="built_in">getSourceRange</span>().<span class="built_in">getBegin</span>()).<span class="built_in">str</span>();</span><br><span class="line">            <span class="comment">// 如果节点有值 &amp;&amp; 是用户文件</span></span><br><span class="line">            <span class="keyword">if</span> (propertyDecl &amp;&amp; <span class="built_in">isUserSourceCode</span>(fileName)) &#123;</span><br><span class="line">                <span class="comment">// 获取节点的类型，并转成字符串</span></span><br><span class="line">                string typeStr = propertyDecl-&gt;<span class="built_in">getType</span>().<span class="built_in">getAsString</span>();</span><br><span class="line">                <span class="comment">// 节点的描述信息</span></span><br><span class="line">                ObjCPropertyAttribute::Kind attrKind = propertyDecl-&gt;<span class="built_in">getPropertyAttributes</span>();</span><br><span class="line">                <span class="comment">// 应该使用copy，但是没有使用copy</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isShouldUseCopy</span>(typeStr) &amp;&amp; !(attrKind &amp; ObjCPropertyAttribute::kind_copy)) &#123;</span><br><span class="line">                    <span class="comment">// 通过CI获取诊断引擎</span></span><br><span class="line">                    DiagnosticsEngine &amp;diag = CI.<span class="built_in">getDiagnostics</span>();</span><br><span class="line">                    <span class="comment">// Report 报告</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     错误位置：getLocation 节点位置</span></span><br><span class="line"><span class="comment">                     错误：getCustomDiagID（等级，提示）</span></span><br><span class="line"><span class="comment">                     DiagnosticsEngine::Warning 警告</span></span><br><span class="line"><span class="comment">                     DiagnosticsEngine::Error 错误</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    diag.<span class="built_in">Report</span>(propertyDecl-&gt;<span class="built_in">getLocation</span>(), diag.<span class="built_in">getCustomDiagID</span>(DiagnosticsEngine::Warning, <span class="string">&quot;%0 - 推荐使用copy修饰该属性&quot;</span>))&lt;&lt; typeStr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：扫描配置完毕</span></span><br><span class="line">    <span class="comment">// 3、自定义MyASTConsumer，继承自抽象类 ASTConsumer，用于监听AST节点的信息 -- 过滤器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyASTConsumer</span> :</span> <span class="keyword">public</span> ASTConsumer &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// AST 节点查找器（过滤器）</span></span><br><span class="line">        MatchFinder matcher;</span><br><span class="line">        <span class="comment">// 回调对象</span></span><br><span class="line">        MyMatchCallback callback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造方法中创建MatchFinder对象</span></span><br><span class="line">        <span class="built_in">MyASTConsumer</span>(CompilerInstance &amp;CI):<span class="built_in">callback</span>(CI) &#123; <span class="comment">// 构造即将CI传递给callback</span></span><br><span class="line">            <span class="comment">// 添加一个MatchFinder，每个objcPropertyDecl节点绑定一个objcPropertyDecl标识（去匹配objcPropertyDecl节点）</span></span><br><span class="line">            <span class="comment">// 回调callback，其实是在CJLMatchCallback里面重写run方法（真正回调的是回调run方法）</span></span><br><span class="line">matcher.<span class="built_in">addMatcher</span>(<span class="built_in">objcPropertyDecl</span>().<span class="built_in">bind</span>(<span class="string">&quot;objcPropertyDecl&quot;</span>), &amp;callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载两个方法 HandleTopLevelDecl 和 HandleTranslationUnit</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析完毕一个顶级的声明就回调一次（顶级节点，即全局变量，属性，函数等）</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">HandleTopLevelDecl</span><span class="params">(DeclGroupRef D)</span> </span>&#123;</span><br><span class="line"><span class="comment">//            cout&lt;&lt;&quot;正在解析...&quot;&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当整个文件都解析完毕后回调</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">HandleTranslationUnit</span><span class="params">(ASTContext &amp;Ctx)</span> </span>&#123;</span><br><span class="line"><span class="comment">//            cout&lt;&lt;&quot;文件解析完毕！！！&quot;&lt;&lt;endl;</span></span><br><span class="line">            <span class="comment">// 将文件解析完毕后的上下文context（即AST语法树） 给 matcher</span></span><br><span class="line">            matcher.<span class="built_in">matchAST</span>(Ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、继承PluginASTAction，实现我们自定义的MyASTAction，即自定义AST语法树行为</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyASTAction</span> :</span> <span class="keyword">public</span> PluginASTAction &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载ParseArgs 和 CreateASTConsumer方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         解析给定的插件命令行参数</span></span><br><span class="line"><span class="comment">         - param CI 编译器实例，用于报告诊断。</span></span><br><span class="line"><span class="comment">         - return 如果解析成功，则为true；否则，插件将被销毁，并且不执行任何操作。该插件负责使用CompilerInstance的Diagnostic对象报告错误。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">ParseArgs</span><span class="params">(<span class="keyword">const</span> CompilerInstance &amp;CI, <span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回自定义的MyASTConsumer对象，抽象类ASTConsumer的子类</span></span><br><span class="line">        <span class="function">unique_ptr&lt;ASTConsumer&gt; <span class="title">CreateASTConsumer</span><span class="params">(CompilerInstance &amp;CI, StringRef InFile)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             传递CI</span></span><br><span class="line"><span class="comment">             CI用于：</span></span><br><span class="line"><span class="comment">             - 判断文件是否是用户的</span></span><br><span class="line"><span class="comment">             - 抛出警告</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> unique_ptr&lt;MyASTConsumer&gt;(<span class="keyword">new</span> <span class="built_in">MyASTConsumer</span>(CI));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一步：注册插件，并自定义MyASTAction类</span></span><br><span class="line"><span class="comment">// 1、注册插件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FrontendPluginRegistry::Add&lt;MyPlugin::MyASTAction&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;MyPlugin&quot;</span>, <span class="string">&quot;this is MyPlugin&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://juejin.cn/post/7004633055012864031">https://juejin.cn/post/7004633055012864031</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要简述LLVM的概念与Clang插件开发&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- 内存管理</title>
    <link href="https://www.arclin.cn/post/56d1bd42.html"/>
    <id>https://www.arclin.cn/post/56d1bd42.html</id>
    <published>2021-09-03T09:26:00.000Z</published>
    <updated>2022-07-12T16:51:57.241Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍iOS中内存管理的一些事情</p><span id="more"></span><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="CADisplayLink、NSTimer"><a href="#CADisplayLink、NSTimer" class="headerlink" title="CADisplayLink、NSTimer"></a>CADisplayLink、NSTimer</h3><p><code>CADisplayLink</code>、<code>NSTimer</code>会对<code>target</code>产生强引用，如果<code>target</code>又对它们产生强引用，那么就会引发循环引用</p><p>比如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerTimer) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>在这里，<code>self</code>强持有了<code>timer</code>，<code>timer</code>强持有了<code>self</code>，造成了循环引用</p><h4 id="利用block解决"><a href="#利用block解决" class="headerlink" title="利用block解决"></a>利用block解决</h4><p>针对<code>NSTimer</code>我们可以有另外的解决办法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">    [weakself timerTest];</span><br><span class="line">]&#125;;</span><br></pre></td></tr></table></figure><p>让<code>timer</code>强持有block，block弱持有<code>self</code>，这样子<code>self</code>就是间接被弱持有，打破了循环引用。</p><h4 id="利用NSProxy解决"><a href="#利用NSProxy解决" class="headerlink" title="利用NSProxy解决"></a>利用NSProxy解决</h4><p>新建一个类继承自<code>NSProxy</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyProxy</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">    <span class="comment">// NSProxy对象不需要调用init，因为它没有init方法</span></span><br><span class="line">    MyProxy *proxy = [MyProxy alloc];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 实现消息转发的两个方法，一定要实现，不然会报方法找不到的错误</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    [invocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:[MyProxy proxyWithTarget:<span class="keyword">self</span>] selector:<span class="keyword">@selector</span>(test) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原理很简单，就是把<code>self</code>让<code>proxy</code>弱持有，<code>timer</code>强持有<code>proxy</code>，这样子就能够做到间接弱持有<code>self</code>，打破循环引用</p><p>为了让<code>timer</code>调用<code>selector</code>的时候能调回到<code>self</code>的方法，在<code>proxy</code>内部我们使用消息转发机制，把消息转发到<code>target</code>（也就是<code>self</code>）中，实现调用。</p><p>至于消息转发机制的另一个方法<code>-forwardingTargetForSelector:</code>之所以不能使用，是因为<code>NSProxy</code>不提供。</p><p>实际上我们如果不继承自<code>NSProxy</code>，直接继承自<code>NSObject</code>也是能完成上述操作的，但是使用<code>NSProxy</code>的话可以跳过消息发送和动态方法解析阶段，直接进入消息转发阶段，效率比较高</p><blockquote><p>注意： <code>NSProxy</code>对象如果调用<code>isKindOfClass:</code>或其他方法，那么由于它直接进入了消息转发阶段，所以会直接拿<code>target</code>属性去调用方法，所以都跟<code>NSProxy</code>对象本身没有关系</p></blockquote><h3 id="GCD定时器"><a href="#GCD定时器" class="headerlink" title="GCD定时器"></a>GCD定时器</h3><ul><li><code>NSTimer</code>依赖<code>RunLoop</code>，如果<code>Runloop</code>的任务过于繁重，可能会导致<code>NSTimer</code>不准时<ul><li>因为Runloop每次循环的时间是不定的，所以下次循环的时候到达处理定时器那个环节，不一定跟上次刚好相差我们所指定时间，所以就会不准</li></ul></li><li>GCD的定时器会更加准时</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建定时器</span></span><br><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置时间</span></span><br><span class="line"><span class="built_in">NSTimeInterval</span> start = <span class="number">2.0</span>; <span class="comment">// 2秒后开始执行</span></span><br><span class="line"><span class="built_in">NSTimeInterval</span> interval = <span class="number">1.0</span>; <span class="comment">// 每1秒执行一次</span></span><br><span class="line">dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * <span class="built_in">NSEC_PER_SEC</span>), interval * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调</span></span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;11111&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动定时器</span></span><br><span class="line">dispatch_resume(timer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消定时器</span></span><br><span class="line"><span class="comment">// dispatch_source_cancel(timer);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.timer = timer;</span><br></pre></td></tr></table></figure><p>由于GCD的定时器跟<code>Runloop</code>没有关系，所以滚动视图也不会影响GCD定时器的执行</p><p>除了使用block回调，我们也可以写一个C函数作为回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_set_event_handler_f(timer, timerFire);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timerFire</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;%@ %@&quot;</span>,param,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><ul><li>内存布局从低地址到高地址排序如下<ol><li>保留</li><li>代码段（__TEXT）</li><li>数据段（__DATA）：字符串常量， 已初始化数据，未初始化数据</li><li>堆（heap）</li><li>栈（stack）</li><li>内核区</li></ol></li><li>代码段：编译之后的代码</li><li>数据段：<ul><li>字符串常量</li><li>已初始化数据：已初始化的全局变量、静态变量等</li><li>未初始化数据：未初始化的全局变量、静态变量等</li></ul></li><li>堆：通过alloc、malloc、calloc的那个动态分配的空间，分配的内存空间地址越来越大</li><li>栈：函数调用开销，比如局部变量，分配的内存空间地址越来越小</li></ul><h2 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h2><ul><li><p>从64bit开始，iOS引入了Tagged Pointer技术，用于优化<code>NSNumber</code>,<code>NSDate</code>，<code>NSString</code>等小对象的存储</p></li><li><p>在没有使用Tagged Pointer之前，<code>NSNumber</code>等对象需要动态分配内存，维护引用计数的等，<code>NSNumber</code>指针存储的是堆中<code>NSNumber</code>对象的地址值.</p></li><li><p>使用<code>Tagged Pointer</code>之后，<code>NSNumber</code>指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中。</p></li><li><p>在Mac环境下当对象指针的二进制最低有效位是1，则该指针为<code>Tagged Pointer</code>（如果是0那么就是OC对象，因为OC对象分配内存是按照16个字节对齐的，所以最后一位肯定是0）,可以编写如下函数来判断是否是<code>Tagged Pointer</code></p><ul><li>跟1进行与运算，取出最低位判断是不是1即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">isTaggedPointer</span><span class="params">(id pointer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span>)(__bridge <span class="keyword">void</span> *)pointer &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果是iOS环境下，则判断的是最高有效位(第64位)是否是1，即<code>(long)(__bridge void *)pointer &amp; 1UL&lt;&lt;63</code></li></ul></li><li><p>当指针不够存储数据时，才会使用动态分配内存来存储数据（比如NSNumber的存储的数字太大了，指针8个十六进制位都装不下）</p></li><li><p><code>objc_msgSend</code>能识别<code>Tagged Pointer</code>，比如<code>NSNumber</code>的intValue方法，直接从指针提取数据，节省了以前的调用开销</p></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br></pre></td></tr></table></figure><p>这个属性的set方法实际为</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)<span class="built_in">setName</span>:(NSString *)<span class="built_in">name</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">_name</span> != <span class="built_in">name</span>) &#123;</span><br><span class="line">        [<span class="variable">_name</span> release];</span><br><span class="line">        <span class="variable">_name</span> = [<span class="built_in">name</span> retain];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们这么给<code>name</code>赋值<code>self.name = [NSString stringWithForamt:@&quot;abcdefghijkl&quot;]</code>，因为这个太大了，转不成<code>tagged pointer</code>，那么在多线程环境下，有可能会因为多次执行了<code>[_name release]</code>导致坏内存访问而崩溃</p><p>字符串其实还有其他样子，总的来说，除了<code>__NSCFString</code>，其他类型的字符串都不会调用<code>release</code>方法</p><ul><li><p>__NSCFConstantString</p><p>  字符串常量，是一种编译时常量，它的 retainCount 值很大，是 4294967295，在控制台打印出的数值则是 18446744073709551615==2^64-1，测试证明，即便对其进行 release 操作，retainCount 也不会产生任何变化。是创建之后便是放不掉的对象。<strong>相同内容的 __NSCFConstantString 对象的地址相同，也就是说常量字符串对象是一种单例</strong>。</p><p>  这种对象一般通过字面值 <code>@&quot;...&quot;</code>、<code>CFSTR(&quot;...&quot;)</code> 或者 <code>stringWithString</code>: 方法（需要说明的是，这个方法在 iOS6 SDK 中已经被称为redundant，使用这个方法会产生一条编译器警告。这个方法等同于字面值创建的方法）产生。</p><p>  这种对象存储在字符串常量区。</p></li><li><p>__NSCFString</p><p>  和 <code>__NSCFConstantString</code> 不同， <code>__NSCFString</code>对象是在运行时创建的一种 <code>NSString</code>子类，他并不是一种字符串常量。所以和其他的对象一样在被创建时获得了 1 的引用计数。</p><p>  通过 NSString 的 stringWithFormat 等方法创建的 NSString 对象一般都是这种类型。</p><p>  这种对象被存储在堆上。</p></li><li><p>NSTaggedPointerString</p><p>  理解这个类型，需要明白什么是<code>TaggedPointer</code>，这是苹果在 64 位环境下对 NSString,NSNumber 等对象做的一些优化。简单来讲可以理解为把指针指向的内容直接放在了指针变量的内存地址中，因为在 64 位环境下指针变量的大小达到了 8 位足以容纳一些长度较小的内容。于是使用了标签指针这种方式来优化数据的存储方式。从他的引用计数可以看出，这货也是一个释放不掉的单例常量对象。在运行时根据实际情况创建。</p><p>  对于 <code>NSString</code> 对象来讲，当非字面值常量的数字，英文字母字符串的长度小于等于 9 的时候会自动成为 <code>NSTaggedPointerString</code> 类型，如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为 ）<code>__NSCFString</code> 类型。</p><p>  这种对象被直接存储在指针的内容中，可以当作一种伪对象。</p><p>  当字符串的长度为10个以内时，字符串的类型都是<code>NSTaggedPointerString</code>类型，当超过10个时，字符串的类型才是<code>__NSCFString</code></p></li><li><p>从<code>NSTaggedPointerString</code>中读取出字符串的值</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_MASK (1UL&lt;&lt;63)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_INDEX_SHIFT 0</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_SLOT_SHIFT 0</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_PAYLOAD_LSHIFT 1</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_PAYLOAD_RSHIFT 4</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_INDEX_SHIFT 55</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_SLOT_SHIFT 55</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_PAYLOAD_LSHIFT 9</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> _objc_isTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">uintptr_t</span>)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uintptr_t</span> _objc_decodeTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)ptr ^ objc_debug_taggedpointer_obfuscator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uintptr_t</span> _objc_getTaggedPointerValue(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> value = _objc_decodeTaggedPointer(ptr);</span><br><span class="line">    <span class="keyword">uintptr_t</span> basicTag = (value &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class="line">    <span class="keyword">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class="line">        <span class="keyword">return</span> (value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (value &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">intptr_t</span> _objc_getTaggedPointerSignedValue(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> value = _objc_decodeTaggedPointer(ptr);</span><br><span class="line">    <span class="keyword">uintptr_t</span> basicTag = (value &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class="line">    <span class="keyword">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">intptr_t</span>)value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">intptr_t</span>)value &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NSNumber"><a href="#NSNumber" class="headerlink" title="NSNumber"></a>NSNumber</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *number1 = @(<span class="number">0x1</span>);</span><br><span class="line"><span class="built_in">NSNumber</span> *number2 = @(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">NSNumber</span> *number3 = @(<span class="number">0x3F</span>);</span><br><span class="line"><span class="built_in">NSNumber</span> *numberFFFF = @(<span class="number">0xFFFFFFFFFFEFE</span>);</span><br><span class="line"><span class="built_in">NSNumber</span> *maxNum = @(MAXFLOAT);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;number1 pointer is %p class is %@&quot;</span>, number1, number1.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;number2 pointer is %p class is %@&quot;</span>, number2, number2.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;number3 pointer is %p class is %@&quot;</span>, number3, number3.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;numberffff pointer is %p class is %@&quot;</span>, numberFFFF, numberFFFF.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;maxNum pointer is %p class is %@&quot;</span>, maxNum, maxNum.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TaggedPointerDemo[<span class="number">59218</span>:<span class="number">2167895</span>] number1 pointer is <span class="number">0xf7cb914ffb51479a</span> <span class="keyword">class</span> is __NSCFNumber</span><br><span class="line">TaggedPointerDemo[<span class="number">59218</span>:<span class="number">2167895</span>] number2 pointer is <span class="number">0xf7cb914ffb51458a</span> <span class="keyword">class</span> is __NSCFNumber</span><br><span class="line">TaggedPointerDemo[<span class="number">59218</span>:<span class="number">2167895</span>] number3 pointer is <span class="number">0xf7cb914ffb51447a</span> <span class="keyword">class</span> is __NSCFNumber</span><br><span class="line">TaggedPointerDemo[<span class="number">59218</span>:<span class="number">2167895</span>] numberffff pointer is <span class="number">0xf7346eb004aea86b</span> <span class="keyword">class</span> is __NSCFNumber</span><br><span class="line">TaggedPointerDemo[<span class="number">59218</span>:<span class="number">2167895</span>] maxNum pointer is <span class="number">0x28172a0c0</span> <span class="keyword">class</span> is __NSCFNumber</span><br></pre></td></tr></table></figure><p>我们发现对于<code>NSNumber</code>，我们打印出来的数据类型均为<code>__NSCFNumber</code>,但是我们发现对于MAXFLOAT打印出的地址显然与其他几项不符，上面几个<code>NSNumber</code>的地址以0xf开头，根据字符串地址的经验我们可以看出<code>f = 1111</code>,首位标记位为1，表示这个数据类型属于<code>TaggedPointer</code>。而<code>MAXFLOAT</code>不是。</p><h2 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h2><ul><li><p>在iOS中，使用<code>引用计数</code>来管理OC对象的内存</p></li><li><p>一个新创建的OC对象的引用计数默认是1，当引用计数减为0，OC对象就会销毁，释放其占用的内存空间</p></li><li><p>调用retain会让OC对象的引用计数+1，调用release会让OC对象的引用计数-1</p></li><li><p>内存管理的经验总结：</p><ul><li>当调用<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>方法返回了一个对象，在不需要这个对象时，要调用<code>release</code>或者<code>autorelease</code>释放它</li><li>想拥有某个对象，就让它的引用计数+1;不想再拥有某个对象，就让它的引用计数-1</li></ul></li><li><p>可以通过以下私有函数来查看自动释放池的情况</p><p>  <code>extern void _objc_autoreleasePoolPrint(void); </code></p></li></ul><p>在ARC中声明<code>@property(nonatomic,assign) int age;</code> 其set方法相当于MRC中的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age &#123;</span><br><span class="line">    _age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ARC中声明<code>@property(nonatomic,strong) NSObject *age;</code> 其set方法相当于MRC中的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="built_in">NSObject</span> *)age &#123;</span><br><span class="line">    <span class="keyword">if</span> (_age != age) &#123; <span class="comment">// 防止同个对象释放后引用计数变成0，就不能再retain了</span></span><br><span class="line">        [_age release]; <span class="comment">// 防止新对象进来之后，旧对象的引用计数多出了1导致释放不掉</span></span><br><span class="line">        _age = [age reatin]; <span class="comment">// 引用计数+1，防止被外部一不小心释放了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>关于Autorelease</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">self.data</span> = [NSMutableArray array]<span class="comment">; // 自动进行了autorelease</span></span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.data = <span class="comment">[<span class="comment">[<span class="comment">[NSMutableArray alloc]</span> init]</span> autorelease]</span>;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">self.data</span> = [[NSMutableArray alloc] init]<span class="comment">;</span></span><br><span class="line"><span class="section">[self.data release]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSMutableArray</span> *<span class="class"><span class="keyword">data</span> = [[<span class="type">NSMutableArray</span> alloc] init];</span></span><br><span class="line"><span class="title">self</span>.<span class="class"><span class="keyword">data</span> = <span class="keyword">data</span>;</span></span><br><span class="line">[<span class="class"><span class="keyword">data</span> release];</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="引用计数的存储"><a href="#引用计数的存储" class="headerlink" title="引用计数的存储"></a>引用计数的存储</h2><p>在64bit中，引用计数可以直接存储在优化过的isa指针中，如果isa指针不够存的话就存储在<code>SiteTable</code>类中（最终的引用计数是两个存储的地方都会取出来值，然后求和）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="keyword">weak_table_t</span> weak_table;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>refcnts是一个存放着对象引用计数的散列表</li></ul><p>在SiteTable中获取到<code>retainCount</code>的核心代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">objc_object::sidetable_getExtraRC_nolock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ASSERT(isa.nonpointer);</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>); </span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.end()) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 遍历refcnts</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT; <span class="comment">// 进行位运算取出retainCount</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Weak"><a href="#Weak" class="headerlink" title="Weak"></a>Weak</h2><p> weak指针能够在对象释放的时候把指针清空，具体是怎么做到的。我们需要看一下对象<code>dealloc</code>的过程</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">objc_object::rootDealloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(isa.nonpointer                     &amp;&amp; <span class="comment">// 0代表普通的指针，1代表优化过的指针，使用位域存储信息</span></span><br><span class="line">                 !isa.weakly_referenced             &amp;&amp; <span class="comment">// 是否有弱引用指针</span></span><br><span class="line">                 !isa.has_assoc                     &amp;&amp; <span class="comment">// 是否有设置关联对象</span></span><br><span class="line">                 !isa.has_cxx_dtor                  &amp;&amp; <span class="comment">// 是否有C++即构函数</span></span><br><span class="line">                 !isa.has_sidetable_rc))   <span class="comment">// 引用计数器是不是过大而无法存放在isa中，如果为1，那引用计数会存储在SideTable的类的属性中</span></span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        object_dispose((id)<span class="keyword">this</span>); <span class="comment">// 显然弱引用指针指向的对象会进入这里</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id  <span class="title">object_dispose</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj); <span class="comment">// 释放前做一些事情</span></span><br><span class="line">    <span class="built_in">free</span>(obj); <span class="comment">// 这里才释放</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj); <span class="comment">// 清除成员变量</span></span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj, <span class="comment">/*deallocating*/</span><span class="literal">true</span>); <span class="comment">// 移除关联对象</span></span><br><span class="line">        obj-&gt;clearDeallocating(); <span class="comment">// 将指向当前对象的弱指针置为nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">objc_object::clearDeallocating</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for raw pointer isa.</span></span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">        clearDeallocating_slow(); <span class="comment">// 再进入这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">NEVER_INLINE <span class="keyword">void</span> <span class="title">objc_object::clearDeallocating_slow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ASSERT(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>]; <span class="comment">// 拿出SiteTables数组，然后取出对应的SiteTable对象</span></span><br><span class="line">    table.lock();</span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)<span class="keyword">this</span>); <span class="comment">// 清除弱引用指针 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.erase(<span class="keyword">this</span>); <span class="comment">// 清除引用计数表</span></span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">weak_clear_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent_id)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 把SiteTable里面的weakTable和指针传进去</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    <span class="keyword">if</span> (entry == nil) &#123;</span><br><span class="line">        <span class="comment">/// XXX shouldn&#x27;t happen, but does with mismatched CF/objc</span></span><br><span class="line">        <span class="comment">//printf(&quot;XXX no entry for clear deallocating %p\n&quot;, referent);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero out references</span></span><br><span class="line">    <span class="keyword">weak_referrer_t</span> *referrers;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;__weak variable at %p holds %p instead of %p. &quot;</span></span><br><span class="line">                             <span class="string">&quot;This is probably incorrect use of &quot;</span></span><br><span class="line">                             <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                             <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                             referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uintptr_t</span> <span class="title">hash_pointer</span><span class="params">(objc_object *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ptr_hash((<span class="keyword">uintptr_t</span>)key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">weak_entry_t</span> * <span class="title">weak_entry_for_referent</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, objc_object *referent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ASSERT(referent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!weak_entries) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 通过与运算得到索引</span></span><br><span class="line">    <span class="keyword">size_t</span> begin = hash_pointer(referent) &amp; weak_table-&gt;mask;</span><br><span class="line">    <span class="keyword">size_t</span> index = begin;</span><br><span class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (weak_table-&gt;weak_entries[index].referent != referent) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(weak_table-&gt;weak_entries);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;weak_table-&gt;weak_entries[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>Weak指针指向的对象释放流程如下</p><ol><li>清除成员变量，移除关联对象</li><li>拿到对象对应的SiteTable，再取出里面的weak_table</li><li>通过hash后的对象的指针和weak_table进行一次与运算，得到索引，在weak_table中通过索引取出弱引用指针</li><li>置空取出的所有的弱引用指针</li><li>清除引用计数表</li><li>释放对象</li></ol><h2 id="Copy和MutableCopy"><a href="#Copy和MutableCopy" class="headerlink" title="Copy和MutableCopy"></a>Copy和MutableCopy</h2><p>拷贝的目的：产生一个副本对象，跟源对象互不影响<br>修改了源对象，不会影响副本对象<br>修改了副本对象，不会影响源对象</p><p>iOS提供了2个拷贝方法</p><ol><li>copy ，不可变拷贝，产生不可变副本。</li><li>mutableCopy，可变拷贝，产生可变副本。</li><li>浅拷贝：指针拷贝，没有产生新的对象。（不可变对象copy）</li><li>深拷贝：内容拷贝，产生新的对象。(可变、不可变对象调用mutableCopy或者可变对象调用copy)</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str1 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;test&quot;</span>];</span><br><span class="line"><span class="built_in">NSString</span> *str2 = [str1 <span class="keyword">copy</span>]; <span class="comment">// 返回的是NSString</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *str3 = [str1 mutableCopy]; <span class="comment">// 返回的是NSMutableString</span></span><br></pre></td></tr></table></figure><p>当<code>copy</code>方法被不可变对象调用的话，不会发生什么变化，直接还是返回原来的对象，但是这时候引用计数会加1，相当于<code>retain</code>了一下，所以上面的代码要释放对象的时候，除了调用<code>[str1 release];</code>，那么还得调用<code>[str2 release]；</code></p><p>在ARC中声明<code>@property(nonatomic,copy) NSString *age;</code> 其set方法相当于MRC中的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="built_in">NSString</span> *)age &#123;</span><br><span class="line">    <span class="keyword">if</span> (_age != age) &#123;</span><br><span class="line">        [_age release];</span><br><span class="line">        _age = [age <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AutoRelease"><a href="#AutoRelease" class="headerlink" title="AutoRelease"></a>AutoRelease</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    Student *student = [[[Student alloc] init] autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  __AtAutoreleasePool() &#123; <span class="comment">// 构造函数</span></span><br><span class="line">      atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">  &#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123; <span class="comment">// 析构函数</span></span><br><span class="line">      objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    __AtAutoreleasePool __autoreleasepool; <span class="comment">// 创建一个结构体变量</span></span><br><span class="line">    Student *student = objc_msgSend(objc_msgSend(objc_msgSend(objc_getClass(<span class="string">&quot;Student&quot;</span>), sel_registerName(<span class="string">&quot;alloc&quot;</span>)), sel_registerName(<span class="string">&quot;init&quot;</span>)), sel_registerName(<span class="string">&quot;autorelease&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">    Student *student = objc_msgSend(objc_msgSend(objc_msgSend(objc_getClass(<span class="string">&quot;Student&quot;</span>), sel_registerName(<span class="string">&quot;alloc&quot;</span>)), sel_registerName(<span class="string">&quot;init&quot;</span>)), sel_registerName(<span class="string">&quot;autorelease&quot;</span>));</span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动释放池的主要底层数据结构是: <code>__AtAutoreleasePool</code>、<code>AutoreleasePoolPage</code></p><p>调用了<code>autorelease</code>的对象最终都是通过<code>AutoreleasePoolPage</code>对象来管的</p><p>源码分析<br>    - clang重写@autoreleasepool<br>    - objc4源码：NSobject.mm</p><h2 id="AutoreleasePoolPage的结构"><a href="#AutoreleasePoolPage的结构" class="headerlink" title="AutoreleasePoolPage的结构"></a>AutoreleasePoolPage的结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;</span><br><span class="line">    id *next;</span><br><span class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;</span><br><span class="line">    AutoreleasePoolPage *<span class="keyword">const</span> parent;</span><br><span class="line">    AutoreleasePoolPage *<span class="keyword">const</span> child;</span><br><span class="line">    <span class="keyword">uint32_t</span> depth;</span><br><span class="line">    <span class="keyword">uint32_t</span> hiwat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放<code>autorelease</code>对象的地址</p></li><li><p>所有的<code>AutoreleasePoolPage</code>对象通过双向链表的形式连接在一起</p></li><li><p>调用push方法会将一个POOL_BOUNDARY入栈，并且返回其存放的内存地址</p></li><li><p>调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送release对象，直到遇到这个POOL_BOUNDARY</p></li><li><p><code>id *next</code>指向了下一个能存放<code>autorelease</code>对象地址的区域</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    id *dest;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(DebugPoolAllocation)) &#123;</span><br><span class="line">        <span class="comment">// Each autorelease pool starts on a new pool page.</span></span><br><span class="line">        dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span> *token)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line">    <span class="keyword">if</span> (token == (<span class="keyword">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        <span class="comment">// Popping the top-level placeholder pool.</span></span><br><span class="line">        page = hotPage();</span><br><span class="line">        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">            <span class="comment">// Pool was never used. Clear the placeholder.</span></span><br><span class="line">            <span class="keyword">return</span> setHotPage(nil);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Pool was used. Pop its contents normally.</span></span><br><span class="line">        <span class="comment">// Pool pages remain allocated for re-use as usual.</span></span><br><span class="line">        page = coldPage();</span><br><span class="line">        token = page-&gt;begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        page = pageForPointer(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    <span class="keyword">if</span> (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            <span class="comment">// Start of coldest page may correctly not be POOL_BOUNDARY:</span></span><br><span class="line">            <span class="comment">// 1. top-level pool is popped, leaving the cold page in place</span></span><br><span class="line">            <span class="comment">// 2. an object is autoreleased with no pool</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Error. For bincompat purposes this is not </span></span><br><span class="line">            <span class="comment">// fatal in executables built with old SDKs.</span></span><br><span class="line">            <span class="keyword">return</span> badPop(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) &#123;</span><br><span class="line">        <span class="keyword">return</span> popPageDebug(token, page, stop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> popPage&lt;<span class="literal">false</span>&gt;(token, page, stop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Runloop和Autorelease"><a href="#Runloop和Autorelease" class="headerlink" title="Runloop和Autorelease"></a>Runloop和Autorelease</h3><ul><li>iOS在主线程的Runloop中注册了两个Observer</li><li>第1个Observer监听了<code>kCFRunLoopEntry</code>事件，会调用<code>objc_autoreleasePoolPush()</code></li><li>第2个Observer<ul><li>监听了<code>kCFRunLoopBeforeWaiting</code>会调用<code>objc_autoreleasePoolPop()</code>、<code>objc_autoreleasePoolPush()</code></li><li>监听了<code>kCFRunloopBeforeExit</code>事件，会调用<code>objc_autoreleasePoolPop()</code></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍iOS中内存管理的一些事情&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS --- 性能优化</title>
    <link href="https://www.arclin.cn/post/a2ff8280.html"/>
    <id>https://www.arclin.cn/post/a2ff8280.html</id>
    <published>2021-08-31T13:42:00.000Z</published>
    <updated>2022-07-12T16:51:57.242Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍iOS内常用的性能优化方案</p><span id="more"></span><h2 id="CPU和GPU"><a href="#CPU和GPU" class="headerlink" title="CPU和GPU"></a>CPU和GPU</h2><ul><li><p>在屏幕成像的过程中，CPU和GPU起着至关重要的作用</p><ul><li>CPU <ul><li>对象的创建和销毁，对象属性的调整、布局计算、文本的计算和排版、图片格式转换和解码、图像的绘制 </li></ul></li><li>GPU<ul><li>纹理的渲染</li></ul></li></ul></li><li><p>在iOS中是双缓冲机制，有前帧缓存、后帧缓存（）</p></li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU-&gt;计算-&gt;GPU-&gt;渲染-&gt;帧缓存-&gt;读取-&gt;视频控制器-&gt;显示-&gt;屏幕   </span><br></pre></td></tr></table></figure><h2 id="屏幕成像原理"><a href="#屏幕成像原理" class="headerlink" title="屏幕成像原理"></a>屏幕成像原理</h2><p>首先先发出一个垂直同步信号（VSync），然后再一行行发出水平同步信号（HSync），直到最后一行HSync发出之后，一帧就渲染完成，然后再次发出一个VSync，渲染下一帧。</p><img src="https://i.loli.net/2021/08/31/hWqVypmfbtga4eK.png" ><h2 id="卡顿"><a href="#卡顿" class="headerlink" title="卡顿"></a>卡顿</h2><h3 id="卡顿产生的原因"><a href="#卡顿产生的原因" class="headerlink" title="卡顿产生的原因"></a>卡顿产生的原因</h3><p><img src="https://i.loli.net/2021/08/31/ZTNhbeyRiq8UgmV.png" alt="1682758-5be402cc0ab5dc56.png"></p><ol><li>首先第一个VSync进入，CPU开始计算处理，然后交给GPU渲染，然后显示到屏幕上</li><li>然后第二个VSync进入，这时候CPU处理的时间比较长，交给GPU后， GPU还没处理完，第三个VSync就进来了，但是因为GPU没处理完。第二帧还不能显示，所以这时候直接取上一帧数据显示，造成第一帧长时间停留</li><li>然后过了一段时间GPU终于处理完了，但是第四个VSync还没来，所以就等，等到第四个VSync进来了，就开始拿刚才生成好的那一帧去显示，然后开始继续第三帧的计算</li></ol><ul><li>解决卡顿的主要思路<ul><li>尽可能减少CPU、GPU资源损耗</li></ul></li><li>按照60fps的刷新率，每个16ms就会有一次VSync信号 </li></ul><h3 id="卡顿检测"><a href="#卡顿检测" class="headerlink" title="卡顿检测"></a>卡顿检测</h3><ul><li>平时所说的__卡顿__主要是因为在主线程执行了比较耗时的操作</li><li>可以添加<code>Observer</code>到主线程<code>Runloop</code>中，通过监听<code>Runloop</code>状态切换的耗时，以达到监控卡顿的目的</li></ul><blockquote><p>参考：<a href="https://github.com/UIControl/LXDAppFluecyMonitor/blob/master/LXDAppFluecyMonitor/LXDAppFluecyMonitor/LXDAppFluecyMonitor.m">LXDAppFluecyMonitor</a></p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> lxdRunLoopObserverCallback(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> * info) &#123;</span><br><span class="line">     <span class="comment">/// 更新当前Runloop状态</span></span><br><span class="line">    SHAREDMONITOR.currentActivity = activity;</span><br><span class="line">    dispatch_semaphore_signal(SHAREDMONITOR.semphore);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startMonitoring &#123;</span><br><span class="line">    <span class="keyword">if</span> (_isMonitoring) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    _isMonitoring = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">CFRunLoopObserverContext</span> context = &#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/// 创建监听对象</span></span><br><span class="line">    _observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, &amp;lxdRunLoopObserverCallback, &amp;context);</span><br><span class="line">    <span class="comment">/// 在CommonModes添加监听者</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 子线程异步串行队列中添加死循环</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(lxd_event_monitor_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">while</span> (SHAREDMONITOR.isMonitoring) &#123;</span><br><span class="line">        <span class="comment">/// 如果当前状态是BeforeWaiting（即将进入休眠）的话</span></span><br><span class="line">            <span class="keyword">if</span> (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeWaiting) &#123;</span><br><span class="line">                __block <span class="built_in">BOOL</span> timeOut = <span class="literal">YES</span>;</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    timeOut = <span class="literal">NO</span>; <span class="comment">// 即将休眠的时候回到主线程超时状态改为NO</span></span><br><span class="line">                    dispatch_semaphore_signal(SHAREDMONITOR.eventSemphore); <span class="comment">//解锁</span></span><br><span class="line">                &#125;);</span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval: lxd_time_out_interval]; <span class="comment">// 子线程休眠一秒</span></span><br><span class="line">                <span class="keyword">if</span> (timeOut) &#123;</span><br><span class="line">                    [LXDBacktraceLogger lxd_logMain]; <span class="comment">// 打印堆栈</span></span><br><span class="line">                &#125;</span><br><span class="line">                dispatch_wait(SHAREDMONITOR.eventSemphore, DISPATCH_TIME_FOREVER); <span class="comment">// 加锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(lxd_fluecy_monitor_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">while</span> (SHAREDMONITOR.isMonitoring) &#123;</span><br><span class="line">            <span class="keyword">long</span> waitTime = dispatch_semaphore_wait(<span class="keyword">self</span>.semphore, dispatch_time(DISPATCH_TIME_NOW, lxd_wait_interval)); <span class="comment">// 等待200纳秒，看是否能拿到锁</span></span><br><span class="line">            <span class="keyword">if</span> (waitTime != LXD_SEMPHORE_SUCCESS) &#123; <span class="comment">// 拿不到锁</span></span><br><span class="line">                <span class="keyword">if</span> (!SHAREDMONITOR.observer) &#123;</span><br><span class="line">                    SHAREDMONITOR.timeOut = <span class="number">0</span>;</span><br><span class="line">                    [SHAREDMONITOR stopMonitoring];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/// Runloop 即将处理Source或者刚从休眠中唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeSources || SHAREDMONITOR.currentActivity == kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (++SHAREDMONITOR.timeOut &lt; <span class="number">5</span>) &#123; <span class="comment">// 超时次数+1，然后如果超时次数大于5次就打印堆栈</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    [LXDBacktraceLogger lxd_logMain];</span><br><span class="line">                    [<span class="built_in">NSThread</span> sleepForTimeInterval: lxd_restore_interval];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            SHAREDMONITOR.timeOut = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="卡顿优化-CPU"><a href="#卡顿优化-CPU" class="headerlink" title="卡顿优化 - CPU"></a>卡顿优化 - CPU</h3><ul><li>尽量使用轻量级的对象，比如用不到事件处理的地方，可以考虑使用<code>CALayer</code>（只是拿来渲染）取代<code>UIView</code>（渲染+处理点击事件等）</li><li>不要频繁地调用<code>UIView</code>的相关属性，比如<code>frame</code>、<code>bounds</code>、<code>transform</code>等属性，尽量减少不必要的修改</li><li>尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</li><li>Autolayout会比直接设置frame消耗更多的CPU资源</li><li>图片的Size最好跟UIImageView的size保持一致</li><li>控制一下线程的最大并发数量</li><li>尽量把耗时操作放到子线程<ul><li>文本处理（尺寸计算、绘制）</li><li>图片处理（解码、绘制）</li></ul></li></ul><p>图片子线程解码举例</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)renderImage &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">/// get CGImage</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> cgImage = [<span class="built_in">UIImage</span> imageWithData:[<span class="built_in">NSData</span> dataWithContentsOfURL:xxx]].CGImage;</span><br><span class="line">        </span><br><span class="line">        size_t width = <span class="built_in">CGImageGetWidth</span>(cgImage);</span><br><span class="line">        size_t height = <span class="built_in">CGImageGetHeight</span>(cgImage);</span><br><span class="line">        <span class="keyword">if</span> (width == <span class="number">0</span> || height == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGImageAlphaInfo</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(cgImage);</span><br><span class="line">        <span class="built_in">BOOL</span> hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</span><br><span class="line">                          alphaInfo == kCGImageAlphaNoneSkipFirst ||</span><br><span class="line">                          alphaInfo == kCGImageAlphaNoneSkipLast);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, <span class="built_in">CGColorSpaceCreateDeviceRGB</span>(), bitmapInfo);</span><br><span class="line">        <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Apply transform</span></span><br><span class="line">        <span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">        <span class="built_in">CGContextConcatCTM</span>(context, transform);</span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), cgImage); <span class="comment">// The rect is bounding box of CGImage, don&#x27;t swap width &amp; height</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> newImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">        <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// back to the main thread</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.imageView.image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:newImageRef];</span><br><span class="line">            <span class="built_in">CGImageRelease</span>(newImageRef);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="卡顿优化-GPU"><a href="#卡顿优化-GPU" class="headerlink" title="卡顿优化 - GPU"></a>卡顿优化 - GPU</h3><ul><li>尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</li><li>GPU能处理的最大纹理尺寸是<strong>4096*4096</strong>，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸</li><li>尽量减少视图数量和层次</li><li>减少透明的视图（alpha &lt; 1），不透明的就设置<code>opaque</code>为<code>YES</code></li><li>尽量避免出现离屏渲染</li></ul><h4 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h4><ul><li><p>在OpenGL中，GPU有2种渲染方式</p><ul><li>On-Screen Rendering：当前离屏渲染，在当前用于显示屏幕缓冲区进行渲染操作</li><li>Off-Screen Rendering: 离屏渲染，在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作 </li></ul></li><li><p>离屏渲染消耗性能的原因</p><ul><li>需要创建新的缓冲区</li><li>离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）;等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕上。</li></ul></li><li><p>哪些操作会触发离屏渲染</p><ul><li>光栅化，<code>layer.shouldRasterize = YES</code></li><li>遮罩 <code>layer.mask</code></li><li>圆角，同时设置 <code>layouer.maskToBounds = YES</code>, <code>layer.cornerRadius</code>大于0<ul><li>考虑通过<code>CoreGraphics</code>绘制裁剪圆角，或者叫美工提供圆角图片</li></ul></li><li>阴影，<code>layer.shadowXXX</code><ul><li>如果设置了<code>layer.shadowPath</code>就不会产生离屏渲染</li></ul></li></ul></li></ul><h2 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h2><h3 id="主要来源"><a href="#主要来源" class="headerlink" title="主要来源"></a>主要来源</h3><ul><li>CPU处理，Processing</li><li>网络，Networking</li><li>定位，Location</li><li>图像，Graphics</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li><p>尽可能降低CPU、GPU功耗</p></li><li><p>少用定时器</p></li><li><p>优化I/O操作</p><ul><li>尽量不要频繁写入小数据，最好批量一次性写入 </li><li>读写大量重要数据时，考虑使用<code>dispatch_io</code>，其提供了基于GCD的异步操作文件的I/O的API.用<code>dispatch_io</code>系统会优化磁盘访问</li><li>数据量比较大的，建议使用数据库(SQLite、CoreData)</li></ul></li><li><p>网络优化</p><ul><li>减少、压缩网络数据</li><li>如果多次请求结果是相同的，尽量使用缓存</li><li>使用断点续传，否则网络不稳定时可能多次传输相同的内容</li><li>网络不可用时，不要尝试执行网络请求</li><li>让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间</li><li>批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载，如果下载广告，一次性多下载一些，然后再慢慢展示，如果下载电子邮件，一次下载多封，不要一封一封地下载</li></ul></li><li><p>定位优化</p><ul><li>如果只是需要快速确定用户当前位置，最好用<code>CLLocationManager</code>的<code>requestLocation</code>方法，定位完成后，会自动让定位硬件断电</li><li>如果不是导航应用， 尽量不要实时更新位置，定位关闭就关掉定位服务</li><li>尽量降低定位精度，比如尽量不要使用精度最高的<code>kCLLocationAccuracyBest</code></li><li>需要后台定位时，尽量设置<code>pausesLocationUpdatesAutomatically</code>为YES，如果用户不太可能移动的时候，系统会自动暂停位置更新</li><li>尽量不要使用<code>startMonitoringSignificantLocationChanges</code>，优先考虑<code>startMonitoringForRegion:</code></li></ul></li><li><p>硬件检测优化</p><ul><li>用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件。</li></ul></li></ul><h2 id="App启动优化"><a href="#App启动优化" class="headerlink" title="App启动优化"></a>App启动优化</h2><ul><li><p>App的启动可以分为2种</p><ul><li>冷启动（Code Launch）：从零开始启动App</li><li>热启动（Warm Launch）：App已经在内存中，在后台存活着，再次点击图标</li></ul></li><li><p>App启动时间的优化，主要是针对冷启动进行优化</p></li><li><p>通过添加环境变量可以打印出App的启动时间分析（Edit Scheme -&gt; Run -&gt; Arguments）</p><ul><li><code>DYLD_PRINT_STATISTICS</code>设置为1 或者 <code>DYLD_PRINT_STATISTICS_DETAILS</code> （更加详细 ）</li></ul></li><li><p>App的冷启动可以概括为3大阶段</p><ul><li><p>dyld</p></li><li><p>runtime</p></li><li><p>main</p><img src="https://i.loli.net/2021/08/31/ldg1cjZCUPe5Gk6.png" ></li><li><p>dyld（dynamic link editor），Apple的动态链接器，可以用来装在Mach-O文件（可执行文件、动态库等 ）</p></li><li><p>启动App时，dyld所做的事情有</p><ul><li>装载App的可执行文件，同时会递归加载所有依赖的动态库</li><li>当dyld把可执行文件、动态库都装载到内存完毕后，会通知Runtime进行下一步的处理</li></ul></li><li><p>启动App时，runtime所做的事情有</p><ul><li>调用<code>map_images</code>进行可执行文件内容的解析和处理</li><li>在<code>load_images</code>中调用<code>call_load_methods</code>,调用所有<code>Class</code>和<code>Category</code>的<code>+load</code>方法</li><li>进行各种objc结构的初始化（注册Objc类，初始化类对象等等）</li><li>调用C++静态初始化器和<code>__attribute((constructor))</code>修饰的函数</li></ul></li><li><p>到此为止，可执行文件和动态库中所有的符号（Class、Protocol、Selector、IMP、…）都已经按格式成功加载到内存中，被<code>runtime</code>所管理</p></li><li><p>总结</p><ul><li>App的启动由dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库</li><li>并由runtime负责加载成objc定义的结构</li><li>所有初始化工作结束后，dyld就会调用main函数</li><li>接下来就是<code>UIApplicationMain</code>函数，AppDelegate的<code>application:didFinishLaunchingWithOptions:</code>方法</li></ul></li></ul></li></ul><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>按照不同的阶段<ul><li>dyld <ul><li>减少动态库，合并一些动态库（定期清理不必要的动态库）</li><li>减少Objc类，分类的数量，减少selector的数量（定期清理不必要的类，分类）</li><li>减少C++虚函数数量</li><li>Swift尽量使用struct</li></ul></li><li>runtime<ul><li>用<code>+initialize</code>和<code>dispatch_once</code>取代所有的<code>__attribute((constructor))</code>、C++静态构造器 、ObjC的<code>+load</code></li></ul></li><li>main<ul><li>在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在<code>finishLaunch</code>方法中</li><li>按需加载 </li></ul></li></ul></li></ul><h2 id="安装包瘦身"><a href="#安装包瘦身" class="headerlink" title="安装包瘦身"></a>安装包瘦身</h2><ul><li><p>安装包（IPA）主要由可执行文件、资源组成</p></li><li><p>资源（图片、视频、音频等）</p><ul><li>采取无损压缩</li><li>去除没有用到的资源(github :LSUnusedResources）</li></ul></li><li><p>可执行文件瘦身</p><ul><li>编译器优化 <ul><li>Strip Linked Product 、 Make Strings Read-Only、 Symbols Hidden By Defaults设置为YES</li><li>去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions 设置为NO，Other C Flags  添加 -fno-exceptions</li></ul></li><li>利用AppCode(<a href="https://www.jetbrains.com/objc">https://www.jetbrains.com/objc</a>)检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code</li><li>编写LLVM插件检测出重复代码，未被调用的代码</li><li>生成Link Map文件，可以查看可执行文件的具体组成（在Build Setting-&gt;Write Link Map File 改为true，就可以在Path to link map file 看到这个文件）</li><li>可以借助第三方工具解析LinkMap文件：<a href="https://github.com/huanxsd/LinkMap">https://github.com/huanxsd/LinkMap</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍iOS内常用的性能优化方案&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>最近看了一本书...</title>
    <link href="https://www.arclin.cn/post/a4ffdee.html"/>
    <id>https://www.arclin.cn/post/a4ffdee.html</id>
    <published>2021-08-29T14:59:00.000Z</published>
    <updated>2022-07-12T16:51:57.245Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了一本 《代码整洁之道》</p><p>基本跟我们平时的编码代码规范有点类似吧。里面的一些设计思想是挺好的。这里记录一下一些个人感觉好像挺有用的点。</p><blockquote><p>部分内容可能存在争议，请不要在意，以自己团队规范为准。</p></blockquote><span id="more"></span><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>用命名常量替代魔术数（泛指任何不能自我描述的符号）</p><p>命名采用描述性名称，确认名称具有描述性</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>封装条件要抽离解释了条件意图函数，比如 shouldBeDelete(timer) 要优于  (timer.hasExpired &amp;&amp; !timer.isRecurrent())</p><p>避免否定条件  if（shouldDo） 要好于 if (!shouldNotDo)</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>为较大作用范围选用较长名称</p><p>名称应该说明函数、变量或类的一切信息，不要用名称掩蔽副作用。</p><p>每个函数只做一件事情</p><p>函数参数应该越少越好</p><p>不要把输入的参数拿来输出</p><p>布尔值参数宣告函数做了不止一件事情，违反了单一职责原则，应该消灭掉</p><p>用布尔、枚举、整数等参数用于判断流程来决定函数行为是不好的，使用多个函数，通常优于向单个函数传递某些代码来选择函数行为</p><p>使用异常替代返回错误码</p><p>抽离Try/Catch代码块</p><p>把重复代码抽离出来</p><p>通常应该倾向于选用非静态方法。如果的确需要静态函数，确保没机会打算让他有多态行为。</p><p>函数名称应该表达其行为</p><p>如果多个函数的调用有时序性，比如必须先调用A才能调用B，要显式声明时序性，比如调用B函数的时候把A函数作为参数传进去，这样子就保证别人不会误把B函数放在A函数前调用</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>顶部给出高层次概念和算法。细节应该往下渐次展开，直至找到原文件中最底层的函数和细节</p><p>如果某个函数调用了另外一个，就应该把它们放在一起，而且调用者应该尽可能放在被调用者上面，</p><p>概念相关的代码应该放到一起，相关性越强，彼此之间的距离就该越短</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数<br>面向对象代码便于在不改动既有函数的前提下添加新类</p><p>过程式代码难以添加新数据结构，因为必须修改所有函数。<br>面向对象代码难以添加新函数，因为必须修改所有类。</p><p>迪米特法则：模块不应了解它所操作对象的内部情形。<br>隐藏结构：<code>let a = b.c().e().f()</code><br>拆分成</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">c</span> = b.c()</span><br><span class="line"><span class="keyword">let</span> <span class="attr">e</span> = c.e()</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span> = e.f()</span><br></pre></td></tr></table></figure><p>应该改成<br><code>let a = b.func()</code></p><p>在方法中，不应该调用其他对象的方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span>(<span class="keyword">let</span> obj)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> item <span class="operator">=</span> obj.func()</span><br><span class="line">    item.func() <span class="comment">// 不可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类C的方法f只能调用以下对象的方法</p><ul><li>C</li><li>由f创建的对象</li><li>作为参数传递给f的对象</li><li>由C的实体变量持有的对象</li></ul><p>用多态替代if/else 或 switch/case</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>不要使用错误码，用try-catch代替</p><p>不要返回null值，用空对象替代，或者抛出异常</p><p>不要传入null值作为参数，除非API要求你这么做</p><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p>使用泛型限制输入</p><p>单元测试</p><p>单元测试应当简单、精悍、足具表达力。</p><p>测试代码和生产代码一样重要</p><p>TDD三定律：</p><ol><li>在编写不能通过的单元测试前，不可编写生产代码</li><li>只可编写刚好无法通过的单元测试，不能编译也不算通过</li><li>只可编写刚好足以通过当前失败测试的生产代码</li></ol><p>每一个测试一个断言</p><ul><li>每一个测试一个概念</li><li>一个概念可以多个断言</li></ul><p>简洁的测试应该遵循5条规则<br>（FIRST: FAST、Independent、Repeatable、Self-Validating、Timely）</p><ol><li>快速：测试应该够快</li><li>独立：测试应该互相独立，某个测试不应为下一个测试设定条件</li><li>可重复：测试应当可在任何环境中重复通过</li><li>自足验证：测试应该有布尔值输出</li><li>及时：测试应及时编写</li></ol><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类应该短小，遵循单一职责原则（类或模块应有且只有一条加以修改的理由）</p><p>类应该只有少量实体变量</p><p>当类丧失了内聚性，就拆分它</p><p>类的方法只应对其所属类中的变量和函数感兴趣，不应该垂青其他类中的变量和函数</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近看了一本 《代码整洁之道》&lt;/p&gt;
&lt;p&gt;基本跟我们平时的编码代码规范有点类似吧。里面的一些设计思想是挺好的。这里记录一下一些个人感觉好像挺有用的点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;部分内容可能存在争议，请不要在意，以自己团队规范为准。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://www.arclin.cn/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="架构" scheme="https://www.arclin.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="技巧" scheme="https://www.arclin.cn/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- 多线程</title>
    <link href="https://www.arclin.cn/post/f4b0e2bd.html"/>
    <id>https://www.arclin.cn/post/f4b0e2bd.html</id>
    <published>2021-08-29T13:49:00.000Z</published>
    <updated>2022-07-12T16:51:57.241Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述iOS中多线程的使用及其原理</p><span id="more"></span><h2 id="常见的多线程方案"><a href="#常见的多线程方案" class="headerlink" title="常见的多线程方案"></a>常见的多线程方案</h2><table><thead><tr><th align="center">技术方案</th><th align="left">简介</th><th align="center">语言</th><th align="center">线程生命周期</th><th align="center">使用频率</th></tr></thead><tbody><tr><td align="center">pthread</td><td align="left"><ul><li>一套通用的多线程API</li><li>适用于Unix\Linux\Windows等系统</li><li>跨平台\可移植</li><li>使用难度大</li></ul></td><td align="center">C</td><td align="center">程序员管理</td><td align="center">几乎不用</td></tr><tr><td align="center">NSThread</td><td align="left"><ul><li>使用更加面向对象</li><li>简单易用，可直接操作线程对象</li></ul></td><td align="center">OC</td><td align="center">程序员管理</td><td align="center">偶尔使用</td></tr><tr><td align="center">GCD</td><td align="left"><ul><li>旨在替代NSThread等线程技术</li><li>充分利用设备的多核</li></ul></td><td align="center">C</td><td align="center">自动管理</td><td align="center">经常使用</td></tr><tr><td align="center">NSOperation</td><td align="left"><ul><li>基于GCD</li><li>比GCD多了一些简单实用的功能</li><li>使用更加面向对象</li></ul></td><td align="center">OC</td><td align="center">自动管理</td><td align="center">经常使用</td></tr></tbody></table><h3 id="一些多线程术语"><a href="#一些多线程术语" class="headerlink" title="一些多线程术语"></a>一些多线程术语</h3><ul><li>同步、异步：能不能开启新的线程<ul><li>同步：在当前线程中执行任务，不具备开启新线程的能力</li><li>异步：在新的线程中执行任务，具备开启新线程的能力</li></ul></li><li>并发、串行：任务的执行方式<ul><li>并发：多个任务并发（同时）执行</li><li>串行：一个任务执行完毕后，再执行下一个任务</li></ul></li></ul><h3 id="各种队列的执行效果"><a href="#各种队列的执行效果" class="headerlink" title="各种队列的执行效果"></a>各种队列的执行效果</h3><table><thead><tr><th></th><th>并发队列</th><th>手动创建的串行队列</th><th>主队列</th></tr></thead><tbody><tr><td>同步（sync）</td><td>没有开启新线程<br>串行执行任务</td><td>没有开启新线程<br>串行执行任务</td><td>没有开启新线程<br>串行执行任务</td></tr><tr><td>异步（async）</td><td>有开启新线程<br>并发执行任务</td><td>有开启新线程<br>串行执行任务</td><td>没有开启新线程<br>串行执行任务</td></tr></tbody></table><ul><li><p>使用<code>sync</code>函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）</p></li><li><p>死锁问题主要产生在串行队列中。由于串行队列的FIFO（First in first out）性质，如果串行队列中有同步函数，那么同步函数要等待串行队列执行完才能执行，又因为同步函数的性质是在当前线程立马执行函数体，所以同步函数后面的代码要等待同步函数执行完才能执行，在这种情况下就会出现死锁</p></li><li><p>因为并发队列允许同时执行多个任务，所以不存在等待队列中其他人完成后才能开始执行的情况，所以一般情况下并发队列不会产生环路等待死锁</p></li></ul><h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><h3 id="GCD的常用函数"><a href="#GCD的常用函数" class="headerlink" title="GCD的常用函数"></a>GCD的常用函数</h3><ul><li>用同步的方式执行任务</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// queue 队列</span></span><br><span class="line"><span class="comment">/// block 任务</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(<span class="built_in">dispatch_queue_t</span> queue,dispatch_block_t block);</span><br></pre></td></tr></table></figure><ul><li>用异步的方式执行任务</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// queue 队列</span></span><br><span class="line"><span class="comment">/// block 任务</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(<span class="built_in">dispatch_queue_t</span> queue,dispatch_block_t block);</span><br></pre></td></tr></table></figure><h3 id="GCD的队列"><a href="#GCD的队列" class="headerlink" title="GCD的队列"></a>GCD的队列</h3><p>GCD的队列可以分为2大类型</p><ul><li><p>并发队列（Concurrent Dispatch Queue）</p><ul><li>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）</li><li>并发功能只有在异步（dispatch_async）函数下才有效</li></ul></li><li><p>串行队列（Serial Dispatch Queue）</p><ul><li>让任务一个接着一个执行（一个任务执行完毕后，在执行下一个任务）</li></ul></li></ul><h3 id="GCD的队列组"><a href="#GCD的队列组" class="headerlink" title="GCD的队列组"></a>GCD的队列组</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建队列组</span></span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;my_queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加异步任务</span></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;任务1-%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;任务2-%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等前面的任务执行完毕后，会自动执行这个任务</span></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;任务3-%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="多线程的安全隐患"><a href="#多线程的安全隐患" class="headerlink" title="多线程的安全隐患"></a>多线程的安全隐患</h2><ul><li>资源共享<ul><li>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源</li><li>比如多个线程访问同一个对象，同一个变量，同一个文件</li></ul></li><li>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题</li></ul><p>解决方案：使用线程同步技术（同步，就是协同步调，按预定的先后持续进行）</p><ul><li>常见的线程同步技术是：加锁，常见线程同步方案如下<ul><li>OSSpinLock</li><li>os_unfair_lock</li><li>pthread_mutex</li><li>dispatch_semaphore</li><li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSRecursiveLock</li><li>NSCondition</li><li>NSConditionLock</li><li>@synchronized</li></ul></li></ul><h3 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h3><p>线程同步的最直接的方案就是串行队列，让多条线程按顺序执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> queue = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;queue&quot;</span>,DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue,^&#123;</span><br><span class="line">    xxxx</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue,^&#123;</span><br><span class="line">    xxxx</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><blockquote><p>这个锁在iOS 10之后被废弃了</p></blockquote><p>自旋锁，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源</p><blockquote><p>忙等：一边等待一边忙着做事情，相当于while(1){xxx}。自旋：自己一直在那里旋转</p></blockquote><blockquote><p>需要导入头文件<code>&lt;libkern/OSAtomic.h&gt;</code></p></blockquote><p>初始化</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">OSSpinLock lock</span> = OS_SPINLOCK_INIT;</span><br></pre></td></tr></table></figure><p>加锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">OSSpinLockLock(&amp;<span class="params">_lock</span>)</span>;</span><br></pre></td></tr></table></figure><p>尝试加锁：如果需要等待就返回false，不加锁；如果不需要等待就返回true，加锁。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Bool</span> <span class="variable"><span class="class">result</span></span> = <span class="function"><span class="title">OSSpinLockTry</span>(&amp;<span class="variable">_lock</span>)</span></span><br></pre></td></tr></table></figure><p>解锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">OSSpinLockUnlock(&amp;<span class="params">_lock</span>)</span>;</span><br></pre></td></tr></table></figure><p>自旋锁现在已经不再安全，可能会出现优先级反转问题</p><p>如果等待锁的优先级线程较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁</p><h3 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h3><ul><li><code>os_unfair_lock</code>用于取代不安全的<code>OSSpinLock</code>，从iOS10开始才支持</li><li>从底层调用看，等待<code>os_unfair_lock</code>锁的线程会处于休眠状态，并非忙等</li><li>需要导入头文件<code>&lt;os/lock.h&gt;</code></li></ul><p>初始化</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">os_unfair_lock lock</span> = OS_UNFAIR_LOCK_INIT;</span><br></pre></td></tr></table></figure><p>加锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os_unfair_lock_lock(&amp;lock);</span><br></pre></td></tr></table></figure><p>解锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os_unfair_lock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure><h3 id="phread-mutex"><a href="#phread-mutex" class="headerlink" title="phread_mutex"></a>phread_mutex</h3><ul><li><code>mutex</code>叫做互斥锁，等待锁的线程会处于休眠状态</li><li>需要导入头文件<code>&lt;pthread.h&gt;</code></li></ul><p>初始化方法1</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pthread_mutex_t mutex</span> = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><p>初始化方法2</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread<span class="constructor">_mutexattr_init(&amp;<span class="params">attr</span>)</span>;</span><br><span class="line">pthread<span class="constructor">_mutexattr_settype(&amp;<span class="params">attr</span>, PTHREAD_MUTEX_DEFAULT)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这里的第二个参数如果传NULL的话表示使用默认属性</span></span><br><span class="line">pthread<span class="constructor">_mutex_init(&amp;<span class="params">_mutex</span>, &amp;<span class="params">attr</span>)</span>;</span><br><span class="line"></span><br><span class="line">pthread<span class="constructor">_mutexattr_destory(&amp;<span class="params">attr</span>)</span>;</span><br></pre></td></tr></table></figure><p>尝试加锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_mutex_trylock(&amp;<span class="params">mutex</span>)</span>;</span><br></pre></td></tr></table></figure><p>加锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_mutex_lock(&amp;<span class="params">mutex</span>)</span>;</span><br></pre></td></tr></table></figure><p>解锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_mutex_unlock(&amp;<span class="params">mutex</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h4><p>锁的属性可以改为递归锁，即允许<strong>同一个线程</strong>对一把锁进行重复加锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_mutexattr_settype(&amp;<span class="params">attr</span>, PTHREAD_MUTEX_RECURSIVE)</span>;</span><br></pre></td></tr></table></figure><h4 id="条件锁"><a href="#条件锁" class="headerlink" title="条件锁"></a>条件锁</h4><p>初始化条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_t <span class="keyword">condition</span>;</span><br><span class="line">pthread_cond_init(<span class="operator">&amp;</span><span class="keyword">condition</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><p>等待条件（进入休眠，放开mutex锁；被唤醒后，会再次对mutex加锁）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_cond_wait(&amp;<span class="params">condition</span>, &amp;<span class="params">mutex</span>)</span>;</span><br></pre></td></tr></table></figure><p>激活<strong>一个</strong>等待该条件的线程（如果这时候有多个在等待，那么也只会激活最先等待的那个）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_cond_signal(&amp;<span class="params">condition</span>)</span>;</span><br></pre></td></tr></table></figure><p>激活所有等待该条件的线程</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_cond_brodcast(&amp;<span class="params">condition</span>)</span>;</span><br></pre></td></tr></table></figure><p>销毁资源</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_mutex_destory(&amp;<span class="params">mutex</span>)</span>;</span><br><span class="line">pthread<span class="constructor">_cond_destory(&amp;<span class="params">condition</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h3><ul><li><code>NSLock</code>是对<code>mutex</code>普通锁的封装，即<code>pthread_mutex_init(&amp;_mutex, NULL);</code></li></ul><p>初始化</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLock</span> *lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br></pre></td></tr></table></figure><p>加锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)lock;</span><br></pre></td></tr></table></figure><p>尝试加锁(调用的瞬间立马去判断当前能不能加锁，能加就加，然后返回YES，然后继续往下走，如果不能加就返回NO，然后继续往下走)</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)tryLock;</span><br></pre></td></tr></table></figure><p>等待锁（调用的时候先阻塞，如果现在能加锁，就返回YES，加锁成功，继续往下走；如果不能加锁，就阻塞，如果在limit之前，锁被放开了，那么就加锁，返回YES，代码继续往下走；如果直到limit到了，锁还没被放开，那么就返回NO，加锁失败，代码继续往下走）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br></pre></td></tr></table></figure><p>解锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)unlock;</span><br></pre></td></tr></table></figure><h3 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a>NSRecursiveLock</h3><ul><li><code>NSRecurseiveLock</code>也是对<code>mutex</code>递归锁的封装，API跟<code>NSLock</code>基本一致</li></ul><h3 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h3><ul><li><code>NSCondition</code>也是对<code>mutex</code>和<code>cont</code>的封装</li></ul><p>等待锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)wait;</span><br><span class="line">- (<span class="keyword">void</span>)waitUtilDate:(<span class="built_in">NSDate</span> *)limit;</span><br></pre></td></tr></table></figure><p>激活锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)signal; <span class="comment">// 激活单个</span></span><br><span class="line">- (<span class="keyword">void</span>)boardcast; <span class="comment">// 激活多个</span></span><br></pre></td></tr></table></figure><h3 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h3><ul><li><code>NSConditionLock</code>是对<code>NSCondition</code>的进一步封装，可以设置具体的条件值</li></ul><p>初始化设定一个条件值，如果直接<code>init</code>的话那么默认值是0</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instance<span class="keyword">type</span>)initWithCondition:(<span class="type">NSInteger</span>)condition;</span><br></pre></td></tr></table></figure><p>加锁并且设定条件值为<code>condition</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLockWhenCondition:(<span class="built_in">NSInteger</span>)condition; <span class="comment">// 尝试加锁</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition beforeDate:(<span class="built_in">NSDate</span> *)limit; <span class="comment">// 在指定时间到达之前等待条件成立加锁</span></span><br></pre></td></tr></table></figure><p>如果直接使用<code>lock</code>方法，那么会无视条件值，直接加锁或者等待加锁</p><p>解当前的锁并且设置条件值为<code>condition</code>，如果这时候有条件值为<code>condition</code>的锁在加着，那么就会释放</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)unlockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br></pre></td></tr></table></figure><p>如果直接使用<code>unlock</code>方法，那么那些带条件的<code>lockWhenCondition</code>不会解锁</p><h3 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h3><ul><li><code>semaphore</code>叫做信号量</li><li>信号量的初始值，可以用来控制线程并发访问的最大数量</li></ul><p>初始化，传入一个允许的最大并发线程数<code>count</code></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dispatch_sempathore semaphore</span> = dispatch_semaphore_create(count);</span><br></pre></td></tr></table></figure><p>如果信号量的值&lt;=0，当前线程就会进入休眠等待（直到信号量的值&gt;0）<br>如果信号量的值&gt;0，就减1，然后往下执行后面的代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch<span class="constructor">_semaphore_wait(<span class="params">semaphore</span>, DISPATCH_TIME_FOREVER)</span>;</span><br></pre></td></tr></table></figure><p>让信号量的值加1</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch<span class="constructor">_semaphore_signal(<span class="params">semaphore</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><ul><li><code>@synchronized</code>是对<code>mutex</code>递归锁的封装</li></ul><p>传入对象即可，用于标记是不是同个锁，一个对象标记一把锁 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@synchronized(xxx)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程同步方案性能比较"><a href="#线程同步方案性能比较" class="headerlink" title="线程同步方案性能比较"></a>线程同步方案性能比较</h3><ul><li>性能从高到低排序<ul><li>os_unfair_lock</li><li>OSSpinLock</li><li>dispatch_semaphore</li><li>pthread_mutex</li><li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSCondition</li><li>pthread_mutex(recursive)</li><li>NSRecursiveLock</li><li>NSConditionLock</li><li>@synchronized</li></ul></li></ul><h2 id="自旋锁、互斥锁比较"><a href="#自旋锁、互斥锁比较" class="headerlink" title="自旋锁、互斥锁比较"></a>自旋锁、互斥锁比较</h2><blockquote><p>iOS10之后已经不推荐使用自旋锁了</p></blockquote><ul><li>什么情况使用自旋锁比较划算？<ul><li>预计线程等待锁的时间很短</li><li>加锁的代码（临界区）经常被调用，但竞争情况很少发生</li><li>CPU资源不紧张</li><li>多核处理器</li></ul></li><li>什么情况使用互斥锁比较划算？<ul><li>预计线程等待锁的时间较长</li><li>单核处理器</li><li>临界区有IO操作（因为比较占用CPU资源）</li><li>临界区代码复杂或者循环量大</li></ul></li></ul><h2 id="读写安全"><a href="#读写安全" class="headerlink" title="读写安全"></a>读写安全</h2><h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h3><p><code>nonatomic</code>和<code>atomic</code> ：给属性加上<code>atomic</code>修饰，可以保证属性的<code>setter</code>和<code>getter</code>都是原子性操作，也就是保证<code>setter</code>和<code>getter</code>内部是线程同步的</p><p>参照runtime源码中 <code>objc-accessors.mm</code>的<code>objc_getProperty</code>和<code>reallySetProperty</code>方法，分别是get方法和set方法的内部实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_getProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, ptrdiff_t offset, <span class="built_in">BOOL</span> atomic) &#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retain release world</span></span><br><span class="line">    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);</span><br><span class="line">    <span class="keyword">if</span> (!atomic) <span class="keyword">return</span> *slot;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是atomic的时候，会加上锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Atomic retain release world</span></span><br><span class="line">    spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();</span><br><span class="line">    <span class="keyword">id</span> value = objc_retain(*slot);</span><br><span class="line">    slotlock.unlock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span></span><br><span class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> reallySetProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> newValue, ptrdiff_t offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> <span class="keyword">copy</span>, <span class="keyword">bool</span> mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        object_setClass(<span class="keyword">self</span>, newValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> oldValue;</span><br><span class="line">    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">copy</span>) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/// 这里可以看出如果是atomic的时候，是会加上锁的</span></span><br><span class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>atmoic</code>是不能保证使用属性的过程中是线程安全的，即虽然他的setter和getter是线程安全的，但是用这个属性去调用其他方法的时候依旧不一定属性安全，比如<code>[self.array addObject:xxx]</code>，这里只能保证取出array属性的时候线程安全，但是添加对象进去的时候就有可能出现线程同步问题</p><h3 id="读写安全方案"><a href="#读写安全方案" class="headerlink" title="读写安全方案"></a>读写安全方案</h3><h4 id="多读单写"><a href="#多读单写" class="headerlink" title="多读单写"></a>多读单写</h4><p>需求</p><ul><li>同一时间，只能有1条线程进行写的操作</li><li>同一时间，允许有多条线程进行读的操作</li><li>同一时间，不允许既有写的操作，又有读的操作</li></ul><p>解决方案</p><ul><li>pthread_rwlock：读写锁</li><li>dispatch_barrier_async：异步栅栏调用</li></ul><h4 id="pthread-rwlock"><a href="#pthread-rwlock" class="headerlink" title="pthread_rwlock"></a>pthread_rwlock</h4><ul><li>等待锁的线程会进入休眠</li><li>需要引入头文件&lt;pthread.h&gt;</li></ul><p>初始化锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_t lock;</span><br><span class="line">pthread_rwlock_init(&amp;lock,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>读-加锁/尝试加锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_rdlock(&amp;lock);</span><br><span class="line">pthread_rwlock_tryrdlock(&amp;lock);</span><br></pre></td></tr></table></figure><p>写-加锁/尝试加锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_wrlock(&amp;lock);</span><br><span class="line">pthread_rwlock_trywrlock(&amp;lock);</span><br></pre></td></tr></table></figure><p>解锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure><p>销毁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_destory(&amp;lock);</span><br></pre></td></tr></table></figure><h4 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h4><ul><li>这个函数传入的并发队列必须是自己通过<code>dispatch_queue_create</code>创建的</li><li>如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于<code>dispatch_async</code>函数的效果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化队列</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;rw_queue&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 读</span><br><span class="line">dispatch_async(queue,^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写</span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>子线程中，<code>performSelector:withObject:afterDelay:</code>不起作用的原因 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> afterDelay:<span class="number">.0</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;3&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>performSelector:withObject:afterDelay:</code> 的本质是往Runloop中添加定时器</li><li>子线程中默认没有启动<code>Runloop</code></li><li>补充代码启动Runloop即可  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSRunloop</span> currentRunloop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunloopMode</span>];</span><br><span class="line">[[<span class="built_in">NSRunloop</span> currentRunloop] runMode:<span class="built_in">NSDefaultRunloopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFeature]];</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要简述iOS中多线程的使用及其原理&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Swift 5.5 async与 await</title>
    <link href="https://www.arclin.cn/post/75996dec.html"/>
    <id>https://www.arclin.cn/post/75996dec.html</id>
    <published>2021-08-23T14:55:00.000Z</published>
    <updated>2022-07-12T16:51:57.239Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述Swift 5.5新特性 async与await的常用方式</p><span id="more"></span><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>首先我们来做一个简单的下载图片的任务</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Download</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">image</span>(<span class="params">url</span>: <span class="type">URL</span>, <span class="params">completeHandler</span>: <span class="keyword">@escaping</span> (<span class="type">UIImage</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> task <span class="operator">=</span> <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error &#123;</span><br><span class="line">                <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                    completeHandler(<span class="literal">nil</span>,error)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> data <span class="operator">=</span> data, <span class="keyword">let</span> httpResponse <span class="operator">=</span> response <span class="keyword">as?</span> <span class="type">HTTPURLResponse</span>, httpResponse.statusCode <span class="operator">==</span> <span class="number">200</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">UIImage</span>(data: data)</span><br><span class="line">                <span class="keyword">if</span> image <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                        completeHandler(image, <span class="literal">nil</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                        completeHandler(<span class="literal">nil</span>, <span class="type">NSError</span>(domain: <span class="string">&quot;org.swift&quot;</span>, code: <span class="operator">-</span><span class="number">2</span>))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                    completeHandler(<span class="literal">nil</span>, <span class="type">NSError</span>(domain: <span class="string">&quot;org.swift&quot;</span>, code: <span class="operator">-</span><span class="number">1</span>))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        task.resume()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这个简单的任务里面涉及到了block嵌套，子线程与主线程的切换等等上下文切换的逻辑。</p><p>代码首先会执行第一行，然后就直接执行最后一行，再回到第二行执行，然后还得判断各种异常状态，最后才回到主线程刷新。可以发现这里面最深的嵌套达到了4层，而且上下文的切换也不利于代码阅读。可想而知要是逻辑稍微再多一点，就远远不止这种复杂度了。</p><h2 id="用-async-和-await-来拯救一下"><a href="#用-async-和-await-来拯救一下" class="headerlink" title="用 async 和 await 来拯救一下"></a>用 async 和 await 来拯救一下</h2><p>改造完之后，代码如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">image</span>(<span class="params">url</span>: <span class="type">URL</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> (data, response) <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">URLSession</span>.shared.data(from: url)</span><br><span class="line">    <span class="keyword">guard</span> (response <span class="keyword">as?</span> <span class="type">HTTPURLResponse</span>)<span class="operator">?</span>.statusCode <span class="operator">==</span> <span class="number">200</span> <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="string">&quot;org,swift&quot;</span>, code: <span class="operator">-</span><span class="number">1</span>) &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> maybeImage <span class="operator">=</span> <span class="type">UIImage</span>(data: data) <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="string">&quot;org,swift&quot;</span>, code: <span class="operator">-</span><span class="number">1</span>) &#125;</span><br><span class="line">    <span class="keyword">return</span> maybeImage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式如下（如果需要捕获异常的话就需要加上<code>do-catch</code>）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> <span class="keyword">self</span>.imageView.image <span class="operator">=</span> <span class="keyword">await</span> <span class="type">AsyncTest</span>.image(url: <span class="type">URL</span>(string: <span class="string">&quot;https://images.xiaozhuanlan.com/photo/2021/fb4d1bcda193cdfb5ccc380d1a008fe1.png&quot;</span>)<span class="operator">!</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们的代码精简了许多，嵌套最深也就是判断到异常的时候抛出的1层，接下来我们来逐行讲解一下</p><h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><p>首先<code>URLSession.shared.data(from: url) </code>是iOS 15 新出的方法，用于发起网络请求，方法定义如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Convenience method to load data using an URL, creates and resumes an URLSessionDataTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter url: The URL for which to load data.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Data and response.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">data</span>(<span class="params">from</span> <span class="params">url</span>: <span class="type">URL</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">Data</span>, <span class="type">URLResponse</span>)</span><br></pre></td></tr></table></figure><p>其中 <code>async</code> 表示这是一个异步方法，如同我们前面定义的方法一样<code>static func image(url: URL) async throws -&gt; UIImage</code>，同样也有<code>async</code>这个关键字，只要方法里面有<code>await</code>关键字，那么方法名就得带上<code>async</code>关键字。带有<code>async</code>的方法就意味着需要使用<code>await</code>去调用，然后其返回值可以直接赋值给某个变量。举例如下:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getName</span>()</span> <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line"><span class="comment">/// 发起网络请求获取名字，这时候线程会卡住，直到请求完成了，就会把这个请求方法的返回值直接赋值给name，然后就会继续往下执行，把拿到的name给返回出去</span></span><br><span class="line"><span class="keyword">let</span> name <span class="operator">=</span> <span class="keyword">await</span> requestName()</span><br><span class="line"><span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 同理，当代码执行到这里的时候，调用异步方法，线程会卡住，然后方法里面去调用网络请求获取名字，然后等待网络请求返回之后，name就会被赋上值</span></span><br><span class="line"><span class="keyword">let</span> name <span class="operator">=</span> <span class="keyword">await</span> getName()</span><br></pre></td></tr></table></figure><p>以上面的<code>URLSession</code>的<code>data(from:delegate:)</code>方法为例，返回的是一个元组，所以就是</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (data, response) <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">URLSession</span>.shared.data(from: url)</span><br></pre></td></tr></table></figure><p>表示请求后，<code>data</code>和<code>response</code>变量都会被赋上值，分别是<code>Data</code>类型和<code>URLResponse</code>类型</p><p>另外我们注意到，和通过block方式返回请求结果不同，这个新方法返回的元组中的<code>data</code>和<code>response</code>都不是可选类型，而是确切有值的，如果发生网络异常则会通过<code>throw</code>抛出异常，这样子的设计能够让我们节省加下来针对空值的判断，可以放心地使用返回值</p><blockquote><p>当然，不仅仅是网络请求可以用<code>await</code>，任意的异步行为（比如读取本地文件）都可以使用<code>await</code></p></blockquote><p>目前在iOS 15 SDK的<code>URLSession</code>中，不仅仅提供了上述请求数据，返回元组的方法，还提供了其他上传，下载的方法，可供异步调用，这里简单列举一下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter request: The URLRequest for which to upload data.</span></span><br><span class="line"><span class="comment">/// - Parameter fileURL: File to upload.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Data and response.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">upload</span>(<span class="params">for</span> <span class="params">request</span>: <span class="type">URLRequest</span>, <span class="params">fromFile</span> <span class="params">fileURL</span>: <span class="type">URL</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">Data</span>, <span class="type">URLResponse</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter request: The URLRequest for which to upload data.</span></span><br><span class="line"><span class="comment">/// - Parameter bodyData: Data to upload.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Data and response.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">upload</span>(<span class="params">for</span> <span class="params">request</span>: <span class="type">URLRequest</span>, <span class="params">from</span> <span class="params">bodyData</span>: <span class="type">Data</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">Data</span>, <span class="type">URLResponse</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Convenience method to download using an URLRequest, creates and resumes an URLSessionDownloadTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter request: The URLRequest for which to download.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Downloaded file URL and response. The file will not be removed automatically.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">download</span>(<span class="params">for</span> <span class="params">request</span>: <span class="type">URLRequest</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">URL</span>, <span class="type">URLResponse</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Convenience method to download using an URL, creates and resumes an URLSessionDownloadTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter url: The URL for which to download.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Downloaded file URL and response. The file will not be removed automatically.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">download</span>(<span class="params">from</span> <span class="params">url</span>: <span class="type">URL</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">URL</span>, <span class="type">URLResponse</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Convenience method to resume download, creates and resumes an URLSessionDownloadTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter resumeData: Resume data from an incomplete download.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Downloaded file URL and response. The file will not be removed automatically.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">download</span>(<span class="params">resumeFrom</span> <span class="params">resumeData</span>: <span class="type">Data</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">URL</span>, <span class="type">URLResponse</span>)</span><br></pre></td></tr></table></figure><h3 id="容错-amp-转码"><a href="#容错-amp-转码" class="headerlink" title="容错 &amp; 转码"></a>容错 &amp; 转码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> (response <span class="keyword">as?</span> <span class="type">HTTPURLResponse</span>)<span class="operator">?</span>.statusCode <span class="operator">==</span> <span class="number">200</span> <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="string">&quot;org,swift&quot;</span>, code: <span class="operator">-</span><span class="number">1</span>) &#125;</span><br></pre></td></tr></table></figure><p>这一行用来处理响应体的异常情况，当<code>statusCode</code> 为 200的判断不成立时，就会抛出异常，则外部需要通过<code>do-catch</code>去捕获</p><p>如果判断成立时，则程序继续往下走</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> maybeImage <span class="operator">=</span> <span class="type">UIImage</span>(data: data) <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="string">&quot;org,swift&quot;</span>, code: <span class="operator">-</span><span class="number">1</span>) &#125;</span><br></pre></td></tr></table></figure><p>这里将<code>data</code>转成了<code>UIImage</code>，由于该方法返回的是一个可选值，所以这里同样需要通过<code>guard</code>去判断转换失败的情况</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> maybeImage</span><br></pre></td></tr></table></figure><p>最后得到了确切的结果之后，我们就可以将转好的图片给发送出去了，并且外面使用这个返回值的时候也不用判空，可以放心地确定返回的图片是有值的。</p><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>当我们的方法被标记为<code>async</code>的时候，我们就需要加上<code>await</code>进行调用，并且调用的环境是需要在异步环境内的，即如下所示</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> &#123;</span><br><span class="line"><span class="keyword">try</span> <span class="keyword">let</span> image <span class="operator">=</span> <span class="keyword">await</span> <span class="type">AsyncTest</span>.image(url: xxxx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Xcode 13.0 bata 4 中这个<code>async &#123;&#125; </code>环境的建立代码被提示即将被废弃，所以改成了如下所示</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span>(priority: .userInitiated) &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">let</span> image <span class="operator">=</span> <span class="keyword">await</span> <span class="type">AsyncTest</span>.image(url: xxxx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>userInitiated</code>表示线程优先级为<code>用户发起</code>，当然<code>priority</code>参数也可以不填，默认优先级是<code>Task.currentPriority</code>，返回值默认是<code>default</code></p><p>目前有六种优先级，这里从高到低进行排列如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 优先级最高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> high: <span class="type">TaskPriority</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 等同于default</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> medium: <span class="type">TaskPriority</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> low: <span class="type">TaskPriority</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> userInitiated: <span class="type">TaskPriority</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> utility: <span class="type">TaskPriority</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 优先级最低</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> background: <span class="type">TaskPriority</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当你标记一个函数为<code>async</code>时，即表示该函数可以被挂起。在<code>async</code>函数内部，使用<code>await</code>关键词标记在哪里可以一次或多次挂起。当<code>async</code>函数挂起时，线程并未阻塞，系统会自由安排其他任务。有时后启动的任务，可能先被执行。即你的程序状态可能在挂起时发生显著变化。当<code>async</code>函数恢复执行时，其返回的结果会自然融入到<code>async</code>函数的调用者，并在先前挂起的地方接续执行。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><code>await</code>关键字表示该异步（async）函数可能会被挂起，而不是畅通无阻地继续执行下去，甚至从挂起恢复回来时，函数可能已经跑到了另一个线程上去了，为了解决这个问题，我们可以用Swift的<code>actor</code>保护可变状态，这个我们后面再讲</p><h2 id="Async序列"><a href="#Async序列" class="headerlink" title="Async序列"></a>Async序列</h2><p>Async序列顾名思义就是异步的序列，比如读取一个很大的文件，我们希望一边下载一边展示读取的内容，这时候我们可以通过使用<code>for await-in</code> 来遍历一个异步的序列，如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">eatchquakes</span>()</span> <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> endpointURL <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.csv&quot;</span>)<span class="operator">!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过首行 因为是header描述不是地震数据</span></span><br><span class="line">    <span class="comment">// 接着遍历提取强度、时间、经纬度信息</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">try</span> <span class="keyword">await</span> event <span class="keyword">in</span> endpointURL.lines.dropFirst() &#123;</span><br><span class="line">        <span class="keyword">let</span> values <span class="operator">=</span> event.split(separator: <span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> time <span class="operator">=</span> values[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> latitude <span class="operator">=</span> values[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">let</span> longtitude <span class="operator">=</span> values[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">let</span> magnitude <span class="operator">=</span> values[<span class="number">4</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Magnitude <span class="subst">\(magnitude)</span> on <span class="subst">\(time)</span> at <span class="subst">\(latitude)</span> <span class="subst">\(longtitude)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，异步序列就是对随着时间推移如何产生值或对象的一种描述方式。由于值的产生是异步的，所以可能会在读取的过程中出现异常，当异常发生的时候，遍历终止，并抛出异常。</p><p>其中，<code>lines</code>方法是iOS 15 新增的一个<code>URL</code>的拓展属性，同时还有<code>resourceBytes</code>属性，完整定义如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">AsyncBytes</span> : <span class="title">AsyncSequence</span>, <span class="title">AsyncIteratorProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">AsyncIterator</span> <span class="operator">=</span> <span class="type">URL</span>.<span class="type">AsyncBytes</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Element</span> <span class="operator">=</span> <span class="type">UInt8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/// Asynchronously advances to the next element and returns it, or ends the</span></span><br><span class="line">        <span class="comment">/// sequence if there is no next element.</span></span><br><span class="line">        <span class="comment">/// </span></span><br><span class="line">        <span class="comment">/// - Returns: The next element, if it exists, or `nil` to signal the end of</span></span><br><span class="line">        <span class="comment">///   the sequence.</span></span><br><span class="line">        <span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span>()</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">UInt8</span>?</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// Creates the asynchronous iterator that produces elements of this</span></span><br><span class="line">        <span class="comment">/// asynchronous sequence.</span></span><br><span class="line">        <span class="comment">///</span></span><br><span class="line">        <span class="comment">/// - Returns: An instance of the `AsyncIterator` type used to produce</span></span><br><span class="line">        <span class="comment">/// elements of the asynchronous sequence.</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">makeAsyncIterator</span>()</span> -&gt; <span class="type">URL</span>.<span class="type">AsyncBytes</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> resourceBytes: <span class="type">URL</span>.<span class="type">AsyncBytes</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> lines: <span class="type">AsyncLineSequence</span>&lt;<span class="type">URL</span>.<span class="type">AsyncBytes</span>&gt; &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>因为异步序列的遍历是一个耗时操作，所以我们也可以在需要的时候中断遍历（取消请求）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span>(priority: .userInitiated) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">AsyncTest</span>.eatchquakes()</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 取消</span></span><br><span class="line">task.cancel()</span><br></pre></td></tr></table></figure><p>除了<code>URL</code>新增的<code>lines</code>方法，iOS 15 还给<code>FileHandle</code>和<code>URLSession</code>添加了异步序列方法，比如<code>FileHandle</code>新增的<code>bytes</code>属性，能提供字节流的异步序列。配合异步序列的扩展能力（把字节流变成<code>lines</code>），我们就可以从文件中异步地获得逐行内容并进行处理了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从FileHandle异步读取bytes</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> bytes: <span class="type">AsyncBytes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">try</span> <span class="keyword">await</span> line <span class="keyword">in</span> <span class="type">FileHandle</span>.standardInput.bytes.lines &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅如此，现在通知也支持异步序列了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步await通知</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">notifications</span>(<span class="params">named</span>: <span class="type">Notification</span>.<span class="type">Name</span>, <span class="params">object</span>: <span class="type">AnyObject</span>)</span> -&gt; notifications</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> center <span class="operator">=</span> <span class="type">NotificationCenter</span>.default</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 返回第一个userInfo的NSStoreUUIDKey值为storeUUID的通知</span></span><br><span class="line"><span class="keyword">let</span> notification <span class="operator">=</span> <span class="keyword">await</span> center.notifications(named: .<span class="type">NSPersistentStoreRemoteChange</span>).first &#123;</span><br><span class="line">    <span class="variable">$0</span>.userInfo[<span class="type">NSStoreUUIDKey</span>] <span class="operator">==</span> storeUUID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将异步回调的闭包方法改造成async方法"><a href="#将异步回调的闭包方法改造成async方法" class="headerlink" title="将异步回调的闭包方法改造成async方法"></a>将异步回调的闭包方法改造成async方法</h2><p>上面提到的都是基于系统提供的<code>async</code>方法，如果要改造我们原有的异步回调block方法，我们可以使用<code>withCheckedContinuation</code>或者<code>withCheckedThrowingContinuation</code>函数，区别在于前者用于确定不会抛出错误的场景，举例如下：</p><ul><li>三秒后返回Hello World</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">getItem</span>(<span class="params">callback</span>: <span class="keyword">@escaping</span> (<span class="type">String</span>)-&gt;(<span class="type">Void</span>))</span> &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">3.0</span>) &#123;</span><br><span class="line">        callback(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造后</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">getItem</span>()</span> <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> withCheckedContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">3.0</span>) &#123;</span><br><span class="line">            continuation.resume(returning: <span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">            <span class="comment">/// 如果需要抛出错误，使用 continuation.resume(throwing: error)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>continuation 有个简单但是重要的原则，resume方法必须在每个路径上执行，有且只有一次。但是不用担心，如果在有的路径上没有执行resume方法，Swift runtime 会发出 warning 警告。</p><p>但如果在某个路径上，resume执行了不止一次，这会是严重得多的问题。Swift runtime 会在第二次 resume 调用处触发 fatal error。</p><p>如果使用的是<code>withTaskCancellationHandler</code>，那么可以在异步操作被取消的时候执行某些行为</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">getItem</span>()</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">await</span> withTaskCancellationHandler &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Cancel&quot;</span>)</span><br><span class="line">    &#125; operation: &#123;</span><br><span class="line">        <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> withCheckedThrowingContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">3.0</span>) &#123;</span><br><span class="line">                continuation.resume(returning: <span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 调用</span></span><br><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> item <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">AsyncTest</span>.getItem()</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error&quot;</span> <span class="operator">+</span> error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 调用取消的时候会打印`Cancel`</span></span><br><span class="line">task.cancel()</span><br></pre></td></tr></table></figure><h2 id="只读属性使用async"><a href="#只读属性使用async" class="headerlink" title="只读属性使用async"></a>只读属性使用async</h2><p>只读属性可以在其<code>get</code>方法中使用<code>async</code>标记是一个异步读取的属性，如下所示</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AsyncTest</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">FileError</span> : <span class="title">Error</span> </span>&#123;</span><br><span class="line">      <span class="keyword">case</span> missing, unreadable</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> content : <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">get</span> <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">          <span class="keyword">guard</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">Bundle</span>.main.url(forResource: <span class="string">&quot;Empty&quot;</span>, withExtension: <span class="string">&quot;md&quot;</span>) <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">FileError</span>.missing &#125;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">String</span>(contentsOf: url)</span><br><span class="line">          &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="type">FileError</span>.unreadable</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">readContent</span>()</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="keyword">self</span>.content</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h2><p>假如我们有多个异步函数，比如<code>切菜</code>、<code>切洋葱</code>、<code>切肉</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cooking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cutVegetable</span>()</span> <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">10_000_000_000</span>) <span class="comment">// 暂停10秒的意思</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;cut vegetable&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cutOnion</span>()</span> <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">5_000_000_000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;cut onion&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cutMeet</span>()</span> <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">5_000_000_000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;cut meet&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们这么调用的话，那么整个过程将是串行的，一共会花费20秒左右</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> step1 <span class="operator">=</span> <span class="keyword">await</span> <span class="type">Cooking</span>.cutVegetable()</span><br><span class="line">    <span class="keyword">let</span> step2 <span class="operator">=</span> <span class="keyword">await</span> <span class="type">Cooking</span>.cutOnion()</span><br><span class="line">    <span class="keyword">let</span> step3 <span class="operator">=</span> <span class="keyword">await</span> <span class="type">Cooking</span>.cutMeet()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>([step1,step2,step3])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是实际三个步骤之间并没有依赖关系，是可以同时进行的，所以我们需要使用结构化并发，让他们并发执行</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cooking</span>()</span> <span class="keyword">async</span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> withTaskGroup(of: <span class="type">String</span>.<span class="keyword">self</span>) &#123; group <span class="keyword">in</span></span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="type">Cooking</span>.cutVegetable()</span><br><span class="line">        &#125;</span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="type">Cooking</span>.cutOnion()</span><br><span class="line">        &#125;</span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="type">Cooking</span>.cutMeet()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> steps : [<span class="type">String</span>] <span class="operator">=</span> []</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">await</span> finishedStep <span class="keyword">in</span> group &#123;</span><br><span class="line">            steps.append(finishedStep)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子只要10秒左右就可以完成任务了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> cooking()</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在执行子任务的过程中发生了异常，那么<code>cooking()</code>方法将会退出，任何尚未完成的子任务都将自动取消。</p><h2 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h2><p>由于我们现在已经多很多异步操作的场景，所以自然我们在设计类的时候，也要注意这个类要是被多个线程同时访问的时候引起的状态变化的问题。</p><p>Swift 5.5引入了Actor，它在概念上类似于在并发环境中可以安全使用的类。Swift 确保在任何给定时间只能由单个线程访问 Actor 内的可变状态，这有助于在编译器级别消除各种严重的错误。</p><p>比如以下代码在单线程情况下是安全的，但是如果是多线程访问的话<code>deck</code>属性会出现资源竞争的问题</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RiskyCollector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> deck: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">deck</span>: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.deck <span class="operator">=</span> deck</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span>(<span class="params">card</span> <span class="params">selected</span>: <span class="type">String</span>, <span class="params">to</span> <span class="params">person</span>: <span class="type">RiskyCollector</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> deck.contains(selected) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">        deck.remove(selected)</span><br><span class="line">        person.transfer(card: selected)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">transfer</span>(<span class="params">card</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        deck.insert(card)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>危险：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = Set<span class="symbol">&lt;String&gt;</span>([<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;11&quot;</span>,<span class="string">&quot;12&quot;</span>])</span><br><span class="line"><span class="keyword">let</span> risky = RiskyCollector(deck:<span class="keyword">set</span>)</span><br><span class="line"><span class="keyword">for</span> i in <span class="number">1</span>...<span class="number">12</span> &#123;</span><br><span class="line">    DispatchQueue.<span class="keyword">global</span>().async &#123;</span><br><span class="line">        _ = risky.send(card: <span class="string">&quot;\(i)&quot;</span>, <span class="keyword">to</span>: risky)</span><br><span class="line">        <span class="keyword">print</span>(risky.deck)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Actor 通过引入 Actor 隔离解决了这个问题：除非异步执行，否则无法从 Actor 对象外部读取属性和方法，并且根本无法从 Actor 对象外部写入属性。 Swift 会自动将这些请求放入一个按顺序处理的队列中，以避免出现多线程竞争。</p><p>我们可以使用Actor重新实现一个SafeCollector，如下:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">actor <span class="type">SafeCollector</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> deck: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line">  <span class="function"><span class="keyword">init</span>(<span class="params">deck</span>: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;)</span> &#123;</span><br><span class="line">      <span class="keyword">self</span>.deck <span class="operator">=</span> deck</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">send</span>(<span class="params">card</span> <span class="params">selected</span>: <span class="type">String</span>, <span class="params">to</span> <span class="params">person</span>: <span class="type">SafeCollector</span>)</span> <span class="keyword">async</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">      <span class="keyword">guard</span> deck.contains(selected) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">      deck.remove(selected)</span><br><span class="line">      <span class="keyword">await</span> person.transfer(card: selected)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">transfer</span>(<span class="params">card</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">      deck.insert(card)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安全：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">String</span>&gt;([<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;11&quot;</span>,<span class="string">&quot;12&quot;</span>])</span><br><span class="line"><span class="keyword">let</span> risky <span class="operator">=</span> <span class="type">SafeCollector</span>(deck:<span class="keyword">set</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">12</span> &#123;</span><br><span class="line">    <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">_</span> <span class="operator">=</span> <span class="keyword">await</span> risky.send(card: <span class="string">&quot;<span class="subst">\(i)</span>&quot;</span>, to: risky)</span><br><span class="line">        <span class="built_in">print</span>(<span class="keyword">await</span> risky.deck)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中有几件事情需要注意：</p><ul><li><p>actor内对外暴露的方法都是异步方法，即使没有标记async，因为它会等到另一个 SafeCollector actor 能够处理请求。</p></li><li><p>actor 可以自由地、异步或以其他方式使用自己的属性和方法，但是当与不同的 actor 交互时，它必须始终异步完成。通过这些特性，Swift 可以确保永远不会同时访问所有与 actor 隔离的状态，更重要的是，这是在编译时完成的，以保证线程安全。</p></li></ul><p>Actor 和 Class 有一些相似之处：</p><ul><li><p>两者都是引用类型，因此它们可用于共享状态。</p></li><li><p>它们可以有方法、属性、初始值设定项和下标。</p></li><li><p>它们可以实现协议。任何静态属性和方法在这两种类型中的行为都相同。</p></li></ul><p>除了 Actor 隔离之外，Actor 和 Class之间还有另外两个重要的区别：</p><ul><li><p>Actor 目前不支持继承，这在未来可能会改变</p></li><li><p>所有 Actor 都隐式遵守一个新的 Actor Protocol</p></li></ul><h3 id="Global-Actor"><a href="#Global-Actor" class="headerlink" title="Global Actor"></a>Global Actor</h3><p>Global Actor 将 actor 隔离的概念扩展到了全局状态，即使状态和函数分散在许多不同的模块中，Global Actor 可以在并发程序中安全地使用全局变量，例如 Swift 提供的 <code>@MainActor</code> 限制属性和方法只能在主线程访问</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MainActor</span> <span class="function"><span class="keyword">func</span> <span class="title">refreshUI</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;updating ui…&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MainActor</span> <span class="keyword">var</span> globalTextSize: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@MainActor</span> <span class="function"><span class="keyword">func</span> <span class="title">increaseTextSize</span>()</span> &#123;</span><br><span class="line">  globalTextSize <span class="operator">+=</span> <span class="number">2</span>   <span class="comment">// okay:</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notOnTheMainActor</span>()</span> <span class="keyword">async</span> &#123;</span><br><span class="line">  globalTextSize <span class="operator">=</span> <span class="number">12</span>  <span class="comment">// error: globalTextSize is isolated to MainActor</span></span><br><span class="line">  increaseTextSize()   <span class="comment">// error: increaseTextSize is isolated to MainActor, cannot call synchronously</span></span><br><span class="line">  <span class="keyword">await</span> increaseTextSize() <span class="comment">// okay: asynchronous call hops over to the main thread and executes there</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要简述Swift 5.5新特性 async与await的常用方式&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="Swift" scheme="https://www.arclin.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 5 Property Wrapper</title>
    <link href="https://www.arclin.cn/post/1bf095f2.html"/>
    <id>https://www.arclin.cn/post/1bf095f2.html</id>
    <published>2021-07-29T16:14:00.000Z</published>
    <updated>2022-07-12T16:51:57.239Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲述Swift5新特性Property Wrapper的使用</p><span id="more"></span><p>Property Wrapper即属性包装器，用于对某个属性进行包装，包装后可以对其做一些约束、限制或者修改</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>举例，比如我们需要添加一个属性包装器用来包装字符串，对字符串长度进行限制，只有当字符串长度在允许范围内，才能被赋值到属性中</p><p>创建一个属性包装器，<code>wrappedValue</code>是必须的，并且需要实现其setter和getter，在里面添加赋值判断逻辑</p><p>我们可以提供两种属性包装器的初始化方法，一种是设置默认字符串长度上下限，一种是设置特定的字符串长度上下限</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value : <span class="type">String</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> minLength : <span class="type">Int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> maxLength : <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> wrappedValue : <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (minLength<span class="operator">...</span>maxLength).contains(newValue.count) &#123;</span><br><span class="line">                value <span class="operator">=</span> newValue</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> minLength <span class="operator">&gt;</span> newValue.count &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;字符串太短了&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;字符串太长了&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 默认5-10个字</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        minLength <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">        maxLength <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">        value <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 设置默认值</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">minLength</span>: <span class="type">Int</span>, <span class="params">maxLength</span>: <span class="type">Int</span>, <span class="params">value</span>: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.maxLength <span class="operator">=</span> maxLength</span><br><span class="line">        <span class="keyword">self</span>.minLength <span class="operator">=</span> minLength</span><br><span class="line">        <span class="keyword">self</span>.value <span class="operator">=</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用属性包装器的方式如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">     <span class="comment">/// 自定义初始化方式</span></span><br><span class="line">    <span class="meta">@StringWrapper</span>(minLength: <span class="number">3</span>, maxLength: <span class="number">5</span>) <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="comment">/// 默认初始化方式</span></span><br><span class="line">    <span class="meta">@StringWrapper</span> <span class="keyword">var</span> title : <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">person.name <span class="operator">=</span> <span class="string">&quot;ARCLIN&quot;</span></span><br><span class="line">person.title <span class="operator">=</span> <span class="string">&quot;Hyper Agent GridMan&quot;</span></span><br><span class="line"><span class="built_in">print</span>(person.name) <span class="comment">/// ARCLIN</span></span><br><span class="line"><span class="built_in">print</span>(person.title) <span class="comment">/// 字符串太长了</span></span><br></pre></td></tr></table></figure><h2 id="从属性包装器中呈现一个值"><a href="#从属性包装器中呈现一个值" class="headerlink" title="从属性包装器中呈现一个值"></a>从属性包装器中呈现一个值</h2><p>属性包装器还提供了另外一个属性，这个属性一般情况下可以用来标记被包装的属性是否被修改过</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringWrapper</span> </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">  <span class="keyword">var</span> projectedValue <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> wrappedValue : <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">get</span> &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">      <span class="keyword">set</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (minLength<span class="operator">...</span>maxLength).contains(newValue.count) &#123;</span><br><span class="line">              value <span class="operator">=</span> newValue</span><br><span class="line">              projectedValue <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> minLength <span class="operator">&gt;</span> newValue.count &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;字符串太短了&quot;</span>)</span><br><span class="line">              projectedValue <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;字符串太长了&quot;</span>)</span><br><span class="line">              projectedValue <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过<code>$</code>符号来调用这个值</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@StringWrapper</span>(minLength: <span class="number">3</span>, maxLength: <span class="number">5</span>) <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">person.name <span class="operator">=</span> <span class="string">&quot;JASON&quot;</span></span><br><span class="line"><span class="built_in">print</span>(person.<span class="variable">$name</span>) <span class="comment">// 打印false，因为这时候长度符合规范</span></span><br><span class="line">person.name <span class="operator">=</span> <span class="string">&quot;HyperJASON&quot;</span></span><br><span class="line"><span class="built_in">print</span>(person.<span class="variable">$name</span>) <span class="comment">// 打印true，因为这时候长度太长了</span></span><br></pre></td></tr></table></figure><p>这个属性也用来可以返回别的东西</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringWrapper</span> </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">  <span class="keyword">var</span> projectedValue : <span class="type">NSAttributedString</span> &#123;</span><br><span class="line">      <span class="comment">/// 构建出一个富文本对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="type">NSAttributedString</span>(string: <span class="string">&quot;--- <span class="subst">\(<span class="keyword">self</span>.value)</span> ---&quot;</span>, attributes: [</span><br><span class="line">          .foregroundColor : <span class="type">UIColor</span>.red,</span><br><span class="line">          .font : <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">15</span>)</span><br><span class="line">      ])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wrappedValue : <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">get</span> &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">      <span class="keyword">set</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (minLength<span class="operator">...</span>maxLength).contains(newValue.count) &#123;</span><br><span class="line">              value <span class="operator">=</span> newValue</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> minLength <span class="operator">&gt;</span> newValue.count &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;字符串太短了&quot;</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;字符串太长了&quot;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@StringWrapper</span>(minLength: <span class="number">3</span>, maxLength: <span class="number">5</span>) <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">person.name <span class="operator">=</span> <span class="string">&quot;JASON&quot;</span></span><br><span class="line"><span class="built_in">print</span>(person.<span class="variable">$name</span>)</span><br><span class="line"><span class="comment">/*  打印出一个富文本对象</span></span><br><span class="line"><span class="comment">--- JASON ---&#123;</span></span><br><span class="line"><span class="comment">    NSColor = &quot;UIExtendedSRGBColorSpace 1 0 0 1&quot;;</span></span><br><span class="line"><span class="comment">    NSFont = &quot;&lt;UICTFont: 0x7fc199f06660&gt; font-family: \&quot;.SFUI-Regular\&quot;; font-weight: normal; font-style: normal; font-size: 15.00pt&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要讲述Swift5新特性Property Wrapper的使用&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="Swift" scheme="https://www.arclin.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 -- Runloop</title>
    <link href="https://www.arclin.cn/post/fee6666f.html"/>
    <id>https://www.arclin.cn/post/fee6666f.html</id>
    <published>2021-07-21T14:10:50.000Z</published>
    <updated>2022-07-12T16:51:57.241Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述iOS中Runloop的一些使用以及原理</p><span id="more"></span><h2 id="Runloop对象"><a href="#Runloop对象" class="headerlink" title="Runloop对象"></a>Runloop对象</h2><ul><li>iOS中有两套API来访问和使用Runloop<ul><li>Foundation : NSRunLoop</li><li>Core Foundation : CFRunloopRef</li></ul></li><li>NSRunloop和CFRunloopRef都代表着Runloop对象</li><li>NSRunloop是基于CFRunloopRef的一层OC包装</li><li>CFRunloopRef是开源的</li></ul><p>获取当前Runloop的两个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop *runloop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">CFRunLoopRef runloopRef &#x3D; CFRunLoopGetCurrent();</span><br></pre></td></tr></table></figure><p>打印runloop可以发现类型是<code>&lt;CFRunLoop 0x600001994300 [0x101405a98]&gt;</code>，跟runloopRef一致，但是打印地址不一样，原因是<code>NSRunLoop</code>是对<code>CFRunLoopRef</code>的封装，<code>CFRunLoopRef</code>是存储在其内部，所以会不一样</p><h2 id="Runloop与线程"><a href="#Runloop与线程" class="headerlink" title="Runloop与线程"></a>Runloop与线程</h2><ul><li><p>每条线程都有唯一的一个与之对应的Runloop对象</p></li><li><p>Runloop保存在一个全局的Dictionary里，线程作为key，Runloop作为Value</p><ul><li>Runloop源码 <code>CFRunloop.c</code>中我们可以找到<code>CFRunLoopGetCurrent()</code>内调用了<code>_CFRunLoopGet0()</code>，在这里面可以看到这行代码得以验证</li></ul>  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef loop = (CFRunLoopRef)<span class="constructor">CFDictionaryGetValue(<span class="params">__CFRunLoops</span>, <span class="params">pthreadPointer</span>(<span class="params">t</span>)</span>);</span><br></pre></td></tr></table></figure></li><li><p>线程刚创建的时候并没有Runloop对象，Runloop会在第一次获取它时创建</p><ul><li>主线程一开始也是没有Runloop的，只是因为在<code>main.m</code>中调用了<code>UIApplicationMain</code>函数，在这里面回去获取Runloop从而创建了Runloop</li><li>对应源码如下</li></ul>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CF_EXPORT</span> <span class="built_in">CFRunLoopRef</span> _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">        loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops,pthreadPointer(t));</span><br><span class="line">        <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">            <span class="built_in">CFDictionarySetValue</span>(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">            loop = newLoop;</span><br><span class="line">        &#125;</span><br><span class="line">         __CFUnlock(&amp;loopsLock);</span><br><span class="line">   <span class="built_in">CFRelease</span>(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Runloop会在线程结束时销毁</p></li><li><p>主线程的Runloop已经自动获取（创建），子线程默认没有开启Runloop</p></li></ul><h2 id="Runloop相关的类"><a href="#Runloop相关的类" class="headerlink" title="Runloop相关的类"></a>Runloop相关的类</h2><p>Core Foundation 中关于Runloop的5个类</p><ul><li>CFRunloopRef</li><li>CFRunloopModeRef</li><li>CFRunloopSourceRef</li><li>CFRunloopTimerRef</li><li>CFRunloopObserverRef</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoop * <span class="built_in">CFRunloopRef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    ...</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems;</span><br><span class="line">    <span class="built_in">CFRunloopModeRef</span> _currentMode;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoopMode *<span class="built_in">CFRunLoopModeRef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0; <span class="comment">// CFRunloopSourceRef数组</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1; <span class="comment">// CFRunloopSourceRef数组</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// CFRunloopObserverRef数组</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers; <span class="comment">// CFRunloopTimerRef数组 </span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码我们可以得知，一个Runloop对象里面有多个mode，存放在<code>_modes</code>成员属性里面。其中有一个mode是<code>_currentMode</code>。 然后每个mode都有<code>name</code>、<code>source0</code>、<code>source1</code>等数组属性</p><ul><li>CFRunloopModeRef 代表Runloop的运行模式</li><li>Runloop启动只能选择其中一个Mode作为currentMode</li><li>如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入<ul><li>不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响</li></ul></li><li>如果Mode里面没有任何Source0/Source1/Timer/Observer，Runloop会立马退出</li></ul><h3 id="CFRunloopModeRef"><a href="#CFRunloopModeRef" class="headerlink" title="CFRunloopModeRef"></a>CFRunloopModeRef</h3><ul><li><p>两种常见的Mode</p><ul><li><code>kCFRunLoopDefaultMode</code>（<code>NSDefaultRunloopMode</code>）: App的默认Mode，通常主线程是在这个Mode下运行</li><li><code>UITrackingRunLoopMode</code>界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响</li></ul></li><li><p>Source0</p><ul><li>触摸事件处理</li><li><code>performSelector:onThread:</code></li></ul></li><li><p>Source1</p><ul><li>基于Port的线程间通信</li><li>系统事件捕捉（捕捉后到Source0去处理）</li></ul></li><li><p>Timers</p><ul><li>NSTimer</li><li><code>performSelector:withObject:afterDelay:</code></li></ul></li><li><p>Observers</p><ul><li>用于监听Runloop的状态</li><li>UI刷新（BeforeWaiting）在Runloop休眠之前会执行一次UI刷新</li><li>Autorelease pool 在Runloop休眠之前自动释放某些内存</li></ul></li></ul><h3 id="CFRunloopObserverRef"><a href="#CFRunloopObserverRef" class="headerlink" title="CFRunloopObserverRef"></a>CFRunloopObserverRef</h3><p>Runloop的几种状态</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>),         <span class="comment">// 即将进入Loop </span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),  <span class="comment">// 即将处理Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>),  <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>),          <span class="comment">// 即将退出Loop</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以自己添加一个监听者来监听Runloop的状态变化</p><ol><li>定义监听回调</li></ol>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> observeRunLoopActivities(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> *info) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopEntry&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeTimers&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeSources&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeWaiting&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopAfterWaiting&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopExit&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建监听者</li></ol>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 创建Observer</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, observeRunLoopActivities, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/// 添加Observer</span></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line"><span class="built_in">CFRelease</span>(observer);</span><br></pre></td></tr></table></figure><h2 id="Runloop的运行逻辑"><a href="#Runloop的运行逻辑" class="headerlink" title="Runloop的运行逻辑"></a>Runloop的运行逻辑</h2><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><ol><li>通知Observers：进入Loop</li><li>通知Observers：即将处理Timers</li><li>通知Observers：即将处理Sources</li><li>处理Blocks（特指执行CFRunLoopPerformBlock内的block参数） <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">CFRunLoopPerformBlock</span>(CFRunLoopGetCurrent(), kCFRunLoopCommonModes, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>处理Source0（可能会再次处理Blocks，因为有可能在处理Source0的时候添加了Blocks）</li><li>如果存在Source1，就跳转到第8步</li><li>通知Observers：开始休眠（等待消息唤醒）</li><li>通知Observers：结束休眠（被某个消息唤醒，被什么东西唤醒就处理什么东西）<ul><li>处理Timer</li><li>处理GCD Async To Main Queue</li><li>处理Source1</li></ul></li><li>处理Blocks</li><li>根据前面的执行结果，决定如何操作（如下几种可能）<ol><li>回到第2步</li><li>退出Loop</li></ol></li><li>通知Observers：退出Loop</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>通过在控制台执行命令<code>bt</code>我们可以看到开始是调用了<code>CFRunLoopRunSpecific</code>函数，核心源码如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SInt32 <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/// 通知Observers：进入Loop</span></span><br><span class="line">__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 具体要做的事情</span></span><br><span class="line">result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 通知Observers：退出Loop</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后查看一下<code>__CFRunLoopRun</code>内的核心处理代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int32_t __CFRunLoopRun(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopModeRef</span> rlm, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle, <span class="built_in">CFRunLoopModeRef</span> previousMode) &#123;</span><br><span class="line">    ...</span><br><span class="line">    int32_t retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 通知Observers：即将处理Timers</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 通知Observers：即将处理Sources</span></span><br><span class="line">         __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 处理Blocks</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 处理Source0</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            <span class="comment">/// 处理Blocks</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0</span>ULL == timeout_context-&gt;termTSR);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 判断有无Source1</span></span><br><span class="line">        <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="comment">/// 如果有Source1，就跳转到handle_msg</span></span><br><span class="line">            <span class="keyword">goto</span> handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 通知Observers：即将休眠</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/// 等待别的消息来唤醒当前线程</span></span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        <span class="comment">/// 通知Observers：结束休眠</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        </span><br><span class="line">    handle_msg:;</span><br><span class="line">        <span class="comment">/// 被Timer唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_TIMER</span>();</span><br><span class="line">            <span class="comment">/// 处理Timers</span></span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer, because we apparently fired early</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">/// 被GCD唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_DISPATCH</span>();</span><br><span class="line">            <span class="comment">/// 处理GCD</span></span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/// 被Source1唤醒</span></span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_SOURCE</span>();</span><br><span class="line">            <span class="comment">/// 处理Source1</span></span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 处理Blocks</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 设置返回值</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行顺序跟我们上面提及的执行流程是相似的，最后的返回值如果是0的话，那么就继续循环，如果是其他值，那么就会退出循环，继而退出Runloop</p><p>上面提及的处理Timers函数，处理GCD函数和处理Source1的函数，都会调用到<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_xxx_FUNCTION__</code>这个函数(这个xxx代表Observer、Block、Source0或者Timer等，见下表)，在这个函数里面，再去执行对应的操作，比如UIKit的界面刷新、Foundation定时器的执行</p><table><thead><tr><th>执行的事情</th><th>调用的函数</th></tr></thead><tbody><tr><td>进入Loop</td><td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</strong></td></tr><tr><td>处理Blocks</td><td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK</strong></td></tr><tr><td>处理Source0</td><td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong></td></tr><tr><td>处理Timer</td><td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong></td></tr><tr><td>处理GCD</td><td><strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong></td></tr><tr><td>处理SOURCE1</td><td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</strong></td></tr></tbody></table><p>GCD只有在回调到主线程的时候才会调用到Runloop的函数，比如下面这种情况 </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>,<span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Runloop休眠的实现原理"><a href="#Runloop休眠的实现原理" class="headerlink" title="Runloop休眠的实现原理"></a>Runloop休眠的实现原理</h3><p>当Runloop需要休眠的时候，会调用用户态的API，然后内部调用mach_msg()切换到内核态，当有消息的时候，就会从内核态切换回用户态的API去处理消息</p><p>用户态 ： mach_msg() -&gt; 内核态： mach_msg() -&gt; 用户态：处理消息</p><p>内核态：</p><ol><li>等待消息</li><li>没有消息就让线程休眠</li><li>有消息就唤醒线程</li></ol><h2 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h2><p>由于NSTimer默认是运行在<code>NSDefaultRunloopMode</code>的，所以在滚动的时候不会执行定时器，因为滚动的时候系统会切换到<code>UITrackingRunLoopMode</code></p><p>这时候我们需要把NSTimer设置到<code>NSRunLoopCommonModes</code>里，如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,++count);</span><br><span class="line">&#125;];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure><p><code>NSDefaultRunloopMode</code>、<code>UITrackingRunLoopMode</code>才是真正存在的模式</p><p><code>NSRunLoopCommonModes</code>并不是一个真的模式，它只是一个标记</p><p>timer能在<code>_commonModes</code>数组中存放的模式下工作</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    ...</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes; <span class="comment">// 存放着NSDefaultRunloopMod，UITrackingRunLoopMode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// 存放着common模式下要处理的对象，比如上面的timer</span></span><br><span class="line">    <span class="built_in">CFRunloopModeRef</span> _currentMode;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes; <span class="comment">// 存放着所有的模式</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="线程保活"><a href="#线程保活" class="headerlink" title="线程保活"></a>线程保活</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>一般情况下，我们创建线程后，当线程的任务执行完了，线程就会销毁，所以有时候我们需要让线程执行完任务后依旧存在，等到我们主动让他销毁他才会销毁。</p><p>首先我们创建一条线程</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>要让这条线程一直活着，我们可以让这个<code>run</code>方法不要结束</p><p>这里添加一个Runloop，由于获取Runloop的时候就会创建Runloop，所以我们获取Runloop即可，然后调用<code>addPort:forMode:</code>方法，添加一个<code>Source0</code></p><p>这样子线程就会卡在<code>[[NSRunLoop currentRunLoop] run];</code>这一行中，不会让方法执行完，线程也就不会销毁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %s begin&quot;</span>,<span class="built_in">NSThread</span>.currentThread,__func__);</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">    <span class="comment">/// 不会走到这里</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %s end&quot;</span>,<span class="built_in">NSThread</span>.currentThread,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后下一步我们需要调用一个方法去销毁这个线程，比如<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>，但是如果我们这么做</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)stop &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 尝试在我们指定的线程上停止这个线程内的Runloop</span></span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(stop) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure><p>发现线程不会销毁，原因是<code>[[NSRunLoop currentRunLoop] run];</code>执行后，会在一个死循环内执行Runloop的<code>runMode:beforeDate:</code>方法，类似于</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode: beforeDate:xxx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CFRunLoopStop(CFRunLoopGetCurrent());</code>只是停止了其中的一次方法调用，进入下个循环后又会开启，所以用这个方法去完全停止Runloop是没用的</p><p>所以我们要使用别的方式去替代<code>[[NSRunLoop currentRunLoop] run];</code>开启线程，因为这个<code>run</code>方法是专门用于开启一个永不销毁的线程。</p><p>只需要改造一下上面那个while方法就好，给self添加一个bool属性</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">BOOL</span> isStop;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %s begin&quot;</span>,<span class="built_in">NSThread</span>.currentThread,__func__);</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    <span class="keyword">while</span>(!<span class="keyword">self</span>.isStop) &#123;</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %s end&quot;</span>,<span class="built_in">NSThread</span>.currentThread,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stop &#123;</span><br><span class="line">    <span class="keyword">self</span>.isStop = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样子我们调用run方法线程就会启动，调用stop方法，while循环就会退出，<code>CFRunLoopStop(CFRunLoopGetCurrent());</code>停止了本次RunLoop，Runloop退出，这样子就能走到打印end那里，线程的方法走完了，线程就可以销毁了</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyThread</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 开启线程</span></span><br><span class="line">- (<span class="keyword">void</span>)run;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 销毁线程</span></span><br><span class="line">- (<span class="keyword">void</span>)stop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 执行任务</span></span><br><span class="line">- (<span class="keyword">void</span>)executeTask:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyThread</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Thread *innerThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span>=isStopped) <span class="built_in">BOOL</span> stopped;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyThread</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        </span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 创建线程 开启Runloop</span></span><br><span class="line">        <span class="keyword">self</span>.innerThread = [[Thread alloc] initWithBlock:^&#123;</span><br><span class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 因为dealloc的时候weakSelf已经空了，所以要明确self存在并且不停止时候，才循环启动Runloop</span></span><br><span class="line">            <span class="keyword">while</span> (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;</span><br><span class="line">                [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 开启线程，启动Runloop</span></span><br><span class="line">    [<span class="keyword">self</span>.innerThread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stop &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 停止线程</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__stop) onThread:<span class="keyword">self</span>.innerThread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)executeTask:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread || !block) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 执行子线程任务</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__executeTask:) onThread:<span class="keyword">self</span>.innerThread withObject:block waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - private method</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__stop &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 标记需要退出Runloop</span></span><br><span class="line">    <span class="keyword">self</span>.stopped = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 退出本次Runloop</span></span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 取消强引用</span></span><br><span class="line">    <span class="keyword">self</span>.innerThread = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__executeTask:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="comment">/// 自动调用停止方法</span></span><br><span class="line">    [<span class="keyword">self</span> stop];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 只是为了监听线程的销毁行为</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Thread</span> : <span class="title">NSThread</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Thread</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲述iOS中Runloop的一些使用以及原理&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Swift 5.4 Result Builder</title>
    <link href="https://www.arclin.cn/post/4bf15bdf.html"/>
    <id>https://www.arclin.cn/post/4bf15bdf.html</id>
    <published>2021-07-18T02:13:00.000Z</published>
    <updated>2022-07-12T16:51:57.239Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲述Swift 5.4的新特性 Result Builder在设计上的一些使用方式</p><span id="more"></span><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>假如我们有一个需求，需要往ScrollView上加入不同类型的View，并且根据不确定的的顺序从上往下进行排列，所以一般情况下我们可以这样子设计框架</p><ol><li>首先定义一个协议，遵循协议的对象使用一个build方法返回一个View</li></ol>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>这里我们设计四种颜色的View，宽度均为屏幕宽度，高度不定</li></ol>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WhiteView</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">UIScreen</span>.main.bounds.width, height: <span class="number">100</span>))</span><br><span class="line">        view.backgroundColor <span class="operator">=</span> .white</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RedView</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> banner <span class="operator">=</span> <span class="type">UIView</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">UIScreen</span>.main.bounds.width, height: <span class="number">200</span>))</span><br><span class="line">        banner.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.red</span><br><span class="line">        <span class="keyword">return</span> banner</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlueView</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> goodsView <span class="operator">=</span> <span class="type">UIView</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">UIScreen</span>.main.bounds.width, height: <span class="number">350</span>))</span><br><span class="line">        goodsView.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.blue</span><br><span class="line">        <span class="keyword">return</span> goodsView</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GreenView</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> dynamicView <span class="operator">=</span> <span class="type">UIView</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">UIScreen</span>.main.bounds.width, height: <span class="number">400</span>))</span><br><span class="line">        dynamicView.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.green</span><br><span class="line">        <span class="keyword">return</span> dynamicView</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>最后我们再定义一个ScrollView的容器，传入一个数组，让其从上到下进行排列</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScrollableContainer</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> contents : [<span class="type">ViewBuilder</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> scrollView <span class="operator">=</span> <span class="type">UIScrollView</span>.<span class="keyword">init</span>(frame: <span class="type">UIScreen</span>.main.bounds)</span><br><span class="line">    <span class="keyword">_</span> <span class="operator">=</span> contents.reduce(<span class="type">CGFloat</span>(<span class="number">0</span>)) &#123; currentY, builder <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> view <span class="operator">=</span> builder.build()</span><br><span class="line">        view.frame.origin.y <span class="operator">=</span> currentY</span><br><span class="line">        scrollView.addSubview(view)</span><br><span class="line">        scrollView.contentSize <span class="operator">=</span> <span class="type">CGSize</span>(width: <span class="type">UIScreen</span>.main.bounds.size.width, height: scrollView.subviews.last<span class="operator">!</span>.frame.maxY)</span><br><span class="line">        <span class="keyword">return</span> currentY <span class="operator">+</span> view.frame.size.height</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scrollView</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样子我们就可以开始布局了</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scrollView <span class="operator">=</span> <span class="type">ScrollableContainer</span>(contents: [</span><br><span class="line">    <span class="type">RedView</span>(),</span><br><span class="line">    <span class="type">BlueView</span>(),</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">])</span><br><span class="line">view.addSubview(scrollView.build())</span><br></pre></td></tr></table></figure><p> 效果如下</p> <img src="https://p6-tt.byteimg.com/origin/pgc-image/8f8201d352eb44a7aab4b0b68ba6e9e2.png" width=50%> </li><li><p>通过这种方式，我们就可以随意调整内部的布局顺序，也可以方便的新增多个View</p></li></ol><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>但是上述方法有一个缺点，就是当如果要重复添加多个相同的View或者说想要通过某个条件再添加View，就会有点复杂，比如当<code>needBlue == true</code>成立的时候再添加<code>BlueView</code>，那么可能需要这么写</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contents <span class="operator">=</span> [</span><br><span class="line">    <span class="type">RedView</span>(),</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> needBlue <span class="operator">==</span> <span class="literal">true</span> &#123;</span><br><span class="line">contents <span class="operator">=</span> [</span><br><span class="line">        <span class="type">RedView</span>(),</span><br><span class="line">        <span class="type">BlueView</span>(),</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scrollView <span class="operator">=</span> <span class="type">ScrollableContainer</span>(contents: contents)</span><br><span class="line">view.addSubview(scrollView.build())</span><br></pre></td></tr></table></figure><p>为了让可读性更加好，我们可以模仿SwiftUI的DSL语法进行设计，这里就需要使用到Swift 5.4的新特性 Result Builder</p><ol><li><p>首先我们要添加一个容器结构体，因为从上到下写的<code>View</code>会被整成一个数组或者多参数传进来，所以要加一个容器把他们从上到下排列好，最后排列完了，再把这个容器放进去ScrollView中</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ViewContainer</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> contents : [<span class="type">ViewBuilder</span>]</span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">         <span class="keyword">let</span> container <span class="operator">=</span> <span class="type">UIView</span>(frame: <span class="type">UIScreen</span>.main.bounds)</span><br><span class="line">         <span class="keyword">_</span> <span class="operator">=</span> contents.reduce(<span class="type">CGFloat</span>(<span class="number">0</span>), &#123; currentY, builder <span class="keyword">in</span></span><br><span class="line">             <span class="keyword">let</span> view <span class="operator">=</span> builder.build()</span><br><span class="line">             view.frame.origin.y <span class="operator">=</span> currentY</span><br><span class="line">             container.addSubview(view)</span><br><span class="line">             container.frame.size <span class="operator">=</span> <span class="type">CGSize</span>(width: <span class="type">UIScreen</span>.main.bounds.size.width, height: container.subviews.last<span class="operator">!</span>.frame.maxY)</span><br><span class="line">             <span class="keyword">return</span> currentY <span class="operator">+</span> view.frame.size.height</span><br><span class="line">         &#125;)</span><br><span class="line">         <span class="keyword">return</span> container</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个Result builder，使用<code>@resultBuilder</code>注解会要求我们添加一个<code>buildBlock</code>方法，实现这个方法，把我们外面传进来的多个View放进去<code>VieContainer</code>容器中，然后实现<code>buildFinalResult</code>在编写结束的时候把<br><code>VieContainer</code>放进去<code>ScrollView</code>容器中</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@resultBuilder</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScrollableViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildBlock</span>(<span class="keyword">_</span> <span class="params">components</span>: <span class="type">ViewBuilder</span>...)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ViewContainer</span>(contents: components)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildFinalResult</span>(<span class="keyword">_</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ScrollableContainer</span>(contents: [component])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这时候我们通过新增的<code>ScrollableViewBuilder</code>来创建一个方法，这里的闭包就是待会我们要写DSL的地方</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">build</span>(<span class="meta">@ScrollableViewBuilder</span> <span class="params">content</span>: () -&gt; <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> content()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个方法传入一个闭包，这个由于我们已经实现了<code>buildBlock</code>，所以<code>content</code>被<code>@ScrollableViewBuilder</code>修饰之后，会自动将闭包内的东西转化成多参数，传入<code>buildBlock</code>方法，在那里面我们把各种各样的<code>View</code>给添加到<code>ViewContainer</code>上，方法调用如下</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> build &#123;</span><br><span class="line">    <span class="type">RedView</span>()</span><br><span class="line">    <span class="type">BlueView</span>()</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">view.addSubview(result.build())</span><br></pre></td></tr></table></figure><p> 这时候运行效果同上图一致</p></li><li><p>接下来我们需要让这个闭包内支持if语句、else if语句、else语句和for语句，</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScrollableViewBuilder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildBlock</span>(<span class="keyword">_</span> <span class="params">components</span>: <span class="type">ViewBuilder</span>...)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">ScrollableContainer</span>(contents: components)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 表示if语句</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildEither</span>(<span class="params">first</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> component</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 表示eles if语句</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildEither</span>(<span class="params">second</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> component</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 表示else语句和其他的可选值（即？修饰的View）</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildOptional</span>(<span class="keyword">_</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>?)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> component <span class="operator">??</span> <span class="type">DefaultView</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后我们试一试这么写</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> build &#123;</span><br><span class="line">    <span class="type">RedView</span>()</span><br><span class="line">    <span class="type">BlueView</span>()</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">    <span class="keyword">if</span> flag <span class="operator">==</span> <span class="number">1</span> &#123;</span><br><span class="line">        <span class="type">RedView</span>()</span><br><span class="line">        <span class="type">RedView</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> flag <span class="operator">==</span> <span class="number">2</span> &#123;</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> flag <span class="operator">==</span> <span class="number">3</span> &#123;</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">BlueView</span>()</span><br><span class="line">        <span class="type">BlueView</span>()</span><br><span class="line">        <span class="type">BlueView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当flag = 1的时候，首先两个<code>RedView()</code>会先进入<code>buildBlock</code>方法，然后被包装成一个<code>ViewContainer</code>，然后再进去<code>buildEither(first component: ViewBuilder)</code>方法，这里我没处理就直接把传进来的值返回出去了</p><p> 当flag = 2 或者 flag = 3 的时候，首先括号内的多个<code>GreenView()</code>会先进入<code>buildBlock</code>方法，然后被包装成一个<code>ViewContainer</code>，然后再进去<code>buildEither(second component: ViewBuilder)</code>方法，这里我没处理就直接把传进来的值返回出去了</p><p> 当 flag 为其他值的时候，首先括号内的多个<code>BlueView()</code>会先进入<code>buildBlock</code>方法，然后被包装成一个<code>ViewContainer</code>，然后再进去<code>buildEither(second component: ViewBuilder)</code>方法。当没有写<code>eles</code>语句的时候，需要实现<code>buildOptional(_ component: ViewBuilder?)</code>方法，去处理没有进入<code>if</code>语句而导致的不返回<code>View</code>的情况，如果没有写<code>else</code>语句，那么不会进入<code>buildBlock</code>，会直接取空值情况下你返回的默认<code>View</code>。</p></li><li><p>处理for语句，比如这样</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> build &#123;</span><br><span class="line">    <span class="type">RedView</span>()</span><br><span class="line">    <span class="type">BlueView</span>()</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">2</span> &#123;</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">        <span class="type">BlueView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>for</code>里面需要返回3个<code>GreenView+BlueView</code>，这里他每次调用for的括号里面的内容，都会走一遍<code>buildBlock</code>把里面的<code>GreenView+BlueView</code>封装成一个<code>ViewContainer</code>，所以这里会产生3个<code>ViewContainer</code>，最后这三个会变成一个数组，进入<code>buildArray</code>方法，再封装成一个<code>ViewContainer</code>，代码如下</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@resultBuilder</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScrollableViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildBlock</span>(<span class="keyword">_</span> <span class="params">components</span>: <span class="type">ViewBuilder</span>...)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ViewContainer</span>(contents: components)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildEither</span>(<span class="params">first</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> component</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildEither</span>(<span class="params">second</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> component</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildOptional</span>(<span class="keyword">_</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>?)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> component <span class="operator">??</span> <span class="type">WhiteView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildArray</span>(<span class="keyword">_</span> <span class="params">components</span>: [<span class="type">ViewBuilder</span>])</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ViewContainer</span>(contents: components)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildFinalResult</span>(<span class="keyword">_</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ScrollableContainer</span>(contents: [component])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理表达式，如果我们要在DSL里面插一些除了<code>View</code>之外的一些东西，那么就需要添加对应的处理方法，比如</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> build &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a123&quot;</span>)</span><br><span class="line">    <span class="type">RedView</span>()</span><br><span class="line">    <span class="type">BlueView</span>()</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 针对这个<code>print</code>我们添加表达式处理</p><p> ScrollableViewBuilder</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 针对正常的表达式，就直接返回</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildExpression</span>(<span class="keyword">_</span> <span class="params">expression</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> expression</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 针对特殊的表达式，返回空View</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildExpression</span>(<span class="keyword">_</span> <span class="params">expression</span>: ())</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">EmptyBuilder</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> EmptyBuilder</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EmptyBuilder</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">UIView</span>.<span class="keyword">init</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里就说的差不多了，其他本文没提及到的内容可以参阅<a href="https://developer.apple.com/videos/play/wwdc2021/10253/">Write a DSL in Swift using result builders</a></p><p>本文<a href="https://github.com/Arc-lin/ResultBuilderDemo">Demo</a>地址</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要讲述Swift 5.4的新特性 Result Builder在设计上的一些使用方式&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="Swift" scheme="https://www.arclin.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 -- Runtime API</title>
    <link href="https://www.arclin.cn/post/11ed4e5e.html"/>
    <id>https://www.arclin.cn/post/11ed4e5e.html</id>
    <published>2021-07-17T15:13:00.000Z</published>
    <updated>2022-07-12T16:51:57.241Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述Runtime的一些常用API</p><span id="more"></span><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>动态创建一个类（参数：父类，类名，额外的内存空间）</p><p><code>Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</code></p><p>注册一个类（要在类注册之前添加成员变量）</p><p><code>void objc_registerClassPair(Class cls) </code></p><p>销毁一个类</p><p><code>void objc_disposeClassPair(Class cls)</code></p><p>获取isa指向的Class</p><p><code>Class object_getClass(id obj)</code></p><p>设置isa指向的Class</p><p><code>Class object_setClass(id obj, Class cls)</code></p><p>判断一个OC对象是否为Class</p><p><code>BOOL object_isClass(id obj)</code></p><p>判断一个Class是否为元类</p><p><code>BOOL class_isMetaClass(Class cls)</code></p><p>获取父类</p><p><code>Class class_getSuperclass(Class cls)</code></p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>获取一个实例变量信息</p><p><code>Ivar class_getInstanceVariable(Class cls, const char *name)</code></p><p>拷贝实例变量列表（最后需要调用free释放）</p><p><code>Ivar *class_copyIvarList(Class cls, unsigned int *outCount)</code></p><p>设置和获取成员变量的值</p><p><code>void object_setIvar(id obj, Ivar ivar, id value)</code></p><p><code>id object_getIvar(id obj, Ivar ivar)</code></p><p>动态添加成员变量（已经注册的类是不能动态添加成员变量的,alignment一般传1，types传成员变量类型，如<code>@encode(int)</code>，<code>@encode(NSObject *)</code>）</p><p><code>BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types)</code></p><p>获取成员变量的相关信息</p><p><code>const char *ivar_getName(Ivar v)</code></p><p><code>const char *ivar_getTypeEncoding(Ivar v)</code></p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>获取一个属性</p><p><code>objc_property_t class_getProperty(Class cls, const char *name)</code></p><p>拷贝属性列表（最后需要调用free释放）</p><p><code>objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</code></p><p>动态添加属性</p><p><code>BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)</code></p><p>动态替换属性</p><p><code>void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)</code></p><p>获取属性的一些信息</p><p><code>const char *property_getName(objc_property_t property)</code></p><p><code>const char *property_getAttributes(objc_property_t property)</code></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>获得一个实例方法、类方法</p><p><code>Method class_getInstanceMethod(Class cls, SEL name)</code></p><p><code>Method class_getClassMethod(Class cls, SEL name)</code></p><p>方法实现相关操作</p><p><code>IMP class_getMethodImplementation(Class cls, SEL name) </code></p><p><code>IMP method_setImplementation(Method m, IMP imp)</code></p><p>方法交换（方法交换之后会清空方法缓存）<br><code>void method_exchangeImplementations(Method m1, Method m2) </code></p><p>拷贝方法列表（最后需要调用free释放）</p><p><code>Method *class_copyMethodList(Class cls, unsigned int *outCount)</code></p><p>动态添加方法</p><p><code>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</code></p><p>动态替换方法（不存在原有方法则动态添加该方法并且返回nil）</p><p><code>IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)</code></p><p>获取方法的相关信息（带有copy的需要调用free去释放）</p><p><code>SEL method_getName(Method m)</code></p><p><code>IMP method_getImplementation(Method m)</code></p><p><code>const char *method_getTypeEncoding(Method m)</code></p><p><code>unsigned int method_getNumberOfArguments(Method m)</code></p><p><code>char *method_copyReturnType(Method m)</code></p><p><code>char *method_copyArgumentType(Method m, unsigned int index)</code></p><p>选择器相关</p><p><code>const char *sel_getName(SEL sel)</code></p><p><code>SEL sel_registerName(const char *str)</code></p><p>用block作为方法实现</p><p><code>IMP imp_implementationWithBlock(id block)</code></p><p><code>id imp_getBlock(IMP anImp)</code></p><p><code>BOOL imp_removeBlock(IMP anImp)</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要简述Runtime的一些常用API&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- 方法、消息发送与super关键字</title>
    <link href="https://www.arclin.cn/post/5ed61a9.html"/>
    <id>https://www.arclin.cn/post/5ed61a9.html</id>
    <published>2021-06-28T17:11:00.000Z</published>
    <updated>2022-07-12T16:51:57.241Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述类（元类）对象里面的方法缓存、消息发送（包括消息发送，动态方法解析与消息转发）与super关键字的底层原理</p><span id="more"></span><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Class对象的结构"><a href="#Class对象的结构" class="headerlink" title="Class对象的结构"></a>Class对象的结构</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache; <span class="comment">// 方法缓存</span></span><br><span class="line">    class_data_bits_t bits; <span class="comment">// 用于获取具体的类信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>bits</code>成员变量与<code>FAST_DATA_MASK</code>进行一次与运算之后，会获得一个其属性可读可写的对象的地址，这个对象长这样</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    <span class="keyword">const</span> clsss_ro_t *ro;</span><br><span class="line">    method_array_t * methods; <span class="comment">// 方法列表</span></span><br><span class="line">    property_array_t *properties; <span class="comment">// 属性列表</span></span><br><span class="line">    protocol_array_t protocols; <span class="comment">// 协议列表</span></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>class_ro_t</code>里面存放的是类的原始信息(不包括分类里面的东西)，是仅可读的，结构如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    unit32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize; <span class="comment">// instance对象占用的内存空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP__64__</span></span><br><span class="line">    uint32_t reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> uint8_t *ivarLayout;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name; <span class="comment">// 类名</span></span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars; <span class="comment">// 成员变量列表</span></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIverLayout;</span><br><span class="line">    property_list_t * baseProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h3><p><code>class_rw_t</code>里面的methods、properties、protocols是二维数组，是可读可写的，比如方法列表随时可以新增<code>method_list_t</code>类型的数据进去。<code>class_rw_t</code>包含了类的初始内容和分类的内容，其中方法列表类似如下结构</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">method_array_t: [</span><br><span class="line">    method_list_t : [</span><br><span class="line">      method_t,</span><br><span class="line">      method_t,</span><br><span class="line">      method_t</span><br><span class="line">    ],</span><br><span class="line">    method_list_t : [</span><br><span class="line">      method_t,</span><br><span class="line">      method_t,</span><br><span class="line">      method_t</span><br><span class="line">    ],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>objc_class</code>内有一个<code>data()</code>函数，其返回值一开始是指向<code>class_ro_t</code>类型的对象的。在合并分类内的内容时，才会产生<code>class_rw_t</code>类型的对象，并指向这个对象。可以参考runtime源码，<code>objc-runtime-new.mm</code>中<code>realizeClassWithoutSwift</code>函数的实现，这里贴出关键部分</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class realizeClassWithoutSwift(Class cls, Class previously)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    auto ro = (<span class="keyword">const</span> class_ro_t *)cls-&gt;data();</span><br><span class="line">    auto isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">        rw = cls-&gt;data();</span><br><span class="line">        ro = cls-&gt;data()-&gt;ro();</span><br><span class="line">        ASSERT(!isMeta);</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">        rw = objc::zalloc&lt;class_rw_t&gt;();</span><br><span class="line">        rw-&gt;set_ro(ro);</span><br><span class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">        cls-&gt;setData(rw);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h3><p><code>class_ro_t</code>里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，所以不能新增内容，包含了类的初始内容，其中方法列表类似如下结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">method_list_t</span> : [</span><br><span class="line">  <span class="keyword">method_t</span>,</span><br><span class="line">  <span class="keyword">method_t</span>,</span><br><span class="line">  <span class="keyword">method_t</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>在runtime源码，<code>objc-runtime-new.mm</code>中的<code>attachCategories</code>方法中我们可以看到分类合并到<code>class_rw_t</code>对象的过程，比如方法的合并如下</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">method_list_t *mlist = entry.cat-&gt;methods<span class="constructor">ForMeta(<span class="params">isMeta</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mcount<span class="operator"> == </span><span class="number">64</span>) &#123;</span><br><span class="line">        prepare<span class="constructor">MethodLists(<span class="params">cls</span>, <span class="params">mlists</span>, <span class="params">mcount</span>, NO, <span class="params">fromBundle</span>, <span class="params">__func__</span>)</span>;</span><br><span class="line">        rwe-&gt;methods.attach<span class="constructor">Lists(<span class="params">mlists</span>, <span class="params">mcount</span>)</span>;</span><br><span class="line">        mcount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mlists<span class="literal">[ATTACH<span class="identifier">_BUFSIZ</span> - <span class="operator">++</span><span class="identifier">mcount</span>]</span> = mlist;</span><br><span class="line">    fromBundle <span class="pattern-match">|= entry.hi-&gt;is<span class="constructor">Bundle()</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><ul><li><code>method_t</code>是对方法/函数的封装（下面是缩减版定义）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function">SEL <span class="title">name</span><span class="params">()</span></span>; <span class="comment">// 函数名</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">types</span><span class="params">()</span></span>; <span class="comment">// 编码（返回值类型、参数类型）</span></span><br><span class="line">    <span class="function">IMP <span class="title">imp</span><span class="params">(<span class="keyword">bool</span> needsLock)</span></span>; <span class="comment">// 指向函数的指针（函数地址）</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>IMP</code>代表具体函数的实现</p><p>  <code>typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</code></p></li><li><p><code>SEL</code>可以代表方法\函数名，一般叫做选择器，底层结构跟<code>char *</code>类似</p><p>  <code>typedef struct objc_selector *SEL</code>;</p><ul><li>可以通过<code>@selector()</code>和<code>sel_registerName()</code>获得</li><li>可以通过<code>sel_getName()</code>和<code>NSStringFromSelector()</code>转成字符串</li><li>不同类中相同名字的方法，所对应的方法选择器是相同的</li></ul></li><li><p><code>types</code>包含了函数返回值、参数编码的字符串，称作<code>Type Encodings</code>（类型编码），具体可以参考<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100">苹果官方文档</a></p><ul><li>比如<code>-（void）test:(int)a;</code>的方法编码为<code>v@:i</code>，v = void,@表示指针变量(因为编译后第一个参数是self)，：表示选择器(因为编译后第二个参数是_cmd)，</li><li>有时类型编码会带上数字，比如<code>v16@0:8</code>，第一个数字表示这个函数的参数一共占用16个字节，第二个数字开始往后的数字都代表偏移值，0代表第一个参数的字节偏移值为0，第三个数字8代表偏移8个字节，也就是第一个参数已经占用了8个字节了，所以第二个参数就从第8个字节开始</li></ul></li></ul><h3 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h3><ul><li>Class内部结构中有个方法缓存（cache_t），用散列表来缓存曾经调用过的方法，可以提高方法的查找速度</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cache_t &#123;</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            explicit_atomic&lt;mask_t&gt;    _maybeMask; <span class="comment">// 散列表的长度 - 1</span></span><br><span class="line">            uint16_t                   _flags;</span><br><span class="line">            uint16_t                   _occupied; <span class="comment">// 已经缓存的方法数量</span></span><br><span class="line">        &#125;;</span><br><span class="line">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;</span><br><span class="line">    &#125;;   </span><br><span class="line">    <span class="keyword">struct</span> bucket_t *buckets() <span class="keyword">const</span>;</span><br><span class="line">    mask_t mask() <span class="keyword">const</span>;</span><br><span class="line">    mask_t occupied() <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，通过<code>buckets()</code>函数我们可以得知<code>_bucketsAndMaybeMask</code>是一个存放<code>bucket_t</code>数组的指针（即<code>_bucketsAndMaybeMask</code>指针指向的是数组的第一个元素），是通过位运算取出来的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> bucket_t *cache_t::buckets() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    uintptr_t addr = _bucketsAndMaybeMask.load(memory_order_relaxed);</span><br><span class="line">    <span class="keyword">return</span> (bucket_t *)(addr &amp; bucketsMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>bucket_t</code>的结构如下</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="class">bucket_t </span>&#123;</span><br><span class="line">    explicit_atomic<span class="params">&lt;uintptr_t&gt;</span> _imp; <span class="comment">// 函数的内存地址</span></span><br><span class="line">    explicit_atomic<span class="params">&lt;SEL&gt;</span> _sel; <span class="comment">// SEL作为key</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过IMP和SEL，我们就可以调用方法了，所以综上所述，一个实例对象调用方法，其类对象从方法缓存里面找方法的大概流程就是</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取sel : class - isa - 偏移<span class="number">16</span>个字节 - <span class="keyword">cache_t </span>- <span class="keyword">buckets() </span>- [<span class="keyword">bucket_t] </span>- 计算出下标index - <span class="keyword">bucket_t </span>- sel()</span><br><span class="line">获取imp : class - isa - 偏移<span class="number">16</span>个字节 - <span class="keyword">cache_t </span>- <span class="keyword">buckets() </span>- [<span class="keyword">bucket_t] </span>- 计算出下标index - <span class="keyword">bucket_t </span>- imp(nil,cls)</span><br></pre></td></tr></table></figure><p>另外<code>_bucketsAndMaybeMask</code>之所以叫这个名字是因为它不仅存放着<code>buckets</code>还存放着<code>maybeMask</code>，在arm64位真机环境下，取高16位，如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mask_t cache_t::mask() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    uintptr_t maskAndBuckets = _bucketsAndMaybeMask.load(memory_order_relaxed);</span><br><span class="line">    <span class="comment">//maskShift 为48,</span></span><br><span class="line">    <span class="keyword">return</span> maskAndBuckets &gt;&gt; maskShift;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法缓存的流程"><a href="#方法缓存的流程" class="headerlink" title="方法缓存的流程"></a>方法缓存的流程</h4><p>先看看runtime源码中，将方法插入缓存的函数（摘抄核心流程）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cache_t::insert(SEL sel, IMP imp, <span class="keyword">id</span> receiver)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//对_occupied赋值 + 1。首次 newOccupied = 1。</span></span><br><span class="line">    mask_t newOccupied = occupied() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//旧容量，（mask + 1） 或者 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> oldCapacity = capacity(), capacity = oldCapacity;</span><br><span class="line">    <span class="comment">//是否为空，首次进入这里</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(isConstantEmptyCache())) &#123;</span><br><span class="line">        <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">        <span class="comment">//默认容量给4</span></span><br><span class="line">        <span class="keyword">if</span> (!capacity) capacity = INIT_CACHE_SIZE;<span class="comment">//1 &lt;&lt; 2 = 4</span></span><br><span class="line">        <span class="comment">//0 4 false 开辟新的容器空间。由于旧容器为空这里不需要释放传false。</span></span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="comment">/* freeOld */</span><span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//newOccupied + 1 (相当于 _occupied + 2) &lt;= capacity * 3 / 4 容量够的时候什么都不做，直接插入。&lt;=75%的容积正常插入，否则扩容。</span></span><br><span class="line">    <span class="comment">//## ⚠️在arm64位的情况下，CACHE_END_MARKER 0 扩容条件为：7 / 8 87.5% 这个时候CACHE_ALLOW_FULL_UTILIZATION 为 1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fastpath(newOccupied + <span class="built_in">CACHE_END_MARKER</span> &lt;= cache_fill_ratio(capacity))) &#123;</span><br><span class="line">        <span class="comment">// Cache is less than 3/4 or 7/8 full. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CACHE_ALLOW_FULL_UTILIZATION</span></span><br><span class="line">    <span class="comment">//capacity &lt;= 1&lt;&lt;3 (8), _occupied + 1（CACHE_END_MARKER为0） &lt;= 容量。少于8个元素的时候允许100%占满。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (capacity &lt;= FULL_UTILIZATION_CACHE_SIZE &amp;&amp; newOccupied + <span class="built_in">CACHE_END_MARKER</span> &lt;= capacity) &#123;</span><br><span class="line">        <span class="comment">// Allow 100% cache utilization for small buckets. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//扩容</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//容量不为空返回 2倍的容量，否则返回4</span></span><br><span class="line">        capacity = capacity ? capacity * <span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line">        <span class="comment">//MAX_CACHE_SIZE 1&lt;&lt;16 = 2^16。最大缓存65536</span></span><br><span class="line">        <span class="keyword">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">            capacity = MAX_CACHE_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开辟新的容器控件，释放旧的空间。</span></span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从_bucketsAndMaybeMask获取buckets</span></span><br><span class="line">    bucket_t *b = buckets();</span><br><span class="line">    mask_t m = capacity - <span class="number">1</span>;<span class="comment">//首次是4-1</span></span><br><span class="line">    <span class="comment">//计算插入的index</span></span><br><span class="line">    mask_t begin = cache_hash(sel, m);</span><br><span class="line">    mask_t i = begin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for the first unused slot and insert there.</span></span><br><span class="line">    <span class="comment">// There is guaranteed to be an empty slot.</span></span><br><span class="line">    <span class="comment">//循环判断插入数据。</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//能走到这里大概率是cache不存在，所以这里走fastpath</span></span><br><span class="line">        <span class="keyword">if</span> (fastpath(b[i].sel() == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">//Occupied + 1</span></span><br><span class="line">            incrementOccupied();</span><br><span class="line">            <span class="comment">//buckets中插入bucket</span></span><br><span class="line">            b[i].set&lt;Atomic, Encoded&gt;(b, sel, imp, cls());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已经存在了，不进行任何处理。有可能是其它线程插入的。</span></span><br><span class="line">        <span class="keyword">if</span> (b[i].sel() == sel) &#123;</span><br><span class="line">            <span class="comment">// The entry was added to the cache by some other thread</span></span><br><span class="line">            <span class="comment">// before we grabbed the cacheUpdateLock.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cache_next为了防止hash冲突。再hash了一次（下文会讲到）。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (fastpath((i = cache_next(i, m)) != begin));</span><br><span class="line">    <span class="comment">//异常处理</span></span><br><span class="line">    bad_cache(receiver, (SEL)sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首次进入isConstantEmptyCache分支。会创建一个容量为4的空buckets。这个时候由于旧buckets不存在不需要释放所以参数传递false。</li><li>当容量大于等于3/4或7/8的情况下扩容。arm64的条件下为7 / 8。</li><li>arm64条件下容量小于等于8的时候会占用100%才扩容。</li><li>扩容是直接翻倍，默认值4。最大值MAX_CACHE_SIZE为216(65536)。在扩容的时候直接释放了旧值。</li><li>mask值为capacity - 1</li><li>通过cache_hash（下文会提及的散列表算法）计算插入的index，后面会通过cache_next再进行计算hash解决冲突问题。</li><li>循环判断通过b[i].set插入bucket数据。</li><li><strong>reallocate函数在开辟控件的同时，把缓存给直接清空了</strong>，清空之后再把现在要缓存的方法放进去，所以扩容后occupied会为1。</li></ul><h4 id="散列表（哈希表）缓存"><a href="#散列表（哈希表）缓存" class="headerlink" title="散列表（哈希表）缓存"></a>散列表（哈希表）缓存</h4><ul><li><p>方法缓存的容器，不是简单的数组，而是用散列表的方式进行存储。</p><p>假如现在散列表长度为10，那么mask（即cache_t里面的_maybeMask）就是10-1 = 9，当selector传进来的时候，会跟mask进行一次与运算，如下：</p><p><code>@selector(personTest) &amp; mask = 4</code></p><p>假如得到的结果是4的话，那么就会插在列表的下标为4的位置，其他位置因为已经开辟好空间了，所以有值就放值，没值就NULL</p><p>这种列表的好处是，当想取到特定的bucket_t的时候，只需要把selector跟mask进行一次与运算，就可以直接得到下标，然后直接从列表取出，这样子就不用遍历查找了，大大节约了性能。</p><p>另外，由于与运算的特性，跟mask进行与运算之后的值，都不可能比mask更大，这样子就保证不会插入越界的位置。</p></li><li><p>如果通过计算后的下标值，插入列表的时候发现已经有东西了那怎么办？</p><p>  这也就是所谓的Hash冲突。为了处理这种问题，系统会调用<code>cache_next</code>函数</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">mask_t</span> <span class="title">cache_next</span><span class="params">(<span class="keyword">mask_t</span> i, <span class="keyword">mask_t</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i ? i<span class="number">-1</span> : mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  也就是说如果<code>@selector(personTest) &amp; mask = 4</code>的4已经有东西了，那么就取 4 - 1 = 3，如果3还有东西，就放在2的位置，如果2还有，就放在1，以此类推，如果直到0都还没有可以插入的位置，那么就从mask的位置开始找，也就是9，然后再找9看看是否可以插入，插不进去再找8，以此类推，找到为止。</p><p>  由于列表在存放数量达到容量的87.5%的时候就会两倍的扩容（arm64），扩容后又会清空缓存，所以一定能找到合适的位置插入的。</p></li></ul><h2 id="消息发送机制"><a href="#消息发送机制" class="headerlink" title="消息发送机制"></a>消息发送机制</h2><p>调用一个不存在的方法的时候，他会经历这么一个流程</p><p>消息发送 - （找不到方法的话） -&gt; 动态方法解析 - （没有实现的话） -&gt; 消息转发 -&gt; （没有实现的话） -&gt; 抛出异常</p><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p>假如我们这么调用一个方法</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[person personTest]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>底层会转换为</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(person,sel_registerName(<span class="string">&quot;personTest&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>这里的person我们称作消息接受者（receiver），就是调用方法的对象，如果这里还是调用类方法的话，那么这里就会传入一个类对象</li><li><code>sel_registerName()</code>函数等价于<code>@selector</code></li><li>为了性能，<code>objc_msgSend</code>方法底层是使用汇编和C++实现的</li></ul><p>消息发送的流程如下：</p><ol><li>receiver 是否为空，如果是退出，否则继续</li><li>从receiver的类对象（如果传入的是类则找的是元类对象，下文统称为receiverClass）的cache中查找方法，如果找到则调用方法，如果找不到则继续</li><li>从receiverClass中的<code>class_rw_t</code>中查找方法，如果找到则调用方法，并将方法插入缓存，如果找不到则继续</li><li>从<code>superClass</code>的cache中查找方法，有则调用并缓存到当前receiverClass的cache中(不是superClass的cache),否则继续</li><li>从<code>superClass</code>的<code>class_rw_t</code>中找，有则调用并缓存到receiverClass的cache中，否则继续</li><li>继续通过<code>superClass</code>的<code>superClass</code>找方法，流程回到4，直到再也没有父类了，并且也找不到方法，那么将会进入动态方法解析阶段。</li></ol><p>其中：</p><ul><li>如果是从<code>class_rw_t</code>中查找方法，若方法列表已经排序好，那么就使用二分查找法查找</li><li>如果是还没排序的方法，那么就使用遍历的方法查找</li><li>在缓存中查找方法的过程也称作快速查找（使用汇编实现），在<code>class_rw_t</code>中查找方法的过程也称作慢速查找(使用汇编和C++实现)，C++部分方法源码在<code>lookUpImpOrForward</code>函数中，如下：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(<span class="keyword">id</span> inst, SEL sel, Class cls, <span class="keyword">int</span> behavior)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> IMP forward_imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    IMP imp = <span class="literal">nil</span>;</span><br><span class="line">    Class curClass;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    <span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(behavior &amp; LOOKUP_CACHE)) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done_nolock;</span><br><span class="line">    &#125;</span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!cls-&gt;isRealized())) &#123;</span><br><span class="line">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</span><br><span class="line">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    curClass = cls;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> attempts = unreasonableClassCount();;) &#123;</span><br><span class="line">        <span class="comment">// curClass method list.</span></span><br><span class="line">        Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slowpath((curClass = curClass-&gt;superclass) == <span class="literal">nil</span>)) &#123;</span><br><span class="line">            imp = forward_imp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(--attempts == <span class="number">0</span>)) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Memory corruption in class list.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Superclass cache.</span></span><br><span class="line">        imp = cache_getImp(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (slowpath(imp == forward_imp)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fastpath(imp)) &#123;</span><br><span class="line">            <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">        behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">        <span class="keyword">return</span> resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">    &#125;</span><br><span class="line"> done:</span><br><span class="line">    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"> done_nolock:</span><br><span class="line">    <span class="keyword">if</span> (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>慢速查找流程图：</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/47b512631098428e8bc60162e1df4ab7.png" ><p>消息发送流程图：</p><img src="https://p9-tt.byteimg.com/origin/pgc-image/70dfbbc7f61a4a9fac15e5ff1af809b4.png"><h3 id="动态方法解析（也称：动态方法决议）"><a href="#动态方法解析（也称：动态方法决议）" class="headerlink" title="动态方法解析（也称：动态方法决议）"></a>动态方法解析（也称：动态方法决议）</h3><p>当消息发送流程找不到方法后就会进入动态方法解析流程。</p><p>动态方法解析是当消息发送阶段找不到方法的时候，开发者可以通过重写特定方法（如果是类方法就重写<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>，如果是对象方法就重写<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>），给原先不存在的方法添加方法实现。主要是用到runtime里面的<code>class_addMethod</code>函数，并且动态解析后，会重新走”消息发送“的流程</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>假如这里的person没有实现print方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [Person new];</span><br><span class="line">[person print];</span><br></pre></td></tr></table></figure><p>那我们可以在<code>Person.m</code>添加一个方法实现用来替换丢失的<code>print</code>，这里我们用<code>truePrint</code>来替代</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)truePrint &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;true print&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取truePrint方法的Method对象</span></span><br><span class="line">        Method truePrint = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(truePrint));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 动态添加print方法的实现，通过method_getImplementation获取到方法的函数指针，通过method_getTypeEncoding拿到方法的函数编码即 v@: 或 v16@0:8</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, method_getImplementation(truePrint), method_getTypeEncoding(truePrint));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回YES代表有动态添加方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method的结构"><a href="#Method的结构" class="headerlink" title="Method的结构"></a>Method的结构</h4><p>点击Method我们可以看到结构如下</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></span><br></pre></td></tr></table></figure><p>而<code>ojbc_method</code>的定义如下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">struct</span> objc_method &#123;</span><br><span class="line">    <span class="attribute">SEL</span> _Nonnull method_name;</span><br><span class="line">    <span class="attribute">char</span> * _Nullable method_types;</span><br><span class="line">    <span class="attribute">IMP</span> _Nonnull method_imp;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>可以看到跟上面所说的<code>method_t</code>是类似的东西</p><p>以下是一些拿到<code>Method</code>对象后可以使用的一些函数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用，但是不接收返回值类型为结构体</span></span><br><span class="line">method_invoke</span><br><span class="line"><span class="comment">// 函数调用，但是接收返回值类型为结构体</span></span><br><span class="line">method_invoke_stret</span><br><span class="line"><span class="comment">// 获取函数名</span></span><br><span class="line">method_getName</span><br><span class="line"><span class="comment">// 获取函数实现IMP</span></span><br><span class="line">method_getImplementation</span><br><span class="line"><span class="comment">// 获取函数type encoding</span></span><br><span class="line">method_getTypeEncoding</span><br><span class="line"><span class="comment">// 复制返回值类型</span></span><br><span class="line">method_copyReturnType</span><br><span class="line"><span class="comment">// 复制参数类型</span></span><br><span class="line">method_copyArgumentType</span><br><span class="line"><span class="comment">// 获取返回值类型</span></span><br><span class="line">method_getReturnType</span><br><span class="line"><span class="comment">// 获取参数个数</span></span><br><span class="line">method_getNumberOfArguments</span><br><span class="line"><span class="comment">// 获取函数参数类型</span></span><br><span class="line">method_getArgumentType</span><br><span class="line"><span class="comment">// 获取函数描述</span></span><br><span class="line">method_getDescription</span><br><span class="line"><span class="comment">// 设置函数实现IMP</span></span><br><span class="line">method_setImplementation</span><br><span class="line"><span class="comment">// 交换函数的实现IMP</span></span><br><span class="line">method_exchangeImplementations</span><br></pre></td></tr></table></figure><h4 id="Runtime中的原理"><a href="#Runtime中的原理" class="headerlink" title="Runtime中的原理"></a>Runtime中的原理</h4><p>在上面的消息发送的流程函数<code>lookUpImpOrForward</code>中，有一段代码如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">    behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">    return resolve<span class="constructor">Method_locked(<span class="params">inst</span>, <span class="params">sel</span>, <span class="params">cls</span>, <span class="params">behavior</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当找不到消息的时候就会进入动态方法解析的流程即<code>resolveMethod_locked</code>，如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NEVER_INLINE IMP resolveMethod_locked(<span class="keyword">id</span> inst, SEL sel, Class cls, <span class="keyword">int</span> behavior) &#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveClassMethod(inst, sel, cls);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNilTryCache(inst, sel, cls)) &#123;</span><br><span class="line">            resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForwardTryCache(inst, sel, cls, behavior);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面我们可以发现<code>resolveInstanceMethod</code>和<code>resolveClassMethod</code>两个函数，分别是实现实例方法的动态消息解析和类方法的动态消息解析，这两个长得差不多，所以我们拿实例对象的函数查看一下</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static void resolveInstanceMethod(id inst, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    ASSERT(<span class="function"><span class="title">cls</span>-&gt;</span>isRealized());</span><br><span class="line">    SEL resolve_sel = @selector(resolveInstanceMethod:);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (!lookUpImpOrNilTryCache(cls, resolve_sel, cls-&gt;</span>ISA(<span class="comment">/*authenticated*/</span><span class="literal">true</span>))) &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    bool resolved = msg(cls, resolve_sel, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveInstanceMethod adds to self a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNilTryCache(inst, sel, cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;RESOLVE: method %c[%s %s] &quot;</span></span><br><span class="line">                         <span class="string">&quot;dynamically resolved to %p&quot;</span>, </span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>isMetaClass() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn&#x27;t add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</span></span><br><span class="line">                         <span class="string">&quot;, but no new implementation of %c[%s %s] was found&quot;</span>,</span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel), </span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>isMetaClass() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们可以看到对<code>resolveInstanceMethod</code>方法进行了一次<code>objc_msgSend</code>调用，调用之后又执行了<code>lookUpImpOrNilTryCache</code>函数进行了缓存，如果缓存成功，那么下次调用这个方法就不会在进入动态方法解析阶段，直接通过消息发送阶段就调用成功了。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>根据我们以前所学的知识可以知道，方法查找的流程为</p><p>实例方法：类 – 父类 – 父类 – … – 根类 – nil</p><p>类方法：元类 – 父元类 – 父元类 – … – 根元类 – 根类 – nil</p><p>也就是说丢失的方法最后都会回到根类去找方法，一般情况下是<code>NSObject</code></p><p>通过这个特性，我们可以直接在<code>NSObject</code>上添加分类，然后实现动态解析方法，根据方法名前缀进行判断，然后统一处理未被找到的方法添加默认实现。通过这种方式我们可以减少一些找不到方法导致的崩溃问题，提升用户体验。</p><h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>如果没有实现动态方法解析，那么将进入消息转发阶段。消息转发即把消息交给别人发送的意思。</p><p>从上面的<code>lookUpImpOrForward</code>函数的源码我们可以看到，最后是调用了<code>_objc_msgForward_impcache</code>这个函数，这个函数是通过汇编实现的</p><p>要实现消息转发，我们有两种方式，一种是实现一个方法<code>-forwardingTargetForSelector</code>，一种是实现<code>-methodSignatureForSelector</code>和<code>-forwardInvocation</code>，比如</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[Student alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了这个方法之后，最后系统会去我们提供的<code>Student</code>对象去寻找<code>print</code>方法，找到了的话就会进行调用。注意这个方法每次都会进来，每次都会生成新的<code>Student</code>对象对其<code>print</code>方法进行调用。</p><p>如果<code>forwardingTargetForSelector</code>没实现或者返回空的话</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就会寻找<code>-methodSignatureForSelector</code>和<code>-forwardInvocation</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 方法签名： 返回值类型、参数类型</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">&quot;v16@0:8&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数</span></span><br><span class="line"><span class="comment">/// anInvocation.target 方法调用者</span></span><br><span class="line"><span class="comment">/// anInvocation.selector 方法名</span></span><br><span class="line"><span class="comment">//// [anInvocation getArgument:NULL atIndex:0] 方法参数</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:[[Student alloc] init]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们在方法签名中指定方法类型，然后在<code>forwardInvocation</code>方法中，修改target，然后直接调用，这样子就会直接调用Student的print方法了</p><img src="https://p3-tt.byteimg.com/origin/pgc-image/ba2d1d5ff71a49c8913690d6f69fb7d7.png" width=80%><h4 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h4><p>当系统执行到<code>forwardInvocation</code>的时候，无论在方法内有任何实现，都不会执行到<code>doseNotRecognizeSelector</code>（抛出异常），所以实现了就不会崩，即便什么都不做。</p><p>在<code>forwardInvocation</code>内我们可以拿到方法调用的很多信息，比如方法调用者<code>anInvocation.target</code>、方法名<code>anInvocation.selector</code>和方法参数</p><p>比如调用方法为<code>[person print:1]</code>，进入到<code>forwardInvocation</code>后我们可以通过以下方法拿到<code>1</code>这个参数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    [anInvocation getArgument:&amp;a atIndex:<span class="number">2</span>]; <span class="comment">// 第一个参数是self，第二个是_cmd，所以从下标2开始取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要拿返回值的话，就可以这么做</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:[[Student alloc] init]]; <span class="comment">// 要先调用一下Student的print方法，这里假设返回值是整型</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    [anInvocation getReturnValue:&amp;result];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,result); <span class="comment">/// 这里可以拿到返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NSMethodSignature"><a href="#NSMethodSignature" class="headerlink" title="NSMethodSignature"></a>NSMethodSignature</h4><p><code>[NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;]</code>，注意这里的方法编码要跟下面<code>forwardInvocation</code>要调用的方法的方法编码一致 </p><p>我们除了可以通过方法编码拿到<code>NSMethodSignature</code>对象之外，还可以这么做</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[Student new] methodSignatureForSelector:<span class="keyword">@selector</span>(print)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类方法的消息转发"><a href="#类方法的消息转发" class="headerlink" title="类方法的消息转发"></a>类方法的消息转发</h4><p><code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code></p><p><code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code></p><p><code>+ (void)forwardInvocation:(NSInvocation *)anInvocation</code></p><p>这几个方法也有类方法版本，但是代码补全没出来，但是实际使用是可行的</p><p><code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>在这个方法里面返回的消息接受者既可以是类对象也可以是实例对象。</p><h4 id="synthesize-和-dynamic"><a href="#synthesize-和-dynamic" class="headerlink" title="@synthesize 和 @dynamic"></a>@synthesize 和 @dynamic</h4><p><code>@synthesize</code>用来自动给成员变量名生成<code>setter</code>和<code>getter</code>的声明和实现</p><p><code>@dynamic</code>用来告诉编译器不要自动生成<code>setter</code>和<code>getter</code>的实现（声明还是会声明的），待到运行时开发者自己实现，并且不会为属性实现带下划线的成员变量</p><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>假如我们调用<code>Student</code>实例的一个父类方法</p><p><code>[super run:xx]</code></p><p>那么编译后会变成如下代码</p><p><code>objc_msgSendSuper(self,class_getSuperclass(objc_getClass(&quot;Student&quot;)),sel_registerName(&quot;run&quot;),xx);</code></p><p>所以<code>super</code>发送消息的本质是调用<code>objc_msgSendSuper2</code>函数，最终的消息接受者依旧是<code>self</code>，只是实例方法寻找从父类的类对象开始寻找，类方法从父类的元类对象开始寻找。</p><p>所以当我们调用方法<code>[super class]</code>的时候，跟<code>[self class]</code>没区别，返回结果是一致的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要简述类（元类）对象里面的方法缓存、消息发送（包括消息发送，动态方法解析与消息转发）与super关键字的底层原理&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- isa指针</title>
    <link href="https://www.arclin.cn/post/78ececc4.html"/>
    <id>https://www.arclin.cn/post/78ececc4.html</id>
    <published>2021-06-14T07:26:00.000Z</published>
    <updated>2022-07-12T16:51:57.241Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述isa指针在runtime内部的底层实现和isa的优化方式</p><span id="more"></span><h2 id="isa指针的底层实现"><a href="#isa指针的底层实现" class="headerlink" title="isa指针的底层实现"></a>isa指针的底层实现</h2><ul><li><p>在arm64架构出现之前，isa就是一个普通的指针(<code>Class isa</code>)，存储着Class,Meta-Class对象的内存地址</p></li><li><p>从arm64架构开始，对isa进行了优化，变成了一个共用体，还使用位域来存储更多的信息</p></li><li><p>isa指针的结构如下（objc4-818.2）</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> &#123;</span></span><br><span class="line">    <span class="built_in">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">isa_t</span>(<span class="keyword">uintptr_t</span> value) : <span class="built_in">bits</span>(value) &#123; &#125;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> unused            : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDeallocating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> extra_rc == <span class="number">0</span> &amp;&amp; has_sidetable_rc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDeallocating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        extra_rc = <span class="number">0</span>;</span><br><span class="line">        has_sidetable_rc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setClass</span><span class="params">(Class cls, objc_object *obj)</span></span>;</span><br><span class="line">    <span class="function">Class <span class="title">getClass</span><span class="params">(<span class="keyword">bool</span> authenticated)</span></span>;</span><br><span class="line">    <span class="function">Class <span class="title">getDecodedClass</span><span class="params">(<span class="keyword">bool</span> authenticated)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先，共用体同结构体一样，是拥有成员变量的，但是不同的点在于所有成员变量共用一块内存，也就是说当一个成员变量有值时，其他成员变量都成了装饰。</p><p>在runtime中，我们只需要用到<code>uintptr_t bits</code>，<code>uintptr_t</code>是<code>unsigned long</code>的别名，在64位系统下占用8个字节，共64位</p><p>共用体内的<code>struct &#123; ... &#125;</code> 是为了增加可读性而添加的，它描述了<code>bits</code>里面存放了什么信息，我们一个个说明一下</p><blockquote><p>补充说明： 结构体内的冒号后面的数字表示这个成员所占的位数，举个例子，本来<code>char name</code>作为一个成员变量，是会占用一个字节，也就是8个二进制位，如果有3个这样子的成员变量，那么这个结构体就会占用3个字节，如果我们在这个成员变量的后面添加了一个数字，去限制这个成员变量所占的位数，比如<code>char name : 1</code>，那么三个这样子的成员变量就一共占用3个二进制位，也就是不到一个字节，因为系统分配内存的最小单位为1个字节，所以这个结构体就占用1个字节，这么做我们就可以节约2个字节了，这种技术叫做<strong>位域</strong>。</p></blockquote><ul><li>nonpointer<ul><li>0代表普通的指针，存储着Class、Meta-Class对象的内存地址</li><li>1代表优化过，使用位域存储着更多的信息</li></ul></li><li>has_assoc<ul><li>是否有设置过关联对象（注意是“设置过”，就算以后关联对象移除了，它还会是true），如果没有，会释放得更快</li></ul></li><li>has_cxx_dtor<ul><li>是否有C++的析构函数（.cxx_destruct），如果没有，会释放得更快</li></ul></li></ul><p>上面两个<code>会释放得更快</code>的原因是，在对象销毁的时候，会调用runtime里面的这个方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void *objc<span class="constructor">_destructInstance(<span class="params">id</span> <span class="params">obj</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="built_in">bool</span> cxx = obj-&gt;has<span class="constructor">CxxDtor()</span>;</span><br><span class="line">        <span class="built_in">bool</span> assoc = obj-&gt;has<span class="constructor">AssociatedObjects()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) <span class="keyword">object</span><span class="constructor">_cxxDestruct(<span class="params">obj</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (assoc) <span class="constructor">_object_remove_assocations(<span class="params">obj</span>, <span class="operator">/</span><span class="operator">*</span><span class="params">deallocating</span><span class="operator">*</span><span class="operator">/</span><span class="params">true</span>)</span>;</span><br><span class="line">        obj-&gt;clear<span class="constructor">Deallocating()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果<code>has_assoc</code>或者<code>has_cxx_dtor</code>的话，就不会进入判断为true的逻辑，函数会运行得更快</p><ul><li>shiftcls<ul><li>存储着Class、Meta-Class对象的内存信息</li></ul></li><li>magic<ul><li>用于在调试时分辨对象是否未完成初始化</li></ul></li><li>weakly_referenced<ul><li>是否有被弱引用指向过（同样注意“指向过”，有过即为true），如果没有，释放时会更快</li></ul></li></ul><p>“会释放得更快”是因为对象销毁时调用了如下runtime源码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE void</span><br><span class="line">objc_object::clear<span class="constructor">Deallocating_slow()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="constructor">ASSERT(<span class="params">isa</span>.<span class="params">nonpointer</span>  <span class="operator">&amp;&amp;</span>  (<span class="params">isa</span>.<span class="params">weakly_referenced</span> <span class="operator">||</span> <span class="params">isa</span>.<span class="params">has_sidetable_rc</span>)</span>);</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table = <span class="constructor">SideTables()</span><span class="literal">[<span class="identifier">this</span>]</span>;</span><br><span class="line">    table.lock<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">        weak<span class="constructor">_clear_no_lock(&amp;<span class="params">table</span>.<span class="params">weak_table</span>, (<span class="params">id</span>)</span>this);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.erase(this);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>deallocating<ul><li>对象是否正在释放</li></ul></li><li>extra_rc <ul><li>里面存储的值是引用计数器减1后的值</li></ul></li><li>has_sitdtable_rc<ul><li>引用计数器是否过大无法存储在isa中</li><li>如果为1，那么引用计数器会存储在一个叫做SideTable的类的属性中</li></ul></li></ul><h2 id="如何从isa指针中取出对应的信息"><a href="#如何从isa指针中取出对应的信息" class="headerlink" title="如何从isa指针中取出对应的信息"></a>如何从isa指针中取出对应的信息</h2><p>isa是通过位运算来取出和存入信息的。</p><ul><li>我们以取出<code>shiftcls</code>内的类信息为例</li></ul><p>首先isa里面的bits存储着64个二进制位，然后其中<code>shiftcls</code>是使用了33个（从上面的共用体里面的位域看出），当系统需要取出对应信息的时候，就使用<code>ISA_MASK</code>（ISA掩码）跟bits做一次与运算，举个例子，bits的十六进制地址为<code>0x011d8001000083a5</code></p><blockquote><p>补充： ISA_MASK在arm64下的值为<code>0x0000000ffffffff8ULL</code>，下面我们把他转成二进制</p></blockquote><table><thead><tr><th></th><th>8</th><th>16</th><th>24</th><th>32</th><th>40</th><th>48</th><th>56</th><th>64</th></tr></thead><tbody><tr><td>bits<br>(0x011d8001000083a5)</td><td>1010 0101</td><td>1100 0001</td><td>0000 0000</td><td>0000 0000</td><td>1000 0000</td><td>0000 0001</td><td>1011 1000</td><td>1000 0000</td></tr><tr><td>ISA_MASK<br>(0x0000000ffffffff8)</td><td>0001 1111</td><td>1111 1111</td><td>1111 1111</td><td>1111 1111</td><td>1111 0000</td><td>0000 0000</td><td>0000 0000</td><td>0000 0000</td></tr><tr><td>与运算后的结果<br>(0x00000001000083a0)</td><td>0000 0101</td><td>1100 0001</td><td>0000 0000</td><td>0000 0000</td><td>1000 0000</td><td>0000 0000</td><td>0000 0000</td><td>0000 0000</td></tr></tbody></table><p>我们可以来验证一下</p><img src="https://z3.ax1x.com/2021/06/15/2qoart.png" width="80%"><p>可以看到 isa一开始的值跟<code>[person class]</code>的值是不相同的，跟<code>ISA_MASK</code>进行一次与运算之后就相同了，所以可以看出实例对象的isa不是直接指向类对象的，是需要进行一次运算取出来的。</p><ul><li>其他的信息如<code>nonpointer</code>等，取出的方式也类似这样，这么做的好处是充分利用了64个二进制位的内存，而不用像以前一样一个属性就占用了多个字节，造成二进制位的浪费。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲述isa指针在runtime内部的底层实现和isa的优化方式&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- Block、__block及其底层实现</title>
    <link href="https://www.arclin.cn/post/8275b854.html"/>
    <id>https://www.arclin.cn/post/8275b854.html</id>
    <published>2021-06-07T15:50:00.000Z</published>
    <updated>2022-07-12T16:51:57.240Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述Block、__block的本质是什么东西，文章涉及循环引用等开发常见问题，需要重点关注。</p><span id="more"></span><h2 id="先写一个最简单的block"><a href="#先写一个最简单的block" class="headerlink" title="先写一个最简单的block"></a>先写一个最简单的block</h2><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span>(^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;Block&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">block</span>();</span><br></pre></td></tr></table></figure><p>使用命令行将<code>main.m</code>文件编译成C++文件<br/><br><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m </code></p><p>编译完成后，上述代码会变成以下结构</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span>(*block)(<span class="literal">void</span>) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="params">((<span class="literal">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block)</span>;</span></span><br></pre></td></tr></table></figure><p>可以看出是生成了一个<code>__main_block_impl_0</code>结构体类型的对象，参数1为<code>__main_block_func_0</code>，参数2为<code>&amp;__main_block_desc_0_DATA</code></p><h2 id="block的底层结构"><a href="#block的底层结构" class="headerlink" title="block的底层结构"></a>block的底层结构</h2><p>接下来查看一下<code>__main_block_impl_0</code>是什么东西</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// block的结构体，引用了两个结构体和实现了一个构造方法</span></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="constructor">__main_block_impl_0(<span class="params">void</span> <span class="operator">*</span><span class="params">fp</span>, <span class="params">struct</span> <span class="params">__main_block_desc_0</span> <span class="operator">*</span><span class="params">desc</span>, <span class="params">int</span> <span class="params">flags</span>=0)</span> &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// block的结构体引用的第一个结构体</span></span><br><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  <span class="built_in">int</span> Flags;</span><br><span class="line">  <span class="built_in">int</span> Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// block的结构体引用的第二个结构体，第一个参数赋值了0，第二个参数赋值了__main_block_impl_0的结构体大小</span></span><br><span class="line">static <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, sizeof(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure><p>所以拼接一下可以看出</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  <span class="built_in">int</span> Flags;</span><br><span class="line">  <span class="built_in">int</span> Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="constructor">__main_block_impl_0(<span class="params">void</span> <span class="operator">*</span><span class="params">fp</span>, <span class="params">struct</span> <span class="params">__main_block_desc_0</span> <span class="operator">*</span><span class="params">desc</span>, <span class="params">int</span> <span class="params">flags</span>=0)</span> &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><em><strong>结论1：block本质上是一个OC对象，它内部也有个isa指针</strong></em></li></ul><p>接下来看看构造方法，第一个参数是<code>void *fp</code>意为<code>function pointer</code>函数指针，所以我们回去看看这里传了什么值进去</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void<span class="comment">(*block)</span><span class="comment">(void)</span> = &amp;__mai<span class="symbol">n_block_impl_0</span><span class="comment">(__main_block_func_0, &amp;__main_block_desc_0_DATA)</span>);</span><br></pre></td></tr></table></figure><p>是<code>__main_block_func_0</code>，那我们再看看<code>__main_block_func_0</code>是什么</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_34b858_mi_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出我们在block内写的代码被封装成了一个函数</p><ul><li><em><strong>结论2：block是封装了函数调用以及函数调用环境的OC对象</strong></em></li></ul><p>最后，看一下block的调用，被编译成了下述结构（这里我们去掉强制转换）</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">(block)</span>-&gt;</span>FuncPtr(block);</span><br></pre></td></tr></table></figure><p>可以看出，是取出了变量中的<code>FuncPtr</code>成员变量，得到函数指针后把自己传进去，这样子就完成了block的调用</p><h2 id="block捕获外部变量"><a href="#block捕获外部变量" class="headerlink" title="block捕获外部变量"></a>block捕获外部变量</h2><p>从上面的分析我们可以得知，局部变量的定义和使用，是在两个函数中进行的，所以为了能够给让变量跨函数访问，block需要捕获该变量 </p><h3 id="局部auto类型的变量捕获"><a href="#局部auto类型的变量捕获" class="headerlink" title="局部auto类型的变量捕获"></a>局部auto类型的变量捕获</h3><p><strong>auto ： 自动变量，离开作用域自动销毁</strong></p><p>平常我们定义的局部变量，默认都是<code>auto</code>修饰的</p><p>先写一个简单的demo</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> age = <span class="number">10</span>; // 等价于 <span class="built_in">auto</span> <span class="built_in">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">void</span>(^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;Block %d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译后变成如下结构(去掉强制转换)</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> age = <span class="number">10</span>;</span><br><span class="line">void(*block)(void) = &amp;<span class="constructor">__main_block_impl_0(<span class="params">__main_block_func_0</span>, &amp;<span class="params">__main_block_desc_0_DATA</span>, <span class="params">age</span>)</span>);</span><br></pre></td></tr></table></figure><p><code>__main_block_impl_0</code>也发生了变化，可以看到多了一个<code>age</code>成员变量，所以构造函数也多了一个参数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line">  <span class="constructor">__main_block_impl_0(<span class="params">void</span> <span class="operator">*</span><span class="params">fp</span>, <span class="params">struct</span> <span class="params">__main_block_desc_0</span> <span class="operator">*</span><span class="params">desc</span>, <span class="params">int</span> <span class="params">_age</span>, <span class="params">int</span> <span class="params">flags</span>=0)</span> : age(_age) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>age(_age)</code>这个语法意为将构造方法传进来的<code>_age</code>赋值到自己的的成员变量<code>age</code>，这个过程我们称作变量的<strong>捕获</strong></p><p>block内编译后的函数<code>__main_block_func_0</code>也发生了变化</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line">   <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_5fd8ec_mi_0,age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出函数内取出了结构体内的<code>age</code>成员变量，然后交给<code>NSLog</code>使用</p><p>由此可知，block在定义的时候就会把外部传进来的参数给存储一遍，然后调用的时候在从block对象中取出来，所以这就意味着<strong>被block捕获的变量，在被捕获后如果修改了值，是不会应用到block中的</strong>，举例如下</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">void</span>(^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;age = %d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line">age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">block</span>(); // 调用这个方法只会输出age = <span class="number">10</span>，因为age被捕获时是<span class="number">10</span>，所以后面就算改了值也没用</span><br></pre></td></tr></table></figure><h3 id="局部static类型的变量捕获"><a href="#局部static类型的变量捕获" class="headerlink" title="局部static类型的变量捕获"></a>局部static类型的变量捕获</h3><p>把上面的<code>age</code>变量加一个<code>static</code>修饰符试试看</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">void</span>(^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;age = %d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line">age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">block</span>();</span><br></pre></td></tr></table></figure><p>结果会输出<code>age = 20</code>，原因是静态变量会将<code>static</code>修饰的对象转为block的指针类型的成员属性，如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">int</span> *age;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> *age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line">  <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_bb86ee_mi_0,(*age));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是指针传递，所以当指针指向的内容变化时，打印出来的值也就会变化了</p><h3 id="全局变量不捕获"><a href="#全局变量不捕获" class="headerlink" title="全局变量不捕获"></a>全局变量不捕获</h3><p>全局<code>static</code>变量不捕获，因为全局<code>static</code>变量大家都能访问，所以函数内可以直接读取值</p><h3 id="block内的self会被捕获吗"><a href="#block内的self会被捕获吗" class="headerlink" title="block内的self会被捕获吗"></a>block内的self会被捕获吗</h3><p>会，我们来举个例子</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>test &#123;</span><br><span class="line">void<span class="params">(^block)</span><span class="params">(void)</span> = ^&#123;</span><br><span class="line">    NSLog<span class="params">(@<span class="string">&quot;%@&quot;</span>,self)</span>; </span><br><span class="line">    &#125;;</span><br><span class="line">    block<span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>test</code>方法会添加两个隐含的参数，编译后如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">_I_Person_Test</span>(<span class="params">Person *self, SEL _cmd</span>)</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这就是为什么我们能在方法内访问<code>self</code>和<code>_cmd</code>的原因，因为方法会传进来<code>self</code>参数，又因为参数是局部变量，又因为局部变量会被捕获，所以<code>self</code>参数会被捕获，捕获后大概长这样子</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="type">__main_block_impl_0</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="type">__block_impl</span> impl;</span><br><span class="line">  <span class="keyword">struct</span> <span class="type">__main_block_desc_0</span>* Desc;</span><br><span class="line">  Person *self;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Block的类型"><a href="#Block的类型" class="headerlink" title="Block的类型"></a>Block的类型</h2><p>Block有三种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型</p><table><thead><tr><th>存储区域</th><th>类名</th><th>特点</th><th>调用copy后的效果</th></tr></thead><tbody><tr><td>数据区域 .data区</td><td><code>__NSGlobalBlock__</code></td><td>没有访问auto变量</td><td>无效果</td></tr><tr><td>栈区</td><td><code>__NSStackBlock__</code></td><td>访问了auto变量</td><td>从栈复制到堆</td></tr><tr><td>堆区</td><td><code>__NSMallocBlock__</code></td><td><code>__NSStackBlock__</code>调用了copy</td><td>引用计数增加</td></tr></tbody></table><h3 id="NSGlobalBlock"><a href="#NSGlobalBlock" class="headerlink" title="__NSGlobalBlock__"></a><code>__NSGlobalBlock__</code></h3><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span>(^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="NSStackBlock"><a href="#NSStackBlock" class="headerlink" title="__NSStackBlock__"></a><code>__NSStackBlock__</code></h3><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">void</span>(^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^&#123;</span><br><span class="line">   <span class="type">NSLog</span>(@<span class="string">&quot;Block %d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为在ARC环境下，栈区block会自动copy，所以要测试这个类型的时候，需要使用MRC环境</p><p><strong>栈区数据的特点是会自动销毁，离开了作用域，数据都会销毁</strong></p><p><strong>栈区block存在的问题是，捕获的变量会存放在栈区，所以一旦离开了作用域，捕获的内容就销毁了，将来再去访问这个block内捕获的变量，访问到的可能就是一个未知的内容</strong></p><p>以下情况编译器会自动将栈上的block复制到堆上：</p><ol><li>block作为函数返回值时，比如 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(^Block)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function">Block <span class="title">myBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;---------%d&quot;</span>,age);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>将block赋值给__strong指针时<ul><li>__strong是是id类型和对象类型默认的所有权修饰符，所以平时在ARC环境下写的引用外部auto局部变量的block都会自动copy到堆中，原因是block默认被__strong修饰了</li></ul></li><li>block作为Cocoa API中方法名含有usingBlock的方法参数时<ul><li>比如NSArray的<code>enumerateObjectsUsingBlock:</code>方法，block传进去之后就会被copy一下</li></ul></li><li>block作为GCD API的方法参数时<ul><li>比如GCD的<code>dispatch_after(dispatch_time_t when, dispatch_queue_t queue,   dispatch_block_t block);</code>方法，block传进去之后就会被copy一下</li></ul></li></ol><h3 id="NSMallocBlock"><a href="#NSMallocBlock" class="headerlink" title="__NSMallocBlock__"></a><code>__NSMallocBlock__</code></h3><p>将<code>__NSStackBlock__</code>进行一次copy，即可得到<code>__NSMallocBlock__</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = [^&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@&quot;Block %d&quot;</span>,age);</span><br><span class="line">&#125; <span class="keyword">copy</span>];</span><br></pre></td></tr></table></figure><h2 id="捕获对象类型的auto变量"><a href="#捕获对象类型的auto变量" class="headerlink" title="捕获对象类型的auto变量"></a>捕获对象类型的auto变量</h2><p>当block内部访问了对象类型的auto变量时，如下</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Person</span> *<span class="keyword">person</span> = <span class="comment">[<span class="comment">[Person alloc]</span> init]</span>;</span><br><span class="line">void(^block)(void) = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;Person %@&quot;</span>,<span class="keyword">person</span>);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>我们在ARC环境下编译，这时候block会在堆上（因为被自动copy了），执行命令行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</code>，会发现block结构体的person属性多了一个<code>__strong</code>的修饰符，证明他被block强持有了。</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  Person *__strong person;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们如果编译的时候去掉<code>-fobjc-arc</code>，默认就是MRC环境了，这时候block会在栈上，查看编译后的c++文件发现不会有<code>__strong</code>修饰符，如果我们在block执行前加一行<code>[person release]</code>，那么这时候<code>person</code>就会直接释放，证明block没有持有<code>person变量</code></p><ul><li>结论1：如果block是在栈上，将不会对auto变量产生强引用</li></ul><p>如果我们给person添加<code>__weak</code>修饰符</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__weak <span class="keyword">Person</span> *<span class="keyword">person</span> = <span class="comment">[<span class="comment">[Person alloc]</span> init]</span>;</span><br><span class="line">void(^block)(void) = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;Person %@&quot;</span>,<span class="keyword">person</span>);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>则block将会对person对象进行弱引用，编译后如下：</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  Person *__weak person;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以使用<code>__weak</code>修饰符可以避免block对外部变量的强引用操作</p><p>我们来看看block的结构体内的<code>__main_block_desc_0</code>是个什么东西</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br></pre></td></tr></table></figure><p>可以发现，多了两个函数指针，<code>copy</code>和<code>dispose</code>，分别指向<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code></p><p>这两个函数的实现如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void <span class="constructor">__main_block_copy_0(<span class="params">struct</span> <span class="params">__main_block_impl_0</span><span class="operator">*</span><span class="params">dst</span>, <span class="params">struct</span> <span class="params">__main_block_impl_0</span><span class="operator">*</span><span class="params">src</span>)</span> &#123;</span><br><span class="line"><span class="constructor">_Block_object_assign((<span class="params">void</span><span class="operator">*</span>)</span>&amp;dst-&gt;person, (void*)src-&gt;person, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void <span class="constructor">__main_block_dispose_0(<span class="params">struct</span> <span class="params">__main_block_impl_0</span><span class="operator">*</span><span class="params">src</span>)</span> &#123;</span><br><span class="line"><span class="constructor">_Block_object_dispose((<span class="params">void</span><span class="operator">*</span>)</span>src-&gt;person, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_Block_object_assign</code>函数内部会对person进行引用计数器的操作，如果<code>__main_block_impl_0</code>结构体内person指针是<code>__strong</code>类型，则为强引用，引用计数+1，如果<code>__main_block_impl_0</code>结构体内person指针是<code>__weak</code>类型，则为弱引用，引用计数不变。</p><p><code>_Block_object_dispose</code>会对person对象做释放操作，类似于release，也就是断开对person对象的引用，而person究竟是否被释放还是取决于person对象自己的引用计数</p><ul><li>结论2：如果block被拷贝到堆上<ul><li>会调用block内部的copy函数</li><li>copy函数内部会调用_Block_object_assign函数</li><li>_Block_object_assign函数会根据auto变量的修饰符（<code>__strong</code>，<code>__weak</code>，<code>__unsafe_unretained</code>）做出相应的操作，类似于retain(形成强引用、弱引用)</li></ul><blockquote><p>__unsafe_unretained修饰的变量不会增加引用计数，当销毁时，该指针不会置空，会造成不安全的情况。</p></blockquote></li><li>结论3：如果block从堆上移除<ul><li>会调用block内部的dispose函数</li><li>dispose函数内部会调用_Block_object_assign函数</li><li>_Block_object_dispose函数会自动释放引用的auto变量，类似于release</li></ul></li></ul><table><thead><tr><th>函数</th><th>调用时机</th></tr></thead><tbody><tr><td>copy函数</td><td>栈上的Block复制到堆时</td></tr><tr><td>dispose函数</td><td>堆上的Block被废弃时</td></tr></tbody></table><h2 id="block"><a href="#block" class="headerlink" title="__block"></a>__block</h2><p>一般情况下我们是无法改变block捕获的外部的值的</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Person</span> *<span class="keyword">person</span> = <span class="comment">[<span class="comment">[Person alloc]</span> init]</span>;</span><br><span class="line">void(^block)(void) = ^&#123;</span><br><span class="line"><span class="keyword">person</span> = nil;  /// 这种情况是会编译失败的</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>从上面的内容我们也可以知道原因。就是因为外部的person所在的内存空间和block内（单独开辟了一个函数）的内存空间不在同一个位置，所以block内是访问不到的外部的person的。</p><p>但是我们如果添加了<code>__block</code>关键字的话，就可以访问了，所以我们编译一下看看添加<code>__block</code>之后的情况</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="built_in">block</span> Person *person = [[Person alloc] init];</span><br><span class="line"><span class="keyword">void</span>(^<span class="built_in">block</span>)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">person = nil;  <span class="comment">// 编译成功</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">block</span>();</span><br></pre></td></tr></table></figure><p>编译后长这样</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_person_0 *person; <span class="comment">// by ref</span></span><br><span class="line">  <span class="constructor">__main_block_impl_0(<span class="params">void</span> <span class="operator">*</span><span class="params">fp</span>, <span class="params">struct</span> <span class="params">__main_block_desc_0</span> <span class="operator">*</span><span class="params">desc</span>, <span class="params">__Block_byref_person_0</span> <span class="operator">*</span><span class="params">_person</span>, <span class="params">int</span> <span class="params">flags</span>=0)</span> : person(_person-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到person对象被封装成了一个<code>__Block_byref_person_0 *</code>类型的属性</p><p>继续看看<code>__Block_byref_person_0</code>是什么</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_person_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_person_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> Person *__<span class="keyword">strong</span> person;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__Block_byref_person_0</code>有isa指针，是一个OC对象，里面有一个强引用的person对象（指向的内容等同于外面的person指针指向的内容），和我们熟悉的<code>__Block_byref_id_object_copy</code>和<code>__Block_byref_id_object_dispose</code>方法用于处理内存管理问题，还有指向自身的<code>forwarding</code>指针（这个指针指向对象自身），<code>flag</code>和<code>size</code>，分别表示标记位和这个结构体的占用内存空间大小。</p><p>person被封装成了结构体对象之后，原先的block函数就变成了</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">__B<span class="function"><span class="title">lock_byref_person_0</span> *person = __cself-&gt;</span>person; <span class="comment">// bound by ref</span></span><br><span class="line">(<span class="function"><span class="title">person</span>-&gt;</span>__<span class="function"><span class="title">forwarding</span>-&gt;</span>person) = __null;</span><br><span class="line">    NSL<span class="function"><span class="title">og</span>((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_250618_mi_0,(person-&gt;</span>__<span class="function"><span class="title">forwarding</span>-&gt;</span>person));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，但我们要改变person指针的值的时候，首先是取出person对象，即<code>__Block_byref_person_0 *person</code>，然后再通过<code>forwarding</code>指针拿到自己，再拿到最里面的person，最后就可以修改了。</p><ol><li><p>通过内存打印，我们可以得知<code>__Block_byref_person_0</code>内的person对象和外部的person对象的地址是一致的，所以我们在block内修改外部的person就是相当于修改<code>__Block_byref_person_0</code>内的person对象</p></li><li><p>为什么要绕一个圈，不直接<code>person-&gt;person</code>而是要<code>person-&gt;__forwarding-&gt;person</code>？原因是防止block从栈复制到堆之后，栈上面的block访问person访问到的是栈上的person而不是堆上的person，所以栈上的forwarding指针要指向堆的block，这样子就能一直访问到堆上的person了</p></li><li><p>封装的<code>__Block_byref_person_0</code>结构体内的<code>__Block_byref_id_object_copy</code>函数会管理他自己的person对象的内存，实现代码如下:<br> <code>_Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);</code>，这里的40是person对象的偏移值，可以看到结构体内person前面的4个指针加2个整型刚好40个字节。</p></li><li><p><code>__Block_byref_person_0</code>在<code>__main_block_impl_0</code>内必定是强引用，跟我们上面所说的不一样，就算在<code>__block</code>之前再添加<code>__weak</code>修饰，<code>__Block_byref_person_0</code>在<code>__main_block_impl_0</code>内依旧是强引用，加上<code>__weak</code>修饰受影响的只有<code>__Block_byref_person_0</code>内的person指针的引用方式</p></li></ol><blockquote><p>注意：MRC环境下，__block 不会对变量造成强引用，即以下情况person会提前释放</p></blockquote>  <figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="built_in">block</span> Person *person = [Person new];</span><br><span class="line"><span class="keyword">void</span>(^<span class="built_in">block</span>)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;%@&quot;</span>,person);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">block</span>(); <span class="comment">/// 这时候person已经释放了</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：__block只能用于修饰auto变量，不能修饰全局变量和静态（static）变量</p></blockquote><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><h3 id="循环引用的发生原因与解决方式"><a href="#循环引用的发生原因与解决方式" class="headerlink" title="循环引用的发生原因与解决方式"></a>循环引用的发生原因与解决方式</h3><ul><li><p>以下代码会产生循环引用</p>  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Person </span>: NSObject</span><br><span class="line"> <span class="variable">@property</span> (nonatomic, copy) void(^block)(void);</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>  <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Person</span> *<span class="keyword">person</span> = <span class="comment">[Person alloc]</span> init];</span><br><span class="line"><span class="keyword">person</span>.age = 10;</span><br><span class="line"><span class="keyword">person</span>.block = ^&#123;</span><br><span class="line">NSLog(@<span class="string">&quot;age is %d&quot;</span>,<span class="keyword">person</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  原因是person.block捕获了person，person又持有着block，也就是block内部对person存在一个强引用，person对block也存在一个强引用，所以均无法释放。</p></li><li><p>在定义person指针的时候添加<code>__weak</code>修饰符或者<code>__unsafe_unretain</code>修饰符，就可以让block在捕获person的时候弱引用person，这样子就不会造成循环引用了.</p>  <img src="https://z3.ax1x.com/2021/06/13/2I2lPU.png" alt="2I2lPU.png" border="0" width="50%" />  > __weak: 不会产生强引用，指向的对象销毁时，会自动让指针至nil，不支持MRC > __unsafe_unretain: 不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变，变成野指针，支持MRC</li><li><p>在定义person指针的时候添加<code>__block</code>修饰符也可以解决循环引用问题，但前提是需要调用block并手动将person指针置为nil，如下</p>  <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">Person</span> *<span class="keyword">person</span> = <span class="comment">[Person alloc]</span> init];</span><br><span class="line"><span class="keyword">person</span>.age = 10;</span><br><span class="line"><span class="keyword">person</span>.block = ^&#123;</span><br><span class="line">NSLog(@<span class="string">&quot;age is %d&quot;</span>,<span class="keyword">person</span>.age);</span><br><span class="line">       <span class="keyword">person</span> = nil;</span><br><span class="line">&#125;;</span><br><span class="line">   <span class="keyword">person</span>.block();</span><br></pre></td></tr></table></figure><p>  为什么这样子可以解决循环引用呢?首先先分析一下内存结构</p><ul><li>peron持有block</li><li>block持有__block对象</li><li>__block持有着person</li><li>peron又持有着block</li><li>…</li></ul><p>  所以这里是三个对象相互持有形成一个三角形关系</p>  <img src="https://z3.ax1x.com/2021/06/13/2IcLXn.png" alt="2IcLXn.png" border="0" width="30%"/>    当block执行，person = nil，解除了`__block`变量对person的引用的时候，循环引用就不再存在了    <img src="https://z3.ax1x.com/2021/06/13/2IgCp4.png" alt="2IgCp4.png" border="0" width="30%"/><ul><li>MRC环境下，由于**__block不会对变量造成强引用**，所以直接用__block修饰指针也可以达到以上效果</li></ul></li></ul><h3 id="为什么block做属性不常用weak而是用copy"><a href="#为什么block做属性不常用weak而是用copy" class="headerlink" title="为什么block做属性不常用weak而是用copy"></a>为什么block做属性不常用weak而是用copy</h3><p>如果上述例子使用weak修饰block的话，那么block会在栈中，block里面的person也会在栈中，所以离开了作用域的话，里面的person就会销毁，从而无法使用。</p><p>如果你希望block做完事情就释放，比如发送一个通知，修改某个单例类的属性，没有引用外部局部变量，那么用weak就可以节约内存空间</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要简述Block、__block的本质是什么东西，文章涉及循环引用等开发常见问题，需要重点关注。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- Category、+load、+initialize和关联对象</title>
    <link href="https://www.arclin.cn/post/2397c268.html"/>
    <id>https://www.arclin.cn/post/2397c268.html</id>
    <published>2021-06-06T14:24:00.000Z</published>
    <updated>2022-07-12T16:51:57.240Z</updated>
    
    <content type="html"><![CDATA[<p>本文简述iOS中分类的底层实现和load方法、initialize方法在类和分类中的调用特性，还有如何通过关联对象的方式给分类添加属性，以及关联对象的底层实现原理</p><span id="more"></span><h2 id="分类（Category）"><a href="#分类（Category）" class="headerlink" title="分类（Category）"></a>分类（Category）</h2><h3 id="先写一个Demo"><a href="#先写一个Demo" class="headerlink" title="先写一个Demo"></a>先写一个Demo</h3><p>新建一个命令行工程，在main.m中写几个类</p><p>父类：写一个run方法</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">Person </span>: NSObject</span><br><span class="line"></span><br><span class="line">- (void)run;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>父类的分类：写一个eat方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>(<span class="title">Test</span>) </span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据经验可知道，现在Peron对象拥有了run方法和eat方法</p><h3 id="分类的底层结构"><a href="#分类的底层结构" class="headerlink" title="分类的底层结构"></a>分类的底层结构</h3><p>输入命令行</p><p><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code></p><p>接下来同级目录下就会多出一个编译后的文件<code>main.cpp</code>，查看后发现<code>Person(Test) </code>分类被编译成了如下变量</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static struct <span class="variable">_category_t</span> <span class="variable">_OBJC_</span>$<span class="variable">_CATEGORY_Person_</span>$<span class="variable">_Test</span> <span class="variable">__attribute__</span> ((used, section (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = </span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;Person&quot;</span>,</span><br><span class="line"><span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_Person,</span></span><br><span class="line">(const struct <span class="variable">_method_list_t</span> *)&amp;<span class="variable">_OBJC_</span>$<span class="variable">_CATEGORY_INSTANCE_METHODS_Person_</span>$<span class="variable">_Test</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个变量的类型是<code>static struct _category_t</code>，名字是<code>_OBJC_$_CATEGORY_Person_$_Test</code>，等于号后面是一个初始化结构体的过程，可以看到要实例化这个结构体需要6个参数，所以查看<code>_category_t</code>的结构如下</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="type">_category_t</span> &#123;</span><br><span class="line">const char *name; <span class="comment">/// 原来的类的名字</span></span><br><span class="line"><span class="keyword">struct</span> <span class="type">_class_t</span> *<span class="keyword">cls</span>; <span class="comment">/// 类对象</span></span><br><span class="line">const <span class="keyword">struct</span> <span class="type">_method_list_t</span> *instance_methods; <span class="comment">/// 实例方法数组</span></span><br><span class="line">const <span class="keyword">struct</span> <span class="type">_method_list_t</span> *class_methods; <span class="comment">/// 类方法数组</span></span><br><span class="line">const <span class="keyword">struct</span> <span class="type">_protocol_list_t</span> *protocols; <span class="comment">/// 遵循的协议数组</span></span><br><span class="line">const <span class="keyword">struct</span> <span class="type">_prop_list_t</span> *properties; <span class="comment">/// 属性数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由此可知，<strong>分类可以定义实例方法，可以定义类方法，可以遵循协议，可以添加属性，但是不能添加成员变量！因为分类的结构里面没有存储成员变量的地方.</strong></p><h3 id="程序通过runtime动态将分类合并到类对象、元类对象中"><a href="#程序通过runtime动态将分类合并到类对象、元类对象中" class="headerlink" title="程序通过runtime动态将分类合并到类对象、元类对象中"></a>程序通过runtime动态将分类合并到类对象、元类对象中</h3><p>分类中的方法是在运行时才添加到类对象和元类对象中的，而不是编译的时候添加的，编译之后只是多了几个类型为<code>_category_t</code>的结构体变量。</p><p>合并的过程可以在runtime源码（objc4-818.2）中<code>objc-runtime-new.mm</code>的<code>load_categories_nolock</code>函数中看到，这里不展开流程，直接说结论。</p><p>合并过程是这样子的，首先我们知道原来的类（我们就叫他主类吧）对象是存放着成员方法的，主类的元类对象是放着类方法的，因为类对象和元类对象结构是一样的，所以我们就讨论成员方法就好了。</p><p>其次呢，runtime先根据分类方法的数量在数组里面开辟空间，然后把分类方法塞到原来的成员方法数组的前端，这样子合并就完成了，其他类方法、协议、属性等数组，也是同样的过程。</p><p>所以最后在<strong>类对象的方法列表数组里面，排在前面的是分类方法，后面才是主类的方法。如果有多个分类的话，那么后编译的分类的成员方法会插在数组的前面（因为插入数组的时候是倒序插入）</strong>。</p><p>有了上述结论 我们就可以解释很多事情了。</p><h4 id="如果分类实现了主类的方法会怎么样"><a href="#如果分类实现了主类的方法会怎么样" class="headerlink" title="如果分类实现了主类的方法会怎么样"></a>如果分类实现了主类的方法会怎么样</h4><p>根据上述结论，系统在找对应的调用方法的时候，会先找到分类的方法，所以主类的方法没有机会被调用到。</p><h4 id="如果多个分类都实现了同个主类的方法"><a href="#如果多个分类都实现了同个主类的方法" class="headerlink" title="如果多个分类都实现了同个主类的方法"></a>如果多个分类都实现了同个主类的方法</h4><p>根据上述结论，后编译的分类的成员方法会插在方法列表的前面，所以谁后编译，就调用谁</p><h4 id="如果子类或者子类的分类实现了父类的分类方法"><a href="#如果子类或者子类的分类实现了父类的分类方法" class="headerlink" title="如果子类或者子类的分类实现了父类的分类方法"></a>如果子类或者子类的分类实现了父类的分类方法</h4><p>根据上述结论和结合我们以前所学知识，最后子类实例对象会去子类的类对象里面寻找方法并调用，使用<code>super</code>关键字调用方法的话，则会去到父类的类对象内找方法。</p><h3 id="Category跟Class-Extension的区别"><a href="#Category跟Class-Extension的区别" class="headerlink" title="Category跟Class Extension的区别"></a>Category跟Class Extension的区别</h3><ul><li>Class Extension是编译的时候，它的数据就已经包含在类信息中</li><li>Category 是在运行时才会讲数据合并到类信息中</li></ul><h2 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h2><h3 id="先写一个Demo-1"><a href="#先写一个Demo-1" class="headerlink" title="先写一个Demo"></a>先写一个Demo</h3><p>父类：实现load方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Person load&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>父类的分类：实现load方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span>(<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Person Text load&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子类：实现load方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Student load&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子类的分类：实现load方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span>(<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Student Test load&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="load方法的调用时机"><a href="#load方法的调用时机" class="headerlink" title="load方法的调用时机"></a>load方法的调用时机</h3><p>通过runtime源码（objc4-818.2）<code>objc-runtime-new.mm</code>第3233行得知，load方法是在加载镜像(load_images)的时候调用的。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void load<span class="constructor">_images(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">path</span> <span class="params">__unused</span>, <span class="params">const</span> <span class="params">struct</span> <span class="params">mach_header</span> <span class="operator">*</span><span class="params">mh</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!didInitialAttachCategories<span class="operator"> &amp;&amp; </span>didCallDyldNotifyRegister) &#123;</span><br><span class="line">        didInitialAttachCategories = <span class="literal">true</span>;</span><br><span class="line">        load<span class="constructor">AllCategories()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!has<span class="constructor">LoadMethods((<span class="params">const</span> <span class="params">headerType</span> <span class="operator">*</span>)</span>mh)) return;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock2(runtimeLock);</span><br><span class="line">        prepare<span class="constructor">_load_methods((<span class="params">const</span> <span class="params">headerType</span> <span class="operator">*</span>)</span>mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call<span class="constructor">_load_methods()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>补充小细节：从<code>load_images</code>函数可以看到，加载分类<code>loadAllCategories()</code>早于调用load方法<code>call_load_methods()</code>，也就是元类对象中的类方法列表内，分类的load方法会在主类的load方法之前</p></blockquote><p>在调用load方法之前，首先要通过<code>prepare_load_methods</code>函数整理出一个数组，这个数组会决定主类的load方法的调用顺序</p><p>从<code>prepare_load_methods</code>函数中调用的<code>schedule_class_load</code>函数的内部实现我们可以知道，父类会先被加入到数组中，其次才是主类。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/<span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">*</span> prepare<span class="emphasis">_load_</span>methods</span></span><br><span class="line"><span class="strong"><span class="emphasis">* Schedule +load for classes in this image, any un-+load-ed </span></span></span><br><span class="line"><span class="strong"><span class="emphasis">*</span> superclasses in other images, and any categories in this image.</span></span><br><span class="line"><span class="strong">**</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span>/</span><br><span class="line">// Recursively schedule +load for cls and any un-+load-ed superclasses.</span><br><span class="line">// cls must already be connected.</span><br><span class="line">static void schedule<span class="emphasis">_class_</span>load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    if (!cls) return;</span></span><br><span class="line"><span class="code">    ASSERT(cls-&gt;isRealized());  // _read_images should realize</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    // Ensure superclass-first ordering</span></span><br><span class="line"><span class="code">    schedule_class_load(cls-&gt;getSuperclass());</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    add_class_to_loadable_list(cls);</span></span><br><span class="line"><span class="code">    cls-&gt;setInfo(RW_LOADED); </span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure><p>然后我们回到最开始的地方（load_images），通过<code>objc-loadmethod.mm</code>第337行<code>call_load_methods</code>得知，先调用主类的load方法(call_class_loads())，再调用分类的load方法<code>call_category_loads();</code></p><blockquote><p>补充一个小细节：在整理数组的时候，这个数组里面存放的是一个个结构体，结构体长这样</p></blockquote>  <figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="type">loadable_class</span> &#123;</span><br><span class="line">    Class <span class="keyword">cls</span>;  <span class="comment">// may be nil  这里放元类对象（load是类方法所以存在元类对象里面）</span></span><br><span class="line">    IMP method;  <span class="comment">/// 这里放的是load方法的函数指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="type">loadable_category</span> &#123;</span><br><span class="line">    Category cat;  <span class="comment">// may be nil 这个是上面讲到的category_t类型的对象</span></span><br><span class="line">    IMP method; <span class="comment">/// 这里放的是load方法的函数指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：runtime代码内有记录类的load方法是否曾经被加入到load数组过（RW_LOADED），如果被调用过了，就会跳过，这就是load方法只会执行一次的原因（但是你要是非要手动调用load方法那还是会执行的）</p><p><strong>重要：系统调用load方法不通过消息发送机制</strong>，可以查看<code>objc-loadmethod.mm</code>第177行如下</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/<span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">*</span> call<span class="emphasis">_class_</span>loads</span></span><br><span class="line"><span class="strong"><span class="emphasis">* Call all pending class +load methods.</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">*</span> If new classes become loadable, +load is NOT called for them.</span></span><br><span class="line"><span class="strong"><span class="emphasis">*</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">*</span> Called only by call<span class="emphasis">_load_</span>methods().</span></span><br><span class="line"><span class="strong">**</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span>/</span><br><span class="line">static void call<span class="emphasis">_class_</span>loads(void)</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    int i;</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    // Detach current loadable list.</span></span><br><span class="line"><span class="code">    struct loadable_class *classes = loadable_classes;</span></span><br><span class="line"><span class="code">    int used = loadable_classes_used;</span></span><br><span class="line"><span class="code">    loadable_classes = nil;</span></span><br><span class="line"><span class="code">    loadable_classes_allocated = 0;</span></span><br><span class="line"><span class="code">    loadable_classes_used = 0;</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    // Call all +loads for the detached list.</span></span><br><span class="line"><span class="code">    for (i = 0; i &lt; used; i++) &#123;</span></span><br><span class="line"><span class="code">        Class cls = classes[i].cls;</span></span><br><span class="line"><span class="code">        load_method_t load_method = (load_method_t)classes[i].method;</span></span><br><span class="line"><span class="code">        if (!cls) continue; </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">        if (PrintLoading) &#123;</span></span><br><span class="line"><span class="code">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">        /// 意为直接通过函数指针调用函数</span></span><br><span class="line"><span class="code">        (*load_method)(cls, @selector(load));</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    // Destroy the detached list.</span></span><br><span class="line"><span class="code">    if (classes) free(classes);</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="load方法的调用顺序"><a href="#load方法的调用顺序" class="headerlink" title="load方法的调用顺序"></a>load方法的调用顺序</h3><p>综上所述，分类也有load方法。调用顺序是：先调用父类load方法，再调用子类load方法，最后调用分类的load方法，如果有多个分类，那么先编译的，先调用。</p><p>所以上述Demo代码执行后输出结果为</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person <span class="keyword">load</span></span><br><span class="line">Student <span class="keyword">load</span></span><br><span class="line">Person Test <span class="keyword">load</span></span><br><span class="line">Student Test <span class="keyword">load</span></span><br></pre></td></tr></table></figure><p>这里Person比Student先调用是因为他是父类，Person(Test)比Student(Test)先调用是因为它先编译</p><h3 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a>综上所述</h3><p>于是我们可以解答下面的问题</p><ol><li>类和分类都有+load方法</li><li>根据编译顺序，先调用父类+load，再调用子类+load，再调用分类+load(看编译顺序)</li><li>因为系统调用load方法时不通过消息发送机制，所以不存在子类load方法覆盖父类load方法的情况，但是，如果手动调用load方法（即通过消息发送机制调用方法），那么这时候就有继承的现象发生了，也就是子类会覆盖父类方法的实现。</li></ol><p>搞点复杂的事情</p><ol><li>父类实现，父类分类实现，子类不实现，子类分类实现<br/><br> 顺序：父类load，子类分类load、父类分类load<br/><br> 原因：本来应该调用子类load的，无奈子类load没实现，但是找到了子类分类，那么就调用子类分类的load，最后在调用父类分类load(因为分类要最晚调用，由于刚才子类分类被调用过了，所以这里没它事了)<br/><br> <strong>所以：不一定主类的load方法总比分类的load方法早调用，存在特殊情况</strong><br/><br/></li><li>父类不实现，父类分类实现，子类实现，子类分类实现<br/><br> 顺序：父类分类load，子类load，子类分类load<br/><br> 原因：跟上面的理由是一样的，父类没实现但是父类分类找到了那么就调用<br/><br> <strong>所以：父类的分类的load也可以比子类load方法早调用</strong></li></ol><h2 id="initialize方法"><a href="#initialize方法" class="headerlink" title="initialize方法"></a>initialize方法</h2><h3 id="先写个Demo"><a href="#先写个Demo" class="headerlink" title="先写个Demo"></a>先写个Demo</h3><p>父类：实现initialize方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Person initialize&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>父类的分类：实现initialize方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span>(<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Person Text initialize&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子类：实现initialize方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Student initialize&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子类的分类：实现initialize方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span>(<span class="title">Test</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Student Test initialize&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="initialize方法的调用时机"><a href="#initialize方法的调用时机" class="headerlink" title="initialize方法的调用时机"></a>initialize方法的调用时机</h3><ul><li><p><code>+initialize</code>会在类第一次接受到消息的时候调用，即<code>objc_msgSend()</code>被触发的时候调用，这部分是汇编实现</p></li><li><p>runtime源码里面有一个<code>class_getInstanceMethod()</code>函数，用于查找方法，当找到要调用的方法之后，就会调用<code>initialize</code>方法，<code>class_getInstanceMethod()</code>内的主要实现为<code>lookUpImpOrForward()</code>函数的调用</p></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/<span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">*</span> class<span class="emphasis">_getInstanceMethod.  Return the instance method for the</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">* specified class and selector.</span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">**/</span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">Method class<span class="emphasis">_getInstanceMethod(Class cls, SEL sel)</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">&#123;</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">    if (!cls  ||  !sel) return nil;</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">    // This deliberately avoids +initialize because it historically did so.</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">    // This implementation is a bit weird because it&#x27;s the only place that </span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">    // wants a Method instead of an IMP.</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">    Method meth;</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">    meth = _</span>cache<span class="emphasis">_getMethod(cls, sel, _</span>objc<span class="emphasis">_msgForward_</span>impcache);</span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">    if (meth == (Method)1) &#123;</span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">        // Cache contains forward:: . Stop searching.</span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">        return nil;</span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">    &#125; else if (meth) &#123;</span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">        return meth;</span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">    &#125;</span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">        </span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">    // Search method lists, try method resolver, etc.</span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">    lookUpImpOrForward(nil, sel, cls, LOOKUP<span class="emphasis">_INITIALIZE | LOOKUP_</span>RESOLVER);</span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">    meth = <span class="emphasis">_cache_</span>getMethod(cls, sel, <span class="emphasis">_objc_</span>msgForward<span class="emphasis">_impcache);</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">    if (meth == (Method)1) &#123;</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">        // Cache contains forward:: . Stop searching.</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">        return nil;</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">    &#125; else if (meth) &#123;</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">        return meth;</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">    &#125;</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis"></span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">    return _</span>class<span class="emphasis">_getMethod(cls, sel);</span></span></span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong"><span class="emphasis">&#125;</span></span></span></span></span><br></pre></td></tr></table></figure><ul><li><p><code>lookUpImpOrForward()</code>函数实现内，有一判断条件为<code>if(slowpath(!cls-&gt;isInitialized())) &#123; ... &#125;</code> ，若该类已经调用过<code>+initialize</code>，那么就不会再调用，这就是<code>+initialize</code>只被系统调用一次的原因</p></li><li><p>经过一层层点击方法实现（流程见补充），最终我们可以在<code>objc-initialize.mm</code>内发现函数<code>callInitialize(Class cls)</code>，内部实现是<code>objc_msgSend</code>，如下</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">callInitialize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, <span class="meta">@selector(initialize)</span>);</span><br><span class="line">    asm(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>补充：函数调用路径为<code>lookUpImpOrForward</code>-&gt;<code>realizeAndInitializeIfNeeded_locked</code>-&gt;<code>initializeAndLeaveLocked</code>-&gt;<code>initializeAndMaybeRelock</code>-&gt;<code>initializeNonMetaClass</code>-&gt;<code>callInitialize</code><br/>其中：<code>initializeNonMetaClass</code>函数实现内有一个递归，不断地传入<code>superclass</code>指针，去调用父类的<code>initialize</code>方法，直到<code>superclass</code>指针为空（或已经调用过<code>initialize</code>）为止，这就是先调用父类的<code>initialize</code>方法的原因</p></blockquote><h3 id="initialize方法的调用顺序"><a href="#initialize方法的调用顺序" class="headerlink" title="initialize方法的调用顺序"></a>initialize方法的调用顺序</h3><ul><li>先调用父类的<code>initialize</code>方法，再调用子类的<code>initialize</code></li></ul><h3 id="综上所述-1"><a href="#综上所述-1" class="headerlink" title="综上所述"></a>综上所述</h3><ol><li><code>initialize</code>是通过<code>objc_msgSend</code>方式调用的，所以会受分类、继承等等因素影响调用</li><li>如果子类没有实现<code>+initialize</code>，会调用父类的<code>+initiailize</code>（所以父类的<code>+initialize</code>可能会被调用多次）</li><li>如果分类实现了<code>+initialize</code>，就会覆盖主类的<code>+initialize</code>调用</li></ol><h2 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h2><p>假如我们要给一个类添加一个属性如下：<br><br><code>@property (copy, nonatomic) NSString *test;</code></p><h3 id="存值"><a href="#存值" class="headerlink" title="存值"></a>存值</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT <span class="keyword">void</span></span><br><span class="line">objc_setAssociatedObject(<span class="keyword">id</span> _Nonnull object, <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull key,</span><br><span class="line">                         <span class="keyword">id</span> _Nullable value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>解释</th></tr></thead><tbody><tr><td>object</td><td>要关联的对象，如果是在分类内给主类添加属性，那么这里就写<code>self</code></td></tr><tr><td>key</td><td>要用来标记这个属性的key，取值的时候也得靠这个key取</td></tr><tr><td>value</td><td>存储的内容</td></tr><tr><td>policy</td><td>存储策略（见下表）</td></tr></tbody></table><h4 id="objc-AssociationPolicy-存储策略"><a href="#objc-AssociationPolicy-存储策略" class="headerlink" title="objc_AssociationPolicy 存储策略"></a>objc_AssociationPolicy 存储策略</h4><table><thead><tr><th>策略枚举</th><th>对应修饰符</th></tr></thead><tbody><tr><td>OBJC_ASSOCIATION_ASSIGN</td><td>assign</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td>strong, nonatomic</td></tr><tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC</td><td>copy,nonatomic</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN</td><td>strong, atomic</td></tr><tr><td>OBJC_ASSOCIATION_COPY</td><td>copy,atomic</td></tr></tbody></table><blockquote><p>如果要存weak类型的对象怎么办？<br/>创建一个类，用<code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code>标记存在主类中，然后在这个新建的类里面再存放一个weak引用的属性</p></blockquote><h4 id="key有多少种填写形式"><a href="#key有多少种填写形式" class="headerlink" title="key有多少种填写形式"></a>key有多少种填写形式</h4><ol><li>声明全局变量<code>static const void *TestKey = &amp;TestKey;</code>,将<code>TestKey</code>的地址作为key的内容，不能直接写<code>const void *TestKey</code>，因为这么写等共同于<code>const void *TestKey = NULL</code>，要是以后添加别的属性，就会冲突，使用例子：</li></ol>  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc<span class="constructor">_setAssociatedObject(<span class="params">self</span>,TestKey,<span class="params">test</span>,OBJC_ASSOCIATION_COPY_NONATOMIC)</span></span><br></pre></td></tr></table></figure><ol start="2"><li>声明全局变量<code>static const char TestKey</code>，同样将<code>TestKey</code>的地址作为key，好处是<code>char</code>只占用一个字节的内存大小，使用例子：</li></ol>  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc<span class="constructor">_setAssociatedObject(<span class="params">self</span>,&amp;TestKey,<span class="params">test</span>,OBJC_ASSOCIATION_COPY_NONATOMIC)</span></span><br></pre></td></tr></table></figure><ol start="3"><li>因为OC内的字符串都存在常量区，所以通过字面量创建的相同字符串都是同个地址，所以我们也可以随便定义一个字符串去做key，使用例子：</li></ol>  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc<span class="constructor">_setAssociatedObject(<span class="params">self</span>,@<span class="string">&quot;Test&quot;</span>,<span class="params">test</span>,OBJC_ASSOCIATION_COPY_NONATOMIC)</span></span><br></pre></td></tr></table></figure><ol start="4"><li>我们也可以通过使用getter方法的方法编号去做key，使用例子：</li></ol>  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">objc_setAssociatedObject</span>(self,<span class="variable">@selector</span>(test),test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure><h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc<span class="constructor">_getAssociatedObject(<span class="params">id</span> <span class="params">_Nonnull</span> <span class="params">object</span>, <span class="params">const</span> <span class="params">void</span> <span class="operator">*</span> <span class="params">_Nonnull</span> <span class="params">key</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>object同上，一般分类里面就填self</li><li>key属性需要和上面设值的key属性一致</li></ul><ul><li>如果使用getter方法的方法编号去做key，有两种写法<ol><li><code>objc_getAssociatedObject(self, @selector(test))</code></li><li><code>objc_getAssociatedObject(self, _cmd)</code>，<code>_cmd</code>表示当前方法的方法地址</li></ol></li></ul><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p><img src="https://www.hualigs.cn/image/60bd149eb55dc.jpg" alt="图片来源自小码哥教程"></p><ul><li>runtime维护着一个名为<code>AssociationsManager</code>的类</li><li>类里面存放着一个字典，键是传入的对象（object参数），值是<code>ObjectAssociationMap</code>类的实例对象</li><li><code>ObjectAssociationMap</code>是一个字典，键是传入的key参数，值是<code>ObjcAssociation</code>类的实例对象</li><li><code>ObjcAssociation</code>有两个成员变量，<code>_policy</code>存放着传入的policy参数，<code>_value</code>存放着传入的value参数</li></ul><h3 id="综上所述-2"><a href="#综上所述-2" class="headerlink" title="综上所述"></a>综上所述</h3><ol><li>关联对象并不是存储在被关联对象的内存中</li><li>关联对象存储在全局统一的<code>AssociationsManager</code>中</li><li>设置关联对象（object参数）为nil，就相当于是移除关联对象</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文简述iOS中分类的底层实现和load方法、initialize方法在类和分类中的调用特性，还有如何通过关联对象的方式给分类添加属性，以及关联对象的底层实现原理&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- KVC</title>
    <link href="https://www.arclin.cn/post/34b9a649.html"/>
    <id>https://www.arclin.cn/post/34b9a649.html</id>
    <published>2021-05-30T03:59:00.000Z</published>
    <updated>2022-07-12T16:51:57.240Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述KVC的底层实现和KVC是否能触发KVO呢？</p><span id="more"></span><h2 id="KVC的使用"><a href="#KVC的使用" class="headerlink" title="KVC的使用"></a>KVC的使用</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.person <span class="symbol">setValue:</span><span class="variable">@10</span> <span class="symbol">forKey:</span>@<span class="string">&quot;age&quot;</span>]</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.person <span class="symbol">setValue:</span><span class="variable">@10</span> <span class="symbol">forKeyPath:</span>@<span class="string">&quot;age&quot;</span>]</span><br></pre></td></tr></table></figure><p>keyPath和key的区别是，keyPath可以使用路径的方式进行赋值，比如person对象内有cat模型属性，cat对象里面有age属性，那么就可以使用<code>[self.person setValue:@10 forKeyPath:@&quot;cat.age&quot;]</code>的方式使用KVC，而key方式只支持直接访问的方式赋值</p><h2 id="赋值过程"><a href="#赋值过程" class="headerlink" title="赋值过程"></a>赋值过程</h2><p><code>setValue:forKey</code>首先会先寻找<code>setKey:</code>方法，如果找不到，那么就会寻找<code>_setKey:</code>方法，类似下面这样子</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 优先找这个方法</span></span><br><span class="line">- （<span class="built_in">void</span>）setAge:(<span class="built_in">int</span>)age &#123;</span><br><span class="line">_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 找不到上面那个方法的话，就找下面这儿方法</span></span><br><span class="line">- （<span class="built_in">void</span>）_setAge:(<span class="built_in">int</span>)age &#123;</span><br><span class="line">_age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述两个方法都找不到，那么就会去访问类方法<code>+ (BOOL)accessInstanceVariablesDirectly</code>，询问是否允许直接访问成员变量，默认返回YES</p><ul><li><p>如果返回NO的话，那么程序会直接抛出异常<code>exception NSUnknownKeyException, reason:[XXX setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key age</code></p></li><li><p>如果返回YES，那么程序会去直接访问成员变量，查找的顺序是<code>_key、_isKey、key、isKey</code>，类似下面这样子</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    @<span class="keyword">public</span> </span><br><span class="line">    <span class="built_in">int</span> _age;</span><br><span class="line">    <span class="built_in">int</span> _isAge;</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">    <span class="built_in">int</span> isAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果找到了成员变量，那么就直接赋值</li><li>如果找不到成员变量，那么就抛出上述异常</li></ol><h2 id="KVC是否会触发KVO"><a href="#KVC是否会触发KVO" class="headerlink" title="KVC是否会触发KVO"></a>KVC是否会触发KVO</h2><p>由于KVO是通过重写set方法的方式实现的，所以如果KVC找到了属性值并且通过set方法赋值的话，那么就自然会触发KVO</p><p>如果KVC找不到set方法，如果<code>+ (BOOL)accessInstanceVariablesDirectly</code>返回YES的话，那么他去访问成员方法的时候，即便这时候成员方法是没有实现set方法的，KVC依旧会去执行<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>方法，在执行<code>didChangeValueForKey:</code>的时候，自然KVO就被触发了</p><h2 id="valueForKey-的底层原理"><a href="#valueForKey-的底层原理" class="headerlink" title="valueForKey:的底层原理"></a>valueForKey:的底层原理</h2><p><code>valueForKey:</code>首先会根据<code>getKey、key、isKey、_key</code>顺序查找方法，找到了的话就调用，拿到返回值。</p><p>如果没有找到方法，那么就会去访问类方法<code>+ (BOOL)accessInstanceVariablesDirectly</code>，询问是否允许直接访问成员变量，默认返回YES</p><p>如果允许，那么按照<code>_key、_isKey、key、isKey</code>顺序查找成员变量，找到了的话就直接取值，找不到就抛出异常<code>NSUnknownKeyException</code>。</p><p>如果不允许，就抛出异常<code>NSUnknownKeyException</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲述KVC的底层实现和KVC是否能触发KVO呢？&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- KVO</title>
    <link href="https://www.arclin.cn/post/81c45883.html"/>
    <id>https://www.arclin.cn/post/81c45883.html</id>
    <published>2021-05-26T17:06:23.000Z</published>
    <updated>2022-07-12T16:51:57.240Z</updated>
    
    <content type="html"><![CDATA[<p>本文简述KVO的底层实现是怎么一回事</p><span id="more"></span><h1 id="如何使用KVO"><a href="#如何使用KVO" class="headerlink" title="如何使用KVO"></a>如何使用KVO</h1><p>举例</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.person <span class="operator">=</span> [[<span class="type">Person</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"><span class="keyword">self</span>.person.age <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这个配置的值会直接影响监听方法的change字典里面带些什么值给你</span></span><br><span class="line"><span class="type">NSKeyValueObservingOptions</span> options <span class="operator">=</span> <span class="type">NSKeyValueObservingOptionNew</span><span class="operator">|</span><span class="type">NSKeyValueObservingOptionOld</span>;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> keyPath:@<span class="string">&quot;age&quot;</span> options:options context:@<span class="string">&quot;123&quot;</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 当监听对象的属性值发生改变时，就会调用这个方法</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line"><span class="comment">/// 这里的context就是注册监听的时候传入的@“123”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部发生了什么"><a href="#内部发生了什么" class="headerlink" title="内部发生了什么"></a>内部发生了什么</h1><p>系统通过运行时机制，给<code>person</code>对象添加了一个父类，名为<code>NSKVONotifying_Person</code>(其他被监听的对象所生成的类也会遵循这个命名规则)，本质上是将<code>person</code>对象的isa指针指向了这个动态新建的类对象。</p><p>另外，这个新建的类对象是继承自<code>Person</code>的，也就是<code>NSKVONotifying_Person</code>的superclass指针指向了<code>Persond</code>的类对象。</p><h1 id="NSKVONotifying-类内部结构"><a href="#NSKVONotifying-类内部结构" class="headerlink" title="NSKVONotifying_*类内部结构"></a>NSKVONotifying_*类内部结构</h1><ul><li>isa指针</li><li>superclass指针</li><li>setAge:方法  因为监听的是age属性，所以重写了setAge方法，若监听的属性没有set方法，或者值改变的时候没有调用set方法，那么KVO无法生效</li><li>class:方法，主要是为了防止对象调用class方法的时候得到了这个动态生成的类对象，所以重写class方法，返回真正<code>的Person</code>类对象</li><li>_isKVOA方法，返回一个bool，用来判断这是不是一个KVO类</li><li>dealloc 进行一些收尾工作</li></ul><h2 id="重写的set方法的实现"><a href="#重写的set方法的实现" class="headerlink" title="重写的set方法的实现"></a>重写的set方法的实现</h2><p>大概是这么实现的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age &#123;</span><br><span class="line">   _NSSetIntValueAnyNotify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _NSSetIntValueAnyNotify() </span><br><span class="line">&#123;</span><br><span class="line">   [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">   [<span class="keyword">super</span> setAge:age];</span><br><span class="line">   [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">   [observer observeValueForKeyPath:key ofObject:<span class="keyword">self</span> change:<span class="literal">nil</span> context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的方法<code>_NSSetIntValueAnyNotify</code>，看具体监听的属性类型而定，如果监听的是<code>double</code>类型，那么方法就会变成<code>_NSSetDoubleValueAnyNotify</code>，所以系统内置了很多这种类似的方法，统称为<code>_NSSet*ValueAnyNotify</code></p><ul><li><p>调用流程</p><ol><li>willChangeValueForKey:</li><li>setAge:</li><li>observeValueForKeyPath:ofObject:change:context:</li><li>didChangeValueForKey:</li></ol></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>利用Runtime API动态生成一个之类，并且让instance对象的isa指针指向这个全新的子类</p></li><li><p>当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAnyNotify函数</p><ul><li>willChangeValueForKey:</li><li>父类原来的setter</li><li>didChangeValueForKey:<ul><li>内部会触发监听器（Observer）的监听方法（observeValueForKeyPath:ofObject:change:context:）</li></ul></li></ul></li><li><p>如何手动触发KVO<br>  注册监听后，手动调用<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p></li><li><p>直接修改成员属性的值不会触发KVO，必须在前后分别补上<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文简述KVO的底层实现是怎么一回事&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
