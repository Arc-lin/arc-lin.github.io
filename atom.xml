<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arclin</title>
  
  <subtitle>Advocate Technology. Enjoy Technology.</subtitle>
  <link href="https://www.arclin.cn/atom.xml" rel="self"/>
  
  <link href="https://www.arclin.cn/"/>
  <updated>2025-06-14T08:04:36.475Z</updated>
  <id>https://www.arclin.cn/</id>
  
  <author>
    <name>Arclin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS测试覆盖率方案</title>
    <link href="https://www.arclin.cn/post/afcee0be.html"/>
    <id>https://www.arclin.cn/post/afcee0be.html</id>
    <published>2025-06-08T06:01:21.000Z</published>
    <updated>2025-06-14T08:04:36.475Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述iOS测试覆盖率方案</p><span id="more"></span><h1 id="编译参数注入"><a href="#编译参数注入" class="headerlink" title="编译参数注入"></a>编译参数注入</h1><p>LLVM本身自带覆盖率插桩工具，只要编译参数中添加指定参数，即可在编译期间插桩，得到代码执行情况。<br>具体操作</p><p>Other C Flags添加参数<code>-sanitize-coverage=func,trace-pc-guard</code></p><p><img src="https://i0.hdslb.com/bfs/openplatform/649c8ece6b26f9e8081109dd19db9396b4cf0e51.png"></p><p>Other Swift Flags添加参数<code>-sanitize-coverage=func</code> 和 <code>-sanitize=undefined</code></p><p><img src="https://i0.hdslb.com/bfs/openplatform/1de410d8ba52156213590cc0aca07da4958570a1.png"></p><p>找个地方实现插桩方法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="keyword">uint32_t</span> *start, <span class="keyword">uint32_t</span> *stop) &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">uint64_t</span> N;  <span class="comment">// Counter for the guards.</span></span><br><span class="line">  <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;  <span class="comment">// Initialize only once.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;INIT: %p %p\n&quot;</span>, start, stop);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> *x = start; x &lt; stop; x++)</span><br><span class="line">    *x = ++N;  <span class="comment">// Guards should start from 1.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard(<span class="keyword">uint32_t</span> *guard) &#123;</span><br><span class="line">  <span class="keyword">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">  Dl_info info;</span><br><span class="line">  <span class="built_in">dladdr</span>(PC, &amp;info);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fname=%s \nfbase=%p \nsname=%s\nsaddr=%p \n\n&quot;</span>,info.dli_fname,info.dli_fbase,info.dli_sname,info.dli_saddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们随便写个Demo, 比如写个tableView, 然后再didSelect回调里面打断点，进入汇编页面，看看插桩是否成功<br><img src="https://i0.hdslb.com/bfs/openplatform/f8d67de756ee0b7c24ea24607247e3e4fc5393ed.png"></p><p>可以看出，插桩成功，程序在调用didSelect之前，会先调用<code>__sanitizer_cov_trace_pc_guard</code><br>简单分析汇编代码插入函数位置，可以得到每个“代码块”都有对应的插桩函数</p><p><img src="https://i0.hdslb.com/bfs/openplatform/9c1748ace00bcb46d3396caaa2b05bde696673ec.png"></p><p>再对Swift插桩进行验证，同样发现了插桩代码<code>__sanitizer_cov_trace_pc_guard</code><br><img src="https://i0.hdslb.com/bfs/openplatform/0444804fdca84a209ca42464da2bb27d8ef47854.png"><br><img src="https://i0.hdslb.com/bfs/openplatform/3bfebb3f119177eaf3f37e59cdf7850a7b00e98a.png"></p><p>由此可以得出结论，OC与Swift都可以通过插桩方式拿到回调</p><h1 id="获取测试覆盖率数据"><a href="#获取测试覆盖率数据" class="headerlink" title="获取测试覆盖率数据"></a>获取测试覆盖率数据</h1><p>1.先声明几个LLVM关键函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROFILE_INSTRPROFILING_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROFILE_INSTRPROFILING_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://clang.llvm.org/docs/SourceBasedCodeCoverage.html</span></span><br><span class="line"><span class="keyword">int</span> __llvm_profile_runtime = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> __llvm_profile_initialize_file(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *__llvm_profile_get_filename(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">void</span> __llvm_profile_set_filename(<span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line"><span class="keyword">int</span> __llvm_profile_write_file(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">int</span> __llvm_profile_register_write_file_atexit(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *__llvm_profile_get_path_prefix(<span class="keyword">void</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* PROFILE_INSTRPROFILING_H_ */</span></span></span><br></pre></td></tr></table></figure><p>2.指定覆盖率数据文件的输出路径,建议在程序启动时调用</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;\(moduleName).profraw&quot;</span></span><br><span class="line"><span class="keyword">let</span> fileManager = <span class="module-access"><span class="module"><span class="identifier">FileManager</span>.</span></span>default</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> documentDirectory = <span class="keyword">try</span> fileManager.url(<span class="keyword">for</span>: .documentDirectory, <span class="keyword">in</span>: .userDomainMask, appropriateFor:nil, create:<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">let</span> filePath: NSString = documentDirectory.appending<span class="constructor">PathComponent(<span class="params">name</span>)</span>.path <span class="keyword">as</span> NSString</span><br><span class="line">    <span class="constructor">__llvm_profile_set_filename(<span class="params">filePath</span>.<span class="params">utf8String</span>)</span></span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    print(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在合适的时机调用<code>__llvm_profile_write_file()</code>写入覆盖率数据，如切后台，退出app时等。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>sceneDidEnterBackground:<span class="params">(UIScene *)</span>scene &#123;</span><br><span class="line">    __llvm_profile_write_file<span class="params">()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="生成测试覆盖率报告"><a href="#生成测试覆盖率报告" class="headerlink" title="生成测试覆盖率报告"></a>生成测试覆盖率报告</h1><p>测试app:</p><p>启动app, 进行操作，然后进入后台。</p><p>在控制台可以看到生成的数据路径：</p><p><code>/Users/arclin/Library/Developer/CoreSimulator/Devices/EEFDE0CE-9572-4D0D-B5F8-5ED4D6F6362C/data/Containers/Data/Application/F9FB0C18-AEE6-404A-B97A-5C6FEEE3B15C/Documents/Demo.profraw</code></p><p>收集Demo.profraw、app产物、转换脚本，放在文件夹里，结构如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tree -L <span class="number">2</span></span><br><span class="line">.</span><br><span class="line">├── MachOFiles</span><br><span class="line">│   └── <span class="module-access"><span class="module"><span class="identifier">Demo</span>.</span></span>app</span><br><span class="line">├── gitdiff</span><br><span class="line">│   └── utils</span><br><span class="line">│    └── diffParser.rb</span><br><span class="line">│    └── trollop.rb</span><br><span class="line">├── <span class="module-access"><span class="module"><span class="identifier">Demo</span>.</span></span>profraw</span><br><span class="line">└── coverage_report.sh</span><br></pre></td></tr></table></figure><p>转换脚本代码coverage_report.sh内容如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">cleanup() &#123;</span><br><span class="line">  echo <span class="string">&quot;清理中间生成的临时文件...&quot;</span></span><br><span class="line">  [ -n <span class="string">&quot;<span class="variable">$profdata_path</span>&quot;</span> ] &amp;&amp; rm -f <span class="string">&quot;<span class="variable">$profdata_path</span>&quot;</span></span><br><span class="line">  [ -n <span class="string">&quot;<span class="variable">$binname</span>&quot;</span> ] &amp;&amp; rm -f <span class="string">&quot;<span class="variable">$&#123;binname&#125;</span>.info&quot;</span></span><br><span class="line">  rm -f gitdiff.diff</span><br><span class="line">  echo <span class="string">&quot;清理完成。&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trap cleanup EXIT</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ]; then</span><br><span class="line">  echo <span class="string">&quot;用法: <span class="variable">$0</span> &lt;profraw文件&gt; [oldCommit]&quot;</span></span><br><span class="line">  exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="attribute">profraw_path</span>=<span class="variable">$1</span></span><br><span class="line"><span class="attribute">profbase</span>=<span class="variable">$&#123;profraw_path%.profraw&#125;</span>   # 去掉 .profraw 后缀</span><br><span class="line"><span class="attribute">profdata_path</span>=<span class="variable">$&#123;profbase&#125;</span>.profdata</span><br><span class="line"></span><br><span class="line">echo <span class="string">&quot;profraw_path: <span class="variable">$profraw_path</span>&quot;</span></span><br><span class="line">echo <span class="string">&quot;profbase: <span class="variable">$profbase</span>&quot;</span></span><br><span class="line">echo <span class="string">&quot;profdata_path: <span class="variable">$profdata_path</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -ge 2 ]; then</span><br><span class="line">  <span class="attribute">oldCommit</span>=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="attribute">oldCommit</span>=$(git rev-parse <span class="attribute">--short</span>=7 HEAD~1)</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 生成 git diff</span></span><br><span class="line"><span class="attribute">currentCommit</span>=$(git rev-parse <span class="attribute">--short</span>=7 HEAD)</span><br><span class="line">git diff <span class="variable">$oldCommit</span> <span class="variable">$currentCommit</span> <span class="attribute">--unified</span>=0 &gt; gitdiff.diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 合并 profraw</span></span><br><span class="line">xcrun llvm-profdata merge -sparse <span class="string">&quot;<span class="variable">$profraw_path</span>&quot;</span> -o <span class="string">&quot;<span class="variable">$profdata_path</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 找到第一个 Mach-O 文件</span></span><br><span class="line"><span class="attribute">macho_bin</span>=$(find ./MachOFiles -type f -exec file &#123;&#125; + | grep <span class="string">&#x27;Mach-O&#x27;</span> | head -n1 | cut -d: -f1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$macho_bin</span>&quot;</span> ]; then</span><br><span class="line">  echo <span class="string">&quot;未找到 Mach-O 二进制文件&quot;</span></span><br><span class="line">  exit 2</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="attribute">binname</span>=$(basename <span class="string">&quot;<span class="variable">$macho_bin</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">echo <span class="string">&quot;macho_bin: <span class="variable">$macho_bin</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 导出 lcov</span></span><br><span class="line">xcrun llvm-cov <span class="builtin-name">export</span> <span class="string">&quot;<span class="variable">$macho_bin</span>&quot;</span> <span class="attribute">-instr-profile</span>=<span class="string">&quot;<span class="variable">$profdata_path</span>&quot;</span> <span class="attribute">-format</span>=lcov &gt; <span class="variable">$&#123;binname&#125;</span>.info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 解析增量覆盖率</span></span><br><span class="line">ruby gitdiff/utils/diffParser.rb <span class="attribute">--diff-file</span>=gitdiff.diff <span class="attribute">--coverage-info-file</span>=<span class="variable">$&#123;binname&#125;</span>.info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 生成 html 报告</span></span><br><span class="line">genhtml -o <span class="variable">$&#123;binname&#125;</span>_html ./<span class="variable">$&#123;binname&#125;</span>_gather.<span class="builtin-name">info</span> --ignore-errors category</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 打开报告</span></span><br><span class="line">open <span class="variable">$&#123;binname&#125;</span>_html/index.html</span><br></pre></td></tr></table></figure><p>使用方式</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sh</span> coverage_report.sh Demo.profraw acf<span class="number">2</span>d<span class="number">5</span>a</span><br></pre></td></tr></table></figure><p>其中<code>acf2d5a</code>是你要比较的上一次commit id</p><p>以上这段脚本，会比较当前commit id与 指定的旧commitID的diff， 保存成一个gitdiff.diff文件</p><p>然后把测试覆盖率源文件进行两次转换转成可读的info文件，info文件里面会包含所有代码的测试覆盖情况。</p><p>然后把info文件和gitdiff文件通过ruby脚本进行匹配，筛选出diff代码的测试覆盖情况，然后生成新的info文件。</p><p>匹配时需要了解info文件里面的符号所代表的含义</p><table><thead><tr><th>标识符及描述</th><th>备注</th></tr></thead><tbody><tr><td><strong>SF</strong>: <code>&lt;absolute path to the source file&gt;</code></td><td>文件的绝对路径</td></tr><tr><td><strong>FN</strong>: <code>&lt;line number of function start&gt;,&lt;function name&gt;</code></td><td>方法的开始行数</td></tr><tr><td><strong>FNDA</strong>: <code>&lt;execution count&gt;,&lt;function name&gt;</code></td><td>该方法执行的次数</td></tr><tr><td><strong>FNF</strong>: <code>&lt;number of functions found&gt;</code></td><td>该方法被发现的次数</td></tr><tr><td><strong>FNH</strong>: <code>&lt;number of function hit&gt;</code></td><td>该方法被命中次数（疑惑）</td></tr><tr><td><strong>DA</strong>: <code>&lt;line number&gt;,&lt;execution count&gt;[,&lt;checksum&gt;]</code></td><td>代码行数，该行代码执行的次数</td></tr><tr><td><strong>LH</strong>: <code>&lt;number of lines with a non-zero execution count&gt;</code></td><td>可执行的代码总行数，行代码覆盖率的分母</td></tr><tr><td><strong>LF</strong>: <code>&lt;number of instrumented lines&gt;</code></td><td>执行到的代码总行数，行代码覆盖率的分子</td></tr></tbody></table><p>核心ruby代码内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">require &#39;json&#39;</span><br><span class="line">require_relative &#39;trollop&#39;</span><br><span class="line"></span><br><span class="line">module GitUtil</span><br><span class="line">    def white_adpator(line, white_list)</span><br><span class="line">        # 注意：使用该代码获取文件名，会在后面多一个换行符，这里需要剔除换行符</span><br><span class="line">        extn &#x3D; File.extname(line).delete!(&quot;\n&quot;)</span><br><span class="line">        white_list.map &#123; |item|</span><br><span class="line">            if item &#x3D;&#x3D; extn</span><br><span class="line">                return true</span><br><span class="line">            end</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    def code_diff_map(diff_file, white_list)</span><br><span class="line">        file_map &#x3D; &#123;&#125;</span><br><span class="line">        current_file &#x3D; nil</span><br><span class="line">        # 是否是白名单格式的文件</span><br><span class="line">        whiteFile &#x3D; false</span><br><span class="line"></span><br><span class="line">        File.open(diff_file).each do |line|</span><br><span class="line">            # 新的文件改动标识</span><br><span class="line">            if line.start_with? &#39;diff --git&#39;</span><br><span class="line">                # 判断是白名单格式的文件</span><br><span class="line">                if white_adpator(line, white_list)</span><br><span class="line">                    whiteFile &#x3D; true</span><br><span class="line">                    next</span><br><span class="line">                else</span><br><span class="line">                    whiteFile &#x3D; false</span><br><span class="line">                    next</span><br><span class="line">                end</span><br><span class="line">            end</span><br><span class="line"></span><br><span class="line">            if whiteFile &#x3D;&#x3D; false</span><br><span class="line">                next</span><br><span class="line">            end</span><br><span class="line"></span><br><span class="line">            if line.start_with? &#39;+++&#39;</span><br><span class="line">                # 提取文件路径</span><br><span class="line">                file_path &#x3D; line[&#x2F;\&#x2F;.*&#x2F;, 0][1..-1]</span><br><span class="line">                if file_path</span><br><span class="line">                    current_file &#x3D; file_path</span><br><span class="line">                    file_map[current_file] &#x3D; []</span><br><span class="line">                end</span><br><span class="line">            end</span><br><span class="line"></span><br><span class="line">            if line.start_with? &#39;@@&#39;</span><br><span class="line">                # 提取新增代码行，格式为 &quot; +66,5&quot;</span><br><span class="line">                change &#x3D; line[&#x2F;\+.*?\s&#123;1&#125;&#x2F;, 0]</span><br><span class="line">                # 消除&quot;+&quot;</span><br><span class="line">                change &#x3D; change[1..-1]</span><br><span class="line">                # flat</span><br><span class="line">                if change.include? &#39;,&#39;</span><br><span class="line">                    base_line &#x3D; change.split(&#39;,&#39;)[0].to_i</span><br><span class="line">                    delta &#x3D; change.split(&#39;,&#39;)[1].to_i</span><br><span class="line">                    delta.times &#123; |i| file_map[current_file].push(base_line + i) if current_file&#125;</span><br><span class="line">                else</span><br><span class="line">                    file_map[current_file].push(change.to_i) if current_file</span><br><span class="line">                end</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        diff_file_path &#x3D; File.dirname(diff_file)</span><br><span class="line">        diff_file_name &#x3D; File.basename(diff_file, &quot;.*&quot;)</span><br><span class="line">        diff_json_file_path &#x3D; &quot;#&#123;diff_file_path&#125;&#x2F;#&#123;diff_file_name&#125;.json&quot;</span><br><span class="line">        diff_json_file &#x3D; File.new(diff_json_file_path, &quot;w+&quot;)</span><br><span class="line">        diff_json_file.syswrite(file_map.to_json)</span><br><span class="line"></span><br><span class="line">        return file_map</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    def gatherCoverageInfo(coverage_info_file, file_map)</span><br><span class="line">        gather_file &#x3D; false</span><br><span class="line">        gather_file_lines &#x3D; []</span><br><span class="line">        coverage_info_path &#x3D; File.dirname(coverage_info_file)</span><br><span class="line">        coverage_file_name &#x3D; File.basename(coverage_info_file, &quot;.*&quot;)</span><br><span class="line">        coverage_gather_file_path &#x3D; &quot;#&#123;coverage_info_path&#125;&#x2F;#&#123;coverage_file_name&#125;_gather.info&quot;</span><br><span class="line">        puts &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line">        puts &quot;coverage_info_path: #&#123;coverage_info_path&#125;&quot;</span><br><span class="line">        puts &quot;coverage_info_file: #&#123;coverage_info_file&#125;&quot;</span><br><span class="line">        puts &quot;coverage_gather_file_path: #&#123;coverage_gather_file_path&#125;&quot;</span><br><span class="line">        # puts file_map</span><br><span class="line">        puts &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line">        coverage_gather_file &#x3D; File.new(coverage_gather_file_path, &quot;w+&quot;)</span><br><span class="line">        File.open(coverage_info_file).each do |line|</span><br><span class="line">            # 代码覆盖率info的文件开头标识</span><br><span class="line">            if line.start_with? &#39;SF:&#39;</span><br><span class="line">                # 获取文件名称，包含后缀</span><br><span class="line">                gather_file &#x3D; false</span><br><span class="line">                basen &#x3D; File.basename(line).delete!(&quot;\n&quot;)</span><br><span class="line">                # puts &quot;basen:#&#123;basen&#125;&quot;</span><br><span class="line">                file_map.each_key &#123; |key|</span><br><span class="line">                    if key.to_s.include?(&quot;&#x2F;&quot;)</span><br><span class="line">                        last_key &#x3D; key.split(&quot;&#x2F;&quot;)[1]</span><br><span class="line">                    end</span><br><span class="line">                    if last_key &#x3D;&#x3D; basen</span><br><span class="line">                        gather_file &#x3D; true</span><br><span class="line">                        gather_file_lines &#x3D; file_map[key]</span><br><span class="line">                        coverage_gather_file.syswrite(line)</span><br><span class="line">                        # puts &quot;gather_file:#&#123;gather_file&#125;&quot;</span><br><span class="line">                        # puts &quot;gather_file_lines:#&#123;gather_file_lines&#125;&quot;</span><br><span class="line">                        next</span><br><span class="line">                    end</span><br><span class="line">                &#125;</span><br><span class="line">            end</span><br><span class="line"></span><br><span class="line">            if gather_file &#x3D;&#x3D; false</span><br><span class="line">                next</span><br><span class="line">            end</span><br><span class="line"></span><br><span class="line">            # 该类中的每一行信息的标识</span><br><span class="line">            # DA:20,1</span><br><span class="line">            if line.start_with? &#39;DA:&#39;</span><br><span class="line">                line_number &#x3D; line.split(&quot;DA:&quot;)[1]</span><br><span class="line">                real_line &#x3D; line_number.split(&quot;,&quot;)[0].to_i</span><br><span class="line">                # puts &quot;gather_file_lines:#&#123;gather_file_lines&#125;&quot;</span><br><span class="line">                # puts &quot;real_line: #&#123;real_line&#125;&quot;</span><br><span class="line">                if gather_file_lines.include?(real_line)</span><br><span class="line">                    # puts &quot;gather_line: #&#123;line&#125;&quot;</span><br><span class="line">                    coverage_gather_file.syswrite(line)</span><br><span class="line">                end</span><br><span class="line">            else</span><br><span class="line">                coverage_gather_file.syswrite(line)</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        return coverage_gather_file</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if __FILE__ &#x3D;&#x3D; $0</span><br><span class="line">    include GitUtil</span><br><span class="line">    </span><br><span class="line">    opts &#x3D; Trollop::options do</span><br><span class="line">        opt :diff_file, &#39;Path for diff file&#39;, :type &#x3D;&gt; :string</span><br><span class="line">        opt :coverage_info_file, &#39;Path for covage info file&#39;, :type &#x3D;&gt; :string</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    Trollop::die :diff_file, &#39;must be provided&#39; if opts[:diff_file].nil?</span><br><span class="line">    Trollop::die :coverage_info_file, &#39;must be provided&#39; if opts[:coverage_info_file].nil?</span><br><span class="line"></span><br><span class="line">    white_list &#x3D; [&#39;.m&#39;, &#39;.mm&#39;, &#39;.swift&#39;]</span><br><span class="line">    # 通过git diff获取简洁可用的增量信息 file_map</span><br><span class="line">    file_map &#x3D; GitUtil.code_diff_map(opts[:diff_file], white_list)</span><br><span class="line">    # 结合file_map 和覆盖率文件，得到增量覆盖率文件</span><br><span class="line">    coverage_gather_file &#x3D; GitUtil.gatherCoverageInfo(opts[:coverage_info_file], file_map)</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>trollop.rb代码参考：<a href="https://github.com/JerryChu/UnitTestParser/blob/master/trollop.rb">trollop.rb</a></p><h1 id="转换结果"><a href="#转换结果" class="headerlink" title="转换结果"></a>转换结果</h1><p>oc和swift都可以检查覆盖率</p><p><img src="https://i0.hdslb.com/bfs/openplatform/8d2b6adc8f3255f44ba9911f717ec88bc9ca22be.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.cn/post/7049973143007395877">https://juejin.cn/post/7049973143007395877</a></p><p><a href="https://github.com/JerryChu/UnitTestParser/tree/master">https://github.com/JerryChu/UnitTestParser/tree/master</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲述iOS测试覆盖率方案&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="测试" scheme="https://www.arclin.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>纯Swift热修方案</title>
    <link href="https://www.arclin.cn/post/8af9107c.html"/>
    <id>https://www.arclin.cn/post/8af9107c.html</id>
    <published>2025-06-03T09:50:28.000Z</published>
    <updated>2025-06-03T14:49:15.373Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲述纯Swift代码的热更方案调研</p><span id="more"></span><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>先从Swift的方法派发原理进行分析，是否存在hook纯Swift方法的可能性</p><h3 id="直接派发"><a href="#直接派发" class="headerlink" title="直接派发"></a>直接派发</h3><p>编译时确定方法地址，场景如下：</p><ol><li>值类型（Struct 和 Enum）：值类型的方法默认使用直接派发。</li><li>final 方法和类：被 final 修饰的方法或类无法被重写或继承，因此使用直接派发。</li><li>全局函数和静态方法：这些方法在编译时就能确定实现，使用直接派发</li></ol><p>如下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">STestViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="keyword">let</span> animal <span class="operator">=</span> <span class="type">Animal</span>(legs: <span class="number">2</span>)</span><br><span class="line">        animal.eat()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> legs: <span class="type">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">eat</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;eat&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用animal.eat()的时候，访问地址0x109ade990，<br><img src="https://i0.hdslb.com/bfs/openplatform/22bd6f8afb626fe5cf3975774bb2a2a0d5ace0fd.png"></p><p>因为是直接确定了方法地址，所以理论上不可能运行时修改这个地址改为我们的补丁方法，但是可以采用插桩方案（查看下面的”方案选型“）</p><h3 id="函数表派发"><a href="#函数表派发" class="headerlink" title="函数表派发"></a>函数表派发</h3><p>运行时通过虚函数表（vtable）动态查找方法地址，场景：类的非 final 实例方法。<br>简单例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">walk</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> walk&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/openplatform/b322f3b9f4edfeea4fc4d5a607780c5c342d860b.png"></p><p>对应的汇编代码如下</p><p><img src="https://i0.hdslb.com/bfs/openplatform/27b50036ed9239b8e5eb76c7ed93ff0d69159995.png"></p><p>一层层读取发现r13寄存器是Person对象，传递给rax寄存器</p><p><img src="https://i0.hdslb.com/bfs/openplatform/4ac7ef48c4ae371a7c15701a8c9ff655a520918e.png"></p><p>*0x78(%rax)： 从 %rax 指向的地址加上偏移量 0x78 的位置读取一个地址，并调用该地址指向的函数。<br>0x78偏移量指向的是虚表中的walk方法的地址</p><p>这里的0x600000255778就是walk方法地址。<br>由此可以确定，要是能提前修改虚表里面的方法地址，就可以做到方法替换<br>所以尝试，虚表地址替换方案</p><h3 id="消息派发"><a href="#消息派发" class="headerlink" title="消息派发"></a>消息派发</h3><p>即objc_msgSend，场景：@objc dynamic 方法、继承自 NSObject 的类、与 Objective-C 交互的代码<br>业界有很多成熟方案如JSPatch、MongoFix等，这里不展开讨论</p><h2 id="方案选型"><a href="#方案选型" class="headerlink" title="方案选型"></a>方案选型</h2><h3 id="插桩方案"><a href="#插桩方案" class="headerlink" title="插桩方案"></a>插桩方案</h3><p>参考SOT的方案，因为官网已经挂了，所以我们从网上收集到一些他曾经存在的证据和一些截图来分析他的实现方案</p><p>文章1：<a href="https://zhuanlan.zhihu.com/p/654079130">https://zhuanlan.zhihu.com/p/654079130</a> 该文章提到“SOT的工作原理是在编译流程中进行代码注入，为函数增加跳板逻辑代码，这样就能够根据需要跳转到虚拟机中运行补丁代码。”</p><p>截图1：从该截图可以看出，SOT会给所有Swift函数插桩，在函数最前面插入判断语句 （从cmp、jz汇编指令可以看出），判断当前方法是否存在于数组中，如果存在就跳转到插桩函数执行，如果不存在就跳转到1007079F3执行原函数，最后调用1007079FB出栈。<br>中间的call j__sotdlg_475573651764395585应该就是跳转到虚拟机执行补丁方法</p><p><img src="https://i0.hdslb.com/bfs/openplatform/720107ba6407713ab6b872cae4d50b374fd07d5c.png"></p><p>所以我们先看插桩实现是否可行，是否真的可以一次性给所有方法（OC、Swift）插桩，先通过LLVM自带的代码覆盖率插桩进行快速验证（LLVM文档）</p><p>Other C Flags添加参数<code>-sanitize-coverage=func,trace-pc-guard</code></p><p><img src="https://i0.hdslb.com/bfs/openplatform/649c8ece6b26f9e8081109dd19db9396b4cf0e51.png"></p><p>Other Swift Flags添加参数<code>-sanitize-coverage=func</code> 和 <code>-sanitize=undefined</code></p><p><img src="https://i0.hdslb.com/bfs/openplatform/1de410d8ba52156213590cc0aca07da4958570a1.png"></p><p>找个地方实现插桩方法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="keyword">uint32_t</span> *start, <span class="keyword">uint32_t</span> *stop) &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">uint64_t</span> N;  <span class="comment">// Counter for the guards.</span></span><br><span class="line">  <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;  <span class="comment">// Initialize only once.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;INIT: %p %p\n&quot;</span>, start, stop);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> *x = start; x &lt; stop; x++)</span><br><span class="line">    *x = ++N;  <span class="comment">// Guards should start from 1.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard(<span class="keyword">uint32_t</span> *guard) &#123;</span><br><span class="line">  <span class="keyword">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">  Dl_info info;</span><br><span class="line">  <span class="built_in">dladdr</span>(PC, &amp;info);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fname=%s \nfbase=%p \nsname=%s\nsaddr=%p \n\n&quot;</span>,info.dli_fname,info.dli_fbase,info.dli_sname,info.dli_saddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们随便写个Demo, 比如写个tableView, 然后再didSelect回调里面打断点，进入汇编页面，看看插桩是否成功<br><img src="https://i0.hdslb.com/bfs/openplatform/f8d67de756ee0b7c24ea24607247e3e4fc5393ed.png"></p><p>可以看出，插桩成功，程序在调用didSelect之前，会先调用<code>__sanitizer_cov_trace_pc_guard</code><br>简单分析汇编代码插入函数位置，可以得到每个“代码块”都有对应的插桩函数</p><p><img src="https://i0.hdslb.com/bfs/openplatform/9c1748ace00bcb46d3396caaa2b05bde696673ec.png"></p><p>再对Swift插桩进行验证，同样发现了插桩代码<code>__sanitizer_cov_trace_pc_guard</code><br><img src="https://i0.hdslb.com/bfs/openplatform/0444804fdca84a209ca42464da2bb27d8ef47854.png"><br><img src="https://i0.hdslb.com/bfs/openplatform/3bfebb3f119177eaf3f37e59cdf7850a7b00e98a.png"></p><p>控制台输出</p><p><img src="https://i0.hdslb.com/bfs/openplatform/d638fa5b37eafc0ca7b5abe4f1d8094b23a36b62.png"></p><p>由此可以得出结论，OC与Swift都可以通过插桩方式拿到回调<br>当然代码覆盖率这个插得太多了，实际实现的时候我们自己写clang插件在头尾插桩就可</p><p>于是可以做如下尝试，结合JSPATCH实现原理进行操作</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> legs: <span class="type">Int</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">eat</span>()</span> &#123;</span><br><span class="line">         <span class="comment">/// 插桩代码开始</span></span><br><span class="line">         <span class="keyword">if</span> <span class="string">&quot;Animal.eat&quot;</span> <span class="keyword">in</span> <span class="type">Start_PATCH_Array</span> &#123;</span><br><span class="line">            id returnValue <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">            <span class="type">RunJavaScipt</span>(<span class="keyword">self</span>, xxxx, <span class="operator">&amp;</span>returnValue)</span><br><span class="line">            <span class="keyword">return</span> returnValue</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/// 插桩代码结束</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;eat&quot;</span>)</span><br><span class="line">          <span class="comment">/// 插桩代码开始</span></span><br><span class="line">         <span class="keyword">if</span> <span class="string">&quot;Animal.eat&quot;</span> <span class="keyword">in</span> <span class="type">END_PATCHArray</span> &#123;</span><br><span class="line">             id returnValue <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">             <span class="type">RunJavaScipt</span>(<span class="keyword">self</span>, xxxx)</span><br><span class="line">             <span class="keyword">return</span> returnValue</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/// 插桩代码结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理补丁方法void返回值可以参考以下方法，参考文档<a href="">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html</a></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* retType = getReturnType();</span><br><span class="line"><span class="keyword">if</span> (strcmp(retType, <span class="meta">@encode</span>(<span class="keyword">void</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">patch</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方案不是真正的热修复方案，反而是作为全埋点方案更为合适。暂时保留方案待定</p><h3 id="虚表地址替换"><a href="#虚表地址替换" class="headerlink" title="虚表地址替换"></a>虚表地址替换</h3><p>以此为例</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">walk</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(name)</span> walk&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先拿到二进制文件进行Mach-O分析，或者通过nm命令，拿到walk方法的名字<br><img src="https://i0.hdslb.com/bfs/openplatform/d64507acc3e9ab23485364906fc4f311c64de2b6.png"></p><p>编写代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;patch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dlfcn.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">new_walk</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; -- new walk -- &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_memory</span><span class="params">(<span class="keyword">void</span> **ptr, <span class="keyword">void</span> *value)</span> </span>&#123;</span><br><span class="line">    *ptr = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">get_method_address</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;new_walk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">get_class_meta_address</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    Class aclass = <span class="built_in">NSClassFromString</span>(@<span class="string">&quot;DynamicFrameworkDemo.Person&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (__bridge <span class="keyword">void</span> *)aclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">get_method_offset</span><span class="params">(<span class="keyword">void</span> *class)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * raw_method_address = <span class="built_in">dlsym</span>(RTLD_DEFAULT, <span class="string">&quot;$s20DynamicFrameworkDemo6PersonC4walkyyF&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(<span class="keyword">long</span> *)(class+i) == (<span class="keyword">long</span>)raw_method_address) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">patch</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *method_address = &amp;new_walk; <span class="comment">/// 获取补丁方法的地址</span></span><br><span class="line">    <span class="keyword">void</span> *class_meta_address = <span class="built_in">get_class_meta_address</span>(); <span class="comment">// 获取类对象元信息地址</span></span><br><span class="line">    <span class="keyword">long</span> offset = <span class="built_in">get_method_offset</span>(class_meta_address); <span class="comment">// 循环遍历获取偏移量</span></span><br><span class="line">    <span class="built_in">write_memory</span>(class_meta_address+offset, method_address); <span class="comment">/// 函数指针替换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i0.hdslb.com/bfs/openplatform/8ce71b55d0718fce5b1cd4617a25cdad7dcaa606.png"></p><p>成功替换实现<br>可以使用dlsym或者symdl进行C函数指针生成</p><p>Todo: 考虑结合MongoFix动态下发解释能力，实现热修复能力</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上方案均无法过审，只能本地调试使用</p><ol><li>插桩方案可以结合JSPatch实现原理进行替换</li><li>虚表地址替换方案可以结合MongoFix能力进行实现</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>调研一些其他的Swift动态替换方案，为热修方案实现思路</p><h3 id="dynamicReplacement"><a href="#dynamicReplacement" class="headerlink" title="@_dynamicReplacement"></a>@_dynamicReplacement</h3><p>Swift5新增的方法交换装饰器， 前提是被替换方法需要被标记为dynamic</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">sleep</span>()</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;sleep&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@_dynamicReplacement</span>(for: sleep())</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">_replaceRunSomething</span>()</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">&quot;replaced&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person <span class="operator">=</span> <span class="type">Person</span>(name: <span class="string">&quot;Mike&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> string <span class="operator">=</span> person.sleep()</span><br><span class="line"><span class="built_in">print</span>(string)</span><br></pre></td></tr></table></figure><p>以上代码可以打印出被替换的代码</p><p><img src="https://i0.hdslb.com/bfs/openplatform/b644d149489ff652f104561bc1cd435d10308336.png"></p><p>本质是使用了虚函数表派发，通过替换表内函数指针实现替换</p><p><img src="https://i0.hdslb.com/bfs/openplatform/e19ced831727c223fb2e03fe18f7f7685311125a.png"></p><p>对应解释如下：</p><ul><li><code>movq (%r13), %rax</code>：加载对象的类型信息（指向元类型的指针）。</li><li><code>movq 0x12c8f(%rip), %rcx</code>：获取<code>swift_isaMask</code>（用于掩码操作）。</li><li><code>andq (%rcx), %rax</code>：应用掩码得到真正的元类型地址。</li><li><code>callq *0x80(%rax)</code>：从虚表中偏移0x80处取出函数指针并调用。</li></ul><h3 id="值类型的方法替换"><a href="#值类型的方法替换" class="headerlink" title="值类型的方法替换"></a>值类型的方法替换</h3><p>Swift里面的值类型，会有一个隐含的super class, 最终都是继承自NSObject，可以通过如下代码打印出来</p><p><img src="https://i0.hdslb.com/bfs/openplatform/57d416273ba7787d12efed0f70360526124702aa.png"></p><p>所以可以通过给这些值类型添加objc运行时方法，有了运行时方法就能进行方法替换</p><p><img src="https://i0.hdslb.com/bfs/openplatform/ff26c62f5d23a697d96f28d25ffc6e0f540b8b2b.png"></p><h3 id="Method-override"><a href="#Method-override" class="headerlink" title="Method_override"></a>Method_override</h3><p>参考<a href="">https://github.com/rentzsch/mach_override</a>的实现方案，具体思路是在原始函数的汇编里面加个jmp指令，jmp指令会跳到指定函数<br>执行完再跳回来。</p><p>示例代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">original</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;original class function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">exchanged</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;exchanged class function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="type">TestClass</span>()</span><br><span class="line">a.original()</span><br></pre></td></tr></table></figure><p>hook代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> override_instance_method(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> (*landing)(<span class="keyword">void</span> * par);</span><br><span class="line">    <span class="keyword">void</span> (*originalFunctionAddress)(<span class="keyword">void</span> * par);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> (*overrideFunctionAddress)(<span class="keyword">void</span> * par);</span><br><span class="line">    </span><br><span class="line">    *(<span class="keyword">void</span> **) (&amp;originalFunctionAddress) = dlsym(RTLD_DEFAULT,<span class="string">&quot;<span class="subst">$s11DynamicDemo9TestClassC8originalyyF</span>&quot;</span>);</span><br><span class="line">    *(<span class="keyword">void</span> **) (&amp;overrideFunctionAddress) = dlsym(RTLD_DEFAULT,<span class="string">&quot;<span class="subst">$s11DynamicDemo9TestClassC9exchangedyyF</span>&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    mach_override_ptr(originalFunctionAddress, overrideFunctionAddress, (<span class="keyword">void</span>**)&amp;landing);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mach_override_ptr 的三个参数：</p><ol><li>要覆盖函数的指针；</li><li>去覆盖函数的指针；</li><li>可以设置为原函数的指针地址，待mach_override_ptr返回成功，就可以调原函数。</li></ol><p><img src="https://i0.hdslb.com/bfs/openplatform/c09dd83cb81fecce08439553a44ed853a61ae972.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要讲述纯Swift代码的热更方案调研&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="Swift" scheme="https://www.arclin.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙SDK开发探索</title>
    <link href="https://www.arclin.cn/post/7a386413.html"/>
    <id>https://www.arclin.cn/post/7a386413.html</id>
    <published>2024-07-31T14:05:00.000Z</published>
    <updated>2025-06-07T14:30:27.510Z</updated>
    
    <content type="html"><![CDATA[<p>本文简述开发鸿蒙第三方 SDK 的选型以及注意事项</p><span id="more"></span><h2 id="HAP"><a href="#HAP" class="headerlink" title="HAP"></a>HAP</h2><p>Harmony Ability Package</p><p>鸿蒙的 App 可以有多个”窗口“，比如微信作为一个窗口，微信小程序作为另一个窗口，不同的窗口之间有独立的 UIAbility，但是需要保证有一个 Entry<br>每个 HAP 虽然也可以创建多个 ability，但是官方并不推荐，因为即便是分了多个 ability， 也会加载所有在 HAP 内的资源，用多 HAP 的方式就可以按需加载。<br>比如视频中同一个应用同时打开了两个窗口，两个窗口各自有各自的生命周期</p><p>官方推荐多 HAP 应用以一个 entry，多 feature 为结构</p><p><img src="https://i0.hdslb.com/bfs/openplatform/df530614bf07e94f6aca20b48bae633a34465d51.png" alt="流程图"></p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>对应第一个 Empty Ability</p><p><img src="https://i0.hdslb.com/bfs/openplatform/768ae31eed6c2144fdb79786b08918adc81b10f9.png"></p><p>创建新 HAP 后目录结构与 entry 目录结构基本一致</p><p><img src="https://i0.hdslb.com/bfs/openplatform/4dc195566511250f482a0507657ce1c69264663b.png"></p><h3 id="多-HAP-跳转"><a href="#多-HAP-跳转" class="headerlink" title="多 HAP 跳转"></a>多 HAP 跳转</h3><p>参考如下代码进行跳转<br>entry : 页面 1， 使用 want 创建目标位置，通过 startAbility 方法进行跳转</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; common, Want &#125; <span class="keyword">from</span> <span class="string">&#x27;@kit.AbilityKit&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entry</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line">struct Index &#123;</span><br><span class="line">  context = getContext(<span class="built_in">this</span>) <span class="keyword">as</span> common.UIAbilityContext</span><br><span class="line">  <span class="function"><span class="title">build</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">Column</span>(<span class="params">&#123; space: <span class="number">20</span> &#125;</span>)</span> &#123;</span><br><span class="line">      Blank()</span><br><span class="line">      Text(<span class="string">&quot;Ability&quot;</span>)</span><br><span class="line">        .fontSize(<span class="number">30</span>)</span><br><span class="line">        .fontWeight(FontWeight.Medium)</span><br><span class="line">      Button(<span class="string">&quot;跳转到另一个Ability&quot;</span>)</span><br><span class="line">        .onClick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> want: Want = &#123;</span><br><span class="line">            bundleName: <span class="string">&quot;com.example.testsdk&quot;</span>, <span class="comment">// 在项目根目录/AppScope/app.json5可以得到bundleName</span></span><br><span class="line">            abilityName: <span class="string">&quot;SecondEntryAbility&quot;</span> <span class="comment">//在HAP目录/src/main/module.json5中可以得到module.abilities.0.name即为入口abilitiyname</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">this</span>.context.startAbility(want).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;跳转成功&quot;</span>)</span><br><span class="line">          &#125;).catch(<span class="function">(<span class="params">error: <span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`跳转失败: <span class="subst">$&#123;error.message&#125;</span>`</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      Blank()</span><br><span class="line">    &#125;</span><br><span class="line">    .height(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">    .width(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>feature: 页面 2， 添加一个返回按钮，点击销毁当前 Ability，系统会返回上个 HAP</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; common &#125; <span class="keyword">from</span> <span class="string">&#x27;@kit.AbilityKit&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; BusinessError &#125; <span class="keyword">from</span> <span class="string">&#x27;@kit.BasicServicesKit&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entry</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line">struct Index &#123;</span><br><span class="line">  context = getContext(<span class="built_in">this</span>) <span class="keyword">as</span> common.UIAbilityContext</span><br><span class="line">  <span class="function"><span class="title">build</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">Column</span>(<span class="params">&#123; space: <span class="number">20</span> &#125;</span>)</span> &#123;</span><br><span class="line">      Blank()</span><br><span class="line">      Text(<span class="string">&quot;Second Entry&quot;</span>)</span><br><span class="line">        .fontSize(<span class="number">30</span>)</span><br><span class="line">        .fontWeight(FontWeight.Medium)</span><br><span class="line">      Button(<span class="string">&quot;Back&quot;</span>)</span><br><span class="line">        .onClick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.context.terminateSelf(<span class="function">(<span class="params">error: BusinessError</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`terminateSelf failed, code is <span class="subst">$&#123;error.code&#125;</span>, message is <span class="subst">$&#123;error.message&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      Blank()</span><br><span class="line">    &#125;</span><br><span class="line">    .height(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">    .width(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要配置依赖才可以进行跳转</p><p><img src="https://i0.hdslb.com/bfs/openplatform/cb8ea5b70502ad67355ef121aa10fc930c7a8214.png"></p><p>勾选两个 Module</p><p><img src="https://i0.hdslb.com/bfs/openplatform/99d948d26bfc163895c61202d2cc32819cbf46e7.png"></p><blockquote><p>获取 bundleName</p></blockquote><p><img src="https://i0.hdslb.com/bfs/openplatform/b00ed0023db56b08d7613d67f9d12df0397e4407.png"></p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>HAP 不支持导出接口和模块，所以只能作为页面/模块入口来使用</p><h3 id="AppStorage-表现"><a href="#AppStorage-表现" class="headerlink" title="AppStorage 表现"></a>AppStorage 表现</h3><p>AppStorage 是系统提供的应用全局数据共享的单例，使用@StroageLink 或者@StorageProp 可以实现多 Ability 同步，不同 Ability 绑定相同 Key，可以实现实时更新，@StroageLink 则可以实现双向同步</p><h2 id="HAR"><a href="#HAR" class="headerlink" title="HAR"></a>HAR</h2><p>Harmony Archive</p><p>相当于静态库，可以导出接口供其他依赖方使用。按照官方说法，HAR 包会 copy 到各个依赖方，会导致包体有重复内容，内存管理也是独立的，依赖方各自管理各自的 HAR 的内存。</p><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p>对应 Static Library</p><p><img src="https://i0.hdslb.com/bfs/openplatform/52bf6d8c45f365406088240411e809e5e2fa2e30.png"></p><h3 id="提供接口"><a href="#提供接口" class="headerlink" title="提供接口"></a>提供接口</h3><p>每个 HAR 根目录里面都有一个 index.ets, 可以通过类似如下语法导出接口</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> &#123; MainPage &#125; <span class="keyword">from</span> <span class="string">&#x27;./src/main/ets/components/MainPage&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h3><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>如果需要跳转到某个 HAR 的页面，那么需要当前组件添加对该 HAR 的依赖<br>比如被依赖组件名为 HARLibraryA<br>在 oh-package.json5 添加 dependencies</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;@ohos/HARLibraryA&quot;</span>: <span class="string">&quot;file:../HARLibraryA&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HAP-gt-HAR"><a href="#HAP-gt-HAR" class="headerlink" title="HAP -&gt; HAR"></a>HAP -&gt; HAR</h4><h5 id="通过-NavigationStack"><a href="#通过-NavigationStack" class="headerlink" title="通过 NavigationStack"></a>通过 NavigationStack</h5><ol><li>主页和被依赖的页面都需要添加 Navigation 包装一层</li><li>主页需要添加 navDestination 判断字符串确定要跳转的页面</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> struct MainPage &#123;</span><br><span class="line">  <span class="meta">@Consume</span>(<span class="string">&#x27;pathStack&#x27;</span>) pathStack: NavPathStack</span><br><span class="line"></span><br><span class="line">  <span class="meta">@State</span> message: <span class="built_in">string</span> = <span class="string">&#x27;This is HAR Library&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 接收参数  </span></span><br><span class="line">  aboutToAppear(): <span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> params = <span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.pathStack.getParamByName(<span class="string">&quot;HARLibraryA&quot;</span>))    </span><br><span class="line">      <span class="built_in">console</span>.log(para)  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">build</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">NavDestination</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">Column</span>(<span class="params">&#123;space: <span class="number">20</span>&#125;</span>)</span> &#123;</span><br><span class="line">        Blank()</span><br><span class="line">        Text(<span class="built_in">this</span>.message)</span><br><span class="line">          .fontSize(<span class="number">50</span>)</span><br><span class="line">          .fontWeight(FontWeight.Bold)</span><br><span class="line">        Button(<span class="string">&quot;Back&quot;</span>)</span><br><span class="line">          .onClick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">             <span class="built_in">this</span>.pathStack.pop()</span><br><span class="line">          &#125;)</span><br><span class="line">        Blank()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> &#123; MainPage &#125; <span class="keyword">from</span> <span class="string">&#x27;@ohos/HARLibraryA&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line">struct Index &#123;</span><br><span class="line">  <span class="meta">@Provide</span>(<span class="string">&#x27;pathStack&#x27;</span>) pathStack: NavPathStack = <span class="keyword">new</span> NavPathStack()</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Builder</span></span><br><span class="line">  <span class="function"><span class="title">pageMap</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;HARLibraryA&quot;</span>) &#123;</span><br><span class="line">      MainPage()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">build</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">Navigation</span>(<span class="params"><span class="built_in">this</span>.pathStack</span>)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">        Button(<span class="string">&quot;跳转到另一个HAR -- 1&quot;</span>)</span><br><span class="line">          .onClick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> param = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">              <span class="string">&quot;data&quot;</span>: <span class="string">&#x27;pass parameters&#x27;</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">let</span> pathInfo = <span class="keyword">new</span> NavPathInfo(<span class="string">&#x27;HARLibraryA&#x27;</span>, param)</span><br><span class="line">            <span class="built_in">this</span>.pathStack.pushPath(pathInfo, <span class="literal">true</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">       ...</span><br><span class="line">      &#125;</span><br><span class="line">      .height(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">      .width(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .navDestination(<span class="built_in">this</span>.pageMap)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通过-Router"><a href="#通过-Router" class="headerlink" title="通过 Router"></a>通过 Router</h5><ol><li>被依赖页面添加<code>@Entry(&#123; routeName: &#39;xxx&#39;&#125;)</code>标记页面名字</li><li>主页直接使用 <code>router.pushNamedRoute()</code>跳转</li></ol><blockquote><p>@Entry 修饰的页面不能用 onPageShow()、onPageHide()监听组件生命周期</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; router &#125; <span class="keyword">from</span> <span class="string">&#x27;@kit.ArkUI&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entry</span>(&#123; <span class="attr">routeName</span>: <span class="string">&#x27;HARPage1&#x27;</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> struct MainPage &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@State</span> message: <span class="built_in">string</span> = <span class="string">&#x27;This is HAR Library&#x27;</span>;</span><br><span class="line">  <span class="comment">/// 接收参数  </span></span><br><span class="line">  aboutToAppear(): <span class="built_in">void</span> &#123; </span><br><span class="line">     <span class="keyword">const</span> params = router.getParams() <span class="keyword">as</span> Record&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(params)&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">build</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">NavDestination</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">Column</span>(<span class="params">&#123;space: <span class="number">20</span>&#125;</span>)</span> &#123;</span><br><span class="line">        Blank()</span><br><span class="line">        Text(<span class="built_in">this</span>.message)</span><br><span class="line">          .fontSize(<span class="number">50</span>)</span><br><span class="line">          .fontWeight(FontWeight.Bold)</span><br><span class="line">        Button(<span class="string">&quot;Back&quot;</span>)</span><br><span class="line">          .onClick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              router.back()</span><br><span class="line">          &#125;</span><br><span class="line">        Blank()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ohos/HARLibraryA/src/main/ets/components/MainPage&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line">struct Index &#123;</span><br><span class="line">  <span class="function"><span class="title">build</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">        Button(<span class="string">&quot;跳转到另一个HAR -- 1&quot;</span>)</span><br><span class="line">          .onClick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            router.pushNamedRoute(&#123;</span><br><span class="line">              name: <span class="string">&quot;HARPage1&quot;</span>,</span><br><span class="line">              params: &#123;</span><br><span class="line">                <span class="string">&#x27;data&#x27;</span>: <span class="string">&#x27;pass parameters&#x27;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用单例"><a href="#使用单例" class="headerlink" title="使用单例"></a>使用单例</h3><p>目前这块表现比较混乱，原因不明，发帖问了一下看看<br><a href="https://developer.huawei.com/consumer/cn/forum/topic/0210157387499898499?fid=0102683795438680754">https://developer.huawei.com/consumer/cn/forum/topic/0210157387499898499?fid=0102683795438680754</a></p><h4 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h4><p>没有 entry 入口， 但是可以有各种 page，可以提供各种页面供入口跳转过来</p><h4 id="引用方式"><a href="#引用方式" class="headerlink" title="引用方式"></a>引用方式</h4><h5 id="静态引用"><a href="#静态引用" class="headerlink" title="静态引用"></a>静态引用</h5><p>如同上面提及的 import { MainPage } from ‘@ohos/HARLibraryA’<br>称之为静态引用，在 oh-package.json5 添加 dependencies 就好</p><h5 id="动态常量引用"><a href="#动态常量引用" class="headerlink" title="动态常量引用"></a>动态常量引用</h5><p>相比起静态引用，好处是可以等到需要的时候再把模块加载到内存中，同样在 oh-package.json5 添加 dependencies 就好</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Button(<span class="string">&quot;加载HSP&quot;</span>)</span><br><span class="line">  .onClick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">import</span>(<span class="string">&#x27;@ohos/HARLibraryA&#x27;</span>).<span class="keyword">then</span>(<span class="function"><span class="params">(ns: ESObject)</span> =&gt;</span> &#123;</span><br><span class="line">        this.HARComponent = ns.HARComponent</span><br><span class="line">        console.log(<span class="string">&#x27;DynamicImport addHar2 4 + 5 = &#x27;</span> + ns.addHar2(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">(<span class="built_in">error</span>: BusinessError)</span> =&gt;</span> &#123;</span><br><span class="line">        hilog.<span class="built_in">error</span>(<span class="number">0</span>, TAG,`show component <span class="name">error</span>: $&#123;<span class="built_in">error</span>.code&#125;, message is $&#123;<span class="built_in">error</span>.message&#125;`)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h5 id="动态变量引用"><a href="#动态变量引用" class="headerlink" title="动态变量引用"></a>动态变量引用</h5><p>上文提到的 import(‘@ohos/HARLibraryA’)方式，在编译的时候编译器会自动加入到依赖树中<br>但是如果是通过变量传参，那么编译器就无法自动加入到依赖树中</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">module</span> = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> (login) &#123;</span><br><span class="line">   <span class="built_in">module</span> = <span class="string">&quot;loginModule&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">module</span> = <span class="string">&quot;featureModule&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span>(<span class="built_in">module</span>).<span class="keyword">then</span>(<span class="function"><span class="params">(ns: ESObject)</span> =&gt;</span> &#123;</span><br><span class="line">    ns.showMainPage()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这时候需要去到 build-profile.json5 添加字段 runtimeOnly，再添加 packages，输入的内容跟 oh-package.json5 里面的 dependencies 名字一致</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;apiType&quot;</span>: <span class="string">&quot;stageMode&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;buildOption&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;runtimeOnly&quot;</span>: &#123;</span><br><span class="line">           <span class="attr">&quot;packages&quot;</span>:  [</span><br><span class="line">                 <span class="string">&quot;@ohos/HARLibraryA&quot;</span></span><br><span class="line">            ]</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态 import 还可以 import 文件路径，比如</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> filePath = <span class="string">&#x27;./Calc&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span>(filePath).<span class="keyword">then</span>(……);</span><br></pre></td></tr></table></figure><p>如果是这种的话，build-profile.json5 的配置就加上 sources</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;runtimeOnly&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;packages&quot;</span>:  [</span><br><span class="line">         <span class="string">&quot;@ohos/HARLibraryA&quot;</span></span><br><span class="line">      ],</span><br><span class="line">    <span class="string">&quot;sources&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;./Calc&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><p>有时候会出现循环依赖的情况，按照以往我们会添加中间层解耦</p><p><img src="https://i0.hdslb.com/bfs/openplatform/84ef769fc7e2610198c90128b85bb6d52b30bd12.png"></p><p>现在官方提供了一种新的方案（仅适用于HAR和HAP之间的依赖 与   HSP与HAR之间的依赖）</p><p><img src="https://i0.hdslb.com/bfs/openplatform/92af14699d178e09c703cfa21424d736a4cbd7bc.png"></p><p>这种方案的好处是，即便HAR1和HAR2中的dependencies里面没有对HAR2和HAR1的依赖配置，也可以通过动态import依赖到。<br>相当于：<br>HAR1和HAR2的依赖转移到了HAP</p><p>另外我们也可把HAR的的依赖转移到HSP，如下图，但是HAR3和HAR4和HSP的依赖不能转移到HAP</p><p><img src="https://i0.hdslb.com/bfs/openplatform/1b98e87c32cb9b0db2c388a1fd4fe8a85c1a1ff7.png"></p><p>下面解释如何操作：</p><p>需要再HAP的oh-package.json5的dependencies和build-profile.json5的runtimeOnly里面同时配置两个HAR模块的依赖</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// oh-package.json5</span></span><br><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;@ohos/HARLibraryA&quot;</span>: <span class="string">&quot;file:../HARLibraryA&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@ohos/HARLibraryB&quot;</span>: <span class="string">&quot;file:../HARLibraryB&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// build-profile.json5</span></span><br><span class="line"><span class="string">&quot;runtimeOnly&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;packages&quot;</span>:  [</span><br><span class="line">    <span class="string">&quot;@ohos/HARLibraryA&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@ohos/HARLibraryB&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在HAP里面调用HAR1的方法</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Button(<span class="string">&quot;调用HAR的方法&quot;</span>)</span><br><span class="line">  .onClick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      let har1 = <span class="string">&#x27;@ohos/HARLibraryA&#x27;</span></span><br><span class="line">      <span class="keyword">import</span>(har1).<span class="keyword">then</span>(<span class="function"><span class="params">(ns: ESObject)</span> =&gt;</span> &#123;</span><br><span class="line">        hilog.info(<span class="number">0</span>, TAG, `$&#123;ns.addHar1(<span class="number">1</span>, <span class="number">2</span>)&#125;`)</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">(<span class="built_in">error</span>: BusinessError)</span> =&gt;</span> &#123;</span><br><span class="line">        hilog.<span class="built_in">error</span>(<span class="number">0</span>, TAG,`show component <span class="name">error</span>: $&#123;<span class="built_in">error</span>.code&#125;, message is $&#123;<span class="built_in">error</span>.message&#125;`)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>HAR1调用HAR2的方法，这里必须使用动态变量import，不可以<code>import(&#39;@ohos/HARLibraryB&#39;)</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addHar1</span>(<span class="params">a:<span class="built_in">number</span>, b:<span class="built_in">number</span></span>):<span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> c = a + b;</span><br><span class="line">  hilog.info(<span class="number">0</span>, TAG, <span class="string">&#x27;DynamicImport I am har1, %d + %d = %d&#x27;</span>, a, b, c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> harName = <span class="string">&#x27;@ohos/HARLibraryB&#x27;</span>;</span><br><span class="line">  <span class="keyword">import</span>(harName).then(<span class="function">(<span class="params">ns:ESObject</span>) =&gt;</span> &#123;</span><br><span class="line">    hilog.info(<span class="number">0</span>, TAG, <span class="string">&#x27;DynamicImport addHar2 4 + 5 = &#x27;</span> + ns.addHar2(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">  &#125;).catch(<span class="function">(<span class="params">error: BusinessError</span>) =&gt;</span> &#123;</span><br><span class="line">    hilog.error(<span class="number">0</span>, TAG,<span class="string">`har1 error: <span class="subst">$&#123;error.code&#125;</span>, message is <span class="subst">$&#123;error.message&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HAR2实现addHar2方法并且export</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addHar2</span>(<span class="params">a:<span class="built_in">number</span>, b:<span class="built_in">number</span></span>):<span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> c = a + b;</span><br><span class="line">  hilog.info(<span class="number">0</span>, <span class="string">&quot;INDEX_TAG&quot;</span>, <span class="string">&#x27;DynamicImport I am har2, %d + %d = %d&#x27;</span>, a, b, c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果达成，并且要注意Promise是异步的</p><p><img src="https://i0.hdslb.com/bfs/openplatform/26b5680bbf08ae83e6bccc5aca66658dade51f53.png"></p><h2 id="HSP"><a href="#HSP" class="headerlink" title="HSP"></a>HSP</h2><p>Harmony Shared Package<br>类似于动态库，内存共享，按需下载</p><h3 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h3><p>对应 SharedLibrary</p><p><img src="https://i0.hdslb.com/bfs/openplatform/a37ef16798ea2b6829a0c92194f49e879ddfd014.png"></p><h3 id="提供接口-1"><a href="#提供接口-1" class="headerlink" title="提供接口"></a>提供接口</h3><p>方式同 HAR</p><h3 id="页面跳转-1"><a href="#页面跳转-1" class="headerlink" title="页面跳转"></a>页面跳转</h3><h4 id="本地引用"><a href="#本地引用" class="headerlink" title="本地引用"></a>本地引用</h4><p>本地引用可以利用 HSP 的内存复用能力，但是不能使用动态下载能力，即下载到用户手机的包体还是会增大</p><h5 id="使用-Navigation"><a href="#使用-Navigation" class="headerlink" title="使用 Navigation"></a>使用 Navigation</h5><p>主页</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; SharedMainPage &#125; <span class="keyword">from</span> <span class="string">&quot;@ohos/SharedLibrary&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entry</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line">struct Index &#123;</span><br><span class="line">  <span class="meta">@Provide</span>(<span class="string">&quot;pathStack&quot;</span>) pathStack: NavPathStack = <span class="keyword">new</span> NavPathStack()</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Builder</span></span><br><span class="line">  <span class="function"><span class="title">pageMap</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&#x27;hps&#x27;</span>) &#123;</span><br><span class="line">      SharedMainPage()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">build</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">Navigation</span>(<span class="params"><span class="built_in">this</span>.pathStack</span>)</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">Column</span>(<span class="params">&#123; space: <span class="number">20</span> &#125;</span>)</span> &#123;</span><br><span class="line">        Blank()</span><br><span class="line">        Text(<span class="string">&quot;Ability&quot;</span>)</span><br><span class="line">          .fontSize(<span class="number">30</span>)</span><br><span class="line">          .fontWeight(FontWeight.Medium)</span><br><span class="line">        Button(<span class="string">&quot;Jump To HSP&quot;</span>)</span><br><span class="line">          .onClick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> info = <span class="keyword">new</span> NavPathInfo(<span class="string">&quot;hps&quot;</span>, <span class="string">&quot;params&quot;</span>)</span><br><span class="line">            <span class="built_in">this</span>.pathStack.pushPath(info,<span class="literal">true</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .navDestination(<span class="built_in">this</span>.pageMap)</span><br><span class="line">    .height(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">    .width(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HSP 页面</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; router &#125; <span class="keyword">from</span> <span class="string">&#x27;@kit.ArkUI&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entry</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> struct SharedMainPage &#123;</span><br><span class="line">  <span class="meta">@State</span> message: <span class="built_in">string</span> = <span class="string">&#x27;Shared MainPage&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Consume</span>(<span class="string">&quot;pathStack&quot;</span>) navStack: NavPathStack</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">build</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">NavDestination</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">Row</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">Column</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          Text(<span class="built_in">this</span>.message)</span><br><span class="line">            .fontSize(<span class="number">50</span>)</span><br><span class="line">            .fontWeight(FontWeight.Bold)</span><br><span class="line">          Button(<span class="string">&quot;跳转到HAR&quot;</span>)</span><br><span class="line">            .onClick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              router.pushNamedRoute(&#123;</span><br><span class="line">                name: <span class="string">&quot;HARPage1&quot;</span></span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        .width(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .height(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-Router"><a href="#使用-Router" class="headerlink" title="使用 Router"></a>使用 Router</h4><p>主页</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; SharedMainPage &#125; <span class="keyword">from</span> <span class="string">&quot;@ohos/SharedLibrary&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; router &#125; <span class="keyword">from</span> <span class="string">&#x27;@kit.ArkUI&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ohos/SharedLibraryB/src/main/ets/pages/Index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Entry</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line">struct Index &#123;</span><br><span class="line">  <span class="function"><span class="title">build</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">Column</span>(<span class="params">&#123; space: <span class="number">20</span> &#125;</span>)</span> &#123;</span><br><span class="line">        Blank()</span><br><span class="line">        Text(<span class="string">&quot;Ability&quot;</span>)</span><br><span class="line">          .fontSize(<span class="number">30</span>)</span><br><span class="line">          .fontWeight(FontWeight.Medium)</span><br><span class="line">        Button(<span class="string">&quot;Jump To HSP 2&quot;</span>)</span><br><span class="line">          .onClick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            router.pushNamedRoute(&#123;</span><br><span class="line">              name: <span class="string">&quot;SharedMainPageB&quot;</span></span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    .height(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">    .width(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HSP 页面</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; router &#125; <span class="keyword">from</span> <span class="string">&#x27;@kit.ArkUI&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entry</span>(&#123;<span class="attr">routeName</span>: <span class="string">&quot;SharedMainPageB&quot;</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> struct SharedMainPageB &#123;</span><br><span class="line">  <span class="meta">@State</span> message: <span class="built_in">string</span> = <span class="string">&#x27;Shared MainPage B&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">build</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">Row</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">Column</span>(<span class="params">&#123;space: <span class="number">20</span>&#125;</span>)</span> &#123;</span><br><span class="line">        Text(<span class="built_in">this</span>.message)</span><br><span class="line">          .fontSize(<span class="number">50</span>)</span><br><span class="line">          .fontWeight(FontWeight.Bold)</span><br><span class="line">        Button(<span class="string">&quot;跳转到HAR&quot;</span>)</span><br><span class="line">          .onClick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            router.pushNamedRoute(&#123;</span><br><span class="line">              name: <span class="string">&quot;HARPage1&quot;</span></span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      .width(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .height(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态引用"><a href="#动态引用" class="headerlink" title="动态引用"></a>动态引用</h4><p>动态引用既可以利用 HSP 的内存复用能力，又可以利用 HSP 的下载能力，前提是配置依赖需要配置到 dynamicDependencies 而不是 dependencies<br>HSP 不支持独立发布，而是跟随宿主包上传，应用市场控制安装时只下载 HAP、HAR 到用户本地，HSP 下载时机由开发者自行控制。<br>参考：<a href="">https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/store-moduleinstall-V5</a><br>示例：点击按钮展示动态模块</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entry</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line">struct Index &#123;</span><br><span class="line">    <span class="meta">@BuilderParam</span> SharedModuleComponent: <span class="built_in">Function</span></span><br><span class="line">    <span class="meta">@State</span> isShow: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">build</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">Row</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">Column</span>(<span class="params">&#123; space: <span class="number">20</span> &#125;</span>)</span> &#123;</span><br><span class="line">        Blank()</span><br><span class="line">        Button(<span class="string">&quot;加载HSP&quot;</span>)</span><br><span class="line">          .onClick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.initSharedModule(<span class="string">&#x27;SharedLibrary&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">import</span>(<span class="string">&#x27;SharedLibrary&#x27;</span>).then(<span class="function">(<span class="params">ns: ESObject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.SharedModuleComponent = ns.showSharedComponent</span><br><span class="line">                <span class="built_in">this</span>.isShow = <span class="literal">true</span></span><br><span class="line">              &#125;).catch(<span class="function">(<span class="params">error: BusinessError</span>) =&gt;</span> &#123;</span><br><span class="line">                hilog.error(<span class="number">0</span>, TAG,<span class="string">`show component error: <span class="subst">$&#123;error.code&#125;</span>, message is <span class="subst">$&#123;error.message&#125;</span>`</span>)</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isShow) &#123;</span><br><span class="line">          <span class="built_in">this</span>.SharedModuleComponent()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      .width(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    .height(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置依赖：给入口的 oh-package.json5 添加 dynamicDependencies 字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;entry&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Please describe the basic information.&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;dynamicDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;SharedLibrary&quot;</span>: <span class="string">&quot;file:../SharedLibrary&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态引用分为三步</p><ol><li>判断是否已经安装到本地，这个方法实现了判断是否加载并且调用下载功能</li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 检查SharedModule是否已经加载</span></span><br><span class="line"><span class="keyword">private</span> initSharedModule(name: string, successCallback: Callback&lt;<span class="keyword">void</span>&gt;): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result: moduleInstallManager.InstalledModule = moduleInstallManager.getInstalledModule(name)</span><br><span class="line">    <span class="keyword">if</span> (result?.installStatus === moduleInstallManager.InstallStatus.INSTALLED) &#123;</span><br><span class="line">      hilog.info(<span class="number">0</span>, TAG, <span class="string">&#x27;SharedLibrary is Installed&#x27;</span>)</span><br><span class="line">      successCallback &amp;&amp; successCallback()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      hilog.info(<span class="number">0</span>, TAG, <span class="string">&#x27;SharedLibrary not installed&#x27;</span>)</span><br><span class="line">      <span class="keyword">this</span>.fetchModule(name, successCallback)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">error</span>) &#123;</span><br><span class="line">    hilog.<span class="keyword">error</span>(<span class="number">0</span>, TAG, `get install module <span class="keyword">error</span>.code is $&#123;<span class="keyword">error</span>.code&#125;, message is $&#123;<span class="keyword">error</span>.message&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如果安装了则直接展示</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (result?.installStatus === moduleInstallManager.InstallStatus.INSTALLED) &#123;</span><br><span class="line">  <span class="selector-tag">hilog</span><span class="selector-class">.info</span>(<span class="number">0</span>, TAG, <span class="string">&#x27;SharedLibrary is Installed&#x27;</span>)</span><br><span class="line">  <span class="selector-tag">successCallback</span> <span class="selector-tag">&amp;</span><span class="selector-tag">&amp;</span> <span class="selector-tag">successCallback</span>()</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol start="3"><li>如果没安装则下载后展示，这个方法实现了下载后回调 callback 的功能</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="title">fetchModule</span>(<span class="params">moduleName: <span class="built_in">string</span>, successCallback: Callback&lt;<span class="built_in">void</span>&gt;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      hilog.info(<span class="number">0</span>, TAG, <span class="string">&#x27;handle fetch modules start&#x27;</span>)</span><br><span class="line">      <span class="keyword">const</span> context = getContext(<span class="built_in">this</span>) <span class="keyword">as</span> common.UIAbilityContext;</span><br><span class="line">      <span class="keyword">const</span> moduleInstallProvider: moduleInstallManager.ModuleInstallProvider = <span class="keyword">new</span> moduleInstallManager.ModuleInstallProvider()</span><br><span class="line">      <span class="keyword">const</span> moduleInstallRequest: moduleInstallManager.ModuleInstallRequest = moduleInstallProvider.createModuleInstallRequest(context)</span><br><span class="line">      <span class="keyword">if</span> (!moduleInstallRequest) &#123;</span><br><span class="line">        hilog.warn(<span class="number">0</span>, TAG, <span class="string">&#x27;moduleInstallRequest is empty&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      moduleInstallRequest.addModule(moduleName)</span><br><span class="line">      moduleInstallManager.fetchModules(moduleInstallRequest).then(<span class="function">(<span class="params">data: moduleInstallManager.ModuleInstallSessionState</span>) =&gt;</span> &#123;</span><br><span class="line">        hilog.info(<span class="number">0</span>,TAG, <span class="string">&#x27;succeed in fetching modules result&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (data.code === moduleInstallManager.RequestErrorCode.SUCCESS) &#123;</span><br><span class="line">          <span class="built_in">this</span>.onListenEvents(successCallback)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          hilog.info(<span class="number">0</span>, TAG, <span class="string">`fetch modules failure <span class="subst">$&#123;data.code&#125;</span> reason <span class="subst">$&#123;data.desc&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).catch(<span class="function">(<span class="params">error: <span class="built_in">Error</span></span>) =&gt;</span> &#123;</span><br><span class="line">        hilog.error(<span class="number">0</span>, TAG, <span class="string">`fetchmodules onError.code is <span class="subst">$&#123;error.name&#125;</span>, message is <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        hilog.error(<span class="number">0</span>, TAG, <span class="string">`fetchmodules onError.code is <span class="subst">$&#123;error.code&#125;</span>, message is <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于包的选型，建议如下结构</p><p><img src="https://i0.hdslb.com/bfs/openplatform/c421f89a0a4763f3d83a2d400c3c1d7422eb9b2c.png"></p><p>关于HAR和HSP<br>如果需要，共享内存或者动态下载，使用HSP，否则使用HAR；如果存在单例，使用HSP。</p><p>HAP、HAR、HSP三者的功能和使用场景总结对比如下：</p><table><thead><tr><th>模块类型</th><th>包类型</th><th>说明</th></tr></thead><tbody><tr><td>Ability</td><td>HAP</td><td>应用的功能模块，可以独立安装和运行，必须包含一个entry类型的HAP，可选包含一个或多个feature类型的HAP。</td></tr><tr><td>Static Library</td><td>HAR</td><td>静态共享包，编译态复用。<br>- 支持应用内共享，也可以发布后供其他应用使用<br>- 作为二方库，发布到OHPM私仓，供公司内部其他应用使用<br>- 作为三方库，发布到OHPM中心仓，供其他应用使用<br>- 多包（HAP/HSP）引用相同的HAR时，会造成多包间代码和资源的重复拷贝，从而导致应用包膨大<br>- 注意：编译HAR时，建议开启混淆能力，保护代码资产</td></tr><tr><td>Shared Library</td><td>HSP</td><td>动态共享包，运行时复用。<br>- 当前仅支持应用内共享<br>- 当多包（HAP/HSP）同时引用同一个共享包时，采用HSP替代HAR，可以避免HAR造成的多包间代码和资源的重复拷贝，从而减小应用包大小</td></tr></tbody></table><p>HAP、HSP、HAR支持的规格对比如下，其中“√”表示是，“×”表示否。</p><table><thead><tr><th>规格</th><th>HAP</th><th>HAR</th><th>HSP</th></tr></thead><tbody><tr><td>支持在配置文件中声明UIAbility组件与ExtensionAbility组件</td><td>√</td><td>×</td><td>×</td></tr><tr><td>支持在配置文件中声明pages页面</td><td>√</td><td>×</td><td>√</td></tr><tr><td>支持包含资源文件与.so文件</td><td>√</td><td>√</td><td>√</td></tr><tr><td>支持依赖其他HAR文件</td><td>√</td><td>√</td><td>√</td></tr><tr><td>支持依赖其他HSP文件</td><td>√</td><td>√</td><td>√</td></tr><tr><td>支持在设备上独立安装运行</td><td>√</td><td>×</td><td>×</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文简述开发鸿蒙第三方 SDK 的选型以及注意事项&lt;/p&gt;</summary>
    
    
    
    <category term="Harmony" scheme="https://www.arclin.cn/categories/Harmony/"/>
    
    
    <category term="Harmony" scheme="https://www.arclin.cn/tags/Harmony/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙状态管理装饰器V2</title>
    <link href="https://www.arclin.cn/post/4b595590.html"/>
    <id>https://www.arclin.cn/post/4b595590.html</id>
    <published>2024-07-22T14:58:58.000Z</published>
    <updated>2025-05-14T15:39:34.878Z</updated>
    
    <content type="html"><![CDATA[<p>鸿蒙 API 12 推出了 V2 版本的状态管理装饰器，比起 V1 装饰器，V2 装饰器的职责更加地清晰，并且能力也得到了加强，建议后续开发使用 V2 版本的装饰器</p><span id="more"></span><p>相关文档：<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/_u6001_u7ba1_u7406_uff08v2_u8bd5_u7528_u7248_uff09-V5">https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/_u6001_u7ba1_u7406_uff08v2_u8bd5_u7528_u7248_uff09-V5</a></p><h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>V2 相关装饰器所涉及到的根视图组件都需要用@ComponentV2 进行修饰</p><h1 id="ObservedV2"><a href="#ObservedV2" class="headerlink" title="@ObservedV2"></a>@ObservedV2</h1><p>举例:</p><p><img src="https://oss.hexoxe.com/2025/05/14/00/1747234940855.rar?type=t.png"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在 V1 中，@Observed 无法深度观测，比如以下的例子</p><ol><li>先点击修改名字，名字变化，再点击修改班级，班级不会变化</li><li>先点击修改班级，班级不会变化，再点击修改名字，名字和班级同时发生变化</li></ol><p>结论：</p><p>直接修改第二层的属性，虽然对象本身已经发生了变化，但是无法被@Observed 观测到<br>修改第一层的属性的时候，会被@Observed 观测到，执行 UI 刷新，并且刷新是全体的，并不只是修改绑定的属性对应的 UI<br>(这里会引申出一个性能问题：如果某个对象有很多属性，只改变一个属性会导致其他无关控件也被刷新，造成无意义的性能损耗)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Observed</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span> </span>&#123;</span><br><span class="line">  grade: <span class="built_in">number</span></span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">grade: <span class="built_in">number</span>, name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.grade = grade</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Observed</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  grade: Grade</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, grade: Grade</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="built_in">this</span>.grade = grade</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entry</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line">struct Index &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@State</span> student: Student = <span class="keyword">new</span> Student(<span class="string">&quot;John&quot;</span>,<span class="number">18</span>, <span class="keyword">new</span> Grade(<span class="number">3</span>,<span class="string">&quot;B&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">build</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">Column</span>(<span class="params">&#123; space: <span class="number">20</span> &#125;</span>)</span> &#123;</span><br><span class="line">        Blank()</span><br><span class="line">        Text(<span class="string">&quot;Name: &quot;</span> + <span class="built_in">this</span>.student.name)</span><br><span class="line">          .fontWeight(FontWeight.Bold)</span><br><span class="line">        Text(<span class="string">&quot;Age: &quot;</span> + <span class="built_in">this</span>.student.age)</span><br><span class="line">          .fontWeight(FontWeight.Bold)</span><br><span class="line">        <span class="function"><span class="title">Row</span>(<span class="params">&#123; space: <span class="number">20</span>&#125;</span>)</span> &#123;</span><br><span class="line">          Text(<span class="string">&quot;Grade: &quot;</span> + <span class="built_in">this</span>.student.grade.grade)</span><br><span class="line">            .fontWeight(FontWeight.Bold)</span><br><span class="line">          Text(<span class="string">&quot;Class: &quot;</span> + <span class="built_in">this</span>.student.grade.name)</span><br><span class="line">            .fontWeight(FontWeight.Bold)</span><br><span class="line">        &#125;</span><br><span class="line">        Button(<span class="string">&quot;修改名字&quot;</span>)</span><br><span class="line">          .onClick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.student.name = <span class="string">&quot;Mike&quot;</span></span><br><span class="line">          &#125;)</span><br><span class="line">        Button(<span class="string">&quot;修改班级&quot;</span>)</span><br><span class="line">          .onClick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.student.grade.name = <span class="string">&quot;C&quot;</span></span><br><span class="line">          &#125;)</span><br><span class="line">        Blank()</span><br><span class="line">      &#125;</span><br><span class="line">      .width(<span class="string">&quot;100%&quot;</span>)</span><br><span class="line">      .height(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>被观察的类使用@ObservedV2 修饰，需要被观察到属性用@Trace 修饰即可</p><p>结果：</p><p>点击修改班级的时候，班级会发生变化；然而，点击修改名字的时候，名字不会变化</p><p>结论：</p><p>只有被@Trace 修饰的属性，修改的时候才会发生变化，没有@Trace 修饰的属性是不会被观察到的<br>使用该修饰器修饰的属性，被修改的时候只会重新渲染相关的组件，其他没有被修改的属性是不会重新渲染的，比起 V1 性能更好</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ObservedV2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grade</span> </span>&#123;</span><br><span class="line">  grade: <span class="built_in">number</span></span><br><span class="line">  <span class="meta">@Trace</span> name: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">grade: <span class="built_in">number</span>, name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.grade = grade</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ObservedV2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  grade: Grade</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, grade: Grade</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="built_in">this</span>.grade = grade</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>@Trace 支持 model 嵌套，支持继承，支持修饰数组/Map/Date/Set</p><h1 id="Local"><a href="#Local" class="headerlink" title="@Local"></a>@Local</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><ol><li>@Local 与@State 用法相同，区别在于@State 的属性可以外部赋值，而@Local 不允许</li></ol><p>如果 student 用@State 修饰，下面代码是允许的，<br>如果 student 用@Local 修饰，则下面代码不允许</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">Index(&#123; <span class="params">student</span>: <span class="params">new</span> Student(<span class="string">&quot;John&quot;</span>,18, <span class="params">new</span> Grade(3,<span class="string">&quot;B&quot;</span>)</span>) &#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>上述的@ObserveV2 和@Trace 只能用于监听对象的属性，但是如果对象本身发生了变化，那 UI 不会刷新，如下代码点击“修改整体”， UI 不会刷新</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Entry</span><br><span class="line">@ComponentV2</span><br><span class="line"><span class="keyword">struct</span> Index &#123;</span><br><span class="line"></span><br><span class="line">  student: Student = <span class="keyword">new</span> <span class="constructor">Student(<span class="string">&quot;John&quot;</span>,18, <span class="params">new</span> Grade(3,<span class="string">&quot;B&quot;</span>)</span>)</span><br><span class="line"></span><br><span class="line">  build<span class="literal">()</span> &#123;</span><br><span class="line">      <span class="constructor">Column(&#123; <span class="params">space</span>: 20 &#125;)</span> &#123;</span><br><span class="line">        <span class="constructor">Blank()</span></span><br><span class="line">        <span class="constructor">Text(<span class="string">&quot;Name: &quot;</span> + <span class="params">this</span>.<span class="params">student</span>.<span class="params">name</span>)</span></span><br><span class="line">          .font<span class="constructor">Weight(FontWeight.Bold)</span></span><br><span class="line">        <span class="constructor">Text(<span class="string">&quot;Age: &quot;</span> + <span class="params">this</span>.<span class="params">student</span>.<span class="params">age</span>)</span></span><br><span class="line">          .font<span class="constructor">Weight(FontWeight.Bold)</span></span><br><span class="line">        <span class="constructor">Row(&#123; <span class="params">space</span>: 20&#125;)</span> &#123;</span><br><span class="line">          <span class="constructor">Text(<span class="string">&quot;Grade: &quot;</span> + <span class="params">this</span>.<span class="params">student</span>.<span class="params">grade</span>.<span class="params">grade</span>)</span></span><br><span class="line">            .font<span class="constructor">Weight(FontWeight.Bold)</span></span><br><span class="line">          <span class="constructor">Text(<span class="string">&quot;Class: &quot;</span> + <span class="params">this</span>.<span class="params">student</span>.<span class="params">grade</span>.<span class="params">name</span>)</span></span><br><span class="line">            .font<span class="constructor">Weight(FontWeight.Bold)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="constructor">Button(<span class="string">&quot;修改整体&quot;</span>)</span></span><br><span class="line">          .on<span class="constructor">Click(()</span> =&gt; &#123;</span><br><span class="line">            this.student = <span class="keyword">new</span> <span class="constructor">Student(<span class="string">&quot;Date&quot;</span>, 23, <span class="params">new</span> Grade(23, <span class="string">&quot;None&quot;</span>)</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        <span class="constructor">Blank()</span></span><br><span class="line">      &#125;</span><br><span class="line">      .width(<span class="string">&quot;100%&quot;</span>)</span><br><span class="line">      .height(&#x27;<span class="number">100</span>%&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h2><p>使用@Local</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Local student: <span class="type">Student </span>= <span class="keyword">new</span> <span class="type">Student</span>(<span class="string">&quot;John&quot;</span>,<span class="number">18</span>, <span class="keyword">new</span> <span class="type">Grade</span>(<span class="number">3</span>,<span class="string">&quot;B&quot;</span>))</span><br></pre></td></tr></table></figure><h1 id="Param"><a href="#Param" class="headerlink" title="@Param"></a>@Param</h1><p>搭配@Local 使用，用于父子组件数据单向传递，复杂类型比起@Prop 性能更好</p><blockquote><p>@Require 表示必须外部传入，本地不用初始化</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Entry</span><br><span class="line">@ComponentV2</span><br><span class="line"><span class="keyword">struct</span> Index &#123;</span><br><span class="line"></span><br><span class="line">  @Local student: Student = <span class="keyword">new</span> <span class="constructor">Student(<span class="string">&quot;John&quot;</span>,18, <span class="params">new</span> Grade(3,<span class="string">&quot;B&quot;</span>)</span>)</span><br><span class="line"></span><br><span class="line">  build<span class="literal">()</span> &#123;</span><br><span class="line">      <span class="constructor">Column(&#123; <span class="params">space</span>: 20 &#125;)</span> &#123;</span><br><span class="line">        <span class="constructor">Blank()</span></span><br><span class="line">        <span class="constructor">Info(&#123; <span class="params">student</span>: <span class="params">this</span>.<span class="params">student</span> &#125;)</span></span><br><span class="line">        <span class="constructor">Button(<span class="string">&quot;修改整体&quot;</span>)</span></span><br><span class="line">          .on<span class="constructor">Click(()</span> =&gt; &#123;</span><br><span class="line">            this.student = <span class="keyword">new</span> <span class="constructor">Student(<span class="string">&quot;Date&quot;</span>, 23, <span class="params">new</span> Grade(23, <span class="string">&quot;None&quot;</span>)</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        <span class="constructor">Blank()</span></span><br><span class="line">      &#125;</span><br><span class="line">      .width(<span class="string">&quot;100%&quot;</span>)</span><br><span class="line">      .height(&#x27;<span class="number">100</span>%&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ComponentV2</span><br><span class="line"><span class="keyword">struct</span> Info &#123;</span><br><span class="line">  @Require @Param student: Student</span><br><span class="line">  build<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="constructor">Column(&#123; <span class="params">space</span>: 20 &#125;)</span> &#123;</span><br><span class="line">      <span class="constructor">Text(<span class="string">&quot;Name: &quot;</span> + <span class="params">this</span>.<span class="params">student</span>.<span class="params">name</span>)</span></span><br><span class="line">        .font<span class="constructor">Weight(FontWeight.Bold)</span></span><br><span class="line">      <span class="constructor">Text(<span class="string">&quot;Age: &quot;</span> + <span class="params">this</span>.<span class="params">student</span>.<span class="params">age</span>)</span></span><br><span class="line">        .font<span class="constructor">Weight(FontWeight.Bold)</span></span><br><span class="line">      <span class="constructor">Row(&#123; <span class="params">space</span>: 20&#125;)</span> &#123;</span><br><span class="line">        <span class="constructor">Text(<span class="string">&quot;Grade: &quot;</span> + <span class="params">this</span>.<span class="params">student</span>.<span class="params">grade</span>.<span class="params">grade</span>)</span></span><br><span class="line">          .font<span class="constructor">Weight(FontWeight.Bold)</span></span><br><span class="line">        <span class="constructor">Text(<span class="string">&quot;Class: &quot;</span> + <span class="params">this</span>.<span class="params">student</span>.<span class="params">grade</span>.<span class="params">name</span>)</span></span><br><span class="line">          .font<span class="constructor">Weight(FontWeight.Bold)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Param 修饰的属性如果是对象的话，可以在子组件内部修改对象的成员属性，此时会同步到父组件<br>但是不可以修改对象本身</p><h1 id="Once"><a href="#Once" class="headerlink" title="@Once"></a>@Once</h1><p>修饰@Param 修饰的属性，表示属性只能被初始化一次，后面不再改变，就算子组件或者父组件修改了这个属性，值也不会改变</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@ComponentV2</span></span><br><span class="line">struct Info &#123;</span><br><span class="line">  <span class="variable">@Require</span> <span class="variable">@Param</span> <span class="attribute">student</span>: Student;</span><br><span class="line">  <span class="variable">@Once</span> <span class="variable">@Param</span> <span class="attribute">type</span>: number;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Event"><a href="#Event" class="headerlink" title="@Event"></a>@Event</h1><p>因为@Param 修饰的变量不可以在子组件修改，所以推出@Event 补充这个功能<br>使用方法是修饰一个方法类型，回调属性回去给父组件进行修改<br>@Event 只能修饰方法类型<br>@Event 更多只是作为一种规范，其实不加这个修饰符也行</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">@Entry</span><br><span class="line">@ComponentV2</span><br><span class="line"><span class="keyword">struct</span> Index &#123;</span><br><span class="line"></span><br><span class="line">  @Local student: Student = <span class="keyword">new</span> <span class="constructor">Student(<span class="string">&quot;John&quot;</span>,18, <span class="params">new</span> Grade(3,<span class="string">&quot;B&quot;</span>)</span>)</span><br><span class="line"></span><br><span class="line">  build<span class="literal">()</span> &#123;</span><br><span class="line">      <span class="constructor">Column(&#123; <span class="params">space</span>: 20 &#125;)</span> &#123;</span><br><span class="line">        <span class="constructor">Blank()</span></span><br><span class="line">        <span class="constructor">Info(&#123; <span class="params">student</span>: <span class="params">this</span>.<span class="params">student</span>, <span class="params">change</span>: (<span class="params">student</span>: Student)</span> =&gt; &#123;</span><br><span class="line">            this.student = student</span><br><span class="line">        &#125;&#125;)</span><br><span class="line">        <span class="constructor">Blank()</span></span><br><span class="line">      &#125;</span><br><span class="line">      .width(<span class="string">&quot;100%&quot;</span>)</span><br><span class="line">      .height(&#x27;<span class="number">100</span>%&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ComponentV2</span><br><span class="line"><span class="keyword">struct</span> Info &#123;</span><br><span class="line">  @Require @Param student: Student</span><br><span class="line">  @Event change:<span class="function"> (<span class="params">x</span>: S<span class="params">tudent</span>) =&gt;</span> void =<span class="function"> <span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">  build<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="constructor">Column(&#123; <span class="params">space</span>: 20 &#125;)</span> &#123;</span><br><span class="line">      <span class="constructor">Text(<span class="string">&quot;Name: &quot;</span> + <span class="params">this</span>.<span class="params">student</span>.<span class="params">name</span>)</span></span><br><span class="line">        .font<span class="constructor">Weight(FontWeight.Bold)</span></span><br><span class="line">      <span class="constructor">Text(<span class="string">&quot;Age: &quot;</span> + <span class="params">this</span>.<span class="params">student</span>.<span class="params">age</span>)</span></span><br><span class="line">        .font<span class="constructor">Weight(FontWeight.Bold)</span></span><br><span class="line">        .on<span class="constructor">Click(()</span> =&gt; &#123;</span><br><span class="line">          <span class="comment">// 无效代码：this.student = new Student(&quot;Info&quot;, 33, new Grade(33, &quot;Info What&quot;))</span></span><br><span class="line">          this.change( <span class="keyword">new</span> <span class="constructor">Student(<span class="string">&quot;Info&quot;</span>, 33, <span class="params">new</span> Grade(33, <span class="string">&quot;Info What&quot;</span>)</span>) )</span><br><span class="line">        &#125;)</span><br><span class="line">      <span class="constructor">Row(&#123; <span class="params">space</span>: 20&#125;)</span> &#123;</span><br><span class="line">        <span class="constructor">Text(<span class="string">&quot;Grade: &quot;</span> + <span class="params">this</span>.<span class="params">student</span>.<span class="params">grade</span>.<span class="params">grade</span>)</span></span><br><span class="line">          .font<span class="constructor">Weight(FontWeight.Bold)</span></span><br><span class="line">        <span class="constructor">Text(<span class="string">&quot;Class: &quot;</span> + <span class="params">this</span>.<span class="params">student</span>.<span class="params">grade</span>.<span class="params">name</span>)</span></span><br><span class="line">          .font<span class="constructor">Weight(FontWeight.Bold)</span></span><br><span class="line">      &#125;.on<span class="constructor">Click(()</span> =&gt; &#123;</span><br><span class="line">        this.student.name = <span class="string">&quot;Info Name&quot;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="！！"><a href="#！！" class="headerlink" title="！！"></a>！！</h1><p>配合@Event 和@Param 进行父子组件双向绑定<br>子组件需要定义一个@Param 属性和一个同名@Event 并加上$，在点击按钮的时候调用@Event 的属性回调新值出去</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@ComponentV2</span><br><span class="line">struct Info &#123;</span><br><span class="line">  @Require @Param student: Student;</span><br><span class="line">  @Event $student: <span class="function"><span class="params">(x: Student)</span> =&gt;</span> <span class="keyword">void</span> = <span class="function"><span class="params">(x: Student)</span> =&gt;</span> &#123;&#125;</span><br><span class="line">  build() &#123;</span><br><span class="line">      Button(<span class="string">&quot;Change Student&quot;</span>)</span><br><span class="line">        .onClick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="regexp">//</span> 无效代码：<span class="built_in">this</span>.student = <span class="keyword">new</span> Student(<span class="string">&quot;Info&quot;</span>, <span class="number">33</span>, <span class="keyword">new</span> Grade(<span class="number">33</span>, <span class="string">&quot;Info What&quot;</span>))</span><br><span class="line">          <span class="built_in">this</span>.$student(<span class="keyword">new</span> Student(<span class="string">&quot;Info&quot;</span>, <span class="number">33</span>, <span class="keyword">new</span> Grade(<span class="number">33</span>, <span class="string">&quot;Info What&quot;</span>)))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>父组件传参数给子组件的时候加上！！</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entry</span></span><br><span class="line"><span class="variable">@ComponentV2</span></span><br><span class="line">struct Index &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable">@Local</span> <span class="attribute">student</span>: Student = new Student(<span class="string">&quot;John&quot;</span>,<span class="number">18</span>, new Grade(<span class="number">3</span>,<span class="string">&quot;B&quot;</span>))</span><br><span class="line"></span><br><span class="line">  build() &#123;</span><br><span class="line">      <span class="selector-tag">Column</span>(&#123; space: 20 &#125;) &#123;</span><br><span class="line">        <span class="selector-tag">Blank</span>()</span><br><span class="line">        <span class="selector-tag">Info</span>(&#123; student: this.student!! &#125;)</span><br><span class="line">        <span class="selector-tag">Blank</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="selector-class">.width</span>(<span class="string">&quot;100%&quot;</span>)</span><br><span class="line">      <span class="selector-class">.height</span>(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现效果为子组件修改传入的属性本身的时候，父子组件的属性值同时发生变化</p><h1 id="Computed"><a href="#Computed" class="headerlink" title="@Computed"></a>@Computed</h1><p>@Compute 可以把某个属性标记为计算属性，如下代码的 sum，注意此时 sum 不是方法，sum 依旧作为属性存在<br>当点击“修改 Grade”的时候，页面发生变化，实时显示 sum 计算后的结果，并且多次点击，不会重复执行 get 方法体<br>注意：sum 会发生变化的前提是，参与 sum 计算的属性需要被@Trace 修饰，如果参与 sum 计算的属性没有被监听的能力的话，那就不会触发计算方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entry</span></span><br><span class="line"><span class="meta">@ComponentV2</span></span><br><span class="line">struct Index &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Local</span> student: Student = <span class="keyword">new</span> Student(<span class="string">&quot;John&quot;</span>,<span class="number">18</span>, <span class="keyword">new</span> Grade(<span class="number">3</span>,<span class="string">&quot;B&quot;</span>))</span><br><span class="line">  <span class="meta">@Computed</span> <span class="keyword">get</span> <span class="title">sum</span>() &#123;</span><br><span class="line">      <span class="keyword">let</span> result = <span class="built_in">this</span>.student.age + <span class="built_in">this</span>.student.grade.grade</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`result = <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">build</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">Column</span>(<span class="params">&#123; space: <span class="number">20</span> &#125;</span>)</span> &#123;</span><br><span class="line">        Blank()</span><br><span class="line">        Text(<span class="string">`sum <span class="subst">$&#123;<span class="built_in">this</span>.sum&#125;</span>`</span>)</span><br><span class="line">          .fontWeight(FontWeight.Medium)</span><br><span class="line">        Button(<span class="string">&quot;修改Grade&quot;</span>)</span><br><span class="line">          .onClick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.student.grade.grade = <span class="number">30</span></span><br><span class="line">          &#125;)</span><br><span class="line">        Blank()</span><br><span class="line">      &#125;</span><br><span class="line">      .width(<span class="string">&quot;100%&quot;</span>)</span><br><span class="line">      .height(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Provider-和-Consumer"><a href="#Provider-和-Consumer" class="headerlink" title="@Provider 和@Consumer"></a>@Provider 和@Consumer</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>用于父组件和子孙组件跨层级数据沟通，只要在同个层级树上，都可以获取到对应的数据</li><li>如下代码，点击 Change 按钮的时候，父组件和孙组件的 student2.name 都会更新 UI（前提是 name 属性加上了@Trace）</li></ol><p>也可以直接更新 student2 本身<br>3. 因为是跨组件传递，所以即使 Info 组件不声明 student2 属性，OtherInfo 组件也可以通过@Comsumer 得到祖父组件的值</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">@Entry</span><br><span class="line">@ComponentV2</span><br><span class="line"><span class="keyword">struct</span> Index &#123;</span><br><span class="line"></span><br><span class="line">  @Local student: Student = <span class="keyword">new</span> <span class="constructor">Student(<span class="string">&quot;John&quot;</span>,18, <span class="params">new</span> Grade(3,<span class="string">&quot;B&quot;</span>)</span>)</span><br><span class="line"></span><br><span class="line">  @<span class="constructor">Provider()</span> student2: Student = <span class="keyword">new</span> <span class="constructor">Student(<span class="string">&quot;Mary&quot;</span>,20, <span class="params">new</span> Grade(4,<span class="string">&quot;B&quot;</span>)</span>)</span><br><span class="line"></span><br><span class="line">  build<span class="literal">()</span> &#123;</span><br><span class="line">      <span class="constructor">Column(&#123; <span class="params">space</span>: 20 &#125;)</span> &#123;</span><br><span class="line">        <span class="constructor">Blank()</span></span><br><span class="line">        <span class="constructor">Text(`<span class="params">name</span>: $&#123;<span class="params">this</span>.<span class="params">student2</span>.<span class="params">name</span>&#125;`)</span></span><br><span class="line">        <span class="constructor">Text(`<span class="params">age</span>: $&#123;<span class="params">this</span>.<span class="params">student2</span>.<span class="params">age</span>&#125;`)</span></span><br><span class="line">        <span class="constructor">Info()</span></span><br><span class="line">        <span class="constructor">Blank()</span></span><br><span class="line">      &#125;</span><br><span class="line">      .width(<span class="string">&quot;100%&quot;</span>)</span><br><span class="line">      .height(&#x27;<span class="number">100</span>%&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ComponentV2</span><br><span class="line"><span class="keyword">struct</span> Info &#123;</span><br><span class="line"></span><br><span class="line">  @<span class="constructor">Consumer()</span> student2: Student = <span class="keyword">new</span> <span class="constructor">Student(<span class="string">&quot;&quot;</span>,0,<span class="params">new</span> Grade(0,<span class="string">&quot;&quot;</span>)</span>)</span><br><span class="line"></span><br><span class="line">  build<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="constructor">Column(&#123; <span class="params">space</span>: 20 &#125;)</span> &#123;</span><br><span class="line">      <span class="constructor">OtherInfo()</span></span><br><span class="line">      <span class="constructor">Button(<span class="string">&quot;Change&quot;</span>)</span></span><br><span class="line">        .on<span class="constructor">Click(()</span> =&gt; &#123;</span><br><span class="line">          this.student2.name = <span class="string">&quot;Sarah&quot;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ComponentV2</span><br><span class="line"><span class="keyword">struct</span> OtherInfo &#123;</span><br><span class="line"></span><br><span class="line">  @<span class="constructor">Consumer()</span> student2: Student = <span class="keyword">new</span> <span class="constructor">Student(<span class="string">&quot;&quot;</span>,0,<span class="params">new</span> Grade(0,<span class="string">&quot;&quot;</span>)</span>)</span><br><span class="line"></span><br><span class="line">  build<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="constructor">Row(&#123;<span class="params">space</span>: 20&#125;)</span> &#123;</span><br><span class="line">      <span class="constructor">Text(`<span class="params">name</span>: $&#123;<span class="params">this</span>.<span class="params">student2</span>.<span class="params">name</span>&#125;`)</span></span><br><span class="line">      <span class="constructor">Text(`<span class="params">age</span>: $&#123;<span class="params">this</span>.<span class="params">student2</span>.<span class="params">age</span>&#125;`)</span></span><br><span class="line">    &#125;</span><br><span class="line">    .background<span class="constructor">Color(Color.Red)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>@Provider 加上别名改为 stu, 那么子组件也要改成 stu 才能访问得到，如果还是使用 student2，则反问不到<br>同理@Consumer 也可以加上别名，那么孙组件的@Comsumer 就得对应改成相应的别名</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Entry</span><br><span class="line">@ComponentV2</span><br><span class="line"><span class="keyword">struct</span> Index &#123;</span><br><span class="line"></span><br><span class="line">  @<span class="constructor">Provider(&#x27;<span class="params">stu</span>&#x27;)</span> student2: Student = <span class="keyword">new</span> <span class="constructor">Student(<span class="string">&quot;Mary&quot;</span>,20, <span class="params">new</span> Grade(4,<span class="string">&quot;B&quot;</span>)</span>)</span><br><span class="line"></span><br><span class="line">  build<span class="literal">()</span> &#123;</span><br><span class="line">      <span class="constructor">Column(&#123; <span class="params">space</span>: 20 &#125;)</span> &#123;</span><br><span class="line">        <span class="constructor">Blank()</span></span><br><span class="line">        <span class="constructor">Text(`<span class="params">name</span>: $&#123;<span class="params">this</span>.<span class="params">student2</span>.<span class="params">name</span>&#125;`)</span></span><br><span class="line">        <span class="constructor">Text(`<span class="params">age</span>: $&#123;<span class="params">this</span>.<span class="params">student2</span>.<span class="params">age</span>&#125;`)</span></span><br><span class="line">        <span class="constructor">Info()</span></span><br><span class="line">        <span class="constructor">Blank()</span></span><br><span class="line">      &#125;</span><br><span class="line">      .width(<span class="string">&quot;100%&quot;</span>)</span><br><span class="line">      .height(&#x27;<span class="number">100</span>%&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ComponentV2</span><br><span class="line"><span class="keyword">struct</span> Info &#123;</span><br><span class="line"></span><br><span class="line">  @<span class="constructor">Consumer()</span> stu: Student = <span class="keyword">new</span> <span class="constructor">Student(<span class="string">&quot;&quot;</span>,0,<span class="params">new</span> Grade(0,<span class="string">&quot;&quot;</span>)</span>)</span><br><span class="line"></span><br><span class="line">  build<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="constructor">Column(&#123; <span class="params">space</span>: 20 &#125;)</span> &#123;</span><br><span class="line">      <span class="constructor">OtherInfo()</span></span><br><span class="line">      <span class="constructor">Button(<span class="string">&quot;Change&quot;</span>)</span></span><br><span class="line">        .on<span class="constructor">Click(()</span> =&gt; &#123;</span><br><span class="line">          this.student2 =  <span class="keyword">new</span> <span class="constructor">Student(<span class="string">&quot;333&quot;</span>,0,<span class="params">new</span> Grade(0,<span class="string">&quot;222&quot;</span>)</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Monitor"><a href="#Monitor" class="headerlink" title="@Monitor"></a>@Monitor</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>可以在类或者结构体中监听某个属性或者某个对象的属性，只能修饰方法，并且方法固定一个参数为 IMoitor<br>相比起 V1 的@Watch 功能更加强大，可以获取到更新前后的值<br>IMonitor 类型:   IMonitor 类型的变量用作@Monitor 装饰方法的参数。</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">参数</th><th align="center">返回值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">dirty</td><td align="center">Array<string></td><td align="center">无</td><td align="center">无</td><td align="center">保存发生变化的属性名。</td></tr><tr><td align="center">value<T></td><td align="center">function</td><td align="center">path?: string</td><td align="center">IMonitorValue<T></td><td align="center">获得指定属性（path）的变化信息。当不填 path 时返回@Monitor 监听顺序中第一个改变的属性的变化信息。</td></tr></tbody></table><p>IMonitorValue<T>类型:  IMonitorValue<T>类型保存了属性变化的信息，包括属性名、变化前值、当前值。</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">before</td><td align="center">T</td><td align="center">监听属性变化之前的值。</td></tr><tr><td align="center">now</td><td align="center">T</td><td align="center">监听属性变化之后的当前值。</td></tr><tr><td align="center">path</td><td align="center">string</td><td align="center">监听的属性名。</td></tr></tbody></table><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><ol><li>使用@Monitor 加上要监听的属性名，如果是监听对象的属性，就使用点语法（需要属性被@Trace 修饰）</li><li>监听数组的时候可以用.0、.1 的方式表示要监听的内容下标，比如@Monitor(“dimensionTwo.0.0”, “dimensionTwo.1.1”)</li><li>监听多个属性用逗号分隔</li><li>可以用多个@Monitor，但是如果监听同个属性，那么只有最后一个方法会生效</li><li>如果监听的对象变了，但是对象里面的所有属性都与变化前的一致，那么不会触发监听回调</li><li>监听时标记的要监听的属性字符串需要初始化时确定，初始化后无法修改监听的属性。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entry</span></span><br><span class="line"><span class="meta">@ComponentV2</span></span><br><span class="line">struct Index &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Local</span> student: Student = <span class="keyword">new</span> Student(<span class="string">&quot;John&quot;</span>,<span class="number">18</span>, <span class="keyword">new</span> Grade(<span class="number">3</span>,<span class="string">&quot;B&quot;</span>))</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Local</span> count: <span class="built_in">number</span> = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Monitor</span>(<span class="string">&quot;student.name&quot;</span>, <span class="string">&quot;count&quot;</span>)</span><br><span class="line">  <span class="function"><span class="title">onChange</span>(<span class="params">monitor: IMonitor</span>)</span> &#123;</span><br><span class="line">    monitor.dirty.forEach(<span class="function">(<span class="params">path: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;path&#125;</span> change from <span class="subst">$&#123;monitor.value(path)?.before&#125;</span> to <span class="subst">$&#123;monitor.value(path)?.now&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">build</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">Column</span>(<span class="params">&#123; space: <span class="number">20</span> &#125;</span>)</span> &#123;</span><br><span class="line">        Blank()</span><br><span class="line">        Text(<span class="string">&quot;Name: &quot;</span> + <span class="built_in">this</span>.student.name)</span><br><span class="line">          .fontWeight(FontWeight.Bold)</span><br><span class="line">        Button(<span class="string">&quot;修改count&quot;</span>)</span><br><span class="line">          .onClick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.count += <span class="number">1</span></span><br><span class="line">            <span class="built_in">this</span>.student.age = <span class="built_in">this</span>.count</span><br><span class="line">            <span class="built_in">this</span>.student.name = <span class="string">`name_<span class="subst">$&#123;<span class="built_in">this</span>.count&#125;</span>`</span></span><br><span class="line">          &#125;)</span><br><span class="line">        Blank()</span><br><span class="line">      &#125;</span><br><span class="line">      .width(<span class="string">&quot;100%&quot;</span>)</span><br><span class="line">      .height(<span class="string">&#x27;100%&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Type"><a href="#Type" class="headerlink" title="@Type"></a>@Type</h2><p>当持久化数据的时候，遇到嵌套属性，需要标记为@Type，目的是反序列化的时候能够保持原来的类型信息<br>这样子使用 PersistenceV2 获取数据的时候能够维持原数据结构</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Type &#125; <span class="keyword">from</span> <span class="string">&#x27;@kit.ArkUI&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据中心</span></span><br><span class="line"><span class="meta">@ObservedV2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleChild</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Trace</span> p1: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">  p2: <span class="built_in">number</span> = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ObservedV2</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 对于复杂对象需要@Type修饰，确保序列化成功</span></span><br><span class="line">  <span class="meta">@Type</span>(SampleChild)</span><br><span class="line">  <span class="meta">@Trace</span> f: SampleChild = <span class="keyword">new</span> SampleChild();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> &#123; PersistenceV2 &#125; <span class="keyword">from</span> <span class="string">&#x27;@kit.ArkUI&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Sample &#125; <span class="keyword">from</span> <span class="string">&#x27;../Sample&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entry</span></span><br><span class="line"><span class="meta">@ComponentV2</span></span><br><span class="line">struct Page &#123;</span><br><span class="line">  prop: Sample = PersistenceV2.connect(Sample, <span class="function">() =&gt;</span> <span class="keyword">new</span> Sample())!;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">build</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">Column</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      Text(<span class="string">`Page1 add 1 to prop.p1: <span class="subst">$&#123;<span class="built_in">this</span>.prop.f.p1&#125;</span>`</span>)</span><br><span class="line">        .fontSize(<span class="number">30</span>)</span><br><span class="line">        .onClick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.prop.f.p1++;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;鸿蒙 API 12 推出了 V2 版本的状态管理装饰器，比起 V1 装饰器，V2 装饰器的职责更加地清晰，并且能力也得到了加强，建议后续开发使用 V2 版本的装饰器&lt;/p&gt;</summary>
    
    
    
    
    <category term="Harmony" scheme="https://www.arclin.cn/tags/Harmony/"/>
    
  </entry>
  
  <entry>
    <title>Swift6新特性</title>
    <link href="https://www.arclin.cn/post/feb7c155.html"/>
    <id>https://www.arclin.cn/post/feb7c155.html</id>
    <published>2024-07-09T13:53:21.000Z</published>
    <updated>2025-05-14T14:31:36.269Z</updated>
    
    <content type="html"><![CDATA[<p>本文旨在介绍ybox桌面端的一些开发上使用的新技术以及设计方法。</p><span id="more"></span><h1 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h1><h2 id="if、switch-作为表达式之一"><a href="#if、switch-作为表达式之一" class="headerlink" title="if、switch 作为表达式之一"></a>if、switch 作为表达式之一</h2><blockquote><p>swift5.9</p></blockquote><p>比如在一段网络请求方法中，当 paramsAsQuery为true的时候，需要将参数作为query插入到url中而不是放在httpBody里面<br>以前可能会这么写</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> urlString: <span class="built_in">String</span>?</span><br><span class="line"><span class="keyword">if</span> paramsAsQuery,<span class="keyword">let</span> query = <span class="keyword">params</span>?.toQueryParameters() &#123;</span><br><span class="line">     urlString = <span class="string">&quot;\(urlString)?\(query)&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     urlString = url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以这么写</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> urlString <span class="operator">=</span> <span class="keyword">if</span> paramsAsQuery, <span class="keyword">let</span> query <span class="operator">=</span> params<span class="operator">?</span>.toQueryParameters() &#123;</span><br><span class="line">    <span class="string">&quot;<span class="subst">\(url)</span>?<span class="subst">\(query)</span>&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了if, switch也一样可以，用法同理</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><blockquote><p>Swift 5.7</p></blockquote><p>有时需要判断分支是否符合以下格式：union/x.xx/union_x.xx_feature 或 union/x.xx/union_x.xx_maint，用来判断是否是主分支，会使用到正则表达式</p><p>方法如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex <span class="operator">=</span> <span class="keyword">try?</span> <span class="type">NSRegularExpression</span>(pattern: <span class="string">&quot;^union<span class="subst">\\</span>/<span class="subst">\\</span>d&#123;1,&#125;<span class="subst">\\</span>.<span class="subst">\\</span>d&#123;1,&#125;<span class="subst">\\</span>/union_<span class="subst">\\</span>d&#123;1,&#125;<span class="subst">\\</span>.<span class="subst">\\</span>d&#123;1,&#125;_feature$&quot;</span>, options: [])</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> results <span class="operator">=</span> regex<span class="operator">?</span>.matches(in: originStr, options: [], range: <span class="type">NSRange</span>(location: <span class="number">0</span>, length: originStr.count)) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> matchItems <span class="operator">=</span> results.map &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> range <span class="operator">=</span> <span class="type">Range</span>(<span class="variable">$0</span>.range, in: originStr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="subst">\(originStr[range])</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> matchItems</span><br></pre></td></tr></table></figure><p>正则本身就复杂，还要考虑字符反转义，所以就很麻烦<br>Swift 5.7 之后，正则迎来了史诗级提升，上述代码可以简化为</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern = /^<span class="keyword">union</span>\/\d&#123;<span class="number">1</span>,&#125;\.\d&#123;<span class="number">1</span>,&#125;\/<span class="keyword">union</span><span class="number">_</span>\d&#123;<span class="number">1</span>,&#125;\.\d&#123;<span class="number">1</span>,&#125;_feature$/</span><br><span class="line">guard <span class="keyword">let</span> matchName =<span class="built_in"> name</span>.firstMatch(of: pattern)?.output <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span><span class="built_in"> false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> matchName</span><br></pre></td></tr></table></figure><p>用 /…/ 两个斜杠的方式就可以构建一个正则表达式<br>如果觉得正则表达式太复杂，也可以使用DSL一样的构建方式构建正则对象</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> regex = Regex &#123;</span><br><span class="line">    <span class="string">&quot;union/&quot;</span></span><br><span class="line">    <span class="constructor">One(.<span class="params">digit</span>)</span></span><br><span class="line">    <span class="string">&quot;.&quot;</span></span><br><span class="line">    <span class="constructor">OneOrMore(.<span class="params">digit</span>)</span></span><br><span class="line">    <span class="string">&quot;/union_&quot;</span></span><br><span class="line">    <span class="constructor">One(.<span class="params">digit</span>)</span></span><br><span class="line">    <span class="string">&quot;.&quot;</span></span><br><span class="line">    <span class="constructor">OneOrMore(.<span class="params">digit</span>)</span></span><br><span class="line">    <span class="string">&quot;_feature&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">guard <span class="keyword">let</span> matchName = name.first<span class="constructor">Match(<span class="params">of</span>: <span class="params">regex</span>)</span>?.output <span class="keyword">else</span> &#123;</span><br><span class="line">    return <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">return matchName</span><br></pre></td></tr></table></figure><p>效果同上</p><h1 id="Concurreny"><a href="#Concurreny" class="headerlink" title="Concurreny"></a>Concurreny</h1><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程两个要素</p><ol><li>用await表示等待，如果异步函数返回正常则继续执行</li><li>用try抛出异常，如果异步函数返回错误则执行catch逻辑</li></ol><p>举个例子，批量拉取代码，每个目录都需要执行一下git pull, 使用协程之前需要递归遍历一个个拉取</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> func pull(workspace: LocalWorkspace, component<span class="variable">s:</span> [Component], <span class="built_in">index</span>: Int = <span class="number">0</span>, operation: Operation, <span class="built_in">complete</span>: ((Component?, Bool)-&gt; Void)?) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">index</span> &gt;= components.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="built_in">complete</span>?(nil, true)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> component = components[<span class="built_in">index</span>] </span><br><span class="line">    pull(componen<span class="variable">t:</span> component) &#123; [weak self] success, errorMsg, <span class="keyword">comp</span> in</span><br><span class="line">        operation.<span class="built_in">complete</span>.<span class="keyword">append</span>(Result(name: <span class="keyword">comp</span>.name, succes<span class="variable">s:</span> success, conten<span class="variable">t:</span> success ? <span class="string">&quot;成功&quot;</span>: errorMsg))</span><br><span class="line">        operation.percent = CGFloat(operation.<span class="built_in">complete</span>.<span class="built_in">count</span>) / CGFloat(components.<span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">if</span> success &#123;</span><br><span class="line">            <span class="built_in">complete</span>?(<span class="keyword">comp</span>, true)</span><br><span class="line">            self?.pull(workspace: workspace, component<span class="variable">s:</span> components, <span class="built_in">index</span>: <span class="built_in">index</span> + <span class="number">1</span> , operation: operation, <span class="built_in">complete</span>: <span class="built_in">complete</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">complete</span>?(<span class="keyword">comp</span>, false)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用协程之后</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func pull(workspace: LocalWorkspace, components: <span class="literal">[C<span class="identifier">omponent</span>]</span>, operation: Operation) async &#123;</span><br><span class="line">    <span class="keyword">for</span> component <span class="keyword">in</span> components &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> await pull(component: component)</span><br><span class="line">            operation.complete.append(<span class="constructor">Result(<span class="params">name</span>: <span class="params">component</span>.<span class="params">name</span>, <span class="params">success</span>: <span class="params">true</span>, <span class="params">content</span>: <span class="string">&quot;成功&quot;</span>)</span>)</span><br><span class="line">        &#125; catch &#123;</span><br><span class="line">            operation.complete.append(<span class="constructor">Result(<span class="params">name</span>: <span class="params">component</span>.<span class="params">name</span>, <span class="params">success</span>: <span class="params">false</span>, <span class="params">content</span>: <span class="params">error</span>.<span class="params">localizedDescription</span>)</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        operation.percent = <span class="constructor">CGFloat(<span class="params">operation</span>.<span class="params">complete</span>.<span class="params">count</span>)</span><span class="operator"> / </span><span class="constructor">CGFloat(<span class="params">components</span>.<span class="params">count</span>)</span></span><br><span class="line">        await <span class="module-access"><span class="module"><span class="identifier">MainActor</span>.</span></span>run &#123;</span><br><span class="line">            update<span class="constructor">Component(<span class="params">component</span>)</span></span><br><span class="line">            currentOperation = operation</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然上面的执行还只是串行的效果，如果需要并行，可以简单修改</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func pull(workspace: LocalWorkspace, components: <span class="literal">[C<span class="identifier">omponent</span>]</span>, operation: Operation) async &#123;</span><br><span class="line">    await <span class="keyword">with</span><span class="constructor">TaskGroup(<span class="params">of</span>: String.<span class="params">self</span>)</span> &#123; group <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">for</span> component <span class="keyword">in</span> components &#123;</span><br><span class="line">            group.addTask &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> await self.pull(component: component)</span><br><span class="line">                    operation.complete.append(<span class="constructor">Result(<span class="params">name</span>: <span class="params">component</span>.<span class="params">name</span>, <span class="params">success</span>: <span class="params">true</span>, <span class="params">content</span>: <span class="string">&quot;成功&quot;</span>)</span>)</span><br><span class="line">                &#125; catch &#123;</span><br><span class="line">                    operation.complete.append(<span class="constructor">Result(<span class="params">name</span>: <span class="params">component</span>.<span class="params">name</span>, <span class="params">success</span>: <span class="params">false</span>, <span class="params">content</span>: <span class="params">error</span>.<span class="params">localizedDescription</span>)</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                operation.percent = <span class="constructor">CGFloat(<span class="params">operation</span>.<span class="params">complete</span>.<span class="params">count</span>)</span><span class="operator"> / </span><span class="constructor">CGFloat(<span class="params">components</span>.<span class="params">count</span>)</span></span><br><span class="line">                await <span class="module-access"><span class="module"><span class="identifier">MainActor</span>.</span></span>run &#123;</span><br><span class="line">                    self.update<span class="constructor">Component(<span class="params">component</span>)</span></span><br><span class="line">                    self.currentOperation = operation</span><br><span class="line">                &#125;</span><br><span class="line">                return component.name</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> await value <span class="keyword">in</span> group &#123;</span><br><span class="line">            print(<span class="string">&quot;\(value)拉取完成&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展一下，如果不是数组类型的任务并发，可以使用async let方式使用控制并发，如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchUserData</span>()</span> <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">let</span> profile <span class="operator">=</span> fetchUserProfile()</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">let</span> posts <span class="operator">=</span> fetchUserPosts()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并行等待两个异步操作的结果</span></span><br><span class="line">        <span class="keyword">let</span> userProfile <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> profile</span><br><span class="line">        <span class="keyword">let</span> userPosts <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> posts</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;User Profile: <span class="subst">\(userProfile)</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;User Posts: <span class="subst">\(userPosts)</span>&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: <span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> fetchUserData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用MainActor替代主线程回调<br>有时候我们需要刷新单个工作区，需要重新查看当前工作区的所有组件的状态，可以调一个全局异步子线程去查询然后主线程回调，可以这么写</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func reload<span class="constructor">Workspace(<span class="params">_</span> <span class="params">workspace</span>: LocalWorkspace)</span> &#123;</span><br><span class="line">    workspace.isLoading = <span class="literal">true</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>global<span class="literal">()</span>.async &#123;</span><br><span class="line">        var newWpss: <span class="literal">[L<span class="identifier">ocalWorkspace</span>]</span> = <span class="literal">[]</span></span><br><span class="line">        <span class="keyword">for</span> wps <span class="keyword">in</span> self.workspaceViewModel.workSpaces &#123;</span><br><span class="line">            <span class="keyword">if</span> wps.path<span class="operator"> == </span>workspace.path &#123;</span><br><span class="line">                <span class="keyword">let</span> path = workspace.path</span><br><span class="line">                <span class="keyword">let</span> name = (path <span class="keyword">as</span> NSString).lastPathComponent</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    var components = <span class="keyword">try</span> <span class="module-access"><span class="module"><span class="identifier">Component</span>.</span></span>parse<span class="constructor">Components(<span class="params">workspace</span>: <span class="params">path</span>)</span>.map &#123;</span><br><span class="line">                        <span class="keyword">let</span> comp = <span class="constructor">Component($0)</span></span><br><span class="line">                        self.update<span class="constructor">Component(<span class="params">comp</span>)</span></span><br><span class="line">                        return comp</span><br><span class="line">                    &#125;</span><br><span class="line">                    components = components.sorted &#123; comp1, comp2 <span class="keyword">in</span></span><br><span class="line">                        return (comp1.unPushCount + comp1.unPullCount) &gt; (comp2.unPushCount + comp2.unPullCount)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">let</span> workspace = <span class="constructor">LocalWorkspace(<span class="params">name</span>: <span class="params">name</span>, <span class="params">path</span>: <span class="params">path</span>, <span class="params">components</span>: <span class="params">components</span>)</span></span><br><span class="line">                    newWpss.append(workspace)</span><br><span class="line">                &#125; catch &#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newWpss.append(wps)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">DispatchQueue</span>.</span></span>main.async &#123;</span><br><span class="line">            self.workspaceViewModel = <span class="constructor">ComponentListViewModel(<span class="params">workSpaces</span>: <span class="params">newWpss</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用@MainActor， 再将读取子线程修改到读取文件的那部分，那可以简单许多</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadWorkspace</span>(<span class="keyword">_</span> <span class="params">workspace</span>: <span class="type">LocalWorkspace</span>)</span> &#123;</span><br><span class="line">        <span class="type">Task</span> &#123; <span class="meta">@MainActor</span> <span class="keyword">in</span></span><br><span class="line">            workspace.isLoading <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">for</span> wps <span class="keyword">in</span> <span class="keyword">self</span>.workspaceViewModel.workSpaces <span class="keyword">where</span> wps.path <span class="operator">==</span> workspace.path &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> baseComponents <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">Component</span>.parseComponents(workspace: path)</span><br><span class="line">                    <span class="keyword">var</span> components <span class="operator">=</span> baseComponents.map &#123;</span><br><span class="line">                        <span class="keyword">let</span> comp <span class="operator">=</span> <span class="type">Component</span>(<span class="variable">$0</span>)</span><br><span class="line">                        <span class="keyword">self</span>.updateComponent(comp)</span><br><span class="line">                        <span class="keyword">return</span> comp</span><br><span class="line">                    &#125;</span><br><span class="line">                    components <span class="operator">=</span> components.sorted &#123; comp1, comp2 <span class="keyword">in</span></span><br><span class="line">                        <span class="keyword">return</span> (comp1.unPushCount <span class="operator">+</span> comp1.unPullCount <span class="operator">+</span> comp1.unCommitCount) <span class="operator">&gt;</span> (comp2.unPushCount <span class="operator">+</span> comp2.unPullCount <span class="operator">+</span> comp2</span><br><span class="line">                            .unCommitCount)</span><br><span class="line">                    &#125;</span><br><span class="line">                    workspace.components <span class="operator">=</span> components</span><br><span class="line">                    workspace.isLoading <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                    <span class="built_in">print</span>(error)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.workspaceViewModel <span class="operator">=</span> <span class="type">ComponentListViewModel</span>(workSpaces: <span class="keyword">self</span>.workspaceViewModel.workSpaces)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>系统会自动将Task里面包含的部分都强制在主线程执行<br>@MainActor除了可以修饰闭包之外，还可以直接写在方法前面，表示该方法都是在主线程执行的， 或者写在类或者结构体前面，这表示强制要求该类的方法或成员属性必须在主线程中执行或进行读写操作。<br>提问：下面这串代码最后会怎么输出？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainActor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> testItem: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;访问的testItem在: <span class="subst">\(Thread.current)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">globalThread</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">Thread</span>.current)</span><br><span class="line">        testItem <span class="operator">=</span> <span class="string">&quot;123&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前线程111：<span class="subst">\(Thread.current)</span>&quot;</span>)</span><br><span class="line">    <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前线程222：<span class="subst">\(Thread.current)</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> item <span class="operator">=</span> <span class="keyword">await</span> <span class="type">TestClass</span>()</span><br><span class="line">        <span class="keyword">await</span> item.globalThread()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前线程333：<span class="subst">\(Thread.current)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前线程444：<span class="subst">\(Thread.current)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当前线程<span class="number">111</span>：&lt;NSThread: <span class="number">0</span>x600001700640&gt;&#123;<span class="attr">number</span> = <span class="number">4</span>, <span class="attr">name</span> = (<span class="literal">null</span>)&#125;</span><br><span class="line">当前线程<span class="number">222</span>：&lt;NSThread: <span class="number">0</span>x60000170cbc0&gt;&#123;<span class="attr">number</span> = <span class="number">9</span>, <span class="attr">name</span> = (<span class="literal">null</span>)&#125;</span><br><span class="line">当前线程<span class="number">444</span>：&lt;NSThread: <span class="number">0</span>x600001700640&gt;&#123;<span class="attr">number</span> = <span class="number">4</span>, <span class="attr">name</span> = (<span class="literal">null</span>)&#125;</span><br><span class="line">&lt;_NSMainThread: <span class="number">0</span>x600001708240&gt;&#123;<span class="attr">number</span> = <span class="number">1</span>, <span class="attr">name</span> = main&#125;</span><br><span class="line">访问的testItem在: &lt;_NSMainThread: <span class="number">0</span>x600001708240&gt;&#123;<span class="attr">number</span> = <span class="number">1</span>, <span class="attr">name</span> = main&#125;</span><br><span class="line">当前线程<span class="number">333</span>：&lt;NSThread: <span class="number">0</span>x60000170cbc0&gt;&#123;<span class="attr">number</span> = <span class="number">9</span>, <span class="attr">name</span> = (<span class="literal">null</span>)&#125;</span><br></pre></td></tr></table></figure><h2 id="数据竞争（Data-Race）"><a href="#数据竞争（Data-Race）" class="headerlink" title="数据竞争（Data Race）"></a>数据竞争（Data Race）</h2><p>在循环执行多个仓库的拉取或者推送的时候，需要看到对应进度以及成功或者失败的状态，失败的话要允许显示失败信息</p><p>其中，pull操作本质上是fetch + merge 的流程，fetch本质是一个文件下载的流程，他的进度回调方法会在子线程<br>所以当多个仓库并发操作的时候，这里就会存在多个子线程同时更改Progress的情况，所以这里我们用actor避免数据竞争情况<br>actor : 属于引用类型，类似class但是不可继承<br>定义一个actor, 存储操作类型，已经完成的组件及其结果，还有当前进度</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  actor <span class="type">Operation</span> &#123;</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> action: <span class="type">Component</span>.<span class="type">Action</span></span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> complete: [<span class="type">Result</span>] <span class="operator">=</span> []</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> percent: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">action</span>: <span class="type">Component</span>.<span class="type">Action</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.action <span class="operator">=</span> action</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addComplete</span>(<span class="keyword">_</span> <span class="params">result</span>: <span class="type">Result</span>)</span> &#123;</span><br><span class="line">        complete.append(result)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updatePercent</span>(<span class="keyword">_</span> <span class="params">newValue</span>: <span class="type">CGFloat</span>)</span> &#123;</span><br><span class="line">        percent <span class="operator">=</span> newValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，actor里面的方法和属性都需要通过await读写</p><p>在dataProvider定义属性，提供给SwiftUI渲染, 当数据更新的时候，调用updateProgress方法更新数据进而更新UI</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Published</span> <span class="keyword">var</span> progress: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="number">0.0</span> </span><br><span class="line"><span class="meta">@Published</span> <span class="keyword">var</span> completeCount: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="meta">@Published</span> <span class="keyword">var</span> totalCount: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="meta">@Published</span> <span class="keyword">var</span> title: <span class="type">String</span>?</span><br><span class="line"><span class="meta">@Published</span> <span class="keyword">var</span> results: [<span class="type">Result</span>] <span class="operator">=</span> []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateProgress</span>()</span> <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> currentOperation <span class="operator">=</span> <span class="keyword">self</span>.currentOperation, <span class="keyword">await</span> currentOperation.action.components.count <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    progress <span class="operator">=</span> <span class="type">CGFloat</span>(<span class="keyword">await</span> currentOperation.complete.count) <span class="operator">/</span> <span class="type">CGFloat</span>(<span class="keyword">await</span> currentOperation.action.components.count)</span><br><span class="line">    completeCount <span class="operator">=</span> <span class="keyword">await</span> currentOperation.complete.count</span><br><span class="line">    totalCount <span class="operator">=</span> <span class="keyword">await</span> currentOperation.action.components.count</span><br><span class="line">    results <span class="operator">=</span> <span class="keyword">await</span> currentOperation.complete</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pull</span>(<span class="params">workspace</span>: <span class="type">LocalWorkspace</span>, <span class="params">components</span>: [<span class="type">Component</span>], <span class="params">operation</span>: <span class="type">Operation</span>)</span> <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> withTaskGroup(of: <span class="type">String</span>.<span class="keyword">self</span>) &#123; group <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">for</span> component <span class="keyword">in</span> components &#123;</span><br><span class="line">            group.addTask &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(component.name)</span>开始执行&quot;</span>)</span><br><span class="line">                    <span class="keyword">try</span> <span class="keyword">await</span> <span class="keyword">self</span>.pull(component: component)</span><br><span class="line">                    <span class="keyword">await</span> operation.addComplete(<span class="type">Result</span>(name: component.name, success: <span class="literal">true</span>, content: <span class="string">&quot;成功&quot;</span>))</span><br><span class="line">                &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                    <span class="keyword">await</span> operation.addComplete(<span class="type">Result</span>(name: component.name, success: <span class="literal">false</span>, content: error.localizedDescription))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">await</span> operation.updatePercent(<span class="type">CGFloat</span>(operation.complete.count) <span class="operator">/</span> <span class="type">CGFloat</span>(components.count))</span><br><span class="line">                <span class="keyword">self</span>.updateComponent(component)</span><br><span class="line">                <span class="keyword">await</span> <span class="keyword">self</span>.updateProgress()</span><br><span class="line">                <span class="keyword">return</span> component.name</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">await</span> value <span class="keyword">in</span> group &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(value)</span>拉取完成&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Task中，如果有actor对象发生行为，自动隔离其他线程对他的操作，相当于加锁，保证这个对象的操作是线程安全的，如果actor内某个方法不需要隔离（比如没有对属性进行操作），那么在方法前面加上nonisolated即可</p><p>当然，保证线程安全 ≠ 在主线程上操作，如果需要在主线程上操作，可以搭配@MainActor + class，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainActor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SwiftUI"><a href="#SwiftUI" class="headerlink" title="SwiftUI"></a>SwiftUI</h1><h2 id="EnvironmentObject"><a href="#EnvironmentObject" class="headerlink" title="@EnvironmentObject"></a>@EnvironmentObject</h2><p>众所周知，要弹窗必须在view下面添加一个alert属性，并且在里面定义alert的样式，如果很多地方都有弹窗需求，那么这个重复代码量就很大。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 第一件事，创建一个Bool控制弹窗显示和隐藏</span></span><br><span class="line"><span class="variable">@State</span> var isShowing = false</span><br><span class="line">VStack &#123;</span><br><span class="line">    <span class="selector-tag">Text</span>(<span class="string">&quot;Anything&quot;</span>)</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 第二个使其，设计弹窗样式，如果弹窗样式复杂，那代码量就更多</span></span><br><span class="line"><span class="selector-class">.alert</span>(<span class="attribute">isPresented</span>: isShowing) &#123;</span><br><span class="line">    <span class="selector-tag">Alert</span>(<span class="attribute">title</span>: Text(title), <span class="attribute">message</span>: Text(message), <span class="attribute">dismissButton</span>: .default(Text(<span class="string">&quot;OK&quot;</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标：设计一个弹窗用来提示错误信息，使其在任意一个View上面都可以弹出，尽量减少重复编码</p><p>首先设计一个类，在全局生效</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlertManager</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> isShowing: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> title: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> message: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showAlert</span>(<span class="params">title</span>: <span class="type">String</span>, <span class="params">message</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.title <span class="operator">=</span> title</span><br><span class="line">        <span class="keyword">self</span>.message <span class="operator">=</span> message</span><br><span class="line">        <span class="keyword">self</span>.isShowing <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化后注入到根视图中， 使用environmentObject注入</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@main</span></span><br><span class="line">struct <span class="attribute">yboxDesktopApp</span>: App &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">@StateObject</span> private var alertManager = AlertManager()</span><br><span class="line">  </span><br><span class="line">    var <span class="attribute">body</span>: some Scene &#123;</span><br><span class="line">        <span class="selector-tag">MenuBarExtra</span>(<span class="string">&quot;yboxDeskTop&quot;</span>, <span class="attribute">image</span>: <span class="string">&quot;icon50&quot;</span>) &#123;</span><br><span class="line">            <span class="selector-tag">ContentView</span>()</span><br><span class="line">                <span class="selector-class">.environmentObject</span>(alertManager)</span><br><span class="line">                <span class="selector-class">.onAppear</span> &#123;</span><br><span class="line">                    <span class="selector-tag">print</span>(<span class="string">&quot;Visible&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.menuBarExtraStyle</span>(.window)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后可以在这个根视图下的任意一个子视图都可以访问到这个alertManager对象<br>如下，在view内定义好环境变量对象之后，点击按钮可以直接访问到alertManager对象，并调用其方法</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">struct</span> <span class="selector-tag">GitUserEditView</span>: <span class="selector-tag">View</span> &#123;</span><br><span class="line">    <span class="variable">@EnvironmentObject</span> var <span class="attribute">alertManager</span>: AlertManager</span><br><span class="line"></span><br><span class="line">    var <span class="attribute">body</span>: some View &#123;</span><br><span class="line">        <span class="selector-tag">VStack</span> &#123;</span><br><span class="line">            <span class="selector-tag">Button</span>(<span class="attribute">action</span>: &#123;</span><br><span class="line">                <span class="selector-tag">alertManager</span><span class="selector-class">.showAlert</span>(<span class="attribute">title</span>: <span class="string">&quot;提示&quot;</span>, <span class="attribute">message</span>: <span class="string">&quot;信息&quot;</span>)</span><br><span class="line">            &#125;) &#123;</span><br><span class="line">                <span class="selector-tag">Text</span>(<span class="string">&quot;点击&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>为了创建弹窗，我们创建一个ViewModifier用于修改View的属性</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">struct</span> <span class="selector-tag">ErrorAlert</span>: <span class="selector-tag">ViewModifier</span> &#123;</span><br><span class="line">    <span class="variable">@EnvironmentObject</span> var <span class="attribute">errorManager</span>: AlertManager</span><br><span class="line"></span><br><span class="line">    func body(<span class="attribute">content</span>: Content) -&gt; some View &#123;</span><br><span class="line">        <span class="selector-tag">content</span></span><br><span class="line">            <span class="selector-class">.alert</span>(<span class="attribute">isPresented</span>: $errorManager.isShowing) &#123;</span><br><span class="line">                <span class="selector-tag">Alert</span>(<span class="attribute">title</span>: Text(errorManager.title), <span class="attribute">message</span>: Text(errorManager.message), <span class="attribute">dismissButton</span>: .default(Text(<span class="string">&quot;OK&quot;</span>)))</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓展一下View, 给他添加刚才创建的ViewModifier</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">errorAlert</span>()</span> -&gt; <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.modifier(<span class="type">ErrorAlert</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成上述工作之后，用如下方式就可以比较低成本的接入弹窗能力</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">struct</span> <span class="selector-tag">GitUserEditView</span>: <span class="selector-tag">View</span> &#123;</span><br><span class="line">    <span class="variable">@EnvironmentObject</span> var <span class="attribute">alertManager</span>: AlertManager</span><br><span class="line">    </span><br><span class="line">    var <span class="attribute">body</span>: some View &#123;</span><br><span class="line">        <span class="selector-tag">VStack</span> &#123;</span><br><span class="line">            <span class="selector-tag">Button</span>(<span class="attribute">action</span>: &#123;</span><br><span class="line">                <span class="selector-tag">alertManager</span><span class="selector-class">.showAlert</span>(<span class="attribute">title</span>: <span class="string">&quot;提示&quot;</span>, <span class="attribute">message</span>: <span class="string">&quot;信息&quot;</span>)</span><br><span class="line">            &#125;) &#123;</span><br><span class="line">                <span class="selector-tag">Text</span>(<span class="string">&quot;点击&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.errorAlert</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Swift-6"><a href="#Swift-6" class="headerlink" title="Swift 6"></a>Swift 6</h1><h2 id="数据竞争问题"><a href="#数据竞争问题" class="headerlink" title="数据竞争问题"></a>数据竞争问题</h2><p>Swift 6 之前，下面代码第十行会有警告，因为user会被认为是不安全的，可能会被其他方法引用导致数据竞争</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name <span class="operator">=</span> <span class="string">&quot;Anonymous&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">            .task &#123;</span><br><span class="line">                <span class="keyword">let</span> user <span class="operator">=</span> <span class="type">User</span>()</span><br><span class="line">                <span class="keyword">await</span> loadData(for: user)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadData</span>(<span class="params">for</span> <span class="params">user</span>: <span class="type">User</span>)</span> <span class="keyword">async</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Loading data for <span class="subst">\(user.name)</span>…&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 6以后警告消失，因为编译器检查到没有其他地方调用了，所以他是安全的<br>另外一个修改，在Swift 6中，如果ViewModel被标记为了@MainActor，那么使用他的LogInView也必须被标记为@MainActor</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainActor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">authenticate</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Authenticating…&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MainActor</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LogInView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">private</span> <span class="keyword">var</span> model <span class="operator">=</span> <span class="type">ViewModel</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(<span class="string">&quot;Hello, world&quot;</span>, action: startAuthentication)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">startAuthentication</span>()</span> &#123;</span><br><span class="line">        model.authenticate()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理， DataController被标记为@MainActor后，入参Logger也必须要@MainActor</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@MainActor</span></span><br><span class="line">class Logger &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@MainActor</span> </span><br><span class="line">class DataController &#123;</span><br><span class="line">    <span class="selector-tag">init</span>(<span class="attribute">logger</span>: Logger = Logger()) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一切都是为了避免数据竞争所作出的修改。</p><h2 id="count-where"><a href="#count-where" class="headerlink" title="count(where:)"></a>count(where:)</h2><p>以前要在下面数组中得到85以上的数据个数，需要创建一个临时数组再数一下</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scores = [<span class="number">100</span>, <span class="number">80</span>, <span class="number">85</span>]</span><br><span class="line"><span class="keyword">let</span> passcount = scores<span class="built_in">.filter</span>(&#123; <span class="variable">$0</span> &gt; <span class="number">85</span> &#125;)<span class="built_in">.count</span></span><br></pre></td></tr></table></figure><p>Swift 6之后可以使用方法</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> passCount = scores<span class="built_in">.count</span> &#123; <span class="variable">$0</span> &gt;= <span class="number">85</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="类型化异常抛出"><a href="#类型化异常抛出" class="headerlink" title="类型化异常抛出"></a>类型化异常抛出</h2><p>以前我们写try catch的时候，在catch里面需要判断方法throw是的什么类型再进行处理</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    <span class="keyword">try</span> xxx</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span><span class="built_in"> error</span> <span class="keyword">as</span> NSError &#123;</span><br><span class="line">    handleNSError<span class="built_in">(error</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span><span class="built_in"> error</span> <span class="keyword">as</span> CustomError &#123;</span><br><span class="line">    handleCustomError<span class="built_in">(error</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">   handleOtherError<span class="built_in">(error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 6之后可以抛出指定类型的异常，外部可以直接知道Error的类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">count</span>&lt;<span class="type">E</span>&gt;(<span class="params">where</span> <span class="params">predicate</span>: (<span class="type">Element</span>) <span class="keyword">throws</span>(<span class="type">E</span>) -&gt; <span class="type">Bool</span>)</span> <span class="keyword">throws</span>(<span class="type">E</span>) -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure><h2 id="import访问控制"><a href="#import访问控制" class="headerlink" title="import访问控制"></a>import访问控制</h2><p>Swift 6之后可以使用如下语法<br>private import SomeLibrary<br>当然private也可以改为public、internal等访问控制符<br>这个语法可以帮助我们隐藏某些库的引入，让外部无法知道我们依赖了哪些库</p><h2 id="不可复制类型"><a href="#不可复制类型" class="headerlink" title="不可复制类型"></a>不可复制类型</h2><p>~Copyable是可复制前面带了一个取反符号，所以直译为不可复制类型<br>不可复制类型是在 Swift 5.9 中引入的，但在 Swift 6 中得到了几次升级<br>虽然翻译是这么翻译，但是我觉得更确切的说法应该是一次性类型。<br>使用方法如下，MissionImpossibleMessage标记为不可复制，并且read方法标记为了consuming<br>意味着message实例调用了read方法后会自动被销毁，他会被“消费”掉<br>继续执行print方法将会报错，因为message已经被销毁</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MissionImpossibleMessage</span>: ~<span class="title">Copyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> message: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">message</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.message <span class="operator">=</span> message</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consuming <span class="function"><span class="keyword">func</span> <span class="title">read</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> message <span class="operator">=</span> <span class="type">MissionImpossibleMessage</span>()</span><br><span class="line">message.read()</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure><h2 id="不连续下标"><a href="#不连续下标" class="headerlink" title="不连续下标"></a>不连续下标</h2><p>swift6升级了RangeSet, 支持从数组中分离出若干个满足条件的元素的不连续下标，并通过for循环结合下标进行遍历<br>比如下面的例子是从成绩表里面找到大于85分的成绩并打印出来<br>swift6之前我们可能会通过filter和map去解决问题，swift6之后多了一种解决方案</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">ExamResult</span> &#123;</span><br><span class="line">    var student: String</span><br><span class="line">    var score: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">results</span> = [</span><br><span class="line">    ExamResult(student: <span class="string">&quot;Eric Effiong&quot;</span>, score: 95),</span><br><span class="line">    ExamResult(student: <span class="string">&quot;Maeve Wiley&quot;</span>, score: 70),</span><br><span class="line">    ExamResult(student: <span class="string">&quot;Otis Milburn&quot;</span>, score: 100)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">let topResults = results.<span class="keyword">indices</span> &#123; student <span class="keyword">in</span></span><br><span class="line">    student.score &gt;= <span class="number">85</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">result</span> <span class="keyword">in</span> <span class="keyword">results</span>[topResults] &#123;</span><br><span class="line">    print(<span class="string">&quot;\(result.student) scored \(result.score)%&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Int128"><a href="#Int128" class="headerlink" title="Int128"></a>Int128</h2><p>就是支持了128位的整型</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let</span> enoughForAnybody: Int<span class="number">128</span> = <span class="number">170</span>_<span class="number">141</span>_<span class="number">183</span>_<span class="number">460</span>_<span class="number">469</span>_<span class="number">231</span>_<span class="number">731</span>_<span class="number">687</span>_<span class="number">303</span>_<span class="number">715</span>_<span class="number">884</span>_<span class="number">105</span>_<span class="number">727</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Swift开始支持Windows、Linux、C++混编、嵌入式编程</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文旨在介绍ybox桌面端的一些开发上使用的新技术以及设计方法。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="Swift" scheme="https://www.arclin.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Xcode 14 优化</title>
    <link href="https://www.arclin.cn/post/1ff3bfb6.html"/>
    <id>https://www.arclin.cn/post/1ff3bfb6.html</id>
    <published>2022-07-12T16:52:48.000Z</published>
    <updated>2022-07-12T17:50:45.919Z</updated>
    
    <content type="html"><![CDATA[<p>本文简述Xcode 14 的编译优化</p><span id="more"></span><h1 id="Link-fast-Improve-build-and-launch-time"><a href="#Link-fast-Improve-build-and-launch-time" class="headerlink" title="Link fast: Improve build and launch time"></a>Link fast: Improve build and launch time</h1><h2 id="什么是链接"><a href="#什么是链接" class="headerlink" title="什么是链接"></a>什么是链接</h2><p><img src="https://s2.loli.net/2022/07/11/kCstwgSpumHbaeU.jpg" alt="链接过程"></p><p>如图所示，链接将不同的语言，通过前端编译器，编译为中间代码LLVM IR，然后再通过，然后再通过LLVM后端编译器，编译成对应处理器架构的机器语言。</p><p>通过这张图我们可以清晰地看到有了中间代码IR的存在，我们就可以在开发高级语言的时候不用去考虑不同处理器之间的细节，而是统一由LLVM去处理，大大降低了开发成本。</p><p>然后链接这一行为，是发生在LLVM后端编译器上的，因为我们平时写代码的时候，以OC语言为例，每个m代码文件都会被编译成o文件，那多个o文件之间的互相调用，要怎么做呢，这时候就是通过链接把他们都合并成一个文件。比如在iOS中，最后就是产出一个Mach-o文件。</p><p>也就是说，链接将<code>各个模块（各个文件的编译产物）</code>的函数连接起来，产出各个架构的可执行文件。</p><p>然后在iOS中，链接方式有两种</p><ul><li>静态链接（ld64）：影响app的编译时间和包大小，选择性加载</li><li>动态链接（dyld）：影响App的启动耗时</li></ul><p>在iOS中我们制作的一些<code>.a</code>或者<code>.framework</code>这些静态库最后就会经过静态链接过程链接到我们的可执行文件中。</p><p>动态链接一般就是链接一些系统库，在启动的时候按需，动态地加载。</p><h2 id="Mach-0文件"><a href="#Mach-0文件" class="headerlink" title="Mach-0文件"></a>Mach-0文件</h2><p><img src="https://s2.loli.net/2022/07/11/bto5WBdzQ9IGx8E.png" alt="mach-o_format_basic_structure.png"></p><p>首先贴下官方的<a href="https://github.com/aidansteele/osx-abi-macho-file-format-reference/blob/master/Mach-O_File_Format.pdf">文档介绍</a></p><p>一个<code>Mach-O</code>主要包括三个区域</p><ul><li>Header <ul><li>文件类型，目标架构类型等（比如可执行文件、静态库、arm64构架等）</li></ul></li><li>Load commands<ul><li>描述文件在虚拟内存中的逻辑结构、布局（数据段，代码段…都有哪些段，顺序如何，分别是做什么的，怎么做，由<code>Load commands</code>来描述）</li><li>包含着多种命令，包括代码签名命令，符号表命令等</li></ul></li><li>Raw segment data<ul><li>在<code>Load command</code>中定义的<code>Segment</code>的原始数据（在<code>Load command</code>中定义的那些段的原始具体数据）</li></ul></li></ul><h2 id="ld64-优化点"><a href="#ld64-优化点" class="headerlink" title="ld64 优化点"></a>ld64 优化点</h2><p>对于大部分项目来说，速度提升近2倍</p><h3 id="利用多核能力和优化算法加速链接"><a href="#利用多核能力和优化算法加速链接" class="headerlink" title="利用多核能力和优化算法加速链接"></a>利用多核能力和优化算法加速链接</h3><ul><li>与时俱进：利用多核能力，并行计算UUID和签名散列值，类似zld<ul><li>在以往的链接中，一个方法被调用之后，如果里面依赖着另外一个方法，那么链接器就回去找依赖的方法在哪儿，然后找到之后就继续找依赖的方法所依赖的另一个方法，是一串连续的操作。而上面这些操作都是单核串行执行的。Xcode 14优化之后将会利用硬件多核的能力去并行的查找，提高效率。</li></ul></li><li>算法调优：字符串表示（C++ string_view objects）升级</li><li>硬件加速：升级加密库</li><li>配置升级：优化链接配置参数</li></ul><p>静态链接参数 <strong>需要开启<code>all_load</code></strong> 才可以使用上述说明的使用多核能力提升链接速度</p><h3 id="静态链接参数说明"><a href="#静态链接参数说明" class="headerlink" title="静态链接参数说明"></a>静态链接参数说明</h3><ul><li><code>all_load</code>：适用于加载静态库的大部分方法或函数<ul><li>开了了<code>all_load</code>之后，链接器会无差别地把<code>.a</code>或者<code>.framework</code>里面的方法和函数链接起来，不同于以前的选择性加载：发现这个方法会被调用时再去取。</li><li>可以加快链接速度，可以并行解析加载</li><li>缺点：包体积变大，线上环境不建议开启。</li></ul></li><li><code>dead_strip</code>：链接器删除不可访问的代码和数据，配合<code>all_load</code><ul><li>因为<code>all_load</code>会无差别地链接所有方法和函数，导致了包体变大，所以这里开启<code>dead_strip</code>可以删除无用的方法和函数</li><li>注意这里有个风险点：通过runtime调用的方法是检测不到的，所以有可能会被裁掉，编译不会报错，运行时找不到符号才报错。线上环境不建议开启。</li></ul></li><li><code>no_exported_symbols</code>：不导出符号文件，节省时间很短，不考虑<ul><li>线上不能开启，因为我们需要用到符号表去排查问题</li></ul></li><li><code>no_deduplicate</code>：减少重复符号检查来提高链接速度，选择已加载的第一个符号<ul><li>不建议开启，相同的符号可能实现方法会不一样</li></ul></li></ul><p><img src="https://s2.loli.net/2022/07/13/5kwpzPU6rlXZnSC.png" alt="Xcode配置"></p><h2 id="dlyd-优化点"><a href="#dlyd-优化点" class="headerlink" title="dlyd 优化点"></a>dlyd 优化点</h2><p>编译过程中，不需要将主项目中对动态库中的接口的调用，链接到主项目中，而是在主项目中，留下了类似协议的调用，直到启动App，才将真正的实现，关联起来—也就是dlyd过程</p><p>举个例子就是编译链接的时候留一个占位符，表示自己需要这么一个函数，等到启动的时候，系统再从动态库去查找这个符号。</p><ul><li>优势：链接耗时</li><li>劣势：启动耗时，并且因为不同Data pages导致的缺页中断更加凸显</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li><p>dylib chainede fixups(13.4)动态库链式修复：即本身动态库里面方法和函数的地址和app需要用到的地址是不一样的，所以需要动态修复地址，但是需要将部署最低版本设到13.4以上，这样子启动时的动态库加载过程才会得到加速</p></li><li><p>page-in linking：针对DATA端的符号，内核提前加载</p></li></ul><h3 id="pre-main-注意事项"><a href="#pre-main-注意事项" class="headerlink" title="pre-main 注意事项"></a>pre-main 注意事项</h3><ol><li>禁止做I/O和网络操作</li><li>任何超过毫秒级别的操作都不应该放到这</li></ol><h2 id="Xcode-14-新增链接相关命令行工具"><a href="#Xcode-14-新增链接相关命令行工具" class="headerlink" title="Xcode 14 新增链接相关命令行工具"></a>Xcode 14 新增链接相关命令行工具</h2><ul><li><p><code>dyld_usage</code>：获取dyld正在做什么，应用在macos-app或者iOS模拟器</p></li><li><p><code>dyld_info</code>：检查磁盘上和当前dyld缓存中的二进制文件</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文简述Xcode 14 的编译优化&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Xcode" scheme="https://www.arclin.cn/tags/Xcode/"/>
    
    <category term="feature" scheme="https://www.arclin.cn/tags/feature/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s new in Swift 5.7</title>
    <link href="https://www.arclin.cn/post/89a7f98f.html"/>
    <id>https://www.arclin.cn/post/89a7f98f.html</id>
    <published>2022-07-06T08:59:46.000Z</published>
    <updated>2022-07-12T16:51:57.240Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结自WWDC 2022 <a href="https://developer.apple.com/videos/play/wwdc2022/110354/">《What’s new in Swift》</a></p><span id="more"></span><h2 id="Optional-unwrapping"><a href="#Optional-unwrapping" class="headerlink" title="Optional unwrapping"></a>Optional unwrapping</h2><p>在对可选值进行解包的时候，可以用一种更简便的方式</p><p>Swift 5.5</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name : <span class="type">String</span>? <span class="operator">=</span> <span class="string">&quot;Linda&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name <span class="operator">=</span> name &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(name)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 5.7</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(name)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Multi-statement-closure-type-inference"><a href="#Multi-statement-closure-type-inference" class="headerlink" title="Multi-statement closure type inference"></a>Multi-statement closure type inference</h2><p>当闭包表达式内有多行语句的时候，可以不用显式声明返回值类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scores <span class="operator">=</span> [<span class="number">100</span>,<span class="number">80</span>, <span class="number">85</span>]</span><br></pre></td></tr></table></figure><p>Swift 5.5 </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldResults <span class="operator">=</span> scores.map &#123; score -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">   <span class="keyword">if</span> score <span class="operator">&gt;</span> <span class="number">85</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="string">&quot;<span class="subst">\(score)</span>%: Pass&quot;</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="string">&quot;<span class="subst">\(score)</span>%: Fail&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 5.7</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> results <span class="operator">=</span> scores.map &#123; score <span class="keyword">in</span></span><br><span class="line">   <span class="keyword">if</span> score <span class="operator">&gt;=</span> <span class="number">85</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="string">&quot;<span class="subst">\(score)</span>%: Pass&quot;</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="string">&quot;<span class="subst">\(score)</span>%: Fail&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Regular-expressions"><a href="#Regular-expressions" class="headerlink" title="Regular expressions"></a>Regular expressions</h2><p>新增正则表达式工具 <code>Regex</code>，支持正则语法检查</p><p>举例：取出句子中的”at”的range</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message <span class="operator">=</span> <span class="string">&quot;the cat sat on the mat&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message.range(of:<span class="string">&quot;at&quot;</span>))</span><br></pre></td></tr></table></figure><p>Swift 5.7 使用字符串初始化Regex，若传入不符合语法规则的正则表达式，则会throw error</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> atSearch <span class="operator">=</span> <span class="keyword">try</span> <span class="type">Regex</span>(<span class="string">&quot;[a-z]at&quot;</span>)</span><br><span class="line">   <span class="built_in">print</span>(message.range(of:atSearch))</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Failed to create regex&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外可以使用<code>/ /</code>包裹正则表达式（字面量语法），当传入不符合语法规则的正则表达式的时候，编译器将会报错</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(message.ranges(of: <span class="operator">/</span>[a<span class="operator">-</span>z]at<span class="operator">/</span>))</span><br></pre></td></tr></table></figure><p>此外，Swift  5.7还新增了一种DSL的语法去做类似正则表达式的事情，如下:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> search <span class="operator">=</span> <span class="operator">/</span><span class="type">My</span> name <span class="keyword">is</span> (<span class="operator">.+?</span>) and <span class="type">I</span>&#x27;m (\d<span class="operator">+</span>) years old<span class="operator">./</span></span><br><span class="line"><span class="keyword">let</span> greeting <span class="operator">=</span> <span class="string">&quot;My name is Taylor and I&#x27;m 26 years old&quot;</span></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> search <span class="operator">=</span> <span class="type">Regex</span> &#123;</span><br><span class="line">   <span class="string">&quot;My name is&quot;</span></span><br><span class="line">   </span><br><span class="line">   <span class="type">Capture</span> &#123;</span><br><span class="line">      <span class="type">OneOrMore</span>(.word)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="string">&quot;and I&#x27;m&quot;</span></span><br><span class="line">   </span><br><span class="line">   <span class="type">Capture</span> &#123;</span><br><span class="line">      <span class="type">OneOrMore</span>(.digit)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="string">&quot; years old.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Protocol-and-generics"><a href="#Protocol-and-generics" class="headerlink" title="Protocol and generics"></a>Protocol and generics</h2><p>针对泛型协议，可以使用<code>any</code>和<code>some</code>关键字来简洁编码</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> size : <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">   <span class="keyword">var</span> name : <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 5.5 </p><p>这里传入的参数可以是任意遵循了<code>Pizza</code>的类或者结构体的实例</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receivePizza</span>(<span class="keyword">_</span> <span class="params">pizza</span>: <span class="type">Pizza</span>)</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Nice <span class="subst">\(pizza.name)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 5.7</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receivePizza</span>(<span class="keyword">_</span> <span class="params">pizza</span>: any <span class="type">Pizza</span>)</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Nice <span class="subst">\(pizza.name)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 5.5 </p><p>这里传入的参数可以是某一个遵循了<code>Pizza</code>的类或者结构体的任意实例，类型T需要确定</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receivePizza</span>&lt;<span class="type">T</span> : <span class="type">Pizza</span>&gt;(<span class="keyword">_</span> <span class="params">pizza</span>: <span class="type">Pizza</span>)</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Nice <span class="subst">\(pizza.name)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift 5.7</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receivePizza</span>(<span class="keyword">_</span> <span class="params">pizza</span>: <span class="keyword">some</span> <span class="type">Pizza</span>)</span> &#123;</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;Nice <span class="subst">\(pizza.name)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Some-和-Any"><a href="#Some-和-Any" class="headerlink" title="Some 和 Any"></a>Some 和 Any</h3><p><code>some</code>和<code>any</code>其实是以前就有的关键字</p><p>some : 指定某种遵循了协议A的类型</p><p>any : 任意遵循了协议A的类型</p><p>举例：</p><p>下面代码会报错，提示Cat不能复制给animal，因为animal已经被指定为Dog类型了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal : <span class="keyword">some</span> <span class="type">Animal</span> <span class="operator">=</span> <span class="type">Dog</span>()</span><br><span class="line">animal <span class="operator">=</span> <span class="type">Cat</span>()</span><br></pre></td></tr></table></figure><p>下面代码不会报错，因为animal可以是任意遵循了Animal协议的类的实例</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal : any <span class="type">Animal</span> <span class="operator">=</span> <span class="type">Dog</span>()</span><br><span class="line">animal <span class="operator">=</span> <span class="type">Cat</span>()</span><br></pre></td></tr></table></figure><p>同理，会报错，因为some只能指定一种类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animals : [<span class="keyword">some</span> <span class="type">Animal</span>] <span class="operator">=</span> [<span class="type">Dog</span>(),<span class="type">Cat</span>()]</span><br></pre></td></tr></table></figure><p>不会报错，因为any能指定任意遵循了Animal协议的类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animals : [<span class="keyword">some</span> <span class="type">Animal</span>] <span class="operator">=</span> [<span class="type">Dog</span>(),<span class="type">Cat</span>()]</span><br></pre></td></tr></table></figure><p>那到底什么时候用<code>some</code>，什么时候用<code>any</code>呢？</p><p>答：当你在设计接口的时候就已经默认是某个类型的时候，就用<code>some</code>，当不符合上述要求的时候就用<code>any</code></p><h2 id="Swift-Package-Plugins"><a href="#Swift-Package-Plugins" class="headerlink" title="Swift Package Plugins"></a>Swift Package Plugins</h2><p>Swift新增的插件，就是可以用swift写脚本，然后可以在Xcode构建的时候运行。比如代码格式化，产出代码统计报告等</p><h2 id="Swift-Concurrency-Instrument"><a href="#Swift-Concurrency-Instrument" class="headerlink" title="Swift Concurrency Instrument"></a>Swift Concurrency Instrument</h2><p>在Instrument里面新增了针对<code>awiat</code>相关代码的性能检测</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文总结自WWDC 2022 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2022/110354/&quot;&gt;《What’s new in Swift》&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="Swift" scheme="https://www.arclin.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>汇编分析Swift inout关键字</title>
    <link href="https://www.arclin.cn/post/4e8bf338.html"/>
    <id>https://www.arclin.cn/post/4e8bf338.html</id>
    <published>2021-10-02T03:24:00.000Z</published>
    <updated>2022-07-12T16:51:57.245Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲述通过汇编分析展示Swift inout的实现原理</p><span id="more"></span><p>首先我们先了解几个汇编指令(AT&amp;T汇编：iOS模拟器汇编，ARM汇编：iOS真机汇编)</p><ul><li><p><code>movq %rax %rdx</code>：将<code>%rax</code>的值赋值给<code>%rdx</code></p></li><li><p><code>leaq -0x18（%rbp）,%rax</code>：将<code>%rbp-0x18</code>的地址值赋值给<code>rax</code></p></li><li><p><code>callq 0x100003f60</code>：调用地址值为<code>0x100003f60</code>的函数</p></li><li><p>寄存器的具体用途</p><ul><li>rax、rdx常作为函数返回值使用</li><li>rdi，rsi，rdx，rcx、r8、r9等寄存器常用于存放函数参数</li><li>rsp、rbp用于栈操作</li><li>rip作为指令指针</li></ul></li></ul><h2 id="函数中的inout"><a href="#函数中的inout" class="headerlink" title="函数中的inout"></a>函数中的inout</h2><p>首先我们看看普通的函数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span>(<span class="keyword">_</span> <span class="params">num</span> : <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(number)</span><br></pre></td></tr></table></figure><p>在函数调用那里打个断点，可以看到汇编指令是这样子的</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x100003f4e</span> &lt;+<span class="number">78</span>&gt;: movq   -<span class="number">0x30</span>(%rbp), %rdi</span><br><span class="line">-&gt;  <span class="number">0x100003f52</span> &lt;+<span class="number">82</span>&gt;: callq  <span class="number">0x100003f60</span>  ; TestSwift.test<span class="function"><span class="params">(Swift.Int)</span> -&gt;</span> () at main.swift:<span class="number">48</span></span><br></pre></td></tr></table></figure><p>分号后面是注释，用于帮助我们理解汇编指令。</p><p>这两行的含义是把寄存器<code>%rbp-0x30</code>地址上的值赋值给寄存器<code>%rdi</code>，将其作为参数然后调用函数地址为<code>0x100003f60</code>的函数。</p><p>所以很明显，这是一个<code>值传递</code>行为</p><p>然后我们再来看看使用inout的函数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span>(<span class="keyword">_</span> <span class="params">num</span> : <span class="keyword">inout</span> <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    num <span class="operator">=</span> <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="operator">&amp;</span>number)</span><br></pre></td></tr></table></figure><p>当然按照预期number的值会被改变成20，这里我们再次在函数调用那里打断点看看效果</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x100003f37</span> &lt;+<span class="number">55</span>&gt;: leaq   <span class="number">0x40da</span>(%rip), %rdi ; TestSwift.number : Swift.Int</span><br><span class="line">-&gt;  <span class="number">0x100003f3e</span> &lt;+<span class="number">62</span>&gt;: callq  <span class="number">0x100003f60</span> ; TestSwift.test(<span class="keyword">inout</span> Swift.Int) -&gt; () at main.swift:<span class="number">40</span></span><br></pre></td></tr></table></figure><p>从这里我们可以看出，系统通过<code>leaq</code>指令，将<code>%rip+0x40da</code>的地址，赋值给了寄存器<code>%rdi</code>，然后将其作为参数调用了地址值为<code>0x100003f60</code>的函数</p><p>所以很明显，这是一个<code>地址传递</code>行为</p><p>总结：在函数调用中，<code>inout</code>修饰的参数是通过地址传递实现修改值的</p><h2 id="属性使用inout"><a href="#属性使用inout" class="headerlink" title="属性使用inout"></a>属性使用inout</h2><p>针对存储属性和计算属性进行<code>inout</code>修饰传参，其实现原理会有所不同，我们看下面的一个例子</p><p>首先先写一个简单的Demo</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width : <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> side : <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;willSetSide&quot;</span>, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;didSetSide&quot;</span>, oldValue, side)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> girth : <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            width <span class="operator">=</span> newValue <span class="operator">/</span> side</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> width <span class="operator">*</span> side</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">show</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;width=<span class="subst">\(width)</span>,side=<span class="subst">\(side)</span>,girth=<span class="subst">\(girth)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span>(<span class="keyword">_</span> <span class="params">num</span> : <span class="keyword">inout</span> <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    num <span class="operator">=</span> <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h3><p>先试试存储属性</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="operator">=</span> <span class="type">Shape</span>(width: <span class="number">10</span>, side: <span class="number">4</span>)</span><br><span class="line">test(<span class="operator">&amp;</span>s.width)</span><br><span class="line">s.show()</span><br></pre></td></tr></table></figure><p>结果输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>=<span class="number">20</span>,side=<span class="number">4</span>,girth=<span class="number">80</span></span><br></pre></td></tr></table></figure><p>显然跟我们预想的一样，我们通过<code>test</code>函数把<code>s.width</code>改成了20，然后这时候四边形的边长就变成了20，周长变成了80</p><p>那么这次是不是通过地址传递呢？</p><p>通过断点，我们可以看到如下结果</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x10000308b</span> &lt;+<span class="number">91</span>&gt;:  leaq   <span class="number">0x4fe6</span>(%rip), %rdi        ; TestSwift.s : TestSwift.Shape</span><br><span class="line"><span class="number">0x100003092</span> &lt;+<span class="number">98</span>&gt;:  callq  <span class="number">0x100003a60</span>               ; TestSwift.test(<span class="keyword">inout</span> Swift.Int) -&gt; () at main.swift:<span class="number">34</span></span><br></pre></td></tr></table></figure><p>这里很明显看到是把结构体<code>s</code>的地址值作为参数传进去了。之所以直接传结构体地址进去，是因为<code>width</code>是一个存储属性，属性存在在结构体的内存结构中，而且又是第一个属性，所以第一个属性的地址值就是结构体的地址值。假如不是第一个属性，那么就加上偏移值，把该属性的地址传进去。</p><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>接下来我们传一个计算属性进去试试看</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="operator">=</span> <span class="type">Shape</span>(width: <span class="number">10</span>, side: <span class="number">4</span>)</span><br><span class="line">test(<span class="operator">&amp;</span>s.girth)</span><br><span class="line">s.show()</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>=<span class="number">5</span>,side=<span class="number">4</span>,girth=<span class="number">20</span></span><br></pre></td></tr></table></figure><p>同样也是符合预期的。然后我们分析一下汇编实现</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 第<span class="number">1</span><span class="number">-2</span>步</span><br><span class="line"><span class="number">0x10000307b</span> &lt;+<span class="number">107</span>&gt;: callq  <span class="number">0x1000034d0</span>               <span class="comment">; TestSwift.Shape.girth.getter : Swift.Int at main.swift:24</span></span><br><span class="line"><span class="number">0x100003080</span> &lt;+<span class="number">112</span>&gt;: movq   <span class="variable">%rax</span><span class="punctuation">,</span> <span class="number">-0</span><span class="keyword">x</span><span class="number">28</span>(<span class="variable">%rbp</span>)</span><br><span class="line">    </span><br><span class="line">// 第<span class="number">3</span>步</span><br><span class="line"><span class="number">0x100003084</span> &lt;+<span class="number">116</span>&gt;: leaq   <span class="number">-0</span><span class="keyword">x</span><span class="number">28</span>(<span class="variable">%rbp</span>)<span class="punctuation">,</span> <span class="variable">%rdi</span></span><br><span class="line"><span class="number">0x100003088</span> &lt;+<span class="number">120</span>&gt;: callq  <span class="number">0x100003a60</span>               <span class="comment">; TestSwift.test(inout Swift.Int) -&gt; () at main.swift:34</span></span><br><span class="line">    </span><br><span class="line">// 第<span class="number">4</span>步    </span><br><span class="line"><span class="number">0x10000308d</span> &lt;+<span class="number">125</span>&gt;: movq   <span class="number">-0</span><span class="keyword">x</span><span class="number">28</span>(<span class="variable">%rbp</span>)<span class="punctuation">,</span> <span class="variable">%rdi</span></span><br><span class="line"><span class="number">0x100003091</span> &lt;+<span class="number">129</span>&gt;: leaq   <span class="number">0x4fe0</span>(<span class="variable">%rip</span>)<span class="punctuation">,</span> <span class="variable">%r13</span>        <span class="comment">; TestSwift.s : TestSwift.Shape</span></span><br><span class="line"><span class="number">0x100003098</span> &lt;+<span class="number">136</span>&gt;: callq  <span class="number">0x100003580</span>               <span class="comment">; TestSwift.Shape.girth.setter : Swift.Int at main.swift:21</span></span><br></pre></td></tr></table></figure><p>可以看到：</p><ol><li>首先系统调用了<code>getter</code>方法，拿到计算属性<code>girth</code>的值</li><li>然后通过<code>movq</code>指令把拿出来的值放在了地址<code>%rbp-0x28</code>（一个临时变量）中</li><li>接下来通过传递地址值的形式，把这个临时变量的地址传了进去，把他指向的值改成了20</li><li>然后改完之后拿出结果值调用计算属性<code>girth</code>的setter方法（<code>%rdi</code>是参数）</li><li>最终就实现了修改<code>width</code>属性的结果</li></ol><h3 id="带属性观察器的存储属性"><a href="#带属性观察器的存储属性" class="headerlink" title="带属性观察器的存储属性"></a>带属性观察器的存储属性</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="operator">=</span> <span class="type">Shape</span>(width: <span class="number">10</span>, side: <span class="number">4</span>)</span><br><span class="line">test(<span class="operator">&amp;</span>s.side)</span><br><span class="line">s.show()</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>=<span class="number">10</span>,side=<span class="number">20</span>,girth=<span class="number">200</span></span><br></pre></td></tr></table></figure><p>同样达到预期。然后我们分析一下汇编实现</p><p>为了方便理解，这里拆分为两个部分</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第1步</span></span><br><span class="line"><span class="number">0x10000306d</span> &lt;+<span class="number">93</span>&gt;:  movq   <span class="number">0x500c</span>(%rip), %rax        ; TestSwift.s : TestSwift.Shape + <span class="number">8</span></span><br><span class="line"><span class="number">0x100003074</span> &lt;+<span class="number">100</span>&gt;: movq   %rax, <span class="number">-0x28</span>(%rbp)</span><br><span class="line"><span class="comment">// 第2步</span></span><br><span class="line"><span class="number">0x100003078</span> &lt;+<span class="number">104</span>&gt;: leaq   <span class="number">-0x28</span>(%rbp), %rdi</span><br><span class="line"><span class="number">0x10000307c</span> &lt;+<span class="number">108</span>&gt;: callq  <span class="number">0x100003a60</span>               ; TestSwift.test(<span class="keyword">inout</span> Swift.Int) -&gt; () at main.swift:<span class="number">34</span></span><br><span class="line">...（省略一些setter方法的参数处理）</span><br><span class="line"><span class="comment">// 第3步</span></span><br><span class="line"><span class="number">0x10000308c</span> &lt;+<span class="number">124</span>&gt;: callq  <span class="number">0x100003180</span>               ; TestSwift.Shape.side.setter : Swift.Int at main.swift:<span class="number">12</span></span><br></pre></td></tr></table></figure><ol><li>首先，取出结构体地址值+8的地址值（也就是side属性的地址值），赋值给临时变量地址<code>%rbp-0x28</code></li><li>取出临时变量的地址值作为函数参数，调用<code>test</code>函数，所以<code>inout</code>本质依旧是<code>地址传递</code></li><li>进入属性的<code>setter</code>方法</li></ol><p>然后我们<code>step into</code>看看<code>setter</code>的主要实现</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/// 第<span class="number">1</span>步</span><br><span class="line"><span class="number">0x1000031be</span> &lt;+<span class="number">62</span>&gt;: callq  <span class="number">0x1000031f0</span>               <span class="comment">; TestSwift.Shape.side.willset : Swift.Int at main.swift:13</span></span><br><span class="line"><span class="number">0x1000031c3</span> &lt;+<span class="number">67</span>&gt;: movq   <span class="number">-0</span><span class="keyword">x</span><span class="number">30</span>(<span class="variable">%rbp</span>)<span class="punctuation">,</span> <span class="variable">%rax</span></span><br><span class="line"><span class="number">0x1000031c7</span> &lt;+<span class="number">71</span>&gt;: movq   <span class="number">-0</span><span class="keyword">x</span><span class="number">28</span>(<span class="variable">%rbp</span>)<span class="punctuation">,</span> <span class="variable">%rcx</span></span><br><span class="line">/// 第<span class="number">2</span>步</span><br><span class="line"><span class="number">0x1000031cb</span> &lt;+<span class="number">75</span>&gt;: movq   <span class="variable">%rcx</span><span class="punctuation">,</span> <span class="number">0x8</span>(<span class="variable">%rax</span>)</span><br><span class="line">/// 第<span class="number">3</span>步</span><br><span class="line"><span class="number">0x1000031cf</span> &lt;+<span class="number">79</span>&gt;: movq   <span class="number">-0</span><span class="keyword">x</span><span class="number">38</span>(<span class="variable">%rbp</span>)<span class="punctuation">,</span> <span class="variable">%rdi</span></span><br><span class="line"><span class="number">0x1000031d3</span> &lt;+<span class="number">83</span>&gt;: movq   <span class="variable">%rax</span><span class="punctuation">,</span> <span class="variable">%r13</span></span><br><span class="line"><span class="number">0x1000031d6</span> &lt;+<span class="number">86</span>&gt;: callq  <span class="number">0x100003370</span>               <span class="comment">; TestSwift.Shape.side.didset : Swift.Int at main.swift:16</span></span><br></pre></td></tr></table></figure><ol><li>触发了属性观察器的<code>willset</code>方法</li><li>给真正的<code>side</code>的地址指向的值改为20</li><li>触发了属性观察器的<code>didset</code>方法</li></ol><p>所以跟计算属性类似，也是先拿一个临时变量中转调用了<code>test</code>方法，等到触发了属性观察器，在两个方法之间才真正拿到中转的临时变量再进行赋值操作</p><h2 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h2><ul><li>可变参数不能标记为<code>inout</code></li><li><code>inout</code>参数不能有默认值</li><li><code>inout</code>参数只能传入可以被多次赋值的（var变量，可变数组的元素等）</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要讲述通过汇编分析展示Swift inout的实现原理&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    <category term="Swift" scheme="https://www.arclin.cn/tags/Swift/"/>
    
    <category term="汇编" scheme="https://www.arclin.cn/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>函数式Swift --- 透镜</title>
    <link href="https://www.arclin.cn/post/c5814bfc.html"/>
    <id>https://www.arclin.cn/post/c5814bfc.html</id>
    <published>2021-09-25T15:29:00.000Z</published>
    <updated>2022-07-12T16:51:57.244Z</updated>
    
    <content type="html"><![CDATA[<p>Swift是实现函数式思想的一门好语言，这里简要讲述一下函数式中透镜的Swift实现</p><span id="more"></span><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>首先我们先创建一个结构体</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x : <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">let</span> y : <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">2</span>)</span><br><span class="line">point.x <span class="operator">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>一般情况下这时候会报错<code>Cannot assign to property: &#39;x&#39; is a &#39;let&#39; constant</code>，因为<code>x</code>是一个常量，所以无法修改</p><p>那么有时候我们如果需要改变一个不可变的属性的值，那么一般我们会选择再创建一个对象去覆盖</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x : <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">let</span> y : <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> tempPoint <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">2</span>, y: point.y)</span><br><span class="line">point <span class="operator">=</span> tempPoint</span><br></pre></td></tr></table></figure><p>但是这样子做未免显得有点麻烦，假如你觉得这样子还能接受，那么我再举个例子</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x : <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">let</span> y : <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start : <span class="type">Point</span></span><br><span class="line">    <span class="keyword">let</span> end : <span class="type">Point</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> line : <span class="type">Line</span> <span class="comment">// 通过线段我们可以计算出正方形的边长</span></span><br><span class="line">    <span class="keyword">let</span> origin : <span class="type">Point</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> start <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> end <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">10</span>, y: <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> line <span class="operator">=</span> <span class="type">Line</span>(start: start, end: end)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> origin <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">5</span>, y: <span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> square <span class="operator">=</span> <span class="type">Square</span>(line: line, origin: origin)</span><br><span class="line"></span><br><span class="line">square.line.start.x <span class="operator">=</span> <span class="number">20</span> <span class="comment">// Error : Cannot assign to property: &#x27;x&#x27; is a &#x27;let&#x27; constant</span></span><br></pre></td></tr></table></figure><p>假如这时候我们希望把<code>square.line.start.x</code>设置为20，那么按照常规的写法就显得很麻烦了，更何况实际开发中可能还存在着更深的嵌套</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>我们可以使用函数式的方案去解决上面的问题，首先我们先把问题简化，先考虑如何把<code>Point</code>的<code>x</code>属性优雅地去进行更改</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>首先我们定义一个函数签名，取名为<code>Lens</code>(透镜)</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt; <span class="operator">=</span> (<span class="keyword">@escaping</span> (<span class="type">Subpart</span>) -&gt; <span class="type">Subpart</span>) -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span></span><br></pre></td></tr></table></figure><p>其中<code>Subpart</code>表示要修改的属性的值，<code>Whole</code>表示被修改的这个对象</p><p>整个定义的含义是</p><ol><li>传入闭包表达式，这个闭包表达式会带入参数，参数值为被修改的属性的当前值，比如<code>x</code>的当前值1，然后闭包表达式修改这个值之后再次返回出去。</li><li>返回一个对象的闭包，这个闭包会带入参数，参数值为当前被修改的对象，闭包表达式返回一个新的对象，比如<code>Point</code></li></ol><p>为了方便构建一个透镜，我们再添加一个方法用于初始化一个透镜</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;(<span class="params">view</span>: <span class="keyword">@escaping</span> (<span class="type">Whole</span>) -&gt; <span class="type">Subpart</span>, <span class="params">set</span>: <span class="keyword">@escaping</span> (<span class="type">Subpart</span>,<span class="type">Whole</span>) -&gt; <span class="type">Whole</span>)</span> -&gt; <span class="type">Lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/// 缩减写法</span></span><br><span class="line">    <span class="keyword">return</span> &#123; mapper <span class="keyword">in</span> &#123; <span class="keyword">set</span>(mapper(view(<span class="variable">$0</span>)), <span class="variable">$0</span>) &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法传入两个参数</p><ol><li>闭包表达式<code>view</code>表示传入一个对象，返回这个对象要被修改的那个属性当前值，比如我们上面提到的<code>x</code>，相当于一个<code>get</code>操作</li><li>闭包表达式<code>set</code>表示传入要被修改属性的新值和要被修改的对象，然后返回包含新值的属性的新对象，相当于一个<code>set</code>操作</li></ol><p>最后把闭包表达式返回出去就是我们所要的透镜，也可以理解为一个修改器。这个修改器内定好了哪个属性要被修改成哪个值，然后这个修改器最后返回一个闭包表达式，传入一个旧对象，返回一个带有新值的新对象</p><p>如果觉得上面的缩减写法有点晦涩，那我们展开来描述</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123; mapper <span class="keyword">in</span> <span class="comment">// mapper是用于修改属性值的一个闭包表达式</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> subpart <span class="operator">=</span> view(<span class="variable">$0</span>) <span class="comment">// 拿到某个属性当前的值</span></span><br><span class="line">        <span class="keyword">let</span> newSubpart <span class="operator">=</span> mapper(subpart) <span class="comment">// 处理成新值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">set</span>(newSubpart, <span class="variable">$0</span>) <span class="comment">// 返回一个新对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>接下来我们就可以用上面定义好的方法来构件我们的<code>x</code>属性透镜和<code>y</code>属性透镜</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> xL : <span class="type">Lens</span>&lt;<span class="type">CGFloat</span>,<span class="type">Point</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.x &#125;,</span><br><span class="line">        set: &#123; <span class="type">Point</span>(x: <span class="variable">$0</span>, y: <span class="variable">$1</span>.y) &#125;</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> yL : <span class="type">Lens</span>&lt;<span class="type">CGFloat</span>,<span class="type">Point</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.y &#125;,<span class="comment">// 即将要被修改的值是y</span></span><br><span class="line">        set: &#123; <span class="type">Point</span>(x: <span class="variable">$1</span>.x, y: <span class="variable">$0</span>) &#125; <span class="comment">// 新值为$0，旧值</span></span><br><span class="line">x依旧还是从原来对象里面取    </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个能把x改成10的透镜</span></span><br><span class="line"><span class="keyword">let</span> xLens <span class="operator">=</span> <span class="type">Point</span>.xL &#123; <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">10</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point1 <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> point2 <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">2</span>, y: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">point1 <span class="operator">=</span> xLens(point1)</span><br><span class="line">point2 <span class="operator">=</span> xLens(point2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(point1) <span class="comment">// Point(x: 10.0, y: 1.0)</span></span><br><span class="line"><span class="built_in">print</span>(point2) <span class="comment">// Point(x: 10.0, y: 2.0)</span></span><br></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>但是这样子的使用方法还是不够方便，所以我们定义多两个方法封装一下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">over</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;(<span class="params">mapper</span>: <span class="keyword">@escaping</span> (<span class="type">Subpart</span>) -&gt; <span class="type">Subpart</span>, <span class="params">lens</span>: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;)</span> -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lens(mapper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;(<span class="params">value</span>: <span class="type">Subpart</span>,<span class="params">lens</span>: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;)</span> -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> over( mapper: &#123; <span class="keyword">_</span> <span class="keyword">in</span> value &#125;, lens: lens)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>over</code>方法传入一个闭包表达式和一个透镜，闭包表达式参数是用来修改属性值，跟透镜结合使用，返回新对象</p><p><code>set</code>方法传入一个新值和一个透镜，新值是用于构建修改属性的闭包，跟传入的透镜结合，调用<code>over</code>方法</p><p>有了这两个方法，我们就可以把之前的写法进行修改</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xLens <span class="operator">=</span> <span class="keyword">set</span>(value: <span class="number">10</span>, lens: <span class="type">Point</span>.xL) <span class="comment">// 等价于下面的写法</span></span><br><span class="line"><span class="comment">// let xLens = Point.xL &#123; _ in 10 &#125; </span></span><br></pre></td></tr></table></figure><p>这么一看貌似只是简单地把闭包表达式变成了函数调用，也就是花括号变成了括号而已</p><p>但实际上变成了函数调用的方式之后我们就可以做更多的事情了</p><p>比如说：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">%~</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> .<span class="title">~</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">%~</span> &lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;(<span class="params">lhs</span>: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;, <span class="params">rhs</span>: <span class="keyword">@escaping</span> (<span class="type">Subpart</span>) -&gt; <span class="type">Subpart</span>)</span> -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> over(mapper: rhs, lens: lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> </span><span class="operator">.~</span> <span class="operator">&lt;</span><span class="type">Subpart</span>, <span class="type">Whole</span><span class="operator">&gt;</span>(lhs: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;, rhs: <span class="type">Subpart</span>) -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">set</span>(value: rhs, lens: lhs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们的调用方式就变成了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xLens <span class="operator">=</span> <span class="type">Point</span>.xL <span class="operator">.~</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>还不够，再加一个定义，我们把对象的修改方式给改了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precedencegroup</span> <span class="title">LensPrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">higherThan</span> : <span class="type">AdditionPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> .<span class="title">~</span> : <span class="type">LensPrecedence</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">%~</span> : <span class="type">LensPrecedence</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">|&gt;</span> : <span class="type">AdditionPrecedence</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">%~</span> &lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;(<span class="params">lhs</span>: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;, <span class="params">rhs</span>: <span class="keyword">@escaping</span> (<span class="type">Subpart</span>) -&gt; <span class="type">Subpart</span>)</span> -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> over(mapper: rhs, lens: lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> </span><span class="operator">.~</span> <span class="operator">&lt;</span><span class="type">Subpart</span>, <span class="type">Whole</span><span class="operator">&gt;</span>(lhs: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;, rhs: <span class="type">Subpart</span>) -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">set</span>(value: rhs, lens: lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">|&gt;</span> &lt;<span class="type">A</span>, <span class="type">B</span>&gt; (<span class="params">lhs</span>: <span class="type">A</span>, <span class="params">rhs</span>: (<span class="type">A</span>) -&gt; <span class="type">B</span>)</span> -&gt; <span class="type">B</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs(lhs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子当我们想要修改一个点的x值和y值的时候，就可以这么写了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">point <span class="operator">=</span> point</span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Point</span>.xL <span class="operator">.~</span> <span class="number">10</span></span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Point</span>.yL <span class="operator">.~</span> <span class="number">20</span></span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Point</span>.xL <span class="operator">%~</span> &#123; <span class="variable">$0</span> <span class="operator">-</span> <span class="number">5</span> &#125;</span><br></pre></td></tr></table></figure><p>看起来就简洁许多</p><h3 id="复杂的情况"><a href="#复杂的情况" class="headerlink" title="复杂的情况"></a>复杂的情况</h3><p>那么刚才我们提及的复杂的情况，除了点之外，还出现了线和面，那应该怎么做呢</p><p>同理可得，我们给线和面也添加透镜</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> startL : <span class="type">Lens</span>&lt;<span class="type">Point</span>,<span class="type">Line</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.start &#125;,</span><br><span class="line">        set: &#123; <span class="type">Line</span>(start: <span class="variable">$0</span>, end: <span class="variable">$1</span>.end ) &#125;</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> endL : <span class="type">Lens</span>&lt;<span class="type">Point</span>,<span class="type">Line</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.end &#125;,</span><br><span class="line">        set: &#123; <span class="type">Line</span>(start: <span class="variable">$1</span>.start, end: <span class="variable">$0</span>) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> lineL : <span class="type">Lens</span>&lt;<span class="type">Line</span>,<span class="type">Square</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.line &#125;,</span><br><span class="line">        set: &#123; <span class="type">Square</span>(line: <span class="variable">$0</span>, origin: <span class="variable">$1</span>.origin) &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> originL : <span class="type">Lens</span>&lt;<span class="type">Point</span>,<span class="type">Square</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.origin &#125;,</span><br><span class="line">        set: &#123; <span class="type">Square</span>(line: <span class="variable">$1</span>.line, origin: <span class="variable">$0</span>) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增一个运算符<code>&lt;&lt;&lt;</code>表示左结合，把右参数（闭包表达式）作为左参数（闭包表达式）的参数，并修改一下运算符之间的优先级</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precedencegroup</span> <span class="title">CombinePrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span> : <span class="keyword">left</span></span><br><span class="line">    <span class="keyword">higherThan</span> : <span class="type">LensPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">precedencegroup</span> <span class="title">LensPrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span>: <span class="keyword">right</span></span><br><span class="line">    <span class="keyword">higherThan</span> : <span class="type">AdditionPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">&lt;&lt;&lt;</span> : <span class="type">CombinePrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">&lt;&lt;&lt;</span> &lt;<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>&gt; (<span class="params">lhs</span>: <span class="keyword">@escaping</span> (<span class="type">B</span>) -&gt; <span class="type">C</span>, <span class="params">rhs</span>: <span class="keyword">@escaping</span> (<span class="type">A</span>) -&gt; <span class="type">B</span>)</span> -&gt; (<span class="type">A</span>) -&gt; <span class="type">C</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; lhs(rhs(<span class="variable">$0</span>)) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用方式如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 线段的起始点设置为20，原点的y值设置为30</span></span><br><span class="line">square <span class="operator">=</span> square</span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Square</span>.lineL <span class="operator">&lt;&lt;&lt;</span> <span class="type">Line</span>.startL <span class="operator">&lt;&lt;&lt;</span> <span class="type">Point</span>.xL <span class="operator">.~</span> <span class="number">20</span></span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Square</span>.originL <span class="operator">&lt;&lt;&lt;</span> <span class="type">Point</span>.yL <span class="operator">.~</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p>看起来也是十分简洁</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p>仅供参考</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x : <span class="type">CGFloat</span></span><br><span class="line">    <span class="keyword">let</span> y : <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start : <span class="type">Point</span></span><br><span class="line">    <span class="keyword">let</span> end : <span class="type">Point</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> line : <span class="type">Line</span></span><br><span class="line">    <span class="keyword">let</span> origin : <span class="type">Point</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">Lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt; <span class="operator">=</span> (<span class="keyword">@escaping</span> (<span class="type">Subpart</span>) -&gt; <span class="type">Subpart</span>) -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;(<span class="params">view</span>: <span class="keyword">@escaping</span> (<span class="type">Whole</span>) -&gt; <span class="type">Subpart</span>, <span class="params">set</span>: <span class="keyword">@escaping</span> (<span class="type">Subpart</span>,<span class="type">Whole</span>) -&gt; <span class="type">Whole</span>)</span> -&gt; <span class="type">Lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt; &#123;</span><br><span class="line"><span class="comment">//    return &#123; mapper in</span></span><br><span class="line"><span class="comment">//        return &#123;</span></span><br><span class="line"><span class="comment">//            let subpart = view($0)</span></span><br><span class="line"><span class="comment">//            let newSubpart = mapper(subpart)</span></span><br><span class="line"><span class="comment">//            return set(newSubpart, $0)</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">/// 可以缩减为这种写法</span></span><br><span class="line">    <span class="keyword">return</span> &#123; mapper <span class="keyword">in</span> &#123; <span class="keyword">set</span>(mapper(view(<span class="variable">$0</span>)), <span class="variable">$0</span>) &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">over</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;(<span class="params">mapper</span>: <span class="keyword">@escaping</span> (<span class="type">Subpart</span>) -&gt; <span class="type">Subpart</span>, <span class="params">lens</span>: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;)</span> -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lens(mapper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">set</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;(<span class="params">value</span>: <span class="type">Subpart</span>,<span class="params">lens</span>: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>,<span class="type">Whole</span>&gt;)</span> -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> over( mapper: &#123; <span class="keyword">_</span> <span class="keyword">in</span> value &#125;, lens: lens)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">precedencegroup</span> <span class="title">CombinePrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span> : <span class="keyword">left</span></span><br><span class="line">    <span class="keyword">higherThan</span> : <span class="type">LensPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">precedencegroup</span> <span class="title">LensPrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span>: <span class="keyword">right</span></span><br><span class="line">    <span class="keyword">higherThan</span> : <span class="type">AdditionPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">%~</span>  : <span class="type">LensPrecedence</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> .<span class="title">~</span>  : <span class="type">LensPrecedence</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">|&gt;</span>  : <span class="type">AdditionPrecedence</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">&lt;&lt;&lt;</span> : <span class="type">CombinePrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">%~</span> &lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;(<span class="params">lhs</span>: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;, <span class="params">rhs</span>: <span class="keyword">@escaping</span> (<span class="type">Subpart</span>) -&gt; <span class="type">Subpart</span>)</span> -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> over(mapper: rhs, lens: lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> </span><span class="operator">.~</span> <span class="operator">&lt;</span><span class="type">Subpart</span>, <span class="type">Whole</span><span class="operator">&gt;</span>(lhs: <span class="type">Lens</span>&lt;<span class="type">Subpart</span>, <span class="type">Whole</span>&gt;, rhs: <span class="type">Subpart</span>) -&gt; (<span class="type">Whole</span>) -&gt; <span class="type">Whole</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">set</span>(value: rhs, lens: lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">|&gt;</span> &lt;<span class="type">A</span>, <span class="type">B</span>&gt; (<span class="params">lhs</span>: <span class="type">A</span>, <span class="params">rhs</span>: (<span class="type">A</span>) -&gt; <span class="type">B</span>)</span> -&gt; <span class="type">B</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs(lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">&lt;&lt;&lt;</span> &lt;<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>&gt; (<span class="params">lhs</span>: <span class="keyword">@escaping</span> (<span class="type">B</span>) -&gt; <span class="type">C</span>, <span class="params">rhs</span>: <span class="keyword">@escaping</span> (<span class="type">A</span>) -&gt; <span class="type">B</span>)</span> -&gt; (<span class="type">A</span>) -&gt; <span class="type">C</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; lhs(rhs(<span class="variable">$0</span>)) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> xL : <span class="type">Lens</span>&lt;<span class="type">CGFloat</span>,<span class="type">Point</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.x &#125;,</span><br><span class="line">        set: &#123; <span class="type">Point</span>(x: <span class="variable">$0</span>, y: <span class="variable">$1</span>.y) &#125;</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> yL : <span class="type">Lens</span>&lt;<span class="type">CGFloat</span>,<span class="type">Point</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.y &#125;,</span><br><span class="line">        set: &#123; <span class="type">Point</span>(x: <span class="variable">$1</span>.x, y: <span class="variable">$0</span>) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> startL : <span class="type">Lens</span>&lt;<span class="type">Point</span>,<span class="type">Line</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.start &#125;,</span><br><span class="line">        set: &#123; <span class="type">Line</span>(start: <span class="variable">$0</span>, end: <span class="variable">$1</span>.end ) &#125;</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> endL : <span class="type">Lens</span>&lt;<span class="type">Point</span>,<span class="type">Line</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.end &#125;,</span><br><span class="line">        set: &#123; <span class="type">Line</span>(start: <span class="variable">$1</span>.start, end: <span class="variable">$0</span>) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> lineL : <span class="type">Lens</span>&lt;<span class="type">Line</span>,<span class="type">Square</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.line &#125;,</span><br><span class="line">        set: &#123; <span class="type">Square</span>(line: <span class="variable">$0</span>, origin: <span class="variable">$1</span>.origin) &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> originL : <span class="type">Lens</span>&lt;<span class="type">Point</span>,<span class="type">Square</span>&gt; <span class="operator">=</span> lens(</span><br><span class="line">        view: &#123; <span class="variable">$0</span>.origin &#125;,</span><br><span class="line">        set: &#123; <span class="type">Square</span>(line: <span class="variable">$1</span>.line, origin: <span class="variable">$0</span>) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//let xLens = Point.xL &#123; _ in 10 &#125;</span></span><br><span class="line"><span class="comment">//let xLens = set(value: 10, lens: Point.xL)</span></span><br><span class="line"><span class="comment">//let xLens = Point.xL .~ 10</span></span><br><span class="line"><span class="keyword">var</span> point1 <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">point1 <span class="operator">=</span> point1</span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Point</span>.xL <span class="operator">.~</span> <span class="number">10</span></span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Point</span>.yL <span class="operator">.~</span> <span class="number">20</span></span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Point</span>.xL <span class="operator">%~</span> &#123; <span class="variable">$0</span> <span class="operator">-</span> <span class="number">5</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> origin <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">5</span>, y: <span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> line <span class="operator">=</span> <span class="type">Line</span>(start: origin, end: point1)</span><br><span class="line"><span class="keyword">var</span> square <span class="operator">=</span> <span class="type">Square</span>(line: line, origin: origin)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改前<span class="subst">\(square)</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 线段的起始点设置为20，原点的y值设置为30</span></span><br><span class="line">square <span class="operator">=</span> square</span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Square</span>.lineL <span class="operator">&lt;&lt;&lt;</span> <span class="type">Line</span>.startL <span class="operator">&lt;&lt;&lt;</span> <span class="type">Point</span>.xL <span class="operator">.~</span> <span class="number">20</span></span><br><span class="line">    <span class="operator">|&gt;</span> <span class="type">Square</span>.originL <span class="operator">&lt;&lt;&lt;</span> <span class="type">Point</span>.yL <span class="operator">.~</span> <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改后<span class="subst">\(square)</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>在这种思想的基础上，我们就可以使用keyPath特性来对我们的编码进行一些改进</p><p>首先我们对keyPath进行拓展，也就是<code>\.xxx</code>这种写法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">WritableKeyPath</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> toLens : <span class="type">Lens</span>&lt;<span class="type">Value</span>,<span class="type">Root</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> lens(view: &#123; <span class="variable">$0</span>[keyPath : <span class="keyword">self</span>] &#125;, set: &#123;</span><br><span class="line">            <span class="keyword">var</span> copy <span class="operator">=</span> <span class="variable">$1</span></span><br><span class="line">            copy[keyPath: <span class="keyword">self</span>] <span class="operator">=</span> <span class="variable">$0</span></span><br><span class="line">            <span class="keyword">return</span> copy</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改一下我们先前定义的两个运算符的实现，设置左值为keyPath的键，右值为新值或者生成新值的闭包表达式</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">%~</span> : <span class="type">LensPrecedence</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> .<span class="title">~</span> : <span class="type">LensPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">%~</span> &lt;<span class="type">Value</span>, <span class="type">Root</span>&gt;(<span class="params">lhs</span>: <span class="type">WritableKeyPath</span>&lt;<span class="type">Root</span>, <span class="type">Value</span>&gt;, <span class="params">rhs</span>: <span class="keyword">@escaping</span> (<span class="type">Value</span>) -&gt; <span class="type">Value</span>)</span> -&gt; (<span class="type">Root</span>) -&gt; <span class="type">Root</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> over(mapper: rhs, lens: lhs.toLens)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> </span><span class="operator">.~</span> <span class="operator">&lt;</span><span class="type">Value</span>, <span class="type">Root</span><span class="operator">&gt;</span>(lhs: <span class="type">WritableKeyPath</span>&lt;<span class="type">Root</span>, <span class="type">Value</span>&gt;, rhs: <span class="type">Value</span>) -&gt; (<span class="type">Root</span>) -&gt; <span class="type">Root</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">set</span>(value: rhs, lens: lhs.toLens)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> formatter <span class="operator">=</span> <span class="type">DateFormatter</span>()</span><br><span class="line">    <span class="operator">|&gt;</span> \.dateFormat <span class="operator">.~</span> <span class="string">&quot;yyyy-MM-dd&quot;</span></span><br><span class="line">    <span class="operator">|&gt;</span> \.timeZone <span class="operator">.~</span> <span class="type">TimeZone</span>(secondsFromGMT: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date <span class="operator">=</span> formatter.date(from: <span class="string">&quot;2020-01-01&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(date)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>()</span><br><span class="line">    <span class="operator">|&gt;</span> \.backgroundColor <span class="operator">.~</span> <span class="type">UIColor</span>.white</span><br><span class="line">    <span class="operator">|&gt;</span> \.alpha <span class="operator">%~</span> &#123; <span class="variable">$0</span> <span class="operator">-</span> <span class="number">0.1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(view)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Swift是实现函数式思想的一门好语言，这里简要讲述一下函数式中透镜的Swift实现&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="Swift" scheme="https://www.arclin.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>LLVM</title>
    <link href="https://www.arclin.cn/post/6d8a8bc2.html"/>
    <id>https://www.arclin.cn/post/6d8a8bc2.html</id>
    <published>2021-09-12T03:11:00.000Z</published>
    <updated>2022-07-12T16:51:57.237Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述LLVM的概念与Clang插件开发</p><span id="more"></span><h2 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h2><ul><li>官网：<a href="https://llvm.org/">https://llvm.org</a></li><li>LLVM项目是模块化、可重用的<code>编译器</code>以及<code>工具链</code>技术的集合</li><li>”LLVM“这个名称不是缩写，是项目全称</li></ul><h2 id="传统的编译器架构"><a href="#传统的编译器架构" class="headerlink" title="传统的编译器架构"></a>传统的编译器架构</h2><p><img src="https://z3.ax1x.com/2021/09/12/4ppCOx.png" alt="4ppCOx.png"></p><ul><li>Frontend：前端<ul><li>词法分析、语法分析、语义分析、生成中间代码</li></ul></li><li>Optimizer：优化器<ul><li>中间代码优化</li></ul></li><li>Backend：后端<ul><li>生成机器码</li></ul></li></ul><h2 id="LLVM架构"><a href="#LLVM架构" class="headerlink" title="LLVM架构"></a>LLVM架构</h2><p><img src="https://z3.ax1x.com/2021/09/12/4pEhkt.png" alt="4pEhkt.png"></p><ul><li>不同的前端后端使用统一的中间代码<code>LLVM Intermediate Representation(LLVM IR)</code></li><li>如果需要支持一种新的编程语言，那么只需要实现一个新的前端</li><li>如果需要支持一种新的硬件设备，那么只需要实现一个新的后端</li><li>优化阶段是一个通用的阶段，他针对的是统一的<code>LLVM IR</code>，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做需修改</li><li>相比之下，GCC的前端和后端没分得太开，前端后端耦合在了一起。所以GCC为了支持一门新的语言，或者为了支持一个新的目标平台，就变得相当困难</li><li>LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构（GCC家族，Java,.Net,Python,Ruby,Scheme,Haskell,D等）</li></ul><h3 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a>Clang</h3><ul><li><p>Clang是LLVM的一个子项目</p></li><li><p>基于LLVM架构的C/C++/Objective-C编译器前端</p></li><li><p>官网：<a href="http://clang.llvm.org/">http://clang.llvm.org/</a></p></li><li><p>相比于GCC，Clang具有如下优点</p><ul><li>编译速度快：在某些平台上，Clang的编译速度显著地快过GCC(Debug模式下编译OC速度比GCC快3倍)</li><li>占用内存小：Clang生成的AST所占用的内存是GCC的五分之一左右</li><li>模块化设计：Clang采用基于库的模块化设计，易于IDE集成及其他用途的重用</li><li>诊断信息可读性强：在编译过程中，Clang创建并保留了大量详细的元数据（metadata），有利于调试和错误报告</li><li>设计清晰简单，容易理解，易于扩展增强 </li></ul></li></ul><h3 id="Clang与LLVM"><a href="#Clang与LLVM" class="headerlink" title="Clang与LLVM"></a>Clang与LLVM</h3><p> <img src="https://i.loli.net/2021/09/12/P7Z2sTB6ifOt4XM.png" alt="WX20210912-142017.png"></p><p> <img src="https://i.loli.net/2021/09/12/EZ9hnywmdQAX3LK.png" alt="WX20210912-142026.png"></p><p> IR：中间代码</p><h2 id="OC源文件的编译过程"><a href="#OC源文件的编译过程" class="headerlink" title="OC源文件的编译过程"></a>OC源文件的编译过程</h2><ul><li>命令行查看编译的过程：<code>$ clang -ccc-print-phases main.m</code></li></ul> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arclin<span class="keyword">@ArcdeMacBook-Pro</span> TestObjC % clang -ccc-print-phases main.m </span><br><span class="line">               +- <span class="number">0</span>: input, <span class="string">&quot;main.m&quot;</span>, objective-c</span><br><span class="line">            +- <span class="number">1</span>: preprocessor, &#123;<span class="number">0</span>&#125;, objective-c-cpp-output</span><br><span class="line">         +- <span class="number">2</span>: compiler, &#123;<span class="number">1</span>&#125;, ir</span><br><span class="line">      +- <span class="number">3</span>: backend, &#123;<span class="number">2</span>&#125;, assembler</span><br><span class="line">   +- <span class="number">4</span>: assembler, &#123;<span class="number">3</span>&#125;, <span class="selector-tag">object</span></span><br><span class="line">+- <span class="number">5</span>: linker, &#123;<span class="number">4</span>&#125;, image</span><br><span class="line"><span class="number">6</span>: bind-arch, <span class="string">&quot;x86_64&quot;</span>, &#123;<span class="number">5</span>&#125;, image</span><br></pre></td></tr></table></figure><p>  preprocessor: 预处理器，处理宏定义，展开引入的头文件内容等</p><p>  complier: 编译，编译成ir中间代码</p><p>  backend: 后端，转成汇编代码</p><p>  assemler: 汇编，转成目标代码</p><p>  linker: 链接，链接动态库、静态库等</p><p>  bind-arch: 绑定当前处理器架构</p><ul><li><p>查看preprocesser(预处理)的结果：<code>$ clang -E main.m</code></p></li><li><p>词法分析，生成Token：<code>$ clang -fmodules -E -Xlang -dump-tokens main.m</code></p></li><li><p>语法分析，生成语法树（AST，Abstract Syntax Tree）：<code>$ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</code></p></li></ul><h2 id="词法分析、语法树"><a href="#词法分析、语法树" class="headerlink" title="词法分析、语法树"></a>词法分析、语法树</h2><p>词法分析，生成Token： <code>$ clang -fmodules -E -Xclang -dump-tokens main.m</code></p><p><a href="https://imgtu.com/i/483bNR"><img src="https://z3.ax1x.com/2021/09/19/483bNR.png" alt="483bNR.png"></a></p><p>语法分析，生成语法树（AST，Abstract Syntax Tree）： <code>$ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</code></p><p><a href="https://imgtu.com/i/483d9P"><img src="https://z3.ax1x.com/2021/09/19/483d9P.png" alt="483d9P.png"></a></p><h2 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h2><p>LLVM IR 有三种表现形式</p><ul><li><p>text：便于阅读的文本格式，类似于汇编语言，拓展名<code>.ll</code>，<code>$ clang -S -emit-llvm main.m</code></p></li><li><p>memory：内存格式</p></li><li><p>bitcode：二进制格式，拓展名<code>.bc</code>，<code>$ clang -c -emit-llvm main.m</code></p></li></ul><p>IR基本语法</p><ul><li>注释以分号开头</li><li>全局标识以@开头，局部标识符以%开头</li><li>alloca, 在当前函数栈帧中分配内存</li><li>i32，32bit，4个字节的意思</li><li>align，内存对齐</li><li>store，写入数据</li><li>load，读取数据</li></ul><p>官方语法参考</p><p><a href="https://llvm.org/docs/LangRef.html">https://llvm.org/docs/LangRef.html</a></p><h2 id="Clang插件开发"><a href="#Clang插件开发" class="headerlink" title="Clang插件开发"></a>Clang插件开发</h2><p>我们可以通过开发Clang插件来对我们的代码进行静态分析，大概步骤是我们先把LLVM源码和clang源码下载到本地，然后进行编译，编译完之后我们就可以得到我们自己的编译器，然后把我们的clang插件放入指定目录，然后在Xcode里面把Xcode原来的编译器配置为我们自己的编译器，然后就可以使用我们的Clang插件了。</p><p>举个例子，通过Clang我们可以对类名命名进行一些约束，比如NSString不用copy修饰的时候就警告一下。</p><p><a href="https://imgtu.com/i/48lKER"><img src="https://z3.ax1x.com/2021/09/19/48lKER.png" alt="48lKER.png"></a></p><p>接下来我们讲解一下配置和开发步骤</p><h3 id="下载LLVM源码"><a href="#下载LLVM源码" class="headerlink" title="下载LLVM源码"></a>下载LLVM源码</h3><p>可以直接在github上面下载到源码，目前最新版本号为12.0.1，直接点击页面的<code>Source Code</code>下载，<a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.1">github地址</a></p><h3 id="下载Clang源码"><a href="#下载Clang源码" class="headerlink" title="下载Clang源码"></a>下载Clang源码</h3><p>同样也是<a href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.1">这个地址</a>，目前的最新版本是12.0.1，点击<code>clang-12.0.1.src.tar.xz</code>下载</p><p>下载后解压，文件夹命名为clang，把文件夹置入LLVM源码目录<code>llvm</code>文件夹的<code>tools</code>文件夹中</p><h3 id="安装cmake和ninja（先安装brew，https-brew-sh）"><a href="#安装cmake和ninja（先安装brew，https-brew-sh）" class="headerlink" title="安装cmake和ninja（先安装brew，https://brew.sh）"></a>安装cmake和ninja（先安装brew，<a href="https://brew.sh)/">https://brew.sh）</a></h3><p>使用cmake和ninja工具是为了让编译速度更快</p><p><code>$ brew install cmake</code><br><code>$ brew install ninja</code></p><p>ninja如果安装失败，可以直接从<a href="https://github.com/ninja-build/ninja/releases">github</a>获取release版（ninja-mac.zip）放入<code>/usr/local/bin</code>中</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><h4 id="使用ninja模板进行编译"><a href="#使用ninja模板进行编译" class="headerlink" title="使用ninja模板进行编译"></a>使用ninja模板进行编译</h4><p>在llvm源码目录内新建一个文件夹命名为<code>llvm_build</code>目录备用，用来放置ninja模板，然后在新建一个<code>llvm_release</code>文件夹，用来放置编译后的成品</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cd</span> llvm_build</span><br><span class="line">$ cmake -G Ninja <span class="string">../llvm</span> -DCMAKE_INSTALL_PREFIX=<span class="string">../llvm_release</span></span><br></pre></td></tr></table></figure><p>命令执行完成后就<code>cd llvm_build</code>进入模板文件夹，然后依次执行以下命令</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ninja</span><br><span class="line"><span class="variable">$ </span>ninja release</span><br></pre></td></tr></table></figure><p>之后就可以在<code>llvm_release</code>内看到编译成品了</p><h4 id="使用Xcode进行编译"><a href="#使用Xcode进行编译" class="headerlink" title="使用Xcode进行编译"></a>使用Xcode进行编译</h4><p>也可以生成Xcode项目再进行编译，但是速度很慢（可能需要1个多小时）</p><p>在llvm源码目录内新建一个文件夹命名为<code>llvm_xcode</code>目录备用</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> llvm_xcode</span><br><span class="line"><span class="variable">$</span> cmake <span class="literal">-G</span> Xcode ../llvm</span><br></pre></td></tr></table></figure><p>生成完之后打开<code>llvm_xcode</code>内的<code>LLVM.xcodeproj</code></p><p>选择自动生成Scheme</p><p><a href="https://imgtu.com/i/430RxA"><img src="https://z3.ax1x.com/2021/09/19/430RxA.png" alt="430RxA.png"></a></p><p>选择<code>ALL_BUILD</code> Scheme 然后就可以Cmd+R开始编译了</p><p><a href="https://imgtu.com/i/43022d"><img src="https://z3.ax1x.com/2021/09/19/43022d.png" alt="43022d.png"></a></p><p>编译后的成品在<code>llvm_xcode/Debug/bin</code>中</p><h3 id="创建Clang插件"><a href="#创建Clang插件" class="headerlink" title="创建Clang插件"></a>创建Clang插件</h3><p>在llvm源码的<code>/llvm/tools/clang/tools</code>文件夹内，新建一个文件夹，命名为<code>my-plugin</code>(举例名字)</p><p>在同目录下打开文件<code>CMakeLists.txt</code>，在最后一行写入<code>add_clang_subdirectory(my-plugin)</code>后保存</p><p>在<code>my-plugin</code>文件夹内新建一个文件命名为<code>MyPlugin.cpp</code>，再新建一个<code>CMakeLists.txt</code>文件到该文件夹内</p><p>编辑<code>CMakeLists.txt</code>文件，写入</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_llvm_library</span><span class="params">(MyPlugin MODULE BUILDTREE_ONLY MyPlugin.cpp)</span></span></span><br></pre></td></tr></table></figure><p>表示可加载模块</p><p>如果有很多cpp文件的话，那么也可以这么写</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_llvm_library( MyPlugin MODULE BUILDTREE_ONLY </span><br><span class="line">MyPlugin.cpp</span><br><span class="line">MyPlugin2.cpp</span><br><span class="line">MyPlugin3.cpp</span><br><span class="line">MyPlugin4.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="编写Clang插件"><a href="#编写Clang插件" class="headerlink" title="编写Clang插件"></a>编写Clang插件</h3><p>因为在文本编辑器中编辑c++代码很麻烦，所以我们一般会生成一个Xcode模板（也就是上面提到那个<code>使用Xcode进行编译</code>的Xcode模板）帮我们辅助编写C++代码</p><p>所以我们在llvm源码目录的<code>llvm_xcode</code>文件夹内执行一下<code>cmake -G Xcode ../llvm</code>命令，就可以得到一个Xcode模板，打开工程之后，就可以看到我们的插件目录</p><p><a href="https://imgtu.com/i/4369gg"><img src="https://z3.ax1x.com/2021/09/19/4369gg.png" alt="4369gg.png"></a></p><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 必要的头文件，主要用来解析语法树</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/AST/AST.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/AST/ASTConsumer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/Frontend/FrontendPluginRegistry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang::ast_matchers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MyPlugin &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyASTConsumer</span> :</span> <span class="keyword">public</span> ASTConsumer &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/// 每当生成一棵语法树就会调用这个方法</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">HandleTranslationUnit</span><span class="params">(ASTContext &amp;Ctx)</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;MyPlugin-HandleTranslationUnit&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyAction</span> :</span> <span class="keyword">public</span> PluginASTAction &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/// 一定要重写的两个父类方法，指定Consumer</span></span><br><span class="line">        <span class="function">unique_ptr&lt;ASTConsumer&gt; <span class="title">CreateASTConsumer</span><span class="params">(CompilerInstance &amp;ci, StringRef InFile)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> unique_ptr&lt;MyASTConsumer&gt; (<span class="keyword">new</span> MyASTConsumer);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">ParseArgs</span><span class="params">(<span class="keyword">const</span> CompilerInstance &amp;CI, <span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 注册插件</span></span><br><span class="line"><span class="keyword">static</span> FrontendPluginRegistry::Add&lt;MyPlugin::MyAction&gt;</span><br><span class="line"><span class="built_in">X</span>(<span class="string">&quot;MyPlugin&quot;</span>, <span class="string">&quot;The MyPlugin is my first clang-plugin.&quot;</span>);</span><br></pre></td></tr></table></figure><p>编译<code>MyPlugin</code> Scheme</p><p><a href="https://imgtu.com/i/481kdA"><img src="https://z3.ax1x.com/2021/09/19/481kdA.png" alt="481kdA.png"></a></p><p>最后得到成品<code>MyPlugin.dylib</code></p><p><a href="https://imgtu.com/i/481eRf"><img src="https://z3.ax1x.com/2021/09/19/481eRf.png" alt="481eRf.png"></a></p><h3 id="使用Clang插件"><a href="#使用Clang插件" class="headerlink" title="使用Clang插件"></a>使用Clang插件</h3><p><code>Show in finder</code>取出<code>MyPlugin.dylib</code>之后，我们新建一个测试工程</p><p>在新建的Xcode项目中指定加载插件：<code>Build Settings &gt; OTHER_CFLAGS</code>，双击输入框后输入</p><p><code>-Xclang -load -Xclang 动态库路径 -Xclang -add-plugin -Xclang 插件名称</code>，回车</p><p><a href="https://imgtu.com/i/43XojJ"><img src="https://z3.ax1x.com/2021/09/19/43XojJ.png" alt="43XojJ.png"></a></p><p>因为Xcode自带的编译器不允许加载插件，所以我们使用刚才自己编译好的编译器</p><p>首先下载<a href="https://github.com/weizhangCoder/XcodeHacking">Xcode破解插件</a></p><p>进入目录<code>XcodeHacking/HackedClang.xcplugin/Contents/Resources</code></p><p>修改<code>HackedClang.xcspec</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ExecPath</span> = <span class="string">&quot;/opt/llvm/llvm_build/bin/clang&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>改为我们刚才编译好的clang的全路径</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ExecPath</span> = <span class="string">&quot;/Users/arclin/Downloads/llvm-project-llvmorg-12.0.1/llvm-release/bin/clang&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>然后在XcodeHacking目录下进行命令行，</p><p>将XcodeHacking的内容剪切到Xcode内部</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv HackedClang.xcplugin `xcode-select -p`<span class="regexp">/../</span>PlugIns<span class="regexp">/Xcode3Core.ideplugin/</span>Contents<span class="regexp">/SharedSupport/</span>Developer<span class="regexp">/Library/</span>Xcode/Plug-ins</span><br><span class="line">$ sudo mv HackedBuildSystem.xcspec `xcode-select -p`<span class="regexp">/Platforms/i</span>PhoneSimulator.platform<span class="regexp">/Developer/</span>Library<span class="regexp">/Xcode/</span>Specifications</span><br></pre></td></tr></table></figure><p>这时候Xcode就应该有多一个编译器可选项，我们选择<code>Clang LLVM Trunk</code></p><p><a href="https://imgtu.com/i/48lXI1"><img src="https://z3.ax1x.com/2021/09/19/48lXI1.png" alt="48lXI1.png"></a></p><p>然后就可以Clean一下后编译进行测试。</p><p>自己在测试的时候发生了一些报错的问题（可能我是用的M1笔记本的原因），可以修改<code>Build System</code>的值为<code>Legacy Build System</code>解决</p><p><a href="https://imgtu.com/i/48lsxS"><img src="https://z3.ax1x.com/2021/09/19/48lsxS.png" alt="48lsxS.png"></a></p><p>如果发生了<code>CADisplayLink&#39; is unavailable: not available on macOS</code>的问题，那尝试新建一个Mac项目</p><p>最后贴出完整的插件代码仅供参考</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/AST/AST.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/AST/DeclObjC.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/AST/ASTConsumer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/ASTMatchers/ASTMatchers.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/Frontend/CompilerInstance.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/ASTMatchers/ASTMatchFinder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;clang/Frontend/FrontendPluginRegistry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明使用命名空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang::ast_matchers;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> MyPlugin &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：扫描完毕回调</span></span><br><span class="line">    <span class="comment">// 4、自定义回调类，继承自MatchCallback</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyMatchCallback</span> :</span> <span class="keyword">public</span> MatchFinder::MatchCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// CI传递路径：MyASTAction类中的CreateASTConsumer方法参数 -&gt; MyASTConsumer的构造函数 -&gt; MyMatchCallback的私有属性，通过构造函数从MyASTConsumer构造函数中获取</span></span><br><span class="line">        CompilerInstance &amp;CI;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否是自己的文件</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isUserSourceCode</span><span class="params">(<span class="keyword">const</span> string fileName)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 文件名不为空</span></span><br><span class="line">            <span class="keyword">if</span> (fileName.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 非Xcode中的代码都认为是用户的</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == fileName.<span class="built_in">find</span>(<span class="string">&quot;/Applications/Xcode.app/&quot;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否应该用copy修饰</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isShouldUseCopy</span><span class="params">(<span class="keyword">const</span> string typeStr)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 判断类型是否是 NSString / NSArray / NSDictionary</span></span><br><span class="line">            <span class="keyword">if</span> (typeStr.<span class="built_in">find</span>(<span class="string">&quot;NSString&quot;</span>) != string::npos ||</span><br><span class="line">                typeStr.<span class="built_in">find</span>(<span class="string">&quot;NSArray&quot;</span>) != string::npos ||</span><br><span class="line">                typeStr.<span class="built_in">find</span>(<span class="string">&quot;NSDictionary&quot;</span>) != string::npos) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="built_in">MyMatchCallback</span>(CompilerInstance &amp;CI):<span class="built_in">CI</span>(CI) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载run方法</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">const</span> MatchFinder::MatchResult &amp;Result)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 通过Result获取节点对象，根据节点id(&quot;objcPropertyDecl&quot;)获取(此id需要与MyASTConsumer构造方法中bind的id一致)</span></span><br><span class="line">            <span class="keyword">const</span> ObjCPropertyDecl *propertyDecl = Result.Nodes.getNodeAs&lt;ObjCPropertyDecl&gt;(<span class="string">&quot;objcPropertyDecl&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取文件名称（包含路径）</span></span><br><span class="line">            string fileName = CI.<span class="built_in">getSourceManager</span>().<span class="built_in">getFilename</span>(propertyDecl-&gt;<span class="built_in">getSourceRange</span>().<span class="built_in">getBegin</span>()).<span class="built_in">str</span>();</span><br><span class="line">            <span class="comment">// 如果节点有值 &amp;&amp; 是用户文件</span></span><br><span class="line">            <span class="keyword">if</span> (propertyDecl &amp;&amp; <span class="built_in">isUserSourceCode</span>(fileName)) &#123;</span><br><span class="line">                <span class="comment">// 获取节点的类型，并转成字符串</span></span><br><span class="line">                string typeStr = propertyDecl-&gt;<span class="built_in">getType</span>().<span class="built_in">getAsString</span>();</span><br><span class="line">                <span class="comment">// 节点的描述信息</span></span><br><span class="line">                ObjCPropertyAttribute::Kind attrKind = propertyDecl-&gt;<span class="built_in">getPropertyAttributes</span>();</span><br><span class="line">                <span class="comment">// 应该使用copy，但是没有使用copy</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isShouldUseCopy</span>(typeStr) &amp;&amp; !(attrKind &amp; ObjCPropertyAttribute::kind_copy)) &#123;</span><br><span class="line">                    <span class="comment">// 通过CI获取诊断引擎</span></span><br><span class="line">                    DiagnosticsEngine &amp;diag = CI.<span class="built_in">getDiagnostics</span>();</span><br><span class="line">                    <span class="comment">// Report 报告</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     错误位置：getLocation 节点位置</span></span><br><span class="line"><span class="comment">                     错误：getCustomDiagID（等级，提示）</span></span><br><span class="line"><span class="comment">                     DiagnosticsEngine::Warning 警告</span></span><br><span class="line"><span class="comment">                     DiagnosticsEngine::Error 错误</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    diag.<span class="built_in">Report</span>(propertyDecl-&gt;<span class="built_in">getLocation</span>(), diag.<span class="built_in">getCustomDiagID</span>(DiagnosticsEngine::Warning, <span class="string">&quot;%0 - 推荐使用copy修饰该属性&quot;</span>))&lt;&lt; typeStr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：扫描配置完毕</span></span><br><span class="line">    <span class="comment">// 3、自定义MyASTConsumer，继承自抽象类 ASTConsumer，用于监听AST节点的信息 -- 过滤器</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyASTConsumer</span> :</span> <span class="keyword">public</span> ASTConsumer &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// AST 节点查找器（过滤器）</span></span><br><span class="line">        MatchFinder matcher;</span><br><span class="line">        <span class="comment">// 回调对象</span></span><br><span class="line">        MyMatchCallback callback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造方法中创建MatchFinder对象</span></span><br><span class="line">        <span class="built_in">MyASTConsumer</span>(CompilerInstance &amp;CI):<span class="built_in">callback</span>(CI) &#123; <span class="comment">// 构造即将CI传递给callback</span></span><br><span class="line">            <span class="comment">// 添加一个MatchFinder，每个objcPropertyDecl节点绑定一个objcPropertyDecl标识（去匹配objcPropertyDecl节点）</span></span><br><span class="line">            <span class="comment">// 回调callback，其实是在CJLMatchCallback里面重写run方法（真正回调的是回调run方法）</span></span><br><span class="line">matcher.<span class="built_in">addMatcher</span>(<span class="built_in">objcPropertyDecl</span>().<span class="built_in">bind</span>(<span class="string">&quot;objcPropertyDecl&quot;</span>), &amp;callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载两个方法 HandleTopLevelDecl 和 HandleTranslationUnit</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析完毕一个顶级的声明就回调一次（顶级节点，即全局变量，属性，函数等）</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">HandleTopLevelDecl</span><span class="params">(DeclGroupRef D)</span> </span>&#123;</span><br><span class="line"><span class="comment">//            cout&lt;&lt;&quot;正在解析...&quot;&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当整个文件都解析完毕后回调</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">HandleTranslationUnit</span><span class="params">(ASTContext &amp;Ctx)</span> </span>&#123;</span><br><span class="line"><span class="comment">//            cout&lt;&lt;&quot;文件解析完毕！！！&quot;&lt;&lt;endl;</span></span><br><span class="line">            <span class="comment">// 将文件解析完毕后的上下文context（即AST语法树） 给 matcher</span></span><br><span class="line">            matcher.<span class="built_in">matchAST</span>(Ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、继承PluginASTAction，实现我们自定义的MyASTAction，即自定义AST语法树行为</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyASTAction</span> :</span> <span class="keyword">public</span> PluginASTAction &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重载ParseArgs 和 CreateASTConsumer方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         解析给定的插件命令行参数</span></span><br><span class="line"><span class="comment">         - param CI 编译器实例，用于报告诊断。</span></span><br><span class="line"><span class="comment">         - return 如果解析成功，则为true；否则，插件将被销毁，并且不执行任何操作。该插件负责使用CompilerInstance的Diagnostic对象报告错误。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">ParseArgs</span><span class="params">(<span class="keyword">const</span> CompilerInstance &amp;CI, <span class="keyword">const</span> std::vector&lt;std::string&gt; &amp;arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回自定义的MyASTConsumer对象，抽象类ASTConsumer的子类</span></span><br><span class="line">        <span class="function">unique_ptr&lt;ASTConsumer&gt; <span class="title">CreateASTConsumer</span><span class="params">(CompilerInstance &amp;CI, StringRef InFile)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             传递CI</span></span><br><span class="line"><span class="comment">             CI用于：</span></span><br><span class="line"><span class="comment">             - 判断文件是否是用户的</span></span><br><span class="line"><span class="comment">             - 抛出警告</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> unique_ptr&lt;MyASTConsumer&gt;(<span class="keyword">new</span> <span class="built_in">MyASTConsumer</span>(CI));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一步：注册插件，并自定义MyASTAction类</span></span><br><span class="line"><span class="comment">// 1、注册插件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> FrontendPluginRegistry::Add&lt;MyPlugin::MyASTAction&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;MyPlugin&quot;</span>, <span class="string">&quot;this is MyPlugin&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>参考：<a href="https://juejin.cn/post/7004633055012864031">https://juejin.cn/post/7004633055012864031</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要简述LLVM的概念与Clang插件开发&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- 内存管理</title>
    <link href="https://www.arclin.cn/post/56d1bd42.html"/>
    <id>https://www.arclin.cn/post/56d1bd42.html</id>
    <published>2021-09-03T09:26:00.000Z</published>
    <updated>2022-07-12T16:51:57.241Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍iOS中内存管理的一些事情</p><span id="more"></span><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="CADisplayLink、NSTimer"><a href="#CADisplayLink、NSTimer" class="headerlink" title="CADisplayLink、NSTimer"></a>CADisplayLink、NSTimer</h3><p><code>CADisplayLink</code>、<code>NSTimer</code>会对<code>target</code>产生强引用，如果<code>target</code>又对它们产生强引用，那么就会引发循环引用</p><p>比如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerTimer) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>在这里，<code>self</code>强持有了<code>timer</code>，<code>timer</code>强持有了<code>self</code>，造成了循环引用</p><h4 id="利用block解决"><a href="#利用block解决" class="headerlink" title="利用block解决"></a>利用block解决</h4><p>针对<code>NSTimer</code>我们可以有另外的解决办法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakself = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">    [weakself timerTest];</span><br><span class="line">]&#125;;</span><br></pre></td></tr></table></figure><p>让<code>timer</code>强持有block，block弱持有<code>self</code>，这样子<code>self</code>就是间接被弱持有，打破了循环引用。</p><h4 id="利用NSProxy解决"><a href="#利用NSProxy解决" class="headerlink" title="利用NSProxy解决"></a>利用NSProxy解决</h4><p>新建一个类继承自<code>NSProxy</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyProxy</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">    <span class="comment">// NSProxy对象不需要调用init，因为它没有init方法</span></span><br><span class="line">    MyProxy *proxy = [MyProxy alloc];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 实现消息转发的两个方法，一定要实现，不然会报方法找不到的错误</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    [invocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:[MyProxy proxyWithTarget:<span class="keyword">self</span>] selector:<span class="keyword">@selector</span>(test) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原理很简单，就是把<code>self</code>让<code>proxy</code>弱持有，<code>timer</code>强持有<code>proxy</code>，这样子就能够做到间接弱持有<code>self</code>，打破循环引用</p><p>为了让<code>timer</code>调用<code>selector</code>的时候能调回到<code>self</code>的方法，在<code>proxy</code>内部我们使用消息转发机制，把消息转发到<code>target</code>（也就是<code>self</code>）中，实现调用。</p><p>至于消息转发机制的另一个方法<code>-forwardingTargetForSelector:</code>之所以不能使用，是因为<code>NSProxy</code>不提供。</p><p>实际上我们如果不继承自<code>NSProxy</code>，直接继承自<code>NSObject</code>也是能完成上述操作的，但是使用<code>NSProxy</code>的话可以跳过消息发送和动态方法解析阶段，直接进入消息转发阶段，效率比较高</p><blockquote><p>注意： <code>NSProxy</code>对象如果调用<code>isKindOfClass:</code>或其他方法，那么由于它直接进入了消息转发阶段，所以会直接拿<code>target</code>属性去调用方法，所以都跟<code>NSProxy</code>对象本身没有关系</p></blockquote><h3 id="GCD定时器"><a href="#GCD定时器" class="headerlink" title="GCD定时器"></a>GCD定时器</h3><ul><li><code>NSTimer</code>依赖<code>RunLoop</code>，如果<code>Runloop</code>的任务过于繁重，可能会导致<code>NSTimer</code>不准时<ul><li>因为Runloop每次循环的时间是不定的，所以下次循环的时候到达处理定时器那个环节，不一定跟上次刚好相差我们所指定时间，所以就会不准</li></ul></li><li>GCD的定时器会更加准时</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建定时器</span></span><br><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置时间</span></span><br><span class="line"><span class="built_in">NSTimeInterval</span> start = <span class="number">2.0</span>; <span class="comment">// 2秒后开始执行</span></span><br><span class="line"><span class="built_in">NSTimeInterval</span> interval = <span class="number">1.0</span>; <span class="comment">// 每1秒执行一次</span></span><br><span class="line">dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * <span class="built_in">NSEC_PER_SEC</span>), interval * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调</span></span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;11111&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动定时器</span></span><br><span class="line">dispatch_resume(timer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消定时器</span></span><br><span class="line"><span class="comment">// dispatch_source_cancel(timer);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.timer = timer;</span><br></pre></td></tr></table></figure><p>由于GCD的定时器跟<code>Runloop</code>没有关系，所以滚动视图也不会影响GCD定时器的执行</p><p>除了使用block回调，我们也可以写一个C函数作为回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_set_event_handler_f(timer, timerFire);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timerFire</span><span class="params">(<span class="keyword">void</span> *param)</span> </span>&#123;</span><br><span class="line">    NSLog(@<span class="string">&quot;%@ %@&quot;</span>,param,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><ul><li>内存布局从低地址到高地址排序如下<ol><li>保留</li><li>代码段（__TEXT）</li><li>数据段（__DATA）：字符串常量， 已初始化数据，未初始化数据</li><li>堆（heap）</li><li>栈（stack）</li><li>内核区</li></ol></li><li>代码段：编译之后的代码</li><li>数据段：<ul><li>字符串常量</li><li>已初始化数据：已初始化的全局变量、静态变量等</li><li>未初始化数据：未初始化的全局变量、静态变量等</li></ul></li><li>堆：通过alloc、malloc、calloc的那个动态分配的空间，分配的内存空间地址越来越大</li><li>栈：函数调用开销，比如局部变量，分配的内存空间地址越来越小</li></ul><h2 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h2><ul><li><p>从64bit开始，iOS引入了Tagged Pointer技术，用于优化<code>NSNumber</code>,<code>NSDate</code>，<code>NSString</code>等小对象的存储</p></li><li><p>在没有使用Tagged Pointer之前，<code>NSNumber</code>等对象需要动态分配内存，维护引用计数的等，<code>NSNumber</code>指针存储的是堆中<code>NSNumber</code>对象的地址值.</p></li><li><p>使用<code>Tagged Pointer</code>之后，<code>NSNumber</code>指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中。</p></li><li><p>在Mac环境下当对象指针的二进制最低有效位是1，则该指针为<code>Tagged Pointer</code>（如果是0那么就是OC对象，因为OC对象分配内存是按照16个字节对齐的，所以最后一位肯定是0）,可以编写如下函数来判断是否是<code>Tagged Pointer</code></p><ul><li>跟1进行与运算，取出最低位判断是不是1即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">isTaggedPointer</span><span class="params">(id pointer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">long</span>)(__bridge <span class="keyword">void</span> *)pointer &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果是iOS环境下，则判断的是最高有效位(第64位)是否是1，即<code>(long)(__bridge void *)pointer &amp; 1UL&lt;&lt;63</code></li></ul></li><li><p>当指针不够存储数据时，才会使用动态分配内存来存储数据（比如NSNumber的存储的数字太大了，指针8个十六进制位都装不下）</p></li><li><p><code>objc_msgSend</code>能识别<code>Tagged Pointer</code>，比如<code>NSNumber</code>的intValue方法，直接从指针提取数据，节省了以前的调用开销</p></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br></pre></td></tr></table></figure><p>这个属性的set方法实际为</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)<span class="built_in">setName</span>:(NSString *)<span class="built_in">name</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">_name</span> != <span class="built_in">name</span>) &#123;</span><br><span class="line">        [<span class="variable">_name</span> release];</span><br><span class="line">        <span class="variable">_name</span> = [<span class="built_in">name</span> retain];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我们这么给<code>name</code>赋值<code>self.name = [NSString stringWithForamt:@&quot;abcdefghijkl&quot;]</code>，因为这个太大了，转不成<code>tagged pointer</code>，那么在多线程环境下，有可能会因为多次执行了<code>[_name release]</code>导致坏内存访问而崩溃</p><p>字符串其实还有其他样子，总的来说，除了<code>__NSCFString</code>，其他类型的字符串都不会调用<code>release</code>方法</p><ul><li><p>__NSCFConstantString</p><p>  字符串常量，是一种编译时常量，它的 retainCount 值很大，是 4294967295，在控制台打印出的数值则是 18446744073709551615==2^64-1，测试证明，即便对其进行 release 操作，retainCount 也不会产生任何变化。是创建之后便是放不掉的对象。<strong>相同内容的 __NSCFConstantString 对象的地址相同，也就是说常量字符串对象是一种单例</strong>。</p><p>  这种对象一般通过字面值 <code>@&quot;...&quot;</code>、<code>CFSTR(&quot;...&quot;)</code> 或者 <code>stringWithString</code>: 方法（需要说明的是，这个方法在 iOS6 SDK 中已经被称为redundant，使用这个方法会产生一条编译器警告。这个方法等同于字面值创建的方法）产生。</p><p>  这种对象存储在字符串常量区。</p></li><li><p>__NSCFString</p><p>  和 <code>__NSCFConstantString</code> 不同， <code>__NSCFString</code>对象是在运行时创建的一种 <code>NSString</code>子类，他并不是一种字符串常量。所以和其他的对象一样在被创建时获得了 1 的引用计数。</p><p>  通过 NSString 的 stringWithFormat 等方法创建的 NSString 对象一般都是这种类型。</p><p>  这种对象被存储在堆上。</p></li><li><p>NSTaggedPointerString</p><p>  理解这个类型，需要明白什么是<code>TaggedPointer</code>，这是苹果在 64 位环境下对 NSString,NSNumber 等对象做的一些优化。简单来讲可以理解为把指针指向的内容直接放在了指针变量的内存地址中，因为在 64 位环境下指针变量的大小达到了 8 位足以容纳一些长度较小的内容。于是使用了标签指针这种方式来优化数据的存储方式。从他的引用计数可以看出，这货也是一个释放不掉的单例常量对象。在运行时根据实际情况创建。</p><p>  对于 <code>NSString</code> 对象来讲，当非字面值常量的数字，英文字母字符串的长度小于等于 9 的时候会自动成为 <code>NSTaggedPointerString</code> 类型，如果有中文或其他特殊符号（可能是非 ASCII 字符）存在的话则会直接成为 ）<code>__NSCFString</code> 类型。</p><p>  这种对象被直接存储在指针的内容中，可以当作一种伪对象。</p><p>  当字符串的长度为10个以内时，字符串的类型都是<code>NSTaggedPointerString</code>类型，当超过10个时，字符串的类型才是<code>__NSCFString</code></p></li><li><p>从<code>NSTaggedPointerString</code>中读取出字符串的值</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_MASK (1UL&lt;&lt;63)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_INDEX_SHIFT 0</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_SLOT_SHIFT 0</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_PAYLOAD_LSHIFT 1</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_PAYLOAD_RSHIFT 4</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_INDEX_SHIFT 55</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_SLOT_SHIFT 55</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_PAYLOAD_LSHIFT 9</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_EXT_PAYLOAD_RSHIFT 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> _objc_isTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">uintptr_t</span>)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uintptr_t</span> _objc_decodeTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)ptr ^ objc_debug_taggedpointer_obfuscator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uintptr_t</span> _objc_getTaggedPointerValue(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> value = _objc_decodeTaggedPointer(ptr);</span><br><span class="line">    <span class="keyword">uintptr_t</span> basicTag = (value &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class="line">    <span class="keyword">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class="line">        <span class="keyword">return</span> (value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (value &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">intptr_t</span> _objc_getTaggedPointerSignedValue(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> value = _objc_decodeTaggedPointer(ptr);</span><br><span class="line">    <span class="keyword">uintptr_t</span> basicTag = (value &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class="line">    <span class="keyword">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">intptr_t</span>)value &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">intptr_t</span>)value &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NSNumber"><a href="#NSNumber" class="headerlink" title="NSNumber"></a>NSNumber</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *number1 = @(<span class="number">0x1</span>);</span><br><span class="line"><span class="built_in">NSNumber</span> *number2 = @(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">NSNumber</span> *number3 = @(<span class="number">0x3F</span>);</span><br><span class="line"><span class="built_in">NSNumber</span> *numberFFFF = @(<span class="number">0xFFFFFFFFFFEFE</span>);</span><br><span class="line"><span class="built_in">NSNumber</span> *maxNum = @(MAXFLOAT);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;number1 pointer is %p class is %@&quot;</span>, number1, number1.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;number2 pointer is %p class is %@&quot;</span>, number2, number2.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;number3 pointer is %p class is %@&quot;</span>, number3, number3.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;numberffff pointer is %p class is %@&quot;</span>, numberFFFF, numberFFFF.class);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;maxNum pointer is %p class is %@&quot;</span>, maxNum, maxNum.class);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TaggedPointerDemo[<span class="number">59218</span>:<span class="number">2167895</span>] number1 pointer is <span class="number">0xf7cb914ffb51479a</span> <span class="keyword">class</span> is __NSCFNumber</span><br><span class="line">TaggedPointerDemo[<span class="number">59218</span>:<span class="number">2167895</span>] number2 pointer is <span class="number">0xf7cb914ffb51458a</span> <span class="keyword">class</span> is __NSCFNumber</span><br><span class="line">TaggedPointerDemo[<span class="number">59218</span>:<span class="number">2167895</span>] number3 pointer is <span class="number">0xf7cb914ffb51447a</span> <span class="keyword">class</span> is __NSCFNumber</span><br><span class="line">TaggedPointerDemo[<span class="number">59218</span>:<span class="number">2167895</span>] numberffff pointer is <span class="number">0xf7346eb004aea86b</span> <span class="keyword">class</span> is __NSCFNumber</span><br><span class="line">TaggedPointerDemo[<span class="number">59218</span>:<span class="number">2167895</span>] maxNum pointer is <span class="number">0x28172a0c0</span> <span class="keyword">class</span> is __NSCFNumber</span><br></pre></td></tr></table></figure><p>我们发现对于<code>NSNumber</code>，我们打印出来的数据类型均为<code>__NSCFNumber</code>,但是我们发现对于MAXFLOAT打印出的地址显然与其他几项不符，上面几个<code>NSNumber</code>的地址以0xf开头，根据字符串地址的经验我们可以看出<code>f = 1111</code>,首位标记位为1，表示这个数据类型属于<code>TaggedPointer</code>。而<code>MAXFLOAT</code>不是。</p><h2 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h2><ul><li><p>在iOS中，使用<code>引用计数</code>来管理OC对象的内存</p></li><li><p>一个新创建的OC对象的引用计数默认是1，当引用计数减为0，OC对象就会销毁，释放其占用的内存空间</p></li><li><p>调用retain会让OC对象的引用计数+1，调用release会让OC对象的引用计数-1</p></li><li><p>内存管理的经验总结：</p><ul><li>当调用<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>方法返回了一个对象，在不需要这个对象时，要调用<code>release</code>或者<code>autorelease</code>释放它</li><li>想拥有某个对象，就让它的引用计数+1;不想再拥有某个对象，就让它的引用计数-1</li></ul></li><li><p>可以通过以下私有函数来查看自动释放池的情况</p><p>  <code>extern void _objc_autoreleasePoolPrint(void); </code></p></li></ul><p>在ARC中声明<code>@property(nonatomic,assign) int age;</code> 其set方法相当于MRC中的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age &#123;</span><br><span class="line">    _age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ARC中声明<code>@property(nonatomic,strong) NSObject *age;</code> 其set方法相当于MRC中的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="built_in">NSObject</span> *)age &#123;</span><br><span class="line">    <span class="keyword">if</span> (_age != age) &#123; <span class="comment">// 防止同个对象释放后引用计数变成0，就不能再retain了</span></span><br><span class="line">        [_age release]; <span class="comment">// 防止新对象进来之后，旧对象的引用计数多出了1导致释放不掉</span></span><br><span class="line">        _age = [age reatin]; <span class="comment">// 引用计数+1，防止被外部一不小心释放了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>关于Autorelease</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">self.data</span> = [NSMutableArray array]<span class="comment">; // 自动进行了autorelease</span></span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.data = <span class="comment">[<span class="comment">[<span class="comment">[NSMutableArray alloc]</span> init]</span> autorelease]</span>;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">self.data</span> = [[NSMutableArray alloc] init]<span class="comment">;</span></span><br><span class="line"><span class="section">[self.data release]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSMutableArray</span> *<span class="class"><span class="keyword">data</span> = [[<span class="type">NSMutableArray</span> alloc] init];</span></span><br><span class="line"><span class="title">self</span>.<span class="class"><span class="keyword">data</span> = <span class="keyword">data</span>;</span></span><br><span class="line">[<span class="class"><span class="keyword">data</span> release];</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="引用计数的存储"><a href="#引用计数的存储" class="headerlink" title="引用计数的存储"></a>引用计数的存储</h2><p>在64bit中，引用计数可以直接存储在优化过的isa指针中，如果isa指针不够存的话就存储在<code>SiteTable</code>类中（最终的引用计数是两个存储的地方都会取出来值，然后求和）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="keyword">weak_table_t</span> weak_table;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>refcnts是一个存放着对象引用计数的散列表</li></ul><p>在SiteTable中获取到<code>retainCount</code>的核心代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">objc_object::sidetable_getExtraRC_nolock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ASSERT(isa.nonpointer);</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>); </span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.end()) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 遍历refcnts</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT; <span class="comment">// 进行位运算取出retainCount</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Weak"><a href="#Weak" class="headerlink" title="Weak"></a>Weak</h2><p> weak指针能够在对象释放的时候把指针清空，具体是怎么做到的。我们需要看一下对象<code>dealloc</code>的过程</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">objc_object::rootDealloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(isa.nonpointer                     &amp;&amp; <span class="comment">// 0代表普通的指针，1代表优化过的指针，使用位域存储信息</span></span><br><span class="line">                 !isa.weakly_referenced             &amp;&amp; <span class="comment">// 是否有弱引用指针</span></span><br><span class="line">                 !isa.has_assoc                     &amp;&amp; <span class="comment">// 是否有设置关联对象</span></span><br><span class="line">                 !isa.has_cxx_dtor                  &amp;&amp; <span class="comment">// 是否有C++即构函数</span></span><br><span class="line">                 !isa.has_sidetable_rc))   <span class="comment">// 引用计数器是不是过大而无法存放在isa中，如果为1，那引用计数会存储在SideTable的类的属性中</span></span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        object_dispose((id)<span class="keyword">this</span>); <span class="comment">// 显然弱引用指针指向的对象会进入这里</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id  <span class="title">object_dispose</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj); <span class="comment">// 释放前做一些事情</span></span><br><span class="line">    <span class="built_in">free</span>(obj); <span class="comment">// 这里才释放</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj); <span class="comment">// 清除成员变量</span></span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj, <span class="comment">/*deallocating*/</span><span class="literal">true</span>); <span class="comment">// 移除关联对象</span></span><br><span class="line">        obj-&gt;clearDeallocating(); <span class="comment">// 将指向当前对象的弱指针置为nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">objc_object::clearDeallocating</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for raw pointer isa.</span></span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">        clearDeallocating_slow(); <span class="comment">// 再进入这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">NEVER_INLINE <span class="keyword">void</span> <span class="title">objc_object::clearDeallocating_slow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ASSERT(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>]; <span class="comment">// 拿出SiteTables数组，然后取出对应的SiteTable对象</span></span><br><span class="line">    table.lock();</span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)<span class="keyword">this</span>); <span class="comment">// 清除弱引用指针 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.erase(<span class="keyword">this</span>); <span class="comment">// 清除引用计数表</span></span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">weak_clear_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent_id)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 把SiteTable里面的weakTable和指针传进去</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    <span class="keyword">if</span> (entry == nil) &#123;</span><br><span class="line">        <span class="comment">/// XXX shouldn&#x27;t happen, but does with mismatched CF/objc</span></span><br><span class="line">        <span class="comment">//printf(&quot;XXX no entry for clear deallocating %p\n&quot;, referent);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero out references</span></span><br><span class="line">    <span class="keyword">weak_referrer_t</span> *referrers;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;__weak variable at %p holds %p instead of %p. &quot;</span></span><br><span class="line">                             <span class="string">&quot;This is probably incorrect use of &quot;</span></span><br><span class="line">                             <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                             <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                             referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uintptr_t</span> <span class="title">hash_pointer</span><span class="params">(objc_object *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ptr_hash((<span class="keyword">uintptr_t</span>)key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">weak_entry_t</span> * <span class="title">weak_entry_for_referent</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, objc_object *referent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ASSERT(referent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!weak_entries) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 通过与运算得到索引</span></span><br><span class="line">    <span class="keyword">size_t</span> begin = hash_pointer(referent) &amp; weak_table-&gt;mask;</span><br><span class="line">    <span class="keyword">size_t</span> index = begin;</span><br><span class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (weak_table-&gt;weak_entries[index].referent != referent) &#123;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; weak_table-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(weak_table-&gt;weak_entries);</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="keyword">if</span> (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;weak_table-&gt;weak_entries[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>Weak指针指向的对象释放流程如下</p><ol><li>清除成员变量，移除关联对象</li><li>拿到对象对应的SiteTable，再取出里面的weak_table</li><li>通过hash后的对象的指针和weak_table进行一次与运算，得到索引，在weak_table中通过索引取出弱引用指针</li><li>置空取出的所有的弱引用指针</li><li>清除引用计数表</li><li>释放对象</li></ol><h2 id="Copy和MutableCopy"><a href="#Copy和MutableCopy" class="headerlink" title="Copy和MutableCopy"></a>Copy和MutableCopy</h2><p>拷贝的目的：产生一个副本对象，跟源对象互不影响<br>修改了源对象，不会影响副本对象<br>修改了副本对象，不会影响源对象</p><p>iOS提供了2个拷贝方法</p><ol><li>copy ，不可变拷贝，产生不可变副本。</li><li>mutableCopy，可变拷贝，产生可变副本。</li><li>浅拷贝：指针拷贝，没有产生新的对象。（不可变对象copy）</li><li>深拷贝：内容拷贝，产生新的对象。(可变、不可变对象调用mutableCopy或者可变对象调用copy)</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str1 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;test&quot;</span>];</span><br><span class="line"><span class="built_in">NSString</span> *str2 = [str1 <span class="keyword">copy</span>]; <span class="comment">// 返回的是NSString</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *str3 = [str1 mutableCopy]; <span class="comment">// 返回的是NSMutableString</span></span><br></pre></td></tr></table></figure><p>当<code>copy</code>方法被不可变对象调用的话，不会发生什么变化，直接还是返回原来的对象，但是这时候引用计数会加1，相当于<code>retain</code>了一下，所以上面的代码要释放对象的时候，除了调用<code>[str1 release];</code>，那么还得调用<code>[str2 release]；</code></p><p>在ARC中声明<code>@property(nonatomic,copy) NSString *age;</code> 其set方法相当于MRC中的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="built_in">NSString</span> *)age &#123;</span><br><span class="line">    <span class="keyword">if</span> (_age != age) &#123;</span><br><span class="line">        [_age release];</span><br><span class="line">        _age = [age <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AutoRelease"><a href="#AutoRelease" class="headerlink" title="AutoRelease"></a>AutoRelease</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    Student *student = [[[Student alloc] init] autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  __AtAutoreleasePool() &#123; <span class="comment">// 构造函数</span></span><br><span class="line">      atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">  &#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123; <span class="comment">// 析构函数</span></span><br><span class="line">      objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    __AtAutoreleasePool __autoreleasepool; <span class="comment">// 创建一个结构体变量</span></span><br><span class="line">    Student *student = objc_msgSend(objc_msgSend(objc_msgSend(objc_getClass(<span class="string">&quot;Student&quot;</span>), sel_registerName(<span class="string">&quot;alloc&quot;</span>)), sel_registerName(<span class="string">&quot;init&quot;</span>)), sel_registerName(<span class="string">&quot;autorelease&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">    Student *student = objc_msgSend(objc_msgSend(objc_msgSend(objc_getClass(<span class="string">&quot;Student&quot;</span>), sel_registerName(<span class="string">&quot;alloc&quot;</span>)), sel_registerName(<span class="string">&quot;init&quot;</span>)), sel_registerName(<span class="string">&quot;autorelease&quot;</span>));</span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动释放池的主要底层数据结构是: <code>__AtAutoreleasePool</code>、<code>AutoreleasePoolPage</code></p><p>调用了<code>autorelease</code>的对象最终都是通过<code>AutoreleasePoolPage</code>对象来管的</p><p>源码分析<br>    - clang重写@autoreleasepool<br>    - objc4源码：NSobject.mm</p><h2 id="AutoreleasePoolPage的结构"><a href="#AutoreleasePoolPage的结构" class="headerlink" title="AutoreleasePoolPage的结构"></a>AutoreleasePoolPage的结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;</span><br><span class="line">    id *next;</span><br><span class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;</span><br><span class="line">    AutoreleasePoolPage *<span class="keyword">const</span> parent;</span><br><span class="line">    AutoreleasePoolPage *<span class="keyword">const</span> child;</span><br><span class="line">    <span class="keyword">uint32_t</span> depth;</span><br><span class="line">    <span class="keyword">uint32_t</span> hiwat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放<code>autorelease</code>对象的地址</p></li><li><p>所有的<code>AutoreleasePoolPage</code>对象通过双向链表的形式连接在一起</p></li><li><p>调用push方法会将一个POOL_BOUNDARY入栈，并且返回其存放的内存地址</p></li><li><p>调用pop方法时传入一个POOL_BOUNDARY的内存地址，会从最后一个入栈的对象开始发送release对象，直到遇到这个POOL_BOUNDARY</p></li><li><p><code>id *next</code>指向了下一个能存放<code>autorelease</code>对象地址的区域</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    id *dest;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(DebugPoolAllocation)) &#123;</span><br><span class="line">        <span class="comment">// Each autorelease pool starts on a new pool page.</span></span><br><span class="line">        dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span> *token)</span> </span>&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line">    <span class="keyword">if</span> (token == (<span class="keyword">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        <span class="comment">// Popping the top-level placeholder pool.</span></span><br><span class="line">        page = hotPage();</span><br><span class="line">        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">            <span class="comment">// Pool was never used. Clear the placeholder.</span></span><br><span class="line">            <span class="keyword">return</span> setHotPage(nil);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Pool was used. Pop its contents normally.</span></span><br><span class="line">        <span class="comment">// Pool pages remain allocated for re-use as usual.</span></span><br><span class="line">        page = coldPage();</span><br><span class="line">        token = page-&gt;begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        page = pageForPointer(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    <span class="keyword">if</span> (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            <span class="comment">// Start of coldest page may correctly not be POOL_BOUNDARY:</span></span><br><span class="line">            <span class="comment">// 1. top-level pool is popped, leaving the cold page in place</span></span><br><span class="line">            <span class="comment">// 2. an object is autoreleased with no pool</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Error. For bincompat purposes this is not </span></span><br><span class="line">            <span class="comment">// fatal in executables built with old SDKs.</span></span><br><span class="line">            <span class="keyword">return</span> badPop(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) &#123;</span><br><span class="line">        <span class="keyword">return</span> popPageDebug(token, page, stop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> popPage&lt;<span class="literal">false</span>&gt;(token, page, stop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Runloop和Autorelease"><a href="#Runloop和Autorelease" class="headerlink" title="Runloop和Autorelease"></a>Runloop和Autorelease</h3><ul><li>iOS在主线程的Runloop中注册了两个Observer</li><li>第1个Observer监听了<code>kCFRunLoopEntry</code>事件，会调用<code>objc_autoreleasePoolPush()</code></li><li>第2个Observer<ul><li>监听了<code>kCFRunLoopBeforeWaiting</code>会调用<code>objc_autoreleasePoolPop()</code>、<code>objc_autoreleasePoolPush()</code></li><li>监听了<code>kCFRunloopBeforeExit</code>事件，会调用<code>objc_autoreleasePoolPop()</code></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍iOS中内存管理的一些事情&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS --- 性能优化</title>
    <link href="https://www.arclin.cn/post/a2ff8280.html"/>
    <id>https://www.arclin.cn/post/a2ff8280.html</id>
    <published>2021-08-31T13:42:00.000Z</published>
    <updated>2022-07-12T16:51:57.242Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍iOS内常用的性能优化方案</p><span id="more"></span><h2 id="CPU和GPU"><a href="#CPU和GPU" class="headerlink" title="CPU和GPU"></a>CPU和GPU</h2><ul><li><p>在屏幕成像的过程中，CPU和GPU起着至关重要的作用</p><ul><li>CPU <ul><li>对象的创建和销毁，对象属性的调整、布局计算、文本的计算和排版、图片格式转换和解码、图像的绘制 </li></ul></li><li>GPU<ul><li>纹理的渲染</li></ul></li></ul></li><li><p>在iOS中是双缓冲机制，有前帧缓存、后帧缓存（）</p></li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU-&gt;计算-&gt;GPU-&gt;渲染-&gt;帧缓存-&gt;读取-&gt;视频控制器-&gt;显示-&gt;屏幕   </span><br></pre></td></tr></table></figure><h2 id="屏幕成像原理"><a href="#屏幕成像原理" class="headerlink" title="屏幕成像原理"></a>屏幕成像原理</h2><p>首先先发出一个垂直同步信号（VSync），然后再一行行发出水平同步信号（HSync），直到最后一行HSync发出之后，一帧就渲染完成，然后再次发出一个VSync，渲染下一帧。</p><img src="https://i.loli.net/2021/08/31/hWqVypmfbtga4eK.png" ><h2 id="卡顿"><a href="#卡顿" class="headerlink" title="卡顿"></a>卡顿</h2><h3 id="卡顿产生的原因"><a href="#卡顿产生的原因" class="headerlink" title="卡顿产生的原因"></a>卡顿产生的原因</h3><p><img src="https://i.loli.net/2021/08/31/ZTNhbeyRiq8UgmV.png" alt="1682758-5be402cc0ab5dc56.png"></p><ol><li>首先第一个VSync进入，CPU开始计算处理，然后交给GPU渲染，然后显示到屏幕上</li><li>然后第二个VSync进入，这时候CPU处理的时间比较长，交给GPU后， GPU还没处理完，第三个VSync就进来了，但是因为GPU没处理完。第二帧还不能显示，所以这时候直接取上一帧数据显示，造成第一帧长时间停留</li><li>然后过了一段时间GPU终于处理完了，但是第四个VSync还没来，所以就等，等到第四个VSync进来了，就开始拿刚才生成好的那一帧去显示，然后开始继续第三帧的计算</li></ol><ul><li>解决卡顿的主要思路<ul><li>尽可能减少CPU、GPU资源损耗</li></ul></li><li>按照60fps的刷新率，每个16ms就会有一次VSync信号 </li></ul><h3 id="卡顿检测"><a href="#卡顿检测" class="headerlink" title="卡顿检测"></a>卡顿检测</h3><ul><li>平时所说的__卡顿__主要是因为在主线程执行了比较耗时的操作</li><li>可以添加<code>Observer</code>到主线程<code>Runloop</code>中，通过监听<code>Runloop</code>状态切换的耗时，以达到监控卡顿的目的</li></ul><blockquote><p>参考：<a href="https://github.com/UIControl/LXDAppFluecyMonitor/blob/master/LXDAppFluecyMonitor/LXDAppFluecyMonitor/LXDAppFluecyMonitor.m">LXDAppFluecyMonitor</a></p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> lxdRunLoopObserverCallback(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> * info) &#123;</span><br><span class="line">     <span class="comment">/// 更新当前Runloop状态</span></span><br><span class="line">    SHAREDMONITOR.currentActivity = activity;</span><br><span class="line">    dispatch_semaphore_signal(SHAREDMONITOR.semphore);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startMonitoring &#123;</span><br><span class="line">    <span class="keyword">if</span> (_isMonitoring) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    _isMonitoring = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">CFRunLoopObserverContext</span> context = &#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/// 创建监听对象</span></span><br><span class="line">    _observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, &amp;lxdRunLoopObserverCallback, &amp;context);</span><br><span class="line">    <span class="comment">/// 在CommonModes添加监听者</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 子线程异步串行队列中添加死循环</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(lxd_event_monitor_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">while</span> (SHAREDMONITOR.isMonitoring) &#123;</span><br><span class="line">        <span class="comment">/// 如果当前状态是BeforeWaiting（即将进入休眠）的话</span></span><br><span class="line">            <span class="keyword">if</span> (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeWaiting) &#123;</span><br><span class="line">                __block <span class="built_in">BOOL</span> timeOut = <span class="literal">YES</span>;</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    timeOut = <span class="literal">NO</span>; <span class="comment">// 即将休眠的时候回到主线程超时状态改为NO</span></span><br><span class="line">                    dispatch_semaphore_signal(SHAREDMONITOR.eventSemphore); <span class="comment">//解锁</span></span><br><span class="line">                &#125;);</span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval: lxd_time_out_interval]; <span class="comment">// 子线程休眠一秒</span></span><br><span class="line">                <span class="keyword">if</span> (timeOut) &#123;</span><br><span class="line">                    [LXDBacktraceLogger lxd_logMain]; <span class="comment">// 打印堆栈</span></span><br><span class="line">                &#125;</span><br><span class="line">                dispatch_wait(SHAREDMONITOR.eventSemphore, DISPATCH_TIME_FOREVER); <span class="comment">// 加锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(lxd_fluecy_monitor_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">while</span> (SHAREDMONITOR.isMonitoring) &#123;</span><br><span class="line">            <span class="keyword">long</span> waitTime = dispatch_semaphore_wait(<span class="keyword">self</span>.semphore, dispatch_time(DISPATCH_TIME_NOW, lxd_wait_interval)); <span class="comment">// 等待200纳秒，看是否能拿到锁</span></span><br><span class="line">            <span class="keyword">if</span> (waitTime != LXD_SEMPHORE_SUCCESS) &#123; <span class="comment">// 拿不到锁</span></span><br><span class="line">                <span class="keyword">if</span> (!SHAREDMONITOR.observer) &#123;</span><br><span class="line">                    SHAREDMONITOR.timeOut = <span class="number">0</span>;</span><br><span class="line">                    [SHAREDMONITOR stopMonitoring];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/// Runloop 即将处理Source或者刚从休眠中唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeSources || SHAREDMONITOR.currentActivity == kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (++SHAREDMONITOR.timeOut &lt; <span class="number">5</span>) &#123; <span class="comment">// 超时次数+1，然后如果超时次数大于5次就打印堆栈</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    [LXDBacktraceLogger lxd_logMain];</span><br><span class="line">                    [<span class="built_in">NSThread</span> sleepForTimeInterval: lxd_restore_interval];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            SHAREDMONITOR.timeOut = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="卡顿优化-CPU"><a href="#卡顿优化-CPU" class="headerlink" title="卡顿优化 - CPU"></a>卡顿优化 - CPU</h3><ul><li>尽量使用轻量级的对象，比如用不到事件处理的地方，可以考虑使用<code>CALayer</code>（只是拿来渲染）取代<code>UIView</code>（渲染+处理点击事件等）</li><li>不要频繁地调用<code>UIView</code>的相关属性，比如<code>frame</code>、<code>bounds</code>、<code>transform</code>等属性，尽量减少不必要的修改</li><li>尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</li><li>Autolayout会比直接设置frame消耗更多的CPU资源</li><li>图片的Size最好跟UIImageView的size保持一致</li><li>控制一下线程的最大并发数量</li><li>尽量把耗时操作放到子线程<ul><li>文本处理（尺寸计算、绘制）</li><li>图片处理（解码、绘制）</li></ul></li></ul><p>图片子线程解码举例</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)renderImage &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">/// get CGImage</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> cgImage = [<span class="built_in">UIImage</span> imageWithData:[<span class="built_in">NSData</span> dataWithContentsOfURL:xxx]].CGImage;</span><br><span class="line">        </span><br><span class="line">        size_t width = <span class="built_in">CGImageGetWidth</span>(cgImage);</span><br><span class="line">        size_t height = <span class="built_in">CGImageGetHeight</span>(cgImage);</span><br><span class="line">        <span class="keyword">if</span> (width == <span class="number">0</span> || height == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGImageAlphaInfo</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(cgImage);</span><br><span class="line">        <span class="built_in">BOOL</span> hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</span><br><span class="line">                          alphaInfo == kCGImageAlphaNoneSkipFirst ||</span><br><span class="line">                          alphaInfo == kCGImageAlphaNoneSkipLast);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, <span class="built_in">CGColorSpaceCreateDeviceRGB</span>(), bitmapInfo);</span><br><span class="line">        <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Apply transform</span></span><br><span class="line">        <span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">        <span class="built_in">CGContextConcatCTM</span>(context, transform);</span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), cgImage); <span class="comment">// The rect is bounding box of CGImage, don&#x27;t swap width &amp; height</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> newImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">        <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// back to the main thread</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.imageView.image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:newImageRef];</span><br><span class="line">            <span class="built_in">CGImageRelease</span>(newImageRef);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="卡顿优化-GPU"><a href="#卡顿优化-GPU" class="headerlink" title="卡顿优化 - GPU"></a>卡顿优化 - GPU</h3><ul><li>尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</li><li>GPU能处理的最大纹理尺寸是<strong>4096*4096</strong>，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸</li><li>尽量减少视图数量和层次</li><li>减少透明的视图（alpha &lt; 1），不透明的就设置<code>opaque</code>为<code>YES</code></li><li>尽量避免出现离屏渲染</li></ul><h4 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h4><ul><li><p>在OpenGL中，GPU有2种渲染方式</p><ul><li>On-Screen Rendering：当前离屏渲染，在当前用于显示屏幕缓冲区进行渲染操作</li><li>Off-Screen Rendering: 离屏渲染，在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作 </li></ul></li><li><p>离屏渲染消耗性能的原因</p><ul><li>需要创建新的缓冲区</li><li>离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）;等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕上。</li></ul></li><li><p>哪些操作会触发离屏渲染</p><ul><li>光栅化，<code>layer.shouldRasterize = YES</code></li><li>遮罩 <code>layer.mask</code></li><li>圆角，同时设置 <code>layouer.maskToBounds = YES</code>, <code>layer.cornerRadius</code>大于0<ul><li>考虑通过<code>CoreGraphics</code>绘制裁剪圆角，或者叫美工提供圆角图片</li></ul></li><li>阴影，<code>layer.shadowXXX</code><ul><li>如果设置了<code>layer.shadowPath</code>就不会产生离屏渲染</li></ul></li></ul></li></ul><h2 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h2><h3 id="主要来源"><a href="#主要来源" class="headerlink" title="主要来源"></a>主要来源</h3><ul><li>CPU处理，Processing</li><li>网络，Networking</li><li>定位，Location</li><li>图像，Graphics</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li><p>尽可能降低CPU、GPU功耗</p></li><li><p>少用定时器</p></li><li><p>优化I/O操作</p><ul><li>尽量不要频繁写入小数据，最好批量一次性写入 </li><li>读写大量重要数据时，考虑使用<code>dispatch_io</code>，其提供了基于GCD的异步操作文件的I/O的API.用<code>dispatch_io</code>系统会优化磁盘访问</li><li>数据量比较大的，建议使用数据库(SQLite、CoreData)</li></ul></li><li><p>网络优化</p><ul><li>减少、压缩网络数据</li><li>如果多次请求结果是相同的，尽量使用缓存</li><li>使用断点续传，否则网络不稳定时可能多次传输相同的内容</li><li>网络不可用时，不要尝试执行网络请求</li><li>让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间</li><li>批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载，如果下载广告，一次性多下载一些，然后再慢慢展示，如果下载电子邮件，一次下载多封，不要一封一封地下载</li></ul></li><li><p>定位优化</p><ul><li>如果只是需要快速确定用户当前位置，最好用<code>CLLocationManager</code>的<code>requestLocation</code>方法，定位完成后，会自动让定位硬件断电</li><li>如果不是导航应用， 尽量不要实时更新位置，定位关闭就关掉定位服务</li><li>尽量降低定位精度，比如尽量不要使用精度最高的<code>kCLLocationAccuracyBest</code></li><li>需要后台定位时，尽量设置<code>pausesLocationUpdatesAutomatically</code>为YES，如果用户不太可能移动的时候，系统会自动暂停位置更新</li><li>尽量不要使用<code>startMonitoringSignificantLocationChanges</code>，优先考虑<code>startMonitoringForRegion:</code></li></ul></li><li><p>硬件检测优化</p><ul><li>用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件。</li></ul></li></ul><h2 id="App启动优化"><a href="#App启动优化" class="headerlink" title="App启动优化"></a>App启动优化</h2><ul><li><p>App的启动可以分为2种</p><ul><li>冷启动（Code Launch）：从零开始启动App</li><li>热启动（Warm Launch）：App已经在内存中，在后台存活着，再次点击图标</li></ul></li><li><p>App启动时间的优化，主要是针对冷启动进行优化</p></li><li><p>通过添加环境变量可以打印出App的启动时间分析（Edit Scheme -&gt; Run -&gt; Arguments）</p><ul><li><code>DYLD_PRINT_STATISTICS</code>设置为1 或者 <code>DYLD_PRINT_STATISTICS_DETAILS</code> （更加详细 ）</li></ul></li><li><p>App的冷启动可以概括为3大阶段</p><ul><li><p>dyld</p></li><li><p>runtime</p></li><li><p>main</p><img src="https://i.loli.net/2021/08/31/ldg1cjZCUPe5Gk6.png" ></li><li><p>dyld（dynamic link editor），Apple的动态链接器，可以用来装在Mach-O文件（可执行文件、动态库等 ）</p></li><li><p>启动App时，dyld所做的事情有</p><ul><li>装载App的可执行文件，同时会递归加载所有依赖的动态库</li><li>当dyld把可执行文件、动态库都装载到内存完毕后，会通知Runtime进行下一步的处理</li></ul></li><li><p>启动App时，runtime所做的事情有</p><ul><li>调用<code>map_images</code>进行可执行文件内容的解析和处理</li><li>在<code>load_images</code>中调用<code>call_load_methods</code>,调用所有<code>Class</code>和<code>Category</code>的<code>+load</code>方法</li><li>进行各种objc结构的初始化（注册Objc类，初始化类对象等等）</li><li>调用C++静态初始化器和<code>__attribute((constructor))</code>修饰的函数</li></ul></li><li><p>到此为止，可执行文件和动态库中所有的符号（Class、Protocol、Selector、IMP、…）都已经按格式成功加载到内存中，被<code>runtime</code>所管理</p></li><li><p>总结</p><ul><li>App的启动由dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库</li><li>并由runtime负责加载成objc定义的结构</li><li>所有初始化工作结束后，dyld就会调用main函数</li><li>接下来就是<code>UIApplicationMain</code>函数，AppDelegate的<code>application:didFinishLaunchingWithOptions:</code>方法</li></ul></li></ul></li></ul><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>按照不同的阶段<ul><li>dyld <ul><li>减少动态库，合并一些动态库（定期清理不必要的动态库）</li><li>减少Objc类，分类的数量，减少selector的数量（定期清理不必要的类，分类）</li><li>减少C++虚函数数量</li><li>Swift尽量使用struct</li></ul></li><li>runtime<ul><li>用<code>+initialize</code>和<code>dispatch_once</code>取代所有的<code>__attribute((constructor))</code>、C++静态构造器 、ObjC的<code>+load</code></li></ul></li><li>main<ul><li>在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在<code>finishLaunch</code>方法中</li><li>按需加载 </li></ul></li></ul></li></ul><h2 id="安装包瘦身"><a href="#安装包瘦身" class="headerlink" title="安装包瘦身"></a>安装包瘦身</h2><ul><li><p>安装包（IPA）主要由可执行文件、资源组成</p></li><li><p>资源（图片、视频、音频等）</p><ul><li>采取无损压缩</li><li>去除没有用到的资源(github :LSUnusedResources）</li></ul></li><li><p>可执行文件瘦身</p><ul><li>编译器优化 <ul><li>Strip Linked Product 、 Make Strings Read-Only、 Symbols Hidden By Defaults设置为YES</li><li>去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions 设置为NO，Other C Flags  添加 -fno-exceptions</li></ul></li><li>利用AppCode(<a href="https://www.jetbrains.com/objc">https://www.jetbrains.com/objc</a>)检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code</li><li>编写LLVM插件检测出重复代码，未被调用的代码</li><li>生成Link Map文件，可以查看可执行文件的具体组成（在Build Setting-&gt;Write Link Map File 改为true，就可以在Path to link map file 看到这个文件）</li><li>可以借助第三方工具解析LinkMap文件：<a href="https://github.com/huanxsd/LinkMap">https://github.com/huanxsd/LinkMap</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍iOS内常用的性能优化方案&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>最近看了一本书...</title>
    <link href="https://www.arclin.cn/post/a4ffdee.html"/>
    <id>https://www.arclin.cn/post/a4ffdee.html</id>
    <published>2021-08-29T14:59:00.000Z</published>
    <updated>2022-07-12T16:51:57.245Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了一本 《代码整洁之道》</p><p>基本跟我们平时的编码代码规范有点类似吧。里面的一些设计思想是挺好的。这里记录一下一些个人感觉好像挺有用的点。</p><blockquote><p>部分内容可能存在争议，请不要在意，以自己团队规范为准。</p></blockquote><span id="more"></span><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>用命名常量替代魔术数（泛指任何不能自我描述的符号）</p><p>命名采用描述性名称，确认名称具有描述性</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>封装条件要抽离解释了条件意图函数，比如 shouldBeDelete(timer) 要优于  (timer.hasExpired &amp;&amp; !timer.isRecurrent())</p><p>避免否定条件  if（shouldDo） 要好于 if (!shouldNotDo)</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>为较大作用范围选用较长名称</p><p>名称应该说明函数、变量或类的一切信息，不要用名称掩蔽副作用。</p><p>每个函数只做一件事情</p><p>函数参数应该越少越好</p><p>不要把输入的参数拿来输出</p><p>布尔值参数宣告函数做了不止一件事情，违反了单一职责原则，应该消灭掉</p><p>用布尔、枚举、整数等参数用于判断流程来决定函数行为是不好的，使用多个函数，通常优于向单个函数传递某些代码来选择函数行为</p><p>使用异常替代返回错误码</p><p>抽离Try/Catch代码块</p><p>把重复代码抽离出来</p><p>通常应该倾向于选用非静态方法。如果的确需要静态函数，确保没机会打算让他有多态行为。</p><p>函数名称应该表达其行为</p><p>如果多个函数的调用有时序性，比如必须先调用A才能调用B，要显式声明时序性，比如调用B函数的时候把A函数作为参数传进去，这样子就保证别人不会误把B函数放在A函数前调用</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>顶部给出高层次概念和算法。细节应该往下渐次展开，直至找到原文件中最底层的函数和细节</p><p>如果某个函数调用了另外一个，就应该把它们放在一起，而且调用者应该尽可能放在被调用者上面，</p><p>概念相关的代码应该放到一起，相关性越强，彼此之间的距离就该越短</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数<br>面向对象代码便于在不改动既有函数的前提下添加新类</p><p>过程式代码难以添加新数据结构，因为必须修改所有函数。<br>面向对象代码难以添加新函数，因为必须修改所有类。</p><p>迪米特法则：模块不应了解它所操作对象的内部情形。<br>隐藏结构：<code>let a = b.c().e().f()</code><br>拆分成</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">c</span> = b.c()</span><br><span class="line"><span class="keyword">let</span> <span class="attr">e</span> = c.e()</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span> = e.f()</span><br></pre></td></tr></table></figure><p>应该改成<br><code>let a = b.func()</code></p><p>在方法中，不应该调用其他对象的方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span>(<span class="keyword">let</span> obj)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> item <span class="operator">=</span> obj.func()</span><br><span class="line">    item.func() <span class="comment">// 不可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类C的方法f只能调用以下对象的方法</p><ul><li>C</li><li>由f创建的对象</li><li>作为参数传递给f的对象</li><li>由C的实体变量持有的对象</li></ul><p>用多态替代if/else 或 switch/case</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>不要使用错误码，用try-catch代替</p><p>不要返回null值，用空对象替代，或者抛出异常</p><p>不要传入null值作为参数，除非API要求你这么做</p><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p>使用泛型限制输入</p><p>单元测试</p><p>单元测试应当简单、精悍、足具表达力。</p><p>测试代码和生产代码一样重要</p><p>TDD三定律：</p><ol><li>在编写不能通过的单元测试前，不可编写生产代码</li><li>只可编写刚好无法通过的单元测试，不能编译也不算通过</li><li>只可编写刚好足以通过当前失败测试的生产代码</li></ol><p>每一个测试一个断言</p><ul><li>每一个测试一个概念</li><li>一个概念可以多个断言</li></ul><p>简洁的测试应该遵循5条规则<br>（FIRST: FAST、Independent、Repeatable、Self-Validating、Timely）</p><ol><li>快速：测试应该够快</li><li>独立：测试应该互相独立，某个测试不应为下一个测试设定条件</li><li>可重复：测试应当可在任何环境中重复通过</li><li>自足验证：测试应该有布尔值输出</li><li>及时：测试应及时编写</li></ol><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类应该短小，遵循单一职责原则（类或模块应有且只有一条加以修改的理由）</p><p>类应该只有少量实体变量</p><p>当类丧失了内聚性，就拆分它</p><p>类的方法只应对其所属类中的变量和函数感兴趣，不应该垂青其他类中的变量和函数</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近看了一本 《代码整洁之道》&lt;/p&gt;
&lt;p&gt;基本跟我们平时的编码代码规范有点类似吧。里面的一些设计思想是挺好的。这里记录一下一些个人感觉好像挺有用的点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;部分内容可能存在争议，请不要在意，以自己团队规范为准。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://www.arclin.cn/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="架构" scheme="https://www.arclin.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="技巧" scheme="https://www.arclin.cn/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- 多线程</title>
    <link href="https://www.arclin.cn/post/f4b0e2bd.html"/>
    <id>https://www.arclin.cn/post/f4b0e2bd.html</id>
    <published>2021-08-29T13:49:00.000Z</published>
    <updated>2022-07-12T16:51:57.241Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述iOS中多线程的使用及其原理</p><span id="more"></span><h2 id="常见的多线程方案"><a href="#常见的多线程方案" class="headerlink" title="常见的多线程方案"></a>常见的多线程方案</h2><table><thead><tr><th align="center">技术方案</th><th align="left">简介</th><th align="center">语言</th><th align="center">线程生命周期</th><th align="center">使用频率</th></tr></thead><tbody><tr><td align="center">pthread</td><td align="left"><ul><li>一套通用的多线程API</li><li>适用于Unix\Linux\Windows等系统</li><li>跨平台\可移植</li><li>使用难度大</li></ul></td><td align="center">C</td><td align="center">程序员管理</td><td align="center">几乎不用</td></tr><tr><td align="center">NSThread</td><td align="left"><ul><li>使用更加面向对象</li><li>简单易用，可直接操作线程对象</li></ul></td><td align="center">OC</td><td align="center">程序员管理</td><td align="center">偶尔使用</td></tr><tr><td align="center">GCD</td><td align="left"><ul><li>旨在替代NSThread等线程技术</li><li>充分利用设备的多核</li></ul></td><td align="center">C</td><td align="center">自动管理</td><td align="center">经常使用</td></tr><tr><td align="center">NSOperation</td><td align="left"><ul><li>基于GCD</li><li>比GCD多了一些简单实用的功能</li><li>使用更加面向对象</li></ul></td><td align="center">OC</td><td align="center">自动管理</td><td align="center">经常使用</td></tr></tbody></table><h3 id="一些多线程术语"><a href="#一些多线程术语" class="headerlink" title="一些多线程术语"></a>一些多线程术语</h3><ul><li>同步、异步：能不能开启新的线程<ul><li>同步：在当前线程中执行任务，不具备开启新线程的能力</li><li>异步：在新的线程中执行任务，具备开启新线程的能力</li></ul></li><li>并发、串行：任务的执行方式<ul><li>并发：多个任务并发（同时）执行</li><li>串行：一个任务执行完毕后，再执行下一个任务</li></ul></li></ul><h3 id="各种队列的执行效果"><a href="#各种队列的执行效果" class="headerlink" title="各种队列的执行效果"></a>各种队列的执行效果</h3><table><thead><tr><th></th><th>并发队列</th><th>手动创建的串行队列</th><th>主队列</th></tr></thead><tbody><tr><td>同步（sync）</td><td>没有开启新线程<br>串行执行任务</td><td>没有开启新线程<br>串行执行任务</td><td>没有开启新线程<br>串行执行任务</td></tr><tr><td>异步（async）</td><td>有开启新线程<br>并发执行任务</td><td>有开启新线程<br>串行执行任务</td><td>没有开启新线程<br>串行执行任务</td></tr></tbody></table><ul><li><p>使用<code>sync</code>函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）</p></li><li><p>死锁问题主要产生在串行队列中。由于串行队列的FIFO（First in first out）性质，如果串行队列中有同步函数，那么同步函数要等待串行队列执行完才能执行，又因为同步函数的性质是在当前线程立马执行函数体，所以同步函数后面的代码要等待同步函数执行完才能执行，在这种情况下就会出现死锁</p></li><li><p>因为并发队列允许同时执行多个任务，所以不存在等待队列中其他人完成后才能开始执行的情况，所以一般情况下并发队列不会产生环路等待死锁</p></li></ul><h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><h3 id="GCD的常用函数"><a href="#GCD的常用函数" class="headerlink" title="GCD的常用函数"></a>GCD的常用函数</h3><ul><li>用同步的方式执行任务</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// queue 队列</span></span><br><span class="line"><span class="comment">/// block 任务</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(<span class="built_in">dispatch_queue_t</span> queue,dispatch_block_t block);</span><br></pre></td></tr></table></figure><ul><li>用异步的方式执行任务</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// queue 队列</span></span><br><span class="line"><span class="comment">/// block 任务</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(<span class="built_in">dispatch_queue_t</span> queue,dispatch_block_t block);</span><br></pre></td></tr></table></figure><h3 id="GCD的队列"><a href="#GCD的队列" class="headerlink" title="GCD的队列"></a>GCD的队列</h3><p>GCD的队列可以分为2大类型</p><ul><li><p>并发队列（Concurrent Dispatch Queue）</p><ul><li>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）</li><li>并发功能只有在异步（dispatch_async）函数下才有效</li></ul></li><li><p>串行队列（Serial Dispatch Queue）</p><ul><li>让任务一个接着一个执行（一个任务执行完毕后，在执行下一个任务）</li></ul></li></ul><h3 id="GCD的队列组"><a href="#GCD的队列组" class="headerlink" title="GCD的队列组"></a>GCD的队列组</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建队列组</span></span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;my_queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加异步任务</span></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;任务1-%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;任务2-%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等前面的任务执行完毕后，会自动执行这个任务</span></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;任务3-%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="多线程的安全隐患"><a href="#多线程的安全隐患" class="headerlink" title="多线程的安全隐患"></a>多线程的安全隐患</h2><ul><li>资源共享<ul><li>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源</li><li>比如多个线程访问同一个对象，同一个变量，同一个文件</li></ul></li><li>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题</li></ul><p>解决方案：使用线程同步技术（同步，就是协同步调，按预定的先后持续进行）</p><ul><li>常见的线程同步技术是：加锁，常见线程同步方案如下<ul><li>OSSpinLock</li><li>os_unfair_lock</li><li>pthread_mutex</li><li>dispatch_semaphore</li><li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSRecursiveLock</li><li>NSCondition</li><li>NSConditionLock</li><li>@synchronized</li></ul></li></ul><h3 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h3><p>线程同步的最直接的方案就是串行队列，让多条线程按顺序执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> queue = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;queue&quot;</span>,DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue,^&#123;</span><br><span class="line">    xxxx</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue,^&#123;</span><br><span class="line">    xxxx</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><blockquote><p>这个锁在iOS 10之后被废弃了</p></blockquote><p>自旋锁，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源</p><blockquote><p>忙等：一边等待一边忙着做事情，相当于while(1){xxx}。自旋：自己一直在那里旋转</p></blockquote><blockquote><p>需要导入头文件<code>&lt;libkern/OSAtomic.h&gt;</code></p></blockquote><p>初始化</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">OSSpinLock lock</span> = OS_SPINLOCK_INIT;</span><br></pre></td></tr></table></figure><p>加锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">OSSpinLockLock(&amp;<span class="params">_lock</span>)</span>;</span><br></pre></td></tr></table></figure><p>尝试加锁：如果需要等待就返回false，不加锁；如果不需要等待就返回true，加锁。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Bool</span> <span class="variable"><span class="class">result</span></span> = <span class="function"><span class="title">OSSpinLockTry</span>(&amp;<span class="variable">_lock</span>)</span></span><br></pre></td></tr></table></figure><p>解锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">OSSpinLockUnlock(&amp;<span class="params">_lock</span>)</span>;</span><br></pre></td></tr></table></figure><p>自旋锁现在已经不再安全，可能会出现优先级反转问题</p><p>如果等待锁的优先级线程较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁</p><h3 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h3><ul><li><code>os_unfair_lock</code>用于取代不安全的<code>OSSpinLock</code>，从iOS10开始才支持</li><li>从底层调用看，等待<code>os_unfair_lock</code>锁的线程会处于休眠状态，并非忙等</li><li>需要导入头文件<code>&lt;os/lock.h&gt;</code></li></ul><p>初始化</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">os_unfair_lock lock</span> = OS_UNFAIR_LOCK_INIT;</span><br></pre></td></tr></table></figure><p>加锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os_unfair_lock_lock(&amp;lock);</span><br></pre></td></tr></table></figure><p>解锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os_unfair_lock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure><h3 id="phread-mutex"><a href="#phread-mutex" class="headerlink" title="phread_mutex"></a>phread_mutex</h3><ul><li><code>mutex</code>叫做互斥锁，等待锁的线程会处于休眠状态</li><li>需要导入头文件<code>&lt;pthread.h&gt;</code></li></ul><p>初始化方法1</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pthread_mutex_t mutex</span> = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><p>初始化方法2</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread<span class="constructor">_mutexattr_init(&amp;<span class="params">attr</span>)</span>;</span><br><span class="line">pthread<span class="constructor">_mutexattr_settype(&amp;<span class="params">attr</span>, PTHREAD_MUTEX_DEFAULT)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这里的第二个参数如果传NULL的话表示使用默认属性</span></span><br><span class="line">pthread<span class="constructor">_mutex_init(&amp;<span class="params">_mutex</span>, &amp;<span class="params">attr</span>)</span>;</span><br><span class="line"></span><br><span class="line">pthread<span class="constructor">_mutexattr_destory(&amp;<span class="params">attr</span>)</span>;</span><br></pre></td></tr></table></figure><p>尝试加锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_mutex_trylock(&amp;<span class="params">mutex</span>)</span>;</span><br></pre></td></tr></table></figure><p>加锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_mutex_lock(&amp;<span class="params">mutex</span>)</span>;</span><br></pre></td></tr></table></figure><p>解锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_mutex_unlock(&amp;<span class="params">mutex</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h4><p>锁的属性可以改为递归锁，即允许<strong>同一个线程</strong>对一把锁进行重复加锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_mutexattr_settype(&amp;<span class="params">attr</span>, PTHREAD_MUTEX_RECURSIVE)</span>;</span><br></pre></td></tr></table></figure><h4 id="条件锁"><a href="#条件锁" class="headerlink" title="条件锁"></a>条件锁</h4><p>初始化条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_t <span class="keyword">condition</span>;</span><br><span class="line">pthread_cond_init(<span class="operator">&amp;</span><span class="keyword">condition</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><p>等待条件（进入休眠，放开mutex锁；被唤醒后，会再次对mutex加锁）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_cond_wait(&amp;<span class="params">condition</span>, &amp;<span class="params">mutex</span>)</span>;</span><br></pre></td></tr></table></figure><p>激活<strong>一个</strong>等待该条件的线程（如果这时候有多个在等待，那么也只会激活最先等待的那个）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_cond_signal(&amp;<span class="params">condition</span>)</span>;</span><br></pre></td></tr></table></figure><p>激活所有等待该条件的线程</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_cond_brodcast(&amp;<span class="params">condition</span>)</span>;</span><br></pre></td></tr></table></figure><p>销毁资源</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_mutex_destory(&amp;<span class="params">mutex</span>)</span>;</span><br><span class="line">pthread<span class="constructor">_cond_destory(&amp;<span class="params">condition</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h3><ul><li><code>NSLock</code>是对<code>mutex</code>普通锁的封装，即<code>pthread_mutex_init(&amp;_mutex, NULL);</code></li></ul><p>初始化</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLock</span> *lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br></pre></td></tr></table></figure><p>加锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)lock;</span><br></pre></td></tr></table></figure><p>尝试加锁(调用的瞬间立马去判断当前能不能加锁，能加就加，然后返回YES，然后继续往下走，如果不能加就返回NO，然后继续往下走)</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)tryLock;</span><br></pre></td></tr></table></figure><p>等待锁（调用的时候先阻塞，如果现在能加锁，就返回YES，加锁成功，继续往下走；如果不能加锁，就阻塞，如果在limit之前，锁被放开了，那么就加锁，返回YES，代码继续往下走；如果直到limit到了，锁还没被放开，那么就返回NO，加锁失败，代码继续往下走）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br></pre></td></tr></table></figure><p>解锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)unlock;</span><br></pre></td></tr></table></figure><h3 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a>NSRecursiveLock</h3><ul><li><code>NSRecurseiveLock</code>也是对<code>mutex</code>递归锁的封装，API跟<code>NSLock</code>基本一致</li></ul><h3 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h3><ul><li><code>NSCondition</code>也是对<code>mutex</code>和<code>cont</code>的封装</li></ul><p>等待锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)wait;</span><br><span class="line">- (<span class="keyword">void</span>)waitUtilDate:(<span class="built_in">NSDate</span> *)limit;</span><br></pre></td></tr></table></figure><p>激活锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)signal; <span class="comment">// 激活单个</span></span><br><span class="line">- (<span class="keyword">void</span>)boardcast; <span class="comment">// 激活多个</span></span><br></pre></td></tr></table></figure><h3 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h3><ul><li><code>NSConditionLock</code>是对<code>NSCondition</code>的进一步封装，可以设置具体的条件值</li></ul><p>初始化设定一个条件值，如果直接<code>init</code>的话那么默认值是0</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instance<span class="keyword">type</span>)initWithCondition:(<span class="type">NSInteger</span>)condition;</span><br></pre></td></tr></table></figure><p>加锁并且设定条件值为<code>condition</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLockWhenCondition:(<span class="built_in">NSInteger</span>)condition; <span class="comment">// 尝试加锁</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition beforeDate:(<span class="built_in">NSDate</span> *)limit; <span class="comment">// 在指定时间到达之前等待条件成立加锁</span></span><br></pre></td></tr></table></figure><p>如果直接使用<code>lock</code>方法，那么会无视条件值，直接加锁或者等待加锁</p><p>解当前的锁并且设置条件值为<code>condition</code>，如果这时候有条件值为<code>condition</code>的锁在加着，那么就会释放</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)unlockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br></pre></td></tr></table></figure><p>如果直接使用<code>unlock</code>方法，那么那些带条件的<code>lockWhenCondition</code>不会解锁</p><h3 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h3><ul><li><code>semaphore</code>叫做信号量</li><li>信号量的初始值，可以用来控制线程并发访问的最大数量</li></ul><p>初始化，传入一个允许的最大并发线程数<code>count</code></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dispatch_sempathore semaphore</span> = dispatch_semaphore_create(count);</span><br></pre></td></tr></table></figure><p>如果信号量的值&lt;=0，当前线程就会进入休眠等待（直到信号量的值&gt;0）<br>如果信号量的值&gt;0，就减1，然后往下执行后面的代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch<span class="constructor">_semaphore_wait(<span class="params">semaphore</span>, DISPATCH_TIME_FOREVER)</span>;</span><br></pre></td></tr></table></figure><p>让信号量的值加1</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch<span class="constructor">_semaphore_signal(<span class="params">semaphore</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><ul><li><code>@synchronized</code>是对<code>mutex</code>递归锁的封装</li></ul><p>传入对象即可，用于标记是不是同个锁，一个对象标记一把锁 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@synchronized(xxx)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程同步方案性能比较"><a href="#线程同步方案性能比较" class="headerlink" title="线程同步方案性能比较"></a>线程同步方案性能比较</h3><ul><li>性能从高到低排序<ul><li>os_unfair_lock</li><li>OSSpinLock</li><li>dispatch_semaphore</li><li>pthread_mutex</li><li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSCondition</li><li>pthread_mutex(recursive)</li><li>NSRecursiveLock</li><li>NSConditionLock</li><li>@synchronized</li></ul></li></ul><h2 id="自旋锁、互斥锁比较"><a href="#自旋锁、互斥锁比较" class="headerlink" title="自旋锁、互斥锁比较"></a>自旋锁、互斥锁比较</h2><blockquote><p>iOS10之后已经不推荐使用自旋锁了</p></blockquote><ul><li>什么情况使用自旋锁比较划算？<ul><li>预计线程等待锁的时间很短</li><li>加锁的代码（临界区）经常被调用，但竞争情况很少发生</li><li>CPU资源不紧张</li><li>多核处理器</li></ul></li><li>什么情况使用互斥锁比较划算？<ul><li>预计线程等待锁的时间较长</li><li>单核处理器</li><li>临界区有IO操作（因为比较占用CPU资源）</li><li>临界区代码复杂或者循环量大</li></ul></li></ul><h2 id="读写安全"><a href="#读写安全" class="headerlink" title="读写安全"></a>读写安全</h2><h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h3><p><code>nonatomic</code>和<code>atomic</code> ：给属性加上<code>atomic</code>修饰，可以保证属性的<code>setter</code>和<code>getter</code>都是原子性操作，也就是保证<code>setter</code>和<code>getter</code>内部是线程同步的</p><p>参照runtime源码中 <code>objc-accessors.mm</code>的<code>objc_getProperty</code>和<code>reallySetProperty</code>方法，分别是get方法和set方法的内部实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_getProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, ptrdiff_t offset, <span class="built_in">BOOL</span> atomic) &#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retain release world</span></span><br><span class="line">    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);</span><br><span class="line">    <span class="keyword">if</span> (!atomic) <span class="keyword">return</span> *slot;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是atomic的时候，会加上锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Atomic retain release world</span></span><br><span class="line">    spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();</span><br><span class="line">    <span class="keyword">id</span> value = objc_retain(*slot);</span><br><span class="line">    slotlock.unlock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span></span><br><span class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> reallySetProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> newValue, ptrdiff_t offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> <span class="keyword">copy</span>, <span class="keyword">bool</span> mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        object_setClass(<span class="keyword">self</span>, newValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> oldValue;</span><br><span class="line">    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">copy</span>) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/// 这里可以看出如果是atomic的时候，是会加上锁的</span></span><br><span class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>atmoic</code>是不能保证使用属性的过程中是线程安全的，即虽然他的setter和getter是线程安全的，但是用这个属性去调用其他方法的时候依旧不一定属性安全，比如<code>[self.array addObject:xxx]</code>，这里只能保证取出array属性的时候线程安全，但是添加对象进去的时候就有可能出现线程同步问题</p><h3 id="读写安全方案"><a href="#读写安全方案" class="headerlink" title="读写安全方案"></a>读写安全方案</h3><h4 id="多读单写"><a href="#多读单写" class="headerlink" title="多读单写"></a>多读单写</h4><p>需求</p><ul><li>同一时间，只能有1条线程进行写的操作</li><li>同一时间，允许有多条线程进行读的操作</li><li>同一时间，不允许既有写的操作，又有读的操作</li></ul><p>解决方案</p><ul><li>pthread_rwlock：读写锁</li><li>dispatch_barrier_async：异步栅栏调用</li></ul><h4 id="pthread-rwlock"><a href="#pthread-rwlock" class="headerlink" title="pthread_rwlock"></a>pthread_rwlock</h4><ul><li>等待锁的线程会进入休眠</li><li>需要引入头文件&lt;pthread.h&gt;</li></ul><p>初始化锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_t lock;</span><br><span class="line">pthread_rwlock_init(&amp;lock,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>读-加锁/尝试加锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_rdlock(&amp;lock);</span><br><span class="line">pthread_rwlock_tryrdlock(&amp;lock);</span><br></pre></td></tr></table></figure><p>写-加锁/尝试加锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_wrlock(&amp;lock);</span><br><span class="line">pthread_rwlock_trywrlock(&amp;lock);</span><br></pre></td></tr></table></figure><p>解锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure><p>销毁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_destory(&amp;lock);</span><br></pre></td></tr></table></figure><h4 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h4><ul><li>这个函数传入的并发队列必须是自己通过<code>dispatch_queue_create</code>创建的</li><li>如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于<code>dispatch_async</code>函数的效果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化队列</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;rw_queue&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 读</span><br><span class="line">dispatch_async(queue,^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写</span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>子线程中，<code>performSelector:withObject:afterDelay:</code>不起作用的原因 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> afterDelay:<span class="number">.0</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;3&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>performSelector:withObject:afterDelay:</code> 的本质是往Runloop中添加定时器</li><li>子线程中默认没有启动<code>Runloop</code></li><li>补充代码启动Runloop即可  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSRunloop</span> currentRunloop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunloopMode</span>];</span><br><span class="line">[[<span class="built_in">NSRunloop</span> currentRunloop] runMode:<span class="built_in">NSDefaultRunloopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFeature]];</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要简述iOS中多线程的使用及其原理&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Swift 5.5 async与 await</title>
    <link href="https://www.arclin.cn/post/75996dec.html"/>
    <id>https://www.arclin.cn/post/75996dec.html</id>
    <published>2021-08-23T14:55:00.000Z</published>
    <updated>2022-07-12T16:51:57.239Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述Swift 5.5新特性 async与await的常用方式</p><span id="more"></span><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>首先我们来做一个简单的下载图片的任务</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Download</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">image</span>(<span class="params">url</span>: <span class="type">URL</span>, <span class="params">completeHandler</span>: <span class="keyword">@escaping</span> (<span class="type">UIImage</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> task <span class="operator">=</span> <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error &#123;</span><br><span class="line">                <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                    completeHandler(<span class="literal">nil</span>,error)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> data <span class="operator">=</span> data, <span class="keyword">let</span> httpResponse <span class="operator">=</span> response <span class="keyword">as?</span> <span class="type">HTTPURLResponse</span>, httpResponse.statusCode <span class="operator">==</span> <span class="number">200</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">UIImage</span>(data: data)</span><br><span class="line">                <span class="keyword">if</span> image <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                        completeHandler(image, <span class="literal">nil</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                        completeHandler(<span class="literal">nil</span>, <span class="type">NSError</span>(domain: <span class="string">&quot;org.swift&quot;</span>, code: <span class="operator">-</span><span class="number">2</span>))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                    completeHandler(<span class="literal">nil</span>, <span class="type">NSError</span>(domain: <span class="string">&quot;org.swift&quot;</span>, code: <span class="operator">-</span><span class="number">1</span>))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        task.resume()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这个简单的任务里面涉及到了block嵌套，子线程与主线程的切换等等上下文切换的逻辑。</p><p>代码首先会执行第一行，然后就直接执行最后一行，再回到第二行执行，然后还得判断各种异常状态，最后才回到主线程刷新。可以发现这里面最深的嵌套达到了4层，而且上下文的切换也不利于代码阅读。可想而知要是逻辑稍微再多一点，就远远不止这种复杂度了。</p><h2 id="用-async-和-await-来拯救一下"><a href="#用-async-和-await-来拯救一下" class="headerlink" title="用 async 和 await 来拯救一下"></a>用 async 和 await 来拯救一下</h2><p>改造完之后，代码如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">image</span>(<span class="params">url</span>: <span class="type">URL</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> (data, response) <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">URLSession</span>.shared.data(from: url)</span><br><span class="line">    <span class="keyword">guard</span> (response <span class="keyword">as?</span> <span class="type">HTTPURLResponse</span>)<span class="operator">?</span>.statusCode <span class="operator">==</span> <span class="number">200</span> <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="string">&quot;org,swift&quot;</span>, code: <span class="operator">-</span><span class="number">1</span>) &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> maybeImage <span class="operator">=</span> <span class="type">UIImage</span>(data: data) <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="string">&quot;org,swift&quot;</span>, code: <span class="operator">-</span><span class="number">1</span>) &#125;</span><br><span class="line">    <span class="keyword">return</span> maybeImage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式如下（如果需要捕获异常的话就需要加上<code>do-catch</code>）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> <span class="keyword">self</span>.imageView.image <span class="operator">=</span> <span class="keyword">await</span> <span class="type">AsyncTest</span>.image(url: <span class="type">URL</span>(string: <span class="string">&quot;https://images.xiaozhuanlan.com/photo/2021/fb4d1bcda193cdfb5ccc380d1a008fe1.png&quot;</span>)<span class="operator">!</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们的代码精简了许多，嵌套最深也就是判断到异常的时候抛出的1层，接下来我们来逐行讲解一下</p><h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><p>首先<code>URLSession.shared.data(from: url) </code>是iOS 15 新出的方法，用于发起网络请求，方法定义如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Convenience method to load data using an URL, creates and resumes an URLSessionDataTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter url: The URL for which to load data.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Data and response.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">data</span>(<span class="params">from</span> <span class="params">url</span>: <span class="type">URL</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">Data</span>, <span class="type">URLResponse</span>)</span><br></pre></td></tr></table></figure><p>其中 <code>async</code> 表示这是一个异步方法，如同我们前面定义的方法一样<code>static func image(url: URL) async throws -&gt; UIImage</code>，同样也有<code>async</code>这个关键字，只要方法里面有<code>await</code>关键字，那么方法名就得带上<code>async</code>关键字。带有<code>async</code>的方法就意味着需要使用<code>await</code>去调用，然后其返回值可以直接赋值给某个变量。举例如下:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getName</span>()</span> <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line"><span class="comment">/// 发起网络请求获取名字，这时候线程会卡住，直到请求完成了，就会把这个请求方法的返回值直接赋值给name，然后就会继续往下执行，把拿到的name给返回出去</span></span><br><span class="line"><span class="keyword">let</span> name <span class="operator">=</span> <span class="keyword">await</span> requestName()</span><br><span class="line"><span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 同理，当代码执行到这里的时候，调用异步方法，线程会卡住，然后方法里面去调用网络请求获取名字，然后等待网络请求返回之后，name就会被赋上值</span></span><br><span class="line"><span class="keyword">let</span> name <span class="operator">=</span> <span class="keyword">await</span> getName()</span><br></pre></td></tr></table></figure><p>以上面的<code>URLSession</code>的<code>data(from:delegate:)</code>方法为例，返回的是一个元组，所以就是</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (data, response) <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">URLSession</span>.shared.data(from: url)</span><br></pre></td></tr></table></figure><p>表示请求后，<code>data</code>和<code>response</code>变量都会被赋上值，分别是<code>Data</code>类型和<code>URLResponse</code>类型</p><p>另外我们注意到，和通过block方式返回请求结果不同，这个新方法返回的元组中的<code>data</code>和<code>response</code>都不是可选类型，而是确切有值的，如果发生网络异常则会通过<code>throw</code>抛出异常，这样子的设计能够让我们节省加下来针对空值的判断，可以放心地使用返回值</p><blockquote><p>当然，不仅仅是网络请求可以用<code>await</code>，任意的异步行为（比如读取本地文件）都可以使用<code>await</code></p></blockquote><p>目前在iOS 15 SDK的<code>URLSession</code>中，不仅仅提供了上述请求数据，返回元组的方法，还提供了其他上传，下载的方法，可供异步调用，这里简单列举一下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter request: The URLRequest for which to upload data.</span></span><br><span class="line"><span class="comment">/// - Parameter fileURL: File to upload.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Data and response.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">upload</span>(<span class="params">for</span> <span class="params">request</span>: <span class="type">URLRequest</span>, <span class="params">fromFile</span> <span class="params">fileURL</span>: <span class="type">URL</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">Data</span>, <span class="type">URLResponse</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter request: The URLRequest for which to upload data.</span></span><br><span class="line"><span class="comment">/// - Parameter bodyData: Data to upload.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Data and response.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">upload</span>(<span class="params">for</span> <span class="params">request</span>: <span class="type">URLRequest</span>, <span class="params">from</span> <span class="params">bodyData</span>: <span class="type">Data</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">Data</span>, <span class="type">URLResponse</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Convenience method to download using an URLRequest, creates and resumes an URLSessionDownloadTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter request: The URLRequest for which to download.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Downloaded file URL and response. The file will not be removed automatically.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">download</span>(<span class="params">for</span> <span class="params">request</span>: <span class="type">URLRequest</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">URL</span>, <span class="type">URLResponse</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Convenience method to download using an URL, creates and resumes an URLSessionDownloadTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter url: The URL for which to download.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Downloaded file URL and response. The file will not be removed automatically.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">download</span>(<span class="params">from</span> <span class="params">url</span>: <span class="type">URL</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">URL</span>, <span class="type">URLResponse</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Convenience method to resume download, creates and resumes an URLSessionDownloadTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter resumeData: Resume data from an incomplete download.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Downloaded file URL and response. The file will not be removed automatically.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">download</span>(<span class="params">resumeFrom</span> <span class="params">resumeData</span>: <span class="type">Data</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">URL</span>, <span class="type">URLResponse</span>)</span><br></pre></td></tr></table></figure><h3 id="容错-amp-转码"><a href="#容错-amp-转码" class="headerlink" title="容错 &amp; 转码"></a>容错 &amp; 转码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> (response <span class="keyword">as?</span> <span class="type">HTTPURLResponse</span>)<span class="operator">?</span>.statusCode <span class="operator">==</span> <span class="number">200</span> <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="string">&quot;org,swift&quot;</span>, code: <span class="operator">-</span><span class="number">1</span>) &#125;</span><br></pre></td></tr></table></figure><p>这一行用来处理响应体的异常情况，当<code>statusCode</code> 为 200的判断不成立时，就会抛出异常，则外部需要通过<code>do-catch</code>去捕获</p><p>如果判断成立时，则程序继续往下走</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> maybeImage <span class="operator">=</span> <span class="type">UIImage</span>(data: data) <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="string">&quot;org,swift&quot;</span>, code: <span class="operator">-</span><span class="number">1</span>) &#125;</span><br></pre></td></tr></table></figure><p>这里将<code>data</code>转成了<code>UIImage</code>，由于该方法返回的是一个可选值，所以这里同样需要通过<code>guard</code>去判断转换失败的情况</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> maybeImage</span><br></pre></td></tr></table></figure><p>最后得到了确切的结果之后，我们就可以将转好的图片给发送出去了，并且外面使用这个返回值的时候也不用判空，可以放心地确定返回的图片是有值的。</p><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>当我们的方法被标记为<code>async</code>的时候，我们就需要加上<code>await</code>进行调用，并且调用的环境是需要在异步环境内的，即如下所示</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> &#123;</span><br><span class="line"><span class="keyword">try</span> <span class="keyword">let</span> image <span class="operator">=</span> <span class="keyword">await</span> <span class="type">AsyncTest</span>.image(url: xxxx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Xcode 13.0 bata 4 中这个<code>async &#123;&#125; </code>环境的建立代码被提示即将被废弃，所以改成了如下所示</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span>(priority: .userInitiated) &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">let</span> image <span class="operator">=</span> <span class="keyword">await</span> <span class="type">AsyncTest</span>.image(url: xxxx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>userInitiated</code>表示线程优先级为<code>用户发起</code>，当然<code>priority</code>参数也可以不填，默认优先级是<code>Task.currentPriority</code>，返回值默认是<code>default</code></p><p>目前有六种优先级，这里从高到低进行排列如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 优先级最高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> high: <span class="type">TaskPriority</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 等同于default</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> medium: <span class="type">TaskPriority</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> low: <span class="type">TaskPriority</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> userInitiated: <span class="type">TaskPriority</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> utility: <span class="type">TaskPriority</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 优先级最低</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> background: <span class="type">TaskPriority</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当你标记一个函数为<code>async</code>时，即表示该函数可以被挂起。在<code>async</code>函数内部，使用<code>await</code>关键词标记在哪里可以一次或多次挂起。当<code>async</code>函数挂起时，线程并未阻塞，系统会自由安排其他任务。有时后启动的任务，可能先被执行。即你的程序状态可能在挂起时发生显著变化。当<code>async</code>函数恢复执行时，其返回的结果会自然融入到<code>async</code>函数的调用者，并在先前挂起的地方接续执行。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><code>await</code>关键字表示该异步（async）函数可能会被挂起，而不是畅通无阻地继续执行下去，甚至从挂起恢复回来时，函数可能已经跑到了另一个线程上去了，为了解决这个问题，我们可以用Swift的<code>actor</code>保护可变状态，这个我们后面再讲</p><h2 id="Async序列"><a href="#Async序列" class="headerlink" title="Async序列"></a>Async序列</h2><p>Async序列顾名思义就是异步的序列，比如读取一个很大的文件，我们希望一边下载一边展示读取的内容，这时候我们可以通过使用<code>for await-in</code> 来遍历一个异步的序列，如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">eatchquakes</span>()</span> <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> endpointURL <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.csv&quot;</span>)<span class="operator">!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过首行 因为是header描述不是地震数据</span></span><br><span class="line">    <span class="comment">// 接着遍历提取强度、时间、经纬度信息</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">try</span> <span class="keyword">await</span> event <span class="keyword">in</span> endpointURL.lines.dropFirst() &#123;</span><br><span class="line">        <span class="keyword">let</span> values <span class="operator">=</span> event.split(separator: <span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> time <span class="operator">=</span> values[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> latitude <span class="operator">=</span> values[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">let</span> longtitude <span class="operator">=</span> values[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">let</span> magnitude <span class="operator">=</span> values[<span class="number">4</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Magnitude <span class="subst">\(magnitude)</span> on <span class="subst">\(time)</span> at <span class="subst">\(latitude)</span> <span class="subst">\(longtitude)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，异步序列就是对随着时间推移如何产生值或对象的一种描述方式。由于值的产生是异步的，所以可能会在读取的过程中出现异常，当异常发生的时候，遍历终止，并抛出异常。</p><p>其中，<code>lines</code>方法是iOS 15 新增的一个<code>URL</code>的拓展属性，同时还有<code>resourceBytes</code>属性，完整定义如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">AsyncBytes</span> : <span class="title">AsyncSequence</span>, <span class="title">AsyncIteratorProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">AsyncIterator</span> <span class="operator">=</span> <span class="type">URL</span>.<span class="type">AsyncBytes</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Element</span> <span class="operator">=</span> <span class="type">UInt8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/// Asynchronously advances to the next element and returns it, or ends the</span></span><br><span class="line">        <span class="comment">/// sequence if there is no next element.</span></span><br><span class="line">        <span class="comment">/// </span></span><br><span class="line">        <span class="comment">/// - Returns: The next element, if it exists, or `nil` to signal the end of</span></span><br><span class="line">        <span class="comment">///   the sequence.</span></span><br><span class="line">        <span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span>()</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">UInt8</span>?</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// Creates the asynchronous iterator that produces elements of this</span></span><br><span class="line">        <span class="comment">/// asynchronous sequence.</span></span><br><span class="line">        <span class="comment">///</span></span><br><span class="line">        <span class="comment">/// - Returns: An instance of the `AsyncIterator` type used to produce</span></span><br><span class="line">        <span class="comment">/// elements of the asynchronous sequence.</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">makeAsyncIterator</span>()</span> -&gt; <span class="type">URL</span>.<span class="type">AsyncBytes</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> resourceBytes: <span class="type">URL</span>.<span class="type">AsyncBytes</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> lines: <span class="type">AsyncLineSequence</span>&lt;<span class="type">URL</span>.<span class="type">AsyncBytes</span>&gt; &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>因为异步序列的遍历是一个耗时操作，所以我们也可以在需要的时候中断遍历（取消请求）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span>(priority: .userInitiated) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">AsyncTest</span>.eatchquakes()</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 取消</span></span><br><span class="line">task.cancel()</span><br></pre></td></tr></table></figure><p>除了<code>URL</code>新增的<code>lines</code>方法，iOS 15 还给<code>FileHandle</code>和<code>URLSession</code>添加了异步序列方法，比如<code>FileHandle</code>新增的<code>bytes</code>属性，能提供字节流的异步序列。配合异步序列的扩展能力（把字节流变成<code>lines</code>），我们就可以从文件中异步地获得逐行内容并进行处理了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从FileHandle异步读取bytes</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> bytes: <span class="type">AsyncBytes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">try</span> <span class="keyword">await</span> line <span class="keyword">in</span> <span class="type">FileHandle</span>.standardInput.bytes.lines &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅如此，现在通知也支持异步序列了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步await通知</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">notifications</span>(<span class="params">named</span>: <span class="type">Notification</span>.<span class="type">Name</span>, <span class="params">object</span>: <span class="type">AnyObject</span>)</span> -&gt; notifications</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> center <span class="operator">=</span> <span class="type">NotificationCenter</span>.default</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 返回第一个userInfo的NSStoreUUIDKey值为storeUUID的通知</span></span><br><span class="line"><span class="keyword">let</span> notification <span class="operator">=</span> <span class="keyword">await</span> center.notifications(named: .<span class="type">NSPersistentStoreRemoteChange</span>).first &#123;</span><br><span class="line">    <span class="variable">$0</span>.userInfo[<span class="type">NSStoreUUIDKey</span>] <span class="operator">==</span> storeUUID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将异步回调的闭包方法改造成async方法"><a href="#将异步回调的闭包方法改造成async方法" class="headerlink" title="将异步回调的闭包方法改造成async方法"></a>将异步回调的闭包方法改造成async方法</h2><p>上面提到的都是基于系统提供的<code>async</code>方法，如果要改造我们原有的异步回调block方法，我们可以使用<code>withCheckedContinuation</code>或者<code>withCheckedThrowingContinuation</code>函数，区别在于前者用于确定不会抛出错误的场景，举例如下：</p><ul><li>三秒后返回Hello World</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">getItem</span>(<span class="params">callback</span>: <span class="keyword">@escaping</span> (<span class="type">String</span>)-&gt;(<span class="type">Void</span>))</span> &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">3.0</span>) &#123;</span><br><span class="line">        callback(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造后</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">getItem</span>()</span> <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> withCheckedContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">3.0</span>) &#123;</span><br><span class="line">            continuation.resume(returning: <span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">            <span class="comment">/// 如果需要抛出错误，使用 continuation.resume(throwing: error)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>continuation 有个简单但是重要的原则，resume方法必须在每个路径上执行，有且只有一次。但是不用担心，如果在有的路径上没有执行resume方法，Swift runtime 会发出 warning 警告。</p><p>但如果在某个路径上，resume执行了不止一次，这会是严重得多的问题。Swift runtime 会在第二次 resume 调用处触发 fatal error。</p><p>如果使用的是<code>withTaskCancellationHandler</code>，那么可以在异步操作被取消的时候执行某些行为</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">getItem</span>()</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">await</span> withTaskCancellationHandler &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Cancel&quot;</span>)</span><br><span class="line">    &#125; operation: &#123;</span><br><span class="line">        <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> withCheckedThrowingContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">3.0</span>) &#123;</span><br><span class="line">                continuation.resume(returning: <span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 调用</span></span><br><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> item <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">AsyncTest</span>.getItem()</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error&quot;</span> <span class="operator">+</span> error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 调用取消的时候会打印`Cancel`</span></span><br><span class="line">task.cancel()</span><br></pre></td></tr></table></figure><h2 id="只读属性使用async"><a href="#只读属性使用async" class="headerlink" title="只读属性使用async"></a>只读属性使用async</h2><p>只读属性可以在其<code>get</code>方法中使用<code>async</code>标记是一个异步读取的属性，如下所示</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AsyncTest</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">FileError</span> : <span class="title">Error</span> </span>&#123;</span><br><span class="line">      <span class="keyword">case</span> missing, unreadable</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> content : <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">get</span> <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">          <span class="keyword">guard</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">Bundle</span>.main.url(forResource: <span class="string">&quot;Empty&quot;</span>, withExtension: <span class="string">&quot;md&quot;</span>) <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">FileError</span>.missing &#125;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">String</span>(contentsOf: url)</span><br><span class="line">          &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="type">FileError</span>.unreadable</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">readContent</span>()</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="keyword">self</span>.content</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h2><p>假如我们有多个异步函数，比如<code>切菜</code>、<code>切洋葱</code>、<code>切肉</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cooking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cutVegetable</span>()</span> <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">10_000_000_000</span>) <span class="comment">// 暂停10秒的意思</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;cut vegetable&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cutOnion</span>()</span> <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">5_000_000_000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;cut onion&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cutMeet</span>()</span> <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">5_000_000_000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;cut meet&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们这么调用的话，那么整个过程将是串行的，一共会花费20秒左右</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> step1 <span class="operator">=</span> <span class="keyword">await</span> <span class="type">Cooking</span>.cutVegetable()</span><br><span class="line">    <span class="keyword">let</span> step2 <span class="operator">=</span> <span class="keyword">await</span> <span class="type">Cooking</span>.cutOnion()</span><br><span class="line">    <span class="keyword">let</span> step3 <span class="operator">=</span> <span class="keyword">await</span> <span class="type">Cooking</span>.cutMeet()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>([step1,step2,step3])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是实际三个步骤之间并没有依赖关系，是可以同时进行的，所以我们需要使用结构化并发，让他们并发执行</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cooking</span>()</span> <span class="keyword">async</span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> withTaskGroup(of: <span class="type">String</span>.<span class="keyword">self</span>) &#123; group <span class="keyword">in</span></span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="type">Cooking</span>.cutVegetable()</span><br><span class="line">        &#125;</span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="type">Cooking</span>.cutOnion()</span><br><span class="line">        &#125;</span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="type">Cooking</span>.cutMeet()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> steps : [<span class="type">String</span>] <span class="operator">=</span> []</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">await</span> finishedStep <span class="keyword">in</span> group &#123;</span><br><span class="line">            steps.append(finishedStep)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子只要10秒左右就可以完成任务了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> cooking()</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在执行子任务的过程中发生了异常，那么<code>cooking()</code>方法将会退出，任何尚未完成的子任务都将自动取消。</p><h2 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h2><p>由于我们现在已经多很多异步操作的场景，所以自然我们在设计类的时候，也要注意这个类要是被多个线程同时访问的时候引起的状态变化的问题。</p><p>Swift 5.5引入了Actor，它在概念上类似于在并发环境中可以安全使用的类。Swift 确保在任何给定时间只能由单个线程访问 Actor 内的可变状态，这有助于在编译器级别消除各种严重的错误。</p><p>比如以下代码在单线程情况下是安全的，但是如果是多线程访问的话<code>deck</code>属性会出现资源竞争的问题</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RiskyCollector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> deck: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">deck</span>: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.deck <span class="operator">=</span> deck</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span>(<span class="params">card</span> <span class="params">selected</span>: <span class="type">String</span>, <span class="params">to</span> <span class="params">person</span>: <span class="type">RiskyCollector</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> deck.contains(selected) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">        deck.remove(selected)</span><br><span class="line">        person.transfer(card: selected)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">transfer</span>(<span class="params">card</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        deck.insert(card)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>危险：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = Set<span class="symbol">&lt;String&gt;</span>([<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;11&quot;</span>,<span class="string">&quot;12&quot;</span>])</span><br><span class="line"><span class="keyword">let</span> risky = RiskyCollector(deck:<span class="keyword">set</span>)</span><br><span class="line"><span class="keyword">for</span> i in <span class="number">1</span>...<span class="number">12</span> &#123;</span><br><span class="line">    DispatchQueue.<span class="keyword">global</span>().async &#123;</span><br><span class="line">        _ = risky.send(card: <span class="string">&quot;\(i)&quot;</span>, <span class="keyword">to</span>: risky)</span><br><span class="line">        <span class="keyword">print</span>(risky.deck)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Actor 通过引入 Actor 隔离解决了这个问题：除非异步执行，否则无法从 Actor 对象外部读取属性和方法，并且根本无法从 Actor 对象外部写入属性。 Swift 会自动将这些请求放入一个按顺序处理的队列中，以避免出现多线程竞争。</p><p>我们可以使用Actor重新实现一个SafeCollector，如下:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">actor <span class="type">SafeCollector</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> deck: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line">  <span class="function"><span class="keyword">init</span>(<span class="params">deck</span>: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;)</span> &#123;</span><br><span class="line">      <span class="keyword">self</span>.deck <span class="operator">=</span> deck</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">send</span>(<span class="params">card</span> <span class="params">selected</span>: <span class="type">String</span>, <span class="params">to</span> <span class="params">person</span>: <span class="type">SafeCollector</span>)</span> <span class="keyword">async</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">      <span class="keyword">guard</span> deck.contains(selected) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">      deck.remove(selected)</span><br><span class="line">      <span class="keyword">await</span> person.transfer(card: selected)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">transfer</span>(<span class="params">card</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">      deck.insert(card)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安全：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">String</span>&gt;([<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;11&quot;</span>,<span class="string">&quot;12&quot;</span>])</span><br><span class="line"><span class="keyword">let</span> risky <span class="operator">=</span> <span class="type">SafeCollector</span>(deck:<span class="keyword">set</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">12</span> &#123;</span><br><span class="line">    <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">_</span> <span class="operator">=</span> <span class="keyword">await</span> risky.send(card: <span class="string">&quot;<span class="subst">\(i)</span>&quot;</span>, to: risky)</span><br><span class="line">        <span class="built_in">print</span>(<span class="keyword">await</span> risky.deck)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中有几件事情需要注意：</p><ul><li><p>actor内对外暴露的方法都是异步方法，即使没有标记async，因为它会等到另一个 SafeCollector actor 能够处理请求。</p></li><li><p>actor 可以自由地、异步或以其他方式使用自己的属性和方法，但是当与不同的 actor 交互时，它必须始终异步完成。通过这些特性，Swift 可以确保永远不会同时访问所有与 actor 隔离的状态，更重要的是，这是在编译时完成的，以保证线程安全。</p></li></ul><p>Actor 和 Class 有一些相似之处：</p><ul><li><p>两者都是引用类型，因此它们可用于共享状态。</p></li><li><p>它们可以有方法、属性、初始值设定项和下标。</p></li><li><p>它们可以实现协议。任何静态属性和方法在这两种类型中的行为都相同。</p></li></ul><p>除了 Actor 隔离之外，Actor 和 Class之间还有另外两个重要的区别：</p><ul><li><p>Actor 目前不支持继承，这在未来可能会改变</p></li><li><p>所有 Actor 都隐式遵守一个新的 Actor Protocol</p></li></ul><h3 id="Global-Actor"><a href="#Global-Actor" class="headerlink" title="Global Actor"></a>Global Actor</h3><p>Global Actor 将 actor 隔离的概念扩展到了全局状态，即使状态和函数分散在许多不同的模块中，Global Actor 可以在并发程序中安全地使用全局变量，例如 Swift 提供的 <code>@MainActor</code> 限制属性和方法只能在主线程访问</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MainActor</span> <span class="function"><span class="keyword">func</span> <span class="title">refreshUI</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;updating ui…&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MainActor</span> <span class="keyword">var</span> globalTextSize: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@MainActor</span> <span class="function"><span class="keyword">func</span> <span class="title">increaseTextSize</span>()</span> &#123;</span><br><span class="line">  globalTextSize <span class="operator">+=</span> <span class="number">2</span>   <span class="comment">// okay:</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notOnTheMainActor</span>()</span> <span class="keyword">async</span> &#123;</span><br><span class="line">  globalTextSize <span class="operator">=</span> <span class="number">12</span>  <span class="comment">// error: globalTextSize is isolated to MainActor</span></span><br><span class="line">  increaseTextSize()   <span class="comment">// error: increaseTextSize is isolated to MainActor, cannot call synchronously</span></span><br><span class="line">  <span class="keyword">await</span> increaseTextSize() <span class="comment">// okay: asynchronous call hops over to the main thread and executes there</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要简述Swift 5.5新特性 async与await的常用方式&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="Swift" scheme="https://www.arclin.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 5 Property Wrapper</title>
    <link href="https://www.arclin.cn/post/1bf095f2.html"/>
    <id>https://www.arclin.cn/post/1bf095f2.html</id>
    <published>2021-07-29T16:14:00.000Z</published>
    <updated>2022-07-12T16:51:57.239Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲述Swift5新特性Property Wrapper的使用</p><span id="more"></span><p>Property Wrapper即属性包装器，用于对某个属性进行包装，包装后可以对其做一些约束、限制或者修改</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>举例，比如我们需要添加一个属性包装器用来包装字符串，对字符串长度进行限制，只有当字符串长度在允许范围内，才能被赋值到属性中</p><p>创建一个属性包装器，<code>wrappedValue</code>是必须的，并且需要实现其setter和getter，在里面添加赋值判断逻辑</p><p>我们可以提供两种属性包装器的初始化方法，一种是设置默认字符串长度上下限，一种是设置特定的字符串长度上下限</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value : <span class="type">String</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> minLength : <span class="type">Int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> maxLength : <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> wrappedValue : <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (minLength<span class="operator">...</span>maxLength).contains(newValue.count) &#123;</span><br><span class="line">                value <span class="operator">=</span> newValue</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> minLength <span class="operator">&gt;</span> newValue.count &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;字符串太短了&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;字符串太长了&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 默认5-10个字</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        minLength <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">        maxLength <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">        value <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 设置默认值</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">minLength</span>: <span class="type">Int</span>, <span class="params">maxLength</span>: <span class="type">Int</span>, <span class="params">value</span>: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.maxLength <span class="operator">=</span> maxLength</span><br><span class="line">        <span class="keyword">self</span>.minLength <span class="operator">=</span> minLength</span><br><span class="line">        <span class="keyword">self</span>.value <span class="operator">=</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用属性包装器的方式如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">     <span class="comment">/// 自定义初始化方式</span></span><br><span class="line">    <span class="meta">@StringWrapper</span>(minLength: <span class="number">3</span>, maxLength: <span class="number">5</span>) <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="comment">/// 默认初始化方式</span></span><br><span class="line">    <span class="meta">@StringWrapper</span> <span class="keyword">var</span> title : <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">person.name <span class="operator">=</span> <span class="string">&quot;ARCLIN&quot;</span></span><br><span class="line">person.title <span class="operator">=</span> <span class="string">&quot;Hyper Agent GridMan&quot;</span></span><br><span class="line"><span class="built_in">print</span>(person.name) <span class="comment">/// ARCLIN</span></span><br><span class="line"><span class="built_in">print</span>(person.title) <span class="comment">/// 字符串太长了</span></span><br></pre></td></tr></table></figure><h2 id="从属性包装器中呈现一个值"><a href="#从属性包装器中呈现一个值" class="headerlink" title="从属性包装器中呈现一个值"></a>从属性包装器中呈现一个值</h2><p>属性包装器还提供了另外一个属性，这个属性一般情况下可以用来标记被包装的属性是否被修改过</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringWrapper</span> </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">  <span class="keyword">var</span> projectedValue <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> wrappedValue : <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">get</span> &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">      <span class="keyword">set</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (minLength<span class="operator">...</span>maxLength).contains(newValue.count) &#123;</span><br><span class="line">              value <span class="operator">=</span> newValue</span><br><span class="line">              projectedValue <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> minLength <span class="operator">&gt;</span> newValue.count &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;字符串太短了&quot;</span>)</span><br><span class="line">              projectedValue <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;字符串太长了&quot;</span>)</span><br><span class="line">              projectedValue <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过<code>$</code>符号来调用这个值</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@StringWrapper</span>(minLength: <span class="number">3</span>, maxLength: <span class="number">5</span>) <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">person.name <span class="operator">=</span> <span class="string">&quot;JASON&quot;</span></span><br><span class="line"><span class="built_in">print</span>(person.<span class="variable">$name</span>) <span class="comment">// 打印false，因为这时候长度符合规范</span></span><br><span class="line">person.name <span class="operator">=</span> <span class="string">&quot;HyperJASON&quot;</span></span><br><span class="line"><span class="built_in">print</span>(person.<span class="variable">$name</span>) <span class="comment">// 打印true，因为这时候长度太长了</span></span><br></pre></td></tr></table></figure><p>这个属性也用来可以返回别的东西</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringWrapper</span> </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">  <span class="keyword">var</span> projectedValue : <span class="type">NSAttributedString</span> &#123;</span><br><span class="line">      <span class="comment">/// 构建出一个富文本对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="type">NSAttributedString</span>(string: <span class="string">&quot;--- <span class="subst">\(<span class="keyword">self</span>.value)</span> ---&quot;</span>, attributes: [</span><br><span class="line">          .foregroundColor : <span class="type">UIColor</span>.red,</span><br><span class="line">          .font : <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">15</span>)</span><br><span class="line">      ])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wrappedValue : <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">get</span> &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">      <span class="keyword">set</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (minLength<span class="operator">...</span>maxLength).contains(newValue.count) &#123;</span><br><span class="line">              value <span class="operator">=</span> newValue</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> minLength <span class="operator">&gt;</span> newValue.count &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;字符串太短了&quot;</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;字符串太长了&quot;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@StringWrapper</span>(minLength: <span class="number">3</span>, maxLength: <span class="number">5</span>) <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">person.name <span class="operator">=</span> <span class="string">&quot;JASON&quot;</span></span><br><span class="line"><span class="built_in">print</span>(person.<span class="variable">$name</span>)</span><br><span class="line"><span class="comment">/*  打印出一个富文本对象</span></span><br><span class="line"><span class="comment">--- JASON ---&#123;</span></span><br><span class="line"><span class="comment">    NSColor = &quot;UIExtendedSRGBColorSpace 1 0 0 1&quot;;</span></span><br><span class="line"><span class="comment">    NSFont = &quot;&lt;UICTFont: 0x7fc199f06660&gt; font-family: \&quot;.SFUI-Regular\&quot;; font-weight: normal; font-style: normal; font-size: 15.00pt&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要讲述Swift5新特性Property Wrapper的使用&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="Swift" scheme="https://www.arclin.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 -- Runloop</title>
    <link href="https://www.arclin.cn/post/fee6666f.html"/>
    <id>https://www.arclin.cn/post/fee6666f.html</id>
    <published>2021-07-21T14:10:50.000Z</published>
    <updated>2022-07-12T16:51:57.241Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述iOS中Runloop的一些使用以及原理</p><span id="more"></span><h2 id="Runloop对象"><a href="#Runloop对象" class="headerlink" title="Runloop对象"></a>Runloop对象</h2><ul><li>iOS中有两套API来访问和使用Runloop<ul><li>Foundation : NSRunLoop</li><li>Core Foundation : CFRunloopRef</li></ul></li><li>NSRunloop和CFRunloopRef都代表着Runloop对象</li><li>NSRunloop是基于CFRunloopRef的一层OC包装</li><li>CFRunloopRef是开源的</li></ul><p>获取当前Runloop的两个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop *runloop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">CFRunLoopRef runloopRef &#x3D; CFRunLoopGetCurrent();</span><br></pre></td></tr></table></figure><p>打印runloop可以发现类型是<code>&lt;CFRunLoop 0x600001994300 [0x101405a98]&gt;</code>，跟runloopRef一致，但是打印地址不一样，原因是<code>NSRunLoop</code>是对<code>CFRunLoopRef</code>的封装，<code>CFRunLoopRef</code>是存储在其内部，所以会不一样</p><h2 id="Runloop与线程"><a href="#Runloop与线程" class="headerlink" title="Runloop与线程"></a>Runloop与线程</h2><ul><li><p>每条线程都有唯一的一个与之对应的Runloop对象</p></li><li><p>Runloop保存在一个全局的Dictionary里，线程作为key，Runloop作为Value</p><ul><li>Runloop源码 <code>CFRunloop.c</code>中我们可以找到<code>CFRunLoopGetCurrent()</code>内调用了<code>_CFRunLoopGet0()</code>，在这里面可以看到这行代码得以验证</li></ul>  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef loop = (CFRunLoopRef)<span class="constructor">CFDictionaryGetValue(<span class="params">__CFRunLoops</span>, <span class="params">pthreadPointer</span>(<span class="params">t</span>)</span>);</span><br></pre></td></tr></table></figure></li><li><p>线程刚创建的时候并没有Runloop对象，Runloop会在第一次获取它时创建</p><ul><li>主线程一开始也是没有Runloop的，只是因为在<code>main.m</code>中调用了<code>UIApplicationMain</code>函数，在这里面回去获取Runloop从而创建了Runloop</li><li>对应源码如下</li></ul>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CF_EXPORT</span> <span class="built_in">CFRunLoopRef</span> _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">        loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops,pthreadPointer(t));</span><br><span class="line">        <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">            <span class="built_in">CFDictionarySetValue</span>(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">            loop = newLoop;</span><br><span class="line">        &#125;</span><br><span class="line">         __CFUnlock(&amp;loopsLock);</span><br><span class="line">   <span class="built_in">CFRelease</span>(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Runloop会在线程结束时销毁</p></li><li><p>主线程的Runloop已经自动获取（创建），子线程默认没有开启Runloop</p></li></ul><h2 id="Runloop相关的类"><a href="#Runloop相关的类" class="headerlink" title="Runloop相关的类"></a>Runloop相关的类</h2><p>Core Foundation 中关于Runloop的5个类</p><ul><li>CFRunloopRef</li><li>CFRunloopModeRef</li><li>CFRunloopSourceRef</li><li>CFRunloopTimerRef</li><li>CFRunloopObserverRef</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoop * <span class="built_in">CFRunloopRef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    ...</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems;</span><br><span class="line">    <span class="built_in">CFRunloopModeRef</span> _currentMode;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoopMode *<span class="built_in">CFRunLoopModeRef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0; <span class="comment">// CFRunloopSourceRef数组</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1; <span class="comment">// CFRunloopSourceRef数组</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// CFRunloopObserverRef数组</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers; <span class="comment">// CFRunloopTimerRef数组 </span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码我们可以得知，一个Runloop对象里面有多个mode，存放在<code>_modes</code>成员属性里面。其中有一个mode是<code>_currentMode</code>。 然后每个mode都有<code>name</code>、<code>source0</code>、<code>source1</code>等数组属性</p><ul><li>CFRunloopModeRef 代表Runloop的运行模式</li><li>Runloop启动只能选择其中一个Mode作为currentMode</li><li>如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入<ul><li>不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响</li></ul></li><li>如果Mode里面没有任何Source0/Source1/Timer/Observer，Runloop会立马退出</li></ul><h3 id="CFRunloopModeRef"><a href="#CFRunloopModeRef" class="headerlink" title="CFRunloopModeRef"></a>CFRunloopModeRef</h3><ul><li><p>两种常见的Mode</p><ul><li><code>kCFRunLoopDefaultMode</code>（<code>NSDefaultRunloopMode</code>）: App的默认Mode，通常主线程是在这个Mode下运行</li><li><code>UITrackingRunLoopMode</code>界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响</li></ul></li><li><p>Source0</p><ul><li>触摸事件处理</li><li><code>performSelector:onThread:</code></li></ul></li><li><p>Source1</p><ul><li>基于Port的线程间通信</li><li>系统事件捕捉（捕捉后到Source0去处理）</li></ul></li><li><p>Timers</p><ul><li>NSTimer</li><li><code>performSelector:withObject:afterDelay:</code></li></ul></li><li><p>Observers</p><ul><li>用于监听Runloop的状态</li><li>UI刷新（BeforeWaiting）在Runloop休眠之前会执行一次UI刷新</li><li>Autorelease pool 在Runloop休眠之前自动释放某些内存</li></ul></li></ul><h3 id="CFRunloopObserverRef"><a href="#CFRunloopObserverRef" class="headerlink" title="CFRunloopObserverRef"></a>CFRunloopObserverRef</h3><p>Runloop的几种状态</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>),         <span class="comment">// 即将进入Loop </span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),  <span class="comment">// 即将处理Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>),  <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>),          <span class="comment">// 即将退出Loop</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以自己添加一个监听者来监听Runloop的状态变化</p><ol><li>定义监听回调</li></ol>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> observeRunLoopActivities(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> *info) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopEntry&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeTimers&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeSources&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeWaiting&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopAfterWaiting&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopExit&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建监听者</li></ol>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 创建Observer</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, observeRunLoopActivities, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/// 添加Observer</span></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line"><span class="built_in">CFRelease</span>(observer);</span><br></pre></td></tr></table></figure><h2 id="Runloop的运行逻辑"><a href="#Runloop的运行逻辑" class="headerlink" title="Runloop的运行逻辑"></a>Runloop的运行逻辑</h2><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><ol><li>通知Observers：进入Loop</li><li>通知Observers：即将处理Timers</li><li>通知Observers：即将处理Sources</li><li>处理Blocks（特指执行CFRunLoopPerformBlock内的block参数） <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">CFRunLoopPerformBlock</span>(CFRunLoopGetCurrent(), kCFRunLoopCommonModes, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>处理Source0（可能会再次处理Blocks，因为有可能在处理Source0的时候添加了Blocks）</li><li>如果存在Source1，就跳转到第8步</li><li>通知Observers：开始休眠（等待消息唤醒）</li><li>通知Observers：结束休眠（被某个消息唤醒，被什么东西唤醒就处理什么东西）<ul><li>处理Timer</li><li>处理GCD Async To Main Queue</li><li>处理Source1</li></ul></li><li>处理Blocks</li><li>根据前面的执行结果，决定如何操作（如下几种可能）<ol><li>回到第2步</li><li>退出Loop</li></ol></li><li>通知Observers：退出Loop</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>通过在控制台执行命令<code>bt</code>我们可以看到开始是调用了<code>CFRunLoopRunSpecific</code>函数，核心源码如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SInt32 <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/// 通知Observers：进入Loop</span></span><br><span class="line">__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 具体要做的事情</span></span><br><span class="line">result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 通知Observers：退出Loop</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后查看一下<code>__CFRunLoopRun</code>内的核心处理代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int32_t __CFRunLoopRun(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopModeRef</span> rlm, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle, <span class="built_in">CFRunLoopModeRef</span> previousMode) &#123;</span><br><span class="line">    ...</span><br><span class="line">    int32_t retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 通知Observers：即将处理Timers</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 通知Observers：即将处理Sources</span></span><br><span class="line">         __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 处理Blocks</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 处理Source0</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            <span class="comment">/// 处理Blocks</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0</span>ULL == timeout_context-&gt;termTSR);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 判断有无Source1</span></span><br><span class="line">        <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="comment">/// 如果有Source1，就跳转到handle_msg</span></span><br><span class="line">            <span class="keyword">goto</span> handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 通知Observers：即将休眠</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/// 等待别的消息来唤醒当前线程</span></span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        <span class="comment">/// 通知Observers：结束休眠</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        </span><br><span class="line">    handle_msg:;</span><br><span class="line">        <span class="comment">/// 被Timer唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_TIMER</span>();</span><br><span class="line">            <span class="comment">/// 处理Timers</span></span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer, because we apparently fired early</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">/// 被GCD唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_DISPATCH</span>();</span><br><span class="line">            <span class="comment">/// 处理GCD</span></span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/// 被Source1唤醒</span></span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_SOURCE</span>();</span><br><span class="line">            <span class="comment">/// 处理Source1</span></span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 处理Blocks</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 设置返回值</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行顺序跟我们上面提及的执行流程是相似的，最后的返回值如果是0的话，那么就继续循环，如果是其他值，那么就会退出循环，继而退出Runloop</p><p>上面提及的处理Timers函数，处理GCD函数和处理Source1的函数，都会调用到<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_xxx_FUNCTION__</code>这个函数(这个xxx代表Observer、Block、Source0或者Timer等，见下表)，在这个函数里面，再去执行对应的操作，比如UIKit的界面刷新、Foundation定时器的执行</p><table><thead><tr><th>执行的事情</th><th>调用的函数</th></tr></thead><tbody><tr><td>进入Loop</td><td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</strong></td></tr><tr><td>处理Blocks</td><td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK</strong></td></tr><tr><td>处理Source0</td><td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong></td></tr><tr><td>处理Timer</td><td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong></td></tr><tr><td>处理GCD</td><td><strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong></td></tr><tr><td>处理SOURCE1</td><td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</strong></td></tr></tbody></table><p>GCD只有在回调到主线程的时候才会调用到Runloop的函数，比如下面这种情况 </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>,<span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Runloop休眠的实现原理"><a href="#Runloop休眠的实现原理" class="headerlink" title="Runloop休眠的实现原理"></a>Runloop休眠的实现原理</h3><p>当Runloop需要休眠的时候，会调用用户态的API，然后内部调用mach_msg()切换到内核态，当有消息的时候，就会从内核态切换回用户态的API去处理消息</p><p>用户态 ： mach_msg() -&gt; 内核态： mach_msg() -&gt; 用户态：处理消息</p><p>内核态：</p><ol><li>等待消息</li><li>没有消息就让线程休眠</li><li>有消息就唤醒线程</li></ol><h2 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h2><p>由于NSTimer默认是运行在<code>NSDefaultRunloopMode</code>的，所以在滚动的时候不会执行定时器，因为滚动的时候系统会切换到<code>UITrackingRunLoopMode</code></p><p>这时候我们需要把NSTimer设置到<code>NSRunLoopCommonModes</code>里，如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,++count);</span><br><span class="line">&#125;];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure><p><code>NSDefaultRunloopMode</code>、<code>UITrackingRunLoopMode</code>才是真正存在的模式</p><p><code>NSRunLoopCommonModes</code>并不是一个真的模式，它只是一个标记</p><p>timer能在<code>_commonModes</code>数组中存放的模式下工作</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    ...</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes; <span class="comment">// 存放着NSDefaultRunloopMod，UITrackingRunLoopMode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// 存放着common模式下要处理的对象，比如上面的timer</span></span><br><span class="line">    <span class="built_in">CFRunloopModeRef</span> _currentMode;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes; <span class="comment">// 存放着所有的模式</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="线程保活"><a href="#线程保活" class="headerlink" title="线程保活"></a>线程保活</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>一般情况下，我们创建线程后，当线程的任务执行完了，线程就会销毁，所以有时候我们需要让线程执行完任务后依旧存在，等到我们主动让他销毁他才会销毁。</p><p>首先我们创建一条线程</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>要让这条线程一直活着，我们可以让这个<code>run</code>方法不要结束</p><p>这里添加一个Runloop，由于获取Runloop的时候就会创建Runloop，所以我们获取Runloop即可，然后调用<code>addPort:forMode:</code>方法，添加一个<code>Source0</code></p><p>这样子线程就会卡在<code>[[NSRunLoop currentRunLoop] run];</code>这一行中，不会让方法执行完，线程也就不会销毁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %s begin&quot;</span>,<span class="built_in">NSThread</span>.currentThread,__func__);</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">    <span class="comment">/// 不会走到这里</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %s end&quot;</span>,<span class="built_in">NSThread</span>.currentThread,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后下一步我们需要调用一个方法去销毁这个线程，比如<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>，但是如果我们这么做</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)stop &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 尝试在我们指定的线程上停止这个线程内的Runloop</span></span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(stop) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure><p>发现线程不会销毁，原因是<code>[[NSRunLoop currentRunLoop] run];</code>执行后，会在一个死循环内执行Runloop的<code>runMode:beforeDate:</code>方法，类似于</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode: beforeDate:xxx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CFRunLoopStop(CFRunLoopGetCurrent());</code>只是停止了其中的一次方法调用，进入下个循环后又会开启，所以用这个方法去完全停止Runloop是没用的</p><p>所以我们要使用别的方式去替代<code>[[NSRunLoop currentRunLoop] run];</code>开启线程，因为这个<code>run</code>方法是专门用于开启一个永不销毁的线程。</p><p>只需要改造一下上面那个while方法就好，给self添加一个bool属性</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">BOOL</span> isStop;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %s begin&quot;</span>,<span class="built_in">NSThread</span>.currentThread,__func__);</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    <span class="keyword">while</span>(!<span class="keyword">self</span>.isStop) &#123;</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %s end&quot;</span>,<span class="built_in">NSThread</span>.currentThread,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stop &#123;</span><br><span class="line">    <span class="keyword">self</span>.isStop = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样子我们调用run方法线程就会启动，调用stop方法，while循环就会退出，<code>CFRunLoopStop(CFRunLoopGetCurrent());</code>停止了本次RunLoop，Runloop退出，这样子就能走到打印end那里，线程的方法走完了，线程就可以销毁了</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyThread</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 开启线程</span></span><br><span class="line">- (<span class="keyword">void</span>)run;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 销毁线程</span></span><br><span class="line">- (<span class="keyword">void</span>)stop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 执行任务</span></span><br><span class="line">- (<span class="keyword">void</span>)executeTask:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyThread</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Thread *innerThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span>=isStopped) <span class="built_in">BOOL</span> stopped;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyThread</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        </span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 创建线程 开启Runloop</span></span><br><span class="line">        <span class="keyword">self</span>.innerThread = [[Thread alloc] initWithBlock:^&#123;</span><br><span class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 因为dealloc的时候weakSelf已经空了，所以要明确self存在并且不停止时候，才循环启动Runloop</span></span><br><span class="line">            <span class="keyword">while</span> (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;</span><br><span class="line">                [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 开启线程，启动Runloop</span></span><br><span class="line">    [<span class="keyword">self</span>.innerThread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stop &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 停止线程</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__stop) onThread:<span class="keyword">self</span>.innerThread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)executeTask:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread || !block) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 执行子线程任务</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__executeTask:) onThread:<span class="keyword">self</span>.innerThread withObject:block waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - private method</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__stop &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 标记需要退出Runloop</span></span><br><span class="line">    <span class="keyword">self</span>.stopped = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 退出本次Runloop</span></span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 取消强引用</span></span><br><span class="line">    <span class="keyword">self</span>.innerThread = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__executeTask:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="comment">/// 自动调用停止方法</span></span><br><span class="line">    [<span class="keyword">self</span> stop];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 只是为了监听线程的销毁行为</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Thread</span> : <span class="title">NSThread</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Thread</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲述iOS中Runloop的一些使用以及原理&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Swift 5.4 Result Builder</title>
    <link href="https://www.arclin.cn/post/4bf15bdf.html"/>
    <id>https://www.arclin.cn/post/4bf15bdf.html</id>
    <published>2021-07-18T02:13:00.000Z</published>
    <updated>2022-07-12T16:51:57.239Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲述Swift 5.4的新特性 Result Builder在设计上的一些使用方式</p><span id="more"></span><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>假如我们有一个需求，需要往ScrollView上加入不同类型的View，并且根据不确定的的顺序从上往下进行排列，所以一般情况下我们可以这样子设计框架</p><ol><li>首先定义一个协议，遵循协议的对象使用一个build方法返回一个View</li></ol>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>这里我们设计四种颜色的View，宽度均为屏幕宽度，高度不定</li></ol>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WhiteView</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">UIScreen</span>.main.bounds.width, height: <span class="number">100</span>))</span><br><span class="line">        view.backgroundColor <span class="operator">=</span> .white</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RedView</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> banner <span class="operator">=</span> <span class="type">UIView</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">UIScreen</span>.main.bounds.width, height: <span class="number">200</span>))</span><br><span class="line">        banner.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.red</span><br><span class="line">        <span class="keyword">return</span> banner</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlueView</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> goodsView <span class="operator">=</span> <span class="type">UIView</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">UIScreen</span>.main.bounds.width, height: <span class="number">350</span>))</span><br><span class="line">        goodsView.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.blue</span><br><span class="line">        <span class="keyword">return</span> goodsView</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GreenView</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> dynamicView <span class="operator">=</span> <span class="type">UIView</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">UIScreen</span>.main.bounds.width, height: <span class="number">400</span>))</span><br><span class="line">        dynamicView.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.green</span><br><span class="line">        <span class="keyword">return</span> dynamicView</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>最后我们再定义一个ScrollView的容器，传入一个数组，让其从上到下进行排列</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScrollableContainer</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> contents : [<span class="type">ViewBuilder</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> scrollView <span class="operator">=</span> <span class="type">UIScrollView</span>.<span class="keyword">init</span>(frame: <span class="type">UIScreen</span>.main.bounds)</span><br><span class="line">    <span class="keyword">_</span> <span class="operator">=</span> contents.reduce(<span class="type">CGFloat</span>(<span class="number">0</span>)) &#123; currentY, builder <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> view <span class="operator">=</span> builder.build()</span><br><span class="line">        view.frame.origin.y <span class="operator">=</span> currentY</span><br><span class="line">        scrollView.addSubview(view)</span><br><span class="line">        scrollView.contentSize <span class="operator">=</span> <span class="type">CGSize</span>(width: <span class="type">UIScreen</span>.main.bounds.size.width, height: scrollView.subviews.last<span class="operator">!</span>.frame.maxY)</span><br><span class="line">        <span class="keyword">return</span> currentY <span class="operator">+</span> view.frame.size.height</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scrollView</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样子我们就可以开始布局了</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scrollView <span class="operator">=</span> <span class="type">ScrollableContainer</span>(contents: [</span><br><span class="line">    <span class="type">RedView</span>(),</span><br><span class="line">    <span class="type">BlueView</span>(),</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">])</span><br><span class="line">view.addSubview(scrollView.build())</span><br></pre></td></tr></table></figure><p> 效果如下</p> <img src="https://p6-tt.byteimg.com/origin/pgc-image/8f8201d352eb44a7aab4b0b68ba6e9e2.png" width=50%> </li><li><p>通过这种方式，我们就可以随意调整内部的布局顺序，也可以方便的新增多个View</p></li></ol><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>但是上述方法有一个缺点，就是当如果要重复添加多个相同的View或者说想要通过某个条件再添加View，就会有点复杂，比如当<code>needBlue == true</code>成立的时候再添加<code>BlueView</code>，那么可能需要这么写</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contents <span class="operator">=</span> [</span><br><span class="line">    <span class="type">RedView</span>(),</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> needBlue <span class="operator">==</span> <span class="literal">true</span> &#123;</span><br><span class="line">contents <span class="operator">=</span> [</span><br><span class="line">        <span class="type">RedView</span>(),</span><br><span class="line">        <span class="type">BlueView</span>(),</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scrollView <span class="operator">=</span> <span class="type">ScrollableContainer</span>(contents: contents)</span><br><span class="line">view.addSubview(scrollView.build())</span><br></pre></td></tr></table></figure><p>为了让可读性更加好，我们可以模仿SwiftUI的DSL语法进行设计，这里就需要使用到Swift 5.4的新特性 Result Builder</p><ol><li><p>首先我们要添加一个容器结构体，因为从上到下写的<code>View</code>会被整成一个数组或者多参数传进来，所以要加一个容器把他们从上到下排列好，最后排列完了，再把这个容器放进去ScrollView中</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ViewContainer</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> contents : [<span class="type">ViewBuilder</span>]</span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">         <span class="keyword">let</span> container <span class="operator">=</span> <span class="type">UIView</span>(frame: <span class="type">UIScreen</span>.main.bounds)</span><br><span class="line">         <span class="keyword">_</span> <span class="operator">=</span> contents.reduce(<span class="type">CGFloat</span>(<span class="number">0</span>), &#123; currentY, builder <span class="keyword">in</span></span><br><span class="line">             <span class="keyword">let</span> view <span class="operator">=</span> builder.build()</span><br><span class="line">             view.frame.origin.y <span class="operator">=</span> currentY</span><br><span class="line">             container.addSubview(view)</span><br><span class="line">             container.frame.size <span class="operator">=</span> <span class="type">CGSize</span>(width: <span class="type">UIScreen</span>.main.bounds.size.width, height: container.subviews.last<span class="operator">!</span>.frame.maxY)</span><br><span class="line">             <span class="keyword">return</span> currentY <span class="operator">+</span> view.frame.size.height</span><br><span class="line">         &#125;)</span><br><span class="line">         <span class="keyword">return</span> container</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个Result builder，使用<code>@resultBuilder</code>注解会要求我们添加一个<code>buildBlock</code>方法，实现这个方法，把我们外面传进来的多个View放进去<code>VieContainer</code>容器中，然后实现<code>buildFinalResult</code>在编写结束的时候把<br><code>VieContainer</code>放进去<code>ScrollView</code>容器中</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@resultBuilder</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScrollableViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildBlock</span>(<span class="keyword">_</span> <span class="params">components</span>: <span class="type">ViewBuilder</span>...)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ViewContainer</span>(contents: components)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildFinalResult</span>(<span class="keyword">_</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ScrollableContainer</span>(contents: [component])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这时候我们通过新增的<code>ScrollableViewBuilder</code>来创建一个方法，这里的闭包就是待会我们要写DSL的地方</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">build</span>(<span class="meta">@ScrollableViewBuilder</span> <span class="params">content</span>: () -&gt; <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> content()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个方法传入一个闭包，这个由于我们已经实现了<code>buildBlock</code>，所以<code>content</code>被<code>@ScrollableViewBuilder</code>修饰之后，会自动将闭包内的东西转化成多参数，传入<code>buildBlock</code>方法，在那里面我们把各种各样的<code>View</code>给添加到<code>ViewContainer</code>上，方法调用如下</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> build &#123;</span><br><span class="line">    <span class="type">RedView</span>()</span><br><span class="line">    <span class="type">BlueView</span>()</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">view.addSubview(result.build())</span><br></pre></td></tr></table></figure><p> 这时候运行效果同上图一致</p></li><li><p>接下来我们需要让这个闭包内支持if语句、else if语句、else语句和for语句，</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScrollableViewBuilder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildBlock</span>(<span class="keyword">_</span> <span class="params">components</span>: <span class="type">ViewBuilder</span>...)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">ScrollableContainer</span>(contents: components)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 表示if语句</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildEither</span>(<span class="params">first</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> component</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 表示eles if语句</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildEither</span>(<span class="params">second</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> component</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 表示else语句和其他的可选值（即？修饰的View）</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildOptional</span>(<span class="keyword">_</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>?)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> component <span class="operator">??</span> <span class="type">DefaultView</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后我们试一试这么写</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> build &#123;</span><br><span class="line">    <span class="type">RedView</span>()</span><br><span class="line">    <span class="type">BlueView</span>()</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">    <span class="keyword">if</span> flag <span class="operator">==</span> <span class="number">1</span> &#123;</span><br><span class="line">        <span class="type">RedView</span>()</span><br><span class="line">        <span class="type">RedView</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> flag <span class="operator">==</span> <span class="number">2</span> &#123;</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> flag <span class="operator">==</span> <span class="number">3</span> &#123;</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">BlueView</span>()</span><br><span class="line">        <span class="type">BlueView</span>()</span><br><span class="line">        <span class="type">BlueView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当flag = 1的时候，首先两个<code>RedView()</code>会先进入<code>buildBlock</code>方法，然后被包装成一个<code>ViewContainer</code>，然后再进去<code>buildEither(first component: ViewBuilder)</code>方法，这里我没处理就直接把传进来的值返回出去了</p><p> 当flag = 2 或者 flag = 3 的时候，首先括号内的多个<code>GreenView()</code>会先进入<code>buildBlock</code>方法，然后被包装成一个<code>ViewContainer</code>，然后再进去<code>buildEither(second component: ViewBuilder)</code>方法，这里我没处理就直接把传进来的值返回出去了</p><p> 当 flag 为其他值的时候，首先括号内的多个<code>BlueView()</code>会先进入<code>buildBlock</code>方法，然后被包装成一个<code>ViewContainer</code>，然后再进去<code>buildEither(second component: ViewBuilder)</code>方法。当没有写<code>eles</code>语句的时候，需要实现<code>buildOptional(_ component: ViewBuilder?)</code>方法，去处理没有进入<code>if</code>语句而导致的不返回<code>View</code>的情况，如果没有写<code>else</code>语句，那么不会进入<code>buildBlock</code>，会直接取空值情况下你返回的默认<code>View</code>。</p></li><li><p>处理for语句，比如这样</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> build &#123;</span><br><span class="line">    <span class="type">RedView</span>()</span><br><span class="line">    <span class="type">BlueView</span>()</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">2</span> &#123;</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">        <span class="type">BlueView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>for</code>里面需要返回3个<code>GreenView+BlueView</code>，这里他每次调用for的括号里面的内容，都会走一遍<code>buildBlock</code>把里面的<code>GreenView+BlueView</code>封装成一个<code>ViewContainer</code>，所以这里会产生3个<code>ViewContainer</code>，最后这三个会变成一个数组，进入<code>buildArray</code>方法，再封装成一个<code>ViewContainer</code>，代码如下</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@resultBuilder</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScrollableViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildBlock</span>(<span class="keyword">_</span> <span class="params">components</span>: <span class="type">ViewBuilder</span>...)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ViewContainer</span>(contents: components)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildEither</span>(<span class="params">first</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> component</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildEither</span>(<span class="params">second</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> component</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildOptional</span>(<span class="keyword">_</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>?)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> component <span class="operator">??</span> <span class="type">WhiteView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildArray</span>(<span class="keyword">_</span> <span class="params">components</span>: [<span class="type">ViewBuilder</span>])</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ViewContainer</span>(contents: components)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildFinalResult</span>(<span class="keyword">_</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ScrollableContainer</span>(contents: [component])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理表达式，如果我们要在DSL里面插一些除了<code>View</code>之外的一些东西，那么就需要添加对应的处理方法，比如</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> build &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a123&quot;</span>)</span><br><span class="line">    <span class="type">RedView</span>()</span><br><span class="line">    <span class="type">BlueView</span>()</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 针对这个<code>print</code>我们添加表达式处理</p><p> ScrollableViewBuilder</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 针对正常的表达式，就直接返回</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildExpression</span>(<span class="keyword">_</span> <span class="params">expression</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> expression</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 针对特殊的表达式，返回空View</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildExpression</span>(<span class="keyword">_</span> <span class="params">expression</span>: ())</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">EmptyBuilder</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> EmptyBuilder</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EmptyBuilder</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">UIView</span>.<span class="keyword">init</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里就说的差不多了，其他本文没提及到的内容可以参阅<a href="https://developer.apple.com/videos/play/wwdc2021/10253/">Write a DSL in Swift using result builders</a></p><p>本文<a href="https://github.com/Arc-lin/ResultBuilderDemo">Demo</a>地址</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要讲述Swift 5.4的新特性 Result Builder在设计上的一些使用方式&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="Swift" scheme="https://www.arclin.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 -- Runtime API</title>
    <link href="https://www.arclin.cn/post/11ed4e5e.html"/>
    <id>https://www.arclin.cn/post/11ed4e5e.html</id>
    <published>2021-07-17T15:13:00.000Z</published>
    <updated>2022-07-12T16:51:57.241Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述Runtime的一些常用API</p><span id="more"></span><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>动态创建一个类（参数：父类，类名，额外的内存空间）</p><p><code>Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</code></p><p>注册一个类（要在类注册之前添加成员变量）</p><p><code>void objc_registerClassPair(Class cls) </code></p><p>销毁一个类</p><p><code>void objc_disposeClassPair(Class cls)</code></p><p>获取isa指向的Class</p><p><code>Class object_getClass(id obj)</code></p><p>设置isa指向的Class</p><p><code>Class object_setClass(id obj, Class cls)</code></p><p>判断一个OC对象是否为Class</p><p><code>BOOL object_isClass(id obj)</code></p><p>判断一个Class是否为元类</p><p><code>BOOL class_isMetaClass(Class cls)</code></p><p>获取父类</p><p><code>Class class_getSuperclass(Class cls)</code></p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>获取一个实例变量信息</p><p><code>Ivar class_getInstanceVariable(Class cls, const char *name)</code></p><p>拷贝实例变量列表（最后需要调用free释放）</p><p><code>Ivar *class_copyIvarList(Class cls, unsigned int *outCount)</code></p><p>设置和获取成员变量的值</p><p><code>void object_setIvar(id obj, Ivar ivar, id value)</code></p><p><code>id object_getIvar(id obj, Ivar ivar)</code></p><p>动态添加成员变量（已经注册的类是不能动态添加成员变量的,alignment一般传1，types传成员变量类型，如<code>@encode(int)</code>，<code>@encode(NSObject *)</code>）</p><p><code>BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types)</code></p><p>获取成员变量的相关信息</p><p><code>const char *ivar_getName(Ivar v)</code></p><p><code>const char *ivar_getTypeEncoding(Ivar v)</code></p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>获取一个属性</p><p><code>objc_property_t class_getProperty(Class cls, const char *name)</code></p><p>拷贝属性列表（最后需要调用free释放）</p><p><code>objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</code></p><p>动态添加属性</p><p><code>BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)</code></p><p>动态替换属性</p><p><code>void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)</code></p><p>获取属性的一些信息</p><p><code>const char *property_getName(objc_property_t property)</code></p><p><code>const char *property_getAttributes(objc_property_t property)</code></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>获得一个实例方法、类方法</p><p><code>Method class_getInstanceMethod(Class cls, SEL name)</code></p><p><code>Method class_getClassMethod(Class cls, SEL name)</code></p><p>方法实现相关操作</p><p><code>IMP class_getMethodImplementation(Class cls, SEL name) </code></p><p><code>IMP method_setImplementation(Method m, IMP imp)</code></p><p>方法交换（方法交换之后会清空方法缓存）<br><code>void method_exchangeImplementations(Method m1, Method m2) </code></p><p>拷贝方法列表（最后需要调用free释放）</p><p><code>Method *class_copyMethodList(Class cls, unsigned int *outCount)</code></p><p>动态添加方法</p><p><code>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</code></p><p>动态替换方法（不存在原有方法则动态添加该方法并且返回nil）</p><p><code>IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)</code></p><p>获取方法的相关信息（带有copy的需要调用free去释放）</p><p><code>SEL method_getName(Method m)</code></p><p><code>IMP method_getImplementation(Method m)</code></p><p><code>const char *method_getTypeEncoding(Method m)</code></p><p><code>unsigned int method_getNumberOfArguments(Method m)</code></p><p><code>char *method_copyReturnType(Method m)</code></p><p><code>char *method_copyArgumentType(Method m, unsigned int index)</code></p><p>选择器相关</p><p><code>const char *sel_getName(SEL sel)</code></p><p><code>SEL sel_registerName(const char *str)</code></p><p>用block作为方法实现</p><p><code>IMP imp_implementationWithBlock(id block)</code></p><p><code>id imp_getBlock(IMP anImp)</code></p><p><code>BOOL imp_removeBlock(IMP anImp)</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要简述Runtime的一些常用API&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- 方法、消息发送与super关键字</title>
    <link href="https://www.arclin.cn/post/5ed61a9.html"/>
    <id>https://www.arclin.cn/post/5ed61a9.html</id>
    <published>2021-06-28T17:11:00.000Z</published>
    <updated>2022-07-12T16:51:57.241Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述类（元类）对象里面的方法缓存、消息发送（包括消息发送，动态方法解析与消息转发）与super关键字的底层原理</p><span id="more"></span><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Class对象的结构"><a href="#Class对象的结构" class="headerlink" title="Class对象的结构"></a>Class对象的结构</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache; <span class="comment">// 方法缓存</span></span><br><span class="line">    class_data_bits_t bits; <span class="comment">// 用于获取具体的类信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>bits</code>成员变量与<code>FAST_DATA_MASK</code>进行一次与运算之后，会获得一个其属性可读可写的对象的地址，这个对象长这样</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    <span class="keyword">const</span> clsss_ro_t *ro;</span><br><span class="line">    method_array_t * methods; <span class="comment">// 方法列表</span></span><br><span class="line">    property_array_t *properties; <span class="comment">// 属性列表</span></span><br><span class="line">    protocol_array_t protocols; <span class="comment">// 协议列表</span></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>class_ro_t</code>里面存放的是类的原始信息(不包括分类里面的东西)，是仅可读的，结构如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    unit32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize; <span class="comment">// instance对象占用的内存空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP__64__</span></span><br><span class="line">    uint32_t reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> uint8_t *ivarLayout;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name; <span class="comment">// 类名</span></span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars; <span class="comment">// 成员变量列表</span></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIverLayout;</span><br><span class="line">    property_list_t * baseProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h3><p><code>class_rw_t</code>里面的methods、properties、protocols是二维数组，是可读可写的，比如方法列表随时可以新增<code>method_list_t</code>类型的数据进去。<code>class_rw_t</code>包含了类的初始内容和分类的内容，其中方法列表类似如下结构</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">method_array_t: [</span><br><span class="line">    method_list_t : [</span><br><span class="line">      method_t,</span><br><span class="line">      method_t,</span><br><span class="line">      method_t</span><br><span class="line">    ],</span><br><span class="line">    method_list_t : [</span><br><span class="line">      method_t,</span><br><span class="line">      method_t,</span><br><span class="line">      method_t</span><br><span class="line">    ],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>objc_class</code>内有一个<code>data()</code>函数，其返回值一开始是指向<code>class_ro_t</code>类型的对象的。在合并分类内的内容时，才会产生<code>class_rw_t</code>类型的对象，并指向这个对象。可以参考runtime源码，<code>objc-runtime-new.mm</code>中<code>realizeClassWithoutSwift</code>函数的实现，这里贴出关键部分</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class realizeClassWithoutSwift(Class cls, Class previously)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    auto ro = (<span class="keyword">const</span> class_ro_t *)cls-&gt;data();</span><br><span class="line">    auto isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">        rw = cls-&gt;data();</span><br><span class="line">        ro = cls-&gt;data()-&gt;ro();</span><br><span class="line">        ASSERT(!isMeta);</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">        rw = objc::zalloc&lt;class_rw_t&gt;();</span><br><span class="line">        rw-&gt;set_ro(ro);</span><br><span class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">        cls-&gt;setData(rw);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h3><p><code>class_ro_t</code>里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，所以不能新增内容，包含了类的初始内容，其中方法列表类似如下结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">method_list_t</span> : [</span><br><span class="line">  <span class="keyword">method_t</span>,</span><br><span class="line">  <span class="keyword">method_t</span>,</span><br><span class="line">  <span class="keyword">method_t</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>在runtime源码，<code>objc-runtime-new.mm</code>中的<code>attachCategories</code>方法中我们可以看到分类合并到<code>class_rw_t</code>对象的过程，比如方法的合并如下</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">method_list_t *mlist = entry.cat-&gt;methods<span class="constructor">ForMeta(<span class="params">isMeta</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mcount<span class="operator"> == </span><span class="number">64</span>) &#123;</span><br><span class="line">        prepare<span class="constructor">MethodLists(<span class="params">cls</span>, <span class="params">mlists</span>, <span class="params">mcount</span>, NO, <span class="params">fromBundle</span>, <span class="params">__func__</span>)</span>;</span><br><span class="line">        rwe-&gt;methods.attach<span class="constructor">Lists(<span class="params">mlists</span>, <span class="params">mcount</span>)</span>;</span><br><span class="line">        mcount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mlists<span class="literal">[ATTACH<span class="identifier">_BUFSIZ</span> - <span class="operator">++</span><span class="identifier">mcount</span>]</span> = mlist;</span><br><span class="line">    fromBundle <span class="pattern-match">|= entry.hi-&gt;is<span class="constructor">Bundle()</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><ul><li><code>method_t</code>是对方法/函数的封装（下面是缩减版定义）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function">SEL <span class="title">name</span><span class="params">()</span></span>; <span class="comment">// 函数名</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">types</span><span class="params">()</span></span>; <span class="comment">// 编码（返回值类型、参数类型）</span></span><br><span class="line">    <span class="function">IMP <span class="title">imp</span><span class="params">(<span class="keyword">bool</span> needsLock)</span></span>; <span class="comment">// 指向函数的指针（函数地址）</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>IMP</code>代表具体函数的实现</p><p>  <code>typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</code></p></li><li><p><code>SEL</code>可以代表方法\函数名，一般叫做选择器，底层结构跟<code>char *</code>类似</p><p>  <code>typedef struct objc_selector *SEL</code>;</p><ul><li>可以通过<code>@selector()</code>和<code>sel_registerName()</code>获得</li><li>可以通过<code>sel_getName()</code>和<code>NSStringFromSelector()</code>转成字符串</li><li>不同类中相同名字的方法，所对应的方法选择器是相同的</li></ul></li><li><p><code>types</code>包含了函数返回值、参数编码的字符串，称作<code>Type Encodings</code>（类型编码），具体可以参考<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100">苹果官方文档</a></p><ul><li>比如<code>-（void）test:(int)a;</code>的方法编码为<code>v@:i</code>，v = void,@表示指针变量(因为编译后第一个参数是self)，：表示选择器(因为编译后第二个参数是_cmd)，</li><li>有时类型编码会带上数字，比如<code>v16@0:8</code>，第一个数字表示这个函数的参数一共占用16个字节，第二个数字开始往后的数字都代表偏移值，0代表第一个参数的字节偏移值为0，第三个数字8代表偏移8个字节，也就是第一个参数已经占用了8个字节了，所以第二个参数就从第8个字节开始</li></ul></li></ul><h3 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h3><ul><li>Class内部结构中有个方法缓存（cache_t），用散列表来缓存曾经调用过的方法，可以提高方法的查找速度</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cache_t &#123;</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            explicit_atomic&lt;mask_t&gt;    _maybeMask; <span class="comment">// 散列表的长度 - 1</span></span><br><span class="line">            uint16_t                   _flags;</span><br><span class="line">            uint16_t                   _occupied; <span class="comment">// 已经缓存的方法数量</span></span><br><span class="line">        &#125;;</span><br><span class="line">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;</span><br><span class="line">    &#125;;   </span><br><span class="line">    <span class="keyword">struct</span> bucket_t *buckets() <span class="keyword">const</span>;</span><br><span class="line">    mask_t mask() <span class="keyword">const</span>;</span><br><span class="line">    mask_t occupied() <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，通过<code>buckets()</code>函数我们可以得知<code>_bucketsAndMaybeMask</code>是一个存放<code>bucket_t</code>数组的指针（即<code>_bucketsAndMaybeMask</code>指针指向的是数组的第一个元素），是通过位运算取出来的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> bucket_t *cache_t::buckets() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    uintptr_t addr = _bucketsAndMaybeMask.load(memory_order_relaxed);</span><br><span class="line">    <span class="keyword">return</span> (bucket_t *)(addr &amp; bucketsMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>bucket_t</code>的结构如下</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="class">bucket_t </span>&#123;</span><br><span class="line">    explicit_atomic<span class="params">&lt;uintptr_t&gt;</span> _imp; <span class="comment">// 函数的内存地址</span></span><br><span class="line">    explicit_atomic<span class="params">&lt;SEL&gt;</span> _sel; <span class="comment">// SEL作为key</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过IMP和SEL，我们就可以调用方法了，所以综上所述，一个实例对象调用方法，其类对象从方法缓存里面找方法的大概流程就是</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取sel : class - isa - 偏移<span class="number">16</span>个字节 - <span class="keyword">cache_t </span>- <span class="keyword">buckets() </span>- [<span class="keyword">bucket_t] </span>- 计算出下标index - <span class="keyword">bucket_t </span>- sel()</span><br><span class="line">获取imp : class - isa - 偏移<span class="number">16</span>个字节 - <span class="keyword">cache_t </span>- <span class="keyword">buckets() </span>- [<span class="keyword">bucket_t] </span>- 计算出下标index - <span class="keyword">bucket_t </span>- imp(nil,cls)</span><br></pre></td></tr></table></figure><p>另外<code>_bucketsAndMaybeMask</code>之所以叫这个名字是因为它不仅存放着<code>buckets</code>还存放着<code>maybeMask</code>，在arm64位真机环境下，取高16位，如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mask_t cache_t::mask() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    uintptr_t maskAndBuckets = _bucketsAndMaybeMask.load(memory_order_relaxed);</span><br><span class="line">    <span class="comment">//maskShift 为48,</span></span><br><span class="line">    <span class="keyword">return</span> maskAndBuckets &gt;&gt; maskShift;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法缓存的流程"><a href="#方法缓存的流程" class="headerlink" title="方法缓存的流程"></a>方法缓存的流程</h4><p>先看看runtime源码中，将方法插入缓存的函数（摘抄核心流程）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cache_t::insert(SEL sel, IMP imp, <span class="keyword">id</span> receiver)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//对_occupied赋值 + 1。首次 newOccupied = 1。</span></span><br><span class="line">    mask_t newOccupied = occupied() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//旧容量，（mask + 1） 或者 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> oldCapacity = capacity(), capacity = oldCapacity;</span><br><span class="line">    <span class="comment">//是否为空，首次进入这里</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(isConstantEmptyCache())) &#123;</span><br><span class="line">        <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">        <span class="comment">//默认容量给4</span></span><br><span class="line">        <span class="keyword">if</span> (!capacity) capacity = INIT_CACHE_SIZE;<span class="comment">//1 &lt;&lt; 2 = 4</span></span><br><span class="line">        <span class="comment">//0 4 false 开辟新的容器空间。由于旧容器为空这里不需要释放传false。</span></span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="comment">/* freeOld */</span><span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//newOccupied + 1 (相当于 _occupied + 2) &lt;= capacity * 3 / 4 容量够的时候什么都不做，直接插入。&lt;=75%的容积正常插入，否则扩容。</span></span><br><span class="line">    <span class="comment">//## ⚠️在arm64位的情况下，CACHE_END_MARKER 0 扩容条件为：7 / 8 87.5% 这个时候CACHE_ALLOW_FULL_UTILIZATION 为 1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fastpath(newOccupied + <span class="built_in">CACHE_END_MARKER</span> &lt;= cache_fill_ratio(capacity))) &#123;</span><br><span class="line">        <span class="comment">// Cache is less than 3/4 or 7/8 full. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CACHE_ALLOW_FULL_UTILIZATION</span></span><br><span class="line">    <span class="comment">//capacity &lt;= 1&lt;&lt;3 (8), _occupied + 1（CACHE_END_MARKER为0） &lt;= 容量。少于8个元素的时候允许100%占满。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (capacity &lt;= FULL_UTILIZATION_CACHE_SIZE &amp;&amp; newOccupied + <span class="built_in">CACHE_END_MARKER</span> &lt;= capacity) &#123;</span><br><span class="line">        <span class="comment">// Allow 100% cache utilization for small buckets. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//扩容</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//容量不为空返回 2倍的容量，否则返回4</span></span><br><span class="line">        capacity = capacity ? capacity * <span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line">        <span class="comment">//MAX_CACHE_SIZE 1&lt;&lt;16 = 2^16。最大缓存65536</span></span><br><span class="line">        <span class="keyword">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">            capacity = MAX_CACHE_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开辟新的容器控件，释放旧的空间。</span></span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从_bucketsAndMaybeMask获取buckets</span></span><br><span class="line">    bucket_t *b = buckets();</span><br><span class="line">    mask_t m = capacity - <span class="number">1</span>;<span class="comment">//首次是4-1</span></span><br><span class="line">    <span class="comment">//计算插入的index</span></span><br><span class="line">    mask_t begin = cache_hash(sel, m);</span><br><span class="line">    mask_t i = begin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for the first unused slot and insert there.</span></span><br><span class="line">    <span class="comment">// There is guaranteed to be an empty slot.</span></span><br><span class="line">    <span class="comment">//循环判断插入数据。</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//能走到这里大概率是cache不存在，所以这里走fastpath</span></span><br><span class="line">        <span class="keyword">if</span> (fastpath(b[i].sel() == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">//Occupied + 1</span></span><br><span class="line">            incrementOccupied();</span><br><span class="line">            <span class="comment">//buckets中插入bucket</span></span><br><span class="line">            b[i].set&lt;Atomic, Encoded&gt;(b, sel, imp, cls());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已经存在了，不进行任何处理。有可能是其它线程插入的。</span></span><br><span class="line">        <span class="keyword">if</span> (b[i].sel() == sel) &#123;</span><br><span class="line">            <span class="comment">// The entry was added to the cache by some other thread</span></span><br><span class="line">            <span class="comment">// before we grabbed the cacheUpdateLock.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cache_next为了防止hash冲突。再hash了一次（下文会讲到）。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (fastpath((i = cache_next(i, m)) != begin));</span><br><span class="line">    <span class="comment">//异常处理</span></span><br><span class="line">    bad_cache(receiver, (SEL)sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首次进入isConstantEmptyCache分支。会创建一个容量为4的空buckets。这个时候由于旧buckets不存在不需要释放所以参数传递false。</li><li>当容量大于等于3/4或7/8的情况下扩容。arm64的条件下为7 / 8。</li><li>arm64条件下容量小于等于8的时候会占用100%才扩容。</li><li>扩容是直接翻倍，默认值4。最大值MAX_CACHE_SIZE为216(65536)。在扩容的时候直接释放了旧值。</li><li>mask值为capacity - 1</li><li>通过cache_hash（下文会提及的散列表算法）计算插入的index，后面会通过cache_next再进行计算hash解决冲突问题。</li><li>循环判断通过b[i].set插入bucket数据。</li><li><strong>reallocate函数在开辟控件的同时，把缓存给直接清空了</strong>，清空之后再把现在要缓存的方法放进去，所以扩容后occupied会为1。</li></ul><h4 id="散列表（哈希表）缓存"><a href="#散列表（哈希表）缓存" class="headerlink" title="散列表（哈希表）缓存"></a>散列表（哈希表）缓存</h4><ul><li><p>方法缓存的容器，不是简单的数组，而是用散列表的方式进行存储。</p><p>假如现在散列表长度为10，那么mask（即cache_t里面的_maybeMask）就是10-1 = 9，当selector传进来的时候，会跟mask进行一次与运算，如下：</p><p><code>@selector(personTest) &amp; mask = 4</code></p><p>假如得到的结果是4的话，那么就会插在列表的下标为4的位置，其他位置因为已经开辟好空间了，所以有值就放值，没值就NULL</p><p>这种列表的好处是，当想取到特定的bucket_t的时候，只需要把selector跟mask进行一次与运算，就可以直接得到下标，然后直接从列表取出，这样子就不用遍历查找了，大大节约了性能。</p><p>另外，由于与运算的特性，跟mask进行与运算之后的值，都不可能比mask更大，这样子就保证不会插入越界的位置。</p></li><li><p>如果通过计算后的下标值，插入列表的时候发现已经有东西了那怎么办？</p><p>  这也就是所谓的Hash冲突。为了处理这种问题，系统会调用<code>cache_next</code>函数</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">mask_t</span> <span class="title">cache_next</span><span class="params">(<span class="keyword">mask_t</span> i, <span class="keyword">mask_t</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i ? i<span class="number">-1</span> : mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  也就是说如果<code>@selector(personTest) &amp; mask = 4</code>的4已经有东西了，那么就取 4 - 1 = 3，如果3还有东西，就放在2的位置，如果2还有，就放在1，以此类推，如果直到0都还没有可以插入的位置，那么就从mask的位置开始找，也就是9，然后再找9看看是否可以插入，插不进去再找8，以此类推，找到为止。</p><p>  由于列表在存放数量达到容量的87.5%的时候就会两倍的扩容（arm64），扩容后又会清空缓存，所以一定能找到合适的位置插入的。</p></li></ul><h2 id="消息发送机制"><a href="#消息发送机制" class="headerlink" title="消息发送机制"></a>消息发送机制</h2><p>调用一个不存在的方法的时候，他会经历这么一个流程</p><p>消息发送 - （找不到方法的话） -&gt; 动态方法解析 - （没有实现的话） -&gt; 消息转发 -&gt; （没有实现的话） -&gt; 抛出异常</p><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p>假如我们这么调用一个方法</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[person personTest]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>底层会转换为</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(person,sel_registerName(<span class="string">&quot;personTest&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>这里的person我们称作消息接受者（receiver），就是调用方法的对象，如果这里还是调用类方法的话，那么这里就会传入一个类对象</li><li><code>sel_registerName()</code>函数等价于<code>@selector</code></li><li>为了性能，<code>objc_msgSend</code>方法底层是使用汇编和C++实现的</li></ul><p>消息发送的流程如下：</p><ol><li>receiver 是否为空，如果是退出，否则继续</li><li>从receiver的类对象（如果传入的是类则找的是元类对象，下文统称为receiverClass）的cache中查找方法，如果找到则调用方法，如果找不到则继续</li><li>从receiverClass中的<code>class_rw_t</code>中查找方法，如果找到则调用方法，并将方法插入缓存，如果找不到则继续</li><li>从<code>superClass</code>的cache中查找方法，有则调用并缓存到当前receiverClass的cache中(不是superClass的cache),否则继续</li><li>从<code>superClass</code>的<code>class_rw_t</code>中找，有则调用并缓存到receiverClass的cache中，否则继续</li><li>继续通过<code>superClass</code>的<code>superClass</code>找方法，流程回到4，直到再也没有父类了，并且也找不到方法，那么将会进入动态方法解析阶段。</li></ol><p>其中：</p><ul><li>如果是从<code>class_rw_t</code>中查找方法，若方法列表已经排序好，那么就使用二分查找法查找</li><li>如果是还没排序的方法，那么就使用遍历的方法查找</li><li>在缓存中查找方法的过程也称作快速查找（使用汇编实现），在<code>class_rw_t</code>中查找方法的过程也称作慢速查找(使用汇编和C++实现)，C++部分方法源码在<code>lookUpImpOrForward</code>函数中，如下：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(<span class="keyword">id</span> inst, SEL sel, Class cls, <span class="keyword">int</span> behavior)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> IMP forward_imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    IMP imp = <span class="literal">nil</span>;</span><br><span class="line">    Class curClass;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    <span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(behavior &amp; LOOKUP_CACHE)) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done_nolock;</span><br><span class="line">    &#125;</span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!cls-&gt;isRealized())) &#123;</span><br><span class="line">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</span><br><span class="line">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    curClass = cls;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> attempts = unreasonableClassCount();;) &#123;</span><br><span class="line">        <span class="comment">// curClass method list.</span></span><br><span class="line">        Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slowpath((curClass = curClass-&gt;superclass) == <span class="literal">nil</span>)) &#123;</span><br><span class="line">            imp = forward_imp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(--attempts == <span class="number">0</span>)) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Memory corruption in class list.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Superclass cache.</span></span><br><span class="line">        imp = cache_getImp(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (slowpath(imp == forward_imp)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fastpath(imp)) &#123;</span><br><span class="line">            <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">        behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">        <span class="keyword">return</span> resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">    &#125;</span><br><span class="line"> done:</span><br><span class="line">    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"> done_nolock:</span><br><span class="line">    <span class="keyword">if</span> (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>慢速查找流程图：</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/47b512631098428e8bc60162e1df4ab7.png" ><p>消息发送流程图：</p><img src="https://p9-tt.byteimg.com/origin/pgc-image/70dfbbc7f61a4a9fac15e5ff1af809b4.png"><h3 id="动态方法解析（也称：动态方法决议）"><a href="#动态方法解析（也称：动态方法决议）" class="headerlink" title="动态方法解析（也称：动态方法决议）"></a>动态方法解析（也称：动态方法决议）</h3><p>当消息发送流程找不到方法后就会进入动态方法解析流程。</p><p>动态方法解析是当消息发送阶段找不到方法的时候，开发者可以通过重写特定方法（如果是类方法就重写<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>，如果是对象方法就重写<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>），给原先不存在的方法添加方法实现。主要是用到runtime里面的<code>class_addMethod</code>函数，并且动态解析后，会重新走”消息发送“的流程</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>假如这里的person没有实现print方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [Person new];</span><br><span class="line">[person print];</span><br></pre></td></tr></table></figure><p>那我们可以在<code>Person.m</code>添加一个方法实现用来替换丢失的<code>print</code>，这里我们用<code>truePrint</code>来替代</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)truePrint &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;true print&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取truePrint方法的Method对象</span></span><br><span class="line">        Method truePrint = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(truePrint));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 动态添加print方法的实现，通过method_getImplementation获取到方法的函数指针，通过method_getTypeEncoding拿到方法的函数编码即 v@: 或 v16@0:8</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, method_getImplementation(truePrint), method_getTypeEncoding(truePrint));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回YES代表有动态添加方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method的结构"><a href="#Method的结构" class="headerlink" title="Method的结构"></a>Method的结构</h4><p>点击Method我们可以看到结构如下</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></span><br></pre></td></tr></table></figure><p>而<code>ojbc_method</code>的定义如下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">struct</span> objc_method &#123;</span><br><span class="line">    <span class="attribute">SEL</span> _Nonnull method_name;</span><br><span class="line">    <span class="attribute">char</span> * _Nullable method_types;</span><br><span class="line">    <span class="attribute">IMP</span> _Nonnull method_imp;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>可以看到跟上面所说的<code>method_t</code>是类似的东西</p><p>以下是一些拿到<code>Method</code>对象后可以使用的一些函数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用，但是不接收返回值类型为结构体</span></span><br><span class="line">method_invoke</span><br><span class="line"><span class="comment">// 函数调用，但是接收返回值类型为结构体</span></span><br><span class="line">method_invoke_stret</span><br><span class="line"><span class="comment">// 获取函数名</span></span><br><span class="line">method_getName</span><br><span class="line"><span class="comment">// 获取函数实现IMP</span></span><br><span class="line">method_getImplementation</span><br><span class="line"><span class="comment">// 获取函数type encoding</span></span><br><span class="line">method_getTypeEncoding</span><br><span class="line"><span class="comment">// 复制返回值类型</span></span><br><span class="line">method_copyReturnType</span><br><span class="line"><span class="comment">// 复制参数类型</span></span><br><span class="line">method_copyArgumentType</span><br><span class="line"><span class="comment">// 获取返回值类型</span></span><br><span class="line">method_getReturnType</span><br><span class="line"><span class="comment">// 获取参数个数</span></span><br><span class="line">method_getNumberOfArguments</span><br><span class="line"><span class="comment">// 获取函数参数类型</span></span><br><span class="line">method_getArgumentType</span><br><span class="line"><span class="comment">// 获取函数描述</span></span><br><span class="line">method_getDescription</span><br><span class="line"><span class="comment">// 设置函数实现IMP</span></span><br><span class="line">method_setImplementation</span><br><span class="line"><span class="comment">// 交换函数的实现IMP</span></span><br><span class="line">method_exchangeImplementations</span><br></pre></td></tr></table></figure><h4 id="Runtime中的原理"><a href="#Runtime中的原理" class="headerlink" title="Runtime中的原理"></a>Runtime中的原理</h4><p>在上面的消息发送的流程函数<code>lookUpImpOrForward</code>中，有一段代码如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">    behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">    return resolve<span class="constructor">Method_locked(<span class="params">inst</span>, <span class="params">sel</span>, <span class="params">cls</span>, <span class="params">behavior</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当找不到消息的时候就会进入动态方法解析的流程即<code>resolveMethod_locked</code>，如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NEVER_INLINE IMP resolveMethod_locked(<span class="keyword">id</span> inst, SEL sel, Class cls, <span class="keyword">int</span> behavior) &#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveClassMethod(inst, sel, cls);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNilTryCache(inst, sel, cls)) &#123;</span><br><span class="line">            resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForwardTryCache(inst, sel, cls, behavior);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面我们可以发现<code>resolveInstanceMethod</code>和<code>resolveClassMethod</code>两个函数，分别是实现实例方法的动态消息解析和类方法的动态消息解析，这两个长得差不多，所以我们拿实例对象的函数查看一下</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static void resolveInstanceMethod(id inst, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    ASSERT(<span class="function"><span class="title">cls</span>-&gt;</span>isRealized());</span><br><span class="line">    SEL resolve_sel = @selector(resolveInstanceMethod:);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (!lookUpImpOrNilTryCache(cls, resolve_sel, cls-&gt;</span>ISA(<span class="comment">/*authenticated*/</span><span class="literal">true</span>))) &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    bool resolved = msg(cls, resolve_sel, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveInstanceMethod adds to self a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNilTryCache(inst, sel, cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;RESOLVE: method %c[%s %s] &quot;</span></span><br><span class="line">                         <span class="string">&quot;dynamically resolved to %p&quot;</span>, </span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>isMetaClass() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn&#x27;t add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</span></span><br><span class="line">                         <span class="string">&quot;, but no new implementation of %c[%s %s] was found&quot;</span>,</span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel), </span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>isMetaClass() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们可以看到对<code>resolveInstanceMethod</code>方法进行了一次<code>objc_msgSend</code>调用，调用之后又执行了<code>lookUpImpOrNilTryCache</code>函数进行了缓存，如果缓存成功，那么下次调用这个方法就不会在进入动态方法解析阶段，直接通过消息发送阶段就调用成功了。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>根据我们以前所学的知识可以知道，方法查找的流程为</p><p>实例方法：类 – 父类 – 父类 – … – 根类 – nil</p><p>类方法：元类 – 父元类 – 父元类 – … – 根元类 – 根类 – nil</p><p>也就是说丢失的方法最后都会回到根类去找方法，一般情况下是<code>NSObject</code></p><p>通过这个特性，我们可以直接在<code>NSObject</code>上添加分类，然后实现动态解析方法，根据方法名前缀进行判断，然后统一处理未被找到的方法添加默认实现。通过这种方式我们可以减少一些找不到方法导致的崩溃问题，提升用户体验。</p><h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>如果没有实现动态方法解析，那么将进入消息转发阶段。消息转发即把消息交给别人发送的意思。</p><p>从上面的<code>lookUpImpOrForward</code>函数的源码我们可以看到，最后是调用了<code>_objc_msgForward_impcache</code>这个函数，这个函数是通过汇编实现的</p><p>要实现消息转发，我们有两种方式，一种是实现一个方法<code>-forwardingTargetForSelector</code>，一种是实现<code>-methodSignatureForSelector</code>和<code>-forwardInvocation</code>，比如</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[Student alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了这个方法之后，最后系统会去我们提供的<code>Student</code>对象去寻找<code>print</code>方法，找到了的话就会进行调用。注意这个方法每次都会进来，每次都会生成新的<code>Student</code>对象对其<code>print</code>方法进行调用。</p><p>如果<code>forwardingTargetForSelector</code>没实现或者返回空的话</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就会寻找<code>-methodSignatureForSelector</code>和<code>-forwardInvocation</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 方法签名： 返回值类型、参数类型</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">&quot;v16@0:8&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数</span></span><br><span class="line"><span class="comment">/// anInvocation.target 方法调用者</span></span><br><span class="line"><span class="comment">/// anInvocation.selector 方法名</span></span><br><span class="line"><span class="comment">//// [anInvocation getArgument:NULL atIndex:0] 方法参数</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:[[Student alloc] init]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们在方法签名中指定方法类型，然后在<code>forwardInvocation</code>方法中，修改target，然后直接调用，这样子就会直接调用Student的print方法了</p><img src="https://p3-tt.byteimg.com/origin/pgc-image/ba2d1d5ff71a49c8913690d6f69fb7d7.png" width=80%><h4 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h4><p>当系统执行到<code>forwardInvocation</code>的时候，无论在方法内有任何实现，都不会执行到<code>doseNotRecognizeSelector</code>（抛出异常），所以实现了就不会崩，即便什么都不做。</p><p>在<code>forwardInvocation</code>内我们可以拿到方法调用的很多信息，比如方法调用者<code>anInvocation.target</code>、方法名<code>anInvocation.selector</code>和方法参数</p><p>比如调用方法为<code>[person print:1]</code>，进入到<code>forwardInvocation</code>后我们可以通过以下方法拿到<code>1</code>这个参数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    [anInvocation getArgument:&amp;a atIndex:<span class="number">2</span>]; <span class="comment">// 第一个参数是self，第二个是_cmd，所以从下标2开始取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要拿返回值的话，就可以这么做</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:[[Student alloc] init]]; <span class="comment">// 要先调用一下Student的print方法，这里假设返回值是整型</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    [anInvocation getReturnValue:&amp;result];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,result); <span class="comment">/// 这里可以拿到返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NSMethodSignature"><a href="#NSMethodSignature" class="headerlink" title="NSMethodSignature"></a>NSMethodSignature</h4><p><code>[NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;]</code>，注意这里的方法编码要跟下面<code>forwardInvocation</code>要调用的方法的方法编码一致 </p><p>我们除了可以通过方法编码拿到<code>NSMethodSignature</code>对象之外，还可以这么做</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[Student new] methodSignatureForSelector:<span class="keyword">@selector</span>(print)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类方法的消息转发"><a href="#类方法的消息转发" class="headerlink" title="类方法的消息转发"></a>类方法的消息转发</h4><p><code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code></p><p><code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code></p><p><code>+ (void)forwardInvocation:(NSInvocation *)anInvocation</code></p><p>这几个方法也有类方法版本，但是代码补全没出来，但是实际使用是可行的</p><p><code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>在这个方法里面返回的消息接受者既可以是类对象也可以是实例对象。</p><h4 id="synthesize-和-dynamic"><a href="#synthesize-和-dynamic" class="headerlink" title="@synthesize 和 @dynamic"></a>@synthesize 和 @dynamic</h4><p><code>@synthesize</code>用来自动给成员变量名生成<code>setter</code>和<code>getter</code>的声明和实现</p><p><code>@dynamic</code>用来告诉编译器不要自动生成<code>setter</code>和<code>getter</code>的实现（声明还是会声明的），待到运行时开发者自己实现，并且不会为属性实现带下划线的成员变量</p><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>假如我们调用<code>Student</code>实例的一个父类方法</p><p><code>[super run:xx]</code></p><p>那么编译后会变成如下代码</p><p><code>objc_msgSendSuper(self,class_getSuperclass(objc_getClass(&quot;Student&quot;)),sel_registerName(&quot;run&quot;),xx);</code></p><p>所以<code>super</code>发送消息的本质是调用<code>objc_msgSendSuper2</code>函数，最终的消息接受者依旧是<code>self</code>，只是实例方法寻找从父类的类对象开始寻找，类方法从父类的元类对象开始寻找。</p><p>所以当我们调用方法<code>[super class]</code>的时候，跟<code>[self class]</code>没区别，返回结果是一致的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要简述类（元类）对象里面的方法缓存、消息发送（包括消息发送，动态方法解析与消息转发）与super关键字的底层原理&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
