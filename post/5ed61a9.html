<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<meta name="referrer" content="no-referrer" />
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.arclin.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"VOFC7668C9","apiKey":"24c644edc8e7353bf2e8d8e31f03a940","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文主要简述类（元类）对象里面的方法缓存、消息发送（包括消息发送，动态方法解析与消息转发）与super关键字的底层原理">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS 底层原理 --- 方法、消息发送与super关键字">
<meta property="og:url" content="https://www.arclin.cn/post/5ed61a9.html">
<meta property="og:site_name" content="Arclin">
<meta property="og:description" content="本文主要简述类（元类）对象里面的方法缓存、消息发送（包括消息发送，动态方法解析与消息转发）与super关键字的底层原理">
<meta property="og:locale">
<meta property="og:image" content="https://p5-tt.byteimg.com/origin/pgc-image/47b512631098428e8bc60162e1df4ab7.png">
<meta property="og:image" content="https://p9-tt.byteimg.com/origin/pgc-image/70dfbbc7f61a4a9fac15e5ff1af809b4.png">
<meta property="og:image" content="https://p3-tt.byteimg.com/origin/pgc-image/ba2d1d5ff71a49c8913690d6f69fb7d7.png">
<meta property="article:published_time" content="2021-06-28T17:11:00.000Z">
<meta property="article:modified_time" content="2022-07-12T16:51:57.241Z">
<meta property="article:author" content="Arclin">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="底层原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p5-tt.byteimg.com/origin/pgc-image/47b512631098428e8bc60162e1df4ab7.png">

<link rel="canonical" href="https://www.arclin.cn/post/5ed61a9.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>iOS 底层原理 --- 方法、消息发送与super关键字 | Arclin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Arclin" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Arclin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Advocate Technology. Enjoy Technology.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.arclin.cn/post/5ed61a9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/12107804?v=4">
      <meta itemprop="name" content="Arclin">
      <meta itemprop="description" content="Stay hungry,stay foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arclin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          iOS 底层原理 --- 方法、消息发送与super关键字
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-29 01:11:00" itemprop="dateCreated datePublished" datetime="2021-06-29T01:11:00+08:00">2021-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文主要简述类（元类）对象里面的方法缓存、消息发送（包括消息发送，动态方法解析与消息转发）与super关键字的底层原理</p>
<span id="more"></span>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Class对象的结构"><a href="#Class对象的结构" class="headerlink" title="Class对象的结构"></a>Class对象的结构</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache; <span class="comment">// 方法缓存</span></span><br><span class="line">    class_data_bits_t bits; <span class="comment">// 用于获取具体的类信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>bits</code>成员变量与<code>FAST_DATA_MASK</code>进行一次与运算之后，会获得一个其属性可读可写的对象的地址，这个对象长这样</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    <span class="keyword">const</span> clsss_ro_t *ro;</span><br><span class="line">    method_array_t * methods; <span class="comment">// 方法列表</span></span><br><span class="line">    property_array_t *properties; <span class="comment">// 属性列表</span></span><br><span class="line">    protocol_array_t protocols; <span class="comment">// 协议列表</span></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>class_ro_t</code>里面存放的是类的原始信息(不包括分类里面的东西)，是仅可读的，结构如下</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    unit32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize; <span class="comment">// instance对象占用的内存空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP__64__</span></span><br><span class="line">    uint32_t reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> uint8_t *ivarLayout;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name; <span class="comment">// 类名</span></span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars; <span class="comment">// 成员变量列表</span></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIverLayout;</span><br><span class="line">    property_list_t * baseProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h3><p><code>class_rw_t</code>里面的methods、properties、protocols是二维数组，是可读可写的，比如方法列表随时可以新增<code>method_list_t</code>类型的数据进去。<code>class_rw_t</code>包含了类的初始内容和分类的内容，其中方法列表类似如下结构</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">method_array_t: [</span><br><span class="line">    method_list_t : [</span><br><span class="line">      method_t,</span><br><span class="line">      method_t,</span><br><span class="line">      method_t</span><br><span class="line">    ],</span><br><span class="line">    method_list_t : [</span><br><span class="line">      method_t,</span><br><span class="line">      method_t,</span><br><span class="line">      method_t</span><br><span class="line">    ],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>objc_class</code>内有一个<code>data()</code>函数，其返回值一开始是指向<code>class_ro_t</code>类型的对象的。在合并分类内的内容时，才会产生<code>class_rw_t</code>类型的对象，并指向这个对象。可以参考runtime源码，<code>objc-runtime-new.mm</code>中<code>realizeClassWithoutSwift</code>函数的实现，这里贴出关键部分</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class realizeClassWithoutSwift(Class cls, Class previously)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    auto ro = (<span class="keyword">const</span> class_ro_t *)cls-&gt;data();</span><br><span class="line">    auto isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">        rw = cls-&gt;data();</span><br><span class="line">        ro = cls-&gt;data()-&gt;ro();</span><br><span class="line">        ASSERT(!isMeta);</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">        rw = objc::zalloc&lt;class_rw_t&gt;();</span><br><span class="line">        rw-&gt;set_ro(ro);</span><br><span class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">        cls-&gt;setData(rw);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h3><p><code>class_ro_t</code>里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，所以不能新增内容，包含了类的初始内容，其中方法列表类似如下结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">method_list_t</span> : [</span><br><span class="line">  <span class="keyword">method_t</span>,</span><br><span class="line">  <span class="keyword">method_t</span>,</span><br><span class="line">  <span class="keyword">method_t</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在runtime源码，<code>objc-runtime-new.mm</code>中的<code>attachCategories</code>方法中我们可以看到分类合并到<code>class_rw_t</code>对象的过程，比如方法的合并如下</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">method_list_t *mlist = entry.cat-&gt;methods<span class="constructor">ForMeta(<span class="params">isMeta</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mcount<span class="operator"> == </span><span class="number">64</span>) &#123;</span><br><span class="line">        prepare<span class="constructor">MethodLists(<span class="params">cls</span>, <span class="params">mlists</span>, <span class="params">mcount</span>, NO, <span class="params">fromBundle</span>, <span class="params">__func__</span>)</span>;</span><br><span class="line">        rwe-&gt;methods.attach<span class="constructor">Lists(<span class="params">mlists</span>, <span class="params">mcount</span>)</span>;</span><br><span class="line">        mcount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mlists<span class="literal">[ATTACH<span class="identifier">_BUFSIZ</span> - <span class="operator">++</span><span class="identifier">mcount</span>]</span> = mlist;</span><br><span class="line">    fromBundle <span class="pattern-match">|= entry.hi-&gt;is<span class="constructor">Bundle()</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><ul>
<li><code>method_t</code>是对方法/函数的封装（下面是缩减版定义）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function">SEL <span class="title">name</span><span class="params">()</span></span>; <span class="comment">// 函数名</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">types</span><span class="params">()</span></span>; <span class="comment">// 编码（返回值类型、参数类型）</span></span><br><span class="line">    <span class="function">IMP <span class="title">imp</span><span class="params">(<span class="keyword">bool</span> needsLock)</span></span>; <span class="comment">// 指向函数的指针（函数地址）</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>IMP</code>代表具体函数的实现</p>
<p>  <code>typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</code></p>
</li>
<li><p><code>SEL</code>可以代表方法\函数名，一般叫做选择器，底层结构跟<code>char *</code>类似</p>
<p>  <code>typedef struct objc_selector *SEL</code>;</p>
<ul>
<li>可以通过<code>@selector()</code>和<code>sel_registerName()</code>获得</li>
<li>可以通过<code>sel_getName()</code>和<code>NSStringFromSelector()</code>转成字符串</li>
<li>不同类中相同名字的方法，所对应的方法选择器是相同的</li>
</ul>
</li>
<li><p><code>types</code>包含了函数返回值、参数编码的字符串，称作<code>Type Encodings</code>（类型编码），具体可以参考<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100">苹果官方文档</a></p>
<ul>
<li>比如<code>-（void）test:(int)a;</code>的方法编码为<code>v@:i</code>，v = void,@表示指针变量(因为编译后第一个参数是self)，：表示选择器(因为编译后第二个参数是_cmd)，</li>
<li>有时类型编码会带上数字，比如<code>v16@0:8</code>，第一个数字表示这个函数的参数一共占用16个字节，第二个数字开始往后的数字都代表偏移值，0代表第一个参数的字节偏移值为0，第三个数字8代表偏移8个字节，也就是第一个参数已经占用了8个字节了，所以第二个参数就从第8个字节开始</li>
</ul>
</li>
</ul>
<h3 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h3><ul>
<li>Class内部结构中有个方法缓存（cache_t），用散列表来缓存曾经调用过的方法，可以提高方法的查找速度</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cache_t &#123;</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            explicit_atomic&lt;mask_t&gt;    _maybeMask; <span class="comment">// 散列表的长度 - 1</span></span><br><span class="line">            uint16_t                   _flags;</span><br><span class="line">            uint16_t                   _occupied; <span class="comment">// 已经缓存的方法数量</span></span><br><span class="line">        &#125;;</span><br><span class="line">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;</span><br><span class="line">    &#125;;   </span><br><span class="line">    <span class="keyword">struct</span> bucket_t *buckets() <span class="keyword">const</span>;</span><br><span class="line">    mask_t mask() <span class="keyword">const</span>;</span><br><span class="line">    mask_t occupied() <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，通过<code>buckets()</code>函数我们可以得知<code>_bucketsAndMaybeMask</code>是一个存放<code>bucket_t</code>数组的指针（即<code>_bucketsAndMaybeMask</code>指针指向的是数组的第一个元素），是通过位运算取出来的</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> bucket_t *cache_t::buckets() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    uintptr_t addr = _bucketsAndMaybeMask.load(memory_order_relaxed);</span><br><span class="line">    <span class="keyword">return</span> (bucket_t *)(addr &amp; bucketsMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>bucket_t</code>的结构如下</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="class">bucket_t </span>&#123;</span><br><span class="line">    explicit_atomic<span class="params">&lt;uintptr_t&gt;</span> _imp; 	<span class="comment">// 函数的内存地址</span></span><br><span class="line">    explicit_atomic<span class="params">&lt;SEL&gt;</span> _sel; <span class="comment">// SEL作为key</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过IMP和SEL，我们就可以调用方法了，所以综上所述，一个实例对象调用方法，其类对象从方法缓存里面找方法的大概流程就是</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取sel : class - isa - 偏移<span class="number">16</span>个字节 - <span class="keyword">cache_t </span>- <span class="keyword">buckets() </span>- [<span class="keyword">bucket_t] </span>- 计算出下标index - <span class="keyword">bucket_t </span>- sel()</span><br><span class="line">获取imp : class - isa - 偏移<span class="number">16</span>个字节 - <span class="keyword">cache_t </span>- <span class="keyword">buckets() </span>- [<span class="keyword">bucket_t] </span>- 计算出下标index - <span class="keyword">bucket_t </span>- imp(nil,cls)</span><br></pre></td></tr></table></figure>

<p>另外<code>_bucketsAndMaybeMask</code>之所以叫这个名字是因为它不仅存放着<code>buckets</code>还存放着<code>maybeMask</code>，在arm64位真机环境下，取高16位，如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mask_t cache_t::mask() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    uintptr_t maskAndBuckets = _bucketsAndMaybeMask.load(memory_order_relaxed);</span><br><span class="line">    <span class="comment">//maskShift 为48,</span></span><br><span class="line">    <span class="keyword">return</span> maskAndBuckets &gt;&gt; maskShift;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法缓存的流程"><a href="#方法缓存的流程" class="headerlink" title="方法缓存的流程"></a>方法缓存的流程</h4><p>先看看runtime源码中，将方法插入缓存的函数（摘抄核心流程）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cache_t::insert(SEL sel, IMP imp, <span class="keyword">id</span> receiver)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//对_occupied赋值 + 1。首次 newOccupied = 1。</span></span><br><span class="line">    mask_t newOccupied = occupied() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//旧容量，（mask + 1） 或者 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> oldCapacity = capacity(), capacity = oldCapacity;</span><br><span class="line">    <span class="comment">//是否为空，首次进入这里</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(isConstantEmptyCache())) &#123;</span><br><span class="line">        <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">        <span class="comment">//默认容量给4</span></span><br><span class="line">        <span class="keyword">if</span> (!capacity) capacity = INIT_CACHE_SIZE;<span class="comment">//1 &lt;&lt; 2 = 4</span></span><br><span class="line">        <span class="comment">//0 4 false 开辟新的容器空间。由于旧容器为空这里不需要释放传false。</span></span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="comment">/* freeOld */</span><span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//newOccupied + 1 (相当于 _occupied + 2) &lt;= capacity * 3 / 4 容量够的时候什么都不做，直接插入。&lt;=75%的容积正常插入，否则扩容。</span></span><br><span class="line">    <span class="comment">//## ⚠️在arm64位的情况下，CACHE_END_MARKER 0 扩容条件为：7 / 8 87.5% 这个时候CACHE_ALLOW_FULL_UTILIZATION 为 1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fastpath(newOccupied + <span class="built_in">CACHE_END_MARKER</span> &lt;= cache_fill_ratio(capacity))) &#123;</span><br><span class="line">        <span class="comment">// Cache is less than 3/4 or 7/8 full. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CACHE_ALLOW_FULL_UTILIZATION</span></span><br><span class="line">    <span class="comment">//capacity &lt;= 1&lt;&lt;3 (8), _occupied + 1（CACHE_END_MARKER为0） &lt;= 容量。少于8个元素的时候允许100%占满。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (capacity &lt;= FULL_UTILIZATION_CACHE_SIZE &amp;&amp; newOccupied + <span class="built_in">CACHE_END_MARKER</span> &lt;= capacity) &#123;</span><br><span class="line">        <span class="comment">// Allow 100% cache utilization for small buckets. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//扩容</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//容量不为空返回 2倍的容量，否则返回4</span></span><br><span class="line">        capacity = capacity ? capacity * <span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line">        <span class="comment">//MAX_CACHE_SIZE 1&lt;&lt;16 = 2^16。最大缓存65536</span></span><br><span class="line">        <span class="keyword">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">            capacity = MAX_CACHE_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开辟新的容器控件，释放旧的空间。</span></span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从_bucketsAndMaybeMask获取buckets</span></span><br><span class="line">    bucket_t *b = buckets();</span><br><span class="line">    mask_t m = capacity - <span class="number">1</span>;<span class="comment">//首次是4-1</span></span><br><span class="line">    <span class="comment">//计算插入的index</span></span><br><span class="line">    mask_t begin = cache_hash(sel, m);</span><br><span class="line">    mask_t i = begin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for the first unused slot and insert there.</span></span><br><span class="line">    <span class="comment">// There is guaranteed to be an empty slot.</span></span><br><span class="line">    <span class="comment">//循环判断插入数据。</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//能走到这里大概率是cache不存在，所以这里走fastpath</span></span><br><span class="line">        <span class="keyword">if</span> (fastpath(b[i].sel() == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">//Occupied + 1</span></span><br><span class="line">            incrementOccupied();</span><br><span class="line">            <span class="comment">//buckets中插入bucket</span></span><br><span class="line">            b[i].set&lt;Atomic, Encoded&gt;(b, sel, imp, cls());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已经存在了，不进行任何处理。有可能是其它线程插入的。</span></span><br><span class="line">        <span class="keyword">if</span> (b[i].sel() == sel) &#123;</span><br><span class="line">            <span class="comment">// The entry was added to the cache by some other thread</span></span><br><span class="line">            <span class="comment">// before we grabbed the cacheUpdateLock.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cache_next为了防止hash冲突。再hash了一次（下文会讲到）。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (fastpath((i = cache_next(i, m)) != begin));</span><br><span class="line">    <span class="comment">//异常处理</span></span><br><span class="line">    bad_cache(receiver, (SEL)sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首次进入isConstantEmptyCache分支。会创建一个容量为4的空buckets。这个时候由于旧buckets不存在不需要释放所以参数传递false。</li>
<li>当容量大于等于3/4或7/8的情况下扩容。arm64的条件下为7 / 8。</li>
<li>arm64条件下容量小于等于8的时候会占用100%才扩容。</li>
<li>扩容是直接翻倍，默认值4。最大值MAX_CACHE_SIZE为216(65536)。在扩容的时候直接释放了旧值。</li>
<li>mask值为capacity - 1</li>
<li>通过cache_hash（下文会提及的散列表算法）计算插入的index，后面会通过cache_next再进行计算hash解决冲突问题。</li>
<li>循环判断通过b[i].set插入bucket数据。</li>
<li><strong>reallocate函数在开辟控件的同时，把缓存给直接清空了</strong>，清空之后再把现在要缓存的方法放进去，所以扩容后occupied会为1。</li>
</ul>
<h4 id="散列表（哈希表）缓存"><a href="#散列表（哈希表）缓存" class="headerlink" title="散列表（哈希表）缓存"></a>散列表（哈希表）缓存</h4><ul>
<li><p>方法缓存的容器，不是简单的数组，而是用散列表的方式进行存储。</p>
<p>假如现在散列表长度为10，那么mask（即cache_t里面的_maybeMask）就是10-1 = 9，当selector传进来的时候，会跟mask进行一次与运算，如下：</p>
<p><code>@selector(personTest) &amp; mask = 4</code></p>
<p>假如得到的结果是4的话，那么就会插在列表的下标为4的位置，其他位置因为已经开辟好空间了，所以有值就放值，没值就NULL</p>
<p>这种列表的好处是，当想取到特定的bucket_t的时候，只需要把selector跟mask进行一次与运算，就可以直接得到下标，然后直接从列表取出，这样子就不用遍历查找了，大大节约了性能。</p>
<p>另外，由于与运算的特性，跟mask进行与运算之后的值，都不可能比mask更大，这样子就保证不会插入越界的位置。</p>
</li>
<li><p>如果通过计算后的下标值，插入列表的时候发现已经有东西了那怎么办？</p>
<p>  这也就是所谓的Hash冲突。为了处理这种问题，系统会调用<code>cache_next</code>函数</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">mask_t</span> <span class="title">cache_next</span><span class="params">(<span class="keyword">mask_t</span> i, <span class="keyword">mask_t</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i ? i<span class="number">-1</span> : mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  也就是说如果<code>@selector(personTest) &amp; mask = 4</code>的4已经有东西了，那么就取 4 - 1 = 3，如果3还有东西，就放在2的位置，如果2还有，就放在1，以此类推，如果直到0都还没有可以插入的位置，那么就从mask的位置开始找，也就是9，然后再找9看看是否可以插入，插不进去再找8，以此类推，找到为止。</p>
<p>  由于列表在存放数量达到容量的87.5%的时候就会两倍的扩容（arm64），扩容后又会清空缓存，所以一定能找到合适的位置插入的。</p>
</li>
</ul>
<h2 id="消息发送机制"><a href="#消息发送机制" class="headerlink" title="消息发送机制"></a>消息发送机制</h2><p>调用一个不存在的方法的时候，他会经历这么一个流程</p>
<p>消息发送 - （找不到方法的话） -&gt; 动态方法解析 - （没有实现的话） -&gt; 消息转发 -&gt; （没有实现的话） -&gt; 抛出异常</p>
<h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p>假如我们这么调用一个方法</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[person personTest]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>底层会转换为</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(person,sel_registerName(<span class="string">&quot;personTest&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的person我们称作消息接受者（receiver），就是调用方法的对象，如果这里还是调用类方法的话，那么这里就会传入一个类对象</li>
<li><code>sel_registerName()</code>函数等价于<code>@selector</code></li>
<li>为了性能，<code>objc_msgSend</code>方法底层是使用汇编和C++实现的</li>
</ul>
<p>消息发送的流程如下：</p>
<ol>
<li>receiver 是否为空，如果是退出，否则继续</li>
<li>从receiver的类对象（如果传入的是类则找的是元类对象，下文统称为receiverClass）的cache中查找方法，如果找到则调用方法，如果找不到则继续</li>
<li>从receiverClass中的<code>class_rw_t</code>中查找方法，如果找到则调用方法，并将方法插入缓存，如果找不到则继续</li>
<li>从<code>superClass</code>的cache中查找方法，有则调用并缓存到当前receiverClass的cache中(不是superClass的cache),否则继续</li>
<li>从<code>superClass</code>的<code>class_rw_t</code>中找，有则调用并缓存到receiverClass的cache中，否则继续</li>
<li>继续通过<code>superClass</code>的<code>superClass</code>找方法，流程回到4，直到再也没有父类了，并且也找不到方法，那么将会进入动态方法解析阶段。</li>
</ol>
<p>其中：</p>
<ul>
<li>如果是从<code>class_rw_t</code>中查找方法，若方法列表已经排序好，那么就使用二分查找法查找</li>
<li>如果是还没排序的方法，那么就使用遍历的方法查找</li>
<li>在缓存中查找方法的过程也称作快速查找（使用汇编实现），在<code>class_rw_t</code>中查找方法的过程也称作慢速查找(使用汇编和C++实现)，C++部分方法源码在<code>lookUpImpOrForward</code>函数中，如下：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(<span class="keyword">id</span> inst, SEL sel, Class cls, <span class="keyword">int</span> behavior)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> IMP forward_imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    IMP imp = <span class="literal">nil</span>;</span><br><span class="line">    Class curClass;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    <span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(behavior &amp; LOOKUP_CACHE)) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done_nolock;</span><br><span class="line">    &#125;</span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!cls-&gt;isRealized())) &#123;</span><br><span class="line">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</span><br><span class="line">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    curClass = cls;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> attempts = unreasonableClassCount();;) &#123;</span><br><span class="line">        <span class="comment">// curClass method list.</span></span><br><span class="line">        Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slowpath((curClass = curClass-&gt;superclass) == <span class="literal">nil</span>)) &#123;</span><br><span class="line">            imp = forward_imp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(--attempts == <span class="number">0</span>)) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Memory corruption in class list.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Superclass cache.</span></span><br><span class="line">        imp = cache_getImp(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (slowpath(imp == forward_imp)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fastpath(imp)) &#123;</span><br><span class="line">            <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">        behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">        <span class="keyword">return</span> resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">    &#125;</span><br><span class="line"> done:</span><br><span class="line">    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"> done_nolock:</span><br><span class="line">    <span class="keyword">if</span> (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>慢速查找流程图：</p>
<img src="https://p5-tt.byteimg.com/origin/pgc-image/47b512631098428e8bc60162e1df4ab7.png" >

<p>消息发送流程图：</p>
<img src="https://p9-tt.byteimg.com/origin/pgc-image/70dfbbc7f61a4a9fac15e5ff1af809b4.png">



<h3 id="动态方法解析（也称：动态方法决议）"><a href="#动态方法解析（也称：动态方法决议）" class="headerlink" title="动态方法解析（也称：动态方法决议）"></a>动态方法解析（也称：动态方法决议）</h3><p>当消息发送流程找不到方法后就会进入动态方法解析流程。</p>
<p>动态方法解析是当消息发送阶段找不到方法的时候，开发者可以通过重写特定方法（如果是类方法就重写<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>，如果是对象方法就重写<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>），给原先不存在的方法添加方法实现。主要是用到runtime里面的<code>class_addMethod</code>函数，并且动态解析后，会重新走”消息发送“的流程</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>假如这里的person没有实现print方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [Person new];</span><br><span class="line">[person print];</span><br></pre></td></tr></table></figure>

<p>那我们可以在<code>Person.m</code>添加一个方法实现用来替换丢失的<code>print</code>，这里我们用<code>truePrint</code>来替代</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)truePrint &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;true print&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取truePrint方法的Method对象</span></span><br><span class="line">        Method truePrint = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(truePrint));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 动态添加print方法的实现，通过method_getImplementation获取到方法的函数指针，通过method_getTypeEncoding拿到方法的函数编码即 v@: 或 v16@0:8</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, method_getImplementation(truePrint), method_getTypeEncoding(truePrint));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回YES代表有动态添加方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Method的结构"><a href="#Method的结构" class="headerlink" title="Method的结构"></a>Method的结构</h4><p>点击Method我们可以看到结构如下</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></span><br></pre></td></tr></table></figure>

<p>而<code>ojbc_method</code>的定义如下</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">struct</span> objc_method &#123;</span><br><span class="line">    <span class="attribute">SEL</span> _Nonnull method_name;	</span><br><span class="line">    <span class="attribute">char</span> * _Nullable method_types;</span><br><span class="line">    <span class="attribute">IMP</span> _Nonnull method_imp;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>可以看到跟上面所说的<code>method_t</code>是类似的东西</p>
<p>以下是一些拿到<code>Method</code>对象后可以使用的一些函数</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用，但是不接收返回值类型为结构体</span></span><br><span class="line">method_invoke</span><br><span class="line"><span class="comment">// 函数调用，但是接收返回值类型为结构体</span></span><br><span class="line">method_invoke_stret</span><br><span class="line"><span class="comment">// 获取函数名</span></span><br><span class="line">method_getName</span><br><span class="line"><span class="comment">// 获取函数实现IMP</span></span><br><span class="line">method_getImplementation</span><br><span class="line"><span class="comment">// 获取函数type encoding</span></span><br><span class="line">method_getTypeEncoding</span><br><span class="line"><span class="comment">// 复制返回值类型</span></span><br><span class="line">method_copyReturnType</span><br><span class="line"><span class="comment">// 复制参数类型</span></span><br><span class="line">method_copyArgumentType</span><br><span class="line"><span class="comment">// 获取返回值类型</span></span><br><span class="line">method_getReturnType</span><br><span class="line"><span class="comment">// 获取参数个数</span></span><br><span class="line">method_getNumberOfArguments</span><br><span class="line"><span class="comment">// 获取函数参数类型</span></span><br><span class="line">method_getArgumentType</span><br><span class="line"><span class="comment">// 获取函数描述</span></span><br><span class="line">method_getDescription</span><br><span class="line"><span class="comment">// 设置函数实现IMP</span></span><br><span class="line">method_setImplementation</span><br><span class="line"><span class="comment">// 交换函数的实现IMP</span></span><br><span class="line">method_exchangeImplementations</span><br></pre></td></tr></table></figure>


<h4 id="Runtime中的原理"><a href="#Runtime中的原理" class="headerlink" title="Runtime中的原理"></a>Runtime中的原理</h4><p>在上面的消息发送的流程函数<code>lookUpImpOrForward</code>中，有一段代码如下</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">    behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">    return resolve<span class="constructor">Method_locked(<span class="params">inst</span>, <span class="params">sel</span>, <span class="params">cls</span>, <span class="params">behavior</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当找不到消息的时候就会进入动态方法解析的流程即<code>resolveMethod_locked</code>，如下</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NEVER_INLINE IMP resolveMethod_locked(<span class="keyword">id</span> inst, SEL sel, Class cls, <span class="keyword">int</span> behavior) &#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveClassMethod(inst, sel, cls);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNilTryCache(inst, sel, cls)) &#123;</span><br><span class="line">            resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForwardTryCache(inst, sel, cls, behavior);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面我们可以发现<code>resolveInstanceMethod</code>和<code>resolveClassMethod</code>两个函数，分别是实现实例方法的动态消息解析和类方法的动态消息解析，这两个长得差不多，所以我们拿实例对象的函数查看一下</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static void resolveInstanceMethod(id inst, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    ASSERT(<span class="function"><span class="title">cls</span>-&gt;</span>isRealized());</span><br><span class="line">    SEL resolve_sel = @selector(resolveInstanceMethod:);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (!lookUpImpOrNilTryCache(cls, resolve_sel, cls-&gt;</span>ISA(<span class="comment">/*authenticated*/</span><span class="literal">true</span>))) &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    bool resolved = msg(cls, resolve_sel, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveInstanceMethod adds to self a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNilTryCache(inst, sel, cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;RESOLVE: method %c[%s %s] &quot;</span></span><br><span class="line">                         <span class="string">&quot;dynamically resolved to %p&quot;</span>, </span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>isMetaClass() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn&#x27;t add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</span></span><br><span class="line">                         <span class="string">&quot;, but no new implementation of %c[%s %s] was found&quot;</span>,</span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel), </span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>isMetaClass() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们可以看到对<code>resolveInstanceMethod</code>方法进行了一次<code>objc_msgSend</code>调用，调用之后又执行了<code>lookUpImpOrNilTryCache</code>函数进行了缓存，如果缓存成功，那么下次调用这个方法就不会在进入动态方法解析阶段，直接通过消息发送阶段就调用成功了。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>根据我们以前所学的知识可以知道，方法查找的流程为</p>
<p>实例方法：类 – 父类 – 父类 – … – 根类 – nil</p>
<p>类方法：元类 – 父元类 – 父元类 – … – 根元类 – 根类 – nil</p>
<p>也就是说丢失的方法最后都会回到根类去找方法，一般情况下是<code>NSObject</code></p>
<p>通过这个特性，我们可以直接在<code>NSObject</code>上添加分类，然后实现动态解析方法，根据方法名前缀进行判断，然后统一处理未被找到的方法添加默认实现。通过这种方式我们可以减少一些找不到方法导致的崩溃问题，提升用户体验。</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>如果没有实现动态方法解析，那么将进入消息转发阶段。消息转发即把消息交给别人发送的意思。</p>
<p>从上面的<code>lookUpImpOrForward</code>函数的源码我们可以看到，最后是调用了<code>_objc_msgForward_impcache</code>这个函数，这个函数是通过汇编实现的</p>
<p>要实现消息转发，我们有两种方式，一种是实现一个方法<code>-forwardingTargetForSelector</code>，一种是实现<code>-methodSignatureForSelector</code>和<code>-forwardInvocation</code>，比如</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[Student alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现了这个方法之后，最后系统会去我们提供的<code>Student</code>对象去寻找<code>print</code>方法，找到了的话就会进行调用。注意这个方法每次都会进来，每次都会生成新的<code>Student</code>对象对其<code>print</code>方法进行调用。</p>
<p>如果<code>forwardingTargetForSelector</code>没实现或者返回空的话</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么就会寻找<code>-methodSignatureForSelector</code>和<code>-forwardInvocation</code></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 方法签名： 返回值类型、参数类型</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">&quot;v16@0:8&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数</span></span><br><span class="line"><span class="comment">/// anInvocation.target 方法调用者</span></span><br><span class="line"><span class="comment">/// anInvocation.selector 方法名</span></span><br><span class="line"><span class="comment">//// [anInvocation getArgument:NULL atIndex:0] 方法参数</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:[[Student alloc] init]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们在方法签名中指定方法类型，然后在<code>forwardInvocation</code>方法中，修改target，然后直接调用，这样子就会直接调用Student的print方法了</p>
<img src="https://p3-tt.byteimg.com/origin/pgc-image/ba2d1d5ff71a49c8913690d6f69fb7d7.png" width=80%>

<h4 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h4><p>当系统执行到<code>forwardInvocation</code>的时候，无论在方法内有任何实现，都不会执行到<code>doseNotRecognizeSelector</code>（抛出异常），所以实现了就不会崩，即便什么都不做。</p>
<p>在<code>forwardInvocation</code>内我们可以拿到方法调用的很多信息，比如方法调用者<code>anInvocation.target</code>、方法名<code>anInvocation.selector</code>和方法参数</p>
<p>比如调用方法为<code>[person print:1]</code>，进入到<code>forwardInvocation</code>后我们可以通过以下方法拿到<code>1</code>这个参数</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    [anInvocation getArgument:&amp;a atIndex:<span class="number">2</span>]; <span class="comment">// 第一个参数是self，第二个是_cmd，所以从下标2开始取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要拿返回值的话，就可以这么做</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:[[Student alloc] init]]; <span class="comment">// 要先调用一下Student的print方法，这里假设返回值是整型</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    [anInvocation getReturnValue:&amp;result];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,result); <span class="comment">/// 这里可以拿到返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NSMethodSignature"><a href="#NSMethodSignature" class="headerlink" title="NSMethodSignature"></a>NSMethodSignature</h4><p><code>[NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;]</code>，注意这里的方法编码要跟下面<code>forwardInvocation</code>要调用的方法的方法编码一致 </p>
<p>我们除了可以通过方法编码拿到<code>NSMethodSignature</code>对象之外，还可以这么做</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[Student new] methodSignatureForSelector:<span class="keyword">@selector</span>(print)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类方法的消息转发"><a href="#类方法的消息转发" class="headerlink" title="类方法的消息转发"></a>类方法的消息转发</h4><p><code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code></p>
<p><code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code></p>
<p><code>+ (void)forwardInvocation:(NSInvocation *)anInvocation</code></p>
<p>这几个方法也有类方法版本，但是代码补全没出来，但是实际使用是可行的</p>
<p><code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>在这个方法里面返回的消息接受者既可以是类对象也可以是实例对象。</p>
<h4 id="synthesize-和-dynamic"><a href="#synthesize-和-dynamic" class="headerlink" title="@synthesize 和 @dynamic"></a>@synthesize 和 @dynamic</h4><p><code>@synthesize</code>用来自动给成员变量名生成<code>setter</code>和<code>getter</code>的声明和实现</p>
<p><code>@dynamic</code>用来告诉编译器不要自动生成<code>setter</code>和<code>getter</code>的实现（声明还是会声明的），待到运行时开发者自己实现，并且不会为属性实现带下划线的成员变量</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>假如我们调用<code>Student</code>实例的一个父类方法</p>
<p><code>[super run:xx]</code></p>
<p>那么编译后会变成如下代码</p>
<p><code>objc_msgSendSuper(self,class_getSuperclass(objc_getClass(&quot;Student&quot;)),sel_registerName(&quot;run&quot;),xx);</code></p>
<p>所以<code>super</code>发送消息的本质是调用<code>objc_msgSendSuper2</code>函数，最终的消息接受者依旧是<code>self</code>，只是实例方法寻找从父类的类对象开始寻找，类方法从父类的元类对象开始寻找。</p>
<p>所以当我们调用方法<code>[super class]</code>的时候，跟<code>[self class]</code>没区别，返回结果是一致的</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"># iOS</a>
              <a href="/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" rel="tag"># 底层原理</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/post/78ececc4.html" rel="prev" title="iOS 底层原理 --- isa指针">
      <i class="fa fa-chevron-left"></i> iOS 底层原理 --- isa指针
    </a></div>
      <div class="post-nav-item">
    <a href="/post/11ed4e5e.html" rel="next" title="iOS 底层原理 -- Runtime API">
      iOS 底层原理 -- Runtime API <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">Class对象的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class-rw-t"><span class="nav-number">1.2.</span> <span class="nav-text">class_rw_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class-ro-t"><span class="nav-number">1.3.</span> <span class="nav-text">class_ro_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#method-t"><span class="nav-number">1.4.</span> <span class="nav-text">method_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache-t"><span class="nav-number">1.5.</span> <span class="nav-text">cache_t</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">1.5.1.</span> <span class="nav-text">方法缓存的流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E7%BC%93%E5%AD%98"><span class="nav-number">1.5.2.</span> <span class="nav-text">散列表（哈希表）缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E6%9C%BA%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">消息发送机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81"><span class="nav-number">2.1.</span> <span class="nav-text">消息发送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B9%9F%E7%A7%B0%EF%BC%9A%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E5%86%B3%E8%AE%AE%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">动态方法解析（也称：动态方法决议）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Method%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.2.</span> <span class="nav-text">Method的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runtime%E4%B8%AD%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.3.</span> <span class="nav-text">Runtime中的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96"><span class="nav-number">2.2.4.</span> <span class="nav-text">优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91"><span class="nav-number">2.3.</span> <span class="nav-text">消息转发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NSInvocation"><span class="nav-number">2.3.1.</span> <span class="nav-text">NSInvocation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSMethodSignature"><span class="nav-number">2.3.2.</span> <span class="nav-text">NSMethodSignature</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91"><span class="nav-number">2.3.3.</span> <span class="nav-text">类方法的消息转发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synthesize-%E5%92%8C-dynamic"><span class="nav-number">2.3.4.</span> <span class="nav-text">@synthesize 和 @dynamic</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super"><span class="nav-number">3.</span> <span class="nav-text">super</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Arclin"
      src="https://avatars.githubusercontent.com/u/12107804?v=4">
  <p class="site-author-name" itemprop="name">Arclin</p>
  <div class="site-description" itemprop="description">Stay hungry,stay foolish</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">106</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Arc-lin" title="GitHub → https://github.com/Arc-lin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:arclin325@gmail.com" title="E-Mail → mailto:arclin325@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Arclin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'df6d1f33bb4a66f5fa60',
      clientSecret: '5fcc9fb756ac9d4b16381288da7b29f691b45e0a',
      repo        : 'arc-lin.github.io',
      owner       : 'Arc-lin',
      admin       : ['Arc-lin'],
      id          : '1cc7c2dc04e24e2db79eb1c8985f9f83',
        language: 'zh-CN',
      distractionFreeMode: false
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
