<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arclin</title>
  
  <subtitle>Advocate Technology. Enjoy Technology.</subtitle>
  <link href="https://www.arclin.cn/atom.xml" rel="self"/>
  
  <link href="https://www.arclin.cn/"/>
  <updated>2021-04-12T06:07:04.038Z</updated>
  <id>https://www.arclin.cn/</id>
  
  <author>
    <name>Arclin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sign in with Apple接入指南</title>
    <link href="https://www.arclin.cn/post/ac0a85bd.html"/>
    <id>https://www.arclin.cn/post/ac0a85bd.html</id>
    <published>2019-11-01T05:15:00.000Z</published>
    <updated>2021-04-12T06:07:04.038Z</updated>
    
    <content type="html"><![CDATA[<p>如果你的应用接入了第三方登陆，那么请同时接入苹果登录。</p><span id="more"></span><p><a href="https://developer.apple.com/app-store/review/guidelines/#sign-in-with-apple">苹果审核指南的相关内容</a><br><a href="https://developer.apple.com/news/?id=09122019b">新闻：2020年4月前需要适配好苹果登录</a></p><h2 id="简单接入"><a href="#简单接入" class="headerlink" title="简单接入"></a>简单接入</h2><p><a href="https://developer.apple.com/sign-in-with-apple/">苹果登录官方文档</a></p><p>流程：</p><p>用户点击按钮 — 调起苹果登录 — 授权成功 — 获取唯一标识符和其他信息 — 返回给后端 — 后端注册/登录 — 返回token — 登录成功</p><h3 id="必要的工作"><a href="#必要的工作" class="headerlink" title="必要的工作"></a>必要的工作</h3><ol><li><p>首先去苹果后台开启<code>Sign in with apple</code>选项，然后重新导出<code>provisionprofile</code>证书</p></li><li><p>授权</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ASAuthorizationAppleIDProvider *provider &#x3D; [[ASAuthorizationAppleIDProvider alloc] init];</span><br><span class="line">ASAuthorizationAppleIDRequest *request &#x3D; [provider createRequest];</span><br><span class="line">request.requestedScopes &#x3D; @[ASAuthorizationScopeFullName, ASAuthorizationScopeEmail];</span><br><span class="line"></span><br><span class="line">NSMutableArray &lt;ASAuthorizationRequest *&gt;* array &#x3D; [NSMutableArray arrayWithCapacity:2];</span><br><span class="line">if (request) [array addObject:request];</span><br><span class="line"></span><br><span class="line">NSArray&lt;ASAuthorizationRequest *&gt; *requests &#x3D; [array copy];</span><br><span class="line">ASAuthorizationController *authorizationController &#x3D; [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];</span><br><span class="line">authorizationController.delegate &#x3D; self;</span><br><span class="line">authorizationController.presentationContextProvider &#x3D; input;</span><br><span class="line">[authorizationController performRequests];</span><br></pre></td></tr></table></figure></li><li><p>回调，遵循回调<code>ASAuthorizationControllerPresentationContextProviding</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization API_AVAILABLE(ios(13.0))</span><br><span class="line">&#123;</span><br><span class="line">if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) &#123;</span><br><span class="line">&#x2F;&#x2F; 用户登录使用ASAuthorizationAppleIDCredential</span><br><span class="line">ASAuthorizationAppleIDCredential *appleIDCredential &#x3D; (ASAuthorizationAppleIDCredential *)authorization.credential;</span><br><span class="line">NSString *user &#x3D; appleIDCredential.user;</span><br><span class="line">NSString *namePerfix &#x3D; appleIDCredential.fullName.namePrefix;</span><br><span class="line">NSString *givenName &#x3D; appleIDCredential.fullName.givenName;</span><br><span class="line">NSString *middleName &#x3D; appleIDCredential.fullName.middleName;</span><br><span class="line">NSString *familyName &#x3D; appleIDCredential.fullName.familyName;</span><br><span class="line">NSString *nameSuffix &#x3D; appleIDCredential.fullName.nameSuffix;</span><br><span class="line">NSString *email &#x3D; appleIDCredential.email;</span><br><span class="line">NSString *nickname &#x3D; appleIDCredential.fullName.nickname;</span><br><span class="line"></span><br><span class="line">if (!nickname || nickname.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">nickname &#x3D; [NSString stringWithFormat:@&quot;%@%@%@%@%@&quot;,namePerfix?:@&quot;&quot;,familyName?:@&quot;&quot;,givenName?:@&quot;&quot;,middleName?:@&quot;&quot;,nameSuffix?:@&quot;&quot;];</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">[self.errorSubject sendNext:LMError(@&quot;授权信息有误&quot;)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithError:(NSError *)error API_AVAILABLE(ios(13.0))</span><br><span class="line">&#123;</span><br><span class="line">NSString *errorMsg &#x3D; nil;</span><br><span class="line">switch (error.code) &#123;</span><br><span class="line">case ASAuthorizationErrorCanceled:</span><br><span class="line">errorMsg &#x3D; @&quot;用户取消了授权请求&quot;;</span><br><span class="line">return;</span><br><span class="line">case ASAuthorizationErrorFailed:</span><br><span class="line">errorMsg &#x3D; @&quot;授权请求失败&quot;;</span><br><span class="line">break;</span><br><span class="line">case ASAuthorizationErrorInvalidResponse:</span><br><span class="line">errorMsg &#x3D; @&quot;授权请求响应无效&quot;;</span><br><span class="line">break;</span><br><span class="line">case ASAuthorizationErrorNotHandled:</span><br><span class="line">errorMsg &#x3D; @&quot;未能处理授权请求&quot;;</span><br><span class="line">break;</span><br><span class="line">case ASAuthorizationErrorUnknown:</span><br><span class="line">errorMsg &#x3D; @&quot;授权请求失败未知原因&quot;;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">[self.errorSubject sendNext:LMError(errorMsg)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="其他可选项"><a href="#其他可选项" class="headerlink" title="其他可选项"></a>其他可选项</h2><h3 id="苹果提供的登录按钮"><a href="#苹果提供的登录按钮" class="headerlink" title="苹果提供的登录按钮"></a>苹果提供的登录按钮</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASAuthorizationAppleIDButton *button &#x3D; [ASAuthorizationAppleIDButton buttonWithType:ASAuthorizationAppleIDButtonTypeSignIn style:ASAuthorizationAppleIDButtonStyleWhiteOutline];</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonType) &#123;</span><br><span class="line">    ASAuthorizationAppleIDButtonTypeSignIn, &#x2F;&#x2F; 按钮文字显示 ：通过Apple登录</span><br><span class="line">    ASAuthorizationAppleIDButtonTypeContinue, &#x2F;&#x2F; 按钮文字显示 ：通过Apple继续</span><br><span class="line"></span><br><span class="line">    ASAuthorizationAppleIDButtonTypeDefault &#x3D; &#x2F;&#x2F; 默认第一个 ASAuthorizationAppleIDButtonTypeSignIn,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonStyle) &#123;</span><br><span class="line">    ASAuthorizationAppleIDButtonStyleWhite, &#x2F;&#x2F; 白底黑字</span><br><span class="line">    ASAuthorizationAppleIDButtonStyleWhiteOutline, &#x2F;&#x2F; 黑字白框</span><br><span class="line">    ASAuthorizationAppleIDButtonStyleBlack, &#x2F;&#x2F; 黑底白字</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="授权成功的回调可以来自于其他地方"><a href="#授权成功的回调可以来自于其他地方" class="headerlink" title="授权成功的回调可以来自于其他地方"></a>授权成功的回调可以来自于其他地方</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;! 授权成功地回调</span><br><span class="line">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization  API_AVAILABLE(ios(13.0))&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    NSLog(@&quot;%@&quot;, controller);</span><br><span class="line">    NSLog(@&quot;%@&quot;, authorization);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;authorization.credential：%@&quot;, authorization.credential);</span><br><span class="line">    </span><br><span class="line">    NSMutableString *mStr &#x3D; [NSMutableString string];</span><br><span class="line">    mStr &#x3D; [_appleIDInfoTextView.text mutableCopy];</span><br><span class="line">    </span><br><span class="line">    if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) &#123;</span><br><span class="line">        &#x2F;&#x2F; 用户登录使用ASAuthorizationAppleIDCredential</span><br><span class="line">        ASAuthorizationAppleIDCredential *appleIDCredential &#x3D; authorization.credential;</span><br><span class="line">        NSString *user &#x3D; appleIDCredential.user;</span><br><span class="line">        &#x2F;&#x2F;  最好使用钥匙串的方式保存用户的唯一信息 这里暂且处于测试阶段，用NSUserDefaults</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] setValue:user forKey:QiShareCurrentIdentifier];</span><br><span class="line">        [mStr appendString:user?:@&quot;&quot;];</span><br><span class="line">        NSString *familyName &#x3D; appleIDCredential.fullName.familyName;</span><br><span class="line">        [mStr appendString:familyName?:@&quot;&quot;];</span><br><span class="line">        NSString *givenName &#x3D; appleIDCredential.fullName.givenName;</span><br><span class="line">        [mStr appendString:givenName?:@&quot;&quot;];</span><br><span class="line">        NSString *email &#x3D; appleIDCredential.email;</span><br><span class="line">        [mStr appendString:email?:@&quot;&quot;];</span><br><span class="line">        NSLog(@&quot;mStr：%@&quot;, mStr);</span><br><span class="line">        [mStr appendString:@&quot;\n&quot;];</span><br><span class="line">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class="line">        </span><br><span class="line">    &#125; else if ([authorization.credential isKindOfClass:[ASPasswordCredential class]]) &#123;</span><br><span class="line">        &#x2F;&#x2F; 用户登录使用现有的密码凭证</span><br><span class="line">        ASPasswordCredential *passwordCredential &#x3D; authorization.credential;</span><br><span class="line">        &#x2F;&#x2F; 密码凭证对象的用户标识 用户的唯一标识</span><br><span class="line">        NSString *user &#x3D; passwordCredential.user;</span><br><span class="line">        &#x2F;&#x2F; 密码凭证对象的密码</span><br><span class="line">        NSString *password &#x3D; passwordCredential.password;</span><br><span class="line">        [mStr appendString:user?:@&quot;&quot;];</span><br><span class="line">        [mStr appendString:password?:@&quot;&quot;];</span><br><span class="line">        [mStr appendString:@&quot;\n&quot;];</span><br><span class="line">        NSLog(@&quot;mStr：%@&quot;, mStr);</span><br><span class="line">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;授权信息均不符&quot;);</span><br><span class="line">        mStr &#x3D; [@&quot;授权信息均不符&quot; mutableCopy];</span><br><span class="line">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="已经使用Sign-In-With-Apple登录过app的用户"><a href="#已经使用Sign-In-With-Apple登录过app的用户" class="headerlink" title="已经使用Sign In With Apple登录过app的用户"></a>已经使用Sign In With Apple登录过app的用户</h3><p>执行已经登录过的场景。如果设备中存在iCloud Keychain 凭证或者AppleID 凭证提示用户直接使用TouchID或FaceID登录即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (void)perfomExistingAccountSetupFlows &#123;</span><br><span class="line">    if (@available(iOS 13.0, *)) &#123;</span><br><span class="line">        &#x2F;&#x2F; A mechanism for generating requests to authenticate users based on their Apple ID.</span><br><span class="line">        &#x2F;&#x2F; 基于用户的Apple ID授权用户，生成用户授权请求的一种机制</span><br><span class="line">        ASAuthorizationAppleIDProvider *appleIDProvider &#x3D; [ASAuthorizationAppleIDProvider new];</span><br><span class="line">        &#x2F;&#x2F; An OpenID authorization request that relies on the user’s Apple ID.</span><br><span class="line">        &#x2F;&#x2F; 授权请求依赖于用于的AppleID</span><br><span class="line">        ASAuthorizationAppleIDRequest *authAppleIDRequest &#x3D; [appleIDProvider createRequest];</span><br><span class="line">        &#x2F;&#x2F; A mechanism for generating requests to perform keychain credential sharing.</span><br><span class="line">        &#x2F;&#x2F; 为了执行钥匙串凭证分享生成请求的一种机制</span><br><span class="line">        ASAuthorizationPasswordRequest *passwordRequest &#x3D; [[ASAuthorizationPasswordProvider new] createRequest];</span><br><span class="line">        </span><br><span class="line">        NSMutableArray &lt;ASAuthorizationRequest *&gt;* mArr &#x3D; [NSMutableArray arrayWithCapacity:2];</span><br><span class="line">        if (authAppleIDRequest) &#123;</span><br><span class="line">            [mArr addObject:authAppleIDRequest];</span><br><span class="line">        &#125;</span><br><span class="line">        if (passwordRequest) &#123;</span><br><span class="line">            [mArr addObject:passwordRequest];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; ASAuthorizationRequest：A base class for different kinds of authorization requests.</span><br><span class="line">        &#x2F;&#x2F; ASAuthorizationRequest：对于不同种类授权请求的基类</span><br><span class="line">        NSArray &lt;ASAuthorizationRequest *&gt;* requests &#x3D; [mArr copy];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; A controller that manages authorization requests created by a provider.</span><br><span class="line">        &#x2F;&#x2F; 由ASAuthorizationAppleIDProvider创建的授权请求 管理授权请求的控制器</span><br><span class="line">        &#x2F;&#x2F; Creates a controller from a collection of authorization requests.</span><br><span class="line">        &#x2F;&#x2F; 从一系列授权请求中创建授权控制器</span><br><span class="line">        ASAuthorizationController *authorizationController &#x3D; [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];</span><br><span class="line">        &#x2F;&#x2F; A delegate that the authorization controller informs about the success or failure of an authorization attempt.</span><br><span class="line">        &#x2F;&#x2F; 设置授权控制器通知授权请求的成功与失败的代理</span><br><span class="line">        authorizationController.delegate &#x3D; self;</span><br><span class="line">        &#x2F;&#x2F; A delegate that provides a display context in which the system can present an authorization interface to the user.</span><br><span class="line">        &#x2F;&#x2F; 设置提供 展示上下文的代理，在这个上下文中 系统可以展示授权界面给用户</span><br><span class="line">        authorizationController.presentationContextProvider &#x3D; self;</span><br><span class="line">        &#x2F;&#x2F; starts the authorization flows named during controller initialization.</span><br><span class="line">        &#x2F;&#x2F; 在控制器初始化期间启动授权流</span><br><span class="line">        [authorizationController performRequests];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听授权状态变化"><a href="#监听授权状态变化" class="headerlink" title="监听授权状态变化"></a>监听授权状态变化</h3><p>监听授权状态改变，并且做出相应处理。授权状态有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ASAuthorizationAppleIDProviderCredentialRevoked：授权状态失效（用户停止使用AppID 登录App）</span><br><span class="line">ASAuthorizationAppleIDProviderCredentialAuthorized：已授权(已使用AppleID 登录过App）</span><br><span class="line">ASAuthorizationAppleIDProviderCredentialNotFound：授权凭证缺失（可能是使用AppleID 登录过App）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;! 观察授权状态</span><br><span class="line">- (void)observeAuthticationState &#123;</span><br><span class="line">    </span><br><span class="line">    if (@available(iOS 13.0, *)) &#123;</span><br><span class="line">        &#x2F;&#x2F; A mechanism for generating requests to authenticate users based on their Apple ID.</span><br><span class="line">        &#x2F;&#x2F; 基于用户的Apple ID 生成授权用户请求的机制</span><br><span class="line">        ASAuthorizationAppleIDProvider *appleIDProvider &#x3D; [ASAuthorizationAppleIDProvider new];</span><br><span class="line">        &#x2F;&#x2F; 注意 存储用户标识信息需要使用钥匙串来存储 这里笔者简单期间 使用NSUserDefaults 做的简单示例</span><br><span class="line">        NSString *userIdentifier &#x3D; [[NSUserDefaults standardUserDefaults] valueForKey:QiShareCurrentIdentifier];</span><br><span class="line">        </span><br><span class="line">        if (userIdentifier) &#123;</span><br><span class="line">            NSString* __block errorMsg &#x3D; nil;</span><br><span class="line">            &#x2F;&#x2F;Returns the credential state for the given user in a completion handler.</span><br><span class="line">            &#x2F;&#x2F; 在回调中返回用户的授权状态</span><br><span class="line">            [appleIDProvider getCredentialStateForUserID:userIdentifier completion:^(ASAuthorizationAppleIDProviderCredentialState credentialState, NSError * _Nullable error) &#123;</span><br><span class="line">                switch (credentialState) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 苹果证书的授权状态</span><br><span class="line">                    case ASAuthorizationAppleIDProviderCredentialRevoked:</span><br><span class="line">                        &#x2F;&#x2F; 苹果授权凭证失效</span><br><span class="line">                        errorMsg &#x3D; @&quot;苹果授权凭证失效&quot;;</span><br><span class="line">                        break;</span><br><span class="line">                    case ASAuthorizationAppleIDProviderCredentialAuthorized:</span><br><span class="line">                        &#x2F;&#x2F; 苹果授权凭证状态良好</span><br><span class="line">                        errorMsg &#x3D; @&quot;苹果授权凭证状态良好&quot;;</span><br><span class="line">                        break;</span><br><span class="line">                    case ASAuthorizationAppleIDProviderCredentialNotFound:</span><br><span class="line">                        &#x2F;&#x2F; 未发现苹果授权凭证</span><br><span class="line">                        errorMsg &#x3D; @&quot;未发现苹果授权凭证&quot;;</span><br><span class="line">                        &#x2F;&#x2F; 可以引导用户重新登录</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    NSLog(@&quot;SignInWithApple授权状态变化情况&quot;);</span><br><span class="line">                    NSLog(@&quot;%@&quot;, errorMsg);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用通知的方式检测是否授权应用支持Sign In With Apple变化情况。如下的代码可以根据自己的业务场景去考虑放置的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;! 添加苹果登录的状态通知</span><br><span class="line">- (void)observeAppleSignInState &#123;</span><br><span class="line">    if (@available(iOS 13.0, *)) &#123;</span><br><span class="line">        NSNotificationCenter *center &#x3D; [NSNotificationCenter defaultCenter];</span><br><span class="line">        [center addObserver:self selector:@selector(handleSignInWithAppleStateChanged:) name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;! 观察SignInWithApple状态改变</span><br><span class="line">- (void)handleSignInWithAppleStateChanged:(id)noti &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    NSLog(@&quot;%@&quot;, noti);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    </span><br><span class="line">    if (@available(iOS 13.0, *)) &#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] removeObserver:self name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重要（Important！）"><a href="#重要（Important！）" class="headerlink" title="重要（Important！）"></a>重要（Important！）</h2><ol><li>最好使用苹果提供的按钮 <code>ASAuthorizationAppleIDButton</code> （只有黑白两种颜色）</li><li>不用他的按钮的话建议使用显眼的颜色 </li><li>尽量放在显眼位置（第一位）</li><li><strong>不能比其他任何登录按钮要小</strong></li><li>保证登录页面一屏就能看到苹果登录按钮，不能滚动后才能看到</li><li>按钮的最小宽高有需求（看<a href="https://developer.apple.com/design/human-interface-guidelines/sign-in-with-apple/overview/">苹果人机交互指南相关文档</a>）</li><li>如果登录后要绑定手机的话，就在备注里面写好 依据来源 <a href="http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm">http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm</a>  指明(截图)第二十四条（苹果一般不会打开网页，建议下载个pdf给他）</li><li>如果不好好跟苹果爸爸的规矩来，那么可能会吃到2.1和4.0 (不要问我为什么知道)</li></ol><p>(更新至2019/11/01)</p><table><thead><tr><th>最小宽度</th><th>最小高度</th><th>最小间距</th></tr></thead><tbody><tr><td>140pt (140px @1x, 280px @2x)</td><td>30pt (30px @1x, 60px @2x)</td><td>1/10 of the button’s height）</td></tr></tbody></table><h2 id="参考其他教程"><a href="#参考其他教程" class="headerlink" title="参考其他教程"></a>参考其他教程</h2><p><a href="https://juejin.im/post/5d8c64d151882509606d6b17">掘金</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果你的应用接入了第三方登陆，那么请同时接入苹果登录。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS13新API</title>
    <link href="https://www.arclin.cn/post/f356f3c1.html"/>
    <id>https://www.arclin.cn/post/f356f3c1.html</id>
    <published>2019-10-24T05:18:00.000Z</published>
    <updated>2021-04-12T06:07:04.039Z</updated>
    
    <content type="html"><![CDATA[<p>可能会用到的iOS13新Api</p><span id="more"></span><h2 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h2><h3 id="截图转PDF"><a href="#截图转PDF" class="headerlink" title="截图转PDF"></a>截图转PDF</h3><p>safari可以长截图了<br><img width=20% src="https://i.loli.net/2019/10/24/iHxWAqL63E2ZfMY.jpg"></p><p>然后我们可以把<code>UIScrollView</code>的截图转成PDF</p><p><a href="https://developer.apple.com/documentation/uikit/uiscreenshotservicedelegate">文档</a></p><h3 id="双指滑动手势"><a href="#双指滑动手势" class="headerlink" title="双指滑动手势"></a>双指滑动手势</h3><p><img src="https://i.loli.net/2019/10/24/FbSEV8WCXcQRrf9.gif"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 是否允许多指选中</span><br><span class="line">optional func tableView(_ tableView: UITableView, shouldBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) -&gt; Bool</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;多指选中开始，这里可以做一些UI修改，比如修改导航栏上按钮的文本</span><br><span class="line">optional func tableView(_ tableView: UITableView, didBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) </span><br></pre></td></tr></table></figure><h3 id="深色模式"><a href="#深色模式" class="headerlink" title="深色模式"></a>深色模式</h3><p>见<a href="https://www.jianshu.com/p/176537b0d9dd">文章</a></p><h2 id="Framework类"><a href="#Framework类" class="headerlink" title="Framework类"></a>Framework类</h2><h3 id="Multiple-UI-Instances"><a href="#Multiple-UI-Instances" class="headerlink" title="Multiple UI Instances"></a>Multiple UI Instances</h3><p>可以支持一个界面同时展示多个控制器（不是父子控制器那种）<br>在iPad上可以使用</p><p><img src="https://docs-assets.developer.apple.com/published/8ce996907a/fc0975ae-c186-438c-abdd-5280f650c377.png"></p><p>主要类<code>UIScene</code></p><p><a href="https://developer.apple.com/documentation/uikit/app_and_environment">文档</a></p><h3 id="BackgroundTasks"><a href="#BackgroundTasks" class="headerlink" title="BackgroundTasks"></a>BackgroundTasks</h3><p>好消息~ 现在维持后台不被杀可以直接用这个API了，以前的会用后台获取定位和播放静音音乐的方式，但是现在只要注册后台就可以了，但是还是只有短期，长时间的话可能会要求充电状态或者持续的网络状态。</p><p><a href="https://developer.apple.com/documentation/backgroundtasks/">文档</a></p><h3 id="Camera-Capture"><a href="#Camera-Capture" class="headerlink" title="Camera Capture"></a>Camera Capture</h3><p>现在可以同时使用前后摄像头，可以进行分割遮罩，可以识别出头发，皮肤，牙齿</p><p><a href="https://developer.apple.com/documentation/avfoundation/avcapturemulticamsession/">文档1</a></p><p><a href="https://developer.apple.com/documentation/avfoundation/avsemanticsegmentationmatte/">文档2</a></p><h3 id="Combine"><a href="#Combine" class="headerlink" title="Combine"></a>Combine</h3><p>官方版RxSwift，主要是配合SwiftUI使用</p><p><a href="https://developer.apple.com/documentation/combine/">文档</a></p><h3 id="Core-Haptics"><a href="#Core-Haptics" class="headerlink" title="Core Haptics"></a>Core Haptics</h3><p>可以在UI交互的时候给点小触觉反馈，比如打开关闭UISwitch的时候小震动一下，或者播放点声音之类的</p><p><a href="https://developer.apple.com/documentation/corehaptics/">文档</a></p><h3 id="Apple-CryptoKit"><a href="#Apple-CryptoKit" class="headerlink" title="Apple CryptoKit"></a>Apple CryptoKit</h3><p>好消息，苹果自带HMAC、SHA、AES、NIST加密算法啦</p><p><a href="https://developer.apple.com/documentation/cryptokit/">文档</a></p><h3 id="VisionKit"><a href="#VisionKit" class="headerlink" title="VisionKit"></a>VisionKit</h3><p>好消息，苹果自带图片转文字功能啦</p><p><a href="https://developer.apple.com/documentation/visionkit/">文档</a></p><h3 id="MetricKit"><a href="#MetricKit" class="headerlink" title="MetricKit"></a>MetricKit</h3><p>用来收集用户设备信息的，主要是使用App的过程中的耗电，CPU等等性能指标，可以依据这些优化你的App</p><p><a href="https://developer.apple.com/documentation/metrickit/">文档</a></p><h3 id="PencilKit"><a href="#PencilKit" class="headerlink" title="PencilKit"></a>PencilKit</h3><p>iPad上跟Apple Pencil交互的API</p><p><a href="https://developer.apple.com/documentation/pencilkit/">文档</a></p><h3 id="Vision"><a href="#Vision" class="headerlink" title="Vision"></a>Vision</h3><p>图像识别相关framework<br>iOS11的功能：面部和面部界标检测，条形码识别，图像配准以及一般特征跟踪。</p><p>iOS13的新功能：</p><ol><li>对图像进行显著性分析。</li><li>在图像中检测人类和动物。</li><li>对图像进行分类和搜索。</li><li>分析图像与特征打印的相似性。</li><li>对文档执行文本识别。</li></ol><p><a href="https://developer.apple.com/documentation/vision/">文档</a></p><h3 id="Sign-in-with-Apple"><a href="#Sign-in-with-Apple" class="headerlink" title="Sign in with Apple"></a>Sign in with Apple</h3><p>苹果登录</p><p><a href="https://developer.apple.com/sign-in-with-apple/get-started/">文档</a></p><h3 id="SF-Symbols"><a href="#SF-Symbols" class="headerlink" title="SF Symbols"></a>SF Symbols</h3><p>可以用来显示矢量图</p><p><a href="https://developer.apple.com/documentation/uikit/uiimage/configuring_and_displaying_symbol_images_in_your_ui/">文档</a></p><h3 id="Bring-Your-iPad-App-to-Mac"><a href="#Bring-Your-iPad-App-to-Mac" class="headerlink" title="Bring Your iPad App to Mac"></a>Bring Your iPad App to Mac</h3><p>直接把iPad App 迁移到 Mac，不过还是要做适配的，下面文档会有一些适配规则，以兼容两个端</p><p><a href="https://developer.apple.com/design/human-interface-guidelines/ios/overview/mac-catalyst/">参考</a></p><p><a href="https://developer.apple.com/documentation/xcode/creating_a_mac_version_of_your_ipad_app">文档1</a></p><p><a href="https://developer.apple.com/documentation/uikit/mac_catalyst/optimizing_your_ipad_app_for_mac">文档2</a></p><h3 id="ARKit-3"><a href="#ARKit-3" class="headerlink" title="ARKit 3"></a>ARKit 3</h3><p>应该大家都知道ARKit，这次主要是多了些新特性，包括动态捕捉动作，同时捕捉多个面部，同时开启前后摄像头等。</p><p><a href="https://developer.apple.com/documentation/arkit/">文档</a></p><h3 id="RealityKit"><a href="#RealityKit" class="headerlink" title="RealityKit"></a>RealityKit</h3><p>3D模型搭建、展示用</p><p><a href="https://developer.apple.com/documentation/realitykit/">文档</a></p><h3 id="Core-ML-3"><a href="#Core-ML-3" class="headerlink" title="Core ML 3"></a>Core ML 3</h3><p>升级版机器学习套件</p><p><a href="https://developer.apple.com/documentation/coreml/">文档</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;可能会用到的iOS13新Api&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>如何开发/管理一个项目</title>
    <link href="https://www.arclin.cn/post/3c7b026b.html"/>
    <id>https://www.arclin.cn/post/3c7b026b.html</id>
    <published>2019-10-20T07:20:00.000Z</published>
    <updated>2021-04-13T14:23:49.922Z</updated>
    
    <content type="html"><![CDATA[<p>如何管理一个项目，这是个沉重的话题。实际上，目前很多人都是凭借经验进行项目管理和开发，事实上管理项目是有着大量的方法论，这些方法论整理起来被人归纳成了一个学科，名字叫做<code>软件工程</code>，接下来的内容将会归纳总结里面的一些要点，如果你有意成为一个项目管理者，请必须了解一下这些基础知识。</p><span id="more"></span><h2 id="软件系统模型"><a href="#软件系统模型" class="headerlink" title="软件系统模型"></a>软件系统模型</h2><p>开始一个项目之前，你需要做好准备，那就是建立系统模型，有了抽象的模型，才会有具像的实现。</p><ul><li>在软件开发中，软件系统模型大体可分为两类：<code>概念模型</code>和<code>软件模型</code>。</li><li>概念模型是创建在需求层上的，它描述了系统是什么。</li><li>软件模型是建立在抽象层上的，它描述了实现概念模型的软件解决方案。</li><li>软件模型可进一步分为<code>设计模型</code>、<code>实现模型</code>和<code>部署模型</code>。</li></ul><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p> 一个完整的需求需要有以下特征：</p><ol><li>必要的：该需求是用户所要求的（产品经常会提一些伪需求，比如说在帖子列表添加个一键评价，点击了就回复666，但实际上没有用户想毫无感情地666，所以这是伪需求，不满足该条件的请拒绝）；</li><li>无歧义的：该需求只能用一种方式解释（这个就不用解释了，遇到有歧义的需求请问清楚）；</li><li>可测的：该需求可以进行测试；</li><li>可跟踪的：该需求可以从一个开发阶段跟踪到另一个开发阶段（意思就是这个需求不会因为开发的进行变得模糊、不清晰）；</li><li>可测量的：该需求是可测量的（意思就是实现这个需求不能无限耗费人力物力，说好这个需求两个人一天能做完，就两个人一天真的能做完）。</li></ol><h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><ol><li>功能需求：系统或系统构件必须执行的功能</li><li>非功能需求：分为性能需求、外部接口需求、设计约束需求、质量属性需求。</li></ol><h3 id="怎么发现需求"><a href="#怎么发现需求" class="headerlink" title="怎么发现需求"></a>怎么发现需求</h3><table><thead><tr><th align="center">名称</th><th align="center">情况</th><th align="center">成功条件</th><th align="center">风险</th></tr></thead><tbody><tr><td align="center">自悟</td><td align="center">自己想</td><td align="center">要比你的最终客户拥有更多的一样弄领域和过程方面的知识和丰富的想象力，也就是你要比你的用户更加清楚用户要啥</td><td align="center">无法验证你想出来的东西是不是你的用户想要的</td></tr><tr><td align="center">交谈</td><td align="center">跟你的客户聊</td><td align="center">你能提出正确的问题，回答人能揭示需求本质的能力</td><td align="center">可能会获得一堆需求，而且越来越多，不断增长，可能还会推翻你之前的需求，可能导致超出项目成本和进度的限制<s>（甚至可能被你的开发揍一顿）</s></td></tr><tr><td align="center">观察</td><td align="center">你去看你的用户怎么用你的软件</td><td align="center">你需要有洞察事物本质的能力</td><td align="center">1. 你的用户会抵触你的观察（很明显侵犯隐私了）2. 用户会觉得你是不是这软件没做好或者哪里需求不到位所以老是来看我，对你的软件产生怀疑</td></tr><tr><td align="center">小组会</td><td align="center">项目组的人全部叫出来开会讨论需求</td><td align="center">你小组的人有不同观点，并且有良好的发现需求的能力，能揭示需求中存在的问题，最重要的是需求能跟用户达成共识</td><td align="center">会议组织不到位就凉了，而且天天开会你的项目组的人也受不了，可能会提出矛盾需求</td></tr><tr><td align="center">提炼</td><td align="center">针对已有的部分需求文档，看线上反馈情况，进行提炼</td><td align="center">你需要有想象力和需求标识能力，包括熟悉相关的技术标准</td><td align="center">跟自悟一样，你不能知道你发现的需求是否是对的</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="需求规约"><a href="#需求规约" class="headerlink" title="需求规约"></a>需求规约</h3><p>需求规约就是怎么写一个需求表，因为形式很多，所以最好就根据实际情况进行，这里不做规定，但是必须包含以下几个特征</p><ol><li>重要性和稳定性：需求要根据重要程度和稳定程度分优先级，例如：基本需求、可选需求和期望需求。</li><li>可修改的：在不过多地影响其他需求的情况下，可以容易地修改一个单一需求。</li><li>完整的：没有被遗漏的需求。</li><li>一致的：不存在互斥的需求。</li></ol><p>为什么需求规约很重要？（概念性东西）</p><ol><li>是软件开发组织和用户之间一份事实上的技术合同书，是产品功能及其环境的体现。</li><li>对于项目的其余大多数工作，需求规约是一个管理控制点。</li><li>对于产品/系统的设计，需求规约是一个正式的、受控的起点。</li></ol><h2 id="结构化方法"><a href="#结构化方法" class="headerlink" title="结构化方法"></a>结构化方法</h2><h3 id="结构化需求分析"><a href="#结构化需求分析" class="headerlink" title="结构化需求分析"></a>结构化需求分析</h3><ol><li><p>为什么要这么做？</p><p> 为了应对三大挑战：</p><pre><code> - 问题空间理解。（假如让你开发一个八字排盘App，但是你又不懂八字，所以要开发出一个高质量、满足用户要求的App，就不容易了） - 人与人之间的通信。（开发过程长、活动多、任务重，项目组成员多，直接面对面沟通起来难免有遗漏、误解等，所以这也是一个挑战） - 需求的变化性。（需求是不断变化的，所以这是软件开发人员面临的挑战）</code></pre><p> 一种好的需求技术应该具有以下基本特征：</p><pre><code> 1. 提供方便通信的机子，例如，在不同开发阶段，使用对相关人员易于理解的语言。 2. 鼓励需求分析人员使用问题空间的术语思考问题，编写文档。 3. 提供定义系统边界的方法。 4. 提供支持抽象的基本机制，例如，&quot;划分&quot;，&quot;功能抽象&quot;，&quot;结构抽象&quot;等。 5. 为需求分析人员提供多种可供选择的方案。 6. 提供特定的技术，适应需求的变化等。</code></pre></li><li><p>几种基本术语的解释</p><p> (1) 数据流：数据流是数据的流动，用于表达在分析中所要使用的、用于表达”客体”的信息，用箭头表示。<br> 大概长这样：</p> <img width=50px src='https://i.loli.net/2019/10/21/wM2SkZXGDY46lQh.png'> (2) 加工：加工是数据变换的单元，即它接受输入的数据，对其进行处理，并产生输出。 大概长这样 <img width=50px src='https://i.loli.net/2019/10/21/mcfwVCaJI1Sn8kZ.png'> (3) 数据存储：数据存储是数据的静态结构。 大概长这样(可以是横的或者竖的) <img width=50px src='https://i.loli.net/2019/10/21/xbXKc45RlYpnNB9.png'> (4) 数据源和数据潭: 数据源是数据流的起点，数据潭是数据流的归宿地。数据源和数据潭是系统之外的实体，可以是人、物或其他软件系统。 大概长这样 <img width=50px src='https://i.loli.net/2019/10/21/LiwWbnSAs7Pqzoh.png'></li><li><p>数据流图</p><p> 把上面的元素组成起来就是数据流图了<br> 大概长这样</p> <img width=70% src="https://i.loli.net/2019/10/21/wDdaFiLe9Ps6UzA.png"><p> 几个要点：1）数据流起到连接其他实体的作用，实体可以是加工、数据存储、数据源和数据潭；2）加工之间可以有多个数据流，这些数据流之间可以没有任何关系，数据流图也不表明他们的先后次序；3）对于一个比较大的软件系统，往往需要采用多层次的数据流图。</p></li><li><p>建模过程</p><ol><li>建立系统环境图，确立系统语境</li><li>自顶向下，逐步求精，建立系统的层次数据流图</li><li>定义数据字典。数据字典有3种基本结构表示：顺序结构，选择结构，重复结构。<ul><li>顺序结构是指数据A由数据B和数据C顺序构成的，并记为”+”。例如：学生成绩=姓名+性别+学号+科目+成绩，其中”=”号表达的是”定义为”.</li><li>选择结构是指由数据A是由数据B或数据C定义的，即数据B不可能同时是B和C，并记为“|”，例如：性别=男|女</li><li>重复结构是指数据A是由多个重复出现的数据B构成的，并记为”| |”，例如：学生成绩表=|学生成绩|<img width="50%" src="https://i.loli.net/2019/10/21/43hSWgZPmVirHfA.png"></li></ul></li><li>描述加工：该步的目标为依据系统的数据流图，给出其中每一加工的小说明。加工可以有3种表达工具。<ol><li>结构化自然语言（自然语言描述）</li><li>判定表: 由条件类别，条件组合，操作，操作执行构成。举例如图<img width=50% src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D22%2C0%2C590%2C389%3Bc0%3Dbaike80%2C5%2C5%2C80%2C26/sign=d64b6fc508087bf469a30da9cfe16500/42166d224f4a20a48dfd6c499a529822730ed059.jpg"></li><li>判定树。举例如图<img width=60%  src="https://i.loli.net/2019/10/21/COmGSet5I61lFsH.png"></li></ol></li></ol></li><li><p>注意事项：</p><ol><li>模型平衡问题</li><li>信息复杂性控制问题</li></ol></li><li><p>需求验证<br> 验证需求规格说明书中的每一单一需求是否满足5个性质，即必要性、无歧义性、可测性、可跟踪性、可测量性；验证需求规格说明是否满足4个性质，即重要性和稳定程度、可修改性、完整性和一致性。在必要时还需要验证其他特性，如设计无关性。</p></li></ol><h3 id="结构化设计"><a href="#结构化设计" class="headerlink" title="结构化设计"></a>结构化设计</h3><h4 id="总体设计步骤"><a href="#总体设计步骤" class="headerlink" title="总体设计步骤"></a>总体设计步骤</h4><p>结构化设计方法基于<code>自顶向下，功能分解</code>的基本原则，针对两种不同类型的数据流图，分别提出了变换设计和事务设计。其中，变换设计的目标是将变换型数据流图映射为模块结构图，而事务设计的目标是将事务型数据流图映射为模块结构图。</p><ol><li><p>变换型数据流图和事务性和数据流图<br>（1）变换型数据流图：具有比较明显的输入部分和变换部分之间的界面、变换部分和输出部分之间界面的数据流图，称为变换型数据流图；<br><img src="https://www.sytm.net/ueditor/net/upload/2013-12-31/bdae1434-8b79-4209-b818-2502c7ea3bee.png"><br>（2）事务型数据流图：数据到达一个加工T，该加工T根据输入的值，在其后若干动作序列中选出一个来执行，这类数据流图成为事务型数据流图。<br><img src="https://www.sytm.net/ueditor/net/upload/2013-12-31/142b2c91-a9ad-4c6e-b075-ecd6a900ee63.png"></p></li><li><p>总体设计分为3个阶段。第一阶段为初始设计，在对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。第二阶段为精化设计，依据模块“高内聚低耦合”的原则精化初始的模块结构图，并设计其中的全局数据结构和每一模块的接口。第三阶段为复审阶段，对前两个阶段所得到的高层软件结构进行复审，必要时还可能需要对该软件结构做一些精化工作，这对软件的一些性质，特别是对软件质量的提高，将产生非常大的影响。</p></li><li><p>天天扯着嗓子喊高内聚低耦合，到底什么是内聚什么是耦合？</p><ul><li>耦合：耦合是指不同模块之间相互依赖程度的度量<ul><li>内容耦合：当一个模块直接修改或操作另一个模块的数据，或当一个模块直接修改或操作，另一个模块的数据或一个模块不通过正常入口转入到一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该尽量避免使用。</li><li>公共耦合：两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。</li><li>控制耦合：一个模块通过接口向另一个模块传递一个控制信号，接收信号的模块根据信号值进行适当的动作，这种耦合被成为控制耦合。</li><li>标记耦合：若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。</li><li>数据耦合：模块之间通过参数来传递数据，则称为数据耦合。数据耦合是最低的一种耦合形式。</li></ul></li><li>内聚：内聚是指一个模块内部各成分之间相互关联程度的度量<ul><li>偶然内聚：如果一个模块的各成分之间基本不存在任何关系，则称为偶然内聚</li><li>逻辑内聚：几个逻辑上相关的功能被放在同一模块中，则称为逻辑内聚。</li><li>时间内聚：如果一个模块完成的功能必须在同一时间内执行（例如，初始化系统或一组变量），但这些功能只是因为时间因素关联在一起，则称为时间内聚。</li><li>过程内聚：如果一个模块内部的处理成分是相关的，而且这些处理必须以特定的次序执行，则称为过程内聚。</li><li>通信内聚：如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚</li><li>顺序内聚：如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚</li><li>功能内聚：最理想的内聚是功能内聚，模块所有的成分对于完成单一的功能都是基本的。功能内聚的模块对完成其功能而言是充分必要的。</li></ul></li><li>启发式规则：无论是变换设计还是事务设计，都涉一个共同的问题，即“基于高内聚低耦合的原理，采用一些经验性的启发式规则，对初始的模块结构图进行精化，形成最终的模块结构图”。</li><li>怎么做？<ol><li>改进软件结构，提高模块独立性。</li><li>力求模块规模适中。</li><li>力求深度、宽度、扇出和扇入适中。深度：表示其控制的<code>层数</code>(不包括自身)；宽度：同一层次上模块总数的<code>最大值</code>；扇出：一个模块<code>直接</code>控制（调用）的下级模块数目；扇入：一个模块有多少个上级模块<code>直接</code>调用它。</li><li>尽力使模块的作用域在其控制域之内。作用域：受该模块内<code>一个判定</code>所影响的所有模块的集合；控制域：模块本身以及所有<code>直接或间接</code>从属于它的模块的集合。</li></ol></li></ul></li></ol><h4 id="详细设计步骤"><a href="#详细设计步骤" class="headerlink" title="详细设计步骤"></a>详细设计步骤</h4><ol><li>结构化程序设计<br> 包含三种基本控制结构：顺序结构、选择结构、循环结构</li><li>详细设计工具<ol><li>程序流程图 <img width=20% src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945069712&di=74b11092aae0042569e80dc22ee83438&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F09%2F17%2F02%2F27798515%2F15.files%2Ffile0001.jpg"> 缺点：不是一种逐步求精的工具，过早地考虑程序的流程，不去考虑程序的全局结构；所表达的控制流，往往不受任何约束可随意转移，从而会影响甚至破坏好的系统结构设计；不易表示数据结构。</li><li>盒图（N-S图） <img width=40% src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945228461&di=10908d6d12f9c8984356e884b3c0aeb5&imgtype=0&src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fzhidao%2Fwh%253D450%252C600%2Fsign%3Da401ed95523d26972e86005960cb9ecd%2Fd833c895d143ad4bd5fe969f81025aafa50f0698.jpg"></li><li>PAD图（Problem Analysis Diagram） <img width="40%" src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945326054&di=d66d2f92c755db3f26640c2bbb6bc338&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F12%2F15%2F14%2F51872755%2F6.files%2Ffile0001.jpeg"></li></ol> N-S图和PAD图支持“自顶向下逐步求精”的设计。可节省人工编码工作，有利于提高软件的可靠性和软件生产率<ol start="4"><li>类程序设计语言（伪码/PDL）<br> 是一种用正文形式表示数据结构和处理过程的设计工具，PDL是一种“混合”的语言。</li></ol></li><li>设计规约<br> 完成软件设计后，应产生设计规约，完整准确地描述满足系统需求规约所要求的的所有功能模块，以及伴随功能模块而出现的非功能机制。设计规约通常包括<code>概要设计规约</code>和<code>详细设计规约</code>。 <code>概要设计规约</code>指明高层软件体系结构，其主要功能如下： 1.系统环境等与设计有关的限定条件 2. 软件模块的结构（模块之间的接口及设计的数据流和主要数据结构）3. 模块描述（接口定义，模块处理逻辑，必要的注释等）4. 文件结构和全局数据文件的逻辑结构 5.测试需求 <code>详细设计规约</code>（包括各处理过程的算法和算法所涉及的全部数据结构的描述）主要作为软件设计人员与程序员之间交流的媒体。</li></ol><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><h3 id="UML是一种图形化建模语言（Unified-Modeling-Language）"><a href="#UML是一种图形化建模语言（Unified-Modeling-Language）" class="headerlink" title="UML是一种图形化建模语言（Unified Modeling Language）"></a>UML是一种图形化建模语言（Unified Modeling Language）</h3><p>为了支持抽象分析和设计中的事物，UML给了八个基本术语，即类、接口、协作、用况、主动类、构件、制品、节点、</p><ul><li>类： 类是一组拥有相同属性、操作、关系和语义的对象的描述。类主要用于抽象客观世界中的事物。</li><li>接口：每个操作描述了类、构件或子系统的一个服务，接口就是操作的一个集合。接口是对系统/产品的“接缝”予以模型化，表明了一个类、构件、子系统所需要得到的、且与实现无关的行为。</li><li>用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的、可观察的结果。</li><li>协作：协作是一个交互，涉及交互的三要素：交互各方、交互方式以及交互内容</li><li>用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的，可观察的结果。</li><li>主动类：主动类是一种至少具有一个进程或线程的类。</li><li>构件：构件是系统设计中的一种模块化部件，通过外部接口隐藏了它的内部实现。</li><li>制品：制品是系统中包含物理信息（比特）的、可替代的物理部件。</li><li>节点：节点是运行时存在的物理元素，通常表示一种具有记忆能力和处理能力的计算机资源。</li></ul><p>类在建模中的主要用途：</p><ol><li>模型化问题域中的概念</li><li>建立系统的职责分布模型</li><li>模型化建模中使用的基本类型</li></ol><p>使用接口应注意的问题</p><ol><li>接口只可以被其他类目使用，而本身不能访问其他类目</li><li>接口描述类的外部可见操作，通常是该类的一个特有限定行为。这些操作可以使用可见性、并发性、衍型、标记值和约束来修饰。</li><li>接口不描述其中操作的实现，也没有属性和状态。据此可见，接口在形式上等价于一个没有属性、没有方法而只有抽象操作的抽象类</li><li>接口之间没有关联、泛化、实现和依赖。但可以参与泛化、实现和依赖</li></ol><h3 id="表达关系的术语"><a href="#表达关系的术语" class="headerlink" title="表达关系的术语"></a>表达关系的术语</h3><pre><code>关联：关联是一组具有相同结构、相同链的描述，是类目之间的一种结构关系。关联可以用一条连接两个类目的线段表示，并可对其命名，其结构可以具有方向性，用一个实心三角形来指示关联的方向。    1. 关联名 。    2. 导航：对于一个给定的类目，可以找到与之关联的另一个类目，这称为导航。    3. 角色：角色是关联一端的类目对另一端的类目的一种呈现。    4. 可见性：通过导航可以找到另一类目的实例，有时候需要限制访问。    5. 多重性：类中对象参与一个关联的数目，成为该关联的多重性    6. 限定符：限定符是一个关联的属性或属性表。    7. 聚合：分类是增强客观实际问题语义的一种手段。聚合是对象之间（不是类之间）的一种结构关系。    8. 组合：组合是聚合的一种特殊形式泛化：泛化是一般性类目和它的较为特殊类目之间的一种关系。子类可以继承父类的属性和操作，同时也可以替换父类的声明。    泛化的四种约束：完整、不完整、互斥、重叠细化：细化是类目之间的语义关系，其中一个类目规约保证了另一个类目执行的契约。依赖：依赖用于描述一个类目使用另一个类目的信息和服务，是一种使用关系。    依赖的分类：绑定、导出、允许、示例、实例化、幂类型、精化、使用。    关联、泛化和细化都是一类特地类型的依赖。使用这四种术语，可以模型化以下各种关系：1. 结构关系（静态结构和动态结构）    进行模型化时两种驱动方式：1.以数据驱动 2. 以行为驱动2. 继承关系3. 精化关系4. 依赖关系</code></pre><h3 id="表达组合信息的术语————包"><a href="#表达组合信息的术语————包" class="headerlink" title="表达组合信息的术语————包"></a>表达组合信息的术语————包</h3><p>为了控制信息组织的复杂性，UML提供了组织信息的一种通用机制————包，支持形成一些可管理的部分。换言之，包可以作为“模块化”和“构件化”的一种机制。</p><p>包是模型元素的一个分组。一个包本身可以被嵌套在其他包中，并且可以含有子包和其他种类的模型元素。</p><p>通过在包的名字前加上一个可见性符号（+，-，#），来指示该包的可见性。</p><pre><code>+ 表示对其他包而言都是可见的# 表示对子孙包而言是可见的- 表示对其他包而言都是不可见的```为了模型化包之间的关系，UML给出了两种依赖，即访问和引入。- 访问：表明目标包中的内容可以被源包所引用，或被那些递归嵌套在源包中的其他包所引用。- 引入：表明目标包中具有适当可见性的内容（名字）被加入到源包的公共命名空间中。UML中用虚线加箭头的方式表示源包到目标包的依赖（访问和引入）。### UML术语的作用1. 类用于抽象客观事物2. 接口用于抽象事物之间的缝隙3. 协作用于抽象协作性行为4. 用况用于抽象功能5. 主动类用于抽象并发行为6. 构件用于抽象软件解中标识的成分7. 制品用于抽象工作产品8. 节点用于抽象计算单元9. 关联用于抽象结构关系10. 泛化用于抽象“一般/特殊”关系11. 实现用于抽象精化关系12. 依赖用于抽象使用关系### UML的模型表达式1. 结构图和行为图    结构图用于表达系统或系统成分的静态结构模型，给出系统或系统成分的一些说明性信息    行为图用于表系统或系统成分的动态结构模型，给出系统或系统成分的一些行为信息2. 类图、用况图、顺序图及状态图    - 类图是可视化地表达系统静态结构功能模型的工具，使用类图所表达的系统静态结构模型，给出的是一些关于系统的说明性信息。    ![](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1572176025075&amp;di=1875f9ac829f33a38a45131069ee3e4a&amp;imgtype=0&amp;src=http%3A%2F%2Fimages.cnblogs.com%2Fcnblogs_com%2Fa-i%2FUml2.JPG)    - 用况图是一种表达系统功能模型的图形化工具，它包含六个模型元素，分别是主题、用况、参与者、关联、泛化、依赖    ![](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1572176303343&amp;di=4146dfc9badef7bc95f4c750ab149eb0&amp;imgtype=0&amp;src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F09%2F24%2F23%2F28839740%2F23.files%2Ffile0001.png)    - 顺序图由一组对象以及按时序组织的对象之间的关系组成，是一种交互图，包含对象之间传递的信息。控制操作包括`选择执行操作`、`条件操作`、`并发迭代操作`、`迭代执行操作`。    ![](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1572176439921&amp;di=d592e65ae4a1bc1c2e65a98e415a897a&amp;imgtype=0&amp;src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fpng%2F20180615101636402475.png)    - 状态图强调了从一个状态到另一个状态的控制流，是显示一个状态机的图。状态图由状态、事件和状态转移构成。使用状态图的作用有两个：一是创建一个系统的动态模型，二是创建一个场景的模型    ![](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1572176576658&amp;di=70e3de58666cf1d7315cf56a05ec0d35&amp;imgtype=0&amp;src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F12%2F07%2F08%2F48638362%2F25.files%2Ffile0001.png)    -3. 创建一个系统的类图的步骤    - 模型化代建系统中的概念，形成类图中的基本元素    - 模型化代建系统中的各种关系，形成该系统的初始类图    - 模型化系统中的协作，给出该系统的最终类图    - 模型化逻辑数据库模式4. 信号事件、调用事件、时间事件和变化事件    - 信号事件是一种异步事件，信号通常由状态机处理。如果没有定义对该事件的响应，那么事件均可能丢失。事件的丢失，就有可能引发接受者——状态机的一个错误的状态转移。5. 状态转移所涉及的内容    描述一个状态转换，一般涉及五个部分：    1. 源状态：发生状态转移的那个状态    2. 转移触发器：在源状态中由对象识别的事件，并且一旦满足其监护条件，则使状态发生转移。    3. 监护条件：一个布尔表达式，当某个事件触发器接受一个事件时，如果该表达式有值为真，则触发一个转移；若有值为假，则不发生状态转移。    4. 效应：一种可执行的行为    5. 目标状态：转移完成后所处的状态6. 最常用的控制操作子    选择执行操作子：该操作子由两部分组成：一是监护条件，二是控制体    条件执行操作子：控制体通过水平线将其分为一些部分，每一部分表示一个条件分支，每一分支有一个监护条件。    并发执行操作子：该控制操作子的体通过水平线将其分为多个部分，每一部分表示一个并行计算。该控制操作子表明，当进入该控制操作子是，所有部分并发执行。    迭代执行操作子：该控制操作子表明，只要在每一次迭代之前该监护条件为真，那么该控制体就反复执行，当该控制体上面的监护条件为假时，控制绕过该控制操作子。7. 子状态机、简单状态和组合状态的概念    子状态机：为了有效地组织状态、控制对象状态的复杂性，UML提供了组合状态，在一个状态机中引入了另一个状态机。被引入的状态机就称为子状态机。    简单状态：子状态是被嵌套到另一状态中的状态。相对地，被引入的状态机就称为子状态机。    组合状态：把含子状态的状态称为组合状态，组合状态可包含两种类型的子状态机，即非正交（顺序）子状态机和正交（并发）子状态机。## RUP### RUP(Rational Unified Process)的特点RUP的突出特点是，它是一种以用况（Use Case）为驱动的、以体系结构为中心的迭代、增量式开发。1. 以用况为驱动以用况为驱动是指在系统的生存周期中，以用况作为基础，驱动系统有关人员对所要建立系统的功能需求进行交流，驱动系统分析、设计、实现和测试等活动。2. 以体系结构为中心以体系结构为中心是指在系统的生存周期中，开发的任何阶段都要给出相关模型视角下有关体系结构的描述，作为构思、构造、管理和改善系统的主要标准。3. 迭代、增量式开发迭代、增量式开发是指通过开发活动的迭代，不断地产生相应的增量。在RUP中，规定了四个开发阶段：初始阶段、精化阶段、构造阶段和移交阶段。### 核心工作流核心工作流：需求获取、分析、设计、实现和测试#### 需求获取|基本步骤|产生的制品||:---:|:---:||列出候选的特征|特征表||理解系统语境|领域模型或业务模型||捕获功能需求|用况模型||捕获非功能需求|补充需求或针对特殊需求的用况|### 业务用况模型和业务对象模型1. 业务用况模型。业务用况模型是以用框图予以表达的2. 业务对象模型。为了精化业务用况模型中的每一个业务用况，RUP引入了三个术语，用于表达参与业务的业务对象：`工作人员`、`业务实体`和`工作单元`。业务对象模型可通过交互图和活动图予以表达。### 标识用况应注意的问题1. 建立用况的结构中，应尽可能反映用况的实际情况。2. 在用况的结构化中，不论是施加什么结构，新引入的用况都不应该太小或太大3. 在建立用况的结构是，应尽量避免对用况模型中的用况功能进行分解。#### 需求分析1. 分析类是类的一种衍型，分为边界类、实体类和控制类2. 用况细化时一个协作，针对一个用况，其行为可用多个分析类之间的相互作用来细化，并记为用况细化。用况细化对用况模型中的一个特定的用况提供了一种直接跟踪的方式。3. 分析包是一种控制信息组织复杂性的机制，提供了分析制品的一种组织手段。其主要特征为：体现问题的分离；高内聚、低耦合；尽可能体现一个系统的完整顶层设计，尽可能成为一些子系统或者成为一些子系统的组成部分。    #### 具有良好结构的分析包的特征1. 体现问题分离2. 高内聚、低耦合。3. 尽可能提现一个系统的完整顶层设计。#### 软件设计层上的术语软件设计是满足需求规约所需要的软件结构。RUP为了满足系统/产品分析模型规约需求的软件结构，为设计层提供了是个术语：设计类、用况细化、设计子系统和接口，用于表达软件结构中的基本元素。1. 设计类：一个设计类是对系统中实现一个类或类似构造的一个无缝抽象2. 用况细化：用况细化是设计模型的一个协作，其中使用设计类及其对象，描述一个特定用况是如何予以细化的，是如何执行的3. 设计子系统：设计子系统可以包含设计类、用况细化、接口，以及其他子系统，通过对其操作来显示其功能。4. 接口：接口用于规约由设计类和设计子系统，必须提供与该接口操作对应的实现方法。#### 创建系统/产品用况模型的活动和任务创建系统/产品用况模型的活动和任务如下1. 活动一：发现并描述参与者任务1：发现参与者，即直接发现一些候选的参与者任务2：描述参与者，即对参与者进行命名并描述2. 活动二：发现用况并对用况进行描述任务1：发现用况任务2：描述用况，即确定用况后对其进行描述3. 活动三：确定用况的优先级，目的是在寻找参与者并对其进行描述和发现用况的并对用况进行描述的基础上确定哪些用况适合在早期的迭代中开发，哪些适合在后期的迭代中开发。4. 活动四：精化用况。这一活动的目的是详细描述出每一用况的事件流，包括用况是怎样开始的，是怎样结束的，是怎样与参与者进行交互的，最终形成一系列精化的用况5. 活动五：构造用户界面原型。这一活动的目的在于建造用户界面原型，使用户可以有效地执行用况。6. 活动六：用况模型的结构化。需要进行以下工作。    1. 抽取用况描述中的那些一般性的和共享的功能并使用泛化关系标识和描述那些共享功能    2. 抽取用况描述附加的或可选的功能    3. 标识用况之间的包含关系。通过用况模型的结构化，最终形成一个系统/产品的精化用户模型    #### 创建系统/产品需求分析模型的活动和任务1. 活动1：体系结构分析。该活动的目标是通过标识分析包和分析类，建立分析模型和体系结构“骨架”，并标识有关分析包和分析类的特定需求。任务1：标识分析包。该任务的基本输入是系统的用况模型任务2：处理分析包之间的共性任务3：标识服务包任务4：定义分析包的依赖，该任务的目标是发现相对独立的包，实现包的高内聚和低耦合任务5：标识重要的实体类，该任务的目标是标识在体系结构方面具有意义的实体类。任务6：标识分析包和重要实体类的公共特定需求，该任务的目标是依据需求获取阶段所标识的非功能需求，针对在分析期间所标识的包和分析类，标识它们的一些公共的特定要求。2. 活动2：用况分析。该活动的目标是：一是标识那些在用况事件流执行中所需要的分析类和对象；二是将用况的行为分布到参与交互的各个分析对象；三是捕获用况细化上的特定需求。任务1：标识分析类，该任务的目标是标识在细化一个用况中所需要实体类、控制类和边界类，给出它们的名字、责任、属性和关系。任务2：描述分析类对象之间的交互。首先确定细化该用况所必要的交互，其次分派该用况的功能，最后根据其责任，发现该交互图中的各个链。3. 活动3：类的分析。该活动的目标：一是标识并维护分析类的属性和关系；二是捕获分析类细化中的特殊需求。任务1：标识责任，通过组合一个类在不同用况细化中所扮演的角色来完成。任务2：标识属性任务3：标识关联和聚合4. 活动4：包的分析。该活的目标是：一是确保分析包尽可能与其他包相对独立；而是确保分析包实现了它的目标；三是描述依赖，以益于可以估计未来的变化。###  创建系统/产品设计模型的活动和任务创建系统/产品设计模型的活动和任务如下：1. 活动1：体系结构设计，该活动的目标是创建设计模型和部署模型，以及它们视角下的体系结构描述任务1：标识节点和它们的网络配置，网络配置通常使用一种三元模式：客户端、数据库功能、业务/应用逻辑任务2：标识子系统和它们的接口，目的是为了寻求一些复用的可能，而后随着设计模型的开发，在形成子系统结构中不断发现并烟花。任务3：标识在体系结构方面有意义的设计类和它们的接口。标识在体系结构方面有意义的设计类的基本思想是：初始可以依据在体系结构方面有意义的分析类来标识一些体系结构上具有重要意义的设计类。标识在系统体系结构方面有意义的设计类时，应注意主动类往往是一类在体系结构方面具有重要意义的类。2. 活动2：用况的设计。其中分析模型用况细化分析是活动的输入、对应输出用况细化设计。为了实现用况设计的输入/输出，一般采用两种方法：    1. 标识参与用况细化的设计类，首先基于分析模型研究相应用况细化分析中的分析类，来标识为细化这些分类所需要的设计类，然后基于用况的功能对每一个标识的设计类赋予相应的责任，最后为该细化创建一个类图，汇聚参与该用况细化的设计类，并给出类之间的关系。    2. 标识参与用况细化的子系统和接口。3. 活动3：类的设计。该活动的目标是完成用况细化设计中每一个类的角色设计，并完成有关每一类的非功能需求的设计。任务1：概括描述设计类，该任务的输入为分析类/接口。任务2：标识的操作，一般应依据分析类来标识设计类所提供的、所需要的操作，其中需要使用程序设计语言的语法来描述说标识的操作。任务3：标识属性，该任务的目标是标识设计类所需要的属性，并使用程序设计语言的语法给出属性的描述。任务4：标识关联和聚合。任务5：标识泛化，基于分析模型中分析类之间的泛化，可以发现设计模型中的很多泛化。任务6：描述方法，在设计期间一般用自然语言或适当的使用伪码对方法进行规约，但是在实现期间直接使用程序设计语言对方法进行规约。任务7：描述状态，有些设计对象是受状态控制的，即它们的状态确定了它们接受一个消息的行为。在这种情况下，使用一个状态图描述一个对象的不同状态转移是有意义的。4. 活动4：子系统的设计。该活动的目标是：确保子系统尽可能独立于其他子系统或它们的接口；确保子系统提供正确的接口；确保子系统实现了它的目标，即给出了该子系统提供的那些接口所定义的操作的细化。### 设计模型包含的元素RUP设计的主要结果是设计模型，它尽量保持该系统具有分析模型的结构，并作为系统实现的输入，包含以下四个元素：1. 设计子系统和服务子系统，以及它们的接口、依赖和内容。2. 设计类以及它们具有的操作、属性、关系及其实现的需求。3. 用况细化设计。4. 设计模型视角下的体系结构描述。### 用况模型与分析模型的比较|用况模型|分析模型||:----:|:---:||使用客户语言来描述 |使用开发者语言来描述 ||给出的是系统对外的视图 | 给出的是系统对内的视图 ||使用用况予以结构化，但给出的是外部视角下的系统结构 | 使用衍型类予以结构化，当给出的是内部视角下的系统结构 ||可以作为客户与开发者之间关于“系统应该做什么，不应该做什么”的契约 |可以作为开发者理解系统如何勾画、如何设计和如何实现的基础||在需求之间可能存在一些冗余、不一致和冲突等问题|在需求之间不应存在冗余、不一致和冲突问题||捕获的是系统的功能，包括在体系结构方面有意义的功能|给出的是细化的系统功能，包括在体系结构方面具有意义的功能||定义了一些进一步需要在分析模型中予以分析的|定义了用况模型中每一个用况的细化|### RUP实现活动目标：基于设计类和子系统生成构件；对构件进行单元测试，进行集成和连接；把可执行的构件映射到部署模型。|输入|活动|执行者|输出||:----:|:---:|:---:|:---:||设计模型、部署模型、体系结构描述【设计模型、部署模型角度】|实现体系结构|体系结构设计者|构件【概述】、体系结构描述【实现模型、部署模型角度】||补充需求、用况模型、设计模型、实现模型【当前建造】|集成系统|系统集成者|集成建造计划、实现模型【连续的建造】||集成建造计划、体系结构描述【实现模型角度】、设计子系统【已设计】、接口【已设计】|实现子接口|构件工程师|实现子系统【建造完成】、接口【建造完成】||设计类【已设计】、接口【由设计类提供】|实现类|构件工程师|构件【完成】||构件【完成】、接口|完成单元测试|构件工程师|构件【已完成单元测试】|### RUP测试活动RUP的测试包括内部测试、中间测试和最终测试|输入|活动|输出||:----:|:---:|:---:||补充需求、用况模型、分析模型、设计模型、实现模型、体系结构的描述|计划测试|测试计划||补充需求、用况模型、分析模型、设计模型、实现模型、体系结构描述、测试计划|设计测试|测试用况 测试过程||测试用况、测试过程、实现模型|实现测试|测试构件||测试用况、测试过程、测试构件、实现模型|执行集成测试|缺陷||测试用况、测试过程、测试构件、实现模型|执行系统测试|缺陷||测试用况、测试模型、缺陷|评价测试|测试评价|## 软件测试### 软件测试目标与软件测试过程模型#### 软件测试及目标软件测试的定义为：按照特定规程发现软件错误的过程。其目的是检验它是否满足规定的需求，或清楚了解预期结构与实际结果之间的差异#### 软件测试与软件调试之间的区别软件测试与软件调试相比，在目的、技术和方法等方面都存在很大区别，主要表现在以下几个方面。1. 测试从一个侧面证明程序员的&quot;失败&quot;.调试是为了证明程序员的正确。2. 测试以已知条件开始，使用预先定义的程序且有预知的结果，不可预见的仅是程序是否通过。调试一般是以不可知的内部条件开始，除统计性调试外，结果是不可预见的。3. 测试是有计划的，并要进行测试设计。调试是不受时间约束的。4. 测试是一个发现错误、改正错误、重新测试的过程。调试是一个推理过程。5. 测试的执行是有规程的。调试的执行往往要求程序员进行必要推理。6. 测试经常是由独立的测试组在不了解软件设计的条件下完成的。调试必须由了解详细设计的程序员完成。7. 大多数测试的执行和设计可由工具支持。调试时，程序员能利用的主要工具是调试器。#### 测试过程模型软件测试是一个有程序的过程，包括测试设计、测试执行以及测试结果比较。测试过程模型可分为三类：环境模型、被测对象模型和错误模型。1. 环境模型：是对程序运行环境的抽象。程序运行环境又包括支持其运行的硬件、固件和软件，如计算机、终端设备、网卡、操作系统、编译系统、实用程序等。在软件测试过程中，建立环境模型的主要目的是，确定所发现的错误是否为环境造成的。2. 被测对象模型：该模型是从测试的角度对程序的抽象。为了测试，必须简化程序，形成被测程序的抽象版本、即对象模型。3. 错误模型：该模型是对程序中的错误及其分类的抽象。在软件测试中，往往需要定义“什么是错误”、“什么是一般性错误”、“什么是严重性错误”等，即要给出“错误模型”。### 软件测试技术1. 测试覆盖及其他们之间的基本关系软件测试技术大体上可分为两大类：一类是白盒测试技术，又称为结构测试技术，典型的是路径测试技术；另一种是黑盒测试技术，又称为功能测试技术，包括事务处理流程技术、状态测试技术、定义域测试技术等。白盒测试技术依据的是程序的逻辑结构，而黑盒测试技术依据的是软件行为的描述。2. 路径测试技术的分类    测试覆盖包括路径覆盖、分支覆盖、条件覆盖与条件组合覆盖。    1. 路径覆盖：执行所以有可能穿过程序控制流程的路径。在路径测试中，该度量是最强的，一般是不可实现的。    2. 语句覆盖：至少执行程序中所有语句一次    3. 分支覆盖：至少将程序中的每一个分支执行一次    4. 条件覆盖与条件组合覆盖：条件覆盖是指每个判定中所有的可能的条件的取值至少执行一次；条件组合覆盖是指设计足够的测试用例，使每个判定中所有可能的条件取值组合至少执行一次。        这四种测试覆盖的测试覆盖率由弱到强的顺序是：语句覆盖 &lt; 分支覆盖 &lt; 条件组合覆盖 &lt; 路径覆盖3. 事务流测试步骤    事务流测试步骤具体如下。    第一步：获得事务流程图。    第二步：浏览、复审。    第三步：用例设计。    第四步：测试执行。    4. 运用等价类划分技术进行测试的步骤    具体测试步骤如下。    第一步：建立等价类表    第二步：为有效等价类设计测试用例    第三步：为无效等价类至少设计一个测试用例    5. 边界值分析的使用原则    边界值分析是一种常用的黑盒测试技术。使用边界值分析在设计测试用例时，可以遵循以下原则。        1. 如果某个输入条件规定了输入值的范围，则应该选择正好等于边界值的数据，以及刚刚超过边界值的数据作为测试数据。    2. 如果某个输入条件规定了值的个数，则可用最大个数、最小个数、比最大个数多1、比最小个数少1的数据作为测试数据    3. 根据规格说明的每个输出条件，使用前面的原则1    4. 根据规格说明的每个输出条件，使用前面的原则2    5. 如果程序的规格说明中，输入域或输出域是有序集合，在实践中则经常选取集合的第一个元素、最后一个元素以及典型元素作为测试用例。    6. 如果程序中使用了内部数据结构，则应该选择这个内部数据结构的边界上的值作为测试用例。    7. 分析规格说明，找出其他可能的边界条件。    6. 使用因果图生成测试用例的步骤    因果图技术是通过为判定表的每一列设计一个测试用例，从而实现测试用例的设计与选择的。该方法生成测试用例的基本步骤如下。    1. 通过软件规格说明书的分析，找出一个模块的原因和结果，并给每个原因和结果赋予一个标识符    2. 分析原因与结果之间以及原因之间对应的关系，并画出因果图。    3. 在因果图上标识出一些特定的约束或限制条件。    4. 把因果图转换成判定表。    5. 把判定表的每一列拿出来作为依据，设计测试用例。    ### 软件测试步骤1. 单元测试    单元测试主要检验软件设计的最小单元---模块。该测试以详细设计文档为指导，测试模块内的重要控制路径。一般来说，单元测试往往采用白盒测试技术。    2. 集成测试    集成测试是软件组装的一个系统化技术，其目标是发现与接口有关的错误，将经过单元测的模块构成一个满足设计要求的软件结构。集成测试集中于模块组合的功能和软件结构检验。集成测试可“自顶向下”地进行，称为自顶向下的集成测试；也可以“自底向上”地进行测试，称为自底向上的集成测试3. 有效性测试    有效性测试的目标是发现软件实现的功能与需求规格说明书不一致的错误。因此有效性测试通常采用黑盒测试技术。    4. 系统测试    系统测试验证将软件融于更大系统中时整个系统的有效性。## 软件生存周期过程与管理### 软件生存周期过程概述1. 过程分类    按过程主体把软件生存周期过程分为以下几个过程。    1. 基本过程：是指那些与软件生产直接相关的活动集。该过程又可分为获取过程、供应过程、开发过程、运行过程和维护过程。    2. 支持过程：是指有关各方按他们的目标所从事的一系列相关支持活动集。该过程又可分为文档过程、配置管理过程、质量保证过程、验证过程、确认过程、联合评审过程、审计过程和问题解决过程。    3. 组织过程：是指那些与软件生产组织有关的活动集。该过程又可分为设计过程、基础设施过程、培训过程和改进过程。    2. 系统语境的过程类    系统语境的过程类包含四个过程组，分别是协议过程组、项目过程组、技术过程组和组织上项目使能过程组。    1. 协议过程组包含两个过程：获取过程和供应过程。    2. 项目过程组包含七个过程：项目规划过程、项目评价过程、决策管理过程、风险管理过程、配置管理过程、信息管理过程和测量过程。    3. 技术过程组包含11个过程：利益攸关方需求定义过程、系统需求分析过程、系统体系结构设计过程、实现过程、系统集成过程、系统测试过程、软件安装过程、软件接受支持过程、软件运行过程、软件维护过程和软件销毁过程。    4. 组织上使能过程组包含五个过程：生存周期模型管理过程、基础设施管理过程、项目包管理过程、人力资源管理过程和质量管理过程。    3. 组织上使能过程的作用。    组织上使能的过程一般来说是组织层面上的工作，为项目的执行提供基本保障。该过程包含五个子过程。    1. 生存周期模型管理过程：其任务为过程建立、过程评估、过程改进。    2. 基础设施管理过程：其任务为过程实现、基础设施的建立、基础设施的维护。    3. 项目包管理过程：项目初始化、项目包评估、项目结束处理。    4. 人力资源管理过程：其任务为技能标识、技能开发、技能获取和供给、知识管理。    5. 质量管理过程：其任务为质量管理、质量管理纠正措施。### 过程描述软件验证过程包括两个活动：过程实现和验证。其中验证活动有五个任务：需求验证、设计验证、代码验证，集成验证和文档验证。一个过程可通过过程意图，期望的结果以及到达过程结果需要执行的活动和任务来描述。对于一个过程的完整技术上的描述，还应包括：达到过程意图和实现过程结果的方法或规程，以及过程和活动文档。### 应用说明1. 系统和软件的关系    在《ISO/IEC系统与软件工程-软件生产周期过程12207-2008》标准中，把软件认为是整个系统的一个组成从部分，执行系统中所确定的功能主要包括三大功能：控制功能、耦合功能以及软件本身提供的功能。由于软件通常存在与一个系统的上下文中，因此软件产品或服务一般可被认为是系统的一个项或称为系统元素。    2. 剪裁过程及应用    剪裁过程是使剪裁这一标准过程慢速以下特定情况或因素。    1. 围绕一个组织，其中该组织在一个协议中使用了这一标准    2. 影响一个项目，其中要求该项目满足一个引用该标准的协议    3. 反映一个组织的需要，其中该组织要供给产品或服务    ### 软件生存周期模型1. 瀑布模型    瀑布模型是将软件生存周期各个活动规定为按固定顺序链接的若干阶段的模型。这一模型规定了个开发阶段的活动：系统需求、软件需求、需求分析、设计、编码、测试和运行，并且自上而下具有相互衔接的固定顺序；还规定了每一个阶段的输入，即工作对象以及本阶段的工作成果，作为输出传送到下一阶段。    瀑布模型的提出，对软件工程的主要贡献如下。    1. 在决定系统怎样做之前存在一个需求阶段，它鼓励对系统做什么进行规约。    2. 在系统构造之前存在一个需求阶段，它鼓励规划系统结构。    3. 在每一阶段结束时进行评审，从而允许获取方和用户的参与。    4. 前一步可以作为下一步被认可的、文档化的基线，并允许基线和配置早期接受控制。    瀑布模型的主要问题是：    1. 要求客户能完整、正确和清晰地表达他们的需求；并要求开发人员一开始就要理解这一应用。    2. 由于需求的不稳定性，使设计、编码和测试阶段都可能发生延期；并且当项目接近结束时，出现了大量的集成和测试工作。    3. 在开始的阶段中，很难评估真正的进度状态；并且直到项目结束之前都不能演示系统的能力。    4. 在一个项目的早期开发阶段，过分地强调了基线和里程碑处的文档；并可能需要花费更多的时间用于建立一些用处不大的文档。    2. 增量模型    增量模型是一种非整体开发的模型。软件在该模型中逐渐开发出来，开发出一部分，向用户展示一部分，可让用户及早看到部分软件，及早发现问题。该模型具有较大的灵活性，适合软件需求不明确、设计方案有一定风险的软件项目。3. 演化模型    该模型主要针对事先不能完整定义需求的软件开发在用户提出待开发系统的核心需求的基础上，软件开发人员按照这一要求，首先开发一个核心系统并投入运行，以便用户能够有效地提出反馈，即精化系统、增强系统能力的需求；接着，软件开发人员根据用户反馈，实施开发的迭代过程；每一迭代过程均由需求、设计、编码、测试、集成等阶段组成，为整个系统增加一个可定义的，可管理的子集；如果在一次迭代中，有的需求不能满足用户的要求，可在下一次迭代中予以修正。    主要特征：该模型显式地把需求获取扩展到需求阶段，既为了第二个构造增量，使用了第一个构造增量来精化需求。演化模型在一定程度上可以减少软件开发活动的盲目性。不足之处：在演化模型的使用中，即使很好地理解了需求或设计，也很容易弱化需求分析阶段的工作。4. 螺旋模型    螺旋模型将瀑布模型与增量模型结合起来，加入了两种模型均忽略了的风险分析，弥补了这两种模型的不足。因而它是一种风险驱动的模型。螺旋模型将开放过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合。    螺旋模型关注解决问题的基本步骤，即标识问题，标识一些可选方案，选择一个最佳方案，遵循动作步骤并实施后续工作。其一个突出特征是，在开发的迭代中实际上只有一个迭代过程真正开发了可交付的软件。螺旋模型与演化模型和增量模型相比，同样适用了瀑布模型作为一个嵌入的过程，但螺旋模型所关注的阶段以及它们的活动是不同的。如果项目的开发风险很大或客户不能确定系统需求，在更广泛的意义上来讲，还包括一个系统或系统类型的要求，这时螺旋模型就是一个很好的生存周期模型。5. 喷泉模型    喷泉模型体现了软件创建所固有的迭代和无间隙的特征。该模型主要用于支持面向对象技术的软件开发。由于对象概念的引入，使分析、设计、实现之间的表达没有明显间隙。### 过程规划与管理1. 创建一个软件项目生存周期过程的步骤    1. 选择软件生存周期模型    2. 细化所选择的生存周期模型    3. 为每一个活动或任务标识合适的实例数目    4. 确定活动的时序关系，并检查信息流    5. 建立过程计划的文档    2. 软件评估中应考虑的影响因素    1. 不管做怎么样的决策，都必须对所采取的的措施对生存周期过程所产生的影响进行评审，以便保证项目获得好的结果。在这一评估中，应考虑以下几方面的影响。        1. 所要求的的“返工”        2. 资源需求        3. 实施时间        4. 对项目和用户的益处        5. 员工情绪## 集成化能力成熟度模型（CMMI）### 背景和原理1. 过程改善    历史过程改善，是指人为设计的一个活动程序，其目的是改进组织的过程性能和成熟度，并改进这一程序的结果2. 过程域、专用目标和共用目标    过程域是一个业务域中一束相关的实践，当它们一起得以实现时，就满足被认为对该过程域的改善具有重要作用的一组条件    专用目标是用于描述满足该过程域必须呈现的一些独有特征。经可以用于帮助确定一个过程域是否得以满足。    共用目标用于描述产现制度化的该过程必须呈现的特征，仅用于确定一个过程域是否得以满足。### CMMI的模型部件|过程域类名|包括的过程域||:---:|:---||项目管理类|项目规划&lt;br/&gt;项目监控&lt;br/&gt;定量项目管理&lt;br/&gt;集成项目管理&lt;br/&gt;风险管理&lt;br/&gt;提供方协议管理||工程类|需求开发&lt;br/&gt;需求管理&lt;br/&gt;技术解决方案&lt;br/&gt;产品集成&lt;br/&gt;确认&lt;br/&gt;验证||支持类|配置管理&lt;br/&gt;过程和产品质量保证&lt;br/&gt;测量与分析&lt;br/&gt;原因分析与解决&lt;br/&gt;决策分析与解决||过程管理类|组织过程定义&lt;br/&gt;组织过程性能&lt;br/&gt;组织过程培训&lt;br/&gt;组织过程关注&lt;br/&gt;组织创新与部署|### CMMI的等级1. 能力等级的组成    能力等级是用来表征组织对一个过程域的改善，是不断改善一个给定过程域的一种手段。在CMMI中，针对每个过程域设定了6个能力等级，即0级：未完成级；1级：已执行级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：待续优化级。    2. 成熟度等级的组成        在CMMI中，应用于一个组织过程改善的成熟度等级有5个。即1级：初始级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：持续优化级    3. 能力等级与成熟度等级之间的基本关系    1. 能力等级与成熟度等级是互补的关系，两者都是一种过程改善路径，即表征组织对单一过程域的改进。    2. 成熟度等级的路径可使组织针对单一过程域不断改善一组相关过程域，即表征组织对一组过程域的改进。    3. 两种等级的2-5级使用了同样的名字    4. 达到各共用目标要实施的共同实践    达到公用目标2、共用目标3、共用目标4和共用目标5所要实施的共同实践如下表所示    ||所要实施的共用实践||:---:|:---:||共用目标2：把过程制度化为一个管理过程|GP2.1 建立组织策略&lt;br/&gt;GP2.2 规划过程&lt;br/&gt;GP2.3 提供资源&lt;br/&gt;GP2.4 指派责任&lt;br/&gt;GP2.5 培训人员&lt;br/&gt;GP2.6 管理配置&lt;br/&gt;GP2.7 标识相关利益方的参与&lt;br/&gt;GP2.8 监控过程&lt;br/&gt;GP2.9 客观地评估符合性&lt;br/&gt;GP2.10 从高层管理的视觉评审状态&lt;br/&gt;||共用目标3：把过程制度化为一个已定义过程|GP3.1 建立一个已定义的过程&lt;br/&gt;GP3.2 收信进信息 所要实施的共用实践||共用目标4：把过程制度化为一个已定量管理过程|GP4.1 为该过程建立定量目的&lt;br/&gt;GP4.2 使子过程性能达到稳定||共用目标5：把过程制度化为一个持续优化过程|GP5.1 确保不断进行过程改善&lt;br/&gt;GP5.2 收集问题的根本原因|完结</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何管理一个项目，这是个沉重的话题。实际上，目前很多人都是凭借经验进行项目管理和开发，事实上管理项目是有着大量的方法论，这些方法论整理起来被人归纳成了一个学科，名字叫做&lt;code&gt;软件工程&lt;/code&gt;，接下来的内容将会归纳总结里面的一些要点，如果你有意成为一个项目管理者，请必须了解一下这些基础知识。&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://www.arclin.cn/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>C++基础</title>
    <link href="https://www.arclin.cn/post/f9a964a9.html"/>
    <id>https://www.arclin.cn/post/f9a964a9.html</id>
    <published>2019-10-15T05:17:00.000Z</published>
    <updated>2021-04-12T06:07:04.036Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS开发过程中，有时候会用到一些C++的库，为了避免大家用到这种库的时候一脸懵逼，这里总结一些基础知识，不写C++没关系，起码当库出了什么问题的时候至少能看懂逻辑（或许吧）。</p><p>这里全部都是基础语法知识，没事的时候可以看看熟悉一下。</p><span id="more"></span><h2 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h2><p>略</p><p>还是简单说一下：<code>.</code>是对象访问属性的操作符，<code>-&gt;</code>是指针访问指针属性的操作符，<br><code>(*a).b</code>=&gt;<code>a-&gt;b</code></p><h2 id="权限访问"><a href="#权限访问" class="headerlink" title="权限访问"></a>权限访问</h2><p>public:   可以被任意实体访问</p><p>protected:只允许子类及本类的成员函数访问</p><p>private:只允许本类的成员函数访问</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>跟Swift差不多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int func (int a , int b &#x3D; 10, int c &#x3D; 10); &#x2F;&#x2F; 声明中有默认参数，实现中不能有默认参数，比如下面这么写就会报错</span><br><span class="line">&#x2F;&#x2F; 声明和实现只能其中一个有默认参数</span><br><span class="line">int func (int a , int b &#x3D; 10, int c &#x3D; 10) &#123; &#x2F;&#x2F; 形参默认值，当b有默认值的时候，后面的参数都需要有默认值，不能b有c没有，但是可以c有b没有</span><br><span class="line"> return a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="占位参数（没啥用）"><a href="#占位参数（没啥用）" class="headerlink" title="占位参数（没啥用）"></a>占位参数（没啥用）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func(int a,int &#x3D; 0) &#123; &#x2F;&#x2F; 占位参数可以有默认参数，也可以没有</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(1,2);</span><br></pre></td></tr></table></figure><p>其实主要是用与兼容C语言的不规范写法，因为在C语言中，传参个数可以比函数声明的参数个数还多，比如<code>func(1,2,3,4,5)</code>,会警告但是不会报错，但是C++这么写就会报错，所以为了兼容C语言的调用方式，就用占位参数，占个位但是不用它，这样子就不会报错。</p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>同一个作用域，函数名相同，参数个数不同/类型不同/顺序不同</p><p><strong>函数的返回值不可以作为函数重载的条件</strong></p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;&#125;</span><br><span class="line">void func(int a) &#123;&#125;</span><br><span class="line">void func(double a) &#123;&#125;</span><br><span class="line">void func(int a, double b) &#123;&#125;</span><br><span class="line">void func(double a, int b) &#123;&#125;</span><br><span class="line">int func() &#123;&#125; &#x2F;&#x2F; 这个会报错</span><br></pre></td></tr></table></figure><h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 引用作为重载的条件</span><br><span class="line">void func(int &amp;a) &#123; &#x2F;&#x2F; 方法1</span><br><span class="line">cout &lt;&lt; &quot;func(int &amp;a)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void func(cont int &amp;a) &#123;  &#x2F;&#x2F; 方法2</span><br><span class="line">cout &lt;&lt; &quot;func(cont int &amp;a)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a &#x3D; 10;</span><br><span class="line">func(a); &#x2F;&#x2F; 方法1</span><br><span class="line"></span><br><span class="line">func(10); &#x2F;&#x2F; 方法2 因为 const int &amp;a &#x3D; 10; 合法，int &amp;a &#x3D; 10; 不合法</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数重载碰到默认参数</span><br><span class="line">void func2(int a) &#123;</span><br><span class="line">cout &lt;&lt; &quot;func2(int a)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func2(int a,int b &#x3D; 10) &#123;</span><br><span class="line">cout &lt;&lt; &quot;func2(int a, int b)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func2(10); &#x2F;&#x2F; 出现歧义（二义性），两个方法都能走，报错，所以建议函数重载的时候不要带默认参数</span><br></pre></td></tr></table></figure><h2 id="struct-和-class-的区别"><a href="#struct-和-class-的区别" class="headerlink" title="struct 和 class 的区别"></a>struct 和 class 的区别</h2><p><code>struct</code>默认权限为<code>public</code><br><code>class</code>默认权限为<code>private</code></p><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person() &#123;</span><br><span class="line">       cout &lt;&lt; &quot;默认构造函数：系统会默认生成&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Person(int age) &#123;</span><br><span class="line">cout &lt;&lt; &quot;带参数构造函数，写了这个系统就不生成无参构造函数&quot; &lt;&lt; endl;</span><br><span class="line">this-&gt;_age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(int age) : _height(15) &#123;</span><br><span class="line">cout &lt;&lt; &quot;初始化部分参数的构造函数&quot; &lt;&lt; endl;</span><br><span class="line">this-&gt;_age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(int age, int height) : _height(height) &#123;</span><br><span class="line">cout &lt;&lt; &quot;初始化部分参数的构造函数,并且顺便赋值了_height属性&quot; &lt;&lt; endl;</span><br><span class="line">this-&gt;_age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(const Person &amp;person) &#123;</span><br><span class="line">cout &lt;&lt; &quot;浅拷贝函数：系统会默认生成&quot; &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F; 如果要深拷贝的话自己手动生成、赋值对象属性。</span><br><span class="line">&#x2F;&#x2F;如果自己写拷贝构造函数的话，系统不提供其他普通构造函数（有&#x2F;无参）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Person() &#123;</span><br><span class="line">       cout&lt;&lt;&quot;析构函数：系统默认生成&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;int age; &#x2F;&#x2F; 不建议使用跟形参同名的成员变量</span><br><span class="line">int _age; &#x2F;&#x2F; 带个下划线吧</span><br><span class="line">int _height;</span><br><span class="line">SomeClass property; &#x2F;&#x2F; 别的类的属性：构造时会优先进入该类构造函数，析构时会优先进入Person的析构函数，再走这个类的析构函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">Person p1; &#x2F;&#x2F; 这样子就实例化了</span><br><span class="line">Person p2(11); &#x2F;&#x2F; age &#x3D; 11</span><br><span class="line">Person p3(11,160); &#x2F;&#x2F; age &#x3D; 11 height &#x3D; 160</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链式调用函数"><a href="#链式调用函数" class="headerlink" title="链式调用函数"></a>链式调用函数</h2><p>在上面的Person类内加多这么一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Person&amp; addAge(Person &amp;p) &#123;</span><br><span class="line">this-&gt;_age +&#x3D; p._Age;</span><br><span class="line">return *this; &#x2F;&#x2F; 返回当前对象指针！！！</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person pp(20);</span><br><span class="line">Person pp2(10);</span><br><span class="line">pp.addAge(pp2).addAge(pp2).addAge(pp2); &#x2F;&#x2F; 爽快地链式调用</span><br></pre></td></tr></table></figure><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">static void func() &#123;</span><br><span class="line">cout &lt;&lt; &quot;静态方法只能访问静态常量&quot; &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int test;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">Person p;</span><br><span class="line">p.func(); &#x2F;&#x2F; 可以这么调</span><br><span class="line">Person::func(); &#x2F;&#x2F; 也可以通过类名直接调</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常函数和常对象"><a href="#常函数和常对象" class="headerlink" title="常函数和常对象"></a>常函数和常对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">void funcA() const &#123;</span><br><span class="line">&#x2F;&#x2F;this-&gt;_name &#x3D; &quot;test&quot;;  常函数不可以访问普通成员属性</span><br><span class="line">this-&gt;_age &#x3D; 1; &#x2F;&#x2F;常函数可以访问被mutable修饰的成员属性</span><br><span class="line">&#125;</span><br><span class="line">string _name;</span><br><span class="line">mutable int _age;</span><br><span class="line"></span><br><span class="line">void funcB() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">const Person p;</span><br><span class="line">&#x2F;&#x2F;p.funcB(); &#x2F;&#x2F; 常对象不能访问普通函数</span><br><span class="line">p.funcA(); &#x2F;&#x2F; 常对象只能访问常函数</span><br><span class="line">reutrn 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在类外部实现函数"><a href="#在类外部实现函数" class="headerlink" title="在类外部实现函数"></a>在类外部实现函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public: &#x2F;&#x2F; 需要是public函数才可以这么玩</span><br><span class="line">Person(); &#x2F;&#x2F; 要在外部实现的都得事先声明</span><br><span class="line">void test();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person::Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Person::test() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>友元函数可以访问被<code>private</code>修饰的属性</p><h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Building &#123;</span><br><span class="line">    &#x2F;&#x2F; 友元函数 可以访问私有属性</span><br><span class="line">    friend void visitor(Building &amp;building);</span><br><span class="line">public:</span><br><span class="line">    Building() &#123;</span><br><span class="line">        m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class="line">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line">private:</span><br><span class="line">    string m_Bedroom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void visitor(Building &amp;building) &#123;</span><br><span class="line">cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_Bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>顺带一提：如果入参是引用的话（<code>&amp;building</code>）,那么可以直接通过点语法访问成员属性，如果入参是指针的话（<code>*building</code>），那么就通过<code>-&gt;</code>访问，如（building-&gt;m_Bedroom）</p></blockquote><blockquote><p>顺带再提，两种函数声明和调用方式的不同</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void visitor(Building &amp;building) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_SittingRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void visitor2(Building *building) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    Building building;  &#x2F;&#x2F; 生成对象</span><br><span class="line">    visitor(building);  &#x2F;&#x2F; 直接传对象</span><br><span class="line">    visitor2(&amp;building); &#x2F;&#x2F; 传对象地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Building &#123;</span><br><span class="line">    friend class Visitor; &#x2F;&#x2F; 这个类下的所有函数都可以访问它的私有属性</span><br><span class="line">public:</span><br><span class="line">    Building() &#123;</span><br><span class="line">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    string m_Bedroom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Visitor</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Visitor() &#123;</span><br><span class="line">building &#x3D; new Building;</span><br><span class="line">&#125;</span><br><span class="line">void visit();</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Visitor::visit() &#123;</span><br><span class="line">cout &lt;&lt; building-&gt;m_Bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">Visitor v;</span><br><span class="line">v.visit();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="成员函数做友元函数"><a href="#成员函数做友元函数" class="headerlink" title="成员函数做友元函数"></a>成员函数做友元函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class Visitor</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Visitor();</span><br><span class="line">    void visit();</span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Building &#123;</span><br><span class="line">    friend void Visitor::visit(); &#x2F;&#x2F; 指定Visitor的visit成员函数可以访问私有属性</span><br><span class="line">public:</span><br><span class="line">    Building() &#123;</span><br><span class="line">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    string m_Bedroom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为什么这个构造函数要写外面，不能写里面？</span><br><span class="line">&#x2F;&#x2F; 因为Visitor需要在Building上面定义，不然不给定义Visitor上的友元函数，然后因为Visitor内有Building的属性，所以要声明一下class Building; 但是因为只是声明没有实现，所以就不能new Building;了，那就只能把这个通过类外实现的方式写在Building定义的下面。</span><br><span class="line">Visitor::Visitor() &#123;  </span><br><span class="line">    building &#x3D; new Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Visitor::visit() &#123;</span><br><span class="line">    cout &lt;&lt; building-&gt;m_Bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Visitor v;</span><br><span class="line">    v.visit();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>跟Swift差不多</p><h3 id="成员函数的运算符重载"><a href="#成员函数的运算符重载" class="headerlink" title="成员函数的运算符重载"></a>成员函数的运算符重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    Animal operator + (Animal &amp;a) &#123;</span><br><span class="line">        Animal temp;</span><br><span class="line">        temp.m_A &#x3D; this -&gt; m_A + a.m_A;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    int m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal a;</span><br><span class="line">a.m_A &#x3D; 1;</span><br><span class="line">Animal b;</span><br><span class="line">b.m_A &#x3D; 2;</span><br><span class="line">Animal c &#x3D; a + b;</span><br><span class="line">cout &lt;&lt; c.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 3</span><br></pre></td></tr></table></figure><p>本质：<code>Animal c = a.operator+(b);</code></p><h3 id="全局函数的运算符重载"><a href="#全局函数的运算符重载" class="headerlink" title="全局函数的运算符重载"></a>全局函数的运算符重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Animal operator - (Animal &amp;a, Animal &amp;b) &#123;</span><br><span class="line">    Animal temp;</span><br><span class="line">    temp.m_A &#x3D; a.m_A - b.m_A;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal a;</span><br><span class="line">a.m_A &#x3D; 1;</span><br><span class="line">Animal b;</span><br><span class="line">b.m_A &#x3D; 2;</span><br><span class="line">Animal c &#x3D; a - b;</span><br><span class="line">cout &lt;&lt; c.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 -1</span><br></pre></td></tr></table></figure><p>本质：<code>Animal c = operator-(a,b);</code></p><h3 id="运算符重载也可以发生函数重载"><a href="#运算符重载也可以发生函数重载" class="headerlink" title="运算符重载也可以发生函数重载"></a>运算符重载也可以发生函数重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Animal operator + (int a, Animal &amp;b) &#123;</span><br><span class="line">    Animal temp;</span><br><span class="line">    temp.m_A &#x3D; a + b.m_A;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line">Animal a;</span><br><span class="line">a.m_A &#x3D; 1;</span><br><span class="line">Animal d &#x3D; 10 + a;</span><br><span class="line">cout &lt;&lt; d.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 11</span><br></pre></td></tr></table></figure><p>本质：<code>Animal d = operator+(10,a);</code></p><h3 id="左移运算符重载（比较常见输出对象细节）"><a href="#左移运算符重载（比较常见输出对象细节）" class="headerlink" title="左移运算符重载（比较常见输出对象细节）"></a>左移运算符重载（比较常见输出对象细节）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MyInteger &#123;</span><br><span class="line">    friend ostream&amp; operator&lt;&lt;(ostream&amp; cout,MyInteger myInt);</span><br><span class="line">public:</span><br><span class="line">    MyInteger() &#123;</span><br><span class="line">        this-&gt;my_int &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int my_int;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 必须是全局函数重载 ostream是cout的类型，为了能链式调用所以返回引用ostream&amp;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; cout,MyInteger myInt) &#123;</span><br><span class="line">    cout &lt;&lt; myInt.my_int; &#x2F;&#x2F; 返回对象细节</span><br><span class="line">    return cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyInteger myInt;</span><br><span class="line">    cout &lt;&lt; myInt &lt;&lt; endl; &#x2F;&#x2F; 输出 my_int 的值 0</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><p>Swift经常使用，参见<code>Equable</code>，<code>Comparable</code>协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    bool operator&#x3D;&#x3D;(Person &amp;p) &#123;</span><br><span class="line">        if (this-&gt;m_Name &#x3D;&#x3D; p.m_Name) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!&#x3D;(Person &amp;p) &#123;</span><br><span class="line">        if (this-&gt;m_Name !&#x3D; p.m_Name) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">string m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">Person p1; p1.m_Name &#x3D; &quot;A&quot;;</span><br><span class="line">    Person p2; p2.m_Name &#x3D; &quot;A&quot;;</span><br><span class="line">    if (p1 &#x3D;&#x3D; p2) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Equal&quot; &lt;&lt; endl; &#x2F;&#x2F; 输出</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Different&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (p1 !&#x3D; p2) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Different&quot; &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Equal&quot; &lt;&lt; endl; &#x2F;&#x2F; 输出</span><br><span class="line">    &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数调用运算符的重载（骚操作）"><a href="#函数调用运算符的重载（骚操作）" class="headerlink" title="函数调用运算符的重载（骚操作）"></a>函数调用运算符的重载（骚操作）</h3><p>因为用起来很像函数，所以又叫做仿函数，STL里相当多这种骚操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyInteger &#123;</span><br><span class="line">int operator()(int a,int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F; MyInteger() ：匿名对象</span><br><span class="line">    int result &#x3D; MyInteger()(1,2);</span><br><span class="line"></span><br><span class="line">    MyInteger i;</span><br><span class="line">    int result2 &#x3D; i(5,2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;  &#x2F;&#x2F; 5</span><br><span class="line">    cout &lt;&lt; result2 &lt;&lt; endl; &#x2F;&#x2F; 7</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>C++有多继承，灰常厉害</p><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>三种继承方式<code>public</code>,<code>protected</code>,<code>private</code>，决定着继承下来的属性和方法以什么形式修饰，<code>class</code>默认<code>private</code>,<code>struct</code>默认<code>public</code>（没错，C++中结构体可以被继承）<br>父类的所有非静态属性会被继承，包括<code>private</code>类型的，但是<code>private</code>类型的默认隐藏，子类无法访问。</p><p>继承语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class SubClass : public SuperClass &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h3><p>父类先构造，子类先析构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">superClass()</span><br><span class="line">subClass()</span><br><span class="line">~subClass()</span><br><span class="line">~superClass()</span><br></pre></td></tr></table></figure><h3 id="同名属性-函数-静态属性-静态函数的访问"><a href="#同名属性-函数-静态属性-静态函数的访问" class="headerlink" title="同名属性/函数/静态属性/静态函数的访问"></a>同名属性/函数/静态属性/静态函数的访问</h3><p>假如子类和父类拥有相同的名字的属性/函数/静态属性/静态函数，则直接调用子类对象的话都是访问子类的，如果要访问父类的话要添加作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    int _a &#x3D; 1;</span><br><span class="line">    static int _b;</span><br><span class="line">    static void staticFunc() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base staticFunc()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Func() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base Func()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int Base::_b &#x3D; 10; &#x2F;&#x2F; 静态成员变量要在外面赋值</span><br><span class="line"></span><br><span class="line">class Sub1 : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    int _a &#x3D; 2;</span><br><span class="line">    static int _b;</span><br><span class="line">    static void staticFunc() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;SubClass staticFunc()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Func() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;SucClass Func()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int Sub1::_b &#x3D; 20;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    Sub1 s;</span><br><span class="line">    &#x2F;&#x2F; 直接调用</span><br><span class="line">    cout &lt;&lt; s._a &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; 调用父类的</span><br><span class="line">    cout &lt;&lt; s.Base::_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 静态直接调用</span><br><span class="line">    cout &lt;&lt; s._b &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; 静态调用父类的</span><br><span class="line">    cout &lt;&lt; s.Base::_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 静态直接调用</span><br><span class="line">    cout &lt;&lt; Sub1::_b &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; 静态调用父类的</span><br><span class="line">    cout &lt;&lt; Sub1::Base::_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 直接调用</span><br><span class="line">    s.Func();</span><br><span class="line">    &#x2F;&#x2F; 调用父类的</span><br><span class="line">    s.Base::Func();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 静态直接调用</span><br><span class="line">    s.staticFunc();</span><br><span class="line">    &#x2F;&#x2F; 静态调用父类的</span><br><span class="line">    s.Base::staticFunc();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 静态直接调用</span><br><span class="line">    Sub1::staticFunc();</span><br><span class="line">    &#x2F;&#x2F; 静态调用父类的</span><br><span class="line">    Sub1::Base::staticFunc();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>不建议使用，因为麻烦事多</p><p>语法：(参照上面的代码)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Other &#123;</span><br><span class="line">public:</span><br><span class="line">    void Func() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Ohter Func()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;...略</span><br><span class="line">class Sub1 : public Base , public Other &#123;</span><br><span class="line">&#x2F;&#x2F;...略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当多个父类中出现同名属性/方法时，需要加作用域指定父类<code>s.Base::Func(); / s.Other::Func();</code></p><h3 id="菱形继承（钻石继承）"><a href="#菱形继承（钻石继承）" class="headerlink" title="菱形继承（钻石继承）"></a>菱形继承（钻石继承）</h3><p>两个子类继承同一个基类，<br>又有某个类同时继承着两个子类</p><p>举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123; int age &#125;;</span><br><span class="line"></span><br><span class="line">class Sub1: public Base &#123;&#125;;</span><br><span class="line">class Sub2: public Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">class SubSub: public Sub1, public Sub2 &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这时候SubSub会有两个父类，有两份 age 属性，造成资源浪费</p><p>这时候用虚继承(<code>virtual</code>)解决问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123; public: int age &#125;; &#x2F;&#x2F; 这时候成为虚基类</span><br><span class="line"></span><br><span class="line">class Sub1: virtual public Base &#123;&#125;;</span><br><span class="line">class Sub2: virtual public Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">class SubSub: public Sub1, public Sub2 &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这时候age属性成为共享属性，最后谁改了就是谁的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SubSub s;</span><br><span class="line">s.Sub1::age &#x3D; 1;</span><br><span class="line">s.Sub2::age &#x3D; 10;</span><br><span class="line">cout &lt;&lt; s.Sub1::age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br><span class="line">cout &lt;&lt; s.Sub2::age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br><span class="line">cout &lt;&lt; s.age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>C++中，多态分两类</p><p>静态多态：函数重载和运算符重载属于静态多态，复用函数名<br>动态多态：子类和虚函数实现运行时多态</p><p>区别：</p><p>静态多态的函数地址早绑定，编译阶段确定函数地址<br>动态多态的函数地址晚绑定，运行阶段确定函数地址</p><p>动态多态满足条件：</p><ol><li>有继承关系</li><li>子类重写父类虚函数</li></ol><p>动态多态使用<br>父类的指针或者引用指向子类对象</p><p>静态多态举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void speak() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Animal Speak&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Cat: public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void speak() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Cat Speak&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void SomeoneSpeak(Animal &amp;animal) &#123;</span><br><span class="line">    animal.speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Cat c;</span><br><span class="line">    SomeoneSpeak(c); &#x2F;&#x2F; 由于SomeoneSpeak(Animal &amp;animal)，编译期间已经确定入参类型，所以输出 Animal Speak</span><br></pre></td></tr></table></figure><p>如果想输出<code>Cat Speak</code>，只需进行如下修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void speak() &#123; &#x2F;&#x2F; 虚函数，可以告知由于SomeoneSpeak(Animal &amp;animal)运行时再确定入参类型</span><br><span class="line">        cout &lt;&lt; &quot;Animal Speak&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经常地，这种情况下也是动态多态，最后会输出<code>Cat Speak</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal *a &#x3D; new Cat;</span><br><span class="line">a-&gt;speak();</span><br></pre></td></tr></table></figure><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>父类的虚函数的实现没什么意义，所以上面的虚函数代码改写为<code>纯虚函数</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual void speak() &#x3D; 0;</span><br></pre></td></tr></table></figure><p>当类中有了纯虚函数，则这个类称为<code>抽象类</code></p><p>抽象类<strong>无法实例化对象</strong>，并且<strong>子类必须重写父类的纯虚函数</strong>，否则也成为<code>抽象类</code></p><h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>当子类在堆区创建数据的时候，需要手动释放，父类需要添加虚析构或者纯虚析构函数，否则子类可能不走析构函数</p><p>比如上面的<code>Animate</code>父类，我们补充一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ~Animal() &#x3D; 0; &#x2F;&#x2F; 纯虚析构</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~Animal() &#123; &#x2F;&#x2F; 析构实现</span><br><span class="line">    cout &lt;&lt; &quot;Animal is Delete&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>文件打开方式</p><p><code>ios::in</code>:读文件<br><code>ios::out</code>:写文件<br><code>ios::ate</code>:初始位置，文件尾<br><code>ios:app</code>:追加写文件<br><code>ios:trunc</code>:如果文件存在先删除，再创建<br><code>ios:binary</code>:二进制方式</p><p>同时两种方式则使用<code>|</code>的方式，比如<code>ios::in|ios:binary</code></p><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ofstream stream;</span><br><span class="line"></span><br><span class="line">stream.open(&quot;Test.txt&quot;,ios::out);</span><br><span class="line"></span><br><span class="line">stream &lt;&lt; &quot;Line 1&quot; &lt;&lt; endl;</span><br><span class="line">stream &lt;&lt; &quot;Line 2&quot; &lt;&lt; endl;</span><br><span class="line">stream &lt;&lt; &quot;Line 3&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">stream.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(&quot;Test.txt&quot;,ios::out);</span><br><span class="line"></span><br><span class="line">if(!ifs.is_open()) &#123;</span><br><span class="line">cout &lt;&lt; &quot;打开文件失败&quot; &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string buf;</span><br><span class="line">while (getline(ifs, buf)) &#123; &#x2F;&#x2F; 一行行读取</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.close();</span><br></pre></td></tr></table></figure><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h3 id="构建类模板与类模板做参数"><a href="#构建类模板与类模板做参数" class="headerlink" title="构建类模板与类模板做参数"></a>构建类模板与类模板做参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class NameType,class AgeType&gt;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    Person(NameType name, AgeType age) &#123;</span><br><span class="line">        this-&gt;_age &#x3D; age;</span><br><span class="line">        this-&gt;_name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    AgeType _age;</span><br><span class="line">    NameType _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不会自动类型推导，需要自己显式声明类型</span><br><span class="line">    Person&lt;string,int&gt; p(&quot;Haha&quot;,123);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; p._name &lt;&lt; &quot; &quot; &lt;&lt; p._age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以给类模板添加默认类型</p><p><code>template&lt;class NameType,class AgeType = int&gt;</code></p><p>这样子调用的时候就可以不全声明类型了</p><p><code>Person&lt;string&gt; p(&quot;Haha&quot;,123);</code></p><p>类模板做参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 指定类型的类模板做参数</span><br><span class="line">void print(Person&lt;string,int&gt; &amp;p) &#123;</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模板化参数的类模板做参数</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">void print2(Person&lt;T1, T2&gt; &amp;p) &#123;</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模板化类做参数</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void print3(T &amp;p) &#123;</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Person&lt;string,int&gt; p(&quot;Haha&quot;,123);</span><br><span class="line">    print(p);</span><br><span class="line">    print2(p);</span><br><span class="line">    print3(p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h3><p>继承时需要指定类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SubClass: public Base&lt;int&gt; &#123; &#x2F;&#x2F; 指定T的类型</span><br><span class="line">public:</span><br><span class="line">    void print() &#123;</span><br><span class="line">        cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果不想指定类型，那么可以模板化子类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class SubClass: public Base&lt;T1&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    SubClass(T1 a, T2 b) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    T2 k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">SubClass&lt;string, int&gt; c(&quot;String&quot;,1);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STL-之-Vector容器"><a href="#STL-之-Vector容器" class="headerlink" title="STL 之 Vector容器"></a>STL 之 Vector容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v1; &#x2F;&#x2F; 初始化指定容器内元素类型</span><br><span class="line">v1.assign(10, 1); &#x2F;&#x2F; 插入10个1，也可以传入其他vector,比如v1.assign(v0.begin,v0.end); 或者直接 v1 &#x3D; v0; 只要保证是同种类型就好</span><br><span class="line">for (vector&lt;int&gt;::iterator i &#x3D; v1.begin(); i !&#x3D; v1.end() ; i++) &#123;</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; endl;</span><br><span class="line">&#125; &#x2F;&#x2F; 打印10个1</span><br><span class="line">cout &lt;&lt; &quot;Size &#x3D; &quot; &lt;&lt; v1.size() &lt;&lt; endl; &#x2F;&#x2F; 长度 10</span><br><span class="line">cout &lt;&lt; &quot;isEmpty &#x3D; &quot; &lt;&lt; v1.empty() &lt;&lt; endl; &#x2F;&#x2F; 判空 0</span><br><span class="line">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 容量 10</span><br><span class="line">v1.resize(20,20); &#x2F;&#x2F; 调整容量为20，多出来的位置用20填充，这里的20可以不传，默认0</span><br><span class="line">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 现在容量变成20</span><br><span class="line"></span><br><span class="line">v1.pop_back(); &#x2F;&#x2F; 删除最后一个元素</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;Size &#x3D; &quot; &lt;&lt; v1.size() &lt;&lt; endl; &#x2F;&#x2F; 长度 19</span><br><span class="line">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 容量不变 20</span><br><span class="line"></span><br><span class="line">v1.insert(v1.begin() + 1, 199); &#x2F;&#x2F; 下标为1的位置插入元素199</span><br><span class="line">v1.insert(v1.begin() + 1, 2, 199); &#x2F;&#x2F; 下标为1的位置插入两个元素199</span><br><span class="line">v1.erase(v1.begin() + 2); &#x2F;&#x2F; 删除第二个元素</span><br><span class="line">v1.erase(v1.begin() + 2 , v1.begin() + 3); &#x2F;&#x2F; 删除第二个到第三个元素</span><br><span class="line">v1.clear(); &#x2F;&#x2F; 清空容器</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;第二个元素是&quot; &lt;&lt; v1.at(1) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;第三个元素是&quot; &lt;&lt; v1[2] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;第一个元素&quot; &lt;&lt; v1.front() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;最后一个元素&quot; &lt;&lt; v1.back() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v1.reverse(100000); &#x2F;&#x2F; 预留空间，减少以后动态拓展的次数</span><br><span class="line"></span><br><span class="line">v1.swap(v0); &#x2F;&#x2F; 交换元素，假如v1的预留空间很大，可以通过交换一个小预留空间的容器达到压缩内存的效果</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在iOS开发过程中，有时候会用到一些C++的库，为了避免大家用到这种库的时候一脸懵逼，这里总结一些基础知识，不写C++没关系，起码当库出了什么问题的时候至少能看懂逻辑（或许吧）。&lt;/p&gt;
&lt;p&gt;这里全部都是基础语法知识，没事的时候可以看看熟悉一下。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.arclin.cn/categories/C/"/>
    
    
    <category term="C++" scheme="https://www.arclin.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>iOS12 新玩具ShortCut(捷径)使用</title>
    <link href="https://www.arclin.cn/post/0.html"/>
    <id>https://www.arclin.cn/post/0.html</id>
    <published>2018-09-28T05:05:00.000Z</published>
    <updated>2021-04-12T06:07:04.039Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>升级iOS12之后可以在<code>设置-Siri</code>与搜索 中发现一个 <code>捷径</code> 功能, 所谓ShortCut就是其英文翻译<br>其作用就是让用户自定义一个一句话或者短语, 然后可以触发app做一系列动作</p><span id="more"></span><h3 id="接入"><a href="#接入" class="headerlink" title="接入"></a>接入</h3><p>ShortCut分为两种, 一种是在手机的<code>Spotlight</code>上搜索某个关键字的时候可以搜索到你的app, 这个关键字就是ShortCut的一种(文字输入), 你需要使用<code>NSUserActivity</code>去实现这个功能</p><blockquote><p>依赖 <code>CoreSpotlight</code> <code>CoreServices</code></p></blockquote><p>另外一种叫做 <code>Intent</code>(语音输入), 需要添加一个IntentExtension和IntentExtensionUI, 然后在主Target添加一个intentdefinition文件, 详细的配置大家可以参考<br><a href="https://juejin.im/post/5b2077d8f265da6e45549c68">文章1</a><br><a href="http://www.cnblogs.com/czjie2010/p/czjie.html">文章2</a></p><blockquote><p>依赖<code>Intents</code> <code>IntentsUI</code></p></blockquote><h3 id="最简单的配置操作步骤"><a href="#最简单的配置操作步骤" class="headerlink" title="最简单的配置操作步骤"></a>最简单的配置操作步骤</h3><ol><li><p>项目的<code>Capabilities</code>打开<code>Siri</code></p></li><li><p>授权</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">if (@available(iOS 10.0, *)) &#123;</span><br><span class="line">[INPreferences requestSiriAuthorization:^(INSiriAuthorizationStatus status) &#123;</span><br><span class="line">switch (status) &#123;</span><br><span class="line">case INSiriAuthorizationStatusNotDetermined:</span><br><span class="line">NSLog(@&quot;用户尚未对该应用程序作出选择。&quot;);</span><br><span class="line">break;</span><br><span class="line">case INSiriAuthorizationStatusRestricted:</span><br><span class="line">NSLog(@&quot;此应用程序无权使用Siri服务&quot;);</span><br><span class="line">break;</span><br><span class="line">case INSiriAuthorizationStatusDenied:</span><br><span class="line">NSLog(@&quot;用户已明确拒绝此应用程序的授权&quot;);</span><br><span class="line">break;</span><br><span class="line">case INSiriAuthorizationStatusAuthorized:</span><br><span class="line">NSLog(@&quot;用户可以使用此应用程序的授权&quot;);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>新建一个<code>intentdefinition</code>，比如<code>A.intentdefinition</code></li><li>新建一个<code>Target</code>,<code>Intent Extension</code>有需要的话把<code>Intent UI Extension</code>也加上，<code>General</code>中配置相关证书</li><li>进入<code>A.intentdefinition</code>，界面左下角<code>+</code>号点一下，点击<code>new intent</code></li><li>界面右边<code>Target Membership</code>，把<code>步骤2</code>中新增的<code>Target</code>给勾上</li><li> 界面中间<code>Title</code>填写需要展示的标题，<code>Descripion</code> 写描述</li><li>Build一下，系统自动生成头文件，头文件名字在界面右测的导航页的第三个按钮的<code>Custom Class</code>里</li><li>找个控制器，导入<code>步骤8</code>生成的头文件，添加个按钮，比如</li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.navigationItem.rightBarButtonItem &#x3D; [[UIBarButtonItem alloc] initWithTitle:@&quot;捷径&quot; style:UIBarButtonItemStylePlain target:self action:@selector(siri:)];</span><br></pre></td></tr></table></figure></li><li><p>点击按钮召唤添加Shortcut的控制器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)siri:(UIBarButtonItem *)item &#123;</span><br><span class="line">    if (@available(iOS 12.0, *)) &#123;</span><br><span class="line">     &#x2F;&#x2F; 这个类名具体看你生成了叫什么名字的头文件</span><br><span class="line">        ZeRiIntent *intent &#x3D; [[ZeRiIntent alloc] init];</span><br><span class="line">        intent.suggestedInvocationPhrase &#x3D; @&quot;打开xxx&quot;; &#x2F;&#x2F; 引导用户说的语句</span><br><span class="line">        INShortcut *shortCur &#x3D; [[INShortcut alloc] initWithIntent:intent];</span><br><span class="line">        INUIAddVoiceShortcutViewController *vc &#x3D; [[INUIAddVoiceShortcutViewController alloc] initWithShortcut:shortCur];</span><br><span class="line">        vc.delegate &#x3D; self;</span><br><span class="line">        [self presentViewController:vc animated:YES completion:nil];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Fallback on earlier versions</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同个地方实现代理方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - INUIAddVoiceShortcutViewControllerDelegate</span><br><span class="line">- (void)addVoiceShortcutViewControllerDidCancel:(INUIAddVoiceShortcutViewController *)controller  API_AVAILABLE(ios(12.0))&#123;</span><br><span class="line">[controller dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">- (void)addVoiceShortcutViewController:(INUIAddVoiceShortcutViewController *)controller didFinishWithVoiceShortcut:(INVoiceShortcut *)voiceShortcut error:(NSError *)error  API_AVAILABLE(ios(12.0))&#123;</span><br><span class="line">[controller dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>Intent</code> target中的<code>IntentHandler</code>类，导入<code>步骤8</code>生成的头文件，要是头文件找不到，在这个target的<code>info.plist</code>中<code>NSExtension</code>下的<code>IntentsSupported</code>下添加一个名为那个头文件的值，主target的<code>info.plist</code>的<code>NSUserActivityTypes</code>下也加一个一样的</p></li><li><p><code>IntentHandler.m</code>遵循协议<code>XXXIntentHandling</code>（具体协议名看你的类名），实现两个方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 用户说了那句话之后要Siri做什么事情</span><br><span class="line">- (void)handleZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion &#123;</span><br><span class="line">completion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);</span><br><span class="line">&#125;</span><br><span class="line">  &#x2F;&#x2F; 用户确认了之后要Siri做什么事情</span><br><span class="line">- (void)confirmZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion &#123;</span><br><span class="line">completion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   <code>ZeRiIntentResponseCodeContinueInApp</code>只是枚举中其中一个值，使用不同的值会有不同     效果，自己探索一下，这里的值指的是打开app(具体方法名看协议)</p></li><li><p>进入<code>AppDelegate</code>，实现方法如下，根据<code>Intent</code>类名判断用户想要的操作</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application continueUserActivity:(nonnull NSUserActivity *)userActivity restorationHandler:(nonnull void (^)(NSArray&lt;id&lt;UIUserActivityRestoring&gt;&gt; * _Nullable))restorationHandler &#123;</span><br><span class="line">if ([userActivity.activityType isEqualToString:@&quot;XXXIntent&quot;]) &#123;</span><br><span class="line">&#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结束</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;升级iOS12之后可以在&lt;code&gt;设置-Siri&lt;/code&gt;与搜索 中发现一个 &lt;code&gt;捷径&lt;/code&gt; 功能, 所谓ShortCut就是其英文翻译&lt;br&gt;其作用就是让用户自定义一个一句话或者短语, 然后可以触发app做一系列动作&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Application Loader / Fastlane pilot 通过代理上传方案</title>
    <link href="https://www.arclin.cn/post/undefined.html"/>
    <id>https://www.arclin.cn/post/undefined.html</id>
    <published>2018-08-03T08:10:07.000Z</published>
    <updated>2021-04-12T06:07:04.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Application-Loader-Fastlane-pilot-通过代理上传方案"><a href="#Application-Loader-Fastlane-pilot-通过代理上传方案" class="headerlink" title="Application Loader / Fastlane pilot 通过代理上传方案"></a>Application Loader / Fastlane pilot 通过代理上传方案</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>为了避免苹果审核马甲包情况, 我们需要通过其他IP去上传包, 这里提供几种方案并记录踩坑过程.</p><span id="more"></span><h3 id="问题解决思路"><a href="#问题解决思路" class="headerlink" title="问题解决思路"></a>问题解决思路</h3><ol><li><p>用Application Loader(后面简称uploader)上传包, 电脑使用SS, VPN会导致上传失败, 原因是uploader内部自带开启代理配置, 但是默认是关闭的,  所以需要修改内部代理配置, 路径是<code>/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/java/lib/net.properties</code>, 配置如下(1086是本地ss的端口)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.net.useSystemProxies&#x3D;true</span><br><span class="line">http.proxyHost&#x3D;127.0.0.1</span><br><span class="line">http.proxyPort&#x3D;1086</span><br><span class="line">https.proxyHost&#x3D;127.0.0.1</span><br><span class="line">https.proxyPort&#x3D;1086</span><br><span class="line">jdk.http.auth.tunneling.disabledSchemes&#x3D;Basic</span><br></pre></td></tr></table></figure></li><li><p>本来<code>net.properties</code>内是有socks代理的配置的, Shadowsocks开启socks代理后, 在配置文件中配置好ip(127.0.0.1)和端口(1086)之后测试发现无法连接到苹果服务器, 故只能选用<code>http/https</code>代理</p><blockquote><p>查询shadowsocks本地端口的方法, 执行<code>lsof -iTCP -sTCP:LISTEN -n -P | grep ss-local</code>, 就可以查到</p></blockquote></li><li><p>现在问题在于怎么将socks代理转成http/https代理, 通过查阅资料得知可以通过安装<code>privoxy</code>解决, 安装之后配置<code>/usr/local/etc/privoxy/config</code>文件, 把<code>forward-socks5t</code>那行注释掉, 加上本地socks ip和端口, 就像下面那段一样, 然后把<code>listen-address  127.0.0.1:8118</code> 改成 <code>listen-address  0.0.0.0:8118</code>就可以实现给局域网内共享你的代理.</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">forward           &#x2F;               127.0.0.1:1086 .</span><br><span class="line">forward-socks4    &#x2F;               127.0.0.1:1086 .</span><br><span class="line">forward-socks4a   &#x2F;               127.0.0.1:1086 .</span><br><span class="line">forward-socks5    &#x2F;               127.0.0.1:1086 .</span><br><span class="line">forward-socks5t   &#x2F;               127.0.0.1:1086 .</span><br></pre></td></tr></table></figure></li><li><p>打开<code>系统偏好设置-网络-高级-代理</code>, 把网页代理和安全网页代理勾上, 填上ip <code>127.0.0.1</code> 端口 <code>8118</code> , 就可以了.  这里的<code>8118</code>是刚刚说到的<code>listen-address  0.0.0.0:8118</code>里面的端口号, 要改也可以改, 记得同步就行.</p></li></ol><h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><ol><li><p>校验<code>privoxy</code>是否代理成功可以通过浏览器访问<code>http://config.privoxy.org/</code>这个网址就能看到成功与否了</p></li><li><p>执行<code>netstat -an | grep 8118</code> 查看<code>8188</code>是否全局监听着, 如果是就会看到<br> <code>tcp4       0      0  *.8118                 *.*                    LISTEN  </code>执行<code>ps aux | grep privoxy</code>, 则可以看到<code>privoxy</code>进程是否正在运行中. 可以通过<code>sudo /Applications/Privoxy/stopPrivoxy.sh</code>停止<code>privoxy</code>和<code>sudo /Applications/Privoxy/startPrivoxy.sh</code>启动<code>privoxy</code></p></li><li><p>浏览器访问<code>https://ip.cn</code>,就可以得知网页代理是否成功了</p></li><li><p>fastlane上传包实际上是调用了<code>/Applications/Xcode.app/Contents/Applications/Application\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool</code>, 也就是Xcode自带的命令行工具 , uploader就不用说了, 反正殊途同归, 最后都会根据<code>net.properties</code>去走代理,  那么问题来了 , 如何验证命令行和桌面应用uploader走的都是代理方式呢. 很遗憾苹果并不会弄出一个界面或者打印出一行log告诉你现在是用哪个ip上传, 我现在能想到的办法是通过工具查看上传过程中的流量波动, 通过实验, 两种方式再上传过程中, <code>ss-local</code>进程有过较大数据上传的流量波动(会有100k/s以上的上传流量速度), 因此我判定确实是走了代理上传包的.  如果要再证据确凿的话, 只能想办法抓包查看他的信息收集了, 但是<code>Charles</code>抓包的原理是再开一个代理, 会造成混乱….所以这就很头疼了.</p></li><li><p>开启了网页代理之后, 影响的只是网页, 实际上只是为了验证<code>Privoxy</code>的可用性, 开启之后你如果在命令行中使用<code>curl ip.cn</code>得到的结果会是你真实网络的出网ip, 而不是你想要的代理的ip, 实际上<code>uploader</code>和<code>fastlane pilot</code>命令行是否真正走了代理, 目前我只能通过<code>ss-local</code>这个代理的进程查看他的上传流量去判断, 具有一定风险. 或者通过安装命令行工具<code>proxychains</code>, 然后执行<code>proxychains4 fastlane pilot upload</code>传包, 但是这种方式100%上传失败 , 原因猜想是<code>net.properties</code>的配置没改, <code>proxychains</code>怎么转发请求都没用.  所以这是不是从某种意义上证明了<code>fastlane pilot</code>是走<code>net.properties</code>配置的呢, 至少我觉得按照目前情况可以这么认为,  后续如果有想法我会进行更多实验去证明的.</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Application-Loader-Fastlane-pilot-通过代理上传方案&quot;&gt;&lt;a href=&quot;#Application-Loader-Fastlane-pilot-通过代理上传方案&quot; class=&quot;headerlink&quot; title=&quot;Application Loader / Fastlane pilot 通过代理上传方案&quot;&gt;&lt;/a&gt;Application Loader / Fastlane pilot 通过代理上传方案&lt;/h2&gt;&lt;h3 id=&quot;需求分析&quot;&gt;&lt;a href=&quot;#需求分析&quot; class=&quot;headerlink&quot; title=&quot;需求分析&quot;&gt;&lt;/a&gt;需求分析&lt;/h3&gt;&lt;p&gt;为了避免苹果审核马甲包情况, 我们需要通过其他IP去上传包, 这里提供几种方案并记录踩坑过程.&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>关于第三方单元测试框架的简单说明</title>
    <link href="https://www.arclin.cn/post/7daa41d8.html"/>
    <id>https://www.arclin.cn/post/7daa41d8.html</id>
    <published>2018-05-23T05:12:00.000Z</published>
    <updated>2021-04-12T06:07:04.040Z</updated>
    
    <content type="html"><![CDATA[<p>关于第三方单元测试框架的简单说明</p><span id="more"></span><h2 id="Pod安装"><a href="#Pod安装" class="headerlink" title="Pod安装"></a>Pod安装</h2><p>Podfile编写（框架只能安装在UnitTest的Target中）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target &#39;BaZiPaiPanSDK&#39; do</span><br><span class="line">    ...</span><br><span class="line">    target &#39;BaZiPaiPanSDKTests&#39; do</span><br><span class="line">        inherit! :search_paths</span><br><span class="line">        pod &#39;Specta&#39;</span><br><span class="line">        pod &#39;Expecta&#39;</span><br><span class="line">        pod &#39;OCMock&#39;</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="Specta"><a href="#Specta" class="headerlink" title="Specta"></a>Specta</h2><ul><li>Specta是一个BDD（行为驱动开发）框架</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;OCMock&#x2F;OCMock.h&gt;</span><br><span class="line">#import &lt;Specta&#x2F;Specta.h&gt;</span><br><span class="line">#import &lt;Expecta&#x2F;Expecta.h&gt;</span><br><span class="line">#import &lt;ReactiveCocoa&#x2F;ReactiveCocoa.h&gt;</span><br><span class="line">#import &quot;BZPPCaiYunViewModel.h&quot;</span><br><span class="line"></span><br><span class="line">SpecBegin(BZPPCaiYunViewModel)&#x2F;&#x2F; 声明了一个测试类</span><br><span class="line"></span><br><span class="line">    __block BZPPCaiYunViewModel *viewModel; &#x2F;&#x2F; 我们要测试这个类</span><br><span class="line"></span><br><span class="line">    beforeEach(^&#123; &#x2F;&#x2F; 通过beforeEach 首先先初始化 </span><br><span class="line">        viewModel &#x3D; [[BZPPCaiYunViewModel alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    describe(@&quot;BZPPCaiYunViewModel&quot;, ^&#123;  &#x2F;&#x2F; 声明一组用例</span><br><span class="line">    </span><br><span class="line">        it(@&quot;refresh when data isn&#39;t empty&quot;, ^&#123; &#x2F;&#x2F; 通过 it 声明一个用例，前面的字符串是一个描述</span><br><span class="line">            __block id result;</span><br><span class="line">            waitUntil(^(DoneCallback done) &#123; &#x2F;&#x2F; 假设这里有网络请求，所以需要异步，有点像GCD的信号量</span><br><span class="line">                [[viewModel.loadDataCommand execute:nil] subscribeNext:^(id x) &#123;</span><br><span class="line">                    result &#x3D; x;</span><br><span class="line">                    done(); &#x2F;&#x2F; 请求结束，告知框架可以继续往下走</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;);</span><br><span class="line">            expect(result).notTo.beNull(); &#x2F;&#x2F; 这里是Expecta框架的内容，后面解释</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    afterEach(^&#123;</span><br><span class="line">        viewModel &#x3D; nil; &#x2F;&#x2F; 测试结束，清空</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">SpecEnd &#x2F;&#x2F; 类的结束，相当于 @end</span><br></pre></td></tr></table></figure><h2 id="OCMock"><a href="#OCMock" class="headerlink" title="OCMock"></a>OCMock</h2><ul><li><p>OCMock一般用来构造伪数据，比如说有时候我们一个方法内部需要通过很多数据才能完成，但是这些数据需要其他复杂的实现去获取，这时候我们用OCMock就可以方便地创造这些数据</p></li><li><p>OCMock可以做的事情大概如下</p><ul><li>指定一个方法的返回值</li><li>验证某个方法是否有被调用 (比如说指定了错误的数据会不会调用处理异常的方法)</li><li>验证方法block传出来的参数是否符合预期</li><li>模拟UI和验证UI的显示</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SpecBegin(BZPPCaiYunViewModel)</span><br><span class="line"></span><br><span class="line">    __block BZPPCaiYunViewModel *viewModel;</span><br><span class="line"></span><br><span class="line">    beforeEach(^&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    describe(@&quot;Test OCMock&quot;, ^&#123;</span><br><span class="line">        it(@&quot;It should not to be null&quot;, ^&#123;</span><br><span class="line">            id mockManager &#x3D; OCMClassMock([BZPPHunLianManager class]); &#x2F;&#x2F; 因为是单例所以要用这种方法mock一个对象</span><br><span class="line">            OCMStub([mockManager sharedInstance]).andReturn([BZPPHunLianManager class]); &#x2F;&#x2F; 同上，调用单例方法返回一个单例对象, OCMStub意思就是模拟执行某个方法, 用andReturn返回指定的值</span><br><span class="line">            OCMVerify([mockManager getGanQingHunYinData:OCMOCK_ANY isMale:YES]); &#x2F;&#x2F; 验证这个方法是否在上面的过程中被调用了，结果是没有被调用，测试失败</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    afterEach(^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">SpecEnd</span><br></pre></td></tr></table></figure><h2 id="Expecta"><a href="#Expecta" class="headerlink" title="Expecta"></a>Expecta</h2><ul><li>Expecta是一个断言框架, 语法十分地通俗易懂, 很接近自然语言</li><li>Expecta的用法比较简单</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect(obj).to.beNull(); &#x2F;&#x2F; 期望某对象应该是空值</span><br><span class="line">expect(obj).toNot.beNull(); &#x2F;&#x2F; 期望某对象不应该是空值</span><br><span class="line">expect(obj).equal(xxx); &#x2F;&#x2F; 期望等于某个值</span><br></pre></td></tr></table></figure><p>诸如此类比较多可以去看Github官方文档</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于第三方单元测试框架的简单说明&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Shell 笔记</title>
    <link href="https://www.arclin.cn/post/cfe784af.html"/>
    <id>https://www.arclin.cn/post/cfe784af.html</id>
    <published>2018-05-17T08:10:25.000Z</published>
    <updated>2021-04-12T06:07:04.037Z</updated>
    
    <content type="html"><![CDATA[<p>Shell 笔记，有机会写就会继续补充</p><span id="more"></span><ol><li>if语句的中括号要留空格  <code>if空格[空格 判断语句 空格]; then xxx fi</code> </li><li>判断买某个路径是否是文件夹  <code>if [ -d “./xxx” ]; then xxx fi</code></li><li>建立一个数组 <code>check=(&quot;Wechat&quot; &quot;Ali&quot; &quot;Union&quot; &quot;Pay&quot;)</code></li><li>声明一个函数, 并取得第一个参数 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function xxx() &#123;</span><br><span class="line">dir&#x3D;$1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>获得某个后缀名的文件 <code>directory=./$&#123;d%.*&#125;&quot;.app&quot;</code></li><li>执行某个命令但不输出到控制台 <code>unzip $xxx &gt; /dev/null 2&gt;&amp;1</code></li><li>声明某个变量为局部变量，使用<code>local</code>关键字 <code>local dir=$1</code></li><li>大写转小写 <code>local file_name_lower=$(echo $file_name | tr &#39;A-Z&#39; &#39;a-z&#39;)</code></li><li>小写转大写 <code>local file_name_lower=$(echo $file_name | tr &#39;a-z&#39; &#39;A-Z&#39;)</code></li><li>遍历数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for item in $&#123;check[@]&#125;; do</span><br><span class="line">    echo $item</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li>字符串A是否包含字符串B <code>if[[ $A =~ $B ]]; then xxx fi</code></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Shell 笔记，有机会写就会继续补充&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Jenkins上蒲公英插件中update description 无法自动写入commit message问题解决</title>
    <link href="https://www.arclin.cn/post/5fcbb764.html"/>
    <id>https://www.arclin.cn/post/5fcbb764.html</id>
    <published>2018-05-10T02:46:00.000Z</published>
    <updated>2021-04-12T06:07:04.036Z</updated>
    
    <content type="html"><![CDATA[<p>花了一天时间解决这个问题，找了好多资料都没找到，最后终于想到了办法。</p><span id="more"></span><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在Jenkins上使用蒲公英上传软件安装包有两种方法，一种是使用命令行的方式<br>类似下面这种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IPANAME&#x3D;&quot;jinkens-myapp&quot;</span><br><span class="line">fastlane gym --export_method ad-hoc --output_name $&#123;IPANAME&#125;</span><br><span class="line"></span><br><span class="line">MSG&#x3D;&#96;git log -1 --pretty&#x3D;%B&#96;</span><br><span class="line">PASSWORD&#x3D;123456</span><br><span class="line">curl -F &quot;file&#x3D;@$&#123;IPANAME&#125;&quot; -F &quot;uKey&#x3D;USER_KEY&quot; -F &quot;_api_key&#x3D;API_KEY&quot; -F &quot;updateDescription&#x3D;$&#123;MSG&#125;&quot; -F &quot;password&#x3D;$&#123;PASSWORD&#125;&quot; https:&#x2F;&#x2F;qiniu-storage.pgyer.com&#x2F;apiv1&#x2F;app&#x2F;upload</span><br></pre></td></tr></table></figure><p>这种方式的话就可以直接通过命令行获得<code>commit message</code>作为版本更新说明，但是缺点是无法直接通过环境变量获得上传后的App的各种信息，比如安装包地址，app二维码图片的等等。</p><p>第二种方式是通过蒲公英在Jenkins上发布的插件<code>Upload to pgyer</code>，优点是上传后的各种App的信息都会被注入到环境变量中，可以在邮件模板中直接调用。缺点是Upload description必须写死为某个值，或者使用某个环境变量，但是Jenkins的Git插件又不提供给你最后一条<code>commit message</code>的环境变量。</p><p>所以说为了结合两种方式的优点，想出了如下办法解决了。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li>安装插件    <code>Environment Injector Plugin</code></li><li>构建步骤添加<code>Execute Shell</code>，填写 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 把commit message写入文件中</span><br><span class="line">MSG&#x3D;$(git log -1 --pretty&#x3D;%B)</span><br><span class="line">echo &quot;commitMessage&#x3D;&quot;$&#123;MSG&#125; &gt; commitMessage.txt</span><br></pre></td></tr></table></figure></li><li>构件步骤中添加<code>Inject Environment variables</code>，<code>Properties File Path</code>填写<code>$&#123;WORKSPACE&#125;/commitMessage.txt</code>(也有可能是别的路径，不要写错了)</li><li>最后在蒲公英插件<code>Upload to pgyer</code>上<code>updateDescription</code>中填写<code>$&#123;commitMessage&#125;</code></li></ol><p>就这样子就可以了，就是把message写到文件中，然后通过文件注入环境变量，然后蒲公英插件再去用就行了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;花了一天时间解决这个问题，找了好多资料都没找到，最后终于想到了办法。&lt;/p&gt;</summary>
    
    
    
    <category term="Jenkins" scheme="https://www.arclin.cn/categories/Jenkins/"/>
    
    
    <category term="Jenkins" scheme="https://www.arclin.cn/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>docker笔记</title>
    <link href="https://www.arclin.cn/post/4417b09c.html"/>
    <id>https://www.arclin.cn/post/4417b09c.html</id>
    <published>2018-02-18T14:19:00.000Z</published>
    <updated>2021-04-12T06:07:04.038Z</updated>
    
    <content type="html"><![CDATA[<p>docker学习笔记</p><span id="more"></span><p>docker是一种类似虚拟机的存在</p><p>// 查看本机docker信息</p><p><code>docker info</code></p><p>// 运行hello world</p><p><code>docker run centos:6.7 /bin/echo &quot;Hello World&quot;</code></p><p>//  -t 进入伪终端<br>//  -i 允许你对容器内的标准输入 (STDIN) 进行交互。 </p><p><code>docker run -i -t centos:6.7 /bin/bash</code></p><p>// -d 后台模式</p><p><code> docker run -d centos:6.7 /bin/sh -c &quot;while true;do echo hello world; sleep 1; done&quot;</code></p><p>//  查看当前运行的容器</p><p><code>docker ps</code></p><p>// -l 最近创建的容器</p><p><code>docker ps -l</code></p><p>// -a 所有容器</p><p><code>docker ps -a</code></p><p>// 查看运行log</p><p><code>docker logs 2b1b7a428627</code></p><p>//或</p><p><code>docker logs angry_austin</code></p><p>// 具体参数看ps的内容进行替换</p><p>// 停止容器</p><p><code>docker stop angry_austin</code></p><p>// 删除容器</p><p><code>docker rm awesome_bardeen</code></p><p>// 进入容器终端 允许标准输入</p><p><code>docker exec -it practical_fermat /bin/bash</code></p><p>中间的参数是容器名</p><p>// 拉取镜像 (如:httpd)</p><p><code>docker pull httpd</code></p><p>// 指定端口运行容器</p><p><code>docker run -d -p 5000:5001 httpd</code></p><p>// 提交新的镜像并添加tag v2 </p><p><code>docker commit -m &quot;has update&quot; -a=&quot;arclin&quot; 000c5746fa52 arclin/centos:v2</code></p><p>// 添加标签dev  中间那串是容器id</p><p><code>docker tag d 607e5fac1115 arclin/centos:dev</code></p><p>// 删除标签 6.7</p><p><code>docker rmi -f arclin/centos:6.7</code></p><p>// 指定端口运行  8080 是本地端口 80是容器端口 -d 是后台运行的意思</p><p><code>docker run -d -p 8080:80 httpd</code></p><p>// 随机端口运行 -P</p><p><code>docker run -d -P  httpd</code></p><p>// 查看容器practical_fermat的80端口被绑定到本机的哪个端口上了</p><p><code>docker port practical_fermat 80</code></p><p>// 运行的时候顺便给容器命名</p><p><code>docker run -d -P --name testName httpd</code></p><p>// 给容器重命名</p><p><code>docker rename practical_fermat test_httpd</code></p><p>// 运行nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 81:80 --name mynginx -v $PWD&#x2F;www:&#x2F;www -v </span><br><span class="line"></span><br><span class="line">$PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf -v $PWD&#x2F;logs:&#x2F;wwwlogs  -d nginx  </span><br><span class="line">-p 81:80：将容器的80端口映射到主机的81端口</span><br><span class="line">--name mynginx：将容器命名为mynginx</span><br><span class="line">-v $PWD&#x2F;www:&#x2F;www：将主机中当前目录下的www挂载到容器的&#x2F;www</span><br><span class="line">-v $PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">-v $PWD&#x2F;logs:&#x2F;wwwlogs：将主机中当前目录下的logs挂载到容器的&#x2F;wwwlogs</span><br></pre></td></tr></table></figure><p>// 查看nginx的文件系统</p><p><code>docker inspect mynginx | grep Mounts -A 20</code></p><p>// 安装Apache</p><p><code>mkdir -p  ~/apache/www ~/apache/logs ~/apache/conf </code></p><p>// 运行Apache</p><p><code>docker run -p 80:80 -v $PWD/www/:/usr/local/apache2/htdocs/ -v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf -v $PWD/logs/:/usr/local/apache2/logs/ -d httpd</code></p><p>// 删除所有容器</p><p><code>sudo docker rm $(docker ps -a -q)</code></p><p>// 下载容器内的文件</p><p><code>docker cp ecef8319d2c8:/root/test.txt /root/</code></p><p>// 上传文件到容器中</p><p><code>docker cp /root/test.txt ecef8319d2c8:/root/</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;docker学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.arclin.cn/categories/Linux/"/>
    
    
    <category term="docker" scheme="https://www.arclin.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 内容替换模块 http_substitutions_filter_module</title>
    <link href="https://www.arclin.cn/post/e35ccdb6.html"/>
    <id>https://www.arclin.cn/post/e35ccdb6.html</id>
    <published>2018-02-18T14:16:00.000Z</published>
    <updated>2021-04-12T06:07:04.036Z</updated>
    
    <content type="html"><![CDATA[<p>在镜像了某个网站之后,想要改变这个网站上某些元素的显示内容, 这是我们可以使用nginx的一个第三方模块<code>http_substitutions_filter_module</code></p><span id="more"></span><p>修改nginx配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name g.arclin.me;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;fullchain.pem;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;privkey.pem;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        subs_filter Google\s提供 Arclin提供 r;</span><br><span class="line">        google on;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在镜像了某个网站之后,想要改变这个网站上某些元素的显示内容, 这是我们可以使用nginx的一个第三方模块&lt;code&gt;http_substitutions_filter_module&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.arclin.cn/categories/Linux/"/>
    
    
    <category term="nginx" scheme="https://www.arclin.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>安装shadowsocks服务端</title>
    <link href="https://www.arclin.cn/post/eb81866c.html"/>
    <id>https://www.arclin.cn/post/eb81866c.html</id>
    <published>2018-02-18T14:15:00.000Z</published>
    <updated>2021-04-12T06:07:04.040Z</updated>
    
    <content type="html"><![CDATA[<p>安装shadowsocks服务端</p><span id="more"></span><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install python-pip</span><br><span class="line">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;server”:”172.93.xx.xx”, # 服务器IP </span><br><span class="line"> &quot;server_port&quot;:8388, # 端口号</span><br><span class="line"> &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line"> &quot;local_port”:1080,</span><br><span class="line"> &quot;password&quot;:&quot;gtPtAb)Wsss&quot;, # 密码</span><br><span class="line"> &quot;timeout&quot;:300,</span><br><span class="line"> &quot;method&quot;:&quot;aes-256-cfb&quot;,# 加密类型</span><br><span class="line"> &quot;fast_open&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;安装shadowsocks服务端&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.arclin.cn/categories/Linux/"/>
    
    
    <category term="Shadowsocks" scheme="https://www.arclin.cn/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>nginx 镜像谷歌</title>
    <link href="https://www.arclin.cn/post/a6a89073.html"/>
    <id>https://www.arclin.cn/post/a6a89073.html</id>
    <published>2018-02-18T14:12:00.000Z</published>
    <updated>2021-04-12T06:07:04.039Z</updated>
    
    <content type="html"><![CDATA[<p>nginx 镜像谷歌</p><span id="more"></span><p>安装nginx第三方模块</p><p>下载-&gt;解压-&gt;编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;artfiles.org&#x2F;openssl.org&#x2F;source&#x2F;old&#x2F;1.1.0&#x2F;openssl-1.1.0g.tar.gz</span><br><span class="line">wget ftp:&#x2F;&#x2F;ftp.csx.cam.ac.uk&#x2F;pub&#x2F;software&#x2F;programming&#x2F;pcre&#x2F;pcre-8.39.tar.gz</span><br><span class="line">wget http:&#x2F;&#x2F;zlib.net&#x2F;zlib-1.2.11.tar.gz</span><br><span class="line"></span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;nginx&#x2F;nginx.git</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;cuber&#x2F;ngx_http_google_filter_module</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;yaoweibin&#x2F;ngx_http_substitutions_filter_module</span><br><span class="line"></span><br><span class="line">cd ngx_http_google_filter_module</span><br><span class="line">git checkout 77532b9</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar -zxvf openssl-1.1.0g.tar.gz </span><br><span class="line">tar -zxvf pcre-8.39.tar.gz </span><br><span class="line">tar -zxvf zlib-1.2.11.tar.gz</span><br><span class="line"></span><br><span class="line">cd nginx</span><br><span class="line"></span><br><span class="line">.&#x2F;auto&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --conf-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf --with-http_v2_module --with-pcre&#x3D;..&#x2F;pcre-8.39 --with-openssl&#x3D;..&#x2F;openssl-1.1.0g --with-zlib&#x3D;..&#x2F;zlib-1.2.11 --with-http_ssl_module --add-module&#x3D;..&#x2F;ngx_http_google_filter_module --add-module&#x3D;..&#x2F;ngx_http_substitutions_filter_module</span><br><span class="line"></span><br><span class="line">make -j 4</span><br><span class="line"></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>修改配置文件</p><p><code>vi /usr/local/nginx/conf/nginx.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name g.arclin.me;</span><br><span class="line">    listen 80;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        google on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br><span class="line">service nginx restart</span><br></pre></td></tr></table></figure><p>reload 时发生错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx: [error] open() &quot;&#x2F;var&#x2F;run&#x2F;nginx.pid&quot; failed (2: No such file or directory)</span><br></pre></td></tr></table></figure><p>解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;nginx 镜像谷歌&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.arclin.cn/categories/Linux/"/>
    
    
    <category term="nginx" scheme="https://www.arclin.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>XCode 添加Target</title>
    <link href="https://www.arclin.cn/post/8cafabb2.html"/>
    <id>https://www.arclin.cn/post/8cafabb2.html</id>
    <published>2018-02-18T14:08:00.000Z</published>
    <updated>2021-04-12T06:07:04.038Z</updated>
    
    <content type="html"><![CDATA[<p>在区分开发环境和测试环境或生产环境的时候经常需要在XCode 添加Target, 所以在此记录一下</p><span id="more"></span><ol><li>Duplicate target</li><li>Change DisplayName &amp; Bundle Identifier</li><li>A copy-info.plist，默认生成在程序环境根目录，也就是<code>A.xcodeproj</code>的同级目录中，如果想放到里层（比如与<code>A-info.plist</code>放在同级目录），可以先在Xcode删除<code>A copy-info.plist</code>索引，然后拷贝文件到制定目录中，然后更名为<code>B-info.plist</code>，在add到project中。在<code>Project</code>的<code>Build Settings</code>中，修改<code>Info.plist</code> File选项为<code>B-info.plist</code>的目录（相对路径）,这样就可以看到Info页了（就是B-info.plist），接着修改<code>ProductName</code>和<code>Bundle identifier</code>，使之成为另一个app。<code>Prefix Header的路径</code>，视具体需求而定是否要修改，如果两个target可以公用同一个<code>Prefix Header</code>，那么就不需要修改这里的路径</li><li>修改scheme，在调试的Stop按钮边上，我们可以选择本工程中所有的target来做编译，如果不修改，在这里选择出来的名字就是A copy，为了与新建的target统一起来，同样也要修改这里的名字。点击scheme选择区，然后选Manager Scheme，找到A copy，然后改成你需要的名字，比如B</li><li>生成一个新的target，一定会与原target有区别，这里可以定义预编译宏，来区分两个版本的不同代码，预编译宏可以在Build Settings中Preprocessor Macros定义，比如在我们新建的target B中定义预编译宏MACRO，然后在代码中通过<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if defined (MACRO)</span><br><span class="line">&#x2F;&#x2F;target  B需要执行的代码</span><br><span class="line">#else</span><br><span class="line">&#x2F;&#x2F;target A需要执行的代码</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>来区分</li><li>其他：Build Phases（各target编译所包含的内容，需要注意的是，如果创建了target B后，再往A里面添加资源或文件，target B中不会自动增加这些资源，需要手动添加）<ul><li>Compile Sources<br>需要编译的代码文件</li><li>Link Binary With Libraries<br>编译所依赖的库</li><li>Copy Bundle Resources<br>编译需要的资源<br>每个target可以根据具体需要增减里面的内容</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在区分开发环境和测试环境或生产环境的时候经常需要在XCode 添加Target, 所以在此记录一下&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="XCode" scheme="https://www.arclin.cn/tags/XCode/"/>
    
  </entry>
  
  <entry>
    <title>frp 内网穿透</title>
    <link href="https://www.arclin.cn/post/b72542c2.html"/>
    <id>https://www.arclin.cn/post/b72542c2.html</id>
    <published>2018-02-18T14:05:00.000Z</published>
    <updated>2021-04-12T06:07:04.038Z</updated>
    
    <content type="html"><![CDATA[<p>frp 内网穿透</p><span id="more"></span><p><a href="https://github.com/fatedier/frp/blob/master/README_zh.md">文档</a></p><h3 id="服务器CentOS下载安装"><a href="#服务器CentOS下载安装" class="headerlink" title="服务器CentOS下载安装"></a>服务器CentOS下载安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.13.0&#x2F;frp_0.13.0_linux_amd64.tar.gz</span><br><span class="line">tar -zxvf frp_0.13.0_linux_amd64.tar.gz</span><br><span class="line">cd frp_0.13.0_linux_amd64.tar.gz</span><br><span class="line">rm -f frpc</span><br><span class="line">rm -f frpc.ini</span><br><span class="line">vi frps.ini</span><br></pre></td></tr></table></figure><p>编辑frps.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">vhost_http_port &#x3D; 8001 # http访问端口</span><br><span class="line">bind_port &#x3D; 8009 # 远程响应的地址</span><br><span class="line">dashboard_port &#x3D; 8002 #控制面板端口号</span><br><span class="line"># dashboard 用户名密码，默认都为 admin</span><br><span class="line">dashboard_user &#x3D; admin</span><br><span class="line">dashboard_pwd &#x3D; admin</span><br></pre></td></tr></table></figure><h3 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;frps -c .&#x2F;frps.ini</span><br></pre></td></tr></table></figure><h3 id="Mac客户端下载"><a href="#Mac客户端下载" class="headerlink" title="Mac客户端下载"></a>Mac客户端下载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.13.0&#x2F;frp_0.13.0_darwin_amd64.tar.gz</span><br><span class="line">tar -zxvf frp_0.13.0_darwin_amd64.tar.gz</span><br><span class="line">cd frp_0.13.0_darwin_amd64.tar.gz</span><br><span class="line">rm -f frps</span><br><span class="line">rm -f frps.ini</span><br><span class="line">vi frpc.ini</span><br></pre></td></tr></table></figure><p>编辑frpc.ini</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr &#x3D; 120.78.175.51 # 远程服务器地址</span><br><span class="line">server_port &#x3D; 8009 # 服务端填写的bind_port</span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line">type &#x3D; http </span><br><span class="line">local_port &#x3D; 3000 # 本地要映射的端口</span><br><span class="line">custom_domains &#x3D; frp.arclin.me # 自定义的域名,需要在dnspod绑定远程主机地址</span><br></pre></td></tr></table></figure><h3 id="客户端运行"><a href="#客户端运行" class="headerlink" title="客户端运行"></a>客户端运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;frpc -c .&#x2F;frpc.ini</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;frp 内网穿透&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.arclin.cn/categories/Linux/"/>
    
    
    <category term="frp" scheme="https://www.arclin.cn/tags/frp/"/>
    
  </entry>
  
  <entry>
    <title>ngrok 内网穿透使用</title>
    <link href="https://www.arclin.cn/post/dda122f4.html"/>
    <id>https://www.arclin.cn/post/dda122f4.html</id>
    <published>2018-02-18T14:02:00.000Z</published>
    <updated>2021-04-12T06:07:04.039Z</updated>
    
    <content type="html"><![CDATA[<p>ngrok 内网穿透使用</p><span id="more"></span><h3 id="安装golang"><a href="#安装golang" class="headerlink" title="安装golang"></a>安装golang</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install build-essential golang mercurial git</span><br></pre></td></tr></table></figure><h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;tutumcloud&#x2F;ngrok.git ngrok</span><br><span class="line">export NGROK_DOMAIN&#x3D;&quot;ngrok.arclin.me&quot;</span><br><span class="line">cd ngrok</span><br><span class="line">openssl genrsa -out rootCA.key 2048</span><br><span class="line">openssl req -x509 -new -nodes -key rootCA.key -subj &quot;&#x2F;CN&#x3D;$NGROK_DOMAIN” -days 5000 -out rootCA.pem</span><br><span class="line">openssl genrsa -out device.key 2048</span><br><span class="line">openssl req -new -key device.key -subj &quot;&#x2F;CN&#x3D;$NGROK_DOMAIN” -out device.csr</span><br><span class="line">openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br><span class="line">cp rootCA.pem assets&#x2F;client&#x2F;tls&#x2F;ngrokroot.crt</span><br><span class="line">cp device.crt assets&#x2F;server&#x2F;tls&#x2F;snakeoil.crt</span><br><span class="line">cp device.key assets&#x2F;server&#x2F;tls&#x2F;snakeoil.key</span><br><span class="line">GOOS&#x3D;linux GOARCH&#x3D;amd64</span><br><span class="line">make release-server</span><br><span class="line">cd &#x2F;usr&#x2F;lib&#x2F;golang&#x2F;src&#x2F;</span><br><span class="line">GOOS&#x3D;darwin GOARCH&#x3D;amd64 .&#x2F;make.bash</span><br><span class="line">cd ~&#x2F;ngrok</span><br><span class="line">GOOS&#x3D;darwin GOARCH&#x3D;amd64 make release-client</span><br></pre></td></tr></table></figure><h3 id="服务端运行脚本"><a href="#服务端运行脚本" class="headerlink" title="服务端运行脚本"></a>服务端运行脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup  bin&#x2F;ngrokd -domain&#x3D;&quot;ngrok.arclin.me&quot; -httpAddr&#x3D;&quot;:8081&quot; -httpsAddr&#x3D;&quot;:8082&quot; &amp;</span><br></pre></td></tr></table></figure><blockquote><p>nohub 后台运行</p></blockquote><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>新建 <code>./ngrok.cfg</code> 文件写入信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server_addr:arclin.me:4443</span><br><span class="line">trust_host_root_certs: false</span><br></pre></td></tr></table></figure><p>客户端运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;ngrok -config&#x3D;.&#x2F;ngrok.cfg -subdomain&#x3D;test 3000</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;ngrok 内网穿透使用&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.arclin.cn/categories/Linux/"/>
    
    
    <category term="ngrok" scheme="https://www.arclin.cn/tags/ngrok/"/>
    
  </entry>
  
  <entry>
    <title>Salesforce SDK Bug</title>
    <link href="https://www.arclin.cn/post/e88dc875.html"/>
    <id>https://www.arclin.cn/post/e88dc875.html</id>
    <published>2018-02-18T13:59:00.000Z</published>
    <updated>2021-04-12T06:07:04.037Z</updated>
    
    <content type="html"><![CDATA[<p>Salesforce SDK 有几个bug 不修复的话跑不起来 所以在这里记录一下</p><span id="more"></span><ol><li><code>SFOAuthCoordinator</code> 960行 </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ([self isRedirectURL:requestUrl]) &#123;</span><br><span class="line">     [self handleUserAgentResponse:url];</span><br><span class="line">     decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">     return;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>SFSDKLoginHostListViewController</code> <code>viewDidLoad</code>最下面的注册cell移动到<code>viewDidLoad</code>的第一行</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Salesforce SDK 有几个bug 不修复的话跑不起来 所以在这里记录一下&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="Salesforce" scheme="https://www.arclin.cn/tags/Salesforce/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB笔记</title>
    <link href="https://www.arclin.cn/post/b3b38c86.html"/>
    <id>https://www.arclin.cn/post/b3b38c86.html</id>
    <published>2018-02-18T13:58:00.000Z</published>
    <updated>2021-04-12T06:07:04.036Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB笔记</p><span id="more"></span><p>OS X安装</p><p><code>brew install mongodb</code></p><p>进入mongodb</p><p><code>mongo</code></p><p>查看所有数据库</p><p><code>db</code></p><p>查看所有<em>有数据的</em>数据库并带上内存信息</p><p><code>show dbs</code></p><p>创建/进入某个数据库</p><p><code>use DATABASE_NAME</code></p><p>删除数据库(需要先<code>use DATABASE_NAME</code> 进入数据库)</p><p><code>db.dropDatabase()</code></p><p>插入数据</p><p><code>db.DATABASE_NAME.insert(&#123;“COLUMN_NAME”:”VALUE”,”COLUMN_NAME_SECOND”:”SECOND_VALUE”&#125;)</code></p><p>查询所有数据</p><p><code>db.DATABASE_NAME.find()</code></p><p>查询所有数据并pretty形式打印</p><p><code>db.DATABASE_NAME.find().pretty()</code></p><p>更新满足条件的第一条数据</p><p><code>db.DATABASE_NAME.update(&#123;‘条件字段’:’条件值’&#125;,&#123;$set:&#123;‘更新字段’:’更新值’,‘更新字段2’:’更新值2’&#125;&#125;)</code></p><p>更新满足条件的所有数据</p><p><code>db.DATABASE_NAME.update(&#123;‘条件字段’:’条件值’&#125;,&#123;$set:&#123;‘更新字段’:’更新值’,‘更新字段2’:’更新值2’&#125;,&#123;multi:true&#125;&#125;)</code></p><p>替换整条数据的内容(根据ID查找)</p><p><code>db.DATABASE_NAME.save(&#123;“_id”:ObjectId(“xxxxx”),”要替换的字段名”:”要替换的字段名”,”要替换的字段名2”:”要替换的字段名2”&#125;)</code></p><p>删除数据</p><p><code>db.DATABASE_NAME.remove(&#123;‘条件字段’:’条件值’&#125;)</code></p><p>删除第一条找到的记录</p><p><code>db.DATABASE_NAME.remove(&#123;‘条件字段’:’条件值’&#125;,1)</code></p><p>删除所有数据(请空表)</p><p><code>db.DATABASE_NAME.remove(&#123;&#125;)</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MongoDB笔记&lt;/p&gt;</summary>
    
    
    
    <category term="MongoDB" scheme="https://www.arclin.cn/categories/MongoDB/"/>
    
    
    <category term="MongoDB" scheme="https://www.arclin.cn/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>使用PHP进行webhook的注意点</title>
    <link href="https://www.arclin.cn/post/f8291fcc.html"/>
    <id>https://www.arclin.cn/post/f8291fcc.html</id>
    <published>2018-02-18T13:55:00.000Z</published>
    <updated>2021-04-12T06:07:04.040Z</updated>
    
    <content type="html"><![CDATA[<p>有时会编写PHP脚本进行webhook, 这里有些地方需要注意一下, 否则会导致脚本执行失败</p><span id="more"></span><p>允许某些敏感方法的执行<br>编辑<code>php.ini</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">disable_functions &#x3D; scandir,passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,</span><br><span class="line">ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,</span><br><span class="line">stream_socket_server,fsocket,fsockopen</span><br></pre></td></tr></table></figure><p>把<code>exec</code>去掉</p><p>检查<code>apache</code>用户的目录权限</p><p>apache用户公钥要配置在项目里面<br>也就是项目里会有两个公钥<br>一个是root的一个是apache的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有时会编写PHP脚本进行webhook, 这里有些地方需要注意一下, 否则会导致脚本执行失败&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.arclin.cn/categories/PHP/"/>
    
    
    <category term="php" scheme="https://www.arclin.cn/tags/php/"/>
    
    <category term="webhook" scheme="https://www.arclin.cn/tags/webhook/"/>
    
  </entry>
  
  <entry>
    <title>Apache强制https </title>
    <link href="https://www.arclin.cn/post/f6ce3122.html"/>
    <id>https://www.arclin.cn/post/f6ce3122.html</id>
    <published>2018-02-18T13:50:00.000Z</published>
    <updated>2021-04-12T06:07:04.038Z</updated>
    
    <content type="html"><![CDATA[<p>当用户访问http的地址的时候，Apache如何强制跳转到https地址</p><span id="more"></span><p>修改httpd.conf</p><ol><li>LoadModule rewrite_module modules/mod_rewrite.so 这个拓展貌似是已经被加载了；</li><li>修改Apache默认项目路径的这个</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&quot;&gt;</span><br></pre></td></tr></table></figure><p>其实是修改为项目发布的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;app&#x2F;src&#x2F;htdocs_www&quot;&gt;</span><br></pre></td></tr></table></figure><p>改为All</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AllowOverride All</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># </span><br><span class="line"># Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, </span><br><span class="line"># or any combination of: </span><br><span class="line"># Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews </span><br><span class="line"># </span><br><span class="line"># Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; </span><br><span class="line"># doesn&#39;t give it to you. </span><br><span class="line"># </span><br><span class="line"># The Options directive is both complicated and important. Please see </span><br><span class="line"># http:&#x2F;&#x2F;httpd.apache.org&#x2F;docs&#x2F;2.2&#x2F;mod&#x2F;core.html</span><br><span class="line"># options </span><br><span class="line"># for more information. </span><br><span class="line"># Options Indexes FollowSymLinks </span><br><span class="line"># </span><br><span class="line"># AllowOverride controls what directives may be placed in .htaccess files. </span><br><span class="line"># It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: </span><br><span class="line"># Options FileInfo AuthConfig Limit </span><br><span class="line"># </span><br><span class="line"># </span><br><span class="line"># Controls who can get stuff from this server. </span><br><span class="line"># </span><br><span class="line">Order allow,deny </span><br><span class="line">Allow from all</span><br></pre></td></tr></table></figure><p>添加三行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RewriteEngine on</span><br><span class="line">RewriteCond %&#123;SERVER_PORT&#125; !^443$</span><br><span class="line">RewriteRule ^(.*)?$ https:&#x2F;&#x2F;%&#123;SERVER_NAME&#125;&#x2F;$1 [L,R]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;当用户访问http的地址的时候，Apache如何强制跳转到https地址&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.arclin.cn/categories/Linux/"/>
    
    
    <category term="https" scheme="https://www.arclin.cn/tags/https/"/>
    
  </entry>
  
</feed>
