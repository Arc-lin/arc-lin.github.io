<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arclin</title>
  
  <subtitle>Advocate Technology. Enjoy Technology.</subtitle>
  <link href="https://www.arclin.cn/atom.xml" rel="self"/>
  
  <link href="https://www.arclin.cn/"/>
  <updated>2021-06-13T04:34:24.741Z</updated>
  <id>https://www.arclin.cn/</id>
  
  <author>
    <name>Arclin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 底层原理 --- Block、__block及其底层实现</title>
    <link href="https://www.arclin.cn/post/8275b854.html"/>
    <id>https://www.arclin.cn/post/8275b854.html</id>
    <published>2021-06-07T15:50:00.000Z</published>
    <updated>2021-06-13T04:34:24.741Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述Block、__block的本质是什么东西，文章涉及循环引用等开发常见问题，需要重点关注。</p><span id="more"></span><h2 id="先写一个最简单的block"><a href="#先写一个最简单的block" class="headerlink" title="先写一个最简单的block"></a>先写一个最简单的block</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Block&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>使用命令行将<code>main.m</code>文件编译成C++文件<br/><br><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m </code></p><p>编译完成后，上述代码会变成以下结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void(*block)(void) &#x3D; &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br></pre></td></tr></table></figure><p>可以看出是生成了一个<code>__main_block_impl_0</code>结构体类型的对象，参数1为<code>__main_block_func_0</code>，参数2为<code>&amp;__main_block_desc_0_DATA</code></p><h2 id="block的底层结构"><a href="#block的底层结构" class="headerlink" title="block的底层结构"></a>block的底层结构</h2><p>接下来查看一下<code>__main_block_impl_0</code>是什么东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; block的结构体，引用了两个结构体和实现了一个构造方法</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags&#x3D;0) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; block的结构体引用的第一个结构体</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; block的结构体引用的第二个结构体，第一个参数赋值了0，第二个参数赋值了__main_block_impl_0的结构体大小</span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure><p>所以拼接一下可以看出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags&#x3D;0) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><em><strong>结论1：block本质上是一个OC对象，它内部也有个isa指针</strong></em></li></ul><p>接下来看看构造方法，第一个参数是<code>void *fp</code>意为<code>function pointer</code>函数指针，所以我们回去看看这里传了什么值进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void(*block)(void) &#x3D; &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure><p>是<code>__main_block_func_0</code>，那我们再看看<code>__main_block_func_0</code>是什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_34b858_mi_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出我们在block内写的代码被封装成了一个函数</p><ul><li><em><strong>结论2：block是封装了函数调用以及函数调用环境的OC对象</strong></em></li></ul><p>最后，看一下block的调用，被编译成了下述结构（这里我们去掉强制转换）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(block)-&gt;FuncPtr(block);</span><br></pre></td></tr></table></figure><p>可以看出，是取出了变量中的<code>FuncPtr</code>成员变量，得到函数指针后把自己传进去，这样子就完成了block的调用</p><h2 id="block捕获外部变量"><a href="#block捕获外部变量" class="headerlink" title="block捕获外部变量"></a>block捕获外部变量</h2><p>从上面的分析我们可以得知，局部变量的定义和使用，是在两个函数中进行的，所以为了能够给让变量跨函数访问，block需要捕获该变量 </p><h3 id="局部auto类型的变量捕获"><a href="#局部auto类型的变量捕获" class="headerlink" title="局部auto类型的变量捕获"></a>局部auto类型的变量捕获</h3><p><strong>auto ： 自动变量，离开作用域自动销毁</strong></p><p>平常我们定义的局部变量，默认都是<code>auto</code>修饰的</p><p>先写一个简单的demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 10; &#x2F;&#x2F; 等价于 auto int age &#x3D; 10;</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Block %d&quot;,age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译后变成如下结构(去掉强制转换)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 10;</span><br><span class="line">void(*block)(void) &#x3D; &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br></pre></td></tr></table></figure><p><code>__main_block_impl_0</code>也发生了变化，可以看到多了一个<code>age</code>成员变量，所以构造函数也多了一个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int age;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags&#x3D;0) : age(_age) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>age(_age)</code>这个语法意为将构造方法传进来的<code>_age</code>赋值到自己的的成员变量<code>age</code>，这个过程我们称作变量的<strong>捕获</strong></p><p>block内编译后的函数<code>__main_block_func_0</code>也发生了变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int age &#x3D; __cself-&gt;age; &#x2F;&#x2F; bound by copy</span><br><span class="line">   NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_5fd8ec_mi_0,age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出函数内取出了结构体内的<code>age</code>成员变量，然后交给<code>NSLog</code>使用</p><p>由此可知，block在定义的时候就会把外部传进来的参数给存储一遍，然后调用的时候在从block对象中取出来，所以这就意味着<strong>被block捕获的变量，在被捕获后如果修改了值，是不会应用到block中的</strong>，举例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 10;</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;age &#x3D; %d&quot;,age);</span><br><span class="line">&#125;;</span><br><span class="line">age &#x3D; 20;</span><br><span class="line">block(); &#x2F;&#x2F; 调用这个方法只会输出age &#x3D; 10，因为age被捕获时是10，所以后面就算改了值也没用</span><br></pre></td></tr></table></figure><h3 id="局部static类型的变量捕获"><a href="#局部static类型的变量捕获" class="headerlink" title="局部static类型的变量捕获"></a>局部static类型的变量捕获</h3><p>把上面的<code>age</code>变量加一个<code>static</code>修饰符试试看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int age &#x3D; 10;</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;age &#x3D; %d&quot;,age);</span><br><span class="line">&#125;;</span><br><span class="line">age &#x3D; 20;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>结果会输出<code>age = 20</code>，原因是静态变量会将<code>static</code>修饰的对象转为block的指针类型的成员属性，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int *age;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int *age &#x3D; __cself-&gt;age; &#x2F;&#x2F; bound by copy</span><br><span class="line">  NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_bb86ee_mi_0,(*age));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是指针传递，所以当指针指向的内容变化时，打印出来的值也就会变化了</p><h3 id="全局变量不捕获"><a href="#全局变量不捕获" class="headerlink" title="全局变量不捕获"></a>全局变量不捕获</h3><p>全局<code>static</code>变量不捕获，因为全局<code>static</code>变量大家都能访问，所以函数内可以直接读取值</p><h3 id="block内的self会被捕获吗"><a href="#block内的self会被捕获吗" class="headerlink" title="block内的self会被捕获吗"></a>block内的self会被捕获吗</h3><p>会，我们来举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)test &#123;</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,self); </span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>test</code>方法会添加两个隐含的参数，编译后如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void _I_Person_Test(Person *self, SEL _cmd) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这就是为什么我们能在方法内访问<code>self</code>和<code>_cmd</code>的原因，因为方法会传进来<code>self</code>参数，又因为参数是局部变量，又因为局部变量会被捕获，所以<code>self</code>参数会被捕获，捕获后大概长这样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  Person *self;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Block的类型"><a href="#Block的类型" class="headerlink" title="Block的类型"></a>Block的类型</h2><p>Block有三种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型</p><table><thead><tr><th>存储区域</th><th>类名</th><th>特点</th><th>调用copy后的效果</th></tr></thead><tbody><tr><td>数据区域 .data区</td><td><code>__NSGlobalBlock__</code></td><td>没有访问auto变量</td><td>无效果</td></tr><tr><td>栈区</td><td><code>__NSStackBlock__</code></td><td>访问了auto变量</td><td>从栈复制到堆</td></tr><tr><td>堆区</td><td><code>__NSMallocBlock__</code></td><td><code>__NSStackBlock__</code>调用了copy</td><td>引用计数增加</td></tr></tbody></table><h3 id="NSGlobalBlock"><a href="#NSGlobalBlock" class="headerlink" title="__NSGlobalBlock__"></a><code>__NSGlobalBlock__</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Hello world&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="NSStackBlock"><a href="#NSStackBlock" class="headerlink" title="__NSStackBlock__"></a><code>__NSStackBlock__</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 20;</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">   NSLog(@&quot;Block %d&quot;,age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为在ARC环境下，栈区block会自动copy，所以要测试这个类型的时候，需要使用MRC环境</p><p><strong>栈区数据的特点是会自动销毁，离开了作用域，数据都会销毁</strong></p><p><strong>栈区block存在的问题是，捕获的变量会存放在栈区，所以一旦离开了作用域，捕获的内容就销毁了，将来再去访问这个block内捕获的变量，访问到的可能就是一个未知的内容</strong></p><p>以下情况编译器会自动将栈上的block复制到堆上：</p><ol><li>block作为函数返回值时，比如 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^Block)(void);</span><br><span class="line">Block myBlock() &#123;</span><br><span class="line">int age &#x3D; 10</span><br><span class="line">    return ^&#123;</span><br><span class="line">    NSLog(@&quot;---------%d&quot;,age);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>将block赋值给__strong指针时<ul><li>__strong是是id类型和对象类型默认的所有权修饰符，所以平时在ARC环境下写的引用外部auto局部变量的block都会自动copy到堆中，原因是block默认被__strong修饰了</li></ul></li><li>block作为Cocoa API中方法名含有usingBlock的方法参数时<ul><li>比如NSArray的<code>enumerateObjectsUsingBlock:</code>方法，block传进去之后就会被copy一下</li></ul></li><li>block作为GCD API的方法参数时<ul><li>比如GCD的<code>dispatch_after(dispatch_time_t when, dispatch_queue_t queue,   dispatch_block_t block);</code>方法，block传进去之后就会被copy一下</li></ul></li></ol><h3 id="NSMallocBlock"><a href="#NSMallocBlock" class="headerlink" title="__NSMallocBlock__"></a><code>__NSMallocBlock__</code></h3><p>将<code>__NSStackBlock__</code>进行一次copy，即可得到<code>__NSMallocBlock__</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 20;</span><br><span class="line">void(^block)(void) &#x3D; [^&#123;</span><br><span class="line">   NSLog(@&quot;Block %d&quot;,age);</span><br><span class="line">&#125; copy];</span><br></pre></td></tr></table></figure><h2 id="捕获对象类型的auto变量"><a href="#捕获对象类型的auto变量" class="headerlink" title="捕获对象类型的auto变量"></a>捕获对象类型的auto变量</h2><p>当block内部访问了对象类型的auto变量时，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Person %@&quot;,person);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>我们在ARC环境下编译，这时候block会在堆上（因为被自动copy了），执行命令行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</code>，会发现block结构体的person属性多了一个<code>__strong</code>的修饰符，证明他被block强持有了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  ...</span><br><span class="line">  Person *__strong person;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们如果编译的时候去掉<code>-fobjc-arc</code>，默认就是MRC环境了，这时候block会在栈上，查看编译后的c++文件发现不会有<code>__strong</code>修饰符，如果我们在block执行前加一行<code>[person release]</code>，那么这时候<code>person</code>就会直接释放，证明block没有持有<code>person变量</code></p><ul><li>结论1：如果block是在栈上，将不会对auto变量产生强引用</li></ul><p>如果我们给person添加<code>__weak</code>修饰符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__weak Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Person %@&quot;,person);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>则block将会对person对象进行弱引用，编译后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  ...</span><br><span class="line">  Person *__weak person;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以使用<code>__weak</code>修饰符可以避免block对外部变量的强引用操作</p><p>我们来看看block的结构体内的<code>__main_block_desc_0</code>是个什么东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br></pre></td></tr></table></figure><p>可以发现，多了两个函数指针，<code>copy</code>和<code>dispose</code>，分别指向<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code></p><p>这两个函数的实现如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">_Block_object_assign((void*)&amp;dst-&gt;person, (void*)src-&gt;person, 3&#x2F;*BLOCK_FIELD_IS_OBJECT*&#x2F;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class="line">_Block_object_dispose((void*)src-&gt;person, 3&#x2F;*BLOCK_FIELD_IS_OBJECT*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_Block_object_assign</code>函数内部会对person进行引用计数器的操作，如果<code>__main_block_impl_0</code>结构体内person指针是<code>__strong</code>类型，则为强引用，引用计数+1，如果<code>__main_block_impl_0</code>结构体内person指针是<code>__weak</code>类型，则为弱引用，引用计数不变。</p><p><code>_Block_object_dispose</code>会对person对象做释放操作，类似于release，也就是断开对person对象的引用，而person究竟是否被释放还是取决于person对象自己的引用计数</p><ul><li>结论2：如果block被拷贝到堆上<ul><li>会调用block内部的copy函数</li><li>copy函数内部会调用_Block_object_assign函数</li><li>_Block_object_assign函数会根据auto变量的修饰符（<code>__strong</code>，<code>__weak</code>，<code>__unsafe_unretained</code>）做出相应的操作，类似于retain(形成强引用、弱引用)</li></ul><blockquote><p>__unsafe_unretained修饰的变量不会增加引用计数，当销毁时，该指针不会置空，会造成不安全的情况。</p></blockquote></li><li>结论3：如果block从堆上移除<ul><li>会调用block内部的dispose函数</li><li>dispose函数内部会调用_Block_object_assign函数</li><li>_Block_object_dispose函数会自动释放引用的auto变量，类似于release</li></ul></li></ul><table><thead><tr><th>函数</th><th>调用时机</th></tr></thead><tbody><tr><td>copy函数</td><td>栈上的Block复制到堆时</td></tr><tr><td>dispose函数</td><td>堆上的Block被废弃时</td></tr></tbody></table><h2 id="block"><a href="#block" class="headerlink" title="__block"></a>__block</h2><p>一般情况下我们是无法改变block捕获的外部的值的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">person &#x3D; nil;  &#x2F;&#x2F;&#x2F; 这种情况是会编译失败的</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>从上面的内容我们也可以知道原因。就是因为外部的person所在的内存空间和block内（单独开辟了一个函数）的内存空间不在同一个位置，所以block内是访问不到的外部的person的。</p><p>但是我们如果添加了<code>__block</code>关键字的话，就可以访问了，所以我们编译一下看看添加<code>__block</code>之后的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__block Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">person &#x3D; nil;  &#x2F;&#x2F; 编译成功</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>编译后长这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_person_0 *person; &#x2F;&#x2F; by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_person_0 *_person, int flags&#x3D;0) : person(_person-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到person对象被封装成了一个<code>__Block_byref_person_0 *</code>类型的属性</p><p>继续看看<code>__Block_byref_person_0</code>是什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_person_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_person_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> void (*__Block_byref_id_object_copy)(void*, void*);</span><br><span class="line"> void (*__Block_byref_id_object_dispose)(void*);</span><br><span class="line"> Person *__strong person;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__Block_byref_person_0</code>有isa指针，是一个OC对象，里面有一个强引用的person对象（指向的内容等同于外面的person指针指向的内容），和我们熟悉的<code>__Block_byref_id_object_copy</code>和<code>__Block_byref_id_object_dispose</code>方法用于处理内存管理问题，还有指向自身的<code>forwarding</code>指针（这个指针指向对象自身），<code>flag</code>和<code>size</code>，分别表示标记位和这个结构体的占用内存空间大小。</p><p>person被封装成了结构体对象之后，原先的block函数就变成了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">__Block_byref_person_0 *person &#x3D; __cself-&gt;person; &#x2F;&#x2F; bound by ref</span><br><span class="line">(person-&gt;__forwarding-&gt;person) &#x3D; __null;</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_250618_mi_0,(person-&gt;__forwarding-&gt;person));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，但我们要改变person指针的值的时候，首先是取出person对象，即<code>__Block_byref_person_0 *person</code>，然后再通过<code>forwarding</code>指针拿到自己，再拿到最里面的person，最后就可以修改了。</p><ol><li><p>通过内存打印，我们可以得知<code>__Block_byref_person_0</code>内的person对象和外部的person对象的地址是一致的，所以我们在block内修改外部的person就是相当于修改<code>__Block_byref_person_0</code>内的person对象</p></li><li><p>为什么要绕一个圈，不直接<code>person-&gt;person</code>而是要<code>person-&gt;__forwarding-&gt;person</code>？原因是防止block从栈复制到堆之后，栈上面的block访问person访问到的是栈上的person而不是堆上的person，所以栈上的forwarding指针要指向堆的block，这样子就能一直访问到堆上的person了</p></li><li><p>封装的<code>__Block_byref_person_0</code>结构体内的<code>__Block_byref_id_object_copy</code>函数会管理他自己的person对象的内存，实现代码如下:<br> <code>_Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);</code>，这里的40是person对象的偏移值，可以看到结构体内person前面的4个指针加2个整型刚好40个字节。</p></li><li><p><code>__Block_byref_person_0</code>在<code>__main_block_impl_0</code>内必定是强引用，跟我们上面所说的不一样，就算在<code>__block</code>之前再添加<code>__weak</code>修饰，<code>__Block_byref_person_0</code>在<code>__main_block_impl_0</code>内依旧是强引用，加上<code>__weak</code>修饰受影响的只有<code>__Block_byref_person_0</code>内的person指针的引用方式</p></li></ol><blockquote><p>注意：MRC环境下，__block 不会对变量造成强引用，即以下情况person会提前释放</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__block Person *person &#x3D; [Person new];</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,person);</span><br><span class="line">&#125;;</span><br><span class="line">block(); &#x2F;&#x2F;&#x2F; 这时候person已经释放了</span><br></pre></td></tr></table></figure><blockquote><p>注意：__block只能用于修饰auto变量，不能修饰全局变量和静态（static）变量</p></blockquote><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><h3 id="循环引用的发生原因与解决方式"><a href="#循环引用的发生原因与解决方式" class="headerlink" title="循环引用的发生原因与解决方式"></a>循环引用的发生原因与解决方式</h3><ul><li><p>以下代码会产生循环引用</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"> @property (nonatomic, copy) void(^block)(void);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person *person &#x3D; [Person alloc] init];</span><br><span class="line">person.age &#x3D; 10;</span><br><span class="line">person.block &#x3D; ^&#123;</span><br><span class="line">NSLog(@&quot;age is %d&quot;,person.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  原因是person.block捕获了person，person又持有着block，也就是block内部对person存在一个强引用，person对block也存在一个强引用，所以均无法释放。</p></li><li><p>在定义person指针的时候添加<code>__weak</code>修饰符或者<code>__unsafe_unretain</code>修饰符，就可以让block在捕获person的时候弱引用person，这样子就不会造成循环引用了.</p>  <img src="https://z3.ax1x.com/2021/06/13/2I2lPU.png" alt="2I2lPU.png" border="0" width="50%" />> __weak: 不会产生强引用，指向的对象销毁时，会自动让指针至nil，不支持MRC > __unsafe_unretain: 不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变，变成野指针，支持MRC</li><li><p>在定义person指针的时候添加<code>__block</code>修饰符也可以解决循环引用问题，但前提是需要调用block并手动将person指针置为nil，如下</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block Person *person &#x3D; [Person alloc] init];</span><br><span class="line">person.age &#x3D; 10;</span><br><span class="line">person.block &#x3D; ^&#123;</span><br><span class="line">NSLog(@&quot;age is %d&quot;,person.age);</span><br><span class="line">       person &#x3D; nil;</span><br><span class="line">&#125;;</span><br><span class="line">   person.block();</span><br></pre></td></tr></table></figure><p>  为什么这样子可以解决循环引用呢?首先先分析一下内存结构</p><ul><li>peron持有block</li><li>block持有__block对象</li><li>__block持有着person</li><li>peron又持有着block</li><li>…</li></ul><p>  所以这里是三个对象相互持有形成一个三角形关系</p>  <img src="https://z3.ax1x.com/2021/06/13/2IcLXn.png" alt="2IcLXn.png" border="0" width="30%"/>    当block执行，person = nil，解除了`__block`变量对person的引用的时候，循环引用就不再存在了    <img src="https://z3.ax1x.com/2021/06/13/2IgCp4.png" alt="2IgCp4.png" border="0" width="30%"/><ul><li>MRC环境下，由于**__block不会对变量造成强引用**，所以直接用__block修饰指针也可以达到以上效果</li></ul></li></ul><h3 id="为什么block做属性不能常weak而是用copy"><a href="#为什么block做属性不能常weak而是用copy" class="headerlink" title="为什么block做属性不能常weak而是用copy"></a>为什么block做属性不能常weak而是用copy</h3><p>如果上述例子使用weak修饰block的话，那么block会在栈中，block里面的person也会在栈中，所以离开了作用域的话，里面的person就会销毁，从而无法使用。</p><p>如果你希望block做完事情就释放，比如发送一个通知，修改某个单例类的属性，没有引用外部局部变量，那么用weak就可以节约内存空间</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要简述Block、__block的本质是什么东西，文章涉及循环引用等开发常见问题，需要重点关注。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- Category、+load、+initialize和关联对象</title>
    <link href="https://www.arclin.cn/post/2397c268.html"/>
    <id>https://www.arclin.cn/post/2397c268.html</id>
    <published>2021-06-06T14:24:00.000Z</published>
    <updated>2021-06-07T15:48:08.999Z</updated>
    
    <content type="html"><![CDATA[<p>本文简述iOS中分类的底层实现和load方法、initialize方法在类和分类中的调用特性，还有如何通过关联对象的方式给分类添加属性，以及关联对象的底层实现原理</p><span id="more"></span><h2 id="分类（Category）"><a href="#分类（Category）" class="headerlink" title="分类（Category）"></a>分类（Category）</h2><h3 id="先写一个Demo"><a href="#先写一个Demo" class="headerlink" title="先写一个Demo"></a>先写一个Demo</h3><p>新建一个命令行工程，在main.m中写几个类</p><p>父类：写一个run方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">- (void)run;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>父类的分类：写一个eat方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface Person(Test) </span><br><span class="line"></span><br><span class="line">- (void)eat;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据经验可知道，现在Peron对象拥有了run方法和eat方法</p><h3 id="分类的底层结构"><a href="#分类的底层结构" class="headerlink" title="分类的底层结构"></a>分类的底层结构</h3><p>输入命令行</p><p><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code></p><p>接下来同级目录下就会多出一个编译后的文件<code>main.cpp</code>，查看后发现<code>Person(Test) </code>分类被编译成了如下变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static struct _category_t _OBJC_$_CATEGORY_Person_$_Test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) &#x3D; </span><br><span class="line">&#123;</span><br><span class="line">&quot;Person&quot;,</span><br><span class="line">0, &#x2F;&#x2F; &amp;OBJC_CLASS_$_Person,</span><br><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Test,</span><br><span class="line">0,</span><br><span class="line">0,</span><br><span class="line">0,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个变量的类型是<code>static struct _category_t</code>，名字是<code>_OBJC_$_CATEGORY_Person_$_Test</code>，等于号后面是一个初始化结构体的过程，可以看到要实例化这个结构体需要6个参数，所以查看<code>_category_t</code>的结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct _category_t &#123;</span><br><span class="line">const char *name; &#x2F;&#x2F;&#x2F; 原来的类的名字</span><br><span class="line">struct _class_t *cls; &#x2F;&#x2F;&#x2F; 类对象</span><br><span class="line">const struct _method_list_t *instance_methods; &#x2F;&#x2F;&#x2F; 实例方法数组</span><br><span class="line">const struct _method_list_t *class_methods; &#x2F;&#x2F;&#x2F; 类方法数组</span><br><span class="line">const struct _protocol_list_t *protocols; &#x2F;&#x2F;&#x2F; 遵循的协议数组</span><br><span class="line">const struct _prop_list_t *properties; &#x2F;&#x2F;&#x2F; 属性数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由此可知，<strong>分类可以定义实例方法，可以定义类方法，可以遵循协议，可以添加属性，但是不能添加成员变量！因为分类的结构里面没有存储成员变量的地方.</strong></p><h3 id="程序通过runtime动态将分类合并到类对象、元类对象中"><a href="#程序通过runtime动态将分类合并到类对象、元类对象中" class="headerlink" title="程序通过runtime动态将分类合并到类对象、元类对象中"></a>程序通过runtime动态将分类合并到类对象、元类对象中</h3><p>分类中的方法是在运行时才添加到类对象和元类对象中的，而不是编译的时候添加的，编译之后只是多了几个类型为<code>_category_t</code>的结构体变量。</p><p>合并的过程可以在runtime源码（objc4-818.2）中<code>objc-runtime-new.mm</code>的<code>load_categories_nolock</code>函数中看到，这里不展开流程，直接说结论。</p><p>合并过程是这样子的，首先我们知道原来的类（我们就叫他主类吧）对象是存放着成员方法的，主类的元类对象是放着类方法的，因为类对象和元类对象结构是一样的，所以我们就讨论成员方法就好了。</p><p>其次呢，runtime先根据分类方法的数量在数组里面开辟空间，然后把分类方法塞到原来的成员方法数组的前端，这样子合并就完成了，其他类方法、协议、属性等数组，也是同样的过程。</p><p>所以最后在<strong>类对象的方法列表数组里面，排在前面的是分类方法，后面才是主类的方法。如果有多个分类的话，那么后编译的分类的成员方法会插在数组的前面（因为插入数组的时候是倒序插入）</strong>。</p><p>有了上述结论 我们就可以解释很多事情了。</p><h4 id="如果分类实现了主类的方法会怎么样"><a href="#如果分类实现了主类的方法会怎么样" class="headerlink" title="如果分类实现了主类的方法会怎么样"></a>如果分类实现了主类的方法会怎么样</h4><p>根据上述结论，系统在找对应的调用方法的时候，会先找到分类的方法，所以主类的方法没有机会被调用到。</p><h4 id="如果多个分类都实现了同个主类的方法"><a href="#如果多个分类都实现了同个主类的方法" class="headerlink" title="如果多个分类都实现了同个主类的方法"></a>如果多个分类都实现了同个主类的方法</h4><p>根据上述结论，后编译的分类的成员方法会插在方法列表的前面，所以谁后编译，就调用谁</p><h4 id="如果子类或者子类的分类实现了父类的分类方法"><a href="#如果子类或者子类的分类实现了父类的分类方法" class="headerlink" title="如果子类或者子类的分类实现了父类的分类方法"></a>如果子类或者子类的分类实现了父类的分类方法</h4><p>根据上述结论和结合我们以前所学知识，最后子类实例对象会去子类的类对象里面寻找方法并调用，使用<code>super</code>关键字调用方法的话，则会去到父类的类对象内找方法。</p><h3 id="Category跟Class-Extension的区别"><a href="#Category跟Class-Extension的区别" class="headerlink" title="Category跟Class Extension的区别"></a>Category跟Class Extension的区别</h3><ul><li>Class Extension是编译的时候，它的数据就已经包含在类信息中</li><li>Category 是在运行时才会讲数据合并到类信息中</li></ul><h2 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h2><h3 id="先写一个Demo-1"><a href="#先写一个Demo-1" class="headerlink" title="先写一个Demo"></a>先写一个Demo</h3><p>父类：实现load方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Person load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>父类的分类：实现load方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person(Test)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Person Text load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子类：实现load方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation Student</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Student load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子类的分类：实现load方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@implementation Student(Test)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Student Test load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="load方法的调用时机"><a href="#load方法的调用时机" class="headerlink" title="load方法的调用时机"></a>load方法的调用时机</h3><p>通过runtime源码（objc4-818.2）<code>objc-runtime-new.mm</code>第3233行得知，load方法是在加载镜像(load_images)的时候调用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    if (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;</span><br><span class="line">        didInitialAttachCategories &#x3D; true;</span><br><span class="line">        loadAllCategories();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Return without taking locks if there are no +load methods here.</span><br><span class="line">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Discover load methods</span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((const headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Call +load methods (without runtimeLock - re-entrant)</span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>补充小细节：从<code>load_images</code>函数可以看到，加载分类<code>loadAllCategories()</code>早于调用load方法<code>call_load_methods()</code>，也就是元类对象中的类方法列表内，分类的load方法会在主类的load方法之前</p></blockquote><p>在调用load方法之前，首先要通过<code>prepare_load_methods</code>函数整理出一个数组，这个数组会决定主类的load方法的调用顺序</p><p>从<code>prepare_load_methods</code>函数中调用的<code>schedule_class_load</code>函数的内部实现我们可以知道，父类会先被加入到数组中，其次才是主类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* prepare_load_methods</span><br><span class="line">* Schedule +load for classes in this image, any un-+load-ed </span><br><span class="line">* superclasses in other images, and any categories in this image.</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">&#x2F;&#x2F; Recursively schedule +load for cls and any un-+load-ed superclasses.</span><br><span class="line">&#x2F;&#x2F; cls must already be connected.</span><br><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());  &#x2F;&#x2F; _read_images should realize</span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Ensure superclass-first ordering</span><br><span class="line">    schedule_class_load(cls-&gt;getSuperclass());</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们回到最开始的地方（load_images），通过<code>objc-loadmethod.mm</code>第337行<code>call_load_methods</code>得知，先调用主类的load方法(call_class_loads())，再调用分类的load方法<code>call_category_loads();</code></p><blockquote><p>补充一个小细节：在整理数组的时候，这个数组里面存放的是一个个结构体，结构体长这样</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct loadable_class &#123;</span><br><span class="line">    Class cls;  &#x2F;&#x2F; may be nil  这里放元类对象（load是类方法所以存在元类对象里面）</span><br><span class="line">    IMP method;  &#x2F;&#x2F;&#x2F; 这里放的是load方法的函数指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct loadable_category &#123;</span><br><span class="line">    Category cat;  &#x2F;&#x2F; may be nil 这个是上面讲到的category_t类型的对象</span><br><span class="line">    IMP method; &#x2F;&#x2F;&#x2F; 这里放的是load方法的函数指针</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：runtime代码内有记录类的load方法是否曾经被加入到load数组过（RW_LOADED），如果被调用过了，就会跳过，这就是load方法只会执行一次的原因（但是你要是非要手动调用load方法那还是会执行的）</p><p><strong>重要：系统调用load方法不通过消息发送机制</strong>，可以查看<code>objc-loadmethod.mm</code>第177行如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* call_class_loads</span><br><span class="line">* Call all pending class +load methods.</span><br><span class="line">* If new classes become loadable, +load is NOT called for them.</span><br><span class="line">*</span><br><span class="line">* Called only by call_load_methods().</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">static void call_class_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Detach current loadable list.</span><br><span class="line">    struct loadable_class *classes &#x3D; loadable_classes;</span><br><span class="line">    int used &#x3D; loadable_classes_used;</span><br><span class="line">    loadable_classes &#x3D; nil;</span><br><span class="line">    loadable_classes_allocated &#x3D; 0;</span><br><span class="line">    loadable_classes_used &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Call all +loads for the detached list.</span><br><span class="line">    for (i &#x3D; 0; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls &#x3D; classes[i].cls;</span><br><span class="line">        load_method_t load_method &#x3D; (load_method_t)classes[i].method;</span><br><span class="line">        if (!cls) continue; </span><br><span class="line"></span><br><span class="line">        if (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 意为直接通过函数指针调用函数</span><br><span class="line">        (*load_method)(cls, @selector(load));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Destroy the detached list.</span><br><span class="line">    if (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="load方法的调用顺序"><a href="#load方法的调用顺序" class="headerlink" title="load方法的调用顺序"></a>load方法的调用顺序</h3><p>综上所述，分类也有load方法。调用顺序是：先调用父类load方法，再调用子类load方法，最后调用分类的load方法，如果有多个分类，那么先编译的，先调用。</p><p>所以上述Demo代码执行后输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person load</span><br><span class="line">Student load</span><br><span class="line">Person Test load</span><br><span class="line">Student Test load</span><br></pre></td></tr></table></figure><p>这里Person比Student先调用是因为他是父类，Person(Test)比Student(Test)先调用是因为它先编译</p><h3 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a>综上所述</h3><p>于是我们可以解答下面的问题</p><ol><li>类和分类都有+load方法</li><li>根据编译顺序，先调用父类+load，再调用子类+load，再调用分类+load(看编译顺序)</li><li>因为系统调用load方法时不通过消息发送机制，所以不存在子类load方法覆盖父类load方法的情况，但是，如果手动调用load方法（即通过消息发送机制调用方法），那么这时候就有继承的现象发生了，也就是子类会覆盖父类方法的实现。</li></ol><p>搞点复杂的事情</p><ol><li>父类实现，父类分类实现，子类不实现，子类分类实现<br/><br> 顺序：父类load，子类分类load、父类分类load<br/><br> 原因：本来应该调用子类load的，无奈子类load没实现，但是找到了子类分类，那么就调用子类分类的load，最后在调用父类分类load(因为分类要最晚调用，由于刚才子类分类被调用过了，所以这里没它事了)<br/><br> <strong>所以：不一定主类的load方法总比分类的load方法早调用，存在特殊情况</strong><br/><br/></li><li>父类不实现，父类分类实现，子类实现，子类分类实现<br/><br> 顺序：父类分类load，子类load，子类分类load<br/><br> 原因：跟上面的理由是一样的，父类没实现但是父类分类找到了那么就调用<br/><br> <strong>所以：父类的分类的load也可以比子类load方法早调用</strong></li></ol><h2 id="initialize方法"><a href="#initialize方法" class="headerlink" title="initialize方法"></a>initialize方法</h2><h3 id="先写个Demo"><a href="#先写个Demo" class="headerlink" title="先写个Demo"></a>先写个Demo</h3><p>父类：实现initialize方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;Person initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>父类的分类：实现initialize方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person(Test)</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;Person Text initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子类：实现initialize方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation Student</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;Student initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子类的分类：实现initialize方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@implementation Student(Test)</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;Student Test initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="initialize方法的调用时机"><a href="#initialize方法的调用时机" class="headerlink" title="initialize方法的调用时机"></a>initialize方法的调用时机</h3><ul><li><p><code>+initialize</code>会在类第一次接受到消息的时候调用，即<code>objc_msgSend()</code>被触发的时候调用，这部分是汇编实现</p></li><li><p>runtime源码里面有一个<code>class_getInstanceMethod()</code>函数，用于查找方法，当找到要调用的方法之后，就会调用<code>initialize</code>方法，<code>class_getInstanceMethod()</code>内的主要实现为<code>lookUpImpOrForward()</code>函数的调用</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* class_getInstanceMethod.  Return the instance method for the</span><br><span class="line">* specified class and selector.</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">Method class_getInstanceMethod(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls  ||  !sel) return nil;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; This deliberately avoids +initialize because it historically did so.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; This implementation is a bit weird because it&#39;s the only place that </span><br><span class="line">    &#x2F;&#x2F; wants a Method instead of an IMP.</span><br><span class="line"></span><br><span class="line">    Method meth;</span><br><span class="line">    meth &#x3D; _cache_getMethod(cls, sel, _objc_msgForward_impcache);</span><br><span class="line">    if (meth &#x3D;&#x3D; (Method)1) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache contains forward:: . Stop searching.</span><br><span class="line">        return nil;</span><br><span class="line">    &#125; else if (meth) &#123;</span><br><span class="line">        return meth;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    &#x2F;&#x2F; Search method lists, try method resolver, etc.</span><br><span class="line">    lookUpImpOrForward(nil, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER);</span><br><span class="line"></span><br><span class="line">    meth &#x3D; _cache_getMethod(cls, sel, _objc_msgForward_impcache);</span><br><span class="line">    if (meth &#x3D;&#x3D; (Method)1) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache contains forward:: . Stop searching.</span><br><span class="line">        return nil;</span><br><span class="line">    &#125; else if (meth) &#123;</span><br><span class="line">        return meth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return _class_getMethod(cls, sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>lookUpImpOrForward()</code>函数实现内，有一判断条件为<code>if(slowpath(!cls-&gt;isInitialized())) &#123; ... &#125;</code> ，若该类已经调用过<code>+initialize</code>，那么就不会再调用，这就是<code>+initialize</code>只被系统调用一次的原因</p></li><li><p>经过一层层点击方法实现（流程见补充），最终我们可以在<code>objc-initialize.mm</code>内发现函数<code>callInitialize(Class cls)</code>，内部实现是<code>objc_msgSend</code>，如下</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  void callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ((void(*)(Class, SEL))objc_msgSend)(cls, @selector(initialize));</span><br><span class="line">    asm(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>补充：函数调用路径为<code>lookUpImpOrForward</code>-&gt;<code>realizeAndInitializeIfNeeded_locked</code>-&gt;<code>initializeAndLeaveLocked</code>-&gt;<code>initializeAndMaybeRelock</code>-&gt;<code>initializeNonMetaClass</code>-&gt;<code>callInitialize</code><br/>其中：<code>initializeNonMetaClass</code>函数实现内有一个递归，不断地传入<code>superclass</code>指针，去调用父类的<code>initialize</code>方法，直到<code>superclass</code>指针为空（或已经调用过<code>initialize</code>）为止，这就是先调用父类的<code>initialize</code>方法的原因</p></blockquote><h3 id="initialize方法的调用顺序"><a href="#initialize方法的调用顺序" class="headerlink" title="initialize方法的调用顺序"></a>initialize方法的调用顺序</h3><ul><li>先调用父类的<code>initialize</code>方法，再调用子类的<code>initialize</code></li></ul><h3 id="综上所述-1"><a href="#综上所述-1" class="headerlink" title="综上所述"></a>综上所述</h3><ol><li><code>initialize</code>是通过<code>objc_msgSend</code>方式调用的，所以会受分类、继承等等因素影响调用</li><li>如果子类没有实现<code>+initialize</code>，会调用父类的<code>+initiailize</code>（所以父类的<code>+initialize</code>可能会被调用多次）</li><li>如果分类实现了<code>+initialize</code>，就会覆盖主类的<code>+initialize</code>调用</li></ol><h2 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h2><p>假如我们要给一个类添加一个属性如下：<br><br><code>@property (copy, nonatomic) NSString *test;</code></p><h3 id="存值"><a href="#存值" class="headerlink" title="存值"></a>存值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT void</span><br><span class="line">objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,</span><br><span class="line">                         id _Nullable value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>解释</th></tr></thead><tbody><tr><td>object</td><td>要关联的对象，如果是在分类内给主类添加属性，那么这里就写<code>self</code></td></tr><tr><td>key</td><td>要用来标记这个属性的key，取值的时候也得靠这个key取</td></tr><tr><td>value</td><td>存储的内容</td></tr><tr><td>policy</td><td>存储策略（见下表）</td></tr></tbody></table><h4 id="objc-AssociationPolicy-存储策略"><a href="#objc-AssociationPolicy-存储策略" class="headerlink" title="objc_AssociationPolicy 存储策略"></a>objc_AssociationPolicy 存储策略</h4><table><thead><tr><th>策略枚举</th><th>对应修饰符</th></tr></thead><tbody><tr><td>OBJC_ASSOCIATION_ASSIGN</td><td>assign</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td>strong, nonatomic</td></tr><tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC</td><td>copy,nonatomic</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN</td><td>strong, atomic</td></tr><tr><td>OBJC_ASSOCIATION_COPY</td><td>copy,atomic</td></tr></tbody></table><blockquote><p>如果要存weak类型的对象怎么办？<br/>创建一个类，用<code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code>标记存在主类中，然后在这个新建的类里面再存放一个weak引用的属性</p></blockquote><h4 id="key有多少种填写形式"><a href="#key有多少种填写形式" class="headerlink" title="key有多少种填写形式"></a>key有多少种填写形式</h4><ol><li>声明全局变量<code>static const void *TestKey = &amp;TestKey;</code>,将<code>TestKey</code>的地址作为key的内容，不能直接写<code>const void *TestKey</code>，因为这么写等共同于<code>const void *TestKey = NULL</code>，要是以后添加别的属性，就会冲突，使用例子：</li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(self,TestKey,test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure><ol start="2"><li>声明全局变量<code>static const char TestKey</code>，同样将<code>TestKey</code>的地址作为key，好处是<code>char</code>只占用一个字节的内存大小，使用例子：</li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(self,&amp;TestKey,test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure><ol start="3"><li>因为OC内的字符串都存在常量区，所以通过字面量创建的相同字符串都是同个地址，所以我们也可以随便定义一个字符串去做key，使用例子：</li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(self,@&quot;Test&quot;,test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure><ol start="4"><li>我们也可以通过使用getter方法的方法编号去做key，使用例子：</li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(self,@selector(test),test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure><h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key);</span><br></pre></td></tr></table></figure><ul><li>object同上，一般分类里面就填self</li><li>key属性需要和上面设值的key属性一致</li></ul><ul><li>如果使用getter方法的方法编号去做key，有两种写法<ol><li><code>objc_getAssociatedObject(self, @selector(test))</code></li><li><code>objc_getAssociatedObject(self, _cmd)</code>，<code>_cmd</code>表示当前方法的方法地址</li></ol></li></ul><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p><img src="https://www.hualigs.cn/image/60bd149eb55dc.jpg" alt="图片来源自小码哥教程"></p><ul><li>runtime维护着一个名为<code>AssociationsManager</code>的类</li><li>类里面存放着一个字典，键是传入的对象（object参数），值是<code>ObjectAssociationMap</code>类的实例对象</li><li><code>ObjectAssociationMap</code>是一个字典，键是传入的key参数，值是<code>ObjcAssociation</code>类的实例对象</li><li><code>ObjcAssociation</code>有两个成员变量，<code>_policy</code>存放着传入的policy参数，<code>_value</code>存放着传入的value参数</li></ul><h3 id="综上所述-2"><a href="#综上所述-2" class="headerlink" title="综上所述"></a>综上所述</h3><ol><li>关联对象并不是存储在被关联对象的内存中</li><li>关联对象存储在全局统一的<code>AssociationsManager</code>中</li><li>设置关联对象（object参数）为nil，就相当于是移除关联对象</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文简述iOS中分类的底层实现和load方法、initialize方法在类和分类中的调用特性，还有如何通过关联对象的方式给分类添加属性，以及关联对象的底层实现原理&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- KVC</title>
    <link href="https://www.arclin.cn/post/34b9a649.html"/>
    <id>https://www.arclin.cn/post/34b9a649.html</id>
    <published>2021-05-30T03:59:00.000Z</published>
    <updated>2021-06-06T18:52:24.963Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述KVC的底层实现和KVC是否能触发KVO呢？</p><span id="more"></span><h2 id="KVC的使用"><a href="#KVC的使用" class="headerlink" title="KVC的使用"></a>KVC的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self.person setValue:@10 forKey:@&quot;age&quot;]</span><br><span class="line"></span><br><span class="line">[self.person setValue:@10 forKeyPath:@&quot;age&quot;]</span><br></pre></td></tr></table></figure><p>keyPath和key的区别是，keyPath可以使用路径的方式进行赋值，比如person对象内有cat模型属性，cat对象里面有age属性，那么就可以使用<code>[self.person setValue:@10 forKeyPath:@&quot;cat.age&quot;]</code>的方式使用KVC，而key方式只支持直接访问的方式赋值</p><h2 id="赋值过程"><a href="#赋值过程" class="headerlink" title="赋值过程"></a>赋值过程</h2><p><code>setValue:forKey</code>首先会先寻找<code>setKey:</code>方法，如果找不到，那么就会寻找<code>_setKey:</code>方法，类似下面这样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 优先找这个方法</span><br><span class="line">- （void）setAge:(int)age &#123;</span><br><span class="line">_age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 找不到上面那个方法的话，就找下面这儿方法</span><br><span class="line">- （void）_setAge:(int)age &#123;</span><br><span class="line">_age &#x3D; age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述两个方法都找不到，那么就会去访问类方法<code>+ (BOOL)accessInstanceVariablesDirectly</code>，询问是否允许直接访问成员变量，默认返回YES</p><ul><li><p>如果返回NO的话，那么程序会直接抛出异常<code>exception NSUnknownKeyException, reason:[XXX setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key age</code></p></li><li><p>如果返回YES，那么程序会去直接访问成员变量，查找的顺序是<code>_key、_isKey、key、isKey</code>，类似下面这样子</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    @public </span><br><span class="line">    int _age;</span><br><span class="line">    int _isAge;</span><br><span class="line">    int age;</span><br><span class="line">    int isAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果找到了成员变量，那么就直接赋值</li><li>如果找不到成员变量，那么就抛出上述异常</li></ol><h2 id="KVC是否会触发KVO"><a href="#KVC是否会触发KVO" class="headerlink" title="KVC是否会触发KVO"></a>KVC是否会触发KVO</h2><p>由于KVO是通过重写set方法的方式实现的，所以如果KVC找到了属性值并且通过set方法赋值的话，那么就自然会触发KVO</p><p>如果KVC找不到set方法，如果<code>+ (BOOL)accessInstanceVariablesDirectly</code>返回YES的话，那么他去访问成员方法的时候，即便这时候成员方法是没有实现set方法的，KVC依旧会去执行<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>方法，在执行<code>didChangeValueForKey:</code>的时候，自然KVO就被触发了</p><h2 id="valueForKey-的底层原理"><a href="#valueForKey-的底层原理" class="headerlink" title="valueForKey:的底层原理"></a>valueForKey:的底层原理</h2><p><code>valueForKey:</code>首先会根据<code>getKey、key、isKey、_key</code>顺序查找方法，找到了的话就调用，拿到返回值。</p><p>如果没有找到方法，那么就会去访问类方法<code>+ (BOOL)accessInstanceVariablesDirectly</code>，询问是否允许直接访问成员变量，默认返回YES</p><p>如果允许，那么按照<code>_key、_isKey、key、isKey</code>顺序查找成员变量，找到了的话就直接取值，找不到就抛出异常<code>NSUnknownKeyException</code>。</p><p>如果不允许，就抛出异常<code>NSUnknownKeyException</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲述KVC的底层实现和KVC是否能触发KVO呢？&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- KVO</title>
    <link href="https://www.arclin.cn/post/81c45883.html"/>
    <id>https://www.arclin.cn/post/81c45883.html</id>
    <published>2021-05-26T17:06:23.000Z</published>
    <updated>2021-06-06T18:52:24.965Z</updated>
    
    <content type="html"><![CDATA[<p>本文简述KVO的底层实现是怎么一回事</p><span id="more"></span><h1 id="如何使用KVO"><a href="#如何使用KVO" class="headerlink" title="如何使用KVO"></a>如何使用KVO</h1><p>举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self.person &#x3D; [[Person alloc] init];</span><br><span class="line">self.person.age &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 这个配置的值会直接影响监听方法的change字典里面带些什么值给你</span><br><span class="line">NSKeyValueObservingOptions options &#x3D; NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld;</span><br><span class="line"></span><br><span class="line">[self.person addObserver:self keyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 当监听对象的属性值发生改变时，就会调用这个方法</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 这里的context就是注册监听的时候传入的@“123”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部发生了什么"><a href="#内部发生了什么" class="headerlink" title="内部发生了什么"></a>内部发生了什么</h1><p>系统通过运行时机制，给<code>person</code>对象添加了一个父类，名为<code>NSKVONotifying_Person</code>(其他被监听的对象所生成的类也会遵循这个命名规则)，本质上是将<code>person</code>对象的isa指针指向了这个动态新建的类对象。</p><p>另外，这个新建的类对象是继承自<code>Person</code>的，也就是<code>NSKVONotifying_Person</code>的superclass指针指向了<code>Persond</code>的类对象。</p><h1 id="NSKVONotifying-类内部结构"><a href="#NSKVONotifying-类内部结构" class="headerlink" title="NSKVONotifying_*类内部结构"></a>NSKVONotifying_*类内部结构</h1><ul><li>isa指针</li><li>superclass指针</li><li>setAge:方法  因为监听的是age属性，所以重写了setAge方法，若监听的属性没有set方法，或者值改变的时候没有调用set方法，那么KVO无法生效</li><li>class:方法，主要是为了防止对象调用class方法的时候得到了这个动态生成的类对象，所以重写class方法，返回真正<code>的Person</code>类对象</li><li>_isKVOA方法，返回一个bool，用来判断这是不是一个KVO类</li><li>dealloc 进行一些收尾工作</li></ul><h2 id="重写的set方法的实现"><a href="#重写的set方法的实现" class="headerlink" title="重写的set方法的实现"></a>重写的set方法的实现</h2><p>大概是这么实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAge:(int)age &#123;</span><br><span class="line">   _NSSetIntValueAnyNotify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _NSSetIntValueAnyNotify() </span><br><span class="line">&#123;</span><br><span class="line">   [self willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">   [super setAge:age];</span><br><span class="line">   [self didChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key &#123;</span><br><span class="line">   [observer observeValueForKeyPath:key ofObject:self change:nil context:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的方法<code>_NSSetIntValueAnyNotify</code>，看具体监听的属性类型而定，如果监听的是<code>double</code>类型，那么方法就会变成<code>_NSSetDoubleValueAnyNotify</code>，所以系统内置了很多这种类似的方法，统称为<code>_NSSet*ValueAnyNotify</code></p><ul><li><p>调用流程</p><ol><li>willChangeValueForKey:</li><li>setAge:</li><li>observeValueForKeyPath:ofObject:change:context:</li><li>didChangeValueForKey:</li></ol></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>利用Runtime API动态生成一个之类，并且让instance对象的isa指针指向这个全新的子类</p></li><li><p>当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAnyNotify函数</p><ul><li>willChangeValueForKey:</li><li>父类原来的setter</li><li>didChangeValueForKey:<ul><li>内部会触发监听器（Observer）的监听方法（observeValueForKeyPath:ofObject:change:context:）</li></ul></li></ul></li><li><p>如何手动触发KVO<br>  注册监听后，手动调用<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p></li><li><p>直接修改成员属性的值不会触发KVO，必须在前后分别补上<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文简述KVO的底层实现是怎么一回事&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- instance、class和meta-class</title>
    <link href="https://www.arclin.cn/post/fdd98f42.html"/>
    <id>https://www.arclin.cn/post/fdd98f42.html</id>
    <published>2021-05-25T16:22:27.000Z</published>
    <updated>2021-06-06T18:52:24.963Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲的是实例对象(instance)，类对象(class)，元类对象（meta-class）的内容和他们之间的联系</p><span id="more"></span><h1 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h1><p>实例对象内存储着成员变量的值</p><h1 id="class对象"><a href="#class对象" class="headerlink" title="class对象"></a>class对象</h1><h2 id="class对象的基本内容"><a href="#class对象的基本内容" class="headerlink" title="class对象的基本内容"></a>class对象的基本内容</h2><p>每个类在内存中有且只有一个class对象</p><p>class对象在内存中，存储的信息主要包括</p><ul><li>isa指针</li><li>superclass指针</li><li>类的属性信息（@property）、 类的对象方法信息（instance method）</li><li>类的协议信息（protocol）、类的成员变量信息（ivar）</li></ul><h2 id="class对象的结构"><a href="#class对象的结构" class="headerlink" title="class对象的结构"></a>class对象的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rw: readwrite</span><br><span class="line">ro: readonly</span><br><span class="line">t:   table</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">Class isa;</span><br><span class="line">Class superclass;</span><br><span class="line">cache_t cache; &#x2F;&#x2F; 方法缓存</span><br><span class="line">cache_data_bits_t bits; &#x2F;&#x2F; 用于获取具体类信息</span><br><span class="line"></span><br><span class="line">class_rw_t *data() &#123;</span><br><span class="line">   return bits.data();  &#x2F;&#x2F;  实际方法实现为 bits &amp; FAST_DATA_MASK  结果返回值为 class_rw_t类型的对象</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">unit32 flags;</span><br><span class="line">unit32 version;</span><br><span class="line">const class_ro_t *ro;&#x2F;&#x2F; 方法列表</span><br><span class="line">property_list_t *properties;&#x2F;&#x2F; 属性列表</span><br><span class="line">const protocol_list_t *protocols;&#x2F;&#x2F; 协议列表</span><br><span class="line">Class firstSubclass;</span><br><span class="line">Class nextSiblingClass;</span><br><span class="line">chat *demangledName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">uint32_t flags;</span><br><span class="line">unit32_t instanceStart;</span><br><span class="line">unit32_t instanceSize; &#x2F;&#x2F; instance对象占用的内存空间</span><br><span class="line"></span><br><span class="line">const uint8_t * ivarLayout;</span><br><span class="line">const chat * name; &#x2F;&#x2F; 类名</span><br><span class="line">method_list_t  * baseMethodList;</span><br><span class="line">protoocl_list_t * baseProtocols;</span><br><span class="line">const ivar_list_t *ivars;  &#x2F;&#x2F; 成员变量列表</span><br><span class="line">const uint8_t *weakIverLayout;</span><br><span class="line">property_list_t *baseProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关的几个函数"><a href="#相关的几个函数" class="headerlink" title="相关的几个函数"></a>相关的几个函数</h2><ol><li><code>Class objc_getClass(const chat *aClassName)</code><ol><li>传入字符串类名</li><li>返回对应的类对象</li></ol></li><li><code>Class object_getClass(id obj)</code>获取isa指向的对象<ol><li>传入的obj可能是instance对象、class对象、meta-class对象</li><li>返回值<ol><li>如果是instance对象，返回class对象</li><li>如果是class对象，返回meta-class对象</li><li>如果是meta-class对象，返回NSObject（基类）的meta-class对象</li></ol></li></ol></li><li> <code>- (Class)class</code>、<code>+ (Class)class</code> 返回的就是类对象</li></ol><h1 id="meta-class对象"><a href="#meta-class对象" class="headerlink" title="meta-class对象"></a>meta-class对象</h1><p>意思是用来描述类对象的对象，是一种特殊的类对象。</p><p>每个类在内存中有且只有一个meta-class对象</p><p>meta-class对象和class对象的内存接口是一样的，但是用途不一样，在内存中存储的信息主要包括</p><ul><li>isa指针</li><li>superclass指针</li><li>类的类方法信息</li></ul><h1 id="isa指针和spuerclass指针"><a href="#isa指针和spuerclass指针" class="headerlink" title="isa指针和spuerclass指针"></a>isa指针和spuerclass指针</h1><img src="https://i.loli.net/2021/05/26/pjxbn5vQ17hrmae.png" width="50%"><h2 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h2><p>instance的isa指向class</p><blockquote><p>当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用</p></blockquote><p>class的isa指向meta-class</p><blockquote><p>当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用 </p></blockquote><p>meta-class的isa指向基类（NSObject）的meta-class（NSObject的meta-class的isa指向自己的meta-class）</p><h2 id="superclass指针"><a href="#superclass指针" class="headerlink" title="superclass指针"></a>superclass指针</h2><p>举个例子，比如Student类继承自Person类，Person类继承自NSObject类：</p><p>Student的class的superclass指针指向父类的class对象，如果没有父类（NSObject），则superclass指针为空</p><p>Student的meta-class对象的superclass指针指向Person的meta-class</p><p>基类（NSObject）的meta-class的superclass指针指向class对象</p><h3 id="调用成员方法"><a href="#调用成员方法" class="headerlink" title="调用成员方法"></a>调用成员方法</h3><p>因为Student要调用成员方法的时候，需要找到class对象，因为class对象才存放着成员方法，找不到的话就通过superclass指针找到父类class对象看看里面有没有想要的成员方法</p><h3 id="调用类方法"><a href="#调用类方法" class="headerlink" title="调用类方法"></a>调用类方法</h3><p>当Student要调用Student的类方法的时候，就通过Student的class对象的isa找到Student的meta-class对象，然后找到类方法进行调用</p><p>当Student要调用Person的类方法的时候，就得先通过Student的class对象的isa找到Student的meta-class对象，然后通过Student的mata-class对象里面的superclass指针找到Person的meta-class对象，然后在里面找到Person的类方法进行调用</p><h3 id="调用init方法"><a href="#调用init方法" class="headerlink" title="调用init方法"></a>调用init方法</h3><p>比如现在Student对象要调用init方法，流程如下</p><ol><li>先通过对象自己的isa指针，找到Student的类对象</li><li>Student的类对象里面有superclass指针，那么就通过superclass指针拿到了Person的类对象</li><li>Person的类对象里面也有superclass指针，那么就通过superclass指针拿到NSObject的类对象</li><li>NSObject的类对象里面找到了init方法的相关信息，那么就可以进行调用了</li></ol><h3 id="调用不存在的类方法"><a href="#调用不存在的类方法" class="headerlink" title="调用不存在的类方法"></a>调用不存在的类方法</h3><p>Student调用一个不存在的类方法流程</p><ol><li>通过isa指针找到类对象</li><li>类对象的isa指针找到meta-class对象</li><li>meta-class找不到该类方法，通过superclass指针找到父类的meta-class对象</li><li>一直找，直到找到基类的meta-class对象，基类的meta-class的superclass指向基类的class对象</li><li>基类的class对象里面有对象方法，如果对象方法刚好跟准备调用的类方法同名，那么则会调用该对象方法，如果找不到，则开始抛出异常</li></ol><h2 id="ISA-MASK"><a href="#ISA-MASK" class="headerlink" title="ISA_MASK"></a>ISA_MASK</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if __arm64___</span><br><span class="line">#define ISA_MASK 0x000000ffffffff8ULL</span><br><span class="line">#elif __x86_64__</span><br><span class="line">#define  ISA_MASK 0x00007ffffffffff8ULL</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>实例对象从64位系统开始，isa不直接指向类对象的地址，isa需要进行一次位运算，才能计算出真实地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instance的 isa &amp; ISA_MASK -&gt; class对象</span><br><span class="line">class的isa &amp; ISA_MASK -&gt; meta_class 对象</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲的是实例对象(instance)，类对象(class)，元类对象（meta-class）的内容和他们之间的联系&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- NSObject</title>
    <link href="https://www.arclin.cn/post/70f61b87.html"/>
    <id>https://www.arclin.cn/post/70f61b87.html</id>
    <published>2021-05-25T14:34:00.000Z</published>
    <updated>2021-06-06T18:52:24.963Z</updated>
    
    <content type="html"><![CDATA[<p>本文只是作为iOS底层原理课程的笔记用，所以均为结论性内容，如有疑问可在评论区进行探讨。</p><span id="more"></span><h2 id="NSObject的本质"><a href="#NSObject的本质" class="headerlink" title="NSObject的本质"></a>NSObject的本质</h2><h3 id="一个NSObject对象占用16个字节。"><a href="#一个NSObject对象占用16个字节。" class="headerlink" title="一个NSObject对象占用16个字节。"></a>一个NSObject对象占用16个字节。</h3><p>验证方法</p><ol><li><p>初始化一个<code>NSObject</code>对象<br> <code>NSObject *obj = [[NSObject alloc] init];</code></p></li><li><p>打印内存分配的量，得到16字节<br> <code>malloc_size((__bridge const void *)obj)</code> </p></li><li><p>但是实际上只使用了8个字节，因为使用<code>class_getInstanceSize([NSObject class])</code>得到8</p></li></ol><p><code>class_getInstanceSize</code>计算出了NSObject对象内的成员变量（即isa）的占用内存大小</p><h3 id="NSObject实质上是一个结构体对象"><a href="#NSObject实质上是一个结构体对象" class="headerlink" title="NSObject实质上是一个结构体对象"></a>NSObject实质上是一个结构体对象</h3><p>大概长这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为成员变量isa永远是对象（NSObject的子类对象）的第一个成员变量，所以对象的地址就是成员变量isa的地址</p><h3 id="NSObject的子类"><a href="#NSObject的子类" class="headerlink" title="NSObject的子类"></a>NSObject的子类</h3><p>比如有这么一个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface Student : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">    int _no;</span><br><span class="line">    int _age;</span><br><span class="line">    int _height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student *stu &#x3D; [[Student alloc] init];</span><br></pre></td></tr></table></figure><p><code>class_getInstanceSize([Student class])</code> 得到 24（意思为这个类至少需要的内存）<br><code>malloc_size((__bridge const void *)stu)</code> 得到32（意思为系统分配给这个类的内存）</p><p>一般情况下我们更关心<code>malloc_size</code>得到的值</p><p>因为继承自<code>NSObject</code>，所以<code>Student</code>有一个<code>Class isa</code>属性，占用8个字节，<code>_no</code>、<code>_age</code>、<code>_height</code> 各占用4个字节，一共占用20个字节，</p><p>因为内存分配原则为<strong>最大成员所占内存</strong>（目前是isa 最大）的倍数，所以给够24个，这个叫做字节对齐</p><p>因为 <code>isa</code>、<code>_no</code>、<code>_age</code> 刚好够 16个字节了，这时候突然又来多了个<code>_height</code>，这时候就需要20个字节了 , 那么为了适配各个厂商的内存读取规则，又给他分配了16个（凑16的倍数），这个叫做内存对齐，所以一共给类分配了 32个字节</p><p>注：int 占用4个字节 double占用8个字节</p><p>分配原则：如果内存一行(16个字节)放不下，那么就直接开新的一行<br>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_no : Int </span><br><span class="line">_age : Double</span><br><span class="line">_height : Int</span><br></pre></td></tr></table></figure><p>第一行：<code>isa</code> :8个，<code>_no</code> 4个，第一行剩下4个字节的位置，不够放<code>_age</code>,但是够放<code>_height</code>，那就直接放<code>_height</code>，如果这时候<code>_height</code>是<code>Double</code>的话，没别的东西来占用这4个位置，那么就直接放弃，开辟下一行<br>第二行：前八个位置直接给<code>_age</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x108b0bb00: d1 81 00 00 01 80 1d 01  &lt;- isa   04 00 00 00 &lt;- age   00 00 00 00  &lt;- height ................</span><br><span class="line">0x108b0bb10: 00 00 00 00 00 00 00 00  &lt;- age 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure><h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h3><p>__sizeof()__方法是一个运算符，在编译期间就确定值，类似于宏替换，他的作用是计算传入的对象占用的内存的大小，如果传入的是类型（或者类名）的话，就计算类型占用的大小，比如传入一个对象的话，就是计算指向这个对象的指针的大小，指针占用的内存大小是8个字节，跟<code>class_getInstanceSize</code>的区别是<code>class_getInstanceSize</code>是计算类实例化后占用的大小。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文只是作为iOS底层原理课程的笔记用，所以均为结论性内容，如有疑问可在评论区进行探讨。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS动态加载字体</title>
    <link href="https://www.arclin.cn/post/f82939c6.html"/>
    <id>https://www.arclin.cn/post/f82939c6.html</id>
    <published>2021-03-17T02:42:42.000Z</published>
    <updated>2021-06-06T18:52:24.965Z</updated>
    
    <content type="html"><![CDATA[<p>当你某个在开发某个SDK时需要使用到特殊字体，因为无法修改应用的info.plist，所以这时候我们需要采用动态注册字体的方式加载字体，方法如下</p><span id="more"></span><ul><li><p>OC</p><p>  方法调用</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[UIFont fontWithName:&lt;#(nonnull NSString *)#&gt; size:&lt;#(CGFloat)#&gt;]</span><br></pre></td></tr></table></figure><p>  如果上述方法返回nil,则你需要注册你的字体</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> NSBundle *bundle &#x3D; [NSBundle bundleForClass:[self class]];</span><br><span class="line">NSURL *fontURL &#x3D; [bundle URLForResource:&lt;#fontName#&gt; withExtension:@&quot;otf&quot;&#x2F;*or TTF*&#x2F;];</span><br><span class="line">NSData *inData &#x3D; [NSData dataWithContentsOfURL:fontURL];</span><br><span class="line">CFErrorRef error;</span><br><span class="line">CGDataProviderRef provider &#x3D; CGDataProviderCreateWithCFData((CFDataRef)inData);</span><br><span class="line">CGFontRef font &#x3D; CGFontCreateWithDataProvider(provider);</span><br><span class="line">if (!CTFontManagerRegisterGraphicsFont(font, &amp;error)) &#123;</span><br><span class="line">CFStringRef errorDescription &#x3D; CFErrorCopyDescription(error);</span><br><span class="line">NSLog(@&quot;Failed to load font: %@&quot;, errorDescription);</span><br><span class="line">CFRelease(errorDescription);</span><br><span class="line">&#125;</span><br><span class="line">CFSafeRelease(font);</span><br><span class="line">CFSafeRelease(provider);</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void CFSafeRelease(CFTypeRef cf) &#123;</span><br><span class="line">if (cf !&#x3D; NULL) &#123;</span><br><span class="line">CFRelease(cf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Swift</p><p>  方法调用</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIFont.customFont(name:&quot;xxx&quot; size: 12)</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">extension UIFont &#123;</span><br><span class="line">    static func customFont(fontName:String, size: CGFloat) -&gt; UIFont &#123;</span><br><span class="line">        if let font &#x3D; UIFont(name: fontName, size: size) &#123;</span><br><span class="line">            return font</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            _ &#x3D; self.registerFont(bundle: Bundle.init(for: XXXX.self), fontName: fontName, fontExtension: &quot;otf&quot;) &#x2F;&#x2F; 也可以写ttf,看具体格式</span><br><span class="line">            if let newFont &#x3D; UIFont(name: fontName, size: size) &#123;</span><br><span class="line">                return newFont</span><br><span class="line">            &#125;</span><br><span class="line">            return UIFont.customFont(ofSize: size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static func registerFont(bundle: Bundle, fontName: String, fontExtension: String) -&gt; Bool &#123;</span><br><span class="line">        guard let fontURL &#x3D; bundle.url(forResource: fontName, withExtension: fontExtension) else &#123;</span><br><span class="line">            fatalError(&quot;Couldn&#39;t find font \(fontName)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        guard let fontDataProvider &#x3D; CGDataProvider(url: fontURL as CFURL) else &#123;</span><br><span class="line">            fatalError(&quot;Couldn&#39;t load data from the font \(fontName)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        guard let font &#x3D; CGFont(fontDataProvider) else &#123;</span><br><span class="line">            fatalError(&quot;Couldn&#39;t create font from data&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        var error: Unmanaged&lt;CFError&gt;?</span><br><span class="line">        let success &#x3D; CTFontManagerRegisterGraphicsFont(font, &amp;error)</span><br><span class="line">        guard success else &#123;</span><br><span class="line">            print(&quot;Error registering font: maybe it was already registered.&quot;)</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>参考资料：<br>    <a href="https://stackoverflow.com/questions/12919513/how-do-i-add-a-custom-font-to-a-cocoapod">https://stackoverflow.com/questions/12919513/how-do-i-add-a-custom-font-to-a-cocoapod</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当你某个在开发某个SDK时需要使用到特殊字体，因为无法修改应用的info.plist，所以这时候我们需要采用动态注册字体的方式加载字体，方法如下&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 14 App Clips</title>
    <link href="https://www.arclin.cn/post/a44df9c3.html"/>
    <id>https://www.arclin.cn/post/a44df9c3.html</id>
    <published>2020-11-25T02:08:18.000Z</published>
    <updated>2021-06-06T18:52:24.965Z</updated>
    
    <content type="html"><![CDATA[<p>本文将主要探讨App Clips开发流程 和 组件化、非组件化两种开发方式下如何复用代码的问题。</p><span id="more"></span><p>App Clips是iOS14系统的新特性之一，类似于小程序，用户可以在不下载App的情况下体验到App的部分功能，如网易严选的商品详情功能（<a href="https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw">https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw</a>），该功能适合做一些推广和引流的运营工作，另外苹果也提供的原生的浮窗样式，可以引导用户下载完整版App。</p><p>苹果官方文档：<a href="https://developer.apple.com/app-clips/">https://developer.apple.com/app-clips/</a></p><h3 id="目前已知的触发方式"><a href="#目前已知的触发方式" class="headerlink" title="目前已知的触发方式"></a>目前已知的触发方式</h3><ul><li><p>二维码</p><p>  必须使用iOS 14系统相机或者使用控制中心的读取二维码组件来扫码才能触发App Clips。</p></li><li><p>NFC Tags</p><p>  NFC标签感应，比如星巴克桌面内嵌的NFC Tags。</p></li><li><p>Safari App Banner</p><p>  当用户用iOS的Safari浏览器浏览相应的网址后，页面顶部会出现一个横幅，提示用户有App Clips可以用。</p></li><li><p>信息</p><p>  iOS系统自带的iMessage，当你在iMessage发送一个App Clips链接时，系统会自动把信息显示成一个App Clips的卡片。</p></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a13d29c7a17d471dbc551c416ce2ed57~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="开发前置工作"><a href="#开发前置工作" class="headerlink" title="开发前置工作"></a>开发前置工作</h3><h4 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h4><h5 id="创建App-Clips-ID"><a href="#创建App-Clips-ID" class="headerlink" title="创建App Clips ID"></a>创建App Clips ID</h5><ol><li>点击新增APP ID</li></ol><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d62145df226549428f600ace6f1b44cb~tplv-k3u1fbpfcp-zoom-1.image" ><ol start="2"><li>选择App Clip <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f93a07c34f7249b982f0cbca84bfcafe~tplv-k3u1fbpfcp-zoom-1.image" ><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da0c96044db46bb897aab6f71543c8d~tplv-k3u1fbpfcp-zoom-1.image" ></li></ol><ol start="3"><li>输入一串英文名，用于拼接在主工程的bundle id的后面，生成该clip的bundle id <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2ae0fb422f149d98589f36c80123315~tplv-k3u1fbpfcp-zoom-1.image" > </li><li>在Description内输入描述（不能使用特殊符号），并且在下方勾选App Clip能力，比如Apple Pay，Sign in with Apple，Push等等，<strong>Associated Domains必须勾选</strong><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33e78440190242efaa8dac9b47004393~tplv-k3u1fbpfcp-zoom-1.image" > </li><li>最后确认并点击右上方Register即可</li></ol><h5 id="创建Profiles"><a href="#创建Profiles" class="headerlink" title="创建Profiles"></a>创建Profiles</h5><p>流程跟创建App的Profiles一样，就是选择bundle id的时候改成Clip的bundle id 即可，同样有Development、AdHoc、Distribution三种类型</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68bfe6ee218047b7a3232058dcc2e006~tplv-k3u1fbpfcp-zoom-1.image" ><h5 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h5><p>如果需要其他NFC、地点等等的一些方式触发App Clip配置的话，参考这个苹果的文档<a href="https://help.apple.com/app-store-connect/#/dev5b665db74">https://help.apple.com/app-store-connect/#/dev5b665db74</a></p><h4 id="Apple-Store-Connect-配置图片和标题，描述"><a href="#Apple-Store-Connect-配置图片和标题，描述" class="headerlink" title="Apple Store Connect 配置图片和标题，描述"></a>Apple Store Connect 配置图片和标题，描述</h4><ol><li>需要一张1800 * 1200 的图片，用于显示在Clip的卡片上</li><li>副标题用于显示在卡片标题下的小字，如图所示<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b3e18f56f6d49219fc46f77dab1cef2~tplv-k3u1fbpfcp-zoom-1.image" width=30%></li><li>操作包括“打开”“查看”“开始游戏”，体现在卡片右边的蓝色按钮内的文案，根据你的产品类型进行选择就好</li></ol><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c14c35967084886bc3f4fce6e985fcb~tplv-k3u1fbpfcp-zoom-1.image" ><h4 id="配置apple-app-site-association-json"><a href="#配置apple-app-site-association-json" class="headerlink" title="配置apple-app-site-association.json"></a>配置apple-app-site-association.json</h4><p>假设你的开发者账号的Team Id是<code>A123</code>，Clips的bundle id是<code>com.abc.def.clips</code>，主工程的bundle id 是<code>com.abc.def</code>，则配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;appclips&quot;:&#123;</span><br><span class="line">        &quot;apps&quot;:[&quot;A123.com.abc.def.clips&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;applinks&quot;:&#123;</span><br><span class="line">        &quot;apps&quot;:[</span><br><span class="line">        ],</span><br><span class="line">        &quot;details&quot;:&#123;</span><br><span class="line">            &quot;A123.com.abc.def&quot;:&#123;</span><br><span class="line">                &quot;paths&quot;:[</span><br><span class="line">                    &quot;*&quot; &#x2F;&#x2F; 这里的Path根据实际情况配置即可</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;webcredentials&quot;:&#123;</span><br><span class="line">        &quot;apps&quot;:[</span><br><span class="line">            &quot;A123.com.abc.def&quot;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;activitycontinuation&quot;:&#123;</span><br><span class="line">        &quot;apps&quot;:[</span><br><span class="line">            &quot;A123.com.abc.def&quot;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后部署到你自己域名的根目录下，配置方法网上很多教程，这里贴上<a href="https://developer.apple.com/documentation/safariservices/supporting_associated_domains?language=objc">苹果官方文档</a></p><p>如果配置错了，那么上传包到苹果后台之后，就会显示无效域名<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05ddb4d106a349d28c1504762697a9eb~tplv-k3u1fbpfcp-zoom-1.image"></p><p>如果是json配置错误，那么配置正确后不用重新传包，等待苹果那边刷新缓存就好。</p><p>App Clip支持最多在三个域名的网页显示入口，到后面的工程配置那里会说明。</p><h4 id="前端页面添加meta标签"><a href="#前端页面添加meta标签" class="headerlink" title="前端页面添加meta标签"></a>前端页面添加meta标签</h4><p>如果要在H5页面显示Clips入口，加上一段meta标签即可</p><p>如果你的应用市场App id是 <code>123456</code>, Clips的bundle id 是 <code>com.abc.clips</code> 则应该配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;apple-itunes-app&quot; content&#x3D;&quot;app-id&#x3D;123456,app-clip-bundle-id&#x3D;com.abc.clips&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="开发工作"><a href="#开发工作" class="headerlink" title="开发工作"></a>开发工作</h3><h4 id="新建App-Clip-Target"><a href="#新建App-Clip-Target" class="headerlink" title="新建App Clip Target"></a>新建App Clip Target</h4><p>这里以OC工程为例</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9edc6108c0b64885b708ef5c9de8e1d0~tplv-k3u1fbpfcp-zoom-1.image" ><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa5c9c1032174d77a4db0518029b78dd~tplv-k3u1fbpfcp-zoom-1.image" ><h4 id="配置证书和Associated-Domains"><a href="#配置证书和Associated-Domains" class="headerlink" title="配置证书和Associated Domains"></a>配置证书和Associated Domains</h4><p>用刚才生成的证书去配置一下即可</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fbccb4eee1445ca9b680200358535e0~tplv-k3u1fbpfcp-zoom-1.image" ><p>添加Associated Domains，目的是打开对应域名网页后，页面上方能够出现Clip的入口。</p><p><strong>这里可以添加多个域名，注意每个域名都需要配置apple-app-site-association！！！</strong></p><p><strong>主工程的Target和Clip的Target都需要配置！！！</strong></p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5125ca96f15433b8205294e48906e13~tplv-k3u1fbpfcp-zoom-1.image" ><h4 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h4><p>创建完之后就会生成一个文件夹，里面就是我们熟悉的AppDelegate、SecneDelegate、Main.storyboard、Info.plist等文件，如果你不使用Storyboard进行界面搭建，那么也是跟之前的开发模式一样，删除info.plist内Application Scene Manifest，修改General-Deployment info - Main interface 为空，修改AppDelegate.m，在里面创建根控制器。</p><p>之后的操作就跟普通开发一样了，调试的话可以直接在Xcode上左上角选择Clip的target，然后就可以跑起来了。</p><p>另外，AppIcon是需要独立配置的，同样也是在Clip项目工程文件夹内Assets.xcassets。</p><h5 id="非组件化开发模式"><a href="#非组件化开发模式" class="headerlink" title="非组件化开发模式"></a>非组件化开发模式</h5><p>一般情况下我们是需要复用代码的，将代码内某些模块功能进行复用，然后直接用在Clip，这时候我们只需要在右侧Target Membership勾选新建的Clip Target即可。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2847eb910740229f410d0aa29f7bb5~tplv-k3u1fbpfcp-zoom-1.image" width=30%><p>同样的 相关的依赖到的文件也需要勾选Clip Target</p><h5 id="组件化开发模式-和-Podfile的配置"><a href="#组件化开发模式-和-Podfile的配置" class="headerlink" title="组件化开发模式 和 Podfile的配置"></a>组件化开发模式 和 Podfile的配置</h5><p>如果是在组件化开发模式下，那么就需要配置Podfile</p><p>在Podfile 底部新增代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class="line"># 你的私有pod仓库</span><br><span class="line">source &#39;https:&#x2F;&#x2F;git.xxx.com&#x2F;yourprivatepodspec&#x2F;Podspec.git&#39;</span><br><span class="line"></span><br><span class="line">target &#39;YourApp’ do</span><br><span class="line">    platform :ios, &#39;10.3&#39;</span><br><span class="line">    pod &quot;AFNetworking&quot;</span><br><span class="line">    pod &quot;SDWebImage&quot;</span><br><span class="line">    # 等等</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#39;YourApp_Clips&#39; do</span><br><span class="line">    platform :ios, &#39;10.3&#39;</span><br><span class="line">    pod &#39;ComponentA&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class="line">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class="line">    pod &quot;AFNetworking&quot;</span><br><span class="line">    pod &quot;SDWebImage&quot;</span><br><span class="line">    # 等等</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这样子相同的第三方pod会写两遍，所以我们可以优化成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class="line"># 你的私有pod仓库</span><br><span class="line">source &#39;https:&#x2F;&#x2F;git.xxx.com&#x2F;yourprivatepodspec&#x2F;Podspec.git&#39;</span><br><span class="line"></span><br><span class="line">def common_pods</span><br><span class="line">    pod &quot;AFNetworking&quot;</span><br><span class="line">    pod &quot;SDWebImage&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#39;YourApp’ do</span><br><span class="line">    platform :ios, &#39;10.3&#39;</span><br><span class="line">    common_pods</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#39;YourApp_Clips&#39; do</span><br><span class="line">    platform :ios, &#39;14.0&#39;</span><br><span class="line">    pod &#39;ComponentA&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class="line">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class="line">    common_pods</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="抽离模块时不同环境的代码复用问题"><a href="#抽离模块时不同环境的代码复用问题" class="headerlink" title="抽离模块时不同环境的代码复用问题"></a>抽离模块时不同环境的代码复用问题</h5><p>假如说A功能需要抽离出来放到Clip，但是A模块里面有需求是会跳转到B模块的，但是我并不希望Clip引入B模块，希望他能在这个地方提示用户下载完整App，那应该怎么做呢？</p><p>首先第一个事情，苹果提供了一个Api可以引导弹窗引导用户下载APP</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fec69fde9e64618819b1b526034d23b~tplv-k3u1fbpfcp-zoom-1.image" width=40%><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UIWindowScene *scene &#x3D; (UIWindowScene *)[[UIApplication sharedApplication].connectedScenes.allObjects firstObject];</span><br><span class="line">SKOverlayAppConfiguration *config &#x3D; [[SKOverlayAppConfiguration alloc] initWithAppIdentifier:@&quot;你的AppID&quot; position:SKOverlayPositionBottomRaised];</span><br><span class="line">SKOverlay *overlay &#x3D; [[SKOverlay alloc] initWithConfiguration:config];</span><br><span class="line">overlay.delegate &#x3D; self; &#x2F;&#x2F; 添加代理后可以监听弹窗的弹出和消失，可以在代理内添加埋点。</span><br><span class="line">[overlay presentInScene:scene];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 主动让弹窗消失</span><br><span class="line">&#x2F;&#x2F; [SKOverlay dismissOverlayInScene:scene];</span><br></pre></td></tr></table></figure><p>第二. 如何在模块内划分环境，区分是主App还是Clip</p><p>方法一：设计一个单例，添加一个枚举属性，分别在<code>主工程</code>的AppDelegate和<code>Clip</code>的AppDelegate内给单例的属性赋值，标记当前环境。然后在业务代码中获取单例的环境属性后进行判断。</p><p>方法二：有时候我们在Clip复用的模块代码内不需要import某些头文件，因为我们不需要这个功能，这时候单例的方法就不管用了，我们需要通过宏去判断。</p><p>如果代码不在pod组件内的话，只需要在Clip Target的<code>Build Settings</code> - <code>Preprocessor Macros</code>添加<code>APP_CLIPS</code>宏即可。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7708c16f9c4247a9ab9ec393d01420b1~tplv-k3u1fbpfcp-zoom-1.image" ><p>如果是组件化的开发模式，代码在pod内部，那么就稍微有点麻烦，需要在对应podspec新增一个subspec，专门提供给clip使用，然后配置上宏定义</p><p><code>ComponentA.podspec</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s.subspec &quot;App&quot; do |ss|</span><br><span class="line">    ss.source_files &#x3D; &quot;xxxxxx&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &quot;AppClip&quot; do |ss|</span><br><span class="line">    ss.source_files &#x3D; &quot;xxxxxx&quot;</span><br><span class="line">    ss.pod_target_xcconfig &#x3D; &#123; &#39;GCC_PREPROCESSOR_DEFINITIONS&#39; &#x3D;&gt; &#39;APP_CLIPS&#x3D;1&#39;&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>这里为什么要弄多一个App的subspec，因为如果主工程直接<code>pod ComponentA</code>的话，所有的subspec都会被引入，所以这里为了区分开，就加多了一个专门给主工程用的subspec</p></blockquote><p><code>Podfile</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def common_pods</span><br><span class="line">    pod &quot;AFNetworking&quot;</span><br><span class="line">    pod &quot;SDWebImage&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#39;YourApp’ do</span><br><span class="line">    platform :ios, &#39;10.3&#39;</span><br><span class="line">    common_pods</span><br><span class="line">    pod &#39;ComponentA&#x2F;App&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#39;YourApp_Clips&#39; do</span><br><span class="line">    platform :ios, &#39;14.0&#39;</span><br><span class="line">    pod &#39;ComponentA&#x2F;AppClip&#39;,   :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class="line">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class="line">    common_pods</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>通过以上方法，就可以用如下方式进行宏判断，区分当前环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef APP_CLIPS</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="测试工作"><a href="#测试工作" class="headerlink" title="测试工作"></a>测试工作</h3><h4 id="开发调试"><a href="#开发调试" class="headerlink" title="开发调试"></a>开发调试</h4><ul><li><p>可以选择Clip Target直接使用Xcode编译运行</p></li><li><p>可以使用真机扫描二维码，调起Clip卡片，但是前提是Clip要先在真机跑一遍。</p><ol><li>手机点击<code>设置-开发者-Local Experiences-Register Local Experience</code></li><li>输入域名、Clip的bundle id、标题、子标题，选择按钮标题、选择Clip弹出的卡片上的图片，然后点击存储即可。</li><li>将刚才输入的域名，去草料二维码等二维码生成网站生成一个二维码，然后手机相机扫描即可弹出卡片样式。</li><li>具体内容可以参考<a href="https://developer.apple.com/documentation/app_clips/testing_your_app_clip_s_launch_experience?language=objc">官方文档</a></li></ol></li></ul><h4 id="外部测试"><a href="#外部测试" class="headerlink" title="外部测试"></a>外部测试</h4><ol><li>可以通过Archive打Release环境的包（Debug状态下没有选择导出Clip ipa的选项，不知道是哪里配置问题，如果有知道的小伙伴可以评论区分享一下），然后单独导出Clip的ipa，上传到蒲公英或者Fir等分发平台，测试同事就可以下载安装测试了。</li><li>如果已经传到了TestFlight，那么也可以在TestFlight上直接点击打开小程序进行测试。</li></ol><h3 id="苹果官方提及的产品要求"><a href="#苹果官方提及的产品要求" class="headerlink" title="苹果官方提及的产品要求"></a>苹果官方提及的产品要求</h3><p>原文：<a href="https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/">https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/</a></p><p>划重点：</p><ol><li><p>请勿仅将App Clip用作营销用途，不能显示广告。</p></li><li><p>避免登录，避免不了的话尽可能使用Apple id登录</p></li><li><p>Clips启动后只有在8小时内才能接收推送</p></li></ol><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol><li><p>苹果文档说的App Clips 10M限制指的是哪个文件的10M</p><p> 经过测试后发现，应该是Release环境下Archive后，导出的Clips的ipa的大小，如果有误欢迎评论区指正。</p></li><li><p>Clips可以有登录功能吗？</p><p> 可以，但是苹果希望用户能不登录就使用App，如果要登录也首选Sign in with Apple登录的方式(iOS13特性)，但是我们可以学网易严选那样子苹果ID登录之后再弹出手机验证码绑定功能。</p></li><li><p>可以有内购吗？</p><p> 可以。</p></li><li><p>用户使用完Clips后，如果想再次进入，入口在哪儿？</p><p> 假如是网页打开的Clips，那么离开网页后，在桌面的”资源库”里可以找到这个Clips并重新打开。如果找不到就搜索资源库，总能搜到的。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将主要探讨App Clips开发流程 和 组件化、非组件化两种开发方式下如何复用代码的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="feature" scheme="https://www.arclin.cn/tags/feature/"/>
    
  </entry>
  
  <entry>
    <title>iOS 14新API</title>
    <link href="https://www.arclin.cn/post/36f1cd4f.html"/>
    <id>https://www.arclin.cn/post/36f1cd4f.html</id>
    <published>2020-06-29T03:08:18.000Z</published>
    <updated>2021-06-06T18:52:24.965Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 14 新API</p><span id="more"></span><h3 id="Control-Appearance-update"><a href="#Control-Appearance-update" class="headerlink" title="Control Appearance update"></a>Control Appearance update</h3><p>控件外观更新，比如UISlider、 UIProgressView、UIActivityIndicatorView，长得稍微有点不一样，不影响适配。</p><p><img src="https://s1.ax1x.com/2020/06/29/NfJ6zt.png"></p><p>UIPageControl样式改变并且可以自定义icon</p><p><img src="https://s1.ax1x.com/2020/06/29/NfYs7F.png"></p><p>自定义小心心icon和书签icon</p><p><img src="https://s1.ax1x.com/2020/06/29/NfYO1I.png"></p><h3 id="Color-Picker"><a href="#Color-Picker" class="headerlink" title="Color Picker"></a>Color Picker</h3><p>新增颜色选择器<code>UIColorPickerViewController</code></p><p>支持取色器 收藏常用颜色等等</p><p>可以配置是否支持调整透明度等等，具体配置项目参考api文档</p><p>建议Present弹出</p><p><a href="https://sm.ms/image/iz1WnGFImlUvkty" target="_blank"><img src="https://i.loli.net/2020/06/29/iz1WnGFImlUvkty.png" width=50% ></a></p><h3 id="Date-Picker"><a href="#Date-Picker" class="headerlink" title="Date Picker"></a>Date Picker</h3><p>UIDatePicker更新UI</p><p>两种样式</p><p>支持农历</p><p><a href="https://sm.ms/image/wMmTIykghRNqWQn" target="_blank"><img src="https://i.loli.net/2020/06/29/wMmTIykghRNqWQn.png" width=50% ></a></p><p><a href="https://sm.ms/image/uF3WonxPAsDyXaO" target="_blank"><img src="https://i.loli.net/2020/06/29/uF3WonxPAsDyXaO.png" width=50% ></a></p><h3 id="Menus"><a href="#Menus" class="headerlink" title="Menus"></a>Menus</h3><p>貌似可以替代我们常有的角标弹窗列表按钮需求</p><p>基于<code>UIButton</code>和<code>UIBarButtonItem</code>的新增的<code>menu</code>属性，可以配置长按或者单击(配置 <code>button.showsMenuAsPrimaryAction = true</code>)弹出菜单列表</p><p><a href="https://sm.ms/image/L1XmoD2d7EKj49Y" target="_blank"><img src="https://i.loli.net/2020/06/29/L1XmoD2d7EKj49Y.png" width=50% ></a></p><p><a href="https://sm.ms/image/ZflMaksQFDuKp3T" target="_blank"><img src="https://i.loli.net/2020/06/29/ZflMaksQFDuKp3T.png" width=50% ></a></p><p>UINavigationBar 的原生返回按钮长按会弹出菜单，可以跳回导航栏栈中的任意一个页面，按钮标题为前面控制器的标题</p><p><a href="https://sm.ms/image/FVdgXvpGeTBfYKZ" target="_blank"><img src="https://i.loli.net/2020/06/29/FVdgXvpGeTBfYKZ.png" width=50% ></a></p><p>更新弹出菜单内容，将会实时更新并自带系统动画：</p><p><code>updateVisibleMenu(_ block: (UIMenu) -&gt; UIMenu)</code></p><h3 id="UIActions"><a href="#UIActions" class="headerlink" title="UIActions"></a>UIActions</h3><p>UIBarButtonItem 新增 fixedSpace(width:) 和 flexibleSpace方法 去调节item之间的间隔，不用像之前那样子创建一个fixedSpace类型的UIBarButtonItem去占位</p><p>UIButton新增了一个初始化方法init(type:primaryAction:) type默认为.system 标题为primaryAction.title ，图片为 primaryAction.image</p><h3 id="WidgetKit"><a href="#WidgetKit" class="headerlink" title="WidgetKit"></a>WidgetKit</h3><p>iOS14 重大新特性之一 支持三种宽度的widget，具体内容另外开篇再讲<br><a href="https://sm.ms/image/eiXyvjhfgAqQURr" target="_blank"><img src="https://i.loli.net/2020/06/29/eiXyvjhfgAqQURr.png" width=50% ></a></p><h3 id="让你的app支持物理键盘"><a href="#让你的app支持物理键盘" class="headerlink" title="让你的app支持物理键盘"></a>让你的app支持物理键盘</h3><p><a href="https://developer.apple.com/documentation/uikit/keyboards_and_input/adding_hardware_keyboard_support_to_your_app">具体内容查看文档</a></p><h3 id="Asynchronously-Loading-Images-into-Table-and-Collection-Views"><a href="#Asynchronously-Loading-Images-into-Table-and-Collection-Views" class="headerlink" title="Asynchronously Loading Images into Table and Collection Views"></a>Asynchronously Loading Images into Table and Collection Views</h3><p><a href="https://developer.apple.com/documentation/uikit/uiimage/asynchronously_loading_images_into_table_and_collection_views">文档</a></p><p>tableView和CollectionView异步加载网络图片的API</p><h3 id="PHPicker-图片选择器"><a href="#PHPicker-图片选择器" class="headerlink" title="PHPicker 图片选择器"></a>PHPicker 图片选择器</h3><p>新的图片选择器，支持多选，不需要用户允许相册访问权限，可以选择图片（包括livePhoto）和视频</p><p><a href="https://sm.ms/image/R9fc3SZIlpLhuwB" target="_blank"><img src="https://i.loli.net/2020/06/29/R9fc3SZIlpLhuwB.png" width=50% ></a></p><h3 id="定位权限更新"><a href="#定位权限更新" class="headerlink" title="定位权限更新"></a>定位权限更新</h3><p>旧的定位权限弹窗如下：</p><p><a href="https://sm.ms/image/kSgBdY3hjRWG21E" target="_blank"><img src="https://i.loli.net/2020/06/29/kSgBdY3hjRWG21E.png" width=50% ></a></p><p>新的定位权限弹窗如下：</p><p><a href="https://sm.ms/image/svo9OnAS1BZdLDP" target="_blank"><img src="https://i.loli.net/2020/06/29/svo9OnAS1BZdLDP.png" width=50% ></a></p><p>多了个小地图，并且小地图的左上角多了个按钮，点击选择是否允许准确定位。</p><p>若不允许的话，开发者获取的定位会变成一个±5公里的范围，并且只能持续定位最多20分钟</p><p>通过一个枚举值得知是否用户选择了模糊定位：</p><p><a href="https://sm.ms/image/9gh6mbKL7VWe3uH" target="_blank"><img src="https://i.loli.net/2020/06/29/9gh6mbKL7VWe3uH.png" ></a></p><p>用户可以改变设置，是否允许app获取准确定位</p><p><a href="https://sm.ms/image/jsQr4xoevXNa2Ju" target="_blank"><img src="https://i.loli.net/2020/06/29/jsQr4xoevXNa2Ju.png" ></a></p><p>开发者可以通过在<code>info.plist</code>里面配置信息解释为何需要用户选择准确定位</p><p><a href="https://sm.ms/image/X5CRUopcnOHG3I2" target="_blank"><img src="https://i.loli.net/2020/06/29/X5CRUopcnOHG3I2.png" ></a></p><p>让隐私弹窗默认选择模糊定位</p><p><a href="https://sm.ms/image/UeLtJhGXOvbKmns" target="_blank"><img src="https://i.loli.net/2020/06/29/UeLtJhGXOvbKmns.png" width=50%></a></p><h3 id="UICollectionView重大更新"><a href="#UICollectionView重大更新" class="headerlink" title="UICollectionView重大更新"></a>UICollectionView重大更新</h3><p>UICollection从数据源协议到Cell都有了新的API，开发者可以为cell添加各种“附件”，已适配复杂的列表样式，如下第二张图，另外可以在collectionView上使用类似tableView的样式，如下图</p><p><a href="https://sm.ms/image/Iaho8TuHE1P4iRx" target="_blank"><img src="https://i.loli.net/2020/06/30/Iaho8TuHE1P4iRx.png" ></a></p><p><a href="https://sm.ms/image/taEDOVHfAk2LnQe" target="_blank"><img src="https://i.loli.net/2020/06/30/taEDOVHfAk2LnQe.png"  width=50% ></a></p><p>通过新的配置类，可以做成如下效果</p><p><a href="https://sm.ms/image/nlrR8VBkzqy2SdP" target="_blank"><img src="https://i.loli.net/2020/06/30/nlrR8VBkzqy2SdP.png"  width=50% ></a></p><p><a href="https://sm.ms/image/PhtUgJrCR2OTQwY" target="_blank"><img src="https://i.loli.net/2020/06/30/PhtUgJrCR2OTQwY.png"  width=50% ></a></p><p>新增一个UICollectionListViewCell，可以做出如下样式的cell</p><p><a href="https://sm.ms/image/jlZKFpCybNJPoET" target="_blank"><img src="https://i.loli.net/2020/06/30/jlZKFpCybNJPoET.png" width=50%  ></a></p><p>Cell的注册方式也有所改变，可以看出苹果从API层面已经进入MVVM架构模式了，注册cell需要带上对应的CellViewModel</p><p><a href="https://sm.ms/image/2awdL6yOmUzIGrZ" target="_blank"><img src="https://i.loli.net/2020/06/30/2awdL6yOmUzIGrZ.jpg" width=50% ></a></p><p>另外也支持像UITableViewCell的侧滑操作等等，详细内容将会另外开篇讲述。</p><p>具体查看<a href="https://developer.apple.com/videos/play/wwdc2020/10097/">视频</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;iOS 14 新API&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="feature" scheme="https://www.arclin.cn/tags/feature/"/>
    
  </entry>
  
  <entry>
    <title>依赖注入与Objection</title>
    <link href="https://www.arclin.cn/post/6ae5f77f.html"/>
    <id>https://www.arclin.cn/post/6ae5f77f.html</id>
    <published>2020-05-01T02:44:01.000Z</published>
    <updated>2021-06-06T18:52:24.970Z</updated>
    
    <content type="html"><![CDATA[<p>本文会说明iOS内依赖注入的概念和依赖注入框架Objection的一般使用</p><span id="more"></span><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>首先先说明什么叫做依赖注入</p><p>比如AController跳转到BController,那么这时候BController就需要在AController内部进行实例化，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@implementation AController : UIViewController</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (void)jump </span><br><span class="line">&#123;</span><br><span class="line">BController *bController &#x3D; [[BController alloc] init];</span><br><span class="line">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这么做的话，当AController被封装成组件之后，BController的配置将会被限制，外部无法改变BController任何细节，所以我们 ** 稍 加 改 进 **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@implementation AController : UIViewController</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCreateBlock:(UIViewController *(^)(void))createBViewControllerBlock &#123;</span><br><span class="line">....</span><br><span class="line">self.createBViewControllerBlock &#x3D; createBViewControllerBlock;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jump </span><br><span class="line">&#123;</span><br><span class="line">UIViewController *bController &#x3D; self.createBViewControllerBlock();</span><br><span class="line">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[AController alloc] initWithCreateBlock:UIViewController* ^&#123;</span><br><span class="line">BController *bController &#x3D; [[BController alloc] initWithTitle:@&quot;xxx&quot;];</span><br><span class="line">return bController;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>将BController的创建通过Block暴露出来，AController内部不关心BController是如何被创建的，那么AController对BController的依赖将通过外部的Block进行注入。</p><p>这，就是依赖注入。</p><p>当然这是最简单的依赖注入，无法满足我们复杂的需求，所以有时候我们需要使用第三方框架，如<code>Objection</code>和<code>Typhoon</code></p><h4 id="Objection"><a href="#Objection" class="headerlink" title="Objection"></a>Objection</h4><p>接下来说明一下Objection的使用</p><p>Objection 是一个依赖注入框架，能够在你获取一个类的实例的时候，这个类内部的属性也同时会被实例化。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Car.h</span><br><span class="line"></span><br><span class="line">@class Engine,Break;</span><br><span class="line"></span><br><span class="line">@interface Car : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) Engine *engine;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) Break *breaks;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Car.m</span><br><span class="line"></span><br><span class="line">#import &lt;Objection&#x2F;Objection.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation Car</span><br><span class="line">objection_requires(@&quot;engine&quot;, @&quot;breaks&quot;)</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建一个默认注射器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSObjectionInjector *injector &#x3D; [JSObjection createInjector];</span><br><span class="line">[JSObjection setDefaultInjector:injector];</span><br></pre></td></tr></table></figure><p>实例化Car对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car *car &#x3D; [[JSObjection defaultInjector] getObject:[Car class]];</span><br></pre></td></tr></table></figure><p>这时候所依赖的<code>engine</code>对象和<code>breaks</code>对象都会通过<code>init</code>方法实例化</p><p>最后打印属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">car &lt;Car: 0x6000006d8480&gt; engine &lt;Engine: 0x6000004841b0&gt; breaks &lt;Break: 0x6000004841e0&gt;</span><br></pre></td></tr></table></figure><p>假如说Car对象不能通过<code>init</code>或者<code>initWithXXX</code>等自定义构造方法去实例化，那么我们需要指定方法，让注射器在指定的方法构建依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@implementation Car</span><br><span class="line">objection_requires(@&quot;engine&quot;, @&quot;breaks&quot;)</span><br><span class="line">- (void)awakeFromNib &#123;</span><br><span class="line">  [[JSObjection defaultInjector] injectDependencies:self];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>当Car被注射器初始化完成之后，会调用<code>- awakeFromObjection</code>方法，这里可以额外赋一些值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)awakeFromObjection </span><br><span class="line">&#123;</span><br><span class="line">self.test &#x3D; @&quot;111&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的说的都是直接init出来的对象，但是更多情况下我们需要指定构造方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation Car</span><br><span class="line">objection_initializer_sel(@selector(initWithObject:)) &#x2F;&#x2F; 该宏只需且只能出现一次</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithObject:(id)object</span><br><span class="line">&#123;</span><br><span class="line">    if (self &#x3D; [super init]) &#123;</span><br><span class="line">        self.test &#x3D; object;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>取出的时候加上<code>argumentList:</code>参数即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car *car &#x3D; [[JSObjection defaultInjector] getObject:[Car class] argumentList:@[@&quot;aaaa&quot;]];</span><br></pre></td></tr></table></figure><p>或者不想写<code>objection_initializer_sel()</code>宏的话<br>可以直接在取的方法那里改动一下变成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car *car &#x3D; [[JSObjection defaultInjector] getObject:[Car class] initializer:@selector(initWithObject:) argumentList:@[@&quot;aaaa&quot;]];</span><br></pre></td></tr></table></figure><p>效果也是一样的</p><h5 id="对象工厂"><a href="#对象工厂" class="headerlink" title="对象工厂"></a>对象工厂</h5><p>在Car中添加一个对象工厂属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, strong) JSObjectFactory *objectFactory;</span><br></pre></td></tr></table></figure><p>然后标记注入里面加多一个<code>objectFactory</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objection_requires(@&quot;engine&quot;, @&quot;breaks&quot;,@&quot;objectFactory&quot;)</span><br></pre></td></tr></table></figure><p>然后你就可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id obj &#x3D; [self.objectFactory getObject:[Engine class]];</span><br></pre></td></tr></table></figure><p>获取到对应的对象</p><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>你可以创建一个继承自<code>JSObjectionModule</code>的模块，在里面绑定相对应的<code>事物</code>，便可直接取到对应的值</p><p>例如  一个协议和一个模块类，对象绑定了类名和这个类所遵循的协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@protocol APIService &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)api:(NSString *)params;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface ModuleA : JSObjectionModule</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ModuleA</span><br><span class="line"></span><br><span class="line">- (void)configure</span><br><span class="line">&#123;</span><br><span class="line">    [self bindClass:[MyAPIService class] toProtocol:@protocol(APIService)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时候注射器初始化方式改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSObjectionInjector *injectorA &#x3D; [JSObjection createInjector:ModuleA.new]; [JSObjection setDefaultInjector:injectorA];</span><br></pre></td></tr></table></figure><p>你就可以直接拿到对应遵循了这个协议的对象而不用通过ModuleA的实例对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyAPIService *delegate &#x3D; [injectorA getObject:@protocol(APIService)];</span><br></pre></td></tr></table></figure><p><strong>注意由于绑定的时候是用了bindClass:方法，所以每次取出都是不同的对象</strong></p><p>除了绑定对象类名和协议外，还可以绑定一个对象和绑定一个类名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@implementation ModuleA</span><br><span class="line"></span><br><span class="line">- (void)configure</span><br><span class="line">&#123;</span><br><span class="line">    [self bind:对象实例 toClass:[UIApplication class]];</span><br><span class="line">    [self bind:对象实例 toProtocol:@protocol(UIApplicationDelegate)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**注意由于绑定的时候是用了bind:方法，所以每次取出都是相同的对象 **</p><p>当对象被创建的时候，可以通过bindBlock:方法进行干涉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@implementation ModuleA</span><br><span class="line"></span><br><span class="line">- (void)configure</span><br><span class="line">&#123;</span><br><span class="line">    [self bindClass:[MyAPIService class] toProtocol:@protocol(APIService)];</span><br><span class="line">    [self bindBlock:^id(JSObjectionInjector *context) &#123;</span><br><span class="line">        MyAPIService *service &#x3D; [[MyAPIService alloc] init];</span><br><span class="line">        service.buildByMySelf &#x3D; YES;</span><br><span class="line">        return service;</span><br><span class="line">    &#125; toClass:[MyAPIService class]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>上面这个例子表示MyAPIService被实例化后都会带上<code>buildByMySelf = YES</code></p><p>但是用这种方法的话，假如用注射器取出对象的时候带上了参数，那我们就没办法拿到参数了，所以我们需要用到<code>ObjectionProvider</code>协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@interface ProviderA : JSObjectionModule&lt;JSObjectionProvider&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ProviderA</span><br><span class="line">- (id)provide:(JSObjectionInjector *)context arguments:(NSArray *)arguments</span><br><span class="line">&#123;</span><br><span class="line">    MyAPIService *service &#x3D; [[MyAPIService alloc] init];</span><br><span class="line">    service.buildByProvider &#x3D; YES;</span><br><span class="line">    service.arguments &#x3D; arguments;</span><br><span class="line">    return service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)configure</span><br><span class="line">&#123;</span><br><span class="line">[self bindProvider:[ModuleA new] toClass:MyAPIService.class];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这样子就能手动构建对象并且得到参数了</p><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>上面提及的<code>bindClass:</code>、<code>bindBlock:</code>、<code>bindProvider:</code>这些方法，都有一个拓展参数<code>inScope:(JSObjectionScope)scope;</code></p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[self bindClass:[MyAPIService class] toProtocol:@protocol(APIService) inScope:JSObjectionScopeSingleton named:@&quot;&quot;];</span><br><span class="line"></span><br><span class="line">[self bindBlock:^id(JSObjectionInjector *context) &#123;</span><br><span class="line">MyAPIService *service &#x3D; [[MyAPIService alloc] init];</span><br><span class="line">service.buildByMySelf &#x3D; YES;</span><br><span class="line">return service;</span><br><span class="line">&#125; toClass:[MyAPIService class] inScope:JSObjectionScopeSingleton named:@&quot;&quot;];</span><br><span class="line"></span><br><span class="line">[self bindProvider:[ModuleA new] toClass:MyAPIService.class inScope:JSObjectionScopeSingleton];</span><br></pre></td></tr></table></figure><p><code>JSObjectionScopeSingleton</code>意味着注射器取出来的都是同个对象，<br><code>JSObjectionScopeNormal</code>意味着注射器取出来的是不同对象。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Objection 帮助你实现** 依赖注入 **，你只需要完成两件事情，配置依赖关系和获取依赖对象。配置依赖关系时，你可以使用几个常用的宏来快速的完成依赖关系的配置，另外你还可以使用模块的概念来完成更多的绑定操作，它允许你将某些类或某些协议接口绑定到某个或某一类的对象上，在配置完成后，你就可以使用关键的 injector 注入器获取到你所需要的对象。</p><p>Objection 像是一种字典容器，通过多种形式将 value 和 key 关联起来，在完成配置之后，你只需要关注你通过何种 key 获取到需要的 value 即可。Objection 最主要的功能之一就是面向接口编程的实现，在上面的示例中也进行了演示，面向接口编程是一种非常重要的编程思想。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文会说明iOS内依赖注入的概念和依赖注入框架Objection的一般使用&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="架构" scheme="https://www.arclin.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>pod install速度慢的终极解决方案</title>
    <link href="https://www.arclin.cn/post/826fbbdd.html"/>
    <id>https://www.arclin.cn/post/826fbbdd.html</id>
    <published>2020-04-01T02:13:48.000Z</published>
    <updated>2021-06-06T18:52:24.967Z</updated>
    
    <content type="html"><![CDATA[<p>相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。</p><span id="more"></span><p><a href="https://blog.csdn.net/iotjin/article/details/81604034">原博文</a>已经被删掉了，所以我自己copy并整理了一份</p><p>相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。</p><p>使用国内镜像的Specs<br>在pod install时使用命令<br><code>pod install --no-repo-update</code></p><p>使用proxychains使终端命令走代理<br>下面就来说明一下这几种方法为何没有完全解决问题</p><p>使用国内镜像的Specs<br>这个只是加快了Specs下载更新速度，而且如果使用国内镜像Specs，那么Podfile中就必须指明使用这个Specs。</p><p>在pod install时使用命令<br><code>pod install --no-repo-update</code></p><p>install时不更新本地库，但如果第一次install还是要去github clone代码</p><p>使用proxychains使终端命令走代理</p><p>这个只是使pod命令走代理，git download的时候不会走代理<br>其实真正慢的原因并不在pod命令，而是在于github上的代码库访问速度慢，那么就知道真正的解决方案就是要加快git命令的速度。</p><p>我使用Shadowsocks代理，默认代理端口为1080，配置好代理之后去终端输入git配置命令，命令如下</p><p><code>git config --global http.proxy socks5://127.0.0.1:1080</code></p><blockquote><p>注意这里的 socks5:// 协议 如果你用的是http/https协议 这里要改成 http:// 或https://</p></blockquote><blockquote><p>这里的http.proxy 一般不用改</p></blockquote><blockquote><p>查看端口号的方式可以在小飞机那里或者其他翻墙软件点击配置信息查看，看本地端口号一项</p></blockquote><p>上面的命令是给git设置全局代理，但是我们并不希望国内git库也走代理，而是只需要github上的代码库走代理，命令如下</p><p><code>git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</code></p><blockquote><p>这里的socks5:// 协议 跟上面说的同理</p></blockquote><p>（ps：如果要恢复/移除上面设置的git代理，使用如下命令<br><code>git config --global --unset http.proxy</code><br><code>git config --global --unset http.https://github.com.proxy</code>)</p><p>（如果不恢复的话，你一旦关掉代理（小飞机），那么之后git命令都跑不了网络了）</p><blockquote><p>注意这里的 http.proxy 其实就是上面的<code>git config --global http.proxy socks5://127.0.0.1:1080</code>中的 http.proxy, 如果你写的是https.proxy，那么这里unset的时候应该也写https.proxy</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="Cocoapods" scheme="https://www.arclin.cn/tags/Cocoapods/"/>
    
    <category term="技巧" scheme="https://www.arclin.cn/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>AppDelegate事件分发</title>
    <link href="https://www.arclin.cn/post/7e5c9fa9.html"/>
    <id>https://www.arclin.cn/post/7e5c9fa9.html</id>
    <published>2020-03-22T03:27:11.000Z</published>
    <updated>2021-06-06T18:52:24.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>当App发展庞大的时候，势必会导致AppDelegate类的庞大，所以如何去优化AppDelegate成为组件化工作中的主要部分之一。</p><span id="more"></span><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>举个例子，比如App中拥有</p><ol><li>用户管理组件</li><li>首页组件</li><li>消息组件</li></ol><p>那么他们分别需要在<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>中实现</p><ol><li>访问接口更新用户信息</li><li>配置首页弹窗</li><li>访问接口获取用户未读消息数</li></ol><p>假设这三个事件之间无关联，只是在初始化自己的模块后做准备工作，但是同时他们堆叠在同一个方法内，必然会导致方法臃肿。设想另外一个场景，假如开发者A只负责维护AppDelegate及主工程项目，开发者B只负责维护用户管理组件，那么开发者B要在App初始化的时候，再加入一个<code>将用户信息传到大数据中心统计</code>的功能，那么由于他不拥有<code>AppDelegate</code>的修改权限，只能让A排期去协助工作，同理可得，当组件变多，团队庞大的时候，开发者A将会有很多协助工作要做，这就是这次要讨论的问题。</p><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>是否可以将组件的初始化安排到组件内部中，而不在AppDelegate类中直接进行维护呢？</p><p>想法1. 组件新增一个类，然后在该类里面进行初始化。AppDelegate import 这个类，调用这个类中的方法。</p><p>缺点：AppDelegate需要耦合该组件，如果要去掉该组件或者新增别的组件，AppDelegate需要增加维护成本。</p><p>想法2. AppDelegate主动分发事件，用通知的形式分发给每个组件消息。</p><p>缺点：由于组件无法依赖主工程，所以通知名无法维护，另外通知会分发到不需要在AppDelgate初始化的组件，属于通知滥用。</p><p>想法3. AppDelegate主动分发事件，组件新增一个类，将AppDelegate事件通过协议的方式分发到这个类中，类遵循该协议。</p><p>缺点：技术上不可行，无法得知哪些类实现了协议。</p><p>想法4. 组件新增一个类，在<code>+ (void)load</code>中将类名注册进入管理类，AppDelegate执行的时候取出所有类名，进行实例化和事件分发。</p><p>缺点：在<code>+ (void)load</code>中进行工作会增加App启动耗时</p><p>想法5. 组件新增一个类，在主工程维护一个plist，将类名写进该plist，AppDelegate执行的时候取出所有类名，进行实例化和事件分发。</p><p>缺点：plist在主工程，同样无法满足无缝对接的需求，A同事仍然需要对接维护。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>目前能得出的最优解决方案：</p><p>将类名注入mach-o文件中，在编译期写入，在AppDelegate事件分发的时候取出并实例化，不占用App启动耗时，也不用维护多一个plist文件。</p><h2 id="试验"><a href="#试验" class="headerlink" title="试验"></a>试验</h2><ol><li><p>新建 MacOS - Command Line Tool 项目，命名为<code>TestC</code></p></li><li><p>加入我们想注入字符串<code>ModuleAModule</code>,将其存储在名为<code>TestModes</code>的section内，那么在main.m中写如下代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char * kModuleAModule_mod __attribute((used, section(&quot;__DATA, &quot;&quot;TestModes&quot;&quot; &quot;))) &#x3D; &quot;&quot;&quot;ModuleAModule&quot;&quot;&quot;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">&#x2F;&#x2F; insert code here...</span><br><span class="line">printf(&quot;Hello, World!\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>输出这个mach-o文件的所有segment和section<code>otool -l TestC</code></p><p> 部分结果：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Section</span><br><span class="line">  sectname TestModes</span><br><span class="line">   segname __DATA</span><br><span class="line">  addr 0x0000000100002008</span><br><span class="line">  size 0x0000000000000008</span><br><span class="line">offset 8200</span><br><span class="line"> align 2^3 (8)</span><br><span class="line">reloff 0</span><br><span class="line">nreloc 0</span><br><span class="line"> flags 0x00000000</span><br><span class="line"> reserved1 0</span><br><span class="line"> reserved2 0</span><br></pre></td></tr></table></figure><p> 看到了<code>Test Modes</code>了，继续看一下section的内容<code>otool -s __DATA TestModes TestC</code></p><p> 结果</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TestC:</span><br><span class="line">Contents of (__DATA,TestModes) section</span><br><span class="line">000000010000200892 0f 00 00 01 00 00 00 </span><br></pre></td></tr></table></figure><p> 发现<code>0000000100002008</code>这个地址可能是我们要的东西，再看看这个地址里有啥<br> <code>otool -V -s __TEXT __cstring TestC </code>打印所有字符串数据内容<br> 看到了</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Contents of (__TEXT,__cstring) section</span><br><span class="line">0000000100000f92  ModuleAModule</span><br><span class="line">0000000100000fa0  Hello, World!\n</span><br></pre></td></tr></table></figure><p> 找到了我们想注入的类名<code>ModuleAModule</code><br> 这样，类名就被存储在mach-o文件的section中了。</p></li><li><p>取出类名， 代码如下</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">NSArray&lt;NSString *&gt;* readConfiguration(char *sectionName,const struct mach_header *mhp)</span><br><span class="line">&#123;</span><br><span class="line">NSMutableArray *configs &#x3D; [NSMutableArray array];</span><br><span class="line">unsigned long size &#x3D; 0;</span><br><span class="line">#ifndef __LP64__</span><br><span class="line">uintptr_t *memory &#x3D; (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#else</span><br><span class="line">const struct mach_header_64 *mhp64 &#x3D; (const struct mach_header_64 *)mhp;</span><br><span class="line">uintptr_t *memory &#x3D; (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">unsigned long counter &#x3D; size&#x2F;sizeof(void*);</span><br><span class="line">for(int idx &#x3D; 0; idx &lt; counter; ++idx)&#123;</span><br><span class="line">char *string &#x3D; (char*)memory[idx];</span><br><span class="line">NSString *str &#x3D; [NSString stringWithUTF8String:string];</span><br><span class="line">if(!str)continue;</span><br><span class="line">if(str) [configs addObject:str];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return configs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide)</span><br><span class="line">&#123;</span><br><span class="line">NSArray *mods &#x3D; readConfiguration(&quot;TestModes&quot;, mhp);</span><br><span class="line">for (NSString *modName in mods) &#123;</span><br><span class="line">if (modName) &#123;</span><br><span class="line">NSLog(@&quot;取得：%@&quot;,modName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line">void initProphet() &#123;</span><br><span class="line">_dyld_register_func_for_add_image(dyld_callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当一个函数被<code>__attribute__((constructor))</code>修饰时，表示这个函数是这个镜像的初始化函数，在镜像被加载时，首先会调用这个函数。（镜像指的是mach-o和动态共享库，在工程运行时，可以使用lldb命令<code>image list</code>查看这个工程中加载的所有镜像。）<br>上述代码表示<code>initProphet</code>函数被指定为mach-o的初始化函数，当dyld（动态链接器）加载mach-o时，执行<code>initProphet</code>函数，其执行时机在main函数和类的load方法之前。</p><p> 当<code>_dyld_register_func_for_add_image(dyld_callback);</code>被执行时，如果已经加载了镜像，则每存在一个已经加载的镜像就执行一次<code>dyld_callback</code>函数，在此之后，每当有一个新的镜像被加载时，也会执行一次<code>dyld_callback</code>函数。<br>（<code>dyld_callback</code>函数在镜像的初始化函数之前被调用，mach-o是第一个被加载的镜像，调用顺序是：<code>load mach-o -&gt; initProphet -&gt; dyld_callback -&gt; load other_image -&gt; dyld_callback -&gt; other_image_initializers -&gt; ......</code>）</p><p> 所以，当程序启动时，会多次调用dyld_callback函数。<br> 在dyld_callback函数中，使用下列函数来获取[步骤2]中存储的类名</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern uint8_t *getsectiondata(</span><br><span class="line">   const struct mach_header_64 *mhp,</span><br><span class="line">   const char *segname,</span><br><span class="line">   const char *sectname,</span><br><span class="line">   unsigned long *size);</span><br></pre></td></tr></table></figure><p> segname的值为<code>__DATA</code>，sectname的值为<code>TestMods</code></p></li></ol><h2 id="封装组件"><a href="#封装组件" class="headerlink" title="封装组件"></a>封装组件</h2><p>有了上面的指导思想，那么我们就可以封装组件了，具体内容见<a href="https://git.linghit.io/ios_cocoapods/LMComponentManager">LMComponentManager</a></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li><p> 在AppDelegate做分发埋点，</p><p> 如<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code></p><p> 埋点如下</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">[[LMComponentManager sharedManager] triggerEvent:LMSetupEvent];</span><br><span class="line">[[LMComponentManager sharedManager] triggerEvent:LMInitEvent];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">[[LMComponentManager sharedManager] triggerEvent:LMSplashEvent];</span><br><span class="line">&#125;);</span><br><span class="line">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;&#x3D; 100000</span><br><span class="line">if ([UIDevice currentDevice].systemVersion.floatValue &gt;&#x3D; 10.0f) &#123;</span><br><span class="line">[UNUserNotificationCenter currentNotificationCenter].delegate &#x3D; self;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 其他埋点见组件Demo</p></li><li><p>给每个组件创建一个类并写上注解，如<code>LMComponentA.m</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@LMMod(LMComponentA);</span><br><span class="line">@interface LMComponentA()&lt;LMComponentProtocol&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation LMComponentA</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>实现协议<code>LMComponentProtocol</code>和需要的协议方法。<br> 这个协议里面蕴含了基本所有的<code>AppDelegate</code>方法，当然要触发这些方法都是要预先在AppDelegate写上埋点。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@implementation LMComponentA</span><br><span class="line"></span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;Component A Load&quot;);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">if (self &#x3D; [super init]) &#123;</span><br><span class="line">NSLog(@&quot;ComponentA Init&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)modSetUp:(LMContext *)context</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;ComponentA setup&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>接下来你就可以尝试使用了。</p></li></ol><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>要是组件间的初始化互相依赖怎么办？</p><p>还能怎么办，已经违背了组件隔离的原则，就只能按原来的方法处理了。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>参考思想：<a href="https://github.com/alibaba/BeeHive">BeeHive</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;当App发展庞大的时候，势必会导致AppDelegate类的庞大，所以如何去优化AppDelegate成为组件化工作中的主要部分之一。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="架构" scheme="https://www.arclin.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>组件化方案之强业务组件的设计</title>
    <link href="https://www.arclin.cn/post/be708589.html"/>
    <id>https://www.arclin.cn/post/be708589.html</id>
    <published>2020-02-04T02:48:31.000Z</published>
    <updated>2021-06-06T18:52:24.973Z</updated>
    
    <content type="html"><![CDATA[<p>本文简述组件化方案之强业务组件的设计</p><span id="more"></span><h3 id="如何定义强业务组件"><a href="#如何定义强业务组件" class="headerlink" title="如何定义强业务组件"></a>如何定义强业务组件</h3><p>涉及到具体业务需求，能单独完成App某个功能点（主要feature）的组件</p><h3 id="需要符合什么要求"><a href="#需要符合什么要求" class="headerlink" title="需要符合什么要求"></a>需要符合什么要求</h3><p>UI层和逻辑层的绝对独立</p><p>需求内容完整</p><p>可拓展，可维护</p><p>可独立配置UI（UI只可重写、不可修改）</p><p>逻辑层不可配置</p><p>代码内容清晰明确</p><h3 id="接下来开始讲故事"><a href="#接下来开始讲故事" class="headerlink" title="接下来开始讲故事"></a>接下来开始讲故事</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>随着业务发展，灵机大师说的咨询室模块需要抽离到各个App当中使用，但是由于不同App的网关配置和UI配置都不一样，造成了代码不可以完全进行复用，所以需要对原有代码重新设计。</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>如何设计组件是个比较复杂的问题</p><p>首先参考其他第三方IM提供商的Demo，基本上要用他们的UI的话就只能全套用，提供的配置项比较有限，自己改里面的东西成本很大，也不方便。</p><p>然后考虑自己如何修改原有代码</p><p>参考原有MVVM架构的话，在View和ViewModel之间是一个强耦合的状态，View会直接依赖ViewModel，如果使用方需要定制UI则会十分懵逼，不明确自己的View需要做什么才能配合ViewModel的使用。但这并不意味着MVVM就不能用，在组件初期，为了快速成型，必须沿用之前的设计模式。</p><p>接下来思考第二种方案，一种能够高度分离职责的架构，那便是VIPER。确实，在VIPER的设计思想中，单一职责原则体现得很好：Presenter寻找实现了InputProtocol的ViewController并给予数据，ViewController内的操作事件则通过实现了OutputProtocol的Presenter去执行，Presenter内部又通过Interactor和wireframe去实现数据获取和路由的交互，这种面相协议的开发也十分契合我们的需求，协议的方式能够很明确的让使用者知道他要做什么和他需要给予什么。但是VIPER的结构比较复杂比较适合后期在发展，目前还是以MVVM为主比较好。</p><p>那么如何改进我们现有的MVVM模式？这里我们就要将VIPER的精髓，面向协议和依赖注入抽离出来。</p><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>首先先说明什么叫做依赖注入</p><p>比如AController跳转到BController,那么这时候BController就需要在AController内部进行实例化，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@implementation AController : UIViewController</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (void)jump </span><br><span class="line">&#123;</span><br><span class="line">BController *bController &#x3D; [[BController alloc] init];</span><br><span class="line">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这么做的话，当AController被封装成组件之后，BController的配置将会被限制，外部无法改变BController任何细节，所以我们 ** 稍 加 改 进 **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@implementation AController : UIViewController</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCreateBlock:(UIViewController *(^)(void))createBViewControllerBlock &#123;</span><br><span class="line">....</span><br><span class="line">self.createBViewControllerBlock &#x3D; createBViewControllerBlock;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jump </span><br><span class="line">&#123;</span><br><span class="line">UIViewController *bController &#x3D; self.createBViewControllerBlock();</span><br><span class="line">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[AController alloc] initWithCreateBlock:UIViewController* ^&#123;</span><br><span class="line">BController *bController &#x3D; [[BController alloc] initWithTitle:@&quot;xxx&quot;];</span><br><span class="line">return bController;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>将BController的创建通过Block暴露出来，AController内部不关心BController是如何被创建的，那么AController对BController的依赖将通过外部的Block进行注入。</p><p>这，就是依赖注入。</p><p>当然这是最简单的依赖注入，无法满足我们复杂的需求，所以有时候我们需要使用第三方框架，如<code>Objection</code>和<code>Typhoon</code></p><h4 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h4><p>依赖倒置是是六个设计原则之一。依赖倒置意味着实现依赖于抽象，抽象不依赖实现。</p><p>举个例子</p><p>当你需要买一杯饮料，你不需要到具体哪家店买，反正任意一个便利店都有饮料卖，所以你需要的并不是获得美宜佳的地址或者711的地址，你需要的只是一个“卖饮料的店”，这是一个抽象的概念，这样子就是依赖被倒置了，本来是你去寻找美宜佳，现在变成拥有“卖饮料”功能的店去满足你。</p><p>在iOS中，抽象是通过代理体现的</p><p>同样的，我们再来看看刚刚的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation AController : UIViewController</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (void)jump </span><br><span class="line">&#123;</span><br><span class="line">BController *bController &#x3D; [[BController alloc] init];</span><br><span class="line">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>根据依赖倒置原则进行改造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface AController()</span><br><span class="line"></span><br><span class="line">@property(weak) id&lt;BControllerProtocol&gt; bViewController;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AController : UIViewController</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (void)jump </span><br><span class="line">&#123;</span><br><span class="line">    [self.navigationController pushViewController:self.bViewController animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AViewController *aViewController &#x3D; [[AViewController alloc] init];</span><br><span class="line">id&lt;BControllerProtocol&gt; bViewController &#x3D; [[BViewController alloc] init];</span><br><span class="line">aViewController.bViewController &#x3D; bViewController;</span><br></pre></td></tr></table></figure><h4 id="依赖注入-依赖倒置"><a href="#依赖注入-依赖倒置" class="headerlink" title="依赖注入+依赖倒置"></a>依赖注入+依赖倒置</h4><p>将协议和注入的模式进行结合，仿照上面的代码，估计就是这样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[AController alloc] initWithCreateBlock:UIViewController&lt;BControllerProtocol&gt;* ^&#123;</span><br><span class="line">id&lt;BControllerProtocol&gt; bController &#x3D; [[BController alloc] initWithTitle:@&quot;xxx&quot;];</span><br><span class="line">return bController;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>当然 这种模式只是个例子，给大家一种具体的观感</p><p>实际上在编码的时候，一个控制器往往有很多依赖，这里分为<code>可注入依赖</code>和<code>不可注入依赖</code></p><p>可注入的依赖往往是一些可以配置的依赖，使用者通过将自己自定义的配置注入，覆盖原有的默认依赖，达到配置内部样式的效果</p><p>反之，不可注入的依赖就会是代码中固定的耦合项目，合理的耦合以不至于组件产生过多未知问题。</p><p>刚刚说到一些依赖注入的第三方框架<code>Objection</code>和<code>Typhoon</code>，这个之后再详细介绍，这里简单说明一下，当使用方需要使用自定义类注入组件的时候，都是需要依赖这两种框架，不能只由组件内部依赖，所以为了避免不必要的学习成本，暂时先不使用，后面如果拓展开了使用方法，可能会修改使用，我们这里先用一些理解起来比较简单但是操作起来可能比较麻烦的注入方式。</p><p>首先我们这里我们新增一个单例用于注入，通过反射机制实例化自定义的对象，然后进行注入。</p><p>当然这个对象是需要遵循我们对应的协议的。</p><p>协议我们按照VIPIER的规范，分为两种<code>InputProtocol</code>和<code>OutputProtocol</code></p><p><code>InputProtocol</code>包括控制器需要的外部参数<br><code>OutputProtocol</code>包括控制器的回调参数</p><p>按照目前咨询室的设计模式看来，是由三个控制器（一个父控制器和两个子控制器）构成，他们分别会有自己的<code>InputProtocol</code>和<code>OutputProtocol</code>，如果业务端需要自己实现UI则自己实现协议然后进行注入即可。</p><p>待续</p><p>有空继续写</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文简述组件化方案之强业务组件的设计&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="架构" scheme="https://www.arclin.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI指南</title>
    <link href="https://www.arclin.cn/post/f6762f39.html"/>
    <id>https://www.arclin.cn/post/f6762f39.html</id>
    <published>2019-12-14T02:20:13.000Z</published>
    <updated>2021-06-06T18:52:24.968Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 13 SwiftUI 指南</p><span id="more"></span><h3 id="布局方向"><a href="#布局方向" class="headerlink" title="布局方向"></a>布局方向</h3><h4 id="VStack-垂直布局"><a href="#VStack-垂直布局" class="headerlink" title="VStack 垂直布局"></a>VStack 垂直布局</h4><p>默认垂直方向居中布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VStack &#123;</span><br><span class="line">Text(&quot;默认居中&quot;)</span><br><span class="line">Text(&quot;Hello, World!&quot;)</span><br><span class="line">Text(&quot;Hello, World Again!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对齐方向参数可选(<code>.leading</code>,<code>.trailing</code>,<code>.center</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VStack(alignment:.leading) &#123;</span><br><span class="line">Text(&quot;左对齐&quot;)</span><br><span class="line">Text(&quot;Hello, World!&quot;)</span><br><span class="line">Text(&quot;Hello, World Again!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HStack-水平布局"><a href="#HStack-水平布局" class="headerlink" title="HStack 水平布局"></a>HStack 水平布局</h4><p>默认水平方向居中布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HStack &#123;</span><br><span class="line">Text(&quot;默认居中&quot;)</span><br><span class="line">Text(&quot;Hello, World!&quot;)</span><br><span class="line">Text(&quot;Hello, World Again!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对齐方向参数可选(<code>.top</code>,<code>.bottom</code>,<code>.center</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HStack(alignment:.bottom) &#123;</span><br><span class="line">Text(&quot;左对齐&quot;)</span><br><span class="line">Text(&quot;Hello, World!&quot;)</span><br><span class="line">Text(&quot;Hello, World Again!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ZStack-前后布局"><a href="#ZStack-前后布局" class="headerlink" title="ZStack 前后布局"></a>ZStack 前后布局</h3><p>代码下面内容的盖住上面的内容</p><p>默认水平居中&amp;垂直居中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZStack &#123;</span><br><span class="line">Text(&quot;默认居中&quot;)</span><br><span class="line">Text(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对齐方向参数可选(<code>.leading</code>,<code>.trailing</code>,<code>.top</code>,<code>.bottom</code>,<code>.topLeading</code>,<code>.topTrailing</code>,<code>.bottomLeading</code>,<code>.bottomTrailing</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZStack(alignment:.bottom) &#123;</span><br><span class="line">Text(&quot;底部对齐&quot;)</span><br><span class="line">Text(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><p>内边距，用来撑开你的布局</p><p>默认撑开上下左右各16pt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZStack&#123;</span><br><span class="line">Text(&quot;默认居中&quot;).padding()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以指定哪个位置撑开和数值大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZStack&#123;</span><br><span class="line">Text(&quot;默认居中&quot;).padding(20) &#x2F;&#x2F; 上下左右均撑开20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZStack&#123;</span><br><span class="line">Text(&quot;默认居中&quot;).padding(.leading: 20) &#x2F;&#x2F; 左边撑开20，其他同理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZStack&#123;</span><br><span class="line">Text(&quot;默认居中&quot;).padding([.leading,.trailing],50).fixedSize() &#x2F;&#x2F; 左边和右边都撑开50，其他同理，fixedSize意思等同于UILabel的sizeToFit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZStack&#123;</span><br><span class="line">Text(&quot;默认居中&quot;).padding(.leading, 10).padding(.top, 20) &#x2F;&#x2F; 左边10，上边20，其他同理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spacer"><a href="#Spacer" class="headerlink" title="Spacer"></a>Spacer</h3><p>用来填充空位。</p><p>因为SwiftUI不像原来的UI开发，是先设置好frame,再往里面添加东西，相反，他是一种先紧紧包住控件，然后通过padding、spacer等元素去“撑开”视图的思想。所以，Spacer在这里有点类似于UIBarButtonItem里的那个<code>UIBarButtonSystemItemFlexibleSpace</code>,就是把东西给撑开。</p><p>举个例子</p><p>水平界面这时候布局紧紧包裹着Text控件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HStack &#123;</span><br><span class="line">Text(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这时候加一个Spacer,那么Text控件就会靠左，右边部分会被Spacer把剩余空隙填满</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HStack &#123;</span><br><span class="line">Text(&quot;Hello, World!&quot;)</span><br><span class="line">Spacer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理如果是<code>VStack</code>，写在下面的话，自然就会把Text控件往上顶，然后把剩余屏幕部分填满。</p><h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p>直接输入图片名就可以引用本地图片<br><code>Image(&quot;bg_nuanxin_mask&quot;)</code></p><h4 id="resizeable"><a href="#resizeable" class="headerlink" title="resizeable"></a>resizeable</h4><p><code>Image(&quot;bg_nuanxin_mask&quot;).resizable()</code></p><p>把图片撑开</p><h3 id="隐藏NavigationBar"><a href="#隐藏NavigationBar" class="headerlink" title="隐藏NavigationBar"></a>隐藏NavigationBar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NavigationView &#123;</span><br><span class="line">ZStack &#123;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br><span class="line">.navigationBarHidden(true)</span><br><span class="line">.navigationBarTitle(&quot;&quot;)</span><br><span class="line">.navigationBarBackButtonHidden(true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="这个界面不显示，下个界面要显示导航栏"><a href="#这个界面不显示，下个界面要显示导航栏" class="headerlink" title="这个界面不显示，下个界面要显示导航栏"></a>这个界面不显示，下个界面要显示导航栏</h4><p>当前页面声明一个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@State private var navBarHidden &#x3D; true</span><br></pre></td></tr></table></figure><p>目标页面加一个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Binding var navBarHidden : Bool</span><br></pre></td></tr></table></figure><p>传值过去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NavigationLink(destination:xxxx, navBarHidden: $navBarHidden)) &#123;</span><br><span class="line">   xxxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标页面处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var body: some View &#123;</span><br><span class="line">WebView(webUrl:&quot;https:&#x2F;&#x2F;www.baidu.com&quot;,title: $title)</span><br><span class="line">.onAppear &#123;</span><br><span class="line">self.navBarHidden &#x3D; false</span><br><span class="line">&#125;</span><br><span class="line">.onDisappear &#123;</span><br><span class="line">self.navBarHidden &#x3D; true</span><br><span class="line">&#125;</span><br><span class="line">.navigationBarTitle(Text(title),displayMode: .inline)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="导航栏标题样式"><a href="#导航栏标题样式" class="headerlink" title="导航栏标题样式"></a>导航栏标题样式</h4><p>普通</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.navigationBarTitle(Text(title),displayMode: .inline)</span><br></pre></td></tr></table></figure><p>特大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.navigationBarTitle(Text(title),displayMode: .large)</span><br></pre></td></tr></table></figure><p>随滚动自动变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.navigationBarTitle(Text(title),displayMode: .automatic)</span><br></pre></td></tr></table></figure><h3 id="需要用到的一些快捷键"><a href="#需要用到的一些快捷键" class="headerlink" title="需要用到的一些快捷键"></a>需要用到的一些快捷键</h3><p>cmd + ctrl + 鼠标左键+控件/布局  =  调出菜单<br>ctrl + i = 代码缩进调整    </p><p>待续</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;iOS 13 SwiftUI 指南&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Sign in with Apple接入指南</title>
    <link href="https://www.arclin.cn/post/ac0a85bd.html"/>
    <id>https://www.arclin.cn/post/ac0a85bd.html</id>
    <published>2019-11-01T05:15:00.000Z</published>
    <updated>2021-06-06T18:52:24.968Z</updated>
    
    <content type="html"><![CDATA[<p>如果你的应用接入了第三方登陆，那么请同时接入苹果登录。</p><span id="more"></span><p><a href="https://developer.apple.com/app-store/review/guidelines/#sign-in-with-apple">苹果审核指南的相关内容</a><br><a href="https://developer.apple.com/news/?id=09122019b">新闻：2020年4月前需要适配好苹果登录</a></p><h2 id="简单接入"><a href="#简单接入" class="headerlink" title="简单接入"></a>简单接入</h2><p><a href="https://developer.apple.com/sign-in-with-apple/">苹果登录官方文档</a></p><p>流程：</p><p>用户点击按钮 — 调起苹果登录 — 授权成功 — 获取唯一标识符和其他信息 — 返回给后端 — 后端注册/登录 — 返回token — 登录成功</p><h3 id="必要的工作"><a href="#必要的工作" class="headerlink" title="必要的工作"></a>必要的工作</h3><ol><li><p>首先去苹果后台开启<code>Sign in with apple</code>选项，然后重新导出<code>provisionprofile</code>证书</p></li><li><p>授权</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ASAuthorizationAppleIDProvider *provider &#x3D; [[ASAuthorizationAppleIDProvider alloc] init];</span><br><span class="line">ASAuthorizationAppleIDRequest *request &#x3D; [provider createRequest];</span><br><span class="line">request.requestedScopes &#x3D; @[ASAuthorizationScopeFullName, ASAuthorizationScopeEmail];</span><br><span class="line"></span><br><span class="line">NSMutableArray &lt;ASAuthorizationRequest *&gt;* array &#x3D; [NSMutableArray arrayWithCapacity:2];</span><br><span class="line">if (request) [array addObject:request];</span><br><span class="line"></span><br><span class="line">NSArray&lt;ASAuthorizationRequest *&gt; *requests &#x3D; [array copy];</span><br><span class="line">ASAuthorizationController *authorizationController &#x3D; [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];</span><br><span class="line">authorizationController.delegate &#x3D; self;</span><br><span class="line">authorizationController.presentationContextProvider &#x3D; input;</span><br><span class="line">[authorizationController performRequests];</span><br></pre></td></tr></table></figure></li><li><p>回调，遵循回调<code>ASAuthorizationControllerPresentationContextProviding</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization API_AVAILABLE(ios(13.0))</span><br><span class="line">&#123;</span><br><span class="line">if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) &#123;</span><br><span class="line">&#x2F;&#x2F; 用户登录使用ASAuthorizationAppleIDCredential</span><br><span class="line">ASAuthorizationAppleIDCredential *appleIDCredential &#x3D; (ASAuthorizationAppleIDCredential *)authorization.credential;</span><br><span class="line">NSString *user &#x3D; appleIDCredential.user;</span><br><span class="line">NSString *namePerfix &#x3D; appleIDCredential.fullName.namePrefix;</span><br><span class="line">NSString *givenName &#x3D; appleIDCredential.fullName.givenName;</span><br><span class="line">NSString *middleName &#x3D; appleIDCredential.fullName.middleName;</span><br><span class="line">NSString *familyName &#x3D; appleIDCredential.fullName.familyName;</span><br><span class="line">NSString *nameSuffix &#x3D; appleIDCredential.fullName.nameSuffix;</span><br><span class="line">NSString *email &#x3D; appleIDCredential.email;</span><br><span class="line">NSString *nickname &#x3D; appleIDCredential.fullName.nickname;</span><br><span class="line"></span><br><span class="line">if (!nickname || nickname.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">nickname &#x3D; [NSString stringWithFormat:@&quot;%@%@%@%@%@&quot;,namePerfix?:@&quot;&quot;,familyName?:@&quot;&quot;,givenName?:@&quot;&quot;,middleName?:@&quot;&quot;,nameSuffix?:@&quot;&quot;];</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">[self.errorSubject sendNext:LMError(@&quot;授权信息有误&quot;)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithError:(NSError *)error API_AVAILABLE(ios(13.0))</span><br><span class="line">&#123;</span><br><span class="line">NSString *errorMsg &#x3D; nil;</span><br><span class="line">switch (error.code) &#123;</span><br><span class="line">case ASAuthorizationErrorCanceled:</span><br><span class="line">errorMsg &#x3D; @&quot;用户取消了授权请求&quot;;</span><br><span class="line">return;</span><br><span class="line">case ASAuthorizationErrorFailed:</span><br><span class="line">errorMsg &#x3D; @&quot;授权请求失败&quot;;</span><br><span class="line">break;</span><br><span class="line">case ASAuthorizationErrorInvalidResponse:</span><br><span class="line">errorMsg &#x3D; @&quot;授权请求响应无效&quot;;</span><br><span class="line">break;</span><br><span class="line">case ASAuthorizationErrorNotHandled:</span><br><span class="line">errorMsg &#x3D; @&quot;未能处理授权请求&quot;;</span><br><span class="line">break;</span><br><span class="line">case ASAuthorizationErrorUnknown:</span><br><span class="line">errorMsg &#x3D; @&quot;授权请求失败未知原因&quot;;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">[self.errorSubject sendNext:LMError(errorMsg)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="其他可选项"><a href="#其他可选项" class="headerlink" title="其他可选项"></a>其他可选项</h2><h3 id="苹果提供的登录按钮"><a href="#苹果提供的登录按钮" class="headerlink" title="苹果提供的登录按钮"></a>苹果提供的登录按钮</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASAuthorizationAppleIDButton *button &#x3D; [ASAuthorizationAppleIDButton buttonWithType:ASAuthorizationAppleIDButtonTypeSignIn style:ASAuthorizationAppleIDButtonStyleWhiteOutline];</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonType) &#123;</span><br><span class="line">    ASAuthorizationAppleIDButtonTypeSignIn, &#x2F;&#x2F; 按钮文字显示 ：通过Apple登录</span><br><span class="line">    ASAuthorizationAppleIDButtonTypeContinue, &#x2F;&#x2F; 按钮文字显示 ：通过Apple继续</span><br><span class="line"></span><br><span class="line">    ASAuthorizationAppleIDButtonTypeDefault &#x3D; &#x2F;&#x2F; 默认第一个 ASAuthorizationAppleIDButtonTypeSignIn,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonStyle) &#123;</span><br><span class="line">    ASAuthorizationAppleIDButtonStyleWhite, &#x2F;&#x2F; 白底黑字</span><br><span class="line">    ASAuthorizationAppleIDButtonStyleWhiteOutline, &#x2F;&#x2F; 黑字白框</span><br><span class="line">    ASAuthorizationAppleIDButtonStyleBlack, &#x2F;&#x2F; 黑底白字</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="授权成功的回调可以来自于其他地方"><a href="#授权成功的回调可以来自于其他地方" class="headerlink" title="授权成功的回调可以来自于其他地方"></a>授权成功的回调可以来自于其他地方</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;! 授权成功地回调</span><br><span class="line">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization  API_AVAILABLE(ios(13.0))&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    NSLog(@&quot;%@&quot;, controller);</span><br><span class="line">    NSLog(@&quot;%@&quot;, authorization);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;authorization.credential：%@&quot;, authorization.credential);</span><br><span class="line">    </span><br><span class="line">    NSMutableString *mStr &#x3D; [NSMutableString string];</span><br><span class="line">    mStr &#x3D; [_appleIDInfoTextView.text mutableCopy];</span><br><span class="line">    </span><br><span class="line">    if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) &#123;</span><br><span class="line">        &#x2F;&#x2F; 用户登录使用ASAuthorizationAppleIDCredential</span><br><span class="line">        ASAuthorizationAppleIDCredential *appleIDCredential &#x3D; authorization.credential;</span><br><span class="line">        NSString *user &#x3D; appleIDCredential.user;</span><br><span class="line">        &#x2F;&#x2F;  最好使用钥匙串的方式保存用户的唯一信息 这里暂且处于测试阶段，用NSUserDefaults</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] setValue:user forKey:QiShareCurrentIdentifier];</span><br><span class="line">        [mStr appendString:user?:@&quot;&quot;];</span><br><span class="line">        NSString *familyName &#x3D; appleIDCredential.fullName.familyName;</span><br><span class="line">        [mStr appendString:familyName?:@&quot;&quot;];</span><br><span class="line">        NSString *givenName &#x3D; appleIDCredential.fullName.givenName;</span><br><span class="line">        [mStr appendString:givenName?:@&quot;&quot;];</span><br><span class="line">        NSString *email &#x3D; appleIDCredential.email;</span><br><span class="line">        [mStr appendString:email?:@&quot;&quot;];</span><br><span class="line">        NSLog(@&quot;mStr：%@&quot;, mStr);</span><br><span class="line">        [mStr appendString:@&quot;\n&quot;];</span><br><span class="line">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class="line">        </span><br><span class="line">    &#125; else if ([authorization.credential isKindOfClass:[ASPasswordCredential class]]) &#123;</span><br><span class="line">        &#x2F;&#x2F; 用户登录使用现有的密码凭证</span><br><span class="line">        ASPasswordCredential *passwordCredential &#x3D; authorization.credential;</span><br><span class="line">        &#x2F;&#x2F; 密码凭证对象的用户标识 用户的唯一标识</span><br><span class="line">        NSString *user &#x3D; passwordCredential.user;</span><br><span class="line">        &#x2F;&#x2F; 密码凭证对象的密码</span><br><span class="line">        NSString *password &#x3D; passwordCredential.password;</span><br><span class="line">        [mStr appendString:user?:@&quot;&quot;];</span><br><span class="line">        [mStr appendString:password?:@&quot;&quot;];</span><br><span class="line">        [mStr appendString:@&quot;\n&quot;];</span><br><span class="line">        NSLog(@&quot;mStr：%@&quot;, mStr);</span><br><span class="line">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;授权信息均不符&quot;);</span><br><span class="line">        mStr &#x3D; [@&quot;授权信息均不符&quot; mutableCopy];</span><br><span class="line">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="已经使用Sign-In-With-Apple登录过app的用户"><a href="#已经使用Sign-In-With-Apple登录过app的用户" class="headerlink" title="已经使用Sign In With Apple登录过app的用户"></a>已经使用Sign In With Apple登录过app的用户</h3><p>执行已经登录过的场景。如果设备中存在iCloud Keychain 凭证或者AppleID 凭证提示用户直接使用TouchID或FaceID登录即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (void)perfomExistingAccountSetupFlows &#123;</span><br><span class="line">    if (@available(iOS 13.0, *)) &#123;</span><br><span class="line">        &#x2F;&#x2F; A mechanism for generating requests to authenticate users based on their Apple ID.</span><br><span class="line">        &#x2F;&#x2F; 基于用户的Apple ID授权用户，生成用户授权请求的一种机制</span><br><span class="line">        ASAuthorizationAppleIDProvider *appleIDProvider &#x3D; [ASAuthorizationAppleIDProvider new];</span><br><span class="line">        &#x2F;&#x2F; An OpenID authorization request that relies on the user’s Apple ID.</span><br><span class="line">        &#x2F;&#x2F; 授权请求依赖于用于的AppleID</span><br><span class="line">        ASAuthorizationAppleIDRequest *authAppleIDRequest &#x3D; [appleIDProvider createRequest];</span><br><span class="line">        &#x2F;&#x2F; A mechanism for generating requests to perform keychain credential sharing.</span><br><span class="line">        &#x2F;&#x2F; 为了执行钥匙串凭证分享生成请求的一种机制</span><br><span class="line">        ASAuthorizationPasswordRequest *passwordRequest &#x3D; [[ASAuthorizationPasswordProvider new] createRequest];</span><br><span class="line">        </span><br><span class="line">        NSMutableArray &lt;ASAuthorizationRequest *&gt;* mArr &#x3D; [NSMutableArray arrayWithCapacity:2];</span><br><span class="line">        if (authAppleIDRequest) &#123;</span><br><span class="line">            [mArr addObject:authAppleIDRequest];</span><br><span class="line">        &#125;</span><br><span class="line">        if (passwordRequest) &#123;</span><br><span class="line">            [mArr addObject:passwordRequest];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; ASAuthorizationRequest：A base class for different kinds of authorization requests.</span><br><span class="line">        &#x2F;&#x2F; ASAuthorizationRequest：对于不同种类授权请求的基类</span><br><span class="line">        NSArray &lt;ASAuthorizationRequest *&gt;* requests &#x3D; [mArr copy];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; A controller that manages authorization requests created by a provider.</span><br><span class="line">        &#x2F;&#x2F; 由ASAuthorizationAppleIDProvider创建的授权请求 管理授权请求的控制器</span><br><span class="line">        &#x2F;&#x2F; Creates a controller from a collection of authorization requests.</span><br><span class="line">        &#x2F;&#x2F; 从一系列授权请求中创建授权控制器</span><br><span class="line">        ASAuthorizationController *authorizationController &#x3D; [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];</span><br><span class="line">        &#x2F;&#x2F; A delegate that the authorization controller informs about the success or failure of an authorization attempt.</span><br><span class="line">        &#x2F;&#x2F; 设置授权控制器通知授权请求的成功与失败的代理</span><br><span class="line">        authorizationController.delegate &#x3D; self;</span><br><span class="line">        &#x2F;&#x2F; A delegate that provides a display context in which the system can present an authorization interface to the user.</span><br><span class="line">        &#x2F;&#x2F; 设置提供 展示上下文的代理，在这个上下文中 系统可以展示授权界面给用户</span><br><span class="line">        authorizationController.presentationContextProvider &#x3D; self;</span><br><span class="line">        &#x2F;&#x2F; starts the authorization flows named during controller initialization.</span><br><span class="line">        &#x2F;&#x2F; 在控制器初始化期间启动授权流</span><br><span class="line">        [authorizationController performRequests];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监听授权状态变化"><a href="#监听授权状态变化" class="headerlink" title="监听授权状态变化"></a>监听授权状态变化</h3><p>监听授权状态改变，并且做出相应处理。授权状态有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ASAuthorizationAppleIDProviderCredentialRevoked：授权状态失效（用户停止使用AppID 登录App）</span><br><span class="line">ASAuthorizationAppleIDProviderCredentialAuthorized：已授权(已使用AppleID 登录过App）</span><br><span class="line">ASAuthorizationAppleIDProviderCredentialNotFound：授权凭证缺失（可能是使用AppleID 登录过App）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;! 观察授权状态</span><br><span class="line">- (void)observeAuthticationState &#123;</span><br><span class="line">    </span><br><span class="line">    if (@available(iOS 13.0, *)) &#123;</span><br><span class="line">        &#x2F;&#x2F; A mechanism for generating requests to authenticate users based on their Apple ID.</span><br><span class="line">        &#x2F;&#x2F; 基于用户的Apple ID 生成授权用户请求的机制</span><br><span class="line">        ASAuthorizationAppleIDProvider *appleIDProvider &#x3D; [ASAuthorizationAppleIDProvider new];</span><br><span class="line">        &#x2F;&#x2F; 注意 存储用户标识信息需要使用钥匙串来存储 这里笔者简单期间 使用NSUserDefaults 做的简单示例</span><br><span class="line">        NSString *userIdentifier &#x3D; [[NSUserDefaults standardUserDefaults] valueForKey:QiShareCurrentIdentifier];</span><br><span class="line">        </span><br><span class="line">        if (userIdentifier) &#123;</span><br><span class="line">            NSString* __block errorMsg &#x3D; nil;</span><br><span class="line">            &#x2F;&#x2F;Returns the credential state for the given user in a completion handler.</span><br><span class="line">            &#x2F;&#x2F; 在回调中返回用户的授权状态</span><br><span class="line">            [appleIDProvider getCredentialStateForUserID:userIdentifier completion:^(ASAuthorizationAppleIDProviderCredentialState credentialState, NSError * _Nullable error) &#123;</span><br><span class="line">                switch (credentialState) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 苹果证书的授权状态</span><br><span class="line">                    case ASAuthorizationAppleIDProviderCredentialRevoked:</span><br><span class="line">                        &#x2F;&#x2F; 苹果授权凭证失效</span><br><span class="line">                        errorMsg &#x3D; @&quot;苹果授权凭证失效&quot;;</span><br><span class="line">                        break;</span><br><span class="line">                    case ASAuthorizationAppleIDProviderCredentialAuthorized:</span><br><span class="line">                        &#x2F;&#x2F; 苹果授权凭证状态良好</span><br><span class="line">                        errorMsg &#x3D; @&quot;苹果授权凭证状态良好&quot;;</span><br><span class="line">                        break;</span><br><span class="line">                    case ASAuthorizationAppleIDProviderCredentialNotFound:</span><br><span class="line">                        &#x2F;&#x2F; 未发现苹果授权凭证</span><br><span class="line">                        errorMsg &#x3D; @&quot;未发现苹果授权凭证&quot;;</span><br><span class="line">                        &#x2F;&#x2F; 可以引导用户重新登录</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    NSLog(@&quot;SignInWithApple授权状态变化情况&quot;);</span><br><span class="line">                    NSLog(@&quot;%@&quot;, errorMsg);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用通知的方式检测是否授权应用支持Sign In With Apple变化情况。如下的代码可以根据自己的业务场景去考虑放置的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;! 添加苹果登录的状态通知</span><br><span class="line">- (void)observeAppleSignInState &#123;</span><br><span class="line">    if (@available(iOS 13.0, *)) &#123;</span><br><span class="line">        NSNotificationCenter *center &#x3D; [NSNotificationCenter defaultCenter];</span><br><span class="line">        [center addObserver:self selector:@selector(handleSignInWithAppleStateChanged:) name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;! 观察SignInWithApple状态改变</span><br><span class="line">- (void)handleSignInWithAppleStateChanged:(id)noti &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    NSLog(@&quot;%@&quot;, noti);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    </span><br><span class="line">    if (@available(iOS 13.0, *)) &#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] removeObserver:self name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重要（Important！）"><a href="#重要（Important！）" class="headerlink" title="重要（Important！）"></a>重要（Important！）</h2><ol><li>最好使用苹果提供的按钮 <code>ASAuthorizationAppleIDButton</code> （只有黑白两种颜色）</li><li>不用他的按钮的话建议使用显眼的颜色 </li><li>尽量放在显眼位置（第一位）</li><li><strong>不能比其他任何登录按钮要小</strong></li><li>保证登录页面一屏就能看到苹果登录按钮，不能滚动后才能看到</li><li>按钮的最小宽高有需求（看<a href="https://developer.apple.com/design/human-interface-guidelines/sign-in-with-apple/overview/">苹果人机交互指南相关文档</a>）</li><li>如果登录后要绑定手机的话，就在备注里面写好 依据来源 <a href="http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm">http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm</a>  指明(截图)第二十四条（苹果一般不会打开网页，建议下载个pdf给他）</li><li>如果不好好跟苹果爸爸的规矩来，那么可能会吃到2.1和4.0 (不要问我为什么知道)</li></ol><p>(更新至2019/11/01)</p><table><thead><tr><th>最小宽度</th><th>最小高度</th><th>最小间距</th></tr></thead><tbody><tr><td>140pt (140px @1x, 280px @2x)</td><td>30pt (30px @1x, 60px @2x)</td><td>1/10 of the button’s height）</td></tr></tbody></table><h2 id="参考其他教程"><a href="#参考其他教程" class="headerlink" title="参考其他教程"></a>参考其他教程</h2><p><a href="https://juejin.im/post/5d8c64d151882509606d6b17">掘金</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果你的应用接入了第三方登陆，那么请同时接入苹果登录。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 13新API</title>
    <link href="https://www.arclin.cn/post/f356f3c1.html"/>
    <id>https://www.arclin.cn/post/f356f3c1.html</id>
    <published>2019-10-24T05:18:00.000Z</published>
    <updated>2021-06-06T18:52:24.964Z</updated>
    
    <content type="html"><![CDATA[<p>可能会用到的iOS13新Api</p><span id="more"></span><h2 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h2><h3 id="截图转PDF"><a href="#截图转PDF" class="headerlink" title="截图转PDF"></a>截图转PDF</h3><p>safari可以长截图了<br><img width=20% src="https://i.loli.net/2019/10/24/iHxWAqL63E2ZfMY.jpg"></p><p>然后我们可以把<code>UIScrollView</code>的截图转成PDF</p><p><a href="https://developer.apple.com/documentation/uikit/uiscreenshotservicedelegate">文档</a></p><h3 id="双指滑动手势"><a href="#双指滑动手势" class="headerlink" title="双指滑动手势"></a>双指滑动手势</h3><p><img src="https://i.loli.net/2019/10/24/FbSEV8WCXcQRrf9.gif"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 是否允许多指选中</span><br><span class="line">optional func tableView(_ tableView: UITableView, shouldBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) -&gt; Bool</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;多指选中开始，这里可以做一些UI修改，比如修改导航栏上按钮的文本</span><br><span class="line">optional func tableView(_ tableView: UITableView, didBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) </span><br></pre></td></tr></table></figure><h3 id="深色模式"><a href="#深色模式" class="headerlink" title="深色模式"></a>深色模式</h3><p>见<a href="https://www.jianshu.com/p/176537b0d9dd">文章</a></p><h2 id="Framework类"><a href="#Framework类" class="headerlink" title="Framework类"></a>Framework类</h2><h3 id="Multiple-UI-Instances"><a href="#Multiple-UI-Instances" class="headerlink" title="Multiple UI Instances"></a>Multiple UI Instances</h3><p>可以支持一个界面同时展示多个控制器（不是父子控制器那种）<br>在iPad上可以使用</p><p><img src="https://docs-assets.developer.apple.com/published/8ce996907a/fc0975ae-c186-438c-abdd-5280f650c377.png"></p><p>主要类<code>UIScene</code></p><p><a href="https://developer.apple.com/documentation/uikit/app_and_environment">文档</a></p><h3 id="BackgroundTasks"><a href="#BackgroundTasks" class="headerlink" title="BackgroundTasks"></a>BackgroundTasks</h3><p>好消息~ 现在维持后台不被杀可以直接用这个API了，以前的会用后台获取定位和播放静音音乐的方式，但是现在只要注册后台就可以了，但是还是只有短期，长时间的话可能会要求充电状态或者持续的网络状态。</p><p><a href="https://developer.apple.com/documentation/backgroundtasks/">文档</a></p><h3 id="Camera-Capture"><a href="#Camera-Capture" class="headerlink" title="Camera Capture"></a>Camera Capture</h3><p>现在可以同时使用前后摄像头，可以进行分割遮罩，可以识别出头发，皮肤，牙齿</p><p><a href="https://developer.apple.com/documentation/avfoundation/avcapturemulticamsession/">文档1</a></p><p><a href="https://developer.apple.com/documentation/avfoundation/avsemanticsegmentationmatte/">文档2</a></p><h3 id="Combine"><a href="#Combine" class="headerlink" title="Combine"></a>Combine</h3><p>官方版RxSwift，主要是配合SwiftUI使用</p><p><a href="https://developer.apple.com/documentation/combine/">文档</a></p><h3 id="Core-Haptics"><a href="#Core-Haptics" class="headerlink" title="Core Haptics"></a>Core Haptics</h3><p>可以在UI交互的时候给点小触觉反馈，比如打开关闭UISwitch的时候小震动一下，或者播放点声音之类的</p><p><a href="https://developer.apple.com/documentation/corehaptics/">文档</a></p><h3 id="Apple-CryptoKit"><a href="#Apple-CryptoKit" class="headerlink" title="Apple CryptoKit"></a>Apple CryptoKit</h3><p>好消息，苹果自带HMAC、SHA、AES、NIST加密算法啦</p><p><a href="https://developer.apple.com/documentation/cryptokit/">文档</a></p><h3 id="VisionKit"><a href="#VisionKit" class="headerlink" title="VisionKit"></a>VisionKit</h3><p>好消息，苹果自带图片转文字功能啦</p><p><a href="https://developer.apple.com/documentation/visionkit/">文档</a></p><h3 id="MetricKit"><a href="#MetricKit" class="headerlink" title="MetricKit"></a>MetricKit</h3><p>用来收集用户设备信息的，主要是使用App的过程中的耗电，CPU等等性能指标，可以依据这些优化你的App</p><p><a href="https://developer.apple.com/documentation/metrickit/">文档</a></p><h3 id="PencilKit"><a href="#PencilKit" class="headerlink" title="PencilKit"></a>PencilKit</h3><p>iPad上跟Apple Pencil交互的API</p><p><a href="https://developer.apple.com/documentation/pencilkit/">文档</a></p><h3 id="Vision"><a href="#Vision" class="headerlink" title="Vision"></a>Vision</h3><p>图像识别相关framework<br>iOS11的功能：面部和面部界标检测，条形码识别，图像配准以及一般特征跟踪。</p><p>iOS13的新功能：</p><ol><li>对图像进行显著性分析。</li><li>在图像中检测人类和动物。</li><li>对图像进行分类和搜索。</li><li>分析图像与特征打印的相似性。</li><li>对文档执行文本识别。</li></ol><p><a href="https://developer.apple.com/documentation/vision/">文档</a></p><h3 id="Sign-in-with-Apple"><a href="#Sign-in-with-Apple" class="headerlink" title="Sign in with Apple"></a>Sign in with Apple</h3><p>苹果登录</p><p><a href="https://developer.apple.com/sign-in-with-apple/get-started/">文档</a></p><h3 id="SF-Symbols"><a href="#SF-Symbols" class="headerlink" title="SF Symbols"></a>SF Symbols</h3><p>可以用来显示矢量图</p><p><a href="https://developer.apple.com/documentation/uikit/uiimage/configuring_and_displaying_symbol_images_in_your_ui/">文档</a></p><h3 id="Bring-Your-iPad-App-to-Mac"><a href="#Bring-Your-iPad-App-to-Mac" class="headerlink" title="Bring Your iPad App to Mac"></a>Bring Your iPad App to Mac</h3><p>直接把iPad App 迁移到 Mac，不过还是要做适配的，下面文档会有一些适配规则，以兼容两个端</p><p><a href="https://developer.apple.com/design/human-interface-guidelines/ios/overview/mac-catalyst/">参考</a></p><p><a href="https://developer.apple.com/documentation/xcode/creating_a_mac_version_of_your_ipad_app">文档1</a></p><p><a href="https://developer.apple.com/documentation/uikit/mac_catalyst/optimizing_your_ipad_app_for_mac">文档2</a></p><h3 id="ARKit-3"><a href="#ARKit-3" class="headerlink" title="ARKit 3"></a>ARKit 3</h3><p>应该大家都知道ARKit，这次主要是多了些新特性，包括动态捕捉动作，同时捕捉多个面部，同时开启前后摄像头等。</p><p><a href="https://developer.apple.com/documentation/arkit/">文档</a></p><h3 id="RealityKit"><a href="#RealityKit" class="headerlink" title="RealityKit"></a>RealityKit</h3><p>3D模型搭建、展示用</p><p><a href="https://developer.apple.com/documentation/realitykit/">文档</a></p><h3 id="Core-ML-3"><a href="#Core-ML-3" class="headerlink" title="Core ML 3"></a>Core ML 3</h3><p>升级版机器学习套件</p><p><a href="https://developer.apple.com/documentation/coreml/">文档</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;可能会用到的iOS13新Api&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="feature" scheme="https://www.arclin.cn/tags/feature/"/>
    
  </entry>
  
  <entry>
    <title>如何开发/管理一个项目</title>
    <link href="https://www.arclin.cn/post/3c7b026b.html"/>
    <id>https://www.arclin.cn/post/3c7b026b.html</id>
    <published>2019-10-20T07:20:00.000Z</published>
    <updated>2021-06-06T18:52:24.971Z</updated>
    
    <content type="html"><![CDATA[<p>如何管理一个项目，这是个沉重的话题。实际上，目前很多人都是凭借经验进行项目管理和开发，事实上管理项目是有着大量的方法论，这些方法论整理起来被人归纳成了一个学科，名字叫做<code>软件工程</code>，接下来的内容将会归纳总结里面的一些要点，如果你有意成为一个项目管理者，请必须了解一下这些基础知识。</p><span id="more"></span><h2 id="软件系统模型"><a href="#软件系统模型" class="headerlink" title="软件系统模型"></a>软件系统模型</h2><p>开始一个项目之前，你需要做好准备，那就是建立系统模型，有了抽象的模型，才会有具像的实现。</p><ul><li>在软件开发中，软件系统模型大体可分为两类：<code>概念模型</code>和<code>软件模型</code>。</li><li>概念模型是创建在需求层上的，它描述了系统是什么。</li><li>软件模型是建立在抽象层上的，它描述了实现概念模型的软件解决方案。</li><li>软件模型可进一步分为<code>设计模型</code>、<code>实现模型</code>和<code>部署模型</code>。</li></ul><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p> 一个完整的需求需要有以下特征：</p><ol><li>必要的：该需求是用户所要求的（产品经常会提一些伪需求，比如说在帖子列表添加个一键评价，点击了就回复666，但实际上没有用户想毫无感情地666，所以这是伪需求，不满足该条件的请拒绝）；</li><li>无歧义的：该需求只能用一种方式解释（这个就不用解释了，遇到有歧义的需求请问清楚）；</li><li>可测的：该需求可以进行测试；</li><li>可跟踪的：该需求可以从一个开发阶段跟踪到另一个开发阶段（意思就是这个需求不会因为开发的进行变得模糊、不清晰）；</li><li>可测量的：该需求是可测量的（意思就是实现这个需求不能无限耗费人力物力，说好这个需求两个人一天能做完，就两个人一天真的能做完）。</li></ol><h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><ol><li>功能需求：系统或系统构件必须执行的功能</li><li>非功能需求：分为性能需求、外部接口需求、设计约束需求、质量属性需求。</li></ol><h3 id="怎么发现需求"><a href="#怎么发现需求" class="headerlink" title="怎么发现需求"></a>怎么发现需求</h3><table><thead><tr><th align="center">名称</th><th align="center">情况</th><th align="center">成功条件</th><th align="center">风险</th></tr></thead><tbody><tr><td align="center">自悟</td><td align="center">自己想</td><td align="center">要比你的最终客户拥有更多的一样弄领域和过程方面的知识和丰富的想象力，也就是你要比你的用户更加清楚用户要啥</td><td align="center">无法验证你想出来的东西是不是你的用户想要的</td></tr><tr><td align="center">交谈</td><td align="center">跟你的客户聊</td><td align="center">你能提出正确的问题，回答人能揭示需求本质的能力</td><td align="center">可能会获得一堆需求，而且越来越多，不断增长，可能还会推翻你之前的需求，可能导致超出项目成本和进度的限制<s>（甚至可能被你的开发揍一顿）</s></td></tr><tr><td align="center">观察</td><td align="center">你去看你的用户怎么用你的软件</td><td align="center">你需要有洞察事物本质的能力</td><td align="center">1. 你的用户会抵触你的观察（很明显侵犯隐私了）2. 用户会觉得你是不是这软件没做好或者哪里需求不到位所以老是来看我，对你的软件产生怀疑</td></tr><tr><td align="center">小组会</td><td align="center">项目组的人全部叫出来开会讨论需求</td><td align="center">你小组的人有不同观点，并且有良好的发现需求的能力，能揭示需求中存在的问题，最重要的是需求能跟用户达成共识</td><td align="center">会议组织不到位就凉了，而且天天开会你的项目组的人也受不了，可能会提出矛盾需求</td></tr><tr><td align="center">提炼</td><td align="center">针对已有的部分需求文档，看线上反馈情况，进行提炼</td><td align="center">你需要有想象力和需求标识能力，包括熟悉相关的技术标准</td><td align="center">跟自悟一样，你不能知道你发现的需求是否是对的</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="需求规约"><a href="#需求规约" class="headerlink" title="需求规约"></a>需求规约</h3><p>需求规约就是怎么写一个需求表，因为形式很多，所以最好就根据实际情况进行，这里不做规定，但是必须包含以下几个特征</p><ol><li>重要性和稳定性：需求要根据重要程度和稳定程度分优先级，例如：基本需求、可选需求和期望需求。</li><li>可修改的：在不过多地影响其他需求的情况下，可以容易地修改一个单一需求。</li><li>完整的：没有被遗漏的需求。</li><li>一致的：不存在互斥的需求。</li></ol><p>为什么需求规约很重要？（概念性东西）</p><ol><li>是软件开发组织和用户之间一份事实上的技术合同书，是产品功能及其环境的体现。</li><li>对于项目的其余大多数工作，需求规约是一个管理控制点。</li><li>对于产品/系统的设计，需求规约是一个正式的、受控的起点。</li></ol><h2 id="结构化方法"><a href="#结构化方法" class="headerlink" title="结构化方法"></a>结构化方法</h2><h3 id="结构化需求分析"><a href="#结构化需求分析" class="headerlink" title="结构化需求分析"></a>结构化需求分析</h3><ol><li><p>为什么要这么做？</p><p> 为了应对三大挑战：</p><pre><code> - 问题空间理解。（假如让你开发一个八字排盘App，但是你又不懂八字，所以要开发出一个高质量、满足用户要求的App，就不容易了） - 人与人之间的通信。（开发过程长、活动多、任务重，项目组成员多，直接面对面沟通起来难免有遗漏、误解等，所以这也是一个挑战） - 需求的变化性。（需求是不断变化的，所以这是软件开发人员面临的挑战）</code></pre><p> 一种好的需求技术应该具有以下基本特征：</p><pre><code> 1. 提供方便通信的机子，例如，在不同开发阶段，使用对相关人员易于理解的语言。 2. 鼓励需求分析人员使用问题空间的术语思考问题，编写文档。 3. 提供定义系统边界的方法。 4. 提供支持抽象的基本机制，例如，&quot;划分&quot;，&quot;功能抽象&quot;，&quot;结构抽象&quot;等。 5. 为需求分析人员提供多种可供选择的方案。 6. 提供特定的技术，适应需求的变化等。</code></pre></li><li><p>几种基本术语的解释</p><p> (1) 数据流：数据流是数据的流动，用于表达在分析中所要使用的、用于表达”客体”的信息，用箭头表示。<br> 大概长这样：</p> <img width=50px src='https://i.loli.net/2019/10/21/wM2SkZXGDY46lQh.png'> (2) 加工：加工是数据变换的单元，即它接受输入的数据，对其进行处理，并产生输出。 大概长这样 <img width=50px src='https://i.loli.net/2019/10/21/mcfwVCaJI1Sn8kZ.png'> (3) 数据存储：数据存储是数据的静态结构。 大概长这样(可以是横的或者竖的) <img width=50px src='https://i.loli.net/2019/10/21/xbXKc45RlYpnNB9.png'> (4) 数据源和数据潭: 数据源是数据流的起点，数据潭是数据流的归宿地。数据源和数据潭是系统之外的实体，可以是人、物或其他软件系统。 大概长这样 <img width=50px src='https://i.loli.net/2019/10/21/LiwWbnSAs7Pqzoh.png'></li><li><p>数据流图</p><p> 把上面的元素组成起来就是数据流图了<br> 大概长这样</p> <img width=70% src="https://i.loli.net/2019/10/21/wDdaFiLe9Ps6UzA.png"><p> 几个要点：1）数据流起到连接其他实体的作用，实体可以是加工、数据存储、数据源和数据潭；2）加工之间可以有多个数据流，这些数据流之间可以没有任何关系，数据流图也不表明他们的先后次序；3）对于一个比较大的软件系统，往往需要采用多层次的数据流图。</p></li><li><p>建模过程</p><ol><li>建立系统环境图，确立系统语境</li><li>自顶向下，逐步求精，建立系统的层次数据流图</li><li>定义数据字典。数据字典有3种基本结构表示：顺序结构，选择结构，重复结构。<ul><li>顺序结构是指数据A由数据B和数据C顺序构成的，并记为”+”。例如：学生成绩=姓名+性别+学号+科目+成绩，其中”=”号表达的是”定义为”.</li><li>选择结构是指由数据A是由数据B或数据C定义的，即数据B不可能同时是B和C，并记为“|”，例如：性别=男|女</li><li>重复结构是指数据A是由多个重复出现的数据B构成的，并记为”| |”，例如：学生成绩表=|学生成绩|<img width="50%" src="https://i.loli.net/2019/10/21/43hSWgZPmVirHfA.png"></li></ul></li><li>描述加工：该步的目标为依据系统的数据流图，给出其中每一加工的小说明。加工可以有3种表达工具。<ol><li>结构化自然语言（自然语言描述）</li><li>判定表: 由条件类别，条件组合，操作，操作执行构成。举例如图<img width=50% src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D22%2C0%2C590%2C389%3Bc0%3Dbaike80%2C5%2C5%2C80%2C26/sign=d64b6fc508087bf469a30da9cfe16500/42166d224f4a20a48dfd6c499a529822730ed059.jpg"></li><li>判定树。举例如图<img width=60%  src="https://i.loli.net/2019/10/21/COmGSet5I61lFsH.png"></li></ol></li></ol></li><li><p>注意事项：</p><ol><li>模型平衡问题</li><li>信息复杂性控制问题</li></ol></li><li><p>需求验证<br> 验证需求规格说明书中的每一单一需求是否满足5个性质，即必要性、无歧义性、可测性、可跟踪性、可测量性；验证需求规格说明是否满足4个性质，即重要性和稳定程度、可修改性、完整性和一致性。在必要时还需要验证其他特性，如设计无关性。</p></li></ol><h3 id="结构化设计"><a href="#结构化设计" class="headerlink" title="结构化设计"></a>结构化设计</h3><h4 id="总体设计步骤"><a href="#总体设计步骤" class="headerlink" title="总体设计步骤"></a>总体设计步骤</h4><p>结构化设计方法基于<code>自顶向下，功能分解</code>的基本原则，针对两种不同类型的数据流图，分别提出了变换设计和事务设计。其中，变换设计的目标是将变换型数据流图映射为模块结构图，而事务设计的目标是将事务型数据流图映射为模块结构图。</p><ol><li><p>变换型数据流图和事务性和数据流图<br>（1）变换型数据流图：具有比较明显的输入部分和变换部分之间的界面、变换部分和输出部分之间界面的数据流图，称为变换型数据流图；<br><img src="https://www.sytm.net/ueditor/net/upload/2013-12-31/bdae1434-8b79-4209-b818-2502c7ea3bee.png"><br>（2）事务型数据流图：数据到达一个加工T，该加工T根据输入的值，在其后若干动作序列中选出一个来执行，这类数据流图成为事务型数据流图。<br><img src="https://www.sytm.net/ueditor/net/upload/2013-12-31/142b2c91-a9ad-4c6e-b075-ecd6a900ee63.png"></p></li><li><p>总体设计分为3个阶段。第一阶段为初始设计，在对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。第二阶段为精化设计，依据模块“高内聚低耦合”的原则精化初始的模块结构图，并设计其中的全局数据结构和每一模块的接口。第三阶段为复审阶段，对前两个阶段所得到的高层软件结构进行复审，必要时还可能需要对该软件结构做一些精化工作，这对软件的一些性质，特别是对软件质量的提高，将产生非常大的影响。</p></li><li><p>天天扯着嗓子喊高内聚低耦合，到底什么是内聚什么是耦合？</p><ul><li>耦合：耦合是指不同模块之间相互依赖程度的度量<ul><li>内容耦合：当一个模块直接修改或操作另一个模块的数据，或当一个模块直接修改或操作，另一个模块的数据或一个模块不通过正常入口转入到一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该尽量避免使用。</li><li>公共耦合：两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。</li><li>控制耦合：一个模块通过接口向另一个模块传递一个控制信号，接收信号的模块根据信号值进行适当的动作，这种耦合被成为控制耦合。</li><li>标记耦合：若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。</li><li>数据耦合：模块之间通过参数来传递数据，则称为数据耦合。数据耦合是最低的一种耦合形式。</li></ul></li><li>内聚：内聚是指一个模块内部各成分之间相互关联程度的度量<ul><li>偶然内聚：如果一个模块的各成分之间基本不存在任何关系，则称为偶然内聚</li><li>逻辑内聚：几个逻辑上相关的功能被放在同一模块中，则称为逻辑内聚。</li><li>时间内聚：如果一个模块完成的功能必须在同一时间内执行（例如，初始化系统或一组变量），但这些功能只是因为时间因素关联在一起，则称为时间内聚。</li><li>过程内聚：如果一个模块内部的处理成分是相关的，而且这些处理必须以特定的次序执行，则称为过程内聚。</li><li>通信内聚：如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚</li><li>顺序内聚：如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚</li><li>功能内聚：最理想的内聚是功能内聚，模块所有的成分对于完成单一的功能都是基本的。功能内聚的模块对完成其功能而言是充分必要的。</li></ul></li><li>启发式规则：无论是变换设计还是事务设计，都涉一个共同的问题，即“基于高内聚低耦合的原理，采用一些经验性的启发式规则，对初始的模块结构图进行精化，形成最终的模块结构图”。</li><li>怎么做？<ol><li>改进软件结构，提高模块独立性。</li><li>力求模块规模适中。</li><li>力求深度、宽度、扇出和扇入适中。深度：表示其控制的<code>层数</code>(不包括自身)；宽度：同一层次上模块总数的<code>最大值</code>；扇出：一个模块<code>直接</code>控制（调用）的下级模块数目；扇入：一个模块有多少个上级模块<code>直接</code>调用它。</li><li>尽力使模块的作用域在其控制域之内。作用域：受该模块内<code>一个判定</code>所影响的所有模块的集合；控制域：模块本身以及所有<code>直接或间接</code>从属于它的模块的集合。</li></ol></li></ul></li></ol><h4 id="详细设计步骤"><a href="#详细设计步骤" class="headerlink" title="详细设计步骤"></a>详细设计步骤</h4><ol><li>结构化程序设计<br> 包含三种基本控制结构：顺序结构、选择结构、循环结构</li><li>详细设计工具<ol><li>程序流程图 <img width=20% src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945069712&di=74b11092aae0042569e80dc22ee83438&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F09%2F17%2F02%2F27798515%2F15.files%2Ffile0001.jpg"> 缺点：不是一种逐步求精的工具，过早地考虑程序的流程，不去考虑程序的全局结构；所表达的控制流，往往不受任何约束可随意转移，从而会影响甚至破坏好的系统结构设计；不易表示数据结构。</li><li>盒图（N-S图） <img width=40% src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945228461&di=10908d6d12f9c8984356e884b3c0aeb5&imgtype=0&src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fzhidao%2Fwh%253D450%252C600%2Fsign%3Da401ed95523d26972e86005960cb9ecd%2Fd833c895d143ad4bd5fe969f81025aafa50f0698.jpg"></li><li>PAD图（Problem Analysis Diagram） <img width="40%" src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945326054&di=d66d2f92c755db3f26640c2bbb6bc338&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F12%2F15%2F14%2F51872755%2F6.files%2Ffile0001.jpeg"></li></ol> N-S图和PAD图支持“自顶向下逐步求精”的设计。可节省人工编码工作，有利于提高软件的可靠性和软件生产率<ol start="4"><li>类程序设计语言（伪码/PDL）<br> 是一种用正文形式表示数据结构和处理过程的设计工具，PDL是一种“混合”的语言。</li></ol></li><li>设计规约<br> 完成软件设计后，应产生设计规约，完整准确地描述满足系统需求规约所要求的的所有功能模块，以及伴随功能模块而出现的非功能机制。设计规约通常包括<code>概要设计规约</code>和<code>详细设计规约</code>。 <code>概要设计规约</code>指明高层软件体系结构，其主要功能如下： 1.系统环境等与设计有关的限定条件 2. 软件模块的结构（模块之间的接口及设计的数据流和主要数据结构）3. 模块描述（接口定义，模块处理逻辑，必要的注释等）4. 文件结构和全局数据文件的逻辑结构 5.测试需求 <code>详细设计规约</code>（包括各处理过程的算法和算法所涉及的全部数据结构的描述）主要作为软件设计人员与程序员之间交流的媒体。</li></ol><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><h3 id="UML是一种图形化建模语言（Unified-Modeling-Language）"><a href="#UML是一种图形化建模语言（Unified-Modeling-Language）" class="headerlink" title="UML是一种图形化建模语言（Unified Modeling Language）"></a>UML是一种图形化建模语言（Unified Modeling Language）</h3><p>为了支持抽象分析和设计中的事物，UML给了八个基本术语，即类、接口、协作、用况、主动类、构件、制品、节点、</p><ul><li>类： 类是一组拥有相同属性、操作、关系和语义的对象的描述。类主要用于抽象客观世界中的事物。</li><li>接口：每个操作描述了类、构件或子系统的一个服务，接口就是操作的一个集合。接口是对系统/产品的“接缝”予以模型化，表明了一个类、构件、子系统所需要得到的、且与实现无关的行为。</li><li>用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的、可观察的结果。</li><li>协作：协作是一个交互，涉及交互的三要素：交互各方、交互方式以及交互内容</li><li>用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的，可观察的结果。</li><li>主动类：主动类是一种至少具有一个进程或线程的类。</li><li>构件：构件是系统设计中的一种模块化部件，通过外部接口隐藏了它的内部实现。</li><li>制品：制品是系统中包含物理信息（比特）的、可替代的物理部件。</li><li>节点：节点是运行时存在的物理元素，通常表示一种具有记忆能力和处理能力的计算机资源。</li></ul><p>类在建模中的主要用途：</p><ol><li>模型化问题域中的概念</li><li>建立系统的职责分布模型</li><li>模型化建模中使用的基本类型</li></ol><p>使用接口应注意的问题</p><ol><li>接口只可以被其他类目使用，而本身不能访问其他类目</li><li>接口描述类的外部可见操作，通常是该类的一个特有限定行为。这些操作可以使用可见性、并发性、衍型、标记值和约束来修饰。</li><li>接口不描述其中操作的实现，也没有属性和状态。据此可见，接口在形式上等价于一个没有属性、没有方法而只有抽象操作的抽象类</li><li>接口之间没有关联、泛化、实现和依赖。但可以参与泛化、实现和依赖</li></ol><h3 id="表达关系的术语"><a href="#表达关系的术语" class="headerlink" title="表达关系的术语"></a>表达关系的术语</h3><pre><code>关联：关联是一组具有相同结构、相同链的描述，是类目之间的一种结构关系。关联可以用一条连接两个类目的线段表示，并可对其命名，其结构可以具有方向性，用一个实心三角形来指示关联的方向。    1. 关联名 。    2. 导航：对于一个给定的类目，可以找到与之关联的另一个类目，这称为导航。    3. 角色：角色是关联一端的类目对另一端的类目的一种呈现。    4. 可见性：通过导航可以找到另一类目的实例，有时候需要限制访问。    5. 多重性：类中对象参与一个关联的数目，成为该关联的多重性    6. 限定符：限定符是一个关联的属性或属性表。    7. 聚合：分类是增强客观实际问题语义的一种手段。聚合是对象之间（不是类之间）的一种结构关系。    8. 组合：组合是聚合的一种特殊形式泛化：泛化是一般性类目和它的较为特殊类目之间的一种关系。子类可以继承父类的属性和操作，同时也可以替换父类的声明。    泛化的四种约束：完整、不完整、互斥、重叠细化：细化是类目之间的语义关系，其中一个类目规约保证了另一个类目执行的契约。依赖：依赖用于描述一个类目使用另一个类目的信息和服务，是一种使用关系。    依赖的分类：绑定、导出、允许、示例、实例化、幂类型、精化、使用。    关联、泛化和细化都是一类特地类型的依赖。使用这四种术语，可以模型化以下各种关系：1. 结构关系（静态结构和动态结构）    进行模型化时两种驱动方式：1.以数据驱动 2. 以行为驱动2. 继承关系3. 精化关系4. 依赖关系</code></pre><h3 id="表达组合信息的术语————包"><a href="#表达组合信息的术语————包" class="headerlink" title="表达组合信息的术语————包"></a>表达组合信息的术语————包</h3><p>为了控制信息组织的复杂性，UML提供了组织信息的一种通用机制————包，支持形成一些可管理的部分。换言之，包可以作为“模块化”和“构件化”的一种机制。</p><p>包是模型元素的一个分组。一个包本身可以被嵌套在其他包中，并且可以含有子包和其他种类的模型元素。</p><p>通过在包的名字前加上一个可见性符号（+，-，#），来指示该包的可见性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ 表示对其他包而言都是可见的</span><br><span class="line"># 表示对子孙包而言是可见的</span><br><span class="line">- 表示对其他包而言都是不可见的</span><br></pre></td></tr></table></figure><p>为了模型化包之间的关系，UML给出了两种依赖，即访问和引入。</p><ul><li>访问：表明目标包中的内容可以被源包所引用，或被那些递归嵌套在源包中的其他包所引用。</li><li>引入：表明目标包中具有适当可见性的内容（名字）被加入到源包的公共命名空间中。</li></ul><p>UML中用虚线加箭头的方式表示源包到目标包的依赖（访问和引入）。</p><h3 id="UML术语的作用"><a href="#UML术语的作用" class="headerlink" title="UML术语的作用"></a>UML术语的作用</h3><ol><li>类用于抽象客观事物</li><li>接口用于抽象事物之间的缝隙</li><li>协作用于抽象协作性行为</li><li>用况用于抽象功能</li><li>主动类用于抽象并发行为</li><li>构件用于抽象软件解中标识的成分</li><li>制品用于抽象工作产品</li><li>节点用于抽象计算单元</li><li>关联用于抽象结构关系</li><li>泛化用于抽象“一般/特殊”关系</li><li>实现用于抽象精化关系</li><li>依赖用于抽象使用关系</li></ol><h3 id="UML的模型表达式"><a href="#UML的模型表达式" class="headerlink" title="UML的模型表达式"></a>UML的模型表达式</h3><ol><li>结构图和行为图<br> 结构图用于表达系统或系统成分的静态结构模型，给出系统或系统成分的一些说明性信息<br> 行为图用于表系统或系统成分的动态结构模型，给出系统或系统成分的一些行为信息</li><li>类图、用况图、顺序图及状态图<ul><li>类图是可视化地表达系统静态结构功能模型的工具，使用类图所表达的系统静态结构模型，给出的是一些关于系统的说明性信息。<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176025075&di=1875f9ac829f33a38a45131069ee3e4a&imgtype=0&src=http://images.cnblogs.com/cnblogs_com/a-i/Uml2.JPG"></li><li>用况图是一种表达系统功能模型的图形化工具，它包含六个模型元素，分别是主题、用况、参与者、关联、泛化、依赖<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176303343&di=4146dfc9badef7bc95f4c750ab149eb0&imgtype=0&src=http://yzhtml01.book118.com/2016/09/24/23/28839740/23.files/file0001.png"></li><li>顺序图由一组对象以及按时序组织的对象之间的关系组成，是一种交互图，包含对象之间传递的信息。控制操作包括<code>选择执行操作</code>、<code>条件操作</code>、<code>并发迭代操作</code>、<code>迭代执行操作</code>。<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176439921&di=d592e65ae4a1bc1c2e65a98e415a897a&imgtype=0&src=http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/png/20180615101636402475.png"></li><li>状态图强调了从一个状态到另一个状态的控制流，是显示一个状态机的图。状态图由状态、事件和状态转移构成。使用状态图的作用有两个：一是创建一个系统的动态模型，二是创建一个场景的模型<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176576658&di=70e3de58666cf1d7315cf56a05ec0d35&imgtype=0&src=http://yzhtml01.book118.com/2016/12/07/08/48638362/25.files/file0001.png"></li><li></li></ul></li><li>创建一个系统的类图的步骤<ul><li>模型化代建系统中的概念，形成类图中的基本元素</li><li>模型化代建系统中的各种关系，形成该系统的初始类图</li><li>模型化系统中的协作，给出该系统的最终类图</li><li>模型化逻辑数据库模式</li></ul></li><li>信号事件、调用事件、时间事件和变化事件<ul><li>信号事件是一种异步事件，信号通常由状态机处理。如果没有定义对该事件的响应，那么事件均可能丢失。事件的丢失，就有可能引发接受者——状态机的一个错误的状态转移。</li></ul></li><li>状态转移所涉及的内容<br> 描述一个状态转换，一般涉及五个部分：<ol><li>源状态：发生状态转移的那个状态</li><li>转移触发器：在源状态中由对象识别的事件，并且一旦满足其监护条件，则使状态发生转移。</li><li>监护条件：一个布尔表达式，当某个事件触发器接受一个事件时，如果该表达式有值为真，则触发一个转移；若有值为假，则不发生状态转移。</li><li>效应：一种可执行的行为</li><li>目标状态：转移完成后所处的状态</li></ol></li><li>最常用的控制操作子<br> 选择执行操作子：该操作子由两部分组成：一是监护条件，二是控制体<br> 条件执行操作子：控制体通过水平线将其分为一些部分，每一部分表示一个条件分支，每一分支有一个监护条件。<br> 并发执行操作子：该控制操作子的体通过水平线将其分为多个部分，每一部分表示一个并行计算。该控制操作子表明，当进入该控制操作子是，所有部分并发执行。<br> 迭代执行操作子：该控制操作子表明，只要在每一次迭代之前该监护条件为真，那么该控制体就反复执行，当该控制体上面的监护条件为假时，控制绕过该控制操作子。</li><li>子状态机、简单状态和组合状态的概念<br> 子状态机：为了有效地组织状态、控制对象状态的复杂性，UML提供了组合状态，在一个状态机中引入了另一个状态机。被引入的状态机就称为子状态机。<br> 简单状态：子状态是被嵌套到另一状态中的状态。相对地，被引入的状态机就称为子状态机。<br> 组合状态：把含子状态的状态称为组合状态，组合状态可包含两种类型的子状态机，即非正交（顺序）子状态机和正交（并发）子状态机。<h2 id="RUP"><a href="#RUP" class="headerlink" title="RUP"></a>RUP</h2></li></ol><h3 id="RUP-Rational-Unified-Process-的特点"><a href="#RUP-Rational-Unified-Process-的特点" class="headerlink" title="RUP(Rational Unified Process)的特点"></a>RUP(Rational Unified Process)的特点</h3><p>RUP的突出特点是，它是一种以用况（Use Case）为驱动的、以体系结构为中心的迭代、增量式开发。</p><ol><li>以用况为驱动<br>以用况为驱动是指在系统的生存周期中，以用况作为基础，驱动系统有关人员对所要建立系统的功能需求进行交流，驱动系统分析、设计、实现和测试等活动。</li><li>以体系结构为中心<br>以体系结构为中心是指在系统的生存周期中，开发的任何阶段都要给出相关模型视角下有关体系结构的描述，作为构思、构造、管理和改善系统的主要标准。</li><li>迭代、增量式开发<br>迭代、增量式开发是指通过开发活动的迭代，不断地产生相应的增量。在RUP中，规定了四个开发阶段：初始阶段、精化阶段、构造阶段和移交阶段。</li></ol><h3 id="核心工作流"><a href="#核心工作流" class="headerlink" title="核心工作流"></a>核心工作流</h3><p>核心工作流：需求获取、分析、设计、实现和测试</p><h4 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h4><table><thead><tr><th align="center">基本步骤</th><th align="center">产生的制品</th></tr></thead><tbody><tr><td align="center">列出候选的特征</td><td align="center">特征表</td></tr><tr><td align="center">理解系统语境</td><td align="center">领域模型或业务模型</td></tr><tr><td align="center">捕获功能需求</td><td align="center">用况模型</td></tr><tr><td align="center">捕获非功能需求</td><td align="center">补充需求或针对特殊需求的用况</td></tr></tbody></table><h3 id="业务用况模型和业务对象模型"><a href="#业务用况模型和业务对象模型" class="headerlink" title="业务用况模型和业务对象模型"></a>业务用况模型和业务对象模型</h3><ol><li>业务用况模型。业务用况模型是以用框图予以表达的</li><li>业务对象模型。为了精化业务用况模型中的每一个业务用况，RUP引入了三个术语，用于表达参与业务的业务对象：<code>工作人员</code>、<code>业务实体</code>和<code>工作单元</code>。业务对象模型可通过交互图和活动图予以表达。</li></ol><h3 id="标识用况应注意的问题"><a href="#标识用况应注意的问题" class="headerlink" title="标识用况应注意的问题"></a>标识用况应注意的问题</h3><ol><li>建立用况的结构中，应尽可能反映用况的实际情况。</li><li>在用况的结构化中，不论是施加什么结构，新引入的用况都不应该太小或太大</li><li>在建立用况的结构是，应尽量避免对用况模型中的用况功能进行分解。</li></ol><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><ol><li>分析类是类的一种衍型，分为边界类、实体类和控制类</li><li>用况细化时一个协作，针对一个用况，其行为可用多个分析类之间的相互作用来细化，并记为用况细化。用况细化对用况模型中的一个特定的用况提供了一种直接跟踪的方式。</li><li>分析包是一种控制信息组织复杂性的机制，提供了分析制品的一种组织手段。其主要特征为：体现问题的分离；高内聚、低耦合；尽可能体现一个系统的完整顶层设计，尽可能成为一些子系统或者成为一些子系统的组成部分。</li></ol><h4 id="具有良好结构的分析包的特征"><a href="#具有良好结构的分析包的特征" class="headerlink" title="具有良好结构的分析包的特征"></a>具有良好结构的分析包的特征</h4><ol><li>体现问题分离</li><li>高内聚、低耦合。</li><li>尽可能提现一个系统的完整顶层设计。</li></ol><h4 id="软件设计层上的术语"><a href="#软件设计层上的术语" class="headerlink" title="软件设计层上的术语"></a>软件设计层上的术语</h4><p>软件设计是满足需求规约所需要的软件结构。RUP为了满足系统/产品分析模型规约需求的软件结构，为设计层提供了是个术语：设计类、用况细化、设计子系统和接口，用于表达软件结构中的基本元素。</p><ol><li>设计类：一个设计类是对系统中实现一个类或类似构造的一个无缝抽象</li><li>用况细化：用况细化是设计模型的一个协作，其中使用设计类及其对象，描述一个特定用况是如何予以细化的，是如何执行的</li><li>设计子系统：设计子系统可以包含设计类、用况细化、接口，以及其他子系统，通过对其操作来显示其功能。</li><li>接口：接口用于规约由设计类和设计子系统，必须提供与该接口操作对应的实现方法。</li></ol><h4 id="创建系统-产品用况模型的活动和任务"><a href="#创建系统-产品用况模型的活动和任务" class="headerlink" title="创建系统/产品用况模型的活动和任务"></a>创建系统/产品用况模型的活动和任务</h4><p>创建系统/产品用况模型的活动和任务如下</p><ol><li>活动一：发现并描述参与者<br>任务1：发现参与者，即直接发现一些候选的参与者<br>任务2：描述参与者，即对参与者进行命名并描述</li><li>活动二：发现用况并对用况进行描述<br>任务1：发现用况<br>任务2：描述用况，即确定用况后对其进行描述</li><li>活动三：确定用况的优先级，目的是在寻找参与者并对其进行描述和发现用况的并对用况进行描述的基础上确定哪些用况适合在早期的迭代中开发，哪些适合在后期的迭代中开发。</li><li>活动四：精化用况。这一活动的目的是详细描述出每一用况的事件流，包括用况是怎样开始的，是怎样结束的，是怎样与参与者进行交互的，最终形成一系列精化的用况</li><li>活动五：构造用户界面原型。这一活动的目的在于建造用户界面原型，使用户可以有效地执行用况。</li><li>活动六：用况模型的结构化。需要进行以下工作。<ol><li>抽取用况描述中的那些一般性的和共享的功能并使用泛化关系标识和描述那些共享功能</li><li>抽取用况描述附加的或可选的功能</li><li>标识用况之间的包含关系。通过用况模型的结构化，最终形成一个系统/产品的精化用户模型</li></ol></li></ol><h4 id="创建系统-产品需求分析模型的活动和任务"><a href="#创建系统-产品需求分析模型的活动和任务" class="headerlink" title="创建系统/产品需求分析模型的活动和任务"></a>创建系统/产品需求分析模型的活动和任务</h4><ol><li>活动1：体系结构分析。该活动的目标是通过标识分析包和分析类，建立分析模型和体系结构“骨架”，并标识有关分析包和分析类的特定需求。<br>任务1：标识分析包。该任务的基本输入是系统的用况模型<br>任务2：处理分析包之间的共性<br>任务3：标识服务包<br>任务4：定义分析包的依赖，该任务的目标是发现相对独立的包，实现包的高内聚和低耦合<br>任务5：标识重要的实体类，该任务的目标是标识在体系结构方面具有意义的实体类。<br>任务6：标识分析包和重要实体类的公共特定需求，该任务的目标是依据需求获取阶段所标识的非功能需求，针对在分析期间所标识的包和分析类，标识它们的一些公共的特定要求。</li><li>活动2：用况分析。该活动的目标是：一是标识那些在用况事件流执行中所需要的分析类和对象；二是将用况的行为分布到参与交互的各个分析对象；三是捕获用况细化上的特定需求。<br>任务1：标识分析类，该任务的目标是标识在细化一个用况中所需要实体类、控制类和边界类，给出它们的名字、责任、属性和关系。<br>任务2：描述分析类对象之间的交互。首先确定细化该用况所必要的交互，其次分派该用况的功能，最后根据其责任，发现该交互图中的各个链。</li><li>活动3：类的分析。该活动的目标：一是标识并维护分析类的属性和关系；二是捕获分析类细化中的特殊需求。<br>任务1：标识责任，通过组合一个类在不同用况细化中所扮演的角色来完成。<br>任务2：标识属性<br>任务3：标识关联和聚合</li><li>活动4：包的分析。该活的目标是：一是确保分析包尽可能与其他包相对独立；而是确保分析包实现了它的目标；三是描述依赖，以益于可以估计未来的变化。</li></ol><h3 id="创建系统-产品设计模型的活动和任务"><a href="#创建系统-产品设计模型的活动和任务" class="headerlink" title="创建系统/产品设计模型的活动和任务"></a>创建系统/产品设计模型的活动和任务</h3><p>创建系统/产品设计模型的活动和任务如下：</p><ol><li>活动1：体系结构设计，该活动的目标是创建设计模型和部署模型，以及它们视角下的体系结构描述<br>任务1：标识节点和它们的网络配置，网络配置通常使用一种三元模式：客户端、数据库功能、业务/应用逻辑<br>任务2：标识子系统和它们的接口，目的是为了寻求一些复用的可能，而后随着设计模型的开发，在形成子系统结构中不断发现并烟花。<br>任务3：标识在体系结构方面有意义的设计类和它们的接口。标识在体系结构方面有意义的设计类的基本思想是：初始可以依据在体系结构方面有意义的分析类来标识一些体系结构上具有重要意义的设计类。标识在系统体系结构方面有意义的设计类时，应注意主动类往往是一类在体系结构方面具有重要意义的类。</li><li>活动2：用况的设计。其中分析模型用况细化分析是活动的输入、对应输出用况细化设计。<br>为了实现用况设计的输入/输出，一般采用两种方法：<ol><li>标识参与用况细化的设计类，首先基于分析模型研究相应用况细化分析中的分析类，来标识为细化这些分类所需要的设计类，然后基于用况的功能对每一个标识的设计类赋予相应的责任，最后为该细化创建一个类图，汇聚参与该用况细化的设计类，并给出类之间的关系。</li><li>标识参与用况细化的子系统和接口。</li></ol></li><li>活动3：类的设计。该活动的目标是完成用况细化设计中每一个类的角色设计，并完成有关每一类的非功能需求的设计。<br>任务1：概括描述设计类，该任务的输入为分析类/接口。<br>任务2：标识的操作，一般应依据分析类来标识设计类所提供的、所需要的操作，其中需要使用程序设计语言的语法来描述说标识的操作。<br>任务3：标识属性，该任务的目标是标识设计类所需要的属性，并使用程序设计语言的语法给出属性的描述。<br>任务4：标识关联和聚合。<br>任务5：标识泛化，基于分析模型中分析类之间的泛化，可以发现设计模型中的很多泛化。<br>任务6：描述方法，在设计期间一般用自然语言或适当的使用伪码对方法进行规约，但是在实现期间直接使用程序设计语言对方法进行规约。<br>任务7：描述状态，有些设计对象是受状态控制的，即它们的状态确定了它们接受一个消息的行为。在这种情况下，使用一个状态图描述一个对象的不同状态转移是有意义的。</li><li>活动4：子系统的设计。该活动的目标是：确保子系统尽可能独立于其他子系统或它们的接口；确保子系统提供正确的接口；确保子系统实现了它的目标，即给出了该子系统提供的那些接口所定义的操作的细化。</li></ol><h3 id="设计模型包含的元素"><a href="#设计模型包含的元素" class="headerlink" title="设计模型包含的元素"></a>设计模型包含的元素</h3><p>RUP设计的主要结果是设计模型，它尽量保持该系统具有分析模型的结构，并作为系统实现的输入，包含以下四个元素：</p><ol><li>设计子系统和服务子系统，以及它们的接口、依赖和内容。</li><li>设计类以及它们具有的操作、属性、关系及其实现的需求。</li><li>用况细化设计。</li><li>设计模型视角下的体系结构描述。</li></ol><h3 id="用况模型与分析模型的比较"><a href="#用况模型与分析模型的比较" class="headerlink" title="用况模型与分析模型的比较"></a>用况模型与分析模型的比较</h3><table><thead><tr><th align="center">用况模型</th><th align="center">分析模型</th></tr></thead><tbody><tr><td align="center">使用客户语言来描述</td><td align="center">使用开发者语言来描述</td></tr><tr><td align="center">给出的是系统对外的视图</td><td align="center">给出的是系统对内的视图</td></tr><tr><td align="center">使用用况予以结构化，但给出的是外部视角下的系统结构</td><td align="center">使用衍型类予以结构化，当给出的是内部视角下的系统结构</td></tr><tr><td align="center">可以作为客户与开发者之间关于“系统应该做什么，不应该做什么”的契约</td><td align="center">可以作为开发者理解系统如何勾画、如何设计和如何实现的基础</td></tr><tr><td align="center">在需求之间可能存在一些冗余、不一致和冲突等问题</td><td align="center">在需求之间不应存在冗余、不一致和冲突问题</td></tr><tr><td align="center">捕获的是系统的功能，包括在体系结构方面有意义的功能</td><td align="center">给出的是细化的系统功能，包括在体系结构方面具有意义的功能</td></tr><tr><td align="center">定义了一些进一步需要在分析模型中予以分析的</td><td align="center">定义了用况模型中每一个用况的细化</td></tr></tbody></table><h3 id="RUP实现活动"><a href="#RUP实现活动" class="headerlink" title="RUP实现活动"></a>RUP实现活动</h3><p>目标：基于设计类和子系统生成构件；对构件进行单元测试，进行集成和连接；把可执行的构件映射到部署模型。</p><table><thead><tr><th align="center">输入</th><th align="center">活动</th><th align="center">执行者</th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">设计模型、部署模型、体系结构描述【设计模型、部署模型角度】</td><td align="center">实现体系结构</td><td align="center">体系结构设计者</td><td align="center">构件【概述】、体系结构描述【实现模型、部署模型角度】</td></tr><tr><td align="center">补充需求、用况模型、设计模型、实现模型【当前建造】</td><td align="center">集成系统</td><td align="center">系统集成者</td><td align="center">集成建造计划、实现模型【连续的建造】</td></tr><tr><td align="center">集成建造计划、体系结构描述【实现模型角度】、设计子系统【已设计】、接口【已设计】</td><td align="center">实现子接口</td><td align="center">构件工程师</td><td align="center">实现子系统【建造完成】、接口【建造完成】</td></tr><tr><td align="center">设计类【已设计】、接口【由设计类提供】</td><td align="center">实现类</td><td align="center">构件工程师</td><td align="center">构件【完成】</td></tr><tr><td align="center">构件【完成】、接口</td><td align="center">完成单元测试</td><td align="center">构件工程师</td><td align="center">构件【已完成单元测试】</td></tr></tbody></table><h3 id="RUP测试活动"><a href="#RUP测试活动" class="headerlink" title="RUP测试活动"></a>RUP测试活动</h3><p>RUP的测试包括内部测试、中间测试和最终测试</p><table><thead><tr><th align="center">输入</th><th align="center">活动</th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">补充需求、用况模型、分析模型、设计模型、实现模型、体系结构的描述</td><td align="center">计划测试</td><td align="center">测试计划</td></tr><tr><td align="center">补充需求、用况模型、分析模型、设计模型、实现模型、体系结构描述、测试计划</td><td align="center">设计测试</td><td align="center">测试用况 测试过程</td></tr><tr><td align="center">测试用况、测试过程、实现模型</td><td align="center">实现测试</td><td align="center">测试构件</td></tr><tr><td align="center">测试用况、测试过程、测试构件、实现模型</td><td align="center">执行集成测试</td><td align="center">缺陷</td></tr><tr><td align="center">测试用况、测试过程、测试构件、实现模型</td><td align="center">执行系统测试</td><td align="center">缺陷</td></tr><tr><td align="center">测试用况、测试模型、缺陷</td><td align="center">评价测试</td><td align="center">测试评价</td></tr></tbody></table><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><h3 id="软件测试目标与软件测试过程模型"><a href="#软件测试目标与软件测试过程模型" class="headerlink" title="软件测试目标与软件测试过程模型"></a>软件测试目标与软件测试过程模型</h3><h4 id="软件测试及目标"><a href="#软件测试及目标" class="headerlink" title="软件测试及目标"></a>软件测试及目标</h4><p>软件测试的定义为：按照特定规程发现软件错误的过程。其目的是检验它是否满足规定的需求，或清楚了解预期结构与实际结果之间的差异</p><h4 id="软件测试与软件调试之间的区别"><a href="#软件测试与软件调试之间的区别" class="headerlink" title="软件测试与软件调试之间的区别"></a>软件测试与软件调试之间的区别</h4><p>软件测试与软件调试相比，在目的、技术和方法等方面都存在很大区别，主要表现在以下几个方面。</p><ol><li>测试从一个侧面证明程序员的”失败”.调试是为了证明程序员的正确。</li><li>测试以已知条件开始，使用预先定义的程序且有预知的结果，不可预见的仅是程序是否通过。调试一般是以不可知的内部条件开始，除统计性调试外，结果是不可预见的。</li><li>测试是有计划的，并要进行测试设计。调试是不受时间约束的。</li><li>测试是一个发现错误、改正错误、重新测试的过程。调试是一个推理过程。</li><li>测试的执行是有规程的。调试的执行往往要求程序员进行必要推理。</li><li>测试经常是由独立的测试组在不了解软件设计的条件下完成的。调试必须由了解详细设计的程序员完成。</li><li>大多数测试的执行和设计可由工具支持。调试时，程序员能利用的主要工具是调试器。</li></ol><h4 id="测试过程模型"><a href="#测试过程模型" class="headerlink" title="测试过程模型"></a>测试过程模型</h4><p>软件测试是一个有程序的过程，包括测试设计、测试执行以及测试结果比较。测试过程模型可分为三类：环境模型、被测对象模型和错误模型。</p><ol><li>环境模型：是对程序运行环境的抽象。程序运行环境又包括支持其运行的硬件、固件和软件，如计算机、终端设备、网卡、操作系统、编译系统、实用程序等。在软件测试过程中，建立环境模型的主要目的是，确定所发现的错误是否为环境造成的。</li><li>被测对象模型：该模型是从测试的角度对程序的抽象。为了测试，必须简化程序，形成被测程序的抽象版本、即对象模型。</li><li>错误模型：该模型是对程序中的错误及其分类的抽象。在软件测试中，往往需要定义“什么是错误”、“什么是一般性错误”、“什么是严重性错误”等，即要给出“错误模型”。</li></ol><h3 id="软件测试技术"><a href="#软件测试技术" class="headerlink" title="软件测试技术"></a>软件测试技术</h3><ol><li><p>测试覆盖及其他们之间的基本关系<br>软件测试技术大体上可分为两大类：一类是白盒测试技术，又称为结构测试技术，典型的是路径测试技术；另一种是黑盒测试技术，又称为功能测试技术，包括事务处理流程技术、状态测试技术、定义域测试技术等。白盒测试技术依据的是程序的逻辑结构，而黑盒测试技术依据的是软件行为的描述。</p></li><li><p>路径测试技术的分类</p><p> 测试覆盖包括路径覆盖、分支覆盖、条件覆盖与条件组合覆盖。</p><ol><li>路径覆盖：执行所以有可能穿过程序控制流程的路径。在路径测试中，该度量是最强的，一般是不可实现的。</li><li>语句覆盖：至少执行程序中所有语句一次</li><li>分支覆盖：至少将程序中的每一个分支执行一次</li><li>条件覆盖与条件组合覆盖：条件覆盖是指每个判定中所有的可能的条件的取值至少执行一次；条件组合覆盖是指设计足够的测试用例，使每个判定中所有可能的条件取值组合至少执行一次。</li></ol><p> 这四种测试覆盖的测试覆盖率由弱到强的顺序是：语句覆盖 &lt; 分支覆盖 &lt; 条件组合覆盖 &lt; 路径覆盖</p></li><li><p>事务流测试步骤</p><p> 事务流测试步骤具体如下。<br> 第一步：获得事务流程图。<br> 第二步：浏览、复审。<br> 第三步：用例设计。<br> 第四步：测试执行。</p></li><li><p>运用等价类划分技术进行测试的步骤</p><p> 具体测试步骤如下。<br> 第一步：建立等价类表<br> 第二步：为有效等价类设计测试用例<br> 第三步：为无效等价类至少设计一个测试用例</p></li><li><p>边界值分析的使用原则</p><p> 边界值分析是一种常用的黑盒测试技术。使用边界值分析在设计测试用例时，可以遵循以下原则。</p><ol><li>如果某个输入条件规定了输入值的范围，则应该选择正好等于边界值的数据，以及刚刚超过边界值的数据作为测试数据。</li><li>如果某个输入条件规定了值的个数，则可用最大个数、最小个数、比最大个数多1、比最小个数少1的数据作为测试数据</li><li>根据规格说明的每个输出条件，使用前面的原则1</li><li>根据规格说明的每个输出条件，使用前面的原则2</li><li>如果程序的规格说明中，输入域或输出域是有序集合，在实践中则经常选取集合的第一个元素、最后一个元素以及典型元素作为测试用例。</li><li>如果程序中使用了内部数据结构，则应该选择这个内部数据结构的边界上的值作为测试用例。</li><li>分析规格说明，找出其他可能的边界条件。</li></ol></li><li><p>使用因果图生成测试用例的步骤</p><p> 因果图技术是通过为判定表的每一列设计一个测试用例，从而实现测试用例的设计与选择的。该方法生成测试用例的基本步骤如下。</p><ol><li>通过软件规格说明书的分析，找出一个模块的原因和结果，并给每个原因和结果赋予一个标识符</li><li>分析原因与结果之间以及原因之间对应的关系，并画出因果图。</li><li>在因果图上标识出一些特定的约束或限制条件。</li><li>把因果图转换成判定表。</li><li>把判定表的每一列拿出来作为依据，设计测试用例。</li></ol></li></ol><h3 id="软件测试步骤"><a href="#软件测试步骤" class="headerlink" title="软件测试步骤"></a>软件测试步骤</h3><ol><li><p>单元测试<br> 单元测试主要检验软件设计的最小单元—模块。该测试以详细设计文档为指导，测试模块内的重要控制路径。一般来说，单元测试往往采用白盒测试技术。</p></li><li><p>集成测试<br> 集成测试是软件组装的一个系统化技术，其目标是发现与接口有关的错误，将经过单元测的模块构成一个满足设计要求的软件结构。集成测试集中于模块组合的功能和软件结构检验。集成测试可“自顶向下”地进行，称为自顶向下的集成测试；也可以“自底向上”地进行测试，称为自底向上的集成测试</p></li><li><p>有效性测试<br> 有效性测试的目标是发现软件实现的功能与需求规格说明书不一致的错误。因此有效性测试通常采用黑盒测试技术。</p></li><li><p>系统测试<br> 系统测试验证将软件融于更大系统中时整个系统的有效性。</p></li></ol><h2 id="软件生存周期过程与管理"><a href="#软件生存周期过程与管理" class="headerlink" title="软件生存周期过程与管理"></a>软件生存周期过程与管理</h2><h3 id="软件生存周期过程概述"><a href="#软件生存周期过程概述" class="headerlink" title="软件生存周期过程概述"></a>软件生存周期过程概述</h3><ol><li><p>过程分类</p><p> 按过程主体把软件生存周期过程分为以下几个过程。</p><ol><li>基本过程：是指那些与软件生产直接相关的活动集。该过程又可分为获取过程、供应过程、开发过程、运行过程和维护过程。</li><li>支持过程：是指有关各方按他们的目标所从事的一系列相关支持活动集。该过程又可分为文档过程、配置管理过程、质量保证过程、验证过程、确认过程、联合评审过程、审计过程和问题解决过程。</li><li>组织过程：是指那些与软件生产组织有关的活动集。该过程又可分为设计过程、基础设施过程、培训过程和改进过程。</li></ol></li><li><p>系统语境的过程类<br> 系统语境的过程类包含四个过程组，分别是协议过程组、项目过程组、技术过程组和组织上项目使能过程组。</p><ol><li>协议过程组包含两个过程：获取过程和供应过程。</li><li>项目过程组包含七个过程：项目规划过程、项目评价过程、决策管理过程、风险管理过程、配置管理过程、信息管理过程和测量过程。</li><li>技术过程组包含11个过程：利益攸关方需求定义过程、系统需求分析过程、系统体系结构设计过程、实现过程、系统集成过程、系统测试过程、软件安装过程、软件接受支持过程、软件运行过程、软件维护过程和软件销毁过程。</li><li>组织上使能过程组包含五个过程：生存周期模型管理过程、基础设施管理过程、项目包管理过程、人力资源管理过程和质量管理过程。</li></ol></li><li><p>组织上使能过程的作用。<br> 组织上使能的过程一般来说是组织层面上的工作，为项目的执行提供基本保障。该过程包含五个子过程。</p><ol><li>生存周期模型管理过程：其任务为过程建立、过程评估、过程改进。</li><li>基础设施管理过程：其任务为过程实现、基础设施的建立、基础设施的维护。</li><li>项目包管理过程：项目初始化、项目包评估、项目结束处理。</li><li>人力资源管理过程：其任务为技能标识、技能开发、技能获取和供给、知识管理。</li><li>质量管理过程：其任务为质量管理、质量管理纠正措施。</li></ol></li></ol><h3 id="过程描述"><a href="#过程描述" class="headerlink" title="过程描述"></a>过程描述</h3><p>软件验证过程包括两个活动：过程实现和验证。其中验证活动有五个任务：需求验证、设计验证、代码验证，集成验证和文档验证。</p><p>一个过程可通过过程意图，期望的结果以及到达过程结果需要执行的活动和任务来描述。对于一个过程的完整技术上的描述，还应包括：达到过程意图和实现过程结果的方法或规程，以及过程和活动文档。</p><h3 id="应用说明"><a href="#应用说明" class="headerlink" title="应用说明"></a>应用说明</h3><ol><li><p>系统和软件的关系</p><p> 在《ISO/IEC系统与软件工程-软件生产周期过程12207-2008》标准中，把软件认为是整个系统的一个组成从部分，执行系统中所确定的功能主要包括三大功能：控制功能、耦合功能以及软件本身提供的功能。由于软件通常存在与一个系统的上下文中，因此软件产品或服务一般可被认为是系统的一个项或称为系统元素。</p></li><li><p>剪裁过程及应用</p><p> 剪裁过程是使剪裁这一标准过程慢速以下特定情况或因素。</p><ol><li>围绕一个组织，其中该组织在一个协议中使用了这一标准</li><li>影响一个项目，其中要求该项目满足一个引用该标准的协议</li><li>反映一个组织的需要，其中该组织要供给产品或服务</li></ol></li></ol><h3 id="软件生存周期模型"><a href="#软件生存周期模型" class="headerlink" title="软件生存周期模型"></a>软件生存周期模型</h3><ol><li><p>瀑布模型</p><p> 瀑布模型是将软件生存周期各个活动规定为按固定顺序链接的若干阶段的模型。这一模型规定了个开发阶段的活动：系统需求、软件需求、需求分析、设计、编码、测试和运行，并且自上而下具有相互衔接的固定顺序；还规定了每一个阶段的输入，即工作对象以及本阶段的工作成果，作为输出传送到下一阶段。</p><p> 瀑布模型的提出，对软件工程的主要贡献如下。</p><ol><li>在决定系统怎样做之前存在一个需求阶段，它鼓励对系统做什么进行规约。</li><li>在系统构造之前存在一个需求阶段，它鼓励规划系统结构。</li><li>在每一阶段结束时进行评审，从而允许获取方和用户的参与。</li><li>前一步可以作为下一步被认可的、文档化的基线，并允许基线和配置早期接受控制。</li></ol><p> 瀑布模型的主要问题是：</p><ol><li>要求客户能完整、正确和清晰地表达他们的需求；并要求开发人员一开始就要理解这一应用。</li><li>由于需求的不稳定性，使设计、编码和测试阶段都可能发生延期；并且当项目接近结束时，出现了大量的集成和测试工作。</li><li>在开始的阶段中，很难评估真正的进度状态；并且直到项目结束之前都不能演示系统的能力。</li><li>在一个项目的早期开发阶段，过分地强调了基线和里程碑处的文档；并可能需要花费更多的时间用于建立一些用处不大的文档。</li></ol></li><li><p>增量模型</p><p> 增量模型是一种非整体开发的模型。软件在该模型中逐渐开发出来，开发出一部分，向用户展示一部分，可让用户及早看到部分软件，及早发现问题。该模型具有较大的灵活性，适合软件需求不明确、设计方案有一定风险的软件项目。</p></li><li><p>演化模型</p><p> 该模型主要针对事先不能完整定义需求的软件开发在用户提出待开发系统的核心需求的基础上，软件开发人员按照这一要求，首先开发一个核心系统并投入运行，以便用户能够有效地提出反馈，即精化系统、增强系统能力的需求；接着，软件开发人员根据用户反馈，实施开发的迭代过程；每一迭代过程均由需求、设计、编码、测试、集成等阶段组成，为整个系统增加一个可定义的，可管理的子集；如果在一次迭代中，有的需求不能满足用户的要求，可在下一次迭代中予以修正。</p><p> 主要特征：该模型显式地把需求获取扩展到需求阶段，既为了第二个构造增量，使用了第一个构造增量来精化需求。演化模型在一定程度上可以减少软件开发活动的盲目性。<br>不足之处：在演化模型的使用中，即使很好地理解了需求或设计，也很容易弱化需求分析阶段的工作。</p></li><li><p>螺旋模型</p><p> 螺旋模型将瀑布模型与增量模型结合起来，加入了两种模型均忽略了的风险分析，弥补了这两种模型的不足。因而它是一种风险驱动的模型。螺旋模型将开放过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合。</p><p> 螺旋模型关注解决问题的基本步骤，即标识问题，标识一些可选方案，选择一个最佳方案，遵循动作步骤并实施后续工作。其一个突出特征是，在开发的迭代中实际上只有一个迭代过程真正开发了可交付的软件。螺旋模型与演化模型和增量模型相比，同样适用了瀑布模型作为一个嵌入的过程，但螺旋模型所关注的阶段以及它们的活动是不同的。如果项目的开发风险很大或客户不能确定系统需求，在更广泛的意义上来讲，还包括一个系统或系统类型的要求，这时螺旋模型就是一个很好的生存周期模型。</p></li><li><p>喷泉模型</p><p> 喷泉模型体现了软件创建所固有的迭代和无间隙的特征。该模型主要用于支持面向对象技术的软件开发。由于对象概念的引入，使分析、设计、实现之间的表达没有明显间隙。</p></li></ol><h3 id="过程规划与管理"><a href="#过程规划与管理" class="headerlink" title="过程规划与管理"></a>过程规划与管理</h3><ol><li><p>创建一个软件项目生存周期过程的步骤</p><ol><li>选择软件生存周期模型</li><li>细化所选择的生存周期模型</li><li>为每一个活动或任务标识合适的实例数目</li><li>确定活动的时序关系，并检查信息流</li><li>建立过程计划的文档</li></ol></li><li><p>软件评估中应考虑的影响因素</p><ol><li>不管做怎么样的决策，都必须对所采取的的措施对生存周期过程所产生的影响进行评审，以便保证项目获得好的结果。在这一评估中，应考虑以下几方面的影响。<ol><li>所要求的的“返工”</li><li>资源需求</li><li>实施时间</li><li>对项目和用户的益处</li><li>员工情绪</li></ol></li></ol></li></ol><h2 id="集成化能力成熟度模型（CMMI）"><a href="#集成化能力成熟度模型（CMMI）" class="headerlink" title="集成化能力成熟度模型（CMMI）"></a>集成化能力成熟度模型（CMMI）</h2><h3 id="背景和原理"><a href="#背景和原理" class="headerlink" title="背景和原理"></a>背景和原理</h3><ol><li><p>过程改善</p><p> 历史过程改善，是指人为设计的一个活动程序，其目的是改进组织的过程性能和成熟度，并改进这一程序的结果</p></li><li><p>过程域、专用目标和共用目标</p><p> 过程域是一个业务域中一束相关的实践，当它们一起得以实现时，就满足被认为对该过程域的改善具有重要作用的一组条件<br> 专用目标是用于描述满足该过程域必须呈现的一些独有特征。经可以用于帮助确定一个过程域是否得以满足。<br> 共用目标用于描述产现制度化的该过程必须呈现的特征，仅用于确定一个过程域是否得以满足。</p></li></ol><h3 id="CMMI的模型部件"><a href="#CMMI的模型部件" class="headerlink" title="CMMI的模型部件"></a>CMMI的模型部件</h3><table><thead><tr><th align="center">过程域类名</th><th align="left">包括的过程域</th></tr></thead><tbody><tr><td align="center">项目管理类</td><td align="left">项目规划<br/>项目监控<br/>定量项目管理<br/>集成项目管理<br/>风险管理<br/>提供方协议管理</td></tr><tr><td align="center">工程类</td><td align="left">需求开发<br/>需求管理<br/>技术解决方案<br/>产品集成<br/>确认<br/>验证</td></tr><tr><td align="center">支持类</td><td align="left">配置管理<br/>过程和产品质量保证<br/>测量与分析<br/>原因分析与解决<br/>决策分析与解决</td></tr><tr><td align="center">过程管理类</td><td align="left">组织过程定义<br/>组织过程性能<br/>组织过程培训<br/>组织过程关注<br/>组织创新与部署</td></tr></tbody></table><h3 id="CMMI的等级"><a href="#CMMI的等级" class="headerlink" title="CMMI的等级"></a>CMMI的等级</h3><ol><li><p>能力等级的组成</p><p> 能力等级是用来表征组织对一个过程域的改善，是不断改善一个给定过程域的一种手段。在CMMI中，针对每个过程域设定了6个能力等级，即0级：未完成级；1级：已执行级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：待续优化级。</p></li><li><p>成熟度等级的组成</p><p> 在CMMI中，应用于一个组织过程改善的成熟度等级有5个。即1级：初始级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：持续优化级</p></li><li><p>能力等级与成熟度等级之间的基本关系</p><ol><li>能力等级与成熟度等级是互补的关系，两者都是一种过程改善路径，即表征组织对单一过程域的改进。</li><li>成熟度等级的路径可使组织针对单一过程域不断改善一组相关过程域，即表征组织对一组过程域的改进。</li><li>两种等级的2-5级使用了同样的名字</li></ol></li><li><p>达到各共用目标要实施的共同实践</p><p> 达到公用目标2、共用目标3、共用目标4和共用目标5所要实施的共同实践如下表所示</p></li></ol><table><thead><tr><th align="center"></th><th align="center">所要实施的共用实践</th></tr></thead><tbody><tr><td align="center">共用目标2：把过程制度化为一个管理过程</td><td align="center">GP2.1 建立组织策略<br/>GP2.2 规划过程<br/>GP2.3 提供资源<br/>GP2.4 指派责任<br/>GP2.5 培训人员<br/>GP2.6 管理配置<br/>GP2.7 标识相关利益方的参与<br/>GP2.8 监控过程<br/>GP2.9 客观地评估符合性<br/>GP2.10 从高层管理的视觉评审状态<br/></td></tr><tr><td align="center">共用目标3：把过程制度化为一个已定义过程</td><td align="center">GP3.1 建立一个已定义的过程<br/>GP3.2 收信进信息 所要实施的共用实践</td></tr><tr><td align="center">共用目标4：把过程制度化为一个已定量管理过程</td><td align="center">GP4.1 为该过程建立定量目的<br/>GP4.2 使子过程性能达到稳定</td></tr><tr><td align="center">共用目标5：把过程制度化为一个持续优化过程</td><td align="center">GP5.1 确保不断进行过程改善<br/>GP5.2 收集问题的根本原因</td></tr></tbody></table><p>完结</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何管理一个项目，这是个沉重的话题。实际上，目前很多人都是凭借经验进行项目管理和开发，事实上管理项目是有着大量的方法论，这些方法论整理起来被人归纳成了一个学科，名字叫做&lt;code&gt;软件工程&lt;/code&gt;，接下来的内容将会归纳总结里面的一些要点，如果你有意成为一个项目管理者，请必须了解一下这些基础知识。&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://www.arclin.cn/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>C++基础</title>
    <link href="https://www.arclin.cn/post/f9a964a9.html"/>
    <id>https://www.arclin.cn/post/f9a964a9.html</id>
    <published>2019-10-15T05:17:00.000Z</published>
    <updated>2021-06-06T18:52:24.960Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS开发过程中，有时候会用到一些C++的库，为了避免大家用到这种库的时候一脸懵逼，这里总结一些基础知识，不写C++没关系，起码当库出了什么问题的时候至少能看懂逻辑（或许吧）。</p><p>这里全部都是基础语法知识，没事的时候可以看看熟悉一下。</p><span id="more"></span><h2 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h2><p>略</p><p>还是简单说一下：<code>.</code>是对象访问属性的操作符，<code>-&gt;</code>是指针访问指针属性的操作符，<br><code>(*a).b</code>=&gt;<code>a-&gt;b</code></p><h2 id="权限访问"><a href="#权限访问" class="headerlink" title="权限访问"></a>权限访问</h2><p>public:   可以被任意实体访问</p><p>protected:只允许子类及本类的成员函数访问</p><p>private:只允许本类的成员函数访问</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>跟Swift差不多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int func (int a , int b &#x3D; 10, int c &#x3D; 10); &#x2F;&#x2F; 声明中有默认参数，实现中不能有默认参数，比如下面这么写就会报错</span><br><span class="line">&#x2F;&#x2F; 声明和实现只能其中一个有默认参数</span><br><span class="line">int func (int a , int b &#x3D; 10, int c &#x3D; 10) &#123; &#x2F;&#x2F; 形参默认值，当b有默认值的时候，后面的参数都需要有默认值，不能b有c没有，但是可以c有b没有</span><br><span class="line"> return a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="占位参数（没啥用）"><a href="#占位参数（没啥用）" class="headerlink" title="占位参数（没啥用）"></a>占位参数（没啥用）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func(int a,int &#x3D; 0) &#123; &#x2F;&#x2F; 占位参数可以有默认参数，也可以没有</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(1,2);</span><br></pre></td></tr></table></figure><p>其实主要是用与兼容C语言的不规范写法，因为在C语言中，传参个数可以比函数声明的参数个数还多，比如<code>func(1,2,3,4,5)</code>,会警告但是不会报错，但是C++这么写就会报错，所以为了兼容C语言的调用方式，就用占位参数，占个位但是不用它，这样子就不会报错。</p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>同一个作用域，函数名相同，参数个数不同/类型不同/顺序不同</p><p><strong>函数的返回值不可以作为函数重载的条件</strong></p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;&#125;</span><br><span class="line">void func(int a) &#123;&#125;</span><br><span class="line">void func(double a) &#123;&#125;</span><br><span class="line">void func(int a, double b) &#123;&#125;</span><br><span class="line">void func(double a, int b) &#123;&#125;</span><br><span class="line">int func() &#123;&#125; &#x2F;&#x2F; 这个会报错</span><br></pre></td></tr></table></figure><h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 引用作为重载的条件</span><br><span class="line">void func(int &amp;a) &#123; &#x2F;&#x2F; 方法1</span><br><span class="line">cout &lt;&lt; &quot;func(int &amp;a)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void func(cont int &amp;a) &#123;  &#x2F;&#x2F; 方法2</span><br><span class="line">cout &lt;&lt; &quot;func(cont int &amp;a)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a &#x3D; 10;</span><br><span class="line">func(a); &#x2F;&#x2F; 方法1</span><br><span class="line"></span><br><span class="line">func(10); &#x2F;&#x2F; 方法2 因为 const int &amp;a &#x3D; 10; 合法，int &amp;a &#x3D; 10; 不合法</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数重载碰到默认参数</span><br><span class="line">void func2(int a) &#123;</span><br><span class="line">cout &lt;&lt; &quot;func2(int a)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func2(int a,int b &#x3D; 10) &#123;</span><br><span class="line">cout &lt;&lt; &quot;func2(int a, int b)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func2(10); &#x2F;&#x2F; 出现歧义（二义性），两个方法都能走，报错，所以建议函数重载的时候不要带默认参数</span><br></pre></td></tr></table></figure><h2 id="struct-和-class-的区别"><a href="#struct-和-class-的区别" class="headerlink" title="struct 和 class 的区别"></a>struct 和 class 的区别</h2><p><code>struct</code>默认权限为<code>public</code><br><code>class</code>默认权限为<code>private</code></p><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person() &#123;</span><br><span class="line">       cout &lt;&lt; &quot;默认构造函数：系统会默认生成&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Person(int age) &#123;</span><br><span class="line">cout &lt;&lt; &quot;带参数构造函数，写了这个系统就不生成无参构造函数&quot; &lt;&lt; endl;</span><br><span class="line">this-&gt;_age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(int age) : _height(15) &#123;</span><br><span class="line">cout &lt;&lt; &quot;初始化部分参数的构造函数&quot; &lt;&lt; endl;</span><br><span class="line">this-&gt;_age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(int age, int height) : _height(height) &#123;</span><br><span class="line">cout &lt;&lt; &quot;初始化部分参数的构造函数,并且顺便赋值了_height属性&quot; &lt;&lt; endl;</span><br><span class="line">this-&gt;_age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person(const Person &amp;person) &#123;</span><br><span class="line">cout &lt;&lt; &quot;浅拷贝函数：系统会默认生成&quot; &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F; 如果要深拷贝的话自己手动生成、赋值对象属性。</span><br><span class="line">&#x2F;&#x2F;如果自己写拷贝构造函数的话，系统不提供其他普通构造函数（有&#x2F;无参）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Person() &#123;</span><br><span class="line">       cout&lt;&lt;&quot;析构函数：系统默认生成&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;int age; &#x2F;&#x2F; 不建议使用跟形参同名的成员变量</span><br><span class="line">int _age; &#x2F;&#x2F; 带个下划线吧</span><br><span class="line">int _height;</span><br><span class="line">SomeClass property; &#x2F;&#x2F; 别的类的属性：构造时会优先进入该类构造函数，析构时会优先进入Person的析构函数，再走这个类的析构函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">Person p1; &#x2F;&#x2F; 这样子就实例化了</span><br><span class="line">Person p2(11); &#x2F;&#x2F; age &#x3D; 11</span><br><span class="line">Person p3(11,160); &#x2F;&#x2F; age &#x3D; 11 height &#x3D; 160</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链式调用函数"><a href="#链式调用函数" class="headerlink" title="链式调用函数"></a>链式调用函数</h2><p>在上面的Person类内加多这么一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Person&amp; addAge(Person &amp;p) &#123;</span><br><span class="line">this-&gt;_age +&#x3D; p._Age;</span><br><span class="line">return *this; &#x2F;&#x2F; 返回当前对象指针！！！</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person pp(20);</span><br><span class="line">Person pp2(10);</span><br><span class="line">pp.addAge(pp2).addAge(pp2).addAge(pp2); &#x2F;&#x2F; 爽快地链式调用</span><br></pre></td></tr></table></figure><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">static void func() &#123;</span><br><span class="line">cout &lt;&lt; &quot;静态方法只能访问静态常量&quot; &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int test;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">Person p;</span><br><span class="line">p.func(); &#x2F;&#x2F; 可以这么调</span><br><span class="line">Person::func(); &#x2F;&#x2F; 也可以通过类名直接调</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常函数和常对象"><a href="#常函数和常对象" class="headerlink" title="常函数和常对象"></a>常函数和常对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">void funcA() const &#123;</span><br><span class="line">&#x2F;&#x2F;this-&gt;_name &#x3D; &quot;test&quot;;  常函数不可以访问普通成员属性</span><br><span class="line">this-&gt;_age &#x3D; 1; &#x2F;&#x2F;常函数可以访问被mutable修饰的成员属性</span><br><span class="line">&#125;</span><br><span class="line">string _name;</span><br><span class="line">mutable int _age;</span><br><span class="line"></span><br><span class="line">void funcB() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">const Person p;</span><br><span class="line">&#x2F;&#x2F;p.funcB(); &#x2F;&#x2F; 常对象不能访问普通函数</span><br><span class="line">p.funcA(); &#x2F;&#x2F; 常对象只能访问常函数</span><br><span class="line">reutrn 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在类外部实现函数"><a href="#在类外部实现函数" class="headerlink" title="在类外部实现函数"></a>在类外部实现函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public: &#x2F;&#x2F; 需要是public函数才可以这么玩</span><br><span class="line">Person(); &#x2F;&#x2F; 要在外部实现的都得事先声明</span><br><span class="line">void test();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person::Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Person::test() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>友元函数可以访问被<code>private</code>修饰的属性</p><h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Building &#123;</span><br><span class="line">    &#x2F;&#x2F; 友元函数 可以访问私有属性</span><br><span class="line">    friend void visitor(Building &amp;building);</span><br><span class="line">public:</span><br><span class="line">    Building() &#123;</span><br><span class="line">        m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class="line">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line">private:</span><br><span class="line">    string m_Bedroom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void visitor(Building &amp;building) &#123;</span><br><span class="line">cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_Bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>顺带一提：如果入参是引用的话（<code>&amp;building</code>）,那么可以直接通过点语法访问成员属性，如果入参是指针的话（<code>*building</code>），那么就通过<code>-&gt;</code>访问，如（building-&gt;m_Bedroom）</p></blockquote><blockquote><p>顺带再提，两种函数声明和调用方式的不同</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void visitor(Building &amp;building) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_SittingRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void visitor2(Building *building) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    Building building;  &#x2F;&#x2F; 生成对象</span><br><span class="line">    visitor(building);  &#x2F;&#x2F; 直接传对象</span><br><span class="line">    visitor2(&amp;building); &#x2F;&#x2F; 传对象地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Building &#123;</span><br><span class="line">    friend class Visitor; &#x2F;&#x2F; 这个类下的所有函数都可以访问它的私有属性</span><br><span class="line">public:</span><br><span class="line">    Building() &#123;</span><br><span class="line">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    string m_Bedroom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Visitor</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Visitor() &#123;</span><br><span class="line">building &#x3D; new Building;</span><br><span class="line">&#125;</span><br><span class="line">void visit();</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Visitor::visit() &#123;</span><br><span class="line">cout &lt;&lt; building-&gt;m_Bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">Visitor v;</span><br><span class="line">v.visit();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="成员函数做友元函数"><a href="#成员函数做友元函数" class="headerlink" title="成员函数做友元函数"></a>成员函数做友元函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class Visitor</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Visitor();</span><br><span class="line">    void visit();</span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Building &#123;</span><br><span class="line">    friend void Visitor::visit(); &#x2F;&#x2F; 指定Visitor的visit成员函数可以访问私有属性</span><br><span class="line">public:</span><br><span class="line">    Building() &#123;</span><br><span class="line">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    string m_Bedroom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为什么这个构造函数要写外面，不能写里面？</span><br><span class="line">&#x2F;&#x2F; 因为Visitor需要在Building上面定义，不然不给定义Visitor上的友元函数，然后因为Visitor内有Building的属性，所以要声明一下class Building; 但是因为只是声明没有实现，所以就不能new Building;了，那就只能把这个通过类外实现的方式写在Building定义的下面。</span><br><span class="line">Visitor::Visitor() &#123;  </span><br><span class="line">    building &#x3D; new Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Visitor::visit() &#123;</span><br><span class="line">    cout &lt;&lt; building-&gt;m_Bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Visitor v;</span><br><span class="line">    v.visit();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>跟Swift差不多</p><h3 id="成员函数的运算符重载"><a href="#成员函数的运算符重载" class="headerlink" title="成员函数的运算符重载"></a>成员函数的运算符重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    Animal operator + (Animal &amp;a) &#123;</span><br><span class="line">        Animal temp;</span><br><span class="line">        temp.m_A &#x3D; this -&gt; m_A + a.m_A;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    int m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal a;</span><br><span class="line">a.m_A &#x3D; 1;</span><br><span class="line">Animal b;</span><br><span class="line">b.m_A &#x3D; 2;</span><br><span class="line">Animal c &#x3D; a + b;</span><br><span class="line">cout &lt;&lt; c.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 3</span><br></pre></td></tr></table></figure><p>本质：<code>Animal c = a.operator+(b);</code></p><h3 id="全局函数的运算符重载"><a href="#全局函数的运算符重载" class="headerlink" title="全局函数的运算符重载"></a>全局函数的运算符重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Animal operator - (Animal &amp;a, Animal &amp;b) &#123;</span><br><span class="line">    Animal temp;</span><br><span class="line">    temp.m_A &#x3D; a.m_A - b.m_A;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal a;</span><br><span class="line">a.m_A &#x3D; 1;</span><br><span class="line">Animal b;</span><br><span class="line">b.m_A &#x3D; 2;</span><br><span class="line">Animal c &#x3D; a - b;</span><br><span class="line">cout &lt;&lt; c.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 -1</span><br></pre></td></tr></table></figure><p>本质：<code>Animal c = operator-(a,b);</code></p><h3 id="运算符重载也可以发生函数重载"><a href="#运算符重载也可以发生函数重载" class="headerlink" title="运算符重载也可以发生函数重载"></a>运算符重载也可以发生函数重载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Animal operator + (int a, Animal &amp;b) &#123;</span><br><span class="line">    Animal temp;</span><br><span class="line">    temp.m_A &#x3D; a + b.m_A;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line">Animal a;</span><br><span class="line">a.m_A &#x3D; 1;</span><br><span class="line">Animal d &#x3D; 10 + a;</span><br><span class="line">cout &lt;&lt; d.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 11</span><br></pre></td></tr></table></figure><p>本质：<code>Animal d = operator+(10,a);</code></p><h3 id="左移运算符重载（比较常见输出对象细节）"><a href="#左移运算符重载（比较常见输出对象细节）" class="headerlink" title="左移运算符重载（比较常见输出对象细节）"></a>左移运算符重载（比较常见输出对象细节）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class MyInteger &#123;</span><br><span class="line">    friend ostream&amp; operator&lt;&lt;(ostream&amp; cout,MyInteger myInt);</span><br><span class="line">public:</span><br><span class="line">    MyInteger() &#123;</span><br><span class="line">        this-&gt;my_int &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int my_int;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 必须是全局函数重载 ostream是cout的类型，为了能链式调用所以返回引用ostream&amp;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; cout,MyInteger myInt) &#123;</span><br><span class="line">    cout &lt;&lt; myInt.my_int; &#x2F;&#x2F; 返回对象细节</span><br><span class="line">    return cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyInteger myInt;</span><br><span class="line">    cout &lt;&lt; myInt &lt;&lt; endl; &#x2F;&#x2F; 输出 my_int 的值 0</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><p>Swift经常使用，参见<code>Equable</code>，<code>Comparable</code>协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    bool operator&#x3D;&#x3D;(Person &amp;p) &#123;</span><br><span class="line">        if (this-&gt;m_Name &#x3D;&#x3D; p.m_Name) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!&#x3D;(Person &amp;p) &#123;</span><br><span class="line">        if (this-&gt;m_Name !&#x3D; p.m_Name) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">string m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">Person p1; p1.m_Name &#x3D; &quot;A&quot;;</span><br><span class="line">    Person p2; p2.m_Name &#x3D; &quot;A&quot;;</span><br><span class="line">    if (p1 &#x3D;&#x3D; p2) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Equal&quot; &lt;&lt; endl; &#x2F;&#x2F; 输出</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Different&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (p1 !&#x3D; p2) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Different&quot; &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Equal&quot; &lt;&lt; endl; &#x2F;&#x2F; 输出</span><br><span class="line">    &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数调用运算符的重载（骚操作）"><a href="#函数调用运算符的重载（骚操作）" class="headerlink" title="函数调用运算符的重载（骚操作）"></a>函数调用运算符的重载（骚操作）</h3><p>因为用起来很像函数，所以又叫做仿函数，STL里相当多这种骚操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyInteger &#123;</span><br><span class="line">int operator()(int a,int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F; MyInteger() ：匿名对象</span><br><span class="line">    int result &#x3D; MyInteger()(1,2);</span><br><span class="line"></span><br><span class="line">    MyInteger i;</span><br><span class="line">    int result2 &#x3D; i(5,2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;  &#x2F;&#x2F; 5</span><br><span class="line">    cout &lt;&lt; result2 &lt;&lt; endl; &#x2F;&#x2F; 7</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>C++有多继承，灰常厉害</p><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>三种继承方式<code>public</code>,<code>protected</code>,<code>private</code>，决定着继承下来的属性和方法以什么形式修饰，<code>class</code>默认<code>private</code>,<code>struct</code>默认<code>public</code>（没错，C++中结构体可以被继承）<br>父类的所有非静态属性会被继承，包括<code>private</code>类型的，但是<code>private</code>类型的默认隐藏，子类无法访问。</p><p>继承语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class SubClass : public SuperClass &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h3><p>父类先构造，子类先析构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">superClass()</span><br><span class="line">subClass()</span><br><span class="line">~subClass()</span><br><span class="line">~superClass()</span><br></pre></td></tr></table></figure><h3 id="同名属性-函数-静态属性-静态函数的访问"><a href="#同名属性-函数-静态属性-静态函数的访问" class="headerlink" title="同名属性/函数/静态属性/静态函数的访问"></a>同名属性/函数/静态属性/静态函数的访问</h3><p>假如子类和父类拥有相同的名字的属性/函数/静态属性/静态函数，则直接调用子类对象的话都是访问子类的，如果要访问父类的话要添加作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    int _a &#x3D; 1;</span><br><span class="line">    static int _b;</span><br><span class="line">    static void staticFunc() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base staticFunc()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Func() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base Func()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int Base::_b &#x3D; 10; &#x2F;&#x2F; 静态成员变量要在外面赋值</span><br><span class="line"></span><br><span class="line">class Sub1 : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    int _a &#x3D; 2;</span><br><span class="line">    static int _b;</span><br><span class="line">    static void staticFunc() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;SubClass staticFunc()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Func() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;SucClass Func()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int Sub1::_b &#x3D; 20;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    Sub1 s;</span><br><span class="line">    &#x2F;&#x2F; 直接调用</span><br><span class="line">    cout &lt;&lt; s._a &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; 调用父类的</span><br><span class="line">    cout &lt;&lt; s.Base::_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 静态直接调用</span><br><span class="line">    cout &lt;&lt; s._b &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; 静态调用父类的</span><br><span class="line">    cout &lt;&lt; s.Base::_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 静态直接调用</span><br><span class="line">    cout &lt;&lt; Sub1::_b &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; 静态调用父类的</span><br><span class="line">    cout &lt;&lt; Sub1::Base::_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 直接调用</span><br><span class="line">    s.Func();</span><br><span class="line">    &#x2F;&#x2F; 调用父类的</span><br><span class="line">    s.Base::Func();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 静态直接调用</span><br><span class="line">    s.staticFunc();</span><br><span class="line">    &#x2F;&#x2F; 静态调用父类的</span><br><span class="line">    s.Base::staticFunc();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 静态直接调用</span><br><span class="line">    Sub1::staticFunc();</span><br><span class="line">    &#x2F;&#x2F; 静态调用父类的</span><br><span class="line">    Sub1::Base::staticFunc();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>不建议使用，因为麻烦事多</p><p>语法：(参照上面的代码)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Other &#123;</span><br><span class="line">public:</span><br><span class="line">    void Func() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Ohter Func()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;...略</span><br><span class="line">class Sub1 : public Base , public Other &#123;</span><br><span class="line">&#x2F;&#x2F;...略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当多个父类中出现同名属性/方法时，需要加作用域指定父类<code>s.Base::Func(); / s.Other::Func();</code></p><h3 id="菱形继承（钻石继承）"><a href="#菱形继承（钻石继承）" class="headerlink" title="菱形继承（钻石继承）"></a>菱形继承（钻石继承）</h3><p>两个子类继承同一个基类，<br>又有某个类同时继承着两个子类</p><p>举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123; int age &#125;;</span><br><span class="line"></span><br><span class="line">class Sub1: public Base &#123;&#125;;</span><br><span class="line">class Sub2: public Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">class SubSub: public Sub1, public Sub2 &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这时候SubSub会有两个父类，有两份 age 属性，造成资源浪费</p><p>这时候用虚继承(<code>virtual</code>)解决问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123; public: int age &#125;; &#x2F;&#x2F; 这时候成为虚基类</span><br><span class="line"></span><br><span class="line">class Sub1: virtual public Base &#123;&#125;;</span><br><span class="line">class Sub2: virtual public Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">class SubSub: public Sub1, public Sub2 &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这时候age属性成为共享属性，最后谁改了就是谁的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SubSub s;</span><br><span class="line">s.Sub1::age &#x3D; 1;</span><br><span class="line">s.Sub2::age &#x3D; 10;</span><br><span class="line">cout &lt;&lt; s.Sub1::age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br><span class="line">cout &lt;&lt; s.Sub2::age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br><span class="line">cout &lt;&lt; s.age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>C++中，多态分两类</p><p>静态多态：函数重载和运算符重载属于静态多态，复用函数名<br>动态多态：子类和虚函数实现运行时多态</p><p>区别：</p><p>静态多态的函数地址早绑定，编译阶段确定函数地址<br>动态多态的函数地址晚绑定，运行阶段确定函数地址</p><p>动态多态满足条件：</p><ol><li>有继承关系</li><li>子类重写父类虚函数</li></ol><p>动态多态使用<br>父类的指针或者引用指向子类对象</p><p>静态多态举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void speak() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Animal Speak&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Cat: public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void speak() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Cat Speak&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void SomeoneSpeak(Animal &amp;animal) &#123;</span><br><span class="line">    animal.speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Cat c;</span><br><span class="line">    SomeoneSpeak(c); &#x2F;&#x2F; 由于SomeoneSpeak(Animal &amp;animal)，编译期间已经确定入参类型，所以输出 Animal Speak</span><br></pre></td></tr></table></figure><p>如果想输出<code>Cat Speak</code>，只需进行如下修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void speak() &#123; &#x2F;&#x2F; 虚函数，可以告知由于SomeoneSpeak(Animal &amp;animal)运行时再确定入参类型</span><br><span class="line">        cout &lt;&lt; &quot;Animal Speak&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经常地，这种情况下也是动态多态，最后会输出<code>Cat Speak</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal *a &#x3D; new Cat;</span><br><span class="line">a-&gt;speak();</span><br></pre></td></tr></table></figure><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>父类的虚函数的实现没什么意义，所以上面的虚函数代码改写为<code>纯虚函数</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual void speak() &#x3D; 0;</span><br></pre></td></tr></table></figure><p>当类中有了纯虚函数，则这个类称为<code>抽象类</code></p><p>抽象类<strong>无法实例化对象</strong>，并且<strong>子类必须重写父类的纯虚函数</strong>，否则也成为<code>抽象类</code></p><h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>当子类在堆区创建数据的时候，需要手动释放，父类需要添加虚析构或者纯虚析构函数，否则子类可能不走析构函数</p><p>比如上面的<code>Animate</code>父类，我们补充一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ~Animal() &#x3D; 0; &#x2F;&#x2F; 纯虚析构</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~Animal() &#123; &#x2F;&#x2F; 析构实现</span><br><span class="line">    cout &lt;&lt; &quot;Animal is Delete&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>文件打开方式</p><p><code>ios::in</code>:读文件<br><code>ios::out</code>:写文件<br><code>ios::ate</code>:初始位置，文件尾<br><code>ios:app</code>:追加写文件<br><code>ios:trunc</code>:如果文件存在先删除，再创建<br><code>ios:binary</code>:二进制方式</p><p>同时两种方式则使用<code>|</code>的方式，比如<code>ios::in|ios:binary</code></p><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ofstream stream;</span><br><span class="line"></span><br><span class="line">stream.open(&quot;Test.txt&quot;,ios::out);</span><br><span class="line"></span><br><span class="line">stream &lt;&lt; &quot;Line 1&quot; &lt;&lt; endl;</span><br><span class="line">stream &lt;&lt; &quot;Line 2&quot; &lt;&lt; endl;</span><br><span class="line">stream &lt;&lt; &quot;Line 3&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">stream.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(&quot;Test.txt&quot;,ios::out);</span><br><span class="line"></span><br><span class="line">if(!ifs.is_open()) &#123;</span><br><span class="line">cout &lt;&lt; &quot;打开文件失败&quot; &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string buf;</span><br><span class="line">while (getline(ifs, buf)) &#123; &#x2F;&#x2F; 一行行读取</span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.close();</span><br></pre></td></tr></table></figure><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h3 id="构建类模板与类模板做参数"><a href="#构建类模板与类模板做参数" class="headerlink" title="构建类模板与类模板做参数"></a>构建类模板与类模板做参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class NameType,class AgeType&gt;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    Person(NameType name, AgeType age) &#123;</span><br><span class="line">        this-&gt;_age &#x3D; age;</span><br><span class="line">        this-&gt;_name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    AgeType _age;</span><br><span class="line">    NameType _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不会自动类型推导，需要自己显式声明类型</span><br><span class="line">    Person&lt;string,int&gt; p(&quot;Haha&quot;,123);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; p._name &lt;&lt; &quot; &quot; &lt;&lt; p._age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以给类模板添加默认类型</p><p><code>template&lt;class NameType,class AgeType = int&gt;</code></p><p>这样子调用的时候就可以不全声明类型了</p><p><code>Person&lt;string&gt; p(&quot;Haha&quot;,123);</code></p><p>类模板做参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 指定类型的类模板做参数</span><br><span class="line">void print(Person&lt;string,int&gt; &amp;p) &#123;</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模板化参数的类模板做参数</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">void print2(Person&lt;T1, T2&gt; &amp;p) &#123;</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模板化类做参数</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void print3(T &amp;p) &#123;</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Person&lt;string,int&gt; p(&quot;Haha&quot;,123);</span><br><span class="line">    print(p);</span><br><span class="line">    print2(p);</span><br><span class="line">    print3(p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h3><p>继承时需要指定类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SubClass: public Base&lt;int&gt; &#123; &#x2F;&#x2F; 指定T的类型</span><br><span class="line">public:</span><br><span class="line">    void print() &#123;</span><br><span class="line">        cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果不想指定类型，那么可以模板化子类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class SubClass: public Base&lt;T1&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    SubClass(T1 a, T2 b) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    T2 k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">SubClass&lt;string, int&gt; c(&quot;String&quot;,1);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STL-之-Vector容器"><a href="#STL-之-Vector容器" class="headerlink" title="STL 之 Vector容器"></a>STL 之 Vector容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v1; &#x2F;&#x2F; 初始化指定容器内元素类型</span><br><span class="line">v1.assign(10, 1); &#x2F;&#x2F; 插入10个1，也可以传入其他vector,比如v1.assign(v0.begin,v0.end); 或者直接 v1 &#x3D; v0; 只要保证是同种类型就好</span><br><span class="line">for (vector&lt;int&gt;::iterator i &#x3D; v1.begin(); i !&#x3D; v1.end() ; i++) &#123;</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; endl;</span><br><span class="line">&#125; &#x2F;&#x2F; 打印10个1</span><br><span class="line">cout &lt;&lt; &quot;Size &#x3D; &quot; &lt;&lt; v1.size() &lt;&lt; endl; &#x2F;&#x2F; 长度 10</span><br><span class="line">cout &lt;&lt; &quot;isEmpty &#x3D; &quot; &lt;&lt; v1.empty() &lt;&lt; endl; &#x2F;&#x2F; 判空 0</span><br><span class="line">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 容量 10</span><br><span class="line">v1.resize(20,20); &#x2F;&#x2F; 调整容量为20，多出来的位置用20填充，这里的20可以不传，默认0</span><br><span class="line">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 现在容量变成20</span><br><span class="line"></span><br><span class="line">v1.pop_back(); &#x2F;&#x2F; 删除最后一个元素</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;Size &#x3D; &quot; &lt;&lt; v1.size() &lt;&lt; endl; &#x2F;&#x2F; 长度 19</span><br><span class="line">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 容量不变 20</span><br><span class="line"></span><br><span class="line">v1.insert(v1.begin() + 1, 199); &#x2F;&#x2F; 下标为1的位置插入元素199</span><br><span class="line">v1.insert(v1.begin() + 1, 2, 199); &#x2F;&#x2F; 下标为1的位置插入两个元素199</span><br><span class="line">v1.erase(v1.begin() + 2); &#x2F;&#x2F; 删除第二个元素</span><br><span class="line">v1.erase(v1.begin() + 2 , v1.begin() + 3); &#x2F;&#x2F; 删除第二个到第三个元素</span><br><span class="line">v1.clear(); &#x2F;&#x2F; 清空容器</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;第二个元素是&quot; &lt;&lt; v1.at(1) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;第三个元素是&quot; &lt;&lt; v1[2] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;第一个元素&quot; &lt;&lt; v1.front() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;最后一个元素&quot; &lt;&lt; v1.back() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v1.reverse(100000); &#x2F;&#x2F; 预留空间，减少以后动态拓展的次数</span><br><span class="line"></span><br><span class="line">v1.swap(v0); &#x2F;&#x2F; 交换元素，假如v1的预留空间很大，可以通过交换一个小预留空间的容器达到压缩内存的效果</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在iOS开发过程中，有时候会用到一些C++的库，为了避免大家用到这种库的时候一脸懵逼，这里总结一些基础知识，不写C++没关系，起码当库出了什么问题的时候至少能看懂逻辑（或许吧）。&lt;/p&gt;
&lt;p&gt;这里全部都是基础语法知识，没事的时候可以看看熟悉一下。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://www.arclin.cn/categories/C/"/>
    
    
    <category term="C++" scheme="https://www.arclin.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>iOS12 新玩具ShortCut(捷径)使用</title>
    <link href="https://www.arclin.cn/post/0.html"/>
    <id>https://www.arclin.cn/post/0.html</id>
    <published>2018-09-28T05:05:00.000Z</published>
    <updated>2021-06-06T18:52:24.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>升级iOS12之后可以在<code>设置-Siri</code>与搜索 中发现一个 <code>捷径</code> 功能, 所谓ShortCut就是其英文翻译<br>其作用就是让用户自定义一个一句话或者短语, 然后可以触发app做一系列动作</p><span id="more"></span><h3 id="接入"><a href="#接入" class="headerlink" title="接入"></a>接入</h3><p>ShortCut分为两种, 一种是在手机的<code>Spotlight</code>上搜索某个关键字的时候可以搜索到你的app, 这个关键字就是ShortCut的一种(文字输入), 你需要使用<code>NSUserActivity</code>去实现这个功能</p><blockquote><p>依赖 <code>CoreSpotlight</code> <code>CoreServices</code></p></blockquote><p>另外一种叫做 <code>Intent</code>(语音输入), 需要添加一个IntentExtension和IntentExtensionUI, 然后在主Target添加一个intentdefinition文件, 详细的配置大家可以参考<br><a href="https://juejin.im/post/5b2077d8f265da6e45549c68">文章1</a><br><a href="http://www.cnblogs.com/czjie2010/p/czjie.html">文章2</a></p><blockquote><p>依赖<code>Intents</code> <code>IntentsUI</code></p></blockquote><h3 id="最简单的配置操作步骤"><a href="#最简单的配置操作步骤" class="headerlink" title="最简单的配置操作步骤"></a>最简单的配置操作步骤</h3><ol><li><p>项目的<code>Capabilities</code>打开<code>Siri</code></p></li><li><p>授权</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">if (@available(iOS 10.0, *)) &#123;</span><br><span class="line">[INPreferences requestSiriAuthorization:^(INSiriAuthorizationStatus status) &#123;</span><br><span class="line">switch (status) &#123;</span><br><span class="line">case INSiriAuthorizationStatusNotDetermined:</span><br><span class="line">NSLog(@&quot;用户尚未对该应用程序作出选择。&quot;);</span><br><span class="line">break;</span><br><span class="line">case INSiriAuthorizationStatusRestricted:</span><br><span class="line">NSLog(@&quot;此应用程序无权使用Siri服务&quot;);</span><br><span class="line">break;</span><br><span class="line">case INSiriAuthorizationStatusDenied:</span><br><span class="line">NSLog(@&quot;用户已明确拒绝此应用程序的授权&quot;);</span><br><span class="line">break;</span><br><span class="line">case INSiriAuthorizationStatusAuthorized:</span><br><span class="line">NSLog(@&quot;用户可以使用此应用程序的授权&quot;);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>新建一个<code>intentdefinition</code>，比如<code>A.intentdefinition</code></li><li>新建一个<code>Target</code>,<code>Intent Extension</code>有需要的话把<code>Intent UI Extension</code>也加上，<code>General</code>中配置相关证书</li><li>进入<code>A.intentdefinition</code>，界面左下角<code>+</code>号点一下，点击<code>new intent</code></li><li>界面右边<code>Target Membership</code>，把<code>步骤2</code>中新增的<code>Target</code>给勾上</li><li> 界面中间<code>Title</code>填写需要展示的标题，<code>Descripion</code> 写描述</li><li>Build一下，系统自动生成头文件，头文件名字在界面右测的导航页的第三个按钮的<code>Custom Class</code>里</li><li>找个控制器，导入<code>步骤8</code>生成的头文件，添加个按钮，比如</li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.navigationItem.rightBarButtonItem &#x3D; [[UIBarButtonItem alloc] initWithTitle:@&quot;捷径&quot; style:UIBarButtonItemStylePlain target:self action:@selector(siri:)];</span><br></pre></td></tr></table></figure></li><li><p>点击按钮召唤添加Shortcut的控制器</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)siri:(UIBarButtonItem *)item &#123;</span><br><span class="line">    if (@available(iOS 12.0, *)) &#123;</span><br><span class="line">     &#x2F;&#x2F; 这个类名具体看你生成了叫什么名字的头文件</span><br><span class="line">        ZeRiIntent *intent &#x3D; [[ZeRiIntent alloc] init];</span><br><span class="line">        intent.suggestedInvocationPhrase &#x3D; @&quot;打开xxx&quot;; &#x2F;&#x2F; 引导用户说的语句</span><br><span class="line">        INShortcut *shortCur &#x3D; [[INShortcut alloc] initWithIntent:intent];</span><br><span class="line">        INUIAddVoiceShortcutViewController *vc &#x3D; [[INUIAddVoiceShortcutViewController alloc] initWithShortcut:shortCur];</span><br><span class="line">        vc.delegate &#x3D; self;</span><br><span class="line">        [self presentViewController:vc animated:YES completion:nil];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Fallback on earlier versions</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同个地方实现代理方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - INUIAddVoiceShortcutViewControllerDelegate</span><br><span class="line">- (void)addVoiceShortcutViewControllerDidCancel:(INUIAddVoiceShortcutViewController *)controller  API_AVAILABLE(ios(12.0))&#123;</span><br><span class="line">[controller dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">- (void)addVoiceShortcutViewController:(INUIAddVoiceShortcutViewController *)controller didFinishWithVoiceShortcut:(INVoiceShortcut *)voiceShortcut error:(NSError *)error  API_AVAILABLE(ios(12.0))&#123;</span><br><span class="line">[controller dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>Intent</code> target中的<code>IntentHandler</code>类，导入<code>步骤8</code>生成的头文件，要是头文件找不到，在这个target的<code>info.plist</code>中<code>NSExtension</code>下的<code>IntentsSupported</code>下添加一个名为那个头文件的值，主target的<code>info.plist</code>的<code>NSUserActivityTypes</code>下也加一个一样的</p></li><li><p><code>IntentHandler.m</code>遵循协议<code>XXXIntentHandling</code>（具体协议名看你的类名），实现两个方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 用户说了那句话之后要Siri做什么事情</span><br><span class="line">- (void)handleZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion &#123;</span><br><span class="line">completion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);</span><br><span class="line">&#125;</span><br><span class="line">  &#x2F;&#x2F; 用户确认了之后要Siri做什么事情</span><br><span class="line">- (void)confirmZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion &#123;</span><br><span class="line">completion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   <code>ZeRiIntentResponseCodeContinueInApp</code>只是枚举中其中一个值，使用不同的值会有不同     效果，自己探索一下，这里的值指的是打开app(具体方法名看协议)</p></li><li><p>进入<code>AppDelegate</code>，实现方法如下，根据<code>Intent</code>类名判断用户想要的操作</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application continueUserActivity:(nonnull NSUserActivity *)userActivity restorationHandler:(nonnull void (^)(NSArray&lt;id&lt;UIUserActivityRestoring&gt;&gt; * _Nullable))restorationHandler &#123;</span><br><span class="line">if ([userActivity.activityType isEqualToString:@&quot;XXXIntent&quot;]) &#123;</span><br><span class="line">&#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结束</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;升级iOS12之后可以在&lt;code&gt;设置-Siri&lt;/code&gt;与搜索 中发现一个 &lt;code&gt;捷径&lt;/code&gt; 功能, 所谓ShortCut就是其英文翻译&lt;br&gt;其作用就是让用户自定义一个一句话或者短语, 然后可以触发app做一系列动作&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Application Loader / Fastlane pilot 通过代理上传方案</title>
    <link href="https://www.arclin.cn/post/undefined.html"/>
    <id>https://www.arclin.cn/post/undefined.html</id>
    <published>2018-08-03T08:10:07.000Z</published>
    <updated>2021-06-06T18:52:24.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Application-Loader-Fastlane-pilot-通过代理上传方案"><a href="#Application-Loader-Fastlane-pilot-通过代理上传方案" class="headerlink" title="Application Loader / Fastlane pilot 通过代理上传方案"></a>Application Loader / Fastlane pilot 通过代理上传方案</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>为了避免苹果审核马甲包情况, 我们需要通过其他IP去上传包, 这里提供几种方案并记录踩坑过程.</p><span id="more"></span><h3 id="问题解决思路"><a href="#问题解决思路" class="headerlink" title="问题解决思路"></a>问题解决思路</h3><ol><li><p>用Application Loader(后面简称uploader)上传包, 电脑使用SS, VPN会导致上传失败, 原因是uploader内部自带开启代理配置, 但是默认是关闭的,  所以需要修改内部代理配置, 路径是<code>/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/java/lib/net.properties</code>, 配置如下(1086是本地ss的端口)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.net.useSystemProxies&#x3D;true</span><br><span class="line">http.proxyHost&#x3D;127.0.0.1</span><br><span class="line">http.proxyPort&#x3D;1086</span><br><span class="line">https.proxyHost&#x3D;127.0.0.1</span><br><span class="line">https.proxyPort&#x3D;1086</span><br><span class="line">jdk.http.auth.tunneling.disabledSchemes&#x3D;Basic</span><br></pre></td></tr></table></figure></li><li><p>本来<code>net.properties</code>内是有socks代理的配置的, Shadowsocks开启socks代理后, 在配置文件中配置好ip(127.0.0.1)和端口(1086)之后测试发现无法连接到苹果服务器, 故只能选用<code>http/https</code>代理</p><blockquote><p>查询shadowsocks本地端口的方法, 执行<code>lsof -iTCP -sTCP:LISTEN -n -P | grep ss-local</code>, 就可以查到</p></blockquote></li><li><p>现在问题在于怎么将socks代理转成http/https代理, 通过查阅资料得知可以通过安装<code>privoxy</code>解决, 安装之后配置<code>/usr/local/etc/privoxy/config</code>文件, 把<code>forward-socks5t</code>那行注释掉, 加上本地socks ip和端口, 就像下面那段一样, 然后把<code>listen-address  127.0.0.1:8118</code> 改成 <code>listen-address  0.0.0.0:8118</code>就可以实现给局域网内共享你的代理.</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">forward           &#x2F;               127.0.0.1:1086 .</span><br><span class="line">forward-socks4    &#x2F;               127.0.0.1:1086 .</span><br><span class="line">forward-socks4a   &#x2F;               127.0.0.1:1086 .</span><br><span class="line">forward-socks5    &#x2F;               127.0.0.1:1086 .</span><br><span class="line">forward-socks5t   &#x2F;               127.0.0.1:1086 .</span><br></pre></td></tr></table></figure></li><li><p>打开<code>系统偏好设置-网络-高级-代理</code>, 把网页代理和安全网页代理勾上, 填上ip <code>127.0.0.1</code> 端口 <code>8118</code> , 就可以了.  这里的<code>8118</code>是刚刚说到的<code>listen-address  0.0.0.0:8118</code>里面的端口号, 要改也可以改, 记得同步就行.</p></li></ol><h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><ol><li><p>校验<code>privoxy</code>是否代理成功可以通过浏览器访问<code>http://config.privoxy.org/</code>这个网址就能看到成功与否了</p></li><li><p>执行<code>netstat -an | grep 8118</code> 查看<code>8188</code>是否全局监听着, 如果是就会看到<br> <code>tcp4       0      0  *.8118                 *.*                    LISTEN  </code>执行<code>ps aux | grep privoxy</code>, 则可以看到<code>privoxy</code>进程是否正在运行中. 可以通过<code>sudo /Applications/Privoxy/stopPrivoxy.sh</code>停止<code>privoxy</code>和<code>sudo /Applications/Privoxy/startPrivoxy.sh</code>启动<code>privoxy</code></p></li><li><p>浏览器访问<code>https://ip.cn</code>,就可以得知网页代理是否成功了</p></li><li><p>fastlane上传包实际上是调用了<code>/Applications/Xcode.app/Contents/Applications/Application\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool</code>, 也就是Xcode自带的命令行工具 , uploader就不用说了, 反正殊途同归, 最后都会根据<code>net.properties</code>去走代理,  那么问题来了 , 如何验证命令行和桌面应用uploader走的都是代理方式呢. 很遗憾苹果并不会弄出一个界面或者打印出一行log告诉你现在是用哪个ip上传, 我现在能想到的办法是通过工具查看上传过程中的流量波动, 通过实验, 两种方式再上传过程中, <code>ss-local</code>进程有过较大数据上传的流量波动(会有100k/s以上的上传流量速度), 因此我判定确实是走了代理上传包的.  如果要再证据确凿的话, 只能想办法抓包查看他的信息收集了, 但是<code>Charles</code>抓包的原理是再开一个代理, 会造成混乱….所以这就很头疼了.</p></li><li><p>开启了网页代理之后, 影响的只是网页, 实际上只是为了验证<code>Privoxy</code>的可用性, 开启之后你如果在命令行中使用<code>curl ip.cn</code>得到的结果会是你真实网络的出网ip, 而不是你想要的代理的ip, 实际上<code>uploader</code>和<code>fastlane pilot</code>命令行是否真正走了代理, 目前我只能通过<code>ss-local</code>这个代理的进程查看他的上传流量去判断, 具有一定风险. 或者通过安装命令行工具<code>proxychains</code>, 然后执行<code>proxychains4 fastlane pilot upload</code>传包, 但是这种方式100%上传失败 , 原因猜想是<code>net.properties</code>的配置没改, <code>proxychains</code>怎么转发请求都没用.  所以这是不是从某种意义上证明了<code>fastlane pilot</code>是走<code>net.properties</code>配置的呢, 至少我觉得按照目前情况可以这么认为,  后续如果有想法我会进行更多实验去证明的.</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Application-Loader-Fastlane-pilot-通过代理上传方案&quot;&gt;&lt;a href=&quot;#Application-Loader-Fastlane-pilot-通过代理上传方案&quot; class=&quot;headerlink&quot; title=&quot;Application Loader / Fastlane pilot 通过代理上传方案&quot;&gt;&lt;/a&gt;Application Loader / Fastlane pilot 通过代理上传方案&lt;/h2&gt;&lt;h3 id=&quot;需求分析&quot;&gt;&lt;a href=&quot;#需求分析&quot; class=&quot;headerlink&quot; title=&quot;需求分析&quot;&gt;&lt;/a&gt;需求分析&lt;/h3&gt;&lt;p&gt;为了避免苹果审核马甲包情况, 我们需要通过其他IP去上传包, 这里提供几种方案并记录踩坑过程.&lt;/p&gt;</summary>
    
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
  </entry>
  
</feed>
