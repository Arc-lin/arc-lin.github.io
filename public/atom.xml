<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Arclin</title>
  
  <subtitle>Advocate Technology. Enjoy Technology.</subtitle>
  <link href="https://www.arclin.cn/atom.xml" rel="self"/>
  
  <link href="https://www.arclin.cn/"/>
  <updated>2021-08-31T13:47:12.428Z</updated>
  <id>https://www.arclin.cn/</id>
  
  <author>
    <name>Arclin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS --- 性能优化</title>
    <link href="https://www.arclin.cn/post/a2ff8280.html"/>
    <id>https://www.arclin.cn/post/a2ff8280.html</id>
    <published>2021-08-31T13:42:00.000Z</published>
    <updated>2021-08-31T13:47:12.428Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍iOS内常用的性能优化方案</p><span id="more"></span><h2 id="CPU和GPU"><a href="#CPU和GPU" class="headerlink" title="CPU和GPU"></a>CPU和GPU</h2><ul><li><p>在屏幕成像的过程中，CPU和GPU起着至关重要的作用</p><ul><li>CPU <ul><li>对象的创建和销毁，对象属性的调整、布局计算、文本的计算和排版、图片格式转换和解码、图像的绘制 </li></ul></li><li>GPU<ul><li>纹理的渲染</li></ul></li></ul></li><li><p>在iOS中是双缓冲机制，有前帧缓存、后帧缓存（）</p></li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU-&gt;计算-&gt;GPU-&gt;渲染-&gt;帧缓存-&gt;读取-&gt;视频控制器-&gt;显示-&gt;屏幕   </span><br></pre></td></tr></table></figure><h2 id="屏幕成像原理"><a href="#屏幕成像原理" class="headerlink" title="屏幕成像原理"></a>屏幕成像原理</h2><p>首先先发出一个垂直同步信号（VSync），然后再一行行发出水平同步信号（HSync），直到最后一行HSync发出之后，一帧就渲染完成，然后再次发出一个VSync，渲染下一帧。</p><img src="https://i.loli.net/2021/08/31/hWqVypmfbtga4eK.png" ><h2 id="卡顿"><a href="#卡顿" class="headerlink" title="卡顿"></a>卡顿</h2><h3 id="卡顿产生的原因"><a href="#卡顿产生的原因" class="headerlink" title="卡顿产生的原因"></a>卡顿产生的原因</h3><p><img src="https://i.loli.net/2021/08/31/ZTNhbeyRiq8UgmV.png" alt="1682758-5be402cc0ab5dc56.png"></p><ol><li>首先第一个VSync进入，CPU开始计算处理，然后交给GPU渲染，然后显示到屏幕上</li><li>然后第二个VSync进入，这时候CPU处理的时间比较长，交给GPU后， GPU还没处理完，第三个VSync就进来了，但是因为GPU没处理完。第二帧还不能显示，所以这时候直接取上一帧数据显示，造成第一帧长时间停留</li><li>然后过了一段时间GPU终于处理完了，但是第四个VSync还没来，所以就等，等到第四个VSync进来了，就开始拿刚才生成好的那一帧去显示，然后开始继续第三帧的计算</li></ol><ul><li>解决卡顿的主要思路<ul><li>尽可能减少CPU、GPU资源损耗</li></ul></li><li>按照60fps的刷新率，每个16ms就会有一次VSync信号 </li></ul><h3 id="卡顿检测"><a href="#卡顿检测" class="headerlink" title="卡顿检测"></a>卡顿检测</h3><ul><li>平时所说的__卡顿__主要是因为在主线程执行了比较耗时的操作</li><li>可以添加<code>Observer</code>到主线程<code>Runloop</code>中，通过监听<code>Runloop</code>状态切换的耗时，以达到监控卡顿的目的</li></ul><blockquote><p>参考：<a href="https://github.com/UIControl/LXDAppFluecyMonitor/blob/master/LXDAppFluecyMonitor/LXDAppFluecyMonitor/LXDAppFluecyMonitor.m">LXDAppFluecyMonitor</a></p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> lxdRunLoopObserverCallback(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> * info) &#123;</span><br><span class="line">     <span class="comment">/// 更新当前Runloop状态</span></span><br><span class="line">    SHAREDMONITOR.currentActivity = activity;</span><br><span class="line">    dispatch_semaphore_signal(SHAREDMONITOR.semphore);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startMonitoring &#123;</span><br><span class="line">    <span class="keyword">if</span> (_isMonitoring) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    _isMonitoring = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">CFRunLoopObserverContext</span> context = &#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/// 创建监听对象</span></span><br><span class="line">    _observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, &amp;lxdRunLoopObserverCallback, &amp;context);</span><br><span class="line">    <span class="comment">/// 在CommonModes添加监听者</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 子线程异步串行队列中添加死循环</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(lxd_event_monitor_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">while</span> (SHAREDMONITOR.isMonitoring) &#123;</span><br><span class="line">        <span class="comment">/// 如果当前状态是BeforeWaiting（即将进入休眠）的话</span></span><br><span class="line">            <span class="keyword">if</span> (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeWaiting) &#123;</span><br><span class="line">                __block <span class="built_in">BOOL</span> timeOut = <span class="literal">YES</span>;</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    timeOut = <span class="literal">NO</span>; <span class="comment">// 即将休眠的时候回到主线程超时状态改为NO</span></span><br><span class="line">                    dispatch_semaphore_signal(SHAREDMONITOR.eventSemphore); <span class="comment">//解锁</span></span><br><span class="line">                &#125;);</span><br><span class="line">                [<span class="built_in">NSThread</span> sleepForTimeInterval: lxd_time_out_interval]; <span class="comment">// 子线程休眠一秒</span></span><br><span class="line">                <span class="keyword">if</span> (timeOut) &#123;</span><br><span class="line">                    [LXDBacktraceLogger lxd_logMain]; <span class="comment">// 打印堆栈</span></span><br><span class="line">                &#125;</span><br><span class="line">                dispatch_wait(SHAREDMONITOR.eventSemphore, DISPATCH_TIME_FOREVER); <span class="comment">// 加锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(lxd_fluecy_monitor_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">while</span> (SHAREDMONITOR.isMonitoring) &#123;</span><br><span class="line">            <span class="keyword">long</span> waitTime = dispatch_semaphore_wait(<span class="keyword">self</span>.semphore, dispatch_time(DISPATCH_TIME_NOW, lxd_wait_interval)); <span class="comment">// 等待200纳秒，看是否能拿到锁</span></span><br><span class="line">            <span class="keyword">if</span> (waitTime != LXD_SEMPHORE_SUCCESS) &#123; <span class="comment">// 拿不到锁</span></span><br><span class="line">                <span class="keyword">if</span> (!SHAREDMONITOR.observer) &#123;</span><br><span class="line">                    SHAREDMONITOR.timeOut = <span class="number">0</span>;</span><br><span class="line">                    [SHAREDMONITOR stopMonitoring];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/// Runloop 即将处理Source或者刚从休眠中唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (SHAREDMONITOR.currentActivity == kCFRunLoopBeforeSources || SHAREDMONITOR.currentActivity == kCFRunLoopAfterWaiting) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (++SHAREDMONITOR.timeOut &lt; <span class="number">5</span>) &#123; <span class="comment">// 超时次数+1，然后如果超时次数大于5次就打印堆栈</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    [LXDBacktraceLogger lxd_logMain];</span><br><span class="line">                    [<span class="built_in">NSThread</span> sleepForTimeInterval: lxd_restore_interval];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            SHAREDMONITOR.timeOut = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="卡顿优化-CPU"><a href="#卡顿优化-CPU" class="headerlink" title="卡顿优化 - CPU"></a>卡顿优化 - CPU</h3><ul><li>尽量使用轻量级的对象，比如用不到事件处理的地方，可以考虑使用<code>CALayer</code>（只是拿来渲染）取代<code>UIView</code>（渲染+处理点击事件等）</li><li>不要频繁地调用<code>UIView</code>的相关属性，比如<code>frame</code>、<code>bounds</code>、<code>transform</code>等属性，尽量减少不必要的修改</li><li>尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</li><li>Autolayout会比直接设置frame消耗更多的CPU资源</li><li>图片的Size最好跟UIImageView的size保持一致</li><li>控制一下线程的最大并发数量</li><li>尽量把耗时操作放到子线程<ul><li>文本处理（尺寸计算、绘制）</li><li>图片处理（解码、绘制）</li></ul></li></ul><p>图片子线程解码举例</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)renderImage &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">/// get CGImage</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> cgImage = [<span class="built_in">UIImage</span> imageWithData:[<span class="built_in">NSData</span> dataWithContentsOfURL:xxx]].CGImage;</span><br><span class="line">        </span><br><span class="line">        size_t width = <span class="built_in">CGImageGetWidth</span>(cgImage);</span><br><span class="line">        size_t height = <span class="built_in">CGImageGetHeight</span>(cgImage);</span><br><span class="line">        <span class="keyword">if</span> (width == <span class="number">0</span> || height == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGImageAlphaInfo</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(cgImage);</span><br><span class="line">        <span class="built_in">BOOL</span> hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</span><br><span class="line">                          alphaInfo == kCGImageAlphaNoneSkipFirst ||</span><br><span class="line">                          alphaInfo == kCGImageAlphaNoneSkipLast);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, <span class="built_in">CGColorSpaceCreateDeviceRGB</span>(), bitmapInfo);</span><br><span class="line">        <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Apply transform</span></span><br><span class="line">        <span class="built_in">CGAffineTransform</span> transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">        <span class="built_in">CGContextConcatCTM</span>(context, transform);</span><br><span class="line">        <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), cgImage); <span class="comment">// The rect is bounding box of CGImage, don&#x27;t swap width &amp; height</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> newImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">        <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// back to the main thread</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.imageView.image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:newImageRef];</span><br><span class="line">            <span class="built_in">CGImageRelease</span>(newImageRef);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="卡顿优化-GPU"><a href="#卡顿优化-GPU" class="headerlink" title="卡顿优化 - GPU"></a>卡顿优化 - GPU</h3><ul><li>尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</li><li>GPU能处理的最大纹理尺寸是<strong>4096*4096</strong>，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸</li><li>尽量减少视图数量和层次</li><li>减少透明的视图（alpha &lt; 1），不透明的就设置<code>opaque</code>为<code>YES</code></li><li>尽量避免出现离屏渲染</li></ul><h4 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h4><ul><li><p>在OpenGL中，GPU有2种渲染方式</p><ul><li>On-Screen Rendering：当前离屏渲染，在当前用于显示屏幕缓冲区进行渲染操作</li><li>Off-Screen Rendering: 离屏渲染，在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作 </li></ul></li><li><p>离屏渲染消耗性能的原因</p><ul><li>需要创建新的缓冲区</li><li>离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）;等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕上。</li></ul></li><li><p>哪些操作会触发离屏渲染</p><ul><li>光栅化，<code>layer.shouldRasterize = YES</code></li><li>遮罩 <code>layer.mask</code></li><li>圆角，同时设置 <code>layouer.maskToBounds = YES</code>, <code>layer.cornerRadius</code>大于0<ul><li>考虑通过<code>CoreGraphics</code>绘制裁剪圆角，或者叫美工提供圆角图片</li></ul></li><li>阴影，<code>layer.shadowXXX</code><ul><li>如果设置了<code>layer.shadowPath</code>就不会产生离屏渲染</li></ul></li></ul></li></ul><h2 id="耗电优化"><a href="#耗电优化" class="headerlink" title="耗电优化"></a>耗电优化</h2><h3 id="主要来源"><a href="#主要来源" class="headerlink" title="主要来源"></a>主要来源</h3><ul><li>CPU处理，Processing</li><li>网络，Networking</li><li>定位，Location</li><li>图像，Graphics</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li><p>尽可能降低CPU、GPU功耗</p></li><li><p>少用定时器</p></li><li><p>优化I/O操作</p><ul><li>尽量不要频繁写入小数据，最好批量一次性写入 </li><li>读写大量重要数据时，考虑使用<code>dispatch_io</code>，其提供了基于GCD的异步操作文件的I/O的API.用<code>dispatch_io</code>系统会优化磁盘访问</li><li>数据量比较大的，建议使用数据库(SQLite、CoreData)</li></ul></li><li><p>网络优化</p><ul><li>减少、压缩网络数据</li><li>如果多次请求结果是相同的，尽量使用缓存</li><li>使用断点续传，否则网络不稳定时可能多次传输相同的内容</li><li>网络不可用时，不要尝试执行网络请求</li><li>让用户可以取消长时间运行或者速度很慢的网络操作，设置合适的超时时间</li><li>批量传输，比如，下载视频流时，不要传输很小的数据包，直接下载整个文件或者一大块一大块地下载，如果下载广告，一次性多下载一些，然后再慢慢展示，如果下载电子邮件，一次下载多封，不要一封一封地下载</li></ul></li><li><p>定位优化</p><ul><li>如果只是需要快速确定用户当前位置，最好用<code>CLLocationManager</code>的<code>requestLocation</code>方法，定位完成后，会自动让定位硬件断电</li><li>如果不是导航应用， 尽量不要实时更新位置，定位关闭就关掉定位服务</li><li>尽量降低定位精度，比如尽量不要使用精度最高的<code>kCLLocationAccuracyBest</code></li><li>需要后台定位时，尽量设置<code>pausesLocationUpdatesAutomatically</code>为YES，如果用户不太可能移动的时候，系统会自动暂停位置更新</li><li>尽量不要使用<code>startMonitoringSignificantLocationChanges</code>，优先考虑<code>startMonitoringForRegion:</code></li></ul></li><li><p>硬件检测优化</p><ul><li>用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件。</li></ul></li></ul><h2 id="App启动优化"><a href="#App启动优化" class="headerlink" title="App启动优化"></a>App启动优化</h2><ul><li><p>App的启动可以分为2种</p><ul><li>冷启动（Code Launch）：从零开始启动App</li><li>热启动（Warm Launch）：App已经在内存中，在后台存活着，再次点击图标</li></ul></li><li><p>App启动时间的优化，主要是针对冷启动进行优化</p></li><li><p>通过添加环境变量可以打印出App的启动时间分析（Edit Scheme -&gt; Run -&gt; Arguments）</p><ul><li><code>DYLD_PRINT_STATISTICS</code>设置为1 或者 <code>DYLD_PRINT_STATISTICS_DETAILS</code> （更加详细 ）</li></ul></li><li><p>App的冷启动可以概括为3大阶段</p><ul><li><p>dyld</p></li><li><p>runtime</p></li><li><p>main</p><img src="https://i.loli.net/2021/08/31/ldg1cjZCUPe5Gk6.png" ></li><li><p>dyld（dynamic link editor），Apple的动态链接器，可以用来装在Mach-O文件（可执行文件、动态库等 ）</p></li><li><p>启动App时，dyld所做的事情有</p><ul><li>装载App的可执行文件，同时会递归加载所有依赖的动态库</li><li>当dyld把可执行文件、动态库都装载到内存完毕后，会通知Runtime进行下一步的处理</li></ul></li><li><p>启动App时，runtime所做的事情有</p><ul><li>调用<code>map_images</code>进行可执行文件内容的解析和处理</li><li>在<code>load_images</code>中调用<code>call_load_methods</code>,调用所有<code>Class</code>和<code>Category</code>的<code>+load</code>方法</li><li>进行各种objc结构的初始化（注册Objc类，初始化类对象等等）</li><li>调用C++静态初始化器和<code>__attribute((constructor))</code>修饰的函数</li></ul></li><li><p>到此为止，可执行文件和动态库中所有的符号（Class、Protocol、Selector、IMP、…）都已经按格式成功加载到内存中，被<code>runtime</code>所管理</p></li><li><p>总结</p><ul><li>App的启动由dyld主导，将可执行文件加载到内存，顺便加载所有依赖的动态库</li><li>并由runtime负责加载成objc定义的结构</li><li>所有初始化工作结束后，dyld就会调用main函数</li><li>接下来就是<code>UIApplicationMain</code>函数，AppDelegate的<code>application:didFinishLaunchingWithOptions:</code>方法</li></ul></li></ul></li></ul><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><ul><li>按照不同的阶段<ul><li>dyld <ul><li>减少动态库，合并一些动态库（定期清理不必要的动态库）</li><li>减少Objc类，分类的数量，减少selector的数量（定期清理不必要的类，分类）</li><li>减少C++虚函数数量</li><li>Swift尽量使用struct</li></ul></li><li>runtime<ul><li>用<code>+initialize</code>和<code>dispatch_once</code>取代所有的<code>__attribute((constructor))</code>、C++静态构造器 、ObjC的<code>+load</code></li></ul></li><li>main<ul><li>在不影响用户体验的前提下，尽可能将一些操作延迟，不要全部都放在<code>finishLaunch</code>方法中</li><li>按需加载 </li></ul></li></ul></li></ul><h2 id="安装包瘦身"><a href="#安装包瘦身" class="headerlink" title="安装包瘦身"></a>安装包瘦身</h2><ul><li><p>安装包（IPA）主要由可执行文件、资源组成</p></li><li><p>资源（图片、视频、音频等）</p><ul><li>采取无损压缩</li><li>去除没有用到的资源(github :LSUnusedResources）</li></ul></li><li><p>可执行文件瘦身</p><ul><li>编译器优化 <ul><li>Strip Linked Product 、 Make Strings Read-Only、 Symbols Hidden By Defaults设置为YES</li><li>去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions 设置为NO，Other C Flags  添加 -fno-exceptions</li></ul></li><li>利用AppCode(<a href="https://www.jetbrains.com/objc">https://www.jetbrains.com/objc</a>)检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code</li><li>编写LLVM插件检测出重复代码，未被调用的代码</li><li>生成Link Map文件，可以查看可执行文件的具体组成（在Build Setting-&gt;Write Link Map File 改为true，就可以在Path to link map file 看到这个文件）</li><li>可以借助第三方工具解析LinkMap文件：<a href="https://github.com/huanxsd/LinkMap">https://github.com/huanxsd/LinkMap</a></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍iOS内常用的性能优化方案&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>最近看了一本书...</title>
    <link href="https://www.arclin.cn/post/a4ffdee.html"/>
    <id>https://www.arclin.cn/post/a4ffdee.html</id>
    <published>2021-08-29T14:59:00.000Z</published>
    <updated>2021-08-29T15:04:10.654Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了一本 《代码整洁之道》</p><p>基本跟我们平时的编码代码规范有点类似吧。里面的一些设计思想是挺好的。这里记录一下一些个人感觉好像挺有用的点。</p><blockquote><p>部分内容可能存在争议，请不要在意，以自己团队规范为准。</p></blockquote><span id="more"></span><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>用命名常量替代魔术数（泛指任何不能自我描述的符号）</p><p>命名采用描述性名称，确认名称具有描述性</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>封装条件要抽离解释了条件意图函数，比如 shouldBeDelete(timer) 要优于  (timer.hasExpired &amp;&amp; !timer.isRecurrent())</p><p>避免否定条件  if（shouldDo） 要好于 if (!shouldNotDo)</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>为较大作用范围选用较长名称</p><p>名称应该说明函数、变量或类的一切信息，不要用名称掩蔽副作用。</p><p>每个函数只做一件事情</p><p>函数参数应该越少越好</p><p>不要把输入的参数拿来输出</p><p>布尔值参数宣告函数做了不止一件事情，违反了单一职责原则，应该消灭掉</p><p>用布尔、枚举、整数等参数用于判断流程来决定函数行为是不好的，使用多个函数，通常优于向单个函数传递某些代码来选择函数行为</p><p>使用异常替代返回错误码</p><p>抽离Try/Catch代码块</p><p>把重复代码抽离出来</p><p>通常应该倾向于选用非静态方法。如果的确需要静态函数，确保没机会打算让他有多态行为。</p><p>函数名称应该表达其行为</p><p>如果多个函数的调用有时序性，比如必须先调用A才能调用B，要显式声明时序性，比如调用B函数的时候把A函数作为参数传进去，这样子就保证别人不会误把B函数放在A函数前调用</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>顶部给出高层次概念和算法。细节应该往下渐次展开，直至找到原文件中最底层的函数和细节</p><p>如果某个函数调用了另外一个，就应该把它们放在一起，而且调用者应该尽可能放在被调用者上面，</p><p>概念相关的代码应该放到一起，相关性越强，彼此之间的距离就该越短</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数<br>面向对象代码便于在不改动既有函数的前提下添加新类</p><p>过程式代码难以添加新数据结构，因为必须修改所有函数。<br>面向对象代码难以添加新函数，因为必须修改所有类。</p><p>迪米特法则：模块不应了解它所操作对象的内部情形。<br>隐藏结构：<code>let a = b.c().e().f()</code><br>拆分成</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">c</span> = b.c()</span><br><span class="line"><span class="keyword">let</span> <span class="attr">e</span> = c.e()</span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span> = e.f()</span><br></pre></td></tr></table></figure><p>应该改成<br><code>let a = b.func()</code></p><p>在方法中，不应该调用其他对象的方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span>(<span class="keyword">let</span> obj)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> item <span class="operator">=</span> obj.func()</span><br><span class="line">    item.func() <span class="comment">// 不可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类C的方法f只能调用以下对象的方法</p><ul><li>C</li><li>由f创建的对象</li><li>作为参数传递给f的对象</li><li>由C的实体变量持有的对象</li></ul><p>用多态替代if/else 或 switch/case</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>不要使用错误码，用try-catch代替</p><p>不要返回null值，用空对象替代，或者抛出异常</p><p>不要传入null值作为参数，除非API要求你这么做</p><h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p>使用泛型限制输入</p><p>单元测试</p><p>单元测试应当简单、精悍、足具表达力。</p><p>测试代码和生产代码一样重要</p><p>TDD三定律：</p><ol><li>在编写不能通过的单元测试前，不可编写生产代码</li><li>只可编写刚好无法通过的单元测试，不能编译也不算通过</li><li>只可编写刚好足以通过当前失败测试的生产代码</li></ol><p>每一个测试一个断言</p><ul><li>每一个测试一个概念</li><li>一个概念可以多个断言</li></ul><p>简洁的测试应该遵循5条规则<br>（FIRST: FAST、Independent、Repeatable、Self-Validating、Timely）</p><ol><li>快速：测试应该够快</li><li>独立：测试应该互相独立，某个测试不应为下一个测试设定条件</li><li>可重复：测试应当可在任何环境中重复通过</li><li>自足验证：测试应该有布尔值输出</li><li>及时：测试应及时编写</li></ol><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类应该短小，遵循单一职责原则（类或模块应有且只有一条加以修改的理由）</p><p>类应该只有少量实体变量</p><p>当类丧失了内聚性，就拆分它</p><p>类的方法只应对其所属类中的变量和函数感兴趣，不应该垂青其他类中的变量和函数</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近看了一本 《代码整洁之道》&lt;/p&gt;
&lt;p&gt;基本跟我们平时的编码代码规范有点类似吧。里面的一些设计思想是挺好的。这里记录一下一些个人感觉好像挺有用的点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;部分内容可能存在争议，请不要在意，以自己团队规范为准。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://www.arclin.cn/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="架构" scheme="https://www.arclin.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="技巧" scheme="https://www.arclin.cn/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- 多线程</title>
    <link href="https://www.arclin.cn/post/f4b0e2bd.html"/>
    <id>https://www.arclin.cn/post/f4b0e2bd.html</id>
    <published>2021-08-29T13:49:00.000Z</published>
    <updated>2021-08-29T09:21:53.755Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述iOS中多线程的使用及其原理</p><span id="more"></span><h2 id="常见的多线程方案"><a href="#常见的多线程方案" class="headerlink" title="常见的多线程方案"></a>常见的多线程方案</h2><table><thead><tr><th align="center">技术方案</th><th align="left">简介</th><th align="center">语言</th><th align="center">线程生命周期</th><th align="center">使用频率</th></tr></thead><tbody><tr><td align="center">pthread</td><td align="left"><ul><li>一套通用的多线程API</li><li>适用于Unix\Linux\Windows等系统</li><li>跨平台\可移植</li><li>使用难度大</li></ul></td><td align="center">C</td><td align="center">程序员管理</td><td align="center">几乎不用</td></tr><tr><td align="center">NSThread</td><td align="left"><ul><li>使用更加面向对象</li><li>简单易用，可直接操作线程对象</li></ul></td><td align="center">OC</td><td align="center">程序员管理</td><td align="center">偶尔使用</td></tr><tr><td align="center">GCD</td><td align="left"><ul><li>旨在替代NSThread等线程技术</li><li>充分利用设备的多核</li></ul></td><td align="center">C</td><td align="center">自动管理</td><td align="center">经常使用</td></tr><tr><td align="center">NSOperation</td><td align="left"><ul><li>基于GCD</li><li>比GCD多了一些简单实用的功能</li><li>使用更加面向对象</li></ul></td><td align="center">OC</td><td align="center">自动管理</td><td align="center">经常使用</td></tr></tbody></table><h3 id="一些多线程术语"><a href="#一些多线程术语" class="headerlink" title="一些多线程术语"></a>一些多线程术语</h3><ul><li>同步、异步：能不能开启新的线程<ul><li>同步：在当前线程中执行任务，不具备开启新线程的能力</li><li>异步：在新的线程中执行任务，具备开启新线程的能力</li></ul></li><li>并发、串行：任务的执行方式<ul><li>并发：多个任务并发（同时）执行</li><li>串行：一个任务执行完毕后，再执行下一个任务</li></ul></li></ul><h3 id="各种队列的执行效果"><a href="#各种队列的执行效果" class="headerlink" title="各种队列的执行效果"></a>各种队列的执行效果</h3><table><thead><tr><th></th><th>并发队列</th><th>手动创建的串行队列</th><th>主队列</th></tr></thead><tbody><tr><td>同步（sync）</td><td>没有开启新线程<br>串行执行任务</td><td>没有开启新线程<br>串行执行任务</td><td>没有开启新线程<br>串行执行任务</td></tr><tr><td>异步（async）</td><td>有开启新线程<br>并发执行任务</td><td>有开启新线程<br>串行执行任务</td><td>没有开启新线程<br>串行执行任务</td></tr></tbody></table><ul><li><p>使用<code>sync</code>函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁）</p></li><li><p>死锁问题主要产生在串行队列中。由于串行队列的FIFO（First in first out）性质，如果串行队列中有同步函数，那么同步函数要等待串行队列执行完才能执行，又因为同步函数的性质是在当前线程立马执行函数体，所以同步函数后面的代码要等待同步函数执行完才能执行，在这种情况下就会出现死锁</p></li><li><p>因为并发队列允许同时执行多个任务，所以不存在等待队列中其他人完成后才能开始执行的情况，所以一般情况下并发队列不会产生环路等待死锁</p></li></ul><h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><h3 id="GCD的常用函数"><a href="#GCD的常用函数" class="headerlink" title="GCD的常用函数"></a>GCD的常用函数</h3><ul><li>用同步的方式执行任务</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// queue 队列</span></span><br><span class="line"><span class="comment">/// block 任务</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(<span class="built_in">dispatch_queue_t</span> queue,dispatch_block_t block);</span><br></pre></td></tr></table></figure><ul><li>用异步的方式执行任务</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// queue 队列</span></span><br><span class="line"><span class="comment">/// block 任务</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(<span class="built_in">dispatch_queue_t</span> queue,dispatch_block_t block);</span><br></pre></td></tr></table></figure><h3 id="GCD的队列"><a href="#GCD的队列" class="headerlink" title="GCD的队列"></a>GCD的队列</h3><p>GCD的队列可以分为2大类型</p><ul><li><p>并发队列（Concurrent Dispatch Queue）</p><ul><li>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）</li><li>并发功能只有在异步（dispatch_async）函数下才有效</li></ul></li><li><p>串行队列（Serial Dispatch Queue）</p><ul><li>让任务一个接着一个执行（一个任务执行完毕后，在执行下一个任务）</li></ul></li></ul><h3 id="GCD的队列组"><a href="#GCD的队列组" class="headerlink" title="GCD的队列组"></a>GCD的队列组</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建队列组</span></span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;my_queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加异步任务</span></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;任务1-%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;任务2-%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等前面的任务执行完毕后，会自动执行这个任务</span></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;任务3-%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="多线程的安全隐患"><a href="#多线程的安全隐患" class="headerlink" title="多线程的安全隐患"></a>多线程的安全隐患</h2><ul><li>资源共享<ul><li>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源</li><li>比如多个线程访问同一个对象，同一个变量，同一个文件</li></ul></li><li>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题</li></ul><p>解决方案：使用线程同步技术（同步，就是协同步调，按预定的先后持续进行）</p><ul><li>常见的线程同步技术是：加锁，常见线程同步方案如下<ul><li>OSSpinLock</li><li>os_unfair_lock</li><li>pthread_mutex</li><li>dispatch_semaphore</li><li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSRecursiveLock</li><li>NSCondition</li><li>NSConditionLock</li><li>@synchronized</li></ul></li></ul><h3 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h3><p>线程同步的最直接的方案就是串行队列，让多条线程按顺序执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> queue = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;queue&quot;</span>,DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue,^&#123;</span><br><span class="line">    xxxx</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue,^&#123;</span><br><span class="line">    xxxx</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><blockquote><p>这个锁在iOS 10之后被废弃了</p></blockquote><p>自旋锁，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源</p><blockquote><p>忙等：一边等待一边忙着做事情，相当于while(1){xxx}。自旋：自己一直在那里旋转</p></blockquote><blockquote><p>需要导入头文件<code>&lt;libkern/OSAtomic.h&gt;</code></p></blockquote><p>初始化</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">OSSpinLock lock</span> = OS_SPINLOCK_INIT;</span><br></pre></td></tr></table></figure><p>加锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">OSSpinLockLock(&amp;<span class="params">_lock</span>)</span>;</span><br></pre></td></tr></table></figure><p>尝试加锁：如果需要等待就返回false，不加锁；如果不需要等待就返回true，加锁。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Bool</span> <span class="variable"><span class="class">result</span></span> = <span class="function"><span class="title">OSSpinLockTry</span>(&amp;<span class="variable">_lock</span>)</span></span><br></pre></td></tr></table></figure><p>解锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">OSSpinLockUnlock(&amp;<span class="params">_lock</span>)</span>;</span><br></pre></td></tr></table></figure><p>自旋锁现在已经不再安全，可能会出现优先级反转问题</p><p>如果等待锁的优先级线程较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁</p><h3 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h3><ul><li><code>os_unfair_lock</code>用于取代不安全的<code>OSSpinLock</code>，从iOS10开始才支持</li><li>从底层调用看，等待<code>os_unfair_lock</code>锁的线程会处于休眠状态，并非忙等</li><li>需要导入头文件<code>&lt;os/lock.h&gt;</code></li></ul><p>初始化</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">os_unfair_lock lock</span> = OS_UNFAIR_LOCK_INIT;</span><br></pre></td></tr></table></figure><p>加锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os_unfair_lock_lock(&amp;lock);</span><br></pre></td></tr></table></figure><p>解锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os_unfair_lock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure><h3 id="phread-mutex"><a href="#phread-mutex" class="headerlink" title="phread_mutex"></a>phread_mutex</h3><ul><li><code>mutex</code>叫做互斥锁，等待锁的线程会处于休眠状态</li><li>需要导入头文件<code>&lt;pthread.h&gt;</code></li></ul><p>初始化方法1</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pthread_mutex_t mutex</span> = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure><p>初始化方法2</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread<span class="constructor">_mutexattr_init(&amp;<span class="params">attr</span>)</span>;</span><br><span class="line">pthread<span class="constructor">_mutexattr_settype(&amp;<span class="params">attr</span>, PTHREAD_MUTEX_DEFAULT)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这里的第二个参数如果传NULL的话表示使用默认属性</span></span><br><span class="line">pthread<span class="constructor">_mutex_init(&amp;<span class="params">_mutex</span>, &amp;<span class="params">attr</span>)</span>;</span><br><span class="line"></span><br><span class="line">pthread<span class="constructor">_mutexattr_destory(&amp;<span class="params">attr</span>)</span>;</span><br></pre></td></tr></table></figure><p>尝试加锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_mutex_trylock(&amp;<span class="params">mutex</span>)</span>;</span><br></pre></td></tr></table></figure><p>加锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_mutex_lock(&amp;<span class="params">mutex</span>)</span>;</span><br></pre></td></tr></table></figure><p>解锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_mutex_unlock(&amp;<span class="params">mutex</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h4><p>锁的属性可以改为递归锁，即允许<strong>同一个线程</strong>对一把锁进行重复加锁</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_mutexattr_settype(&amp;<span class="params">attr</span>, PTHREAD_MUTEX_RECURSIVE)</span>;</span><br></pre></td></tr></table></figure><h4 id="条件锁"><a href="#条件锁" class="headerlink" title="条件锁"></a>条件锁</h4><p>初始化条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_t <span class="keyword">condition</span>;</span><br><span class="line">pthread_cond_init(<span class="operator">&amp;</span><span class="keyword">condition</span>, <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><p>等待条件（进入休眠，放开mutex锁；被唤醒后，会再次对mutex加锁）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_cond_wait(&amp;<span class="params">condition</span>, &amp;<span class="params">mutex</span>)</span>;</span><br></pre></td></tr></table></figure><p>激活<strong>一个</strong>等待该条件的线程（如果这时候有多个在等待，那么也只会激活最先等待的那个）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_cond_signal(&amp;<span class="params">condition</span>)</span>;</span><br></pre></td></tr></table></figure><p>激活所有等待该条件的线程</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_cond_brodcast(&amp;<span class="params">condition</span>)</span>;</span><br></pre></td></tr></table></figure><p>销毁资源</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread<span class="constructor">_mutex_destory(&amp;<span class="params">mutex</span>)</span>;</span><br><span class="line">pthread<span class="constructor">_cond_destory(&amp;<span class="params">condition</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h3><ul><li><code>NSLock</code>是对<code>mutex</code>普通锁的封装，即<code>pthread_mutex_init(&amp;_mutex, NULL);</code></li></ul><p>初始化</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLock</span> *lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br></pre></td></tr></table></figure><p>加锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)lock;</span><br></pre></td></tr></table></figure><p>尝试加锁(调用的瞬间立马去判断当前能不能加锁，能加就加，然后返回YES，然后继续往下走，如果不能加就返回NO，然后继续往下走)</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)tryLock;</span><br></pre></td></tr></table></figure><p>等待锁（调用的时候先阻塞，如果现在能加锁，就返回YES，加锁成功，继续往下走；如果不能加锁，就阻塞，如果在limit之前，锁被放开了，那么就加锁，返回YES，代码继续往下走；如果直到limit到了，锁还没被放开，那么就返回NO，加锁失败，代码继续往下走）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br></pre></td></tr></table></figure><p>解锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)unlock;</span><br></pre></td></tr></table></figure><h3 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a>NSRecursiveLock</h3><ul><li><code>NSRecurseiveLock</code>也是对<code>mutex</code>递归锁的封装，API跟<code>NSLock</code>基本一致</li></ul><h3 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h3><ul><li><code>NSCondition</code>也是对<code>mutex</code>和<code>cont</code>的封装</li></ul><p>等待锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)wait;</span><br><span class="line">- (<span class="keyword">void</span>)waitUtilDate:(<span class="built_in">NSDate</span> *)limit;</span><br></pre></td></tr></table></figure><p>激活锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)signal; <span class="comment">// 激活单个</span></span><br><span class="line">- (<span class="keyword">void</span>)boardcast; <span class="comment">// 激活多个</span></span><br></pre></td></tr></table></figure><h3 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h3><ul><li><code>NSConditionLock</code>是对<code>NSCondition</code>的进一步封装，可以设置具体的条件值</li></ul><p>初始化设定一个条件值，如果直接<code>init</code>的话那么默认值是0</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instance<span class="keyword">type</span>)initWithCondition:(<span class="type">NSInteger</span>)condition;</span><br></pre></td></tr></table></figure><p>加锁并且设定条件值为<code>condition</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLockWhenCondition:(<span class="built_in">NSInteger</span>)condition; <span class="comment">// 尝试加锁</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition beforeDate:(<span class="built_in">NSDate</span> *)limit; <span class="comment">// 在指定时间到达之前等待条件成立加锁</span></span><br></pre></td></tr></table></figure><p>如果直接使用<code>lock</code>方法，那么会无视条件值，直接加锁或者等待加锁</p><p>解当前的锁并且设置条件值为<code>condition</code>，如果这时候有条件值为<code>condition</code>的锁在加着，那么就会释放</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)unlockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br></pre></td></tr></table></figure><p>如果直接使用<code>unlock</code>方法，那么那些带条件的<code>lockWhenCondition</code>不会解锁</p><h3 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h3><ul><li><code>semaphore</code>叫做信号量</li><li>信号量的初始值，可以用来控制线程并发访问的最大数量</li></ul><p>初始化，传入一个允许的最大并发线程数<code>count</code></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dispatch_sempathore semaphore</span> = dispatch_semaphore_create(count);</span><br></pre></td></tr></table></figure><p>如果信号量的值&lt;=0，当前线程就会进入休眠等待（直到信号量的值&gt;0）<br>如果信号量的值&gt;0，就减1，然后往下执行后面的代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch<span class="constructor">_semaphore_wait(<span class="params">semaphore</span>, DISPATCH_TIME_FOREVER)</span>;</span><br></pre></td></tr></table></figure><p>让信号量的值加1</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch<span class="constructor">_semaphore_signal(<span class="params">semaphore</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h3><ul><li><code>@synchronized</code>是对<code>mutex</code>递归锁的封装</li></ul><p>传入对象即可，用于标记是不是同个锁，一个对象标记一把锁 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@synchronized(xxx)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程同步方案性能比较"><a href="#线程同步方案性能比较" class="headerlink" title="线程同步方案性能比较"></a>线程同步方案性能比较</h3><ul><li>性能从高到低排序<ul><li>os_unfair_lock</li><li>OSSpinLock</li><li>dispatch_semaphore</li><li>pthread_mutex</li><li>dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSCondition</li><li>pthread_mutex(recursive)</li><li>NSRecursiveLock</li><li>NSConditionLock</li><li>@synchronized</li></ul></li></ul><h2 id="自旋锁、互斥锁比较"><a href="#自旋锁、互斥锁比较" class="headerlink" title="自旋锁、互斥锁比较"></a>自旋锁、互斥锁比较</h2><blockquote><p>iOS10之后已经不推荐使用自旋锁了</p></blockquote><ul><li>什么情况使用自旋锁比较划算？<ul><li>预计线程等待锁的时间很短</li><li>加锁的代码（临界区）经常被调用，但竞争情况很少发生</li><li>CPU资源不紧张</li><li>多核处理器</li></ul></li><li>什么情况使用互斥锁比较划算？<ul><li>预计线程等待锁的时间较长</li><li>单核处理器</li><li>临界区有IO操作（因为比较占用CPU资源）</li><li>临界区代码复杂或者循环量大</li></ul></li></ul><h2 id="读写安全"><a href="#读写安全" class="headerlink" title="读写安全"></a>读写安全</h2><h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h3><p><code>nonatomic</code>和<code>atomic</code> ：给属性加上<code>atomic</code>修饰，可以保证属性的<code>setter</code>和<code>getter</code>都是原子性操作，也就是保证<code>setter</code>和<code>getter</code>内部是线程同步的</p><p>参照runtime源码中 <code>objc-accessors.mm</code>的<code>objc_getProperty</code>和<code>reallySetProperty</code>方法，分别是get方法和set方法的内部实现</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_getProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, ptrdiff_t offset, <span class="built_in">BOOL</span> atomic) &#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retain release world</span></span><br><span class="line">    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);</span><br><span class="line">    <span class="keyword">if</span> (!atomic) <span class="keyword">return</span> *slot;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是atomic的时候，会加上锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Atomic retain release world</span></span><br><span class="line">    spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();</span><br><span class="line">    <span class="keyword">id</span> value = objc_retain(*slot);</span><br><span class="line">    slotlock.unlock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span></span><br><span class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> reallySetProperty(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> newValue, ptrdiff_t offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> <span class="keyword">copy</span>, <span class="keyword">bool</span> mutableCopy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        object_setClass(<span class="keyword">self</span>, newValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> oldValue;</span><br><span class="line">    <span class="keyword">id</span> *slot = (<span class="keyword">id</span>*) ((<span class="keyword">char</span>*)<span class="keyword">self</span> + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">copy</span>) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!atomic) &#123;</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/// 这里可以看出如果是atomic的时候，是会加上锁的</span></span><br><span class="line">        spinlock_t&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>atmoic</code>是不能保证使用属性的过程中是线程安全的，即虽然他的setter和getter是线程安全的，但是用这个属性去调用其他方法的时候依旧不一定属性安全，比如<code>[self.array addObject:xxx]</code>，这里只能保证取出array属性的时候线程安全，但是添加对象进去的时候就有可能出现线程同步问题</p><h3 id="读写安全方案"><a href="#读写安全方案" class="headerlink" title="读写安全方案"></a>读写安全方案</h3><h4 id="多读单写"><a href="#多读单写" class="headerlink" title="多读单写"></a>多读单写</h4><p>需求</p><ul><li>同一时间，只能有1条线程进行写的操作</li><li>同一时间，允许有多条线程进行读的操作</li><li>同一时间，不允许既有写的操作，又有读的操作</li></ul><p>解决方案</p><ul><li>pthread_rwlock：读写锁</li><li>dispatch_barrier_async：异步栅栏调用</li></ul><h4 id="pthread-rwlock"><a href="#pthread-rwlock" class="headerlink" title="pthread_rwlock"></a>pthread_rwlock</h4><ul><li>等待锁的线程会进入休眠</li><li>需要引入头文件&lt;pthread.h&gt;</li></ul><p>初始化锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_t lock;</span><br><span class="line">pthread_rwlock_init(&amp;lock,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>读-加锁/尝试加锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_rdlock(&amp;lock);</span><br><span class="line">pthread_rwlock_tryrdlock(&amp;lock);</span><br></pre></td></tr></table></figure><p>写-加锁/尝试加锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_wrlock(&amp;lock);</span><br><span class="line">pthread_rwlock_trywrlock(&amp;lock);</span><br></pre></td></tr></table></figure><p>解锁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure><p>销毁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_destory(&amp;lock);</span><br></pre></td></tr></table></figure><h4 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h4><ul><li>这个函数传入的并发队列必须是自己通过<code>dispatch_queue_create</code>创建的</li><li>如果传入的是一个串行或是一个全局的并发队列，那这个函数便等同于<code>dispatch_async</code>函数的效果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化队列</span><br><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;rw_queue&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 读</span><br><span class="line">dispatch_async(queue,^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写</span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>子线程中，<code>performSelector:withObject:afterDelay:</code>不起作用的原因 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;1&quot;</span>);</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) withObject:<span class="literal">nil</span> afterDelay:<span class="number">.0</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;3&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>performSelector:withObject:afterDelay:</code> 的本质是往Runloop中添加定时器</li><li>子线程中默认没有启动<code>Runloop</code></li><li>补充代码启动Runloop即可  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSRunloop</span> currentRunloop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunloopMode</span>];</span><br><span class="line">[[<span class="built_in">NSRunloop</span> currentRunloop] runMode:<span class="built_in">NSDefaultRunloopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFeature]];</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要简述iOS中多线程的使用及其原理&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Swift 5.5 async与 await</title>
    <link href="https://www.arclin.cn/post/75996dec.html"/>
    <id>https://www.arclin.cn/post/75996dec.html</id>
    <published>2021-08-23T14:55:00.000Z</published>
    <updated>2021-08-23T15:04:24.323Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述Swift 5.5新特性 async与await的常用方式</p><span id="more"></span><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>首先我们来做一个简单的下载图片的任务</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Download</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">image</span>(<span class="params">url</span>: <span class="type">URL</span>, <span class="params">completeHandler</span>: <span class="keyword">@escaping</span> (<span class="type">UIImage</span>?, <span class="type">Error</span>?) -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> task <span class="operator">=</span> <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error &#123;</span><br><span class="line">                <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                    completeHandler(<span class="literal">nil</span>,error)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> data <span class="operator">=</span> data, <span class="keyword">let</span> httpResponse <span class="operator">=</span> response <span class="keyword">as?</span> <span class="type">HTTPURLResponse</span>, httpResponse.statusCode <span class="operator">==</span> <span class="number">200</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">UIImage</span>(data: data)</span><br><span class="line">                <span class="keyword">if</span> image <span class="operator">!=</span> <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                        completeHandler(image, <span class="literal">nil</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                        completeHandler(<span class="literal">nil</span>, <span class="type">NSError</span>(domain: <span class="string">&quot;org.swift&quot;</span>, code: <span class="operator">-</span><span class="number">2</span>))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                    completeHandler(<span class="literal">nil</span>, <span class="type">NSError</span>(domain: <span class="string">&quot;org.swift&quot;</span>, code: <span class="operator">-</span><span class="number">1</span>))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        task.resume()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这个简单的任务里面涉及到了block嵌套，子线程与主线程的切换等等上下文切换的逻辑。</p><p>代码首先会执行第一行，然后就直接执行最后一行，再回到第二行执行，然后还得判断各种异常状态，最后才回到主线程刷新。可以发现这里面最深的嵌套达到了4层，而且上下文的切换也不利于代码阅读。可想而知要是逻辑稍微再多一点，就远远不止这种复杂度了。</p><h2 id="用-async-和-await-来拯救一下"><a href="#用-async-和-await-来拯救一下" class="headerlink" title="用 async 和 await 来拯救一下"></a>用 async 和 await 来拯救一下</h2><p>改造完之后，代码如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">image</span>(<span class="params">url</span>: <span class="type">URL</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> (data, response) <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">URLSession</span>.shared.data(from: url)</span><br><span class="line">    <span class="keyword">guard</span> (response <span class="keyword">as?</span> <span class="type">HTTPURLResponse</span>)<span class="operator">?</span>.statusCode <span class="operator">==</span> <span class="number">200</span> <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="string">&quot;org,swift&quot;</span>, code: <span class="operator">-</span><span class="number">1</span>) &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> maybeImage <span class="operator">=</span> <span class="type">UIImage</span>(data: data) <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="string">&quot;org,swift&quot;</span>, code: <span class="operator">-</span><span class="number">1</span>) &#125;</span><br><span class="line">    <span class="keyword">return</span> maybeImage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式如下（如果需要捕获异常的话就需要加上<code>do-catch</code>）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> <span class="keyword">self</span>.imageView.image <span class="operator">=</span> <span class="keyword">await</span> <span class="type">AsyncTest</span>.image(url: <span class="type">URL</span>(string: <span class="string">&quot;https://images.xiaozhuanlan.com/photo/2021/fb4d1bcda193cdfb5ccc380d1a008fe1.png&quot;</span>)<span class="operator">!</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们的代码精简了许多，嵌套最深也就是判断到异常的时候抛出的1层，接下来我们来逐行讲解一下</p><h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><p>首先<code>URLSession.shared.data(from: url) </code>是iOS 15 新出的方法，用于发起网络请求，方法定义如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Convenience method to load data using an URL, creates and resumes an URLSessionDataTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter url: The URL for which to load data.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Data and response.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">data</span>(<span class="params">from</span> <span class="params">url</span>: <span class="type">URL</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">Data</span>, <span class="type">URLResponse</span>)</span><br></pre></td></tr></table></figure><p>其中 <code>async</code> 表示这是一个异步方法，如同我们前面定义的方法一样<code>static func image(url: URL) async throws -&gt; UIImage</code>，同样也有<code>async</code>这个关键字，只要方法里面有<code>await</code>关键字，那么方法名就得带上<code>async</code>关键字。带有<code>async</code>的方法就意味着需要使用<code>await</code>去调用，然后其返回值可以直接赋值给某个变量。举例如下:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getName</span>()</span> <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line"><span class="comment">/// 发起网络请求获取名字，这时候线程会卡住，直到请求完成了，就会把这个请求方法的返回值直接赋值给name，然后就会继续往下执行，把拿到的name给返回出去</span></span><br><span class="line"><span class="keyword">let</span> name <span class="operator">=</span> <span class="keyword">await</span> requestName()</span><br><span class="line"><span class="keyword">return</span> name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 同理，当代码执行到这里的时候，调用异步方法，线程会卡住，然后方法里面去调用网络请求获取名字，然后等待网络请求返回之后，name就会被赋上值</span></span><br><span class="line"><span class="keyword">let</span> name <span class="operator">=</span> <span class="keyword">await</span> getName()</span><br></pre></td></tr></table></figure><p>以上面的<code>URLSession</code>的<code>data(from:delegate:)</code>方法为例，返回的是一个元组，所以就是</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (data, response) <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">URLSession</span>.shared.data(from: url)</span><br></pre></td></tr></table></figure><p>表示请求后，<code>data</code>和<code>response</code>变量都会被赋上值，分别是<code>Data</code>类型和<code>URLResponse</code>类型</p><p>另外我们注意到，和通过block方式返回请求结果不同，这个新方法返回的元组中的<code>data</code>和<code>response</code>都不是可选类型，而是确切有值的，如果发生网络异常则会通过<code>throw</code>抛出异常，这样子的设计能够让我们节省加下来针对空值的判断，可以放心地使用返回值</p><blockquote><p>当然，不仅仅是网络请求可以用<code>await</code>，任意的异步行为（比如读取本地文件）都可以使用<code>await</code></p></blockquote><p>目前在iOS 15 SDK的<code>URLSession</code>中，不仅仅提供了上述请求数据，返回元组的方法，还提供了其他上传，下载的方法，可供异步调用，这里简单列举一下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter request: The URLRequest for which to upload data.</span></span><br><span class="line"><span class="comment">/// - Parameter fileURL: File to upload.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Data and response.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">upload</span>(<span class="params">for</span> <span class="params">request</span>: <span class="type">URLRequest</span>, <span class="params">fromFile</span> <span class="params">fileURL</span>: <span class="type">URL</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">Data</span>, <span class="type">URLResponse</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter request: The URLRequest for which to upload data.</span></span><br><span class="line"><span class="comment">/// - Parameter bodyData: Data to upload.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Data and response.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">upload</span>(<span class="params">for</span> <span class="params">request</span>: <span class="type">URLRequest</span>, <span class="params">from</span> <span class="params">bodyData</span>: <span class="type">Data</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">Data</span>, <span class="type">URLResponse</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Convenience method to download using an URLRequest, creates and resumes an URLSessionDownloadTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter request: The URLRequest for which to download.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Downloaded file URL and response. The file will not be removed automatically.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">download</span>(<span class="params">for</span> <span class="params">request</span>: <span class="type">URLRequest</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">URL</span>, <span class="type">URLResponse</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Convenience method to download using an URL, creates and resumes an URLSessionDownloadTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter url: The URL for which to download.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Downloaded file URL and response. The file will not be removed automatically.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">download</span>(<span class="params">from</span> <span class="params">url</span>: <span class="type">URL</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">URL</span>, <span class="type">URLResponse</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Convenience method to resume download, creates and resumes an URLSessionDownloadTask internally.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Parameter resumeData: Resume data from an incomplete download.</span></span><br><span class="line"><span class="comment">/// - Parameter delegate: Task-specific delegate.</span></span><br><span class="line"><span class="comment">/// - Returns: Downloaded file URL and response. The file will not be removed automatically.</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">download</span>(<span class="params">resumeFrom</span> <span class="params">resumeData</span>: <span class="type">Data</span>, <span class="params">delegate</span>: <span class="type">URLSessionTaskDelegate</span>? <span class="operator">=</span> <span class="literal">nil</span>)</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; (<span class="type">URL</span>, <span class="type">URLResponse</span>)</span><br></pre></td></tr></table></figure><h3 id="容错-amp-转码"><a href="#容错-amp-转码" class="headerlink" title="容错 &amp; 转码"></a>容错 &amp; 转码</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> (response <span class="keyword">as?</span> <span class="type">HTTPURLResponse</span>)<span class="operator">?</span>.statusCode <span class="operator">==</span> <span class="number">200</span> <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="string">&quot;org,swift&quot;</span>, code: <span class="operator">-</span><span class="number">1</span>) &#125;</span><br></pre></td></tr></table></figure><p>这一行用来处理响应体的异常情况，当<code>statusCode</code> 为 200的判断不成立时，就会抛出异常，则外部需要通过<code>do-catch</code>去捕获</p><p>如果判断成立时，则程序继续往下走</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> maybeImage <span class="operator">=</span> <span class="type">UIImage</span>(data: data) <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="string">&quot;org,swift&quot;</span>, code: <span class="operator">-</span><span class="number">1</span>) &#125;</span><br></pre></td></tr></table></figure><p>这里将<code>data</code>转成了<code>UIImage</code>，由于该方法返回的是一个可选值，所以这里同样需要通过<code>guard</code>去判断转换失败的情况</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> maybeImage</span><br></pre></td></tr></table></figure><p>最后得到了确切的结果之后，我们就可以将转好的图片给发送出去了，并且外面使用这个返回值的时候也不用判空，可以放心地确定返回的图片是有值的。</p><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>当我们的方法被标记为<code>async</code>的时候，我们就需要加上<code>await</code>进行调用，并且调用的环境是需要在异步环境内的，即如下所示</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> &#123;</span><br><span class="line"><span class="keyword">try</span> <span class="keyword">let</span> image <span class="operator">=</span> <span class="keyword">await</span> <span class="type">AsyncTest</span>.image(url: xxxx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Xcode 13.0 bata 4 中这个<code>async &#123;&#125; </code>环境的建立代码被提示即将被废弃，所以改成了如下所示</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span>(priority: .userInitiated) &#123;</span><br><span class="line">    <span class="keyword">try</span> <span class="keyword">let</span> image <span class="operator">=</span> <span class="keyword">await</span> <span class="type">AsyncTest</span>.image(url: xxxx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>userInitiated</code>表示线程优先级为<code>用户发起</code>，当然<code>priority</code>参数也可以不填，默认优先级是<code>Task.currentPriority</code>，返回值默认是<code>default</code></p><p>目前有六种优先级，这里从高到低进行排列如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 优先级最高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> high: <span class="type">TaskPriority</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 等同于default</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> medium: <span class="type">TaskPriority</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> low: <span class="type">TaskPriority</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> userInitiated: <span class="type">TaskPriority</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> utility: <span class="type">TaskPriority</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 优先级最低</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> background: <span class="type">TaskPriority</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当你标记一个函数为<code>async</code>时，即表示该函数可以被挂起。在<code>async</code>函数内部，使用<code>await</code>关键词标记在哪里可以一次或多次挂起。当<code>async</code>函数挂起时，线程并未阻塞，系统会自由安排其他任务。有时后启动的任务，可能先被执行。即你的程序状态可能在挂起时发生显著变化。当<code>async</code>函数恢复执行时，其返回的结果会自然融入到<code>async</code>函数的调用者，并在先前挂起的地方接续执行。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><code>await</code>关键字表示该异步（async）函数可能会被挂起，而不是畅通无阻地继续执行下去，甚至从挂起恢复回来时，函数可能已经跑到了另一个线程上去了，为了解决这个问题，我们可以用Swift的<code>actor</code>保护可变状态，这个我们后面再讲</p><h2 id="Async序列"><a href="#Async序列" class="headerlink" title="Async序列"></a>Async序列</h2><p>Async序列顾名思义就是异步的序列，比如读取一个很大的文件，我们希望一边下载一边展示读取的内容，这时候我们可以通过使用<code>for await-in</code> 来遍历一个异步的序列，如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">eatchquakes</span>()</span> <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> endpointURL <span class="operator">=</span> <span class="type">URL</span>(string: <span class="string">&quot;https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_month.csv&quot;</span>)<span class="operator">!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过首行 因为是header描述不是地震数据</span></span><br><span class="line">    <span class="comment">// 接着遍历提取强度、时间、经纬度信息</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">try</span> <span class="keyword">await</span> event <span class="keyword">in</span> endpointURL.lines.dropFirst() &#123;</span><br><span class="line">        <span class="keyword">let</span> values <span class="operator">=</span> event.split(separator: <span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> time <span class="operator">=</span> values[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> latitude <span class="operator">=</span> values[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">let</span> longtitude <span class="operator">=</span> values[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">let</span> magnitude <span class="operator">=</span> values[<span class="number">4</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Magnitude <span class="subst">\(magnitude)</span> on <span class="subst">\(time)</span> at <span class="subst">\(latitude)</span> <span class="subst">\(longtitude)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，异步序列就是对随着时间推移如何产生值或对象的一种描述方式。由于值的产生是异步的，所以可能会在读取的过程中出现异常，当异常发生的时候，遍历终止，并抛出异常。</p><p>其中，<code>lines</code>方法是iOS 15 新增的一个<code>URL</code>的拓展属性，同时还有<code>resourceBytes</code>属性，完整定义如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">AsyncBytes</span> : <span class="title">AsyncSequence</span>, <span class="title">AsyncIteratorProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">AsyncIterator</span> <span class="operator">=</span> <span class="type">URL</span>.<span class="type">AsyncBytes</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Element</span> <span class="operator">=</span> <span class="type">UInt8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/// Asynchronously advances to the next element and returns it, or ends the</span></span><br><span class="line">        <span class="comment">/// sequence if there is no next element.</span></span><br><span class="line">        <span class="comment">/// </span></span><br><span class="line">        <span class="comment">/// - Returns: The next element, if it exists, or `nil` to signal the end of</span></span><br><span class="line">        <span class="comment">///   the sequence.</span></span><br><span class="line">        <span class="keyword">@inlinable</span> <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span>()</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">UInt8</span>?</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// Creates the asynchronous iterator that produces elements of this</span></span><br><span class="line">        <span class="comment">/// asynchronous sequence.</span></span><br><span class="line">        <span class="comment">///</span></span><br><span class="line">        <span class="comment">/// - Returns: An instance of the `AsyncIterator` type used to produce</span></span><br><span class="line">        <span class="comment">/// elements of the asynchronous sequence.</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">makeAsyncIterator</span>()</span> -&gt; <span class="type">URL</span>.<span class="type">AsyncBytes</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> resourceBytes: <span class="type">URL</span>.<span class="type">AsyncBytes</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> lines: <span class="type">AsyncLineSequence</span>&lt;<span class="type">URL</span>.<span class="type">AsyncBytes</span>&gt; &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>因为异步序列的遍历是一个耗时操作，所以我们也可以在需要的时候中断遍历（取消请求）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span>(priority: .userInitiated) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">AsyncTest</span>.eatchquakes()</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 取消</span></span><br><span class="line">task.cancel()</span><br></pre></td></tr></table></figure><p>除了<code>URL</code>新增的<code>lines</code>方法，iOS 15 还给<code>FileHandle</code>和<code>URLSession</code>添加了异步序列方法，比如<code>FileHandle</code>新增的<code>bytes</code>属性，能提供字节流的异步序列。配合异步序列的扩展能力（把字节流变成<code>lines</code>），我们就可以从文件中异步地获得逐行内容并进行处理了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从FileHandle异步读取bytes</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> bytes: <span class="type">AsyncBytes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">try</span> <span class="keyword">await</span> line <span class="keyword">in</span> <span class="type">FileHandle</span>.standardInput.bytes.lines &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅如此，现在通知也支持异步序列了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步await通知</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">notifications</span>(<span class="params">named</span>: <span class="type">Notification</span>.<span class="type">Name</span>, <span class="params">object</span>: <span class="type">AnyObject</span>)</span> -&gt; notifications</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> center <span class="operator">=</span> <span class="type">NotificationCenter</span>.default</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 返回第一个userInfo的NSStoreUUIDKey值为storeUUID的通知</span></span><br><span class="line"><span class="keyword">let</span> notification <span class="operator">=</span> <span class="keyword">await</span> center.notifications(named: .<span class="type">NSPersistentStoreRemoteChange</span>).first &#123;</span><br><span class="line">    <span class="variable">$0</span>.userInfo[<span class="type">NSStoreUUIDKey</span>] <span class="operator">==</span> storeUUID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将异步回调的闭包方法改造成async方法"><a href="#将异步回调的闭包方法改造成async方法" class="headerlink" title="将异步回调的闭包方法改造成async方法"></a>将异步回调的闭包方法改造成async方法</h2><p>上面提到的都是基于系统提供的<code>async</code>方法，如果要改造我们原有的异步回调block方法，我们可以使用<code>withCheckedContinuation</code>或者<code>withCheckedThrowingContinuation</code>函数，区别在于前者用于确定不会抛出错误的场景，举例如下：</p><ul><li>三秒后返回Hello World</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">getItem</span>(<span class="params">callback</span>: <span class="keyword">@escaping</span> (<span class="type">String</span>)-&gt;(<span class="type">Void</span>))</span> &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">3.0</span>) &#123;</span><br><span class="line">        callback(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造后</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">getItem</span>()</span> <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> withCheckedContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">3.0</span>) &#123;</span><br><span class="line">            continuation.resume(returning: <span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">            <span class="comment">/// 如果需要抛出错误，使用 continuation.resume(throwing: error)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>continuation 有个简单但是重要的原则，resume方法必须在每个路径上执行，有且只有一次。但是不用担心，如果在有的路径上没有执行resume方法，Swift runtime 会发出 warning 警告。</p><p>但如果在某个路径上，resume执行了不止一次，这会是严重得多的问题。Swift runtime 会在第二次 resume 调用处触发 fatal error。</p><p>如果使用的是<code>withTaskCancellationHandler</code>，那么可以在异步操作被取消的时候执行某些行为</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">getItem</span>()</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> <span class="keyword">await</span> withTaskCancellationHandler &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Cancel&quot;</span>)</span><br><span class="line">    &#125; operation: &#123;</span><br><span class="line">        <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> withCheckedThrowingContinuation &#123; continuation <span class="keyword">in</span></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> <span class="number">3.0</span>) &#123;</span><br><span class="line">                continuation.resume(returning: <span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 调用</span></span><br><span class="line"><span class="keyword">let</span> task <span class="operator">=</span> <span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> item <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="type">AsyncTest</span>.getItem()</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error&quot;</span> <span class="operator">+</span> error.localizedDescription)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 调用取消的时候会打印`Cancel`</span></span><br><span class="line">task.cancel()</span><br></pre></td></tr></table></figure><h2 id="只读属性使用async"><a href="#只读属性使用async" class="headerlink" title="只读属性使用async"></a>只读属性使用async</h2><p>只读属性可以在其<code>get</code>方法中使用<code>async</code>标记是一个异步读取的属性，如下所示</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AsyncTest</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">FileError</span> : <span class="title">Error</span> </span>&#123;</span><br><span class="line">      <span class="keyword">case</span> missing, unreadable</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> content : <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">get</span> <span class="keyword">async</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">          <span class="keyword">guard</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">Bundle</span>.main.url(forResource: <span class="string">&quot;Empty&quot;</span>, withExtension: <span class="string">&quot;md&quot;</span>) <span class="keyword">else</span> &#123; <span class="keyword">throw</span> <span class="type">FileError</span>.missing &#125;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">String</span>(contentsOf: url)</span><br><span class="line">          &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="type">FileError</span>.unreadable</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">readContent</span>()</span> <span class="keyword">async</span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">try</span> <span class="keyword">await</span> <span class="keyword">self</span>.content</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h2><p>假如我们有多个异步函数，比如<code>切菜</code>、<code>切洋葱</code>、<code>切肉</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cooking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cutVegetable</span>()</span> <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">10_000_000_000</span>) <span class="comment">// 暂停10秒的意思</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;cut vegetable&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cutOnion</span>()</span> <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">5_000_000_000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;cut onion&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cutMeet</span>()</span> <span class="keyword">async</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="type">Task</span>.sleep(<span class="number">5_000_000_000</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;cut meet&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们这么调用的话，那么整个过程将是串行的，一共会花费20秒左右</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> step1 <span class="operator">=</span> <span class="keyword">await</span> <span class="type">Cooking</span>.cutVegetable()</span><br><span class="line">    <span class="keyword">let</span> step2 <span class="operator">=</span> <span class="keyword">await</span> <span class="type">Cooking</span>.cutOnion()</span><br><span class="line">    <span class="keyword">let</span> step3 <span class="operator">=</span> <span class="keyword">await</span> <span class="type">Cooking</span>.cutMeet()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>([step1,step2,step3])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是实际三个步骤之间并没有依赖关系，是可以同时进行的，所以我们需要使用结构化并发，让他们并发执行</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cooking</span>()</span> <span class="keyword">async</span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> withTaskGroup(of: <span class="type">String</span>.<span class="keyword">self</span>) &#123; group <span class="keyword">in</span></span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="type">Cooking</span>.cutVegetable()</span><br><span class="line">        &#125;</span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="type">Cooking</span>.cutOnion()</span><br><span class="line">        &#125;</span><br><span class="line">        group.addTask &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="type">Cooking</span>.cutMeet()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> steps : [<span class="type">String</span>] <span class="operator">=</span> []</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">await</span> finishedStep <span class="keyword">in</span> group &#123;</span><br><span class="line">            steps.append(finishedStep)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子只要10秒左右就可以完成任务了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">await</span> cooking()</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在执行子任务的过程中发生了异常，那么<code>cooking()</code>方法将会退出，任何尚未完成的子任务都将自动取消。</p><h2 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h2><p>由于我们现在已经多很多异步操作的场景，所以自然我们在设计类的时候，也要注意这个类要是被多个线程同时访问的时候引起的状态变化的问题。</p><p>Swift 5.5引入了Actor，它在概念上类似于在并发环境中可以安全使用的类。Swift 确保在任何给定时间只能由单个线程访问 Actor 内的可变状态，这有助于在编译器级别消除各种严重的错误。</p><p>比如以下代码在单线程情况下是安全的，但是如果是多线程访问的话<code>deck</code>属性会出现资源竞争的问题</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RiskyCollector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> deck: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">deck</span>: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.deck <span class="operator">=</span> deck</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span>(<span class="params">card</span> <span class="params">selected</span>: <span class="type">String</span>, <span class="params">to</span> <span class="params">person</span>: <span class="type">RiskyCollector</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> deck.contains(selected) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">        deck.remove(selected)</span><br><span class="line">        person.transfer(card: selected)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">transfer</span>(<span class="params">card</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        deck.insert(card)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>危险：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = Set<span class="symbol">&lt;String&gt;</span>([<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;11&quot;</span>,<span class="string">&quot;12&quot;</span>])</span><br><span class="line"><span class="keyword">let</span> risky = RiskyCollector(deck:<span class="keyword">set</span>)</span><br><span class="line"><span class="keyword">for</span> i in <span class="number">1</span>...<span class="number">12</span> &#123;</span><br><span class="line">    DispatchQueue.<span class="keyword">global</span>().async &#123;</span><br><span class="line">        _ = risky.send(card: <span class="string">&quot;\(i)&quot;</span>, <span class="keyword">to</span>: risky)</span><br><span class="line">        <span class="keyword">print</span>(risky.deck)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Actor 通过引入 Actor 隔离解决了这个问题：除非异步执行，否则无法从 Actor 对象外部读取属性和方法，并且根本无法从 Actor 对象外部写入属性。 Swift 会自动将这些请求放入一个按顺序处理的队列中，以避免出现多线程竞争。</p><p>我们可以使用Actor重新实现一个SafeCollector，如下:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">actor <span class="type">SafeCollector</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> deck: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line">  <span class="function"><span class="keyword">init</span>(<span class="params">deck</span>: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;)</span> &#123;</span><br><span class="line">      <span class="keyword">self</span>.deck <span class="operator">=</span> deck</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">send</span>(<span class="params">card</span> <span class="params">selected</span>: <span class="type">String</span>, <span class="params">to</span> <span class="params">person</span>: <span class="type">SafeCollector</span>)</span> <span class="keyword">async</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">      <span class="keyword">guard</span> deck.contains(selected) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">      deck.remove(selected)</span><br><span class="line">      <span class="keyword">await</span> person.transfer(card: selected)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">transfer</span>(<span class="params">card</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">      deck.insert(card)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安全：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> <span class="operator">=</span> <span class="type">Set</span>&lt;<span class="type">String</span>&gt;([<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;11&quot;</span>,<span class="string">&quot;12&quot;</span>])</span><br><span class="line"><span class="keyword">let</span> risky <span class="operator">=</span> <span class="type">SafeCollector</span>(deck:<span class="keyword">set</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">12</span> &#123;</span><br><span class="line">    <span class="type">Task</span> &#123;</span><br><span class="line">        <span class="keyword">_</span> <span class="operator">=</span> <span class="keyword">await</span> risky.send(card: <span class="string">&quot;<span class="subst">\(i)</span>&quot;</span>, to: risky)</span><br><span class="line">        <span class="built_in">print</span>(<span class="keyword">await</span> risky.deck)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中有几件事情需要注意：</p><ul><li><p>actor内对外暴露的方法都是异步方法，即使没有标记async，因为它会等到另一个 SafeCollector actor 能够处理请求。</p></li><li><p>actor 可以自由地、异步或以其他方式使用自己的属性和方法，但是当与不同的 actor 交互时，它必须始终异步完成。通过这些特性，Swift 可以确保永远不会同时访问所有与 actor 隔离的状态，更重要的是，这是在编译时完成的，以保证线程安全。</p></li></ul><p>Actor 和 Class 有一些相似之处：</p><ul><li><p>两者都是引用类型，因此它们可用于共享状态。</p></li><li><p>它们可以有方法、属性、初始值设定项和下标。</p></li><li><p>它们可以实现协议。任何静态属性和方法在这两种类型中的行为都相同。</p></li></ul><p>除了 Actor 隔离之外，Actor 和 Class之间还有另外两个重要的区别：</p><ul><li><p>Actor 目前不支持继承，这在未来可能会改变</p></li><li><p>所有 Actor 都隐式遵守一个新的 Actor Protocol</p></li></ul><h3 id="Global-Actor"><a href="#Global-Actor" class="headerlink" title="Global Actor"></a>Global Actor</h3><p>Global Actor 将 actor 隔离的概念扩展到了全局状态，即使状态和函数分散在许多不同的模块中，Global Actor 可以在并发程序中安全地使用全局变量，例如 Swift 提供的 <code>@MainActor</code> 限制属性和方法只能在主线程访问</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MainActor</span> <span class="function"><span class="keyword">func</span> <span class="title">refreshUI</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;updating ui…&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MainActor</span> <span class="keyword">var</span> globalTextSize: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@MainActor</span> <span class="function"><span class="keyword">func</span> <span class="title">increaseTextSize</span>()</span> &#123;</span><br><span class="line">  globalTextSize <span class="operator">+=</span> <span class="number">2</span>   <span class="comment">// okay:</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notOnTheMainActor</span>()</span> <span class="keyword">async</span> &#123;</span><br><span class="line">  globalTextSize <span class="operator">=</span> <span class="number">12</span>  <span class="comment">// error: globalTextSize is isolated to MainActor</span></span><br><span class="line">  increaseTextSize()   <span class="comment">// error: increaseTextSize is isolated to MainActor, cannot call synchronously</span></span><br><span class="line">  <span class="keyword">await</span> increaseTextSize() <span class="comment">// okay: asynchronous call hops over to the main thread and executes there</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要简述Swift 5.5新特性 async与await的常用方式&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="Swift" scheme="https://www.arclin.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 5 Property Wrapper</title>
    <link href="https://www.arclin.cn/post/1bf095f2.html"/>
    <id>https://www.arclin.cn/post/1bf095f2.html</id>
    <published>2021-07-29T16:14:00.000Z</published>
    <updated>2021-08-21T08:59:39.068Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲述Swift5新特性Property Wrapper的使用</p><span id="more"></span><p>Property Wrapper即属性包装器，用于对某个属性进行包装，包装后可以对其做一些约束、限制或者修改</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>举例，比如我们需要添加一个属性包装器用来包装字符串，对字符串长度进行限制，只有当字符串长度在允许范围内，才能被赋值到属性中</p><p>创建一个属性包装器，<code>wrappedValue</code>是必须的，并且需要实现其setter和getter，在里面添加赋值判断逻辑</p><p>我们可以提供两种属性包装器的初始化方法，一种是设置默认字符串长度上下限，一种是设置特定的字符串长度上下限</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value : <span class="type">String</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> minLength : <span class="type">Int</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> maxLength : <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> wrappedValue : <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (minLength<span class="operator">...</span>maxLength).contains(newValue.count) &#123;</span><br><span class="line">                value <span class="operator">=</span> newValue</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> minLength <span class="operator">&gt;</span> newValue.count &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;字符串太短了&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;字符串太长了&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 默认5-10个字</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>()</span> &#123;</span><br><span class="line">        minLength <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">        maxLength <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">        value <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 设置默认值</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">minLength</span>: <span class="type">Int</span>, <span class="params">maxLength</span>: <span class="type">Int</span>, <span class="params">value</span>: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.maxLength <span class="operator">=</span> maxLength</span><br><span class="line">        <span class="keyword">self</span>.minLength <span class="operator">=</span> minLength</span><br><span class="line">        <span class="keyword">self</span>.value <span class="operator">=</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用属性包装器的方式如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">     <span class="comment">/// 自定义初始化方式</span></span><br><span class="line">    <span class="meta">@StringWrapper</span>(minLength: <span class="number">3</span>, maxLength: <span class="number">5</span>) <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="comment">/// 默认初始化方式</span></span><br><span class="line">    <span class="meta">@StringWrapper</span> <span class="keyword">var</span> title : <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">person.name <span class="operator">=</span> <span class="string">&quot;ARCLIN&quot;</span></span><br><span class="line">person.title <span class="operator">=</span> <span class="string">&quot;Hyper Agent GridMan&quot;</span></span><br><span class="line"><span class="built_in">print</span>(person.name) <span class="comment">/// ARCLIN</span></span><br><span class="line"><span class="built_in">print</span>(person.title) <span class="comment">/// 字符串太长了</span></span><br></pre></td></tr></table></figure><h2 id="从属性包装器中呈现一个值"><a href="#从属性包装器中呈现一个值" class="headerlink" title="从属性包装器中呈现一个值"></a>从属性包装器中呈现一个值</h2><p>属性包装器还提供了另外一个属性，这个属性一般情况下可以用来标记被包装的属性是否被修改过</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringWrapper</span> </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">  <span class="keyword">var</span> projectedValue <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> wrappedValue : <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">get</span> &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">      <span class="keyword">set</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (minLength<span class="operator">...</span>maxLength).contains(newValue.count) &#123;</span><br><span class="line">              value <span class="operator">=</span> newValue</span><br><span class="line">              projectedValue <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> minLength <span class="operator">&gt;</span> newValue.count &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;字符串太短了&quot;</span>)</span><br><span class="line">              projectedValue <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;字符串太长了&quot;</span>)</span><br><span class="line">              projectedValue <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过<code>$</code>符号来调用这个值</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@StringWrapper</span>(minLength: <span class="number">3</span>, maxLength: <span class="number">5</span>) <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">person.name <span class="operator">=</span> <span class="string">&quot;JASON&quot;</span></span><br><span class="line"><span class="built_in">print</span>(person.<span class="variable">$name</span>) <span class="comment">// 打印false，因为这时候长度符合规范</span></span><br><span class="line">person.name <span class="operator">=</span> <span class="string">&quot;HyperJASON&quot;</span></span><br><span class="line"><span class="built_in">print</span>(person.<span class="variable">$name</span>) <span class="comment">// 打印true，因为这时候长度太长了</span></span><br></pre></td></tr></table></figure><p>这个属性也用来可以返回别的东西</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@propertyWrapper</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringWrapper</span> </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">  <span class="keyword">var</span> projectedValue : <span class="type">NSAttributedString</span> &#123;</span><br><span class="line">      <span class="comment">/// 构建出一个富文本对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="type">NSAttributedString</span>(string: <span class="string">&quot;--- <span class="subst">\(<span class="keyword">self</span>.value)</span> ---&quot;</span>, attributes: [</span><br><span class="line">          .foregroundColor : <span class="type">UIColor</span>.red,</span><br><span class="line">          .font : <span class="type">UIFont</span>.systemFont(ofSize: <span class="number">15</span>)</span><br><span class="line">      ])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wrappedValue : <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">get</span> &#123; <span class="keyword">return</span> value &#125;</span><br><span class="line">      <span class="keyword">set</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (minLength<span class="operator">...</span>maxLength).contains(newValue.count) &#123;</span><br><span class="line">              value <span class="operator">=</span> newValue</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> minLength <span class="operator">&gt;</span> newValue.count &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;字符串太短了&quot;</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;字符串太长了&quot;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@StringWrapper</span>(minLength: <span class="number">3</span>, maxLength: <span class="number">5</span>) <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">person.name <span class="operator">=</span> <span class="string">&quot;JASON&quot;</span></span><br><span class="line"><span class="built_in">print</span>(person.<span class="variable">$name</span>)</span><br><span class="line"><span class="comment">/*  打印出一个富文本对象</span></span><br><span class="line"><span class="comment">--- JASON ---&#123;</span></span><br><span class="line"><span class="comment">    NSColor = &quot;UIExtendedSRGBColorSpace 1 0 0 1&quot;;</span></span><br><span class="line"><span class="comment">    NSFont = &quot;&lt;UICTFont: 0x7fc199f06660&gt; font-family: \&quot;.SFUI-Regular\&quot;; font-weight: normal; font-style: normal; font-size: 15.00pt&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要讲述Swift5新特性Property Wrapper的使用&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="Swift" scheme="https://www.arclin.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 -- Runloop</title>
    <link href="https://www.arclin.cn/post/fee6666f.html"/>
    <id>https://www.arclin.cn/post/fee6666f.html</id>
    <published>2021-07-21T14:10:50.000Z</published>
    <updated>2021-08-25T16:02:31.329Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述iOS中Runloop的一些使用以及原理</p><span id="more"></span><h2 id="Runloop对象"><a href="#Runloop对象" class="headerlink" title="Runloop对象"></a>Runloop对象</h2><ul><li>iOS中有两套API来访问和使用Runloop<ul><li>Foundation : NSRunLoop</li><li>Core Foundation : CFRunloopRef</li></ul></li><li>NSRunloop和CFRunloopRef都代表着Runloop对象</li><li>NSRunloop是基于CFRunloopRef的一层OC包装</li><li>CFRunloopRef是开源的</li></ul><p>获取当前Runloop的两个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop *runloop &#x3D; [NSRunLoop currentRunLoop];</span><br><span class="line">CFRunLoopRef runloopRef &#x3D; CFRunLoopGetCurrent();</span><br></pre></td></tr></table></figure><p>打印runloop可以发现类型是<code>&lt;CFRunLoop 0x600001994300 [0x101405a98]&gt;</code>，跟runloopRef一致，但是打印地址不一样，原因是<code>NSRunLoop</code>是对<code>CFRunLoopRef</code>的封装，<code>CFRunLoopRef</code>是存储在其内部，所以会不一样</p><h2 id="Runloop与线程"><a href="#Runloop与线程" class="headerlink" title="Runloop与线程"></a>Runloop与线程</h2><ul><li><p>每条线程都有唯一的一个与之对应的Runloop对象</p></li><li><p>Runloop保存在一个全局的Dictionary里，线程作为key，Runloop作为Value</p><ul><li>Runloop源码 <code>CFRunloop.c</code>中我们可以找到<code>CFRunLoopGetCurrent()</code>内调用了<code>_CFRunLoopGet0()</code>，在这里面可以看到这行代码得以验证</li></ul>  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef loop = (CFRunLoopRef)<span class="constructor">CFDictionaryGetValue(<span class="params">__CFRunLoops</span>, <span class="params">pthreadPointer</span>(<span class="params">t</span>)</span>);</span><br></pre></td></tr></table></figure></li><li><p>线程刚创建的时候并没有Runloop对象，Runloop会在第一次获取它时创建</p><ul><li>主线程一开始也是没有Runloop的，只是因为在<code>main.m</code>中调用了<code>UIApplicationMain</code>函数，在这里面回去获取Runloop从而创建了Runloop</li><li>对应源码如下</li></ul>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CF_EXPORT</span> <span class="built_in">CFRunLoopRef</span> _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">        loop = (<span class="built_in">CFRunLoopRef</span>)<span class="built_in">CFDictionaryGetValue</span>(__CFRunLoops,pthreadPointer(t));</span><br><span class="line">        <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">            <span class="built_in">CFDictionarySetValue</span>(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">            loop = newLoop;</span><br><span class="line">        &#125;</span><br><span class="line">         __CFUnlock(&amp;loopsLock);</span><br><span class="line">   <span class="built_in">CFRelease</span>(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Runloop会在线程结束时销毁</p></li><li><p>主线程的Runloop已经自动获取（创建），子线程默认没有开启Runloop</p></li></ul><h2 id="Runloop相关的类"><a href="#Runloop相关的类" class="headerlink" title="Runloop相关的类"></a>Runloop相关的类</h2><p>Core Foundation 中关于Runloop的5个类</p><ul><li>CFRunloopRef</li><li>CFRunloopModeRef</li><li>CFRunloopSourceRef</li><li>CFRunloopTimerRef</li><li>CFRunloopObserverRef</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoop * <span class="built_in">CFRunloopRef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    ...</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems;</span><br><span class="line">    <span class="built_in">CFRunloopModeRef</span> _currentMode;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoopMode *<span class="built_in">CFRunLoopModeRef</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0; <span class="comment">// CFRunloopSourceRef数组</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1; <span class="comment">// CFRunloopSourceRef数组</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// CFRunloopObserverRef数组</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers; <span class="comment">// CFRunloopTimerRef数组 </span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过源码我们可以得知，一个Runloop对象里面有多个mode，存放在<code>_modes</code>成员属性里面。其中有一个mode是<code>_currentMode</code>。 然后每个mode都有<code>name</code>、<code>source0</code>、<code>source1</code>等数组属性</p><ul><li>CFRunloopModeRef 代表Runloop的运行模式</li><li>Runloop启动只能选择其中一个Mode作为currentMode</li><li>如果需要切换Mode，只能退出当前Loop，再重新选择一个Mode进入<ul><li>不同组的Source0/Source1/Timer/Observer能分隔开来，互不影响</li></ul></li><li>如果Mode里面没有任何Source0/Source1/Timer/Observer，Runloop会立马退出</li></ul><h3 id="CFRunloopModeRef"><a href="#CFRunloopModeRef" class="headerlink" title="CFRunloopModeRef"></a>CFRunloopModeRef</h3><ul><li><p>两种常见的Mode</p><ul><li><code>kCFRunLoopDefaultMode</code>（<code>NSDefaultRunloopMode</code>）: App的默认Mode，通常主线程是在这个Mode下运行</li><li><code>UITrackingRunLoopMode</code>界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响</li></ul></li><li><p>Source0</p><ul><li>触摸事件处理</li><li><code>performSelector:onThread:</code></li></ul></li><li><p>Source1</p><ul><li>基于Port的线程间通信</li><li>系统事件捕捉（捕捉后到Source0去处理）</li></ul></li><li><p>Timers</p><ul><li>NSTimer</li><li><code>performSelector:withObject:afterDelay:</code></li></ul></li><li><p>Observers</p><ul><li>用于监听Runloop的状态</li><li>UI刷新（BeforeWaiting）在Runloop休眠之前会执行一次UI刷新</li><li>Autorelease pool 在Runloop休眠之前自动释放某些内存</li></ul></li></ul><h3 id="CFRunloopObserverRef"><a href="#CFRunloopObserverRef" class="headerlink" title="CFRunloopObserverRef"></a>CFRunloopObserverRef</h3><p>Runloop的几种状态</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>),         <span class="comment">// 即将进入Loop </span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),  <span class="comment">// 即将处理Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>),  <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>),          <span class="comment">// 即将退出Loop</span></span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以自己添加一个监听者来监听Runloop的状态变化</p><ol><li>定义监听回调</li></ol>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> observeRunLoopActivities(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> *info) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopEntry&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeTimers&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeSources&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeWaiting&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopAfterWaiting&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopExit&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建监听者</li></ol>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 创建Observer</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, observeRunLoopActivities, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/// 添加Observer</span></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), observer, kCFRunLoopCommonModes);</span><br><span class="line"><span class="built_in">CFRelease</span>(observer);</span><br></pre></td></tr></table></figure><h2 id="Runloop的运行逻辑"><a href="#Runloop的运行逻辑" class="headerlink" title="Runloop的运行逻辑"></a>Runloop的运行逻辑</h2><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><ol><li>通知Observers：进入Loop</li><li>通知Observers：即将处理Timers</li><li>通知Observers：即将处理Sources</li><li>处理Blocks（特指执行CFRunLoopPerformBlock内的block参数） <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">CFRunLoopPerformBlock</span>(CFRunLoopGetCurrent(), kCFRunLoopCommonModes, ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>处理Source0（可能会再次处理Blocks，因为有可能在处理Source0的时候添加了Blocks）</li><li>如果存在Source1，就跳转到第8步</li><li>通知Observers：开始休眠（等待消息唤醒）</li><li>通知Observers：结束休眠（被某个消息唤醒，被什么东西唤醒就处理什么东西）<ul><li>处理Timer</li><li>处理GCD Async To Main Queue</li><li>处理Source1</li></ul></li><li>处理Blocks</li><li>根据前面的执行结果，决定如何操作（如下几种可能）<ol><li>回到第2步</li><li>退出Loop</li></ol></li><li>通知Observers：退出Loop</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>通过在控制台执行命令<code>bt</code>我们可以看到开始是调用了<code>CFRunLoopRunSpecific</code>函数，核心源码如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SInt32 <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/// 通知Observers：进入Loop</span></span><br><span class="line">__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 具体要做的事情</span></span><br><span class="line">result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 通知Observers：退出Loop</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后查看一下<code>__CFRunLoopRun</code>内的核心处理代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int32_t __CFRunLoopRun(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopModeRef</span> rlm, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle, <span class="built_in">CFRunLoopModeRef</span> previousMode) &#123;</span><br><span class="line">    ...</span><br><span class="line">    int32_t retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 通知Observers：即将处理Timers</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 通知Observers：即将处理Sources</span></span><br><span class="line">         __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 处理Blocks</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 处理Source0</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            <span class="comment">/// 处理Blocks</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Boolean poll = sourceHandledThisLoop || (<span class="number">0</span>ULL == timeout_context-&gt;termTSR);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 判断有无Source1</span></span><br><span class="line">        <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="comment">/// 如果有Source1，就跳转到handle_msg</span></span><br><span class="line">            <span class="keyword">goto</span> handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 通知Observers：即将休眠</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/// 等待别的消息来唤醒当前线程</span></span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        <span class="comment">/// 通知Observers：结束休眠</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        </span><br><span class="line">    handle_msg:;</span><br><span class="line">        <span class="comment">/// 被Timer唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_TIMER</span>();</span><br><span class="line">            <span class="comment">/// 处理Timers</span></span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer, because we apparently fired early</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">/// 被GCD唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort == dispatchPort) &#123;</span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_DISPATCH</span>();</span><br><span class="line">            <span class="comment">/// 处理GCD</span></span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/// 被Source1唤醒</span></span><br><span class="line">            <span class="built_in">CFRUNLOOP_WAKEUP_FOR_SOURCE</span>();</span><br><span class="line">            <span class="comment">/// 处理Source1</span></span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 处理Blocks</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 设置返回值</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行顺序跟我们上面提及的执行流程是相似的，最后的返回值如果是0的话，那么就继续循环，如果是其他值，那么就会退出循环，继而退出Runloop</p><p>上面提及的处理Timers函数，处理GCD函数和处理Source1的函数，都会调用到<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_xxx_FUNCTION__</code>这个函数(这个xxx代表Observer、Block、Source0或者Timer等，见下表)，在这个函数里面，再去执行对应的操作，比如UIKit的界面刷新、Foundation定时器的执行</p><table><thead><tr><th>执行的事情</th><th>调用的函数</th></tr></thead><tbody><tr><td>进入Loop</td><td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</strong></td></tr><tr><td>处理Blocks</td><td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK</strong></td></tr><tr><td>处理Source0</td><td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION</strong></td></tr><tr><td>处理Timer</td><td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION</strong></td></tr><tr><td>处理GCD</td><td><strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong></td></tr><tr><td>处理SOURCE1</td><td><strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION</strong></td></tr></tbody></table><p>GCD只有在回调到主线程的时候才会调用到Runloop的函数，比如下面这种情况 </p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>,<span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Runloop休眠的实现原理"><a href="#Runloop休眠的实现原理" class="headerlink" title="Runloop休眠的实现原理"></a>Runloop休眠的实现原理</h3><p>当Runloop需要休眠的时候，会调用用户态的API，然后内部调用mach_msg()切换到内核态，当有消息的时候，就会从内核态切换回用户态的API去处理消息</p><p>用户态 ： mach_msg() -&gt; 内核态： mach_msg() -&gt; 用户态：处理消息</p><p>内核态：</p><ol><li>等待消息</li><li>没有消息就让线程休眠</li><li>有消息就唤醒线程</li></ol><h2 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h2><p>由于NSTimer默认是运行在<code>NSDefaultRunloopMode</code>的，所以在滚动的时候不会执行定时器，因为滚动的时候系统会切换到<code>UITrackingRunLoopMode</code></p><p>这时候我们需要把NSTimer设置到<code>NSRunLoopCommonModes</code>里，如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,++count);</span><br><span class="line">&#125;];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure><p><code>NSDefaultRunloopMode</code>、<code>UITrackingRunLoopMode</code>才是真正存在的模式</p><p><code>NSRunLoopCommonModes</code>并不是一个真的模式，它只是一个标记</p><p>timer能在<code>_commonModes</code>数组中存放的模式下工作</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    ...</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes; <span class="comment">// 存放着NSDefaultRunloopMod，UITrackingRunLoopMode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// 存放着common模式下要处理的对象，比如上面的timer</span></span><br><span class="line">    <span class="built_in">CFRunloopModeRef</span> _currentMode;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes; <span class="comment">// 存放着所有的模式</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="线程保活"><a href="#线程保活" class="headerlink" title="线程保活"></a>线程保活</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>一般情况下，我们创建线程后，当线程的任务执行完了，线程就会销毁，所以有时候我们需要让线程执行完任务后依旧存在，等到我们主动让他销毁他才会销毁。</p><p>首先我们创建一条线程</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>要让这条线程一直活着，我们可以让这个<code>run</code>方法不要结束</p><p>这里添加一个Runloop，由于获取Runloop的时候就会创建Runloop，所以我们获取Runloop即可，然后调用<code>addPort:forMode:</code>方法，添加一个<code>Source0</code></p><p>这样子线程就会卡在<code>[[NSRunLoop currentRunLoop] run];</code>这一行中，不会让方法执行完，线程也就不会销毁</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %s begin&quot;</span>,<span class="built_in">NSThread</span>.currentThread,__func__);</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">    <span class="comment">/// 不会走到这里</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %s end&quot;</span>,<span class="built_in">NSThread</span>.currentThread,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后下一步我们需要调用一个方法去销毁这个线程，比如<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>，但是如果我们这么做</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)stop &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 尝试在我们指定的线程上停止这个线程内的Runloop</span></span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(stop) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br></pre></td></tr></table></figure><p>发现线程不会销毁，原因是<code>[[NSRunLoop currentRunLoop] run];</code>执行后，会在一个死循环内执行Runloop的<code>runMode:beforeDate:</code>方法，类似于</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode: beforeDate:xxx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CFRunLoopStop(CFRunLoopGetCurrent());</code>只是停止了其中的一次方法调用，进入下个循环后又会开启，所以用这个方法去完全停止Runloop是没用的</p><p>所以我们要使用别的方式去替代<code>[[NSRunLoop currentRunLoop] run];</code>开启线程，因为这个<code>run</code>方法是专门用于开启一个永不销毁的线程。</p><p>只需要改造一下上面那个while方法就好，给self添加一个bool属性</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="built_in">BOOL</span> isStop;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %s begin&quot;</span>,<span class="built_in">NSThread</span>.currentThread,__func__);</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    <span class="keyword">while</span>(!<span class="keyword">self</span>.isStop) &#123;</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ %s end&quot;</span>,<span class="built_in">NSThread</span>.currentThread,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stop &#123;</span><br><span class="line">    <span class="keyword">self</span>.isStop = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样子我们调用run方法线程就会启动，调用stop方法，while循环就会退出，<code>CFRunLoopStop(CFRunLoopGetCurrent());</code>停止了本次RunLoop，Runloop退出，这样子就能走到打印end那里，线程的方法走完了，线程就可以销毁了</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyThread</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 开启线程</span></span><br><span class="line">- (<span class="keyword">void</span>)run;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 销毁线程</span></span><br><span class="line">- (<span class="keyword">void</span>)stop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 执行任务</span></span><br><span class="line">- (<span class="keyword">void</span>)executeTask:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyThread</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Thread *innerThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span>=isStopped) <span class="built_in">BOOL</span> stopped;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyThread</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        </span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 创建线程 开启Runloop</span></span><br><span class="line">        <span class="keyword">self</span>.innerThread = [[Thread alloc] initWithBlock:^&#123;</span><br><span class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/// 因为dealloc的时候weakSelf已经空了，所以要明确self存在并且不停止时候，才循环启动Runloop</span></span><br><span class="line">            <span class="keyword">while</span> (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;</span><br><span class="line">                [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 开启线程，启动Runloop</span></span><br><span class="line">    [<span class="keyword">self</span>.innerThread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stop &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 停止线程</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__stop) onThread:<span class="keyword">self</span>.innerThread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)executeTask:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread || !block) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 执行子线程任务</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__executeTask:) onThread:<span class="keyword">self</span>.innerThread withObject:block waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - private method</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__stop &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 标记需要退出Runloop</span></span><br><span class="line">    <span class="keyword">self</span>.stopped = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 退出本次Runloop</span></span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 取消强引用</span></span><br><span class="line">    <span class="keyword">self</span>.innerThread = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__executeTask:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="comment">/// 自动调用停止方法</span></span><br><span class="line">    [<span class="keyword">self</span> stop];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 只是为了监听线程的销毁行为</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Thread</span> : <span class="title">NSThread</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Thread</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲述iOS中Runloop的一些使用以及原理&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Swift 5.4 Result Builder</title>
    <link href="https://www.arclin.cn/post/4bf15bdf.html"/>
    <id>https://www.arclin.cn/post/4bf15bdf.html</id>
    <published>2021-07-18T02:13:00.000Z</published>
    <updated>2021-08-21T09:01:12.999Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲述Swift 5.4的新特性 Result Builder在设计上的一些使用方式</p><span id="more"></span><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>假如我们有一个需求，需要往ScrollView上加入不同类型的View，并且根据不确定的的顺序从上往下进行排列，所以一般情况下我们可以这样子设计框架</p><ol><li>首先定义一个协议，遵循协议的对象使用一个build方法返回一个View</li></ol>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>这里我们设计四种颜色的View，宽度均为屏幕宽度，高度不定</li></ol>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WhiteView</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> view <span class="operator">=</span> <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">UIScreen</span>.main.bounds.width, height: <span class="number">100</span>))</span><br><span class="line">        view.backgroundColor <span class="operator">=</span> .white</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RedView</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> banner <span class="operator">=</span> <span class="type">UIView</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">UIScreen</span>.main.bounds.width, height: <span class="number">200</span>))</span><br><span class="line">        banner.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.red</span><br><span class="line">        <span class="keyword">return</span> banner</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlueView</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> goodsView <span class="operator">=</span> <span class="type">UIView</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">UIScreen</span>.main.bounds.width, height: <span class="number">350</span>))</span><br><span class="line">        goodsView.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.blue</span><br><span class="line">        <span class="keyword">return</span> goodsView</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GreenView</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> dynamicView <span class="operator">=</span> <span class="type">UIView</span>.<span class="keyword">init</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">UIScreen</span>.main.bounds.width, height: <span class="number">400</span>))</span><br><span class="line">        dynamicView.backgroundColor <span class="operator">=</span> <span class="type">UIColor</span>.green</span><br><span class="line">        <span class="keyword">return</span> dynamicView</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>最后我们再定义一个ScrollView的容器，传入一个数组，让其从上到下进行排列</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScrollableContainer</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> contents : [<span class="type">ViewBuilder</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> scrollView <span class="operator">=</span> <span class="type">UIScrollView</span>.<span class="keyword">init</span>(frame: <span class="type">UIScreen</span>.main.bounds)</span><br><span class="line">    <span class="keyword">_</span> <span class="operator">=</span> contents.reduce(<span class="type">CGFloat</span>(<span class="number">0</span>)) &#123; currentY, builder <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> view <span class="operator">=</span> builder.build()</span><br><span class="line">        view.frame.origin.y <span class="operator">=</span> currentY</span><br><span class="line">        scrollView.addSubview(view)</span><br><span class="line">        scrollView.contentSize <span class="operator">=</span> <span class="type">CGSize</span>(width: <span class="type">UIScreen</span>.main.bounds.size.width, height: scrollView.subviews.last<span class="operator">!</span>.frame.maxY)</span><br><span class="line">        <span class="keyword">return</span> currentY <span class="operator">+</span> view.frame.size.height</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scrollView</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样子我们就可以开始布局了</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scrollView <span class="operator">=</span> <span class="type">ScrollableContainer</span>(contents: [</span><br><span class="line">    <span class="type">RedView</span>(),</span><br><span class="line">    <span class="type">BlueView</span>(),</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">])</span><br><span class="line">view.addSubview(scrollView.build())</span><br></pre></td></tr></table></figure><p> 效果如下</p> <img src="https://p6-tt.byteimg.com/origin/pgc-image/8f8201d352eb44a7aab4b0b68ba6e9e2.png" width=50%> </li><li><p>通过这种方式，我们就可以随意调整内部的布局顺序，也可以方便的新增多个View</p></li></ol><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>但是上述方法有一个缺点，就是当如果要重复添加多个相同的View或者说想要通过某个条件再添加View，就会有点复杂，比如当<code>needBlue == true</code>成立的时候再添加<code>BlueView</code>，那么可能需要这么写</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contents <span class="operator">=</span> [</span><br><span class="line">    <span class="type">RedView</span>(),</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> needBlue <span class="operator">==</span> <span class="literal">true</span> &#123;</span><br><span class="line">contents <span class="operator">=</span> [</span><br><span class="line">        <span class="type">RedView</span>(),</span><br><span class="line">        <span class="type">BlueView</span>(),</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scrollView <span class="operator">=</span> <span class="type">ScrollableContainer</span>(contents: contents)</span><br><span class="line">view.addSubview(scrollView.build())</span><br></pre></td></tr></table></figure><p>为了让可读性更加好，我们可以模仿SwiftUI的DSL语法进行设计，这里就需要使用到Swift 5.4的新特性 Result Builder</p><ol><li><p>首先我们要添加一个容器结构体，因为从上到下写的<code>View</code>会被整成一个数组或者多参数传进来，所以要加一个容器把他们从上到下排列好，最后排列完了，再把这个容器放进去ScrollView中</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ViewContainer</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> contents : [<span class="type">ViewBuilder</span>]</span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">         <span class="keyword">let</span> container <span class="operator">=</span> <span class="type">UIView</span>(frame: <span class="type">UIScreen</span>.main.bounds)</span><br><span class="line">         <span class="keyword">_</span> <span class="operator">=</span> contents.reduce(<span class="type">CGFloat</span>(<span class="number">0</span>), &#123; currentY, builder <span class="keyword">in</span></span><br><span class="line">             <span class="keyword">let</span> view <span class="operator">=</span> builder.build()</span><br><span class="line">             view.frame.origin.y <span class="operator">=</span> currentY</span><br><span class="line">             container.addSubview(view)</span><br><span class="line">             container.frame.size <span class="operator">=</span> <span class="type">CGSize</span>(width: <span class="type">UIScreen</span>.main.bounds.size.width, height: container.subviews.last<span class="operator">!</span>.frame.maxY)</span><br><span class="line">             <span class="keyword">return</span> currentY <span class="operator">+</span> view.frame.size.height</span><br><span class="line">         &#125;)</span><br><span class="line">         <span class="keyword">return</span> container</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个Result builder，使用<code>@resultBuilder</code>注解会要求我们添加一个<code>buildBlock</code>方法，实现这个方法，把我们外面传进来的多个View放进去<code>VieContainer</code>容器中，然后实现<code>buildFinalResult</code>在编写结束的时候把<br><code>VieContainer</code>放进去<code>ScrollView</code>容器中</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@resultBuilder</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScrollableViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildBlock</span>(<span class="keyword">_</span> <span class="params">components</span>: <span class="type">ViewBuilder</span>...)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ViewContainer</span>(contents: components)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildFinalResult</span>(<span class="keyword">_</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ScrollableContainer</span>(contents: [component])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这时候我们通过新增的<code>ScrollableViewBuilder</code>来创建一个方法，这里的闭包就是待会我们要写DSL的地方</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">build</span>(<span class="meta">@ScrollableViewBuilder</span> <span class="params">content</span>: () -&gt; <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> content()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个方法传入一个闭包，这个由于我们已经实现了<code>buildBlock</code>，所以<code>content</code>被<code>@ScrollableViewBuilder</code>修饰之后，会自动将闭包内的东西转化成多参数，传入<code>buildBlock</code>方法，在那里面我们把各种各样的<code>View</code>给添加到<code>ViewContainer</code>上，方法调用如下</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> build &#123;</span><br><span class="line">    <span class="type">RedView</span>()</span><br><span class="line">    <span class="type">BlueView</span>()</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">view.addSubview(result.build())</span><br></pre></td></tr></table></figure><p> 这时候运行效果同上图一致</p></li><li><p>接下来我们需要让这个闭包内支持if语句、else if语句、else语句和for语句，</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScrollableViewBuilder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildBlock</span>(<span class="keyword">_</span> <span class="params">components</span>: <span class="type">ViewBuilder</span>...)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">ScrollableContainer</span>(contents: components)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 表示if语句</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildEither</span>(<span class="params">first</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> component</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 表示eles if语句</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildEither</span>(<span class="params">second</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> component</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// 表示else语句和其他的可选值（即？修饰的View）</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildOptional</span>(<span class="keyword">_</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>?)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> component <span class="operator">??</span> <span class="type">DefaultView</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后我们试一试这么写</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> build &#123;</span><br><span class="line">    <span class="type">RedView</span>()</span><br><span class="line">    <span class="type">BlueView</span>()</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">    <span class="keyword">if</span> flag <span class="operator">==</span> <span class="number">1</span> &#123;</span><br><span class="line">        <span class="type">RedView</span>()</span><br><span class="line">        <span class="type">RedView</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> flag <span class="operator">==</span> <span class="number">2</span> &#123;</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> flag <span class="operator">==</span> <span class="number">3</span> &#123;</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">BlueView</span>()</span><br><span class="line">        <span class="type">BlueView</span>()</span><br><span class="line">        <span class="type">BlueView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当flag = 1的时候，首先两个<code>RedView()</code>会先进入<code>buildBlock</code>方法，然后被包装成一个<code>ViewContainer</code>，然后再进去<code>buildEither(first component: ViewBuilder)</code>方法，这里我没处理就直接把传进来的值返回出去了</p><p> 当flag = 2 或者 flag = 3 的时候，首先括号内的多个<code>GreenView()</code>会先进入<code>buildBlock</code>方法，然后被包装成一个<code>ViewContainer</code>，然后再进去<code>buildEither(second component: ViewBuilder)</code>方法，这里我没处理就直接把传进来的值返回出去了</p><p> 当 flag 为其他值的时候，首先括号内的多个<code>BlueView()</code>会先进入<code>buildBlock</code>方法，然后被包装成一个<code>ViewContainer</code>，然后再进去<code>buildEither(second component: ViewBuilder)</code>方法。当没有写<code>eles</code>语句的时候，需要实现<code>buildOptional(_ component: ViewBuilder?)</code>方法，去处理没有进入<code>if</code>语句而导致的不返回<code>View</code>的情况，如果没有写<code>else</code>语句，那么不会进入<code>buildBlock</code>，会直接取空值情况下你返回的默认<code>View</code>。</p></li><li><p>处理for语句，比如这样</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> build &#123;</span><br><span class="line">    <span class="type">RedView</span>()</span><br><span class="line">    <span class="type">BlueView</span>()</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">2</span> &#123;</span><br><span class="line">        <span class="type">GreenView</span>()</span><br><span class="line">        <span class="type">BlueView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>for</code>里面需要返回3个<code>GreenView+BlueView</code>，这里他每次调用for的括号里面的内容，都会走一遍<code>buildBlock</code>把里面的<code>GreenView+BlueView</code>封装成一个<code>ViewContainer</code>，所以这里会产生3个<code>ViewContainer</code>，最后这三个会变成一个数组，进入<code>buildArray</code>方法，再封装成一个<code>ViewContainer</code>，代码如下</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@resultBuilder</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScrollableViewBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildBlock</span>(<span class="keyword">_</span> <span class="params">components</span>: <span class="type">ViewBuilder</span>...)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ViewContainer</span>(contents: components)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildEither</span>(<span class="params">first</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> component</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildEither</span>(<span class="params">second</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> component</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildOptional</span>(<span class="keyword">_</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>?)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> component <span class="operator">??</span> <span class="type">WhiteView</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildArray</span>(<span class="keyword">_</span> <span class="params">components</span>: [<span class="type">ViewBuilder</span>])</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ViewContainer</span>(contents: components)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildFinalResult</span>(<span class="keyword">_</span> <span class="params">component</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ScrollableContainer</span>(contents: [component])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理表达式，如果我们要在DSL里面插一些除了<code>View</code>之外的一些东西，那么就需要添加对应的处理方法，比如</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> build &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a123&quot;</span>)</span><br><span class="line">    <span class="type">RedView</span>()</span><br><span class="line">    <span class="type">BlueView</span>()</span><br><span class="line">    <span class="type">GreenView</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 针对这个<code>print</code>我们添加表达式处理</p><p> ScrollableViewBuilder</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 针对正常的表达式，就直接返回</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildExpression</span>(<span class="keyword">_</span> <span class="params">expression</span>: <span class="type">ViewBuilder</span>)</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> expression</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 针对特殊的表达式，返回空View</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">buildExpression</span>(<span class="keyword">_</span> <span class="params">expression</span>: ())</span> -&gt; <span class="type">ViewBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">EmptyBuilder</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> EmptyBuilder</p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EmptyBuilder</span> : <span class="title">ViewBuilder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">build</span>()</span> -&gt; <span class="type">UIView</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">UIView</span>.<span class="keyword">init</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里就说的差不多了，其他本文没提及到的内容可以参阅<a href="https://developer.apple.com/videos/play/wwdc2021/10253/">Write a DSL in Swift using result builders</a></p><p>本文<a href="https://github.com/Arc-lin/ResultBuilderDemo">Demo</a>地址</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要讲述Swift 5.4的新特性 Result Builder在设计上的一些使用方式&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="Swift" scheme="https://www.arclin.cn/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 -- Runtime API</title>
    <link href="https://www.arclin.cn/post/11ed4e5e.html"/>
    <id>https://www.arclin.cn/post/11ed4e5e.html</id>
    <published>2021-07-17T15:13:00.000Z</published>
    <updated>2021-07-17T15:53:09.367Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述Runtime的一些常用API</p><span id="more"></span><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>动态创建一个类（参数：父类，类名，额外的内存空间）</p><p><code>Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes)</code></p><p>注册一个类（要在类注册之前添加成员变量）</p><p><code>void objc_registerClassPair(Class cls) </code></p><p>销毁一个类</p><p><code>void objc_disposeClassPair(Class cls)</code></p><p>获取isa指向的Class</p><p><code>Class object_getClass(id obj)</code></p><p>设置isa指向的Class</p><p><code>Class object_setClass(id obj, Class cls)</code></p><p>判断一个OC对象是否为Class</p><p><code>BOOL object_isClass(id obj)</code></p><p>判断一个Class是否为元类</p><p><code>BOOL class_isMetaClass(Class cls)</code></p><p>获取父类</p><p><code>Class class_getSuperclass(Class cls)</code></p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>获取一个实例变量信息</p><p><code>Ivar class_getInstanceVariable(Class cls, const char *name)</code></p><p>拷贝实例变量列表（最后需要调用free释放）</p><p><code>Ivar *class_copyIvarList(Class cls, unsigned int *outCount)</code></p><p>设置和获取成员变量的值</p><p><code>void object_setIvar(id obj, Ivar ivar, id value)</code></p><p><code>id object_getIvar(id obj, Ivar ivar)</code></p><p>动态添加成员变量（已经注册的类是不能动态添加成员变量的,alignment一般传1，types传成员变量类型，如<code>@encode(int)</code>，<code>@encode(NSObject *)</code>）</p><p><code>BOOL class_addIvar(Class cls, const char * name, size_t size, uint8_t alignment, const char * types)</code></p><p>获取成员变量的相关信息</p><p><code>const char *ivar_getName(Ivar v)</code></p><p><code>const char *ivar_getTypeEncoding(Ivar v)</code></p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>获取一个属性</p><p><code>objc_property_t class_getProperty(Class cls, const char *name)</code></p><p>拷贝属性列表（最后需要调用free释放）</p><p><code>objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</code></p><p>动态添加属性</p><p><code>BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)</code></p><p>动态替换属性</p><p><code>void class_replaceProperty(Class cls, const char *name, const objc_property_attribute_t *attributes,unsigned int attributeCount)</code></p><p>获取属性的一些信息</p><p><code>const char *property_getName(objc_property_t property)</code></p><p><code>const char *property_getAttributes(objc_property_t property)</code></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>获得一个实例方法、类方法</p><p><code>Method class_getInstanceMethod(Class cls, SEL name)</code></p><p><code>Method class_getClassMethod(Class cls, SEL name)</code></p><p>方法实现相关操作</p><p><code>IMP class_getMethodImplementation(Class cls, SEL name) </code></p><p><code>IMP method_setImplementation(Method m, IMP imp)</code></p><p>方法交换（方法交换之后会清空方法缓存）<br><code>void method_exchangeImplementations(Method m1, Method m2) </code></p><p>拷贝方法列表（最后需要调用free释放）</p><p><code>Method *class_copyMethodList(Class cls, unsigned int *outCount)</code></p><p>动态添加方法</p><p><code>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)</code></p><p>动态替换方法（不存在原有方法则动态添加该方法并且返回nil）</p><p><code>IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)</code></p><p>获取方法的相关信息（带有copy的需要调用free去释放）</p><p><code>SEL method_getName(Method m)</code></p><p><code>IMP method_getImplementation(Method m)</code></p><p><code>const char *method_getTypeEncoding(Method m)</code></p><p><code>unsigned int method_getNumberOfArguments(Method m)</code></p><p><code>char *method_copyReturnType(Method m)</code></p><p><code>char *method_copyArgumentType(Method m, unsigned int index)</code></p><p>选择器相关</p><p><code>const char *sel_getName(SEL sel)</code></p><p><code>SEL sel_registerName(const char *str)</code></p><p>用block作为方法实现</p><p><code>IMP imp_implementationWithBlock(id block)</code></p><p><code>id imp_getBlock(IMP anImp)</code></p><p><code>BOOL imp_removeBlock(IMP anImp)</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要简述Runtime的一些常用API&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- 方法、消息发送与super关键字</title>
    <link href="https://www.arclin.cn/post/5ed61a9.html"/>
    <id>https://www.arclin.cn/post/5ed61a9.html</id>
    <published>2021-06-28T17:11:00.000Z</published>
    <updated>2021-08-25T16:05:35.774Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述类（元类）对象里面的方法缓存、消息发送（包括消息发送，动态方法解析与消息转发）与super关键字的底层原理</p><span id="more"></span><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Class对象的结构"><a href="#Class对象的结构" class="headerlink" title="Class对象的结构"></a>Class对象的结构</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache; <span class="comment">// 方法缓存</span></span><br><span class="line">    class_data_bits_t bits; <span class="comment">// 用于获取具体的类信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>bits</code>成员变量与<code>FAST_DATA_MASK</code>进行一次与运算之后，会获得一个其属性可读可写的对象的地址，这个对象长这样</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    <span class="keyword">const</span> clsss_ro_t *ro;</span><br><span class="line">    method_array_t * methods; <span class="comment">// 方法列表</span></span><br><span class="line">    property_array_t *properties; <span class="comment">// 属性列表</span></span><br><span class="line">    protocol_array_t protocols; <span class="comment">// 协议列表</span></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>class_ro_t</code>里面存放的是类的原始信息(不包括分类里面的东西)，是仅可读的，结构如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    unit32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize; <span class="comment">// instance对象占用的内存空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP__64__</span></span><br><span class="line">    uint32_t reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> uint8_t *ivarLayout;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name; <span class="comment">// 类名</span></span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars; <span class="comment">// 成员变量列表</span></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIverLayout;</span><br><span class="line">    property_list_t * baseProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h3><p><code>class_rw_t</code>里面的methods、properties、protocols是二维数组，是可读可写的，比如方法列表随时可以新增<code>method_list_t</code>类型的数据进去。<code>class_rw_t</code>包含了类的初始内容和分类的内容，其中方法列表类似如下结构</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">method_array_t: [</span><br><span class="line">    method_list_t : [</span><br><span class="line">      method_t,</span><br><span class="line">      method_t,</span><br><span class="line">      method_t</span><br><span class="line">    ],</span><br><span class="line">    method_list_t : [</span><br><span class="line">      method_t,</span><br><span class="line">      method_t,</span><br><span class="line">      method_t</span><br><span class="line">    ],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>objc_class</code>内有一个<code>data()</code>函数，其返回值一开始是指向<code>class_ro_t</code>类型的对象的。在合并分类内的内容时，才会产生<code>class_rw_t</code>类型的对象，并指向这个对象。可以参考runtime源码，<code>objc-runtime-new.mm</code>中<code>realizeClassWithoutSwift</code>函数的实现，这里贴出关键部分</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class realizeClassWithoutSwift(Class cls, Class previously)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    auto ro = (<span class="keyword">const</span> class_ro_t *)cls-&gt;data();</span><br><span class="line">    auto isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line">    <span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">        rw = cls-&gt;data();</span><br><span class="line">        ro = cls-&gt;data()-&gt;ro();</span><br><span class="line">        ASSERT(!isMeta);</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">        rw = objc::zalloc&lt;class_rw_t&gt;();</span><br><span class="line">        rw-&gt;set_ro(ro);</span><br><span class="line">        rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">        cls-&gt;setData(rw);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h3><p><code>class_ro_t</code>里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，所以不能新增内容，包含了类的初始内容，其中方法列表类似如下结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">method_list_t</span> : [</span><br><span class="line">  <span class="keyword">method_t</span>,</span><br><span class="line">  <span class="keyword">method_t</span>,</span><br><span class="line">  <span class="keyword">method_t</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>在runtime源码，<code>objc-runtime-new.mm</code>中的<code>attachCategories</code>方法中我们可以看到分类合并到<code>class_rw_t</code>对象的过程，比如方法的合并如下</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">method_list_t *mlist = entry.cat-&gt;methods<span class="constructor">ForMeta(<span class="params">isMeta</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mcount<span class="operator"> == </span><span class="number">64</span>) &#123;</span><br><span class="line">        prepare<span class="constructor">MethodLists(<span class="params">cls</span>, <span class="params">mlists</span>, <span class="params">mcount</span>, NO, <span class="params">fromBundle</span>, <span class="params">__func__</span>)</span>;</span><br><span class="line">        rwe-&gt;methods.attach<span class="constructor">Lists(<span class="params">mlists</span>, <span class="params">mcount</span>)</span>;</span><br><span class="line">        mcount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mlists<span class="literal">[ATTACH<span class="identifier">_BUFSIZ</span> - <span class="operator">++</span><span class="identifier">mcount</span>]</span> = mlist;</span><br><span class="line">    fromBundle <span class="pattern-match">|= entry.hi-&gt;is<span class="constructor">Bundle()</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><ul><li><code>method_t</code>是对方法/函数的封装（下面是缩减版定义）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function">SEL <span class="title">name</span><span class="params">()</span></span>; <span class="comment">// 函数名</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">types</span><span class="params">()</span></span>; <span class="comment">// 编码（返回值类型、参数类型）</span></span><br><span class="line">    <span class="function">IMP <span class="title">imp</span><span class="params">(<span class="keyword">bool</span> needsLock)</span></span>; <span class="comment">// 指向函数的指针（函数地址）</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>IMP</code>代表具体函数的实现</p><p>  <code>typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</code></p></li><li><p><code>SEL</code>可以代表方法\函数名，一般叫做选择器，底层结构跟<code>char *</code>类似</p><p>  <code>typedef struct objc_selector *SEL</code>;</p><ul><li>可以通过<code>@selector()</code>和<code>sel_registerName()</code>获得</li><li>可以通过<code>sel_getName()</code>和<code>NSStringFromSelector()</code>转成字符串</li><li>不同类中相同名字的方法，所对应的方法选择器是相同的</li></ul></li><li><p><code>types</code>包含了函数返回值、参数编码的字符串，称作<code>Type Encodings</code>（类型编码），具体可以参考<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100">苹果官方文档</a></p><ul><li>比如<code>-（void）test:(int)a;</code>的方法编码为<code>v@:i</code>，v = void,@表示指针变量(因为编译后第一个参数是self)，：表示选择器(因为编译后第二个参数是_cmd)，</li><li>有时类型编码会带上数字，比如<code>v16@0:8</code>，第一个数字表示这个函数的参数一共占用16个字节，第二个数字开始往后的数字都代表偏移值，0代表第一个参数的字节偏移值为0，第三个数字8代表偏移8个字节，也就是第一个参数已经占用了8个字节了，所以第二个参数就从第8个字节开始</li></ul></li></ul><h3 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h3><ul><li>Class内部结构中有个方法缓存（cache_t），用散列表来缓存曾经调用过的方法，可以提高方法的查找速度</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cache_t &#123;</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            explicit_atomic&lt;mask_t&gt;    _maybeMask; <span class="comment">// 散列表的长度 - 1</span></span><br><span class="line">            uint16_t                   _flags;</span><br><span class="line">            uint16_t                   _occupied; <span class="comment">// 已经缓存的方法数量</span></span><br><span class="line">        &#125;;</span><br><span class="line">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;</span><br><span class="line">    &#125;;   </span><br><span class="line">    <span class="keyword">struct</span> bucket_t *buckets() <span class="keyword">const</span>;</span><br><span class="line">    mask_t mask() <span class="keyword">const</span>;</span><br><span class="line">    mask_t occupied() <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，通过<code>buckets()</code>函数我们可以得知<code>_bucketsAndMaybeMask</code>是一个存放<code>bucket_t</code>数组的指针（即<code>_bucketsAndMaybeMask</code>指针指向的是数组的第一个元素），是通过位运算取出来的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> bucket_t *cache_t::buckets() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    uintptr_t addr = _bucketsAndMaybeMask.load(memory_order_relaxed);</span><br><span class="line">    <span class="keyword">return</span> (bucket_t *)(addr &amp; bucketsMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>bucket_t</code>的结构如下</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="class">bucket_t </span>&#123;</span><br><span class="line">    explicit_atomic<span class="params">&lt;uintptr_t&gt;</span> _imp; <span class="comment">// 函数的内存地址</span></span><br><span class="line">    explicit_atomic<span class="params">&lt;SEL&gt;</span> _sel; <span class="comment">// SEL作为key</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过IMP和SEL，我们就可以调用方法了，所以综上所述，一个实例对象调用方法，其类对象从方法缓存里面找方法的大概流程就是</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取sel : class - isa - 偏移<span class="number">16</span>个字节 - <span class="keyword">cache_t </span>- <span class="keyword">buckets() </span>- [<span class="keyword">bucket_t] </span>- 计算出下标index - <span class="keyword">bucket_t </span>- sel()</span><br><span class="line">获取imp : class - isa - 偏移<span class="number">16</span>个字节 - <span class="keyword">cache_t </span>- <span class="keyword">buckets() </span>- [<span class="keyword">bucket_t] </span>- 计算出下标index - <span class="keyword">bucket_t </span>- imp(nil,cls)</span><br></pre></td></tr></table></figure><p>另外<code>_bucketsAndMaybeMask</code>之所以叫这个名字是因为它不仅存放着<code>buckets</code>还存放着<code>maybeMask</code>，在arm64位真机环境下，取高16位，如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mask_t cache_t::mask() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    uintptr_t maskAndBuckets = _bucketsAndMaybeMask.load(memory_order_relaxed);</span><br><span class="line">    <span class="comment">//maskShift 为48,</span></span><br><span class="line">    <span class="keyword">return</span> maskAndBuckets &gt;&gt; maskShift;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法缓存的流程"><a href="#方法缓存的流程" class="headerlink" title="方法缓存的流程"></a>方法缓存的流程</h4><p>先看看runtime源码中，将方法插入缓存的函数（摘抄核心流程）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cache_t::insert(SEL sel, IMP imp, <span class="keyword">id</span> receiver)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//对_occupied赋值 + 1。首次 newOccupied = 1。</span></span><br><span class="line">    mask_t newOccupied = occupied() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//旧容量，（mask + 1） 或者 0</span></span><br><span class="line">    <span class="keyword">unsigned</span> oldCapacity = capacity(), capacity = oldCapacity;</span><br><span class="line">    <span class="comment">//是否为空，首次进入这里</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(isConstantEmptyCache())) &#123;</span><br><span class="line">        <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">        <span class="comment">//默认容量给4</span></span><br><span class="line">        <span class="keyword">if</span> (!capacity) capacity = INIT_CACHE_SIZE;<span class="comment">//1 &lt;&lt; 2 = 4</span></span><br><span class="line">        <span class="comment">//0 4 false 开辟新的容器空间。由于旧容器为空这里不需要释放传false。</span></span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="comment">/* freeOld */</span><span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//newOccupied + 1 (相当于 _occupied + 2) &lt;= capacity * 3 / 4 容量够的时候什么都不做，直接插入。&lt;=75%的容积正常插入，否则扩容。</span></span><br><span class="line">    <span class="comment">//## ⚠️在arm64位的情况下，CACHE_END_MARKER 0 扩容条件为：7 / 8 87.5% 这个时候CACHE_ALLOW_FULL_UTILIZATION 为 1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fastpath(newOccupied + <span class="built_in">CACHE_END_MARKER</span> &lt;= cache_fill_ratio(capacity))) &#123;</span><br><span class="line">        <span class="comment">// Cache is less than 3/4 or 7/8 full. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CACHE_ALLOW_FULL_UTILIZATION</span></span><br><span class="line">    <span class="comment">//capacity &lt;= 1&lt;&lt;3 (8), _occupied + 1（CACHE_END_MARKER为0） &lt;= 容量。少于8个元素的时候允许100%占满。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (capacity &lt;= FULL_UTILIZATION_CACHE_SIZE &amp;&amp; newOccupied + <span class="built_in">CACHE_END_MARKER</span> &lt;= capacity) &#123;</span><br><span class="line">        <span class="comment">// Allow 100% cache utilization for small buckets. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//扩容</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//容量不为空返回 2倍的容量，否则返回4</span></span><br><span class="line">        capacity = capacity ? capacity * <span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line">        <span class="comment">//MAX_CACHE_SIZE 1&lt;&lt;16 = 2^16。最大缓存65536</span></span><br><span class="line">        <span class="keyword">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">            capacity = MAX_CACHE_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开辟新的容器控件，释放旧的空间。</span></span><br><span class="line">        reallocate(oldCapacity, capacity, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从_bucketsAndMaybeMask获取buckets</span></span><br><span class="line">    bucket_t *b = buckets();</span><br><span class="line">    mask_t m = capacity - <span class="number">1</span>;<span class="comment">//首次是4-1</span></span><br><span class="line">    <span class="comment">//计算插入的index</span></span><br><span class="line">    mask_t begin = cache_hash(sel, m);</span><br><span class="line">    mask_t i = begin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for the first unused slot and insert there.</span></span><br><span class="line">    <span class="comment">// There is guaranteed to be an empty slot.</span></span><br><span class="line">    <span class="comment">//循环判断插入数据。</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//能走到这里大概率是cache不存在，所以这里走fastpath</span></span><br><span class="line">        <span class="keyword">if</span> (fastpath(b[i].sel() == <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">//Occupied + 1</span></span><br><span class="line">            incrementOccupied();</span><br><span class="line">            <span class="comment">//buckets中插入bucket</span></span><br><span class="line">            b[i].set&lt;Atomic, Encoded&gt;(b, sel, imp, cls());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已经存在了，不进行任何处理。有可能是其它线程插入的。</span></span><br><span class="line">        <span class="keyword">if</span> (b[i].sel() == sel) &#123;</span><br><span class="line">            <span class="comment">// The entry was added to the cache by some other thread</span></span><br><span class="line">            <span class="comment">// before we grabbed the cacheUpdateLock.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cache_next为了防止hash冲突。再hash了一次（下文会讲到）。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (fastpath((i = cache_next(i, m)) != begin));</span><br><span class="line">    <span class="comment">//异常处理</span></span><br><span class="line">    bad_cache(receiver, (SEL)sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首次进入isConstantEmptyCache分支。会创建一个容量为4的空buckets。这个时候由于旧buckets不存在不需要释放所以参数传递false。</li><li>当容量大于等于3/4或7/8的情况下扩容。arm64的条件下为7 / 8。</li><li>arm64条件下容量小于等于8的时候会占用100%才扩容。</li><li>扩容是直接翻倍，默认值4。最大值MAX_CACHE_SIZE为216(65536)。在扩容的时候直接释放了旧值。</li><li>mask值为capacity - 1</li><li>通过cache_hash（下文会提及的散列表算法）计算插入的index，后面会通过cache_next再进行计算hash解决冲突问题。</li><li>循环判断通过b[i].set插入bucket数据。</li><li><strong>reallocate函数在开辟控件的同时，把缓存给直接清空了</strong>，清空之后再把现在要缓存的方法放进去，所以扩容后occupied会为1。</li></ul><h4 id="散列表（哈希表）缓存"><a href="#散列表（哈希表）缓存" class="headerlink" title="散列表（哈希表）缓存"></a>散列表（哈希表）缓存</h4><ul><li><p>方法缓存的容器，不是简单的数组，而是用散列表的方式进行存储。</p><p>假如现在散列表长度为10，那么mask（即cache_t里面的_maybeMask）就是10-1 = 9，当selector传进来的时候，会跟mask进行一次与运算，如下：</p><p><code>@selector(personTest) &amp; mask = 4</code></p><p>假如得到的结果是4的话，那么就会插在列表的下标为4的位置，其他位置因为已经开辟好空间了，所以有值就放值，没值就NULL</p><p>这种列表的好处是，当想取到特定的bucket_t的时候，只需要把selector跟mask进行一次与运算，就可以直接得到下标，然后直接从列表取出，这样子就不用遍历查找了，大大节约了性能。</p><p>另外，由于与运算的特性，跟mask进行与运算之后的值，都不可能比mask更大，这样子就保证不会插入越界的位置。</p></li><li><p>如果通过计算后的下标值，插入列表的时候发现已经有东西了那怎么办？</p><p>  这也就是所谓的Hash冲突。为了处理这种问题，系统会调用<code>cache_next</code>函数</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">mask_t</span> <span class="title">cache_next</span><span class="params">(<span class="keyword">mask_t</span> i, <span class="keyword">mask_t</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i ? i<span class="number">-1</span> : mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  也就是说如果<code>@selector(personTest) &amp; mask = 4</code>的4已经有东西了，那么就取 4 - 1 = 3，如果3还有东西，就放在2的位置，如果2还有，就放在1，以此类推，如果直到0都还没有可以插入的位置，那么就从mask的位置开始找，也就是9，然后再找9看看是否可以插入，插不进去再找8，以此类推，找到为止。</p><p>  由于列表在存放数量达到容量的87.5%的时候就会两倍的扩容（arm64），扩容后又会清空缓存，所以一定能找到合适的位置插入的。</p></li></ul><h2 id="消息发送机制"><a href="#消息发送机制" class="headerlink" title="消息发送机制"></a>消息发送机制</h2><p>调用一个不存在的方法的时候，他会经历这么一个流程</p><p>消息发送 - （找不到方法的话） -&gt; 动态方法解析 - （没有实现的话） -&gt; 消息转发 -&gt; （没有实现的话） -&gt; 抛出异常</p><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p>假如我们这么调用一个方法</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[person personTest]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>底层会转换为</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(person,sel_registerName(<span class="string">&quot;personTest&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>这里的person我们称作消息接受者（receiver），就是调用方法的对象，如果这里还是调用类方法的话，那么这里就会传入一个类对象</li><li><code>sel_registerName()</code>函数等价于<code>@selector</code></li><li>为了性能，<code>objc_msgSend</code>方法底层是使用汇编和C++实现的</li></ul><p>消息发送的流程如下：</p><ol><li>receiver 是否为空，如果是退出，否则继续</li><li>从receiver的类对象（如果传入的是类则找的是元类对象，下文统称为receiverClass）的cache中查找方法，如果找到则调用方法，如果找不到则继续</li><li>从receiverClass中的<code>class_rw_t</code>中查找方法，如果找到则调用方法，并将方法插入缓存，如果找不到则继续</li><li>从<code>superClass</code>的cache中查找方法，有则调用并缓存到当前receiverClass的cache中(不是superClass的cache),否则继续</li><li>从<code>superClass</code>的<code>class_rw_t</code>中找，有则调用并缓存到receiverClass的cache中，否则继续</li><li>继续通过<code>superClass</code>的<code>superClass</code>找方法，流程回到4，直到再也没有父类了，并且也找不到方法，那么将会进入动态方法解析阶段。</li></ol><p>其中：</p><ul><li>如果是从<code>class_rw_t</code>中查找方法，若方法列表已经排序好，那么就使用二分查找法查找</li><li>如果是还没排序的方法，那么就使用遍历的方法查找</li><li>在缓存中查找方法的过程也称作快速查找（使用汇编实现），在<code>class_rw_t</code>中查找方法的过程也称作慢速查找(使用汇编和C++实现)，C++部分方法源码在<code>lookUpImpOrForward</code>函数中，如下：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(<span class="keyword">id</span> inst, SEL sel, Class cls, <span class="keyword">int</span> behavior)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> IMP forward_imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    IMP imp = <span class="literal">nil</span>;</span><br><span class="line">    Class curClass;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    <span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(behavior &amp; LOOKUP_CACHE)) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done_nolock;</span><br><span class="line">    &#125;</span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!cls-&gt;isRealized())) &#123;</span><br><span class="line">        cls = realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</span><br><span class="line">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    curClass = cls;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> attempts = unreasonableClassCount();;) &#123;</span><br><span class="line">        <span class="comment">// curClass method list.</span></span><br><span class="line">        Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slowpath((curClass = curClass-&gt;superclass) == <span class="literal">nil</span>)) &#123;</span><br><span class="line">            imp = forward_imp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(--attempts == <span class="number">0</span>)) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Memory corruption in class list.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Superclass cache.</span></span><br><span class="line">        imp = cache_getImp(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (slowpath(imp == forward_imp)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fastpath(imp)) &#123;</span><br><span class="line">            <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">        behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">        <span class="keyword">return</span> resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">    &#125;</span><br><span class="line"> done:</span><br><span class="line">    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"> done_nolock:</span><br><span class="line">    <span class="keyword">if</span> (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp == forward_imp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>慢速查找流程图：</p><img src="https://p5-tt.byteimg.com/origin/pgc-image/47b512631098428e8bc60162e1df4ab7.png" ><p>消息发送流程图：</p><img src="https://p9-tt.byteimg.com/origin/pgc-image/70dfbbc7f61a4a9fac15e5ff1af809b4.png"><h3 id="动态方法解析（也称：动态方法决议）"><a href="#动态方法解析（也称：动态方法决议）" class="headerlink" title="动态方法解析（也称：动态方法决议）"></a>动态方法解析（也称：动态方法决议）</h3><p>当消息发送流程找不到方法后就会进入动态方法解析流程。</p><p>动态方法解析是当消息发送阶段找不到方法的时候，开发者可以通过重写特定方法（如果是类方法就重写<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>，如果是对象方法就重写<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>），给原先不存在的方法添加方法实现。主要是用到runtime里面的<code>class_addMethod</code>函数，并且动态解析后，会重新走”消息发送“的流程</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>假如这里的person没有实现print方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [Person new];</span><br><span class="line">[person print];</span><br></pre></td></tr></table></figure><p>那我们可以在<code>Person.m</code>添加一个方法实现用来替换丢失的<code>print</code>，这里我们用<code>truePrint</code>来替代</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)truePrint &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;true print&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取truePrint方法的Method对象</span></span><br><span class="line">        Method truePrint = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(truePrint));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 动态添加print方法的实现，通过method_getImplementation获取到方法的函数指针，通过method_getTypeEncoding拿到方法的函数编码即 v@: 或 v16@0:8</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, method_getImplementation(truePrint), method_getTypeEncoding(truePrint));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回YES代表有动态添加方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Method的结构"><a href="#Method的结构" class="headerlink" title="Method的结构"></a>Method的结构</h4><p>点击Method我们可以看到结构如下</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *<span class="function"><span class="keyword">Method</span>;</span></span><br></pre></td></tr></table></figure><p>而<code>ojbc_method</code>的定义如下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">struct</span> objc_method &#123;</span><br><span class="line">    <span class="attribute">SEL</span> _Nonnull method_name;</span><br><span class="line">    <span class="attribute">char</span> * _Nullable method_types;</span><br><span class="line">    <span class="attribute">IMP</span> _Nonnull method_imp;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>可以看到跟上面所说的<code>method_t</code>是类似的东西</p><p>以下是一些拿到<code>Method</code>对象后可以使用的一些函数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数调用，但是不接收返回值类型为结构体</span></span><br><span class="line">method_invoke</span><br><span class="line"><span class="comment">// 函数调用，但是接收返回值类型为结构体</span></span><br><span class="line">method_invoke_stret</span><br><span class="line"><span class="comment">// 获取函数名</span></span><br><span class="line">method_getName</span><br><span class="line"><span class="comment">// 获取函数实现IMP</span></span><br><span class="line">method_getImplementation</span><br><span class="line"><span class="comment">// 获取函数type encoding</span></span><br><span class="line">method_getTypeEncoding</span><br><span class="line"><span class="comment">// 复制返回值类型</span></span><br><span class="line">method_copyReturnType</span><br><span class="line"><span class="comment">// 复制参数类型</span></span><br><span class="line">method_copyArgumentType</span><br><span class="line"><span class="comment">// 获取返回值类型</span></span><br><span class="line">method_getReturnType</span><br><span class="line"><span class="comment">// 获取参数个数</span></span><br><span class="line">method_getNumberOfArguments</span><br><span class="line"><span class="comment">// 获取函数参数类型</span></span><br><span class="line">method_getArgumentType</span><br><span class="line"><span class="comment">// 获取函数描述</span></span><br><span class="line">method_getDescription</span><br><span class="line"><span class="comment">// 设置函数实现IMP</span></span><br><span class="line">method_setImplementation</span><br><span class="line"><span class="comment">// 交换函数的实现IMP</span></span><br><span class="line">method_exchangeImplementations</span><br></pre></td></tr></table></figure><h4 id="Runtime中的原理"><a href="#Runtime中的原理" class="headerlink" title="Runtime中的原理"></a>Runtime中的原理</h4><p>在上面的消息发送的流程函数<code>lookUpImpOrForward</code>中，有一段代码如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">    behavior ^= LOOKUP_RESOLVER;</span><br><span class="line">    return resolve<span class="constructor">Method_locked(<span class="params">inst</span>, <span class="params">sel</span>, <span class="params">cls</span>, <span class="params">behavior</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当找不到消息的时候就会进入动态方法解析的流程即<code>resolveMethod_locked</code>，如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NEVER_INLINE IMP resolveMethod_locked(<span class="keyword">id</span> inst, SEL sel, Class cls, <span class="keyword">int</span> behavior) &#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveClassMethod(inst, sel, cls);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNilTryCache(inst, sel, cls)) &#123;</span><br><span class="line">            resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForwardTryCache(inst, sel, cls, behavior);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面我们可以发现<code>resolveInstanceMethod</code>和<code>resolveClassMethod</code>两个函数，分别是实现实例方法的动态消息解析和类方法的动态消息解析，这两个长得差不多，所以我们拿实例对象的函数查看一下</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static void resolveInstanceMethod(id inst, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    ASSERT(<span class="function"><span class="title">cls</span>-&gt;</span>isRealized());</span><br><span class="line">    SEL resolve_sel = @selector(resolveInstanceMethod:);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (!lookUpImpOrNilTryCache(cls, resolve_sel, cls-&gt;</span>ISA(<span class="comment">/*authenticated*/</span><span class="literal">true</span>))) &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    bool resolved = msg(cls, resolve_sel, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveInstanceMethod adds to self a.k.a. cls</span></span><br><span class="line">    IMP imp = lookUpImpOrNilTryCache(inst, sel, cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;RESOLVE: method %c[%s %s] &quot;</span></span><br><span class="line">                         <span class="string">&quot;dynamically resolved to %p&quot;</span>, </span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>isMetaClass() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn&#x27;t add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</span></span><br><span class="line">                         <span class="string">&quot;, but no new implementation of %c[%s %s] was found&quot;</span>,</span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel), </span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>isMetaClass() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                         <span class="function"><span class="title">cls</span>-&gt;</span>nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们可以看到对<code>resolveInstanceMethod</code>方法进行了一次<code>objc_msgSend</code>调用，调用之后又执行了<code>lookUpImpOrNilTryCache</code>函数进行了缓存，如果缓存成功，那么下次调用这个方法就不会在进入动态方法解析阶段，直接通过消息发送阶段就调用成功了。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>根据我们以前所学的知识可以知道，方法查找的流程为</p><p>实例方法：类 – 父类 – 父类 – … – 根类 – nil</p><p>类方法：元类 – 父元类 – 父元类 – … – 根元类 – 根类 – nil</p><p>也就是说丢失的方法最后都会回到根类去找方法，一般情况下是<code>NSObject</code></p><p>通过这个特性，我们可以直接在<code>NSObject</code>上添加分类，然后实现动态解析方法，根据方法名前缀进行判断，然后统一处理未被找到的方法添加默认实现。通过这种方式我们可以减少一些找不到方法导致的崩溃问题，提升用户体验。</p><h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>如果没有实现动态方法解析，那么将进入消息转发阶段。消息转发即把消息交给别人发送的意思。</p><p>从上面的<code>lookUpImpOrForward</code>函数的源码我们可以看到，最后是调用了<code>_objc_msgForward_impcache</code>这个函数，这个函数是通过汇编实现的</p><p>要实现消息转发，我们有两种方式，一种是实现一个方法<code>-forwardingTargetForSelector</code>，一种是实现<code>-methodSignatureForSelector</code>和<code>-forwardInvocation</code>，比如</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[Student alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了这个方法之后，最后系统会去我们提供的<code>Student</code>对象去寻找<code>print</code>方法，找到了的话就会进行调用。注意这个方法每次都会进来，每次都会生成新的<code>Student</code>对象对其<code>print</code>方法进行调用。</p><p>如果<code>forwardingTargetForSelector</code>没实现或者返回空的话</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就会寻找<code>-methodSignatureForSelector</code>和<code>-forwardInvocation</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 方法签名： 返回值类型、参数类型</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">&quot;v16@0:8&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数</span></span><br><span class="line"><span class="comment">/// anInvocation.target 方法调用者</span></span><br><span class="line"><span class="comment">/// anInvocation.selector 方法名</span></span><br><span class="line"><span class="comment">//// [anInvocation getArgument:NULL atIndex:0] 方法参数</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:[[Student alloc] init]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们在方法签名中指定方法类型，然后在<code>forwardInvocation</code>方法中，修改target，然后直接调用，这样子就会直接调用Student的print方法了</p><img src="https://p3-tt.byteimg.com/origin/pgc-image/ba2d1d5ff71a49c8913690d6f69fb7d7.png" width=80%><h4 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h4><p>当系统执行到<code>forwardInvocation</code>的时候，无论在方法内有任何实现，都不会执行到<code>doseNotRecognizeSelector</code>（抛出异常），所以实现了就不会崩，即便什么都不做。</p><p>在<code>forwardInvocation</code>内我们可以拿到方法调用的很多信息，比如方法调用者<code>anInvocation.target</code>、方法名<code>anInvocation.selector</code>和方法参数</p><p>比如调用方法为<code>[person print:1]</code>，进入到<code>forwardInvocation</code>后我们可以通过以下方法拿到<code>1</code>这个参数</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    [anInvocation getArgument:&amp;a atIndex:<span class="number">2</span>]; <span class="comment">// 第一个参数是self，第二个是_cmd，所以从下标2开始取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要拿返回值的话，就可以这么做</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:[[Student alloc] init]]; <span class="comment">// 要先调用一下Student的print方法，这里假设返回值是整型</span></span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    [anInvocation getReturnValue:&amp;result];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,result); <span class="comment">/// 这里可以拿到返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NSMethodSignature"><a href="#NSMethodSignature" class="headerlink" title="NSMethodSignature"></a>NSMethodSignature</h4><p><code>[NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;]</code>，注意这里的方法编码要跟下面<code>forwardInvocation</code>要调用的方法的方法编码一致 </p><p>我们除了可以通过方法编码拿到<code>NSMethodSignature</code>对象之外，还可以这么做</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(print)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [[Student new] methodSignatureForSelector:<span class="keyword">@selector</span>(print)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类方法的消息转发"><a href="#类方法的消息转发" class="headerlink" title="类方法的消息转发"></a>类方法的消息转发</h4><p><code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code></p><p><code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code></p><p><code>+ (void)forwardInvocation:(NSInvocation *)anInvocation</code></p><p>这几个方法也有类方法版本，但是代码补全没出来，但是实际使用是可行的</p><p><code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>在这个方法里面返回的消息接受者既可以是类对象也可以是实例对象。</p><h4 id="synthesize-和-dynamic"><a href="#synthesize-和-dynamic" class="headerlink" title="@synthesize 和 @dynamic"></a>@synthesize 和 @dynamic</h4><p><code>@synthesize</code>用来自动给成员变量名生成<code>setter</code>和<code>getter</code>的声明和实现</p><p><code>@dynamic</code>用来告诉编译器不要自动生成<code>setter</code>和<code>getter</code>的实现（声明还是会声明的），待到运行时开发者自己实现，并且不会为属性实现带下划线的成员变量</p><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>假如我们调用<code>Student</code>实例的一个父类方法</p><p><code>[super run:xx]</code></p><p>那么编译后会变成如下代码</p><p><code>objc_msgSendSuper(self,class_getSuperclass(objc_getClass(&quot;Student&quot;)),sel_registerName(&quot;run&quot;),xx);</code></p><p>所以<code>super</code>发送消息的本质是调用<code>objc_msgSendSuper2</code>函数，最终的消息接受者依旧是<code>self</code>，只是实例方法寻找从父类的类对象开始寻找，类方法从父类的元类对象开始寻找。</p><p>所以当我们调用方法<code>[super class]</code>的时候，跟<code>[self class]</code>没区别，返回结果是一致的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要简述类（元类）对象里面的方法缓存、消息发送（包括消息发送，动态方法解析与消息转发）与super关键字的底层原理&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- isa指针</title>
    <link href="https://www.arclin.cn/post/78ececc4.html"/>
    <id>https://www.arclin.cn/post/78ececc4.html</id>
    <published>2021-06-14T07:26:00.000Z</published>
    <updated>2021-06-15T15:52:05.333Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述isa指针在runtime内部的底层实现和isa的优化方式</p><span id="more"></span><h2 id="isa指针的底层实现"><a href="#isa指针的底层实现" class="headerlink" title="isa指针的底层实现"></a>isa指针的底层实现</h2><ul><li><p>在arm64架构出现之前，isa就是一个普通的指针(<code>Class isa</code>)，存储着Class,Meta-Class对象的内存地址</p></li><li><p>从arm64架构开始，对isa进行了优化，变成了一个共用体，还使用位域来存储更多的信息</p></li><li><p>isa指针的结构如下（objc4-818.2）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    struct &#123;</span><br><span class="line">        uintptr_t nonpointer        : 1; </span><br><span class="line">        uintptr_t has_assoc         : 1;</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">        uintptr_t shiftcls          : 33;</span><br><span class="line">        uintptr_t magic             : 6;</span><br><span class="line">        uintptr_t weakly_referenced : 1;</span><br><span class="line">        uintptr_t unused            : 1;</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">        uintptr_t extra_rc          : 19</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    bool isDeallocating() &#123;</span><br><span class="line">        return extra_rc &#x3D;&#x3D; 0 &amp;&amp; has_sidetable_rc &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    void setDeallocating() &#123;</span><br><span class="line">        extra_rc &#x3D; 0;</span><br><span class="line">        has_sidetable_rc &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setClass(Class cls, objc_object *obj);</span><br><span class="line">    Class getClass(bool authenticated);</span><br><span class="line">    Class getDecodedClass(bool authenticated);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先，共用体同结构体一样，是拥有成员变量的，但是不同的点在于所有成员变量共用一块内存，也就是说当一个成员变量有值时，其他成员变量都成了装饰。</p><p>在runtime中，我们只需要用到<code>uintptr_t bits</code>，<code>uintptr_t</code>是<code>unsigned long</code>的别名，在64位系统下占用8个字节，共64位</p><p>共用体内的<code>struct &#123; ... &#125;</code> 是为了增加可读性而添加的，它描述了<code>bits</code>里面存放了什么信息，我们一个个说明一下</p><blockquote><p>补充说明： 结构体内的冒号后面的数字表示这个成员所占的位数，举个例子，本来<code>char name</code>作为一个成员变量，是会占用一个字节，也就是8个二进制位，如果有3个这样子的成员变量，那么这个结构体就会占用3个字节，如果我们在这个成员变量的后面添加了一个数字，去限制这个成员变量所占的位数，比如<code>char name : 1</code>，那么三个这样子的成员变量就一共占用3个二进制位，也就是不到一个字节，因为系统分配内存的最小单位为1个字节，所以这个结构体就占用1个字节，这么做我们就可以节约2个字节了，这种技术叫做<strong>位域</strong>。</p></blockquote><ul><li>nonpointer<ul><li>0代表普通的指针，存储着Class、Meta-Class对象的内存地址</li><li>1代表优化过，使用位域存储着更多的信息</li></ul></li><li>has_assoc<ul><li>是否有设置过关联对象（注意是“设置过”，就算以后关联对象移除了，它还会是true），如果没有，会释放得更快</li></ul></li><li>has_cxx_dtor<ul><li>是否有C++的析构函数（.cxx_destruct），如果没有，会释放得更快</li></ul></li></ul><p>上面两个<code>会释放得更快</code>的原因是，在对象销毁的时候，会调用runtime里面的这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        &#x2F;&#x2F; Read all of the flags at once for performance.</span><br><span class="line">        bool cxx &#x3D; obj-&gt;hasCxxDtor();</span><br><span class="line">        bool assoc &#x3D; obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This order is important.</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        if (assoc) _object_remove_assocations(obj, &#x2F;*deallocating*&#x2F;true);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果<code>has_assoc</code>或者<code>has_cxx_dtor</code>的话，就不会进入判断为true的逻辑，函数会运行得更快</p><ul><li>shiftcls<ul><li>存储着Class、Meta-Class对象的内存信息</li></ul></li><li>magic<ul><li>用于在调试时分辨对象是否未完成初始化</li></ul></li><li>weakly_referenced<ul><li>是否有被弱引用指向过（同样注意“指向过”，有过即为true），如果没有，释放时会更快</li></ul></li></ul><p>“会释放得更快”是因为对象销毁时调用了如下runtime源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE void</span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    table.lock();</span><br><span class="line">    if (isa.weakly_referenced) &#123;</span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)this);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.erase(this);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>deallocating<ul><li>对象是否正在释放</li></ul></li><li>extra_rc <ul><li>里面存储的值是引用计数器减1后的值</li></ul></li><li>has_sitdtable_rc<ul><li>引用计数器是否过大无法存储在isa中</li><li>如果为1，那么引用计数器会存储在一个叫做SideTable的类的属性中</li></ul></li></ul><h2 id="如何从isa指针中取出对应的信息"><a href="#如何从isa指针中取出对应的信息" class="headerlink" title="如何从isa指针中取出对应的信息"></a>如何从isa指针中取出对应的信息</h2><p>isa是通过位运算来取出和存入信息的。</p><ul><li>我们以取出<code>shiftcls</code>内的类信息为例</li></ul><p>首先isa里面的bits存储着64个二进制位，然后其中<code>shiftcls</code>是使用了33个（从上面的共用体里面的位域看出），当系统需要取出对应信息的时候，就使用<code>ISA_MASK</code>（ISA掩码）跟bits做一次与运算，举个例子，bits的十六进制地址为<code>0x011d8001000083a5</code></p><blockquote><p>补充： ISA_MASK在arm64下的值为<code>0x0000000ffffffff8ULL</code>，下面我们把他转成二进制</p></blockquote><table><thead><tr><th></th><th>8</th><th>16</th><th>24</th><th>32</th><th>40</th><th>48</th><th>56</th><th>64</th></tr></thead><tbody><tr><td>bits<br>(0x011d8001000083a5)</td><td>1010 0101</td><td>1100 0001</td><td>0000 0000</td><td>0000 0000</td><td>1000 0000</td><td>0000 0001</td><td>1011 1000</td><td>1000 0000</td></tr><tr><td>ISA_MASK<br>(0x0000000ffffffff8)</td><td>0001 1111</td><td>1111 1111</td><td>1111 1111</td><td>1111 1111</td><td>1111 0000</td><td>0000 0000</td><td>0000 0000</td><td>0000 0000</td></tr><tr><td>与运算后的结果<br>(0x00000001000083a0)</td><td>0000 0101</td><td>1100 0001</td><td>0000 0000</td><td>0000 0000</td><td>1000 0000</td><td>0000 0000</td><td>0000 0000</td><td>0000 0000</td></tr></tbody></table><p>我们可以来验证一下</p><img src="https://z3.ax1x.com/2021/06/15/2qoart.png" width="80%"><p>可以看到 isa一开始的值跟<code>[person class]</code>的值是不相同的，跟<code>ISA_MASK</code>进行一次与运算之后就相同了，所以可以看出实例对象的isa不是直接指向类对象的，是需要进行一次运算取出来的。</p><ul><li>其他的信息如<code>nonpointer</code>等，取出的方式也类似这样，这么做的好处是充分利用了64个二进制位的内存，而不用像以前一样一个属性就占用了多个字节，造成二进制位的浪费。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲述isa指针在runtime内部的底层实现和isa的优化方式&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- Block、__block及其底层实现</title>
    <link href="https://www.arclin.cn/post/8275b854.html"/>
    <id>https://www.arclin.cn/post/8275b854.html</id>
    <published>2021-06-07T15:50:00.000Z</published>
    <updated>2021-06-14T07:24:54.237Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要简述Block、__block的本质是什么东西，文章涉及循环引用等开发常见问题，需要重点关注。</p><span id="more"></span><h2 id="先写一个最简单的block"><a href="#先写一个最简单的block" class="headerlink" title="先写一个最简单的block"></a>先写一个最简单的block</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Block&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>使用命令行将<code>main.m</code>文件编译成C++文件<br/><br><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m </code></p><p>编译完成后，上述代码会变成以下结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void(*block)(void) &#x3D; &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br></pre></td></tr></table></figure><p>可以看出是生成了一个<code>__main_block_impl_0</code>结构体类型的对象，参数1为<code>__main_block_func_0</code>，参数2为<code>&amp;__main_block_desc_0_DATA</code></p><h2 id="block的底层结构"><a href="#block的底层结构" class="headerlink" title="block的底层结构"></a>block的底层结构</h2><p>接下来查看一下<code>__main_block_impl_0</code>是什么东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; block的结构体，引用了两个结构体和实现了一个构造方法</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags&#x3D;0) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; block的结构体引用的第一个结构体</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; block的结构体引用的第二个结构体，第一个参数赋值了0，第二个参数赋值了__main_block_impl_0的结构体大小</span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure><p>所以拼接一下可以看出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags&#x3D;0) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><em><strong>结论1：block本质上是一个OC对象，它内部也有个isa指针</strong></em></li></ul><p>接下来看看构造方法，第一个参数是<code>void *fp</code>意为<code>function pointer</code>函数指针，所以我们回去看看这里传了什么值进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void(*block)(void) &#x3D; &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure><p>是<code>__main_block_func_0</code>，那我们再看看<code>__main_block_func_0</code>是什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_34b858_mi_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出我们在block内写的代码被封装成了一个函数</p><ul><li><em><strong>结论2：block是封装了函数调用以及函数调用环境的OC对象</strong></em></li></ul><p>最后，看一下block的调用，被编译成了下述结构（这里我们去掉强制转换）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(block)-&gt;FuncPtr(block);</span><br></pre></td></tr></table></figure><p>可以看出，是取出了变量中的<code>FuncPtr</code>成员变量，得到函数指针后把自己传进去，这样子就完成了block的调用</p><h2 id="block捕获外部变量"><a href="#block捕获外部变量" class="headerlink" title="block捕获外部变量"></a>block捕获外部变量</h2><p>从上面的分析我们可以得知，局部变量的定义和使用，是在两个函数中进行的，所以为了能够给让变量跨函数访问，block需要捕获该变量 </p><h3 id="局部auto类型的变量捕获"><a href="#局部auto类型的变量捕获" class="headerlink" title="局部auto类型的变量捕获"></a>局部auto类型的变量捕获</h3><p><strong>auto ： 自动变量，离开作用域自动销毁</strong></p><p>平常我们定义的局部变量，默认都是<code>auto</code>修饰的</p><p>先写一个简单的demo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 10; &#x2F;&#x2F; 等价于 auto int age &#x3D; 10;</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Block %d&quot;,age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译后变成如下结构(去掉强制转换)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 10;</span><br><span class="line">void(*block)(void) &#x3D; &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br></pre></td></tr></table></figure><p><code>__main_block_impl_0</code>也发生了变化，可以看到多了一个<code>age</code>成员变量，所以构造函数也多了一个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int age;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags&#x3D;0) : age(_age) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>age(_age)</code>这个语法意为将构造方法传进来的<code>_age</code>赋值到自己的的成员变量<code>age</code>，这个过程我们称作变量的<strong>捕获</strong></p><p>block内编译后的函数<code>__main_block_func_0</code>也发生了变化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int age &#x3D; __cself-&gt;age; &#x2F;&#x2F; bound by copy</span><br><span class="line">   NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_5fd8ec_mi_0,age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出函数内取出了结构体内的<code>age</code>成员变量，然后交给<code>NSLog</code>使用</p><p>由此可知，block在定义的时候就会把外部传进来的参数给存储一遍，然后调用的时候在从block对象中取出来，所以这就意味着<strong>被block捕获的变量，在被捕获后如果修改了值，是不会应用到block中的</strong>，举例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 10;</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;age &#x3D; %d&quot;,age);</span><br><span class="line">&#125;;</span><br><span class="line">age &#x3D; 20;</span><br><span class="line">block(); &#x2F;&#x2F; 调用这个方法只会输出age &#x3D; 10，因为age被捕获时是10，所以后面就算改了值也没用</span><br></pre></td></tr></table></figure><h3 id="局部static类型的变量捕获"><a href="#局部static类型的变量捕获" class="headerlink" title="局部static类型的变量捕获"></a>局部static类型的变量捕获</h3><p>把上面的<code>age</code>变量加一个<code>static</code>修饰符试试看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int age &#x3D; 10;</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;age &#x3D; %d&quot;,age);</span><br><span class="line">&#125;;</span><br><span class="line">age &#x3D; 20;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>结果会输出<code>age = 20</code>，原因是静态变量会将<code>static</code>修饰的对象转为block的指针类型的成员属性，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int *age;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int *age &#x3D; __cself-&gt;age; &#x2F;&#x2F; bound by copy</span><br><span class="line">  NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_bb86ee_mi_0,(*age));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是指针传递，所以当指针指向的内容变化时，打印出来的值也就会变化了</p><h3 id="全局变量不捕获"><a href="#全局变量不捕获" class="headerlink" title="全局变量不捕获"></a>全局变量不捕获</h3><p>全局<code>static</code>变量不捕获，因为全局<code>static</code>变量大家都能访问，所以函数内可以直接读取值</p><h3 id="block内的self会被捕获吗"><a href="#block内的self会被捕获吗" class="headerlink" title="block内的self会被捕获吗"></a>block内的self会被捕获吗</h3><p>会，我们来举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)test &#123;</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,self); </span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>test</code>方法会添加两个隐含的参数，编译后如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void _I_Person_Test(Person *self, SEL _cmd) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这就是为什么我们能在方法内访问<code>self</code>和<code>_cmd</code>的原因，因为方法会传进来<code>self</code>参数，又因为参数是局部变量，又因为局部变量会被捕获，所以<code>self</code>参数会被捕获，捕获后大概长这样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  Person *self;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Block的类型"><a href="#Block的类型" class="headerlink" title="Block的类型"></a>Block的类型</h2><p>Block有三种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型</p><table><thead><tr><th>存储区域</th><th>类名</th><th>特点</th><th>调用copy后的效果</th></tr></thead><tbody><tr><td>数据区域 .data区</td><td><code>__NSGlobalBlock__</code></td><td>没有访问auto变量</td><td>无效果</td></tr><tr><td>栈区</td><td><code>__NSStackBlock__</code></td><td>访问了auto变量</td><td>从栈复制到堆</td></tr><tr><td>堆区</td><td><code>__NSMallocBlock__</code></td><td><code>__NSStackBlock__</code>调用了copy</td><td>引用计数增加</td></tr></tbody></table><h3 id="NSGlobalBlock"><a href="#NSGlobalBlock" class="headerlink" title="__NSGlobalBlock__"></a><code>__NSGlobalBlock__</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Hello world&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="NSStackBlock"><a href="#NSStackBlock" class="headerlink" title="__NSStackBlock__"></a><code>__NSStackBlock__</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 20;</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">   NSLog(@&quot;Block %d&quot;,age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为在ARC环境下，栈区block会自动copy，所以要测试这个类型的时候，需要使用MRC环境</p><p><strong>栈区数据的特点是会自动销毁，离开了作用域，数据都会销毁</strong></p><p><strong>栈区block存在的问题是，捕获的变量会存放在栈区，所以一旦离开了作用域，捕获的内容就销毁了，将来再去访问这个block内捕获的变量，访问到的可能就是一个未知的内容</strong></p><p>以下情况编译器会自动将栈上的block复制到堆上：</p><ol><li>block作为函数返回值时，比如 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^Block)(void);</span><br><span class="line">Block myBlock() &#123;</span><br><span class="line">int age &#x3D; 10</span><br><span class="line">    return ^&#123;</span><br><span class="line">    NSLog(@&quot;---------%d&quot;,age);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>将block赋值给__strong指针时<ul><li>__strong是是id类型和对象类型默认的所有权修饰符，所以平时在ARC环境下写的引用外部auto局部变量的block都会自动copy到堆中，原因是block默认被__strong修饰了</li></ul></li><li>block作为Cocoa API中方法名含有usingBlock的方法参数时<ul><li>比如NSArray的<code>enumerateObjectsUsingBlock:</code>方法，block传进去之后就会被copy一下</li></ul></li><li>block作为GCD API的方法参数时<ul><li>比如GCD的<code>dispatch_after(dispatch_time_t when, dispatch_queue_t queue,   dispatch_block_t block);</code>方法，block传进去之后就会被copy一下</li></ul></li></ol><h3 id="NSMallocBlock"><a href="#NSMallocBlock" class="headerlink" title="__NSMallocBlock__"></a><code>__NSMallocBlock__</code></h3><p>将<code>__NSStackBlock__</code>进行一次copy，即可得到<code>__NSMallocBlock__</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int age &#x3D; 20;</span><br><span class="line">void(^block)(void) &#x3D; [^&#123;</span><br><span class="line">   NSLog(@&quot;Block %d&quot;,age);</span><br><span class="line">&#125; copy];</span><br></pre></td></tr></table></figure><h2 id="捕获对象类型的auto变量"><a href="#捕获对象类型的auto变量" class="headerlink" title="捕获对象类型的auto变量"></a>捕获对象类型的auto变量</h2><p>当block内部访问了对象类型的auto变量时，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Person %@&quot;,person);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>我们在ARC环境下编译，这时候block会在堆上（因为被自动copy了），执行命令行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</code>，会发现block结构体的person属性多了一个<code>__strong</code>的修饰符，证明他被block强持有了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  ...</span><br><span class="line">  Person *__strong person;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们如果编译的时候去掉<code>-fobjc-arc</code>，默认就是MRC环境了，这时候block会在栈上，查看编译后的c++文件发现不会有<code>__strong</code>修饰符，如果我们在block执行前加一行<code>[person release]</code>，那么这时候<code>person</code>就会直接释放，证明block没有持有<code>person变量</code></p><ul><li>结论1：如果block是在栈上，将不会对auto变量产生强引用</li></ul><p>如果我们给person添加<code>__weak</code>修饰符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__weak Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Person %@&quot;,person);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>则block将会对person对象进行弱引用，编译后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  ...</span><br><span class="line">  Person *__weak person;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以使用<code>__weak</code>修饰符可以避免block对外部变量的强引用操作</p><p>我们来看看block的结构体内的<code>__main_block_desc_0</code>是个什么东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br></pre></td></tr></table></figure><p>可以发现，多了两个函数指针，<code>copy</code>和<code>dispose</code>，分别指向<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code></p><p>这两个函数的实现如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">_Block_object_assign((void*)&amp;dst-&gt;person, (void*)src-&gt;person, 3&#x2F;*BLOCK_FIELD_IS_OBJECT*&#x2F;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class="line">_Block_object_dispose((void*)src-&gt;person, 3&#x2F;*BLOCK_FIELD_IS_OBJECT*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_Block_object_assign</code>函数内部会对person进行引用计数器的操作，如果<code>__main_block_impl_0</code>结构体内person指针是<code>__strong</code>类型，则为强引用，引用计数+1，如果<code>__main_block_impl_0</code>结构体内person指针是<code>__weak</code>类型，则为弱引用，引用计数不变。</p><p><code>_Block_object_dispose</code>会对person对象做释放操作，类似于release，也就是断开对person对象的引用，而person究竟是否被释放还是取决于person对象自己的引用计数</p><ul><li>结论2：如果block被拷贝到堆上<ul><li>会调用block内部的copy函数</li><li>copy函数内部会调用_Block_object_assign函数</li><li>_Block_object_assign函数会根据auto变量的修饰符（<code>__strong</code>，<code>__weak</code>，<code>__unsafe_unretained</code>）做出相应的操作，类似于retain(形成强引用、弱引用)</li></ul><blockquote><p>__unsafe_unretained修饰的变量不会增加引用计数，当销毁时，该指针不会置空，会造成不安全的情况。</p></blockquote></li><li>结论3：如果block从堆上移除<ul><li>会调用block内部的dispose函数</li><li>dispose函数内部会调用_Block_object_assign函数</li><li>_Block_object_dispose函数会自动释放引用的auto变量，类似于release</li></ul></li></ul><table><thead><tr><th>函数</th><th>调用时机</th></tr></thead><tbody><tr><td>copy函数</td><td>栈上的Block复制到堆时</td></tr><tr><td>dispose函数</td><td>堆上的Block被废弃时</td></tr></tbody></table><h2 id="block"><a href="#block" class="headerlink" title="__block"></a>__block</h2><p>一般情况下我们是无法改变block捕获的外部的值的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">person &#x3D; nil;  &#x2F;&#x2F;&#x2F; 这种情况是会编译失败的</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>从上面的内容我们也可以知道原因。就是因为外部的person所在的内存空间和block内（单独开辟了一个函数）的内存空间不在同一个位置，所以block内是访问不到的外部的person的。</p><p>但是我们如果添加了<code>__block</code>关键字的话，就可以访问了，所以我们编译一下看看添加<code>__block</code>之后的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__block Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">person &#x3D; nil;  &#x2F;&#x2F; 编译成功</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure><p>编译后长这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_person_0 *person; &#x2F;&#x2F; by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_person_0 *_person, int flags&#x3D;0) : person(_person-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到person对象被封装成了一个<code>__Block_byref_person_0 *</code>类型的属性</p><p>继续看看<code>__Block_byref_person_0</code>是什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_person_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_person_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> void (*__Block_byref_id_object_copy)(void*, void*);</span><br><span class="line"> void (*__Block_byref_id_object_dispose)(void*);</span><br><span class="line"> Person *__strong person;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__Block_byref_person_0</code>有isa指针，是一个OC对象，里面有一个强引用的person对象（指向的内容等同于外面的person指针指向的内容），和我们熟悉的<code>__Block_byref_id_object_copy</code>和<code>__Block_byref_id_object_dispose</code>方法用于处理内存管理问题，还有指向自身的<code>forwarding</code>指针（这个指针指向对象自身），<code>flag</code>和<code>size</code>，分别表示标记位和这个结构体的占用内存空间大小。</p><p>person被封装成了结构体对象之后，原先的block函数就变成了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">__Block_byref_person_0 *person &#x3D; __cself-&gt;person; &#x2F;&#x2F; bound by ref</span><br><span class="line">(person-&gt;__forwarding-&gt;person) &#x3D; __null;</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_250618_mi_0,(person-&gt;__forwarding-&gt;person));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，但我们要改变person指针的值的时候，首先是取出person对象，即<code>__Block_byref_person_0 *person</code>，然后再通过<code>forwarding</code>指针拿到自己，再拿到最里面的person，最后就可以修改了。</p><ol><li><p>通过内存打印，我们可以得知<code>__Block_byref_person_0</code>内的person对象和外部的person对象的地址是一致的，所以我们在block内修改外部的person就是相当于修改<code>__Block_byref_person_0</code>内的person对象</p></li><li><p>为什么要绕一个圈，不直接<code>person-&gt;person</code>而是要<code>person-&gt;__forwarding-&gt;person</code>？原因是防止block从栈复制到堆之后，栈上面的block访问person访问到的是栈上的person而不是堆上的person，所以栈上的forwarding指针要指向堆的block，这样子就能一直访问到堆上的person了</p></li><li><p>封装的<code>__Block_byref_person_0</code>结构体内的<code>__Block_byref_id_object_copy</code>函数会管理他自己的person对象的内存，实现代码如下:<br> <code>_Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);</code>，这里的40是person对象的偏移值，可以看到结构体内person前面的4个指针加2个整型刚好40个字节。</p></li><li><p><code>__Block_byref_person_0</code>在<code>__main_block_impl_0</code>内必定是强引用，跟我们上面所说的不一样，就算在<code>__block</code>之前再添加<code>__weak</code>修饰，<code>__Block_byref_person_0</code>在<code>__main_block_impl_0</code>内依旧是强引用，加上<code>__weak</code>修饰受影响的只有<code>__Block_byref_person_0</code>内的person指针的引用方式</p></li></ol><blockquote><p>注意：MRC环境下，__block 不会对变量造成强引用，即以下情况person会提前释放</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__block Person *person &#x3D; [Person new];</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,person);</span><br><span class="line">&#125;;</span><br><span class="line">block(); &#x2F;&#x2F;&#x2F; 这时候person已经释放了</span><br></pre></td></tr></table></figure><blockquote><p>注意：__block只能用于修饰auto变量，不能修饰全局变量和静态（static）变量</p></blockquote><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><h3 id="循环引用的发生原因与解决方式"><a href="#循环引用的发生原因与解决方式" class="headerlink" title="循环引用的发生原因与解决方式"></a>循环引用的发生原因与解决方式</h3><ul><li><p>以下代码会产生循环引用</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"> @property (nonatomic, copy) void(^block)(void);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person *person &#x3D; [Person alloc] init];</span><br><span class="line">person.age &#x3D; 10;</span><br><span class="line">person.block &#x3D; ^&#123;</span><br><span class="line">NSLog(@&quot;age is %d&quot;,person.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  原因是person.block捕获了person，person又持有着block，也就是block内部对person存在一个强引用，person对block也存在一个强引用，所以均无法释放。</p></li><li><p>在定义person指针的时候添加<code>__weak</code>修饰符或者<code>__unsafe_unretain</code>修饰符，就可以让block在捕获person的时候弱引用person，这样子就不会造成循环引用了.</p>  <img src="https://z3.ax1x.com/2021/06/13/2I2lPU.png" alt="2I2lPU.png" border="0" width="50%" />  > __weak: 不会产生强引用，指向的对象销毁时，会自动让指针至nil，不支持MRC > __unsafe_unretain: 不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变，变成野指针，支持MRC</li><li><p>在定义person指针的时候添加<code>__block</code>修饰符也可以解决循环引用问题，但前提是需要调用block并手动将person指针置为nil，如下</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block Person *person &#x3D; [Person alloc] init];</span><br><span class="line">person.age &#x3D; 10;</span><br><span class="line">person.block &#x3D; ^&#123;</span><br><span class="line">NSLog(@&quot;age is %d&quot;,person.age);</span><br><span class="line">       person &#x3D; nil;</span><br><span class="line">&#125;;</span><br><span class="line">   person.block();</span><br></pre></td></tr></table></figure><p>  为什么这样子可以解决循环引用呢?首先先分析一下内存结构</p><ul><li>peron持有block</li><li>block持有__block对象</li><li>__block持有着person</li><li>peron又持有着block</li><li>…</li></ul><p>  所以这里是三个对象相互持有形成一个三角形关系</p>  <img src="https://z3.ax1x.com/2021/06/13/2IcLXn.png" alt="2IcLXn.png" border="0" width="30%"/>    当block执行，person = nil，解除了`__block`变量对person的引用的时候，循环引用就不再存在了    <img src="https://z3.ax1x.com/2021/06/13/2IgCp4.png" alt="2IgCp4.png" border="0" width="30%"/><ul><li>MRC环境下，由于**__block不会对变量造成强引用**，所以直接用__block修饰指针也可以达到以上效果</li></ul></li></ul><h3 id="为什么block做属性不常用weak而是用copy"><a href="#为什么block做属性不常用weak而是用copy" class="headerlink" title="为什么block做属性不常用weak而是用copy"></a>为什么block做属性不常用weak而是用copy</h3><p>如果上述例子使用weak修饰block的话，那么block会在栈中，block里面的person也会在栈中，所以离开了作用域的话，里面的person就会销毁，从而无法使用。</p><p>如果你希望block做完事情就释放，比如发送一个通知，修改某个单例类的属性，没有引用外部局部变量，那么用weak就可以节约内存空间</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要简述Block、__block的本质是什么东西，文章涉及循环引用等开发常见问题，需要重点关注。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- Category、+load、+initialize和关联对象</title>
    <link href="https://www.arclin.cn/post/2397c268.html"/>
    <id>https://www.arclin.cn/post/2397c268.html</id>
    <published>2021-06-06T14:24:00.000Z</published>
    <updated>2021-06-07T15:48:08.999Z</updated>
    
    <content type="html"><![CDATA[<p>本文简述iOS中分类的底层实现和load方法、initialize方法在类和分类中的调用特性，还有如何通过关联对象的方式给分类添加属性，以及关联对象的底层实现原理</p><span id="more"></span><h2 id="分类（Category）"><a href="#分类（Category）" class="headerlink" title="分类（Category）"></a>分类（Category）</h2><h3 id="先写一个Demo"><a href="#先写一个Demo" class="headerlink" title="先写一个Demo"></a>先写一个Demo</h3><p>新建一个命令行工程，在main.m中写几个类</p><p>父类：写一个run方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">- (void)run;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>父类的分类：写一个eat方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface Person(Test) </span><br><span class="line"></span><br><span class="line">- (void)eat;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据经验可知道，现在Peron对象拥有了run方法和eat方法</p><h3 id="分类的底层结构"><a href="#分类的底层结构" class="headerlink" title="分类的底层结构"></a>分类的底层结构</h3><p>输入命令行</p><p><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code></p><p>接下来同级目录下就会多出一个编译后的文件<code>main.cpp</code>，查看后发现<code>Person(Test) </code>分类被编译成了如下变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static struct _category_t _OBJC_$_CATEGORY_Person_$_Test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) &#x3D; </span><br><span class="line">&#123;</span><br><span class="line">&quot;Person&quot;,</span><br><span class="line">0, &#x2F;&#x2F; &amp;OBJC_CLASS_$_Person,</span><br><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Test,</span><br><span class="line">0,</span><br><span class="line">0,</span><br><span class="line">0,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个变量的类型是<code>static struct _category_t</code>，名字是<code>_OBJC_$_CATEGORY_Person_$_Test</code>，等于号后面是一个初始化结构体的过程，可以看到要实例化这个结构体需要6个参数，所以查看<code>_category_t</code>的结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct _category_t &#123;</span><br><span class="line">const char *name; &#x2F;&#x2F;&#x2F; 原来的类的名字</span><br><span class="line">struct _class_t *cls; &#x2F;&#x2F;&#x2F; 类对象</span><br><span class="line">const struct _method_list_t *instance_methods; &#x2F;&#x2F;&#x2F; 实例方法数组</span><br><span class="line">const struct _method_list_t *class_methods; &#x2F;&#x2F;&#x2F; 类方法数组</span><br><span class="line">const struct _protocol_list_t *protocols; &#x2F;&#x2F;&#x2F; 遵循的协议数组</span><br><span class="line">const struct _prop_list_t *properties; &#x2F;&#x2F;&#x2F; 属性数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由此可知，<strong>分类可以定义实例方法，可以定义类方法，可以遵循协议，可以添加属性，但是不能添加成员变量！因为分类的结构里面没有存储成员变量的地方.</strong></p><h3 id="程序通过runtime动态将分类合并到类对象、元类对象中"><a href="#程序通过runtime动态将分类合并到类对象、元类对象中" class="headerlink" title="程序通过runtime动态将分类合并到类对象、元类对象中"></a>程序通过runtime动态将分类合并到类对象、元类对象中</h3><p>分类中的方法是在运行时才添加到类对象和元类对象中的，而不是编译的时候添加的，编译之后只是多了几个类型为<code>_category_t</code>的结构体变量。</p><p>合并的过程可以在runtime源码（objc4-818.2）中<code>objc-runtime-new.mm</code>的<code>load_categories_nolock</code>函数中看到，这里不展开流程，直接说结论。</p><p>合并过程是这样子的，首先我们知道原来的类（我们就叫他主类吧）对象是存放着成员方法的，主类的元类对象是放着类方法的，因为类对象和元类对象结构是一样的，所以我们就讨论成员方法就好了。</p><p>其次呢，runtime先根据分类方法的数量在数组里面开辟空间，然后把分类方法塞到原来的成员方法数组的前端，这样子合并就完成了，其他类方法、协议、属性等数组，也是同样的过程。</p><p>所以最后在<strong>类对象的方法列表数组里面，排在前面的是分类方法，后面才是主类的方法。如果有多个分类的话，那么后编译的分类的成员方法会插在数组的前面（因为插入数组的时候是倒序插入）</strong>。</p><p>有了上述结论 我们就可以解释很多事情了。</p><h4 id="如果分类实现了主类的方法会怎么样"><a href="#如果分类实现了主类的方法会怎么样" class="headerlink" title="如果分类实现了主类的方法会怎么样"></a>如果分类实现了主类的方法会怎么样</h4><p>根据上述结论，系统在找对应的调用方法的时候，会先找到分类的方法，所以主类的方法没有机会被调用到。</p><h4 id="如果多个分类都实现了同个主类的方法"><a href="#如果多个分类都实现了同个主类的方法" class="headerlink" title="如果多个分类都实现了同个主类的方法"></a>如果多个分类都实现了同个主类的方法</h4><p>根据上述结论，后编译的分类的成员方法会插在方法列表的前面，所以谁后编译，就调用谁</p><h4 id="如果子类或者子类的分类实现了父类的分类方法"><a href="#如果子类或者子类的分类实现了父类的分类方法" class="headerlink" title="如果子类或者子类的分类实现了父类的分类方法"></a>如果子类或者子类的分类实现了父类的分类方法</h4><p>根据上述结论和结合我们以前所学知识，最后子类实例对象会去子类的类对象里面寻找方法并调用，使用<code>super</code>关键字调用方法的话，则会去到父类的类对象内找方法。</p><h3 id="Category跟Class-Extension的区别"><a href="#Category跟Class-Extension的区别" class="headerlink" title="Category跟Class Extension的区别"></a>Category跟Class Extension的区别</h3><ul><li>Class Extension是编译的时候，它的数据就已经包含在类信息中</li><li>Category 是在运行时才会讲数据合并到类信息中</li></ul><h2 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h2><h3 id="先写一个Demo-1"><a href="#先写一个Demo-1" class="headerlink" title="先写一个Demo"></a>先写一个Demo</h3><p>父类：实现load方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Person load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>父类的分类：实现load方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person(Test)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Person Text load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子类：实现load方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation Student</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Student load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子类的分类：实现load方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@implementation Student(Test)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Student Test load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="load方法的调用时机"><a href="#load方法的调用时机" class="headerlink" title="load方法的调用时机"></a>load方法的调用时机</h3><p>通过runtime源码（objc4-818.2）<code>objc-runtime-new.mm</code>第3233行得知，load方法是在加载镜像(load_images)的时候调用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    if (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;</span><br><span class="line">        didInitialAttachCategories &#x3D; true;</span><br><span class="line">        loadAllCategories();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Return without taking locks if there are no +load methods here.</span><br><span class="line">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Discover load methods</span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((const headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Call +load methods (without runtimeLock - re-entrant)</span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>补充小细节：从<code>load_images</code>函数可以看到，加载分类<code>loadAllCategories()</code>早于调用load方法<code>call_load_methods()</code>，也就是元类对象中的类方法列表内，分类的load方法会在主类的load方法之前</p></blockquote><p>在调用load方法之前，首先要通过<code>prepare_load_methods</code>函数整理出一个数组，这个数组会决定主类的load方法的调用顺序</p><p>从<code>prepare_load_methods</code>函数中调用的<code>schedule_class_load</code>函数的内部实现我们可以知道，父类会先被加入到数组中，其次才是主类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* prepare_load_methods</span><br><span class="line">* Schedule +load for classes in this image, any un-+load-ed </span><br><span class="line">* superclasses in other images, and any categories in this image.</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">&#x2F;&#x2F; Recursively schedule +load for cls and any un-+load-ed superclasses.</span><br><span class="line">&#x2F;&#x2F; cls must already be connected.</span><br><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());  &#x2F;&#x2F; _read_images should realize</span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Ensure superclass-first ordering</span><br><span class="line">    schedule_class_load(cls-&gt;getSuperclass());</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们回到最开始的地方（load_images），通过<code>objc-loadmethod.mm</code>第337行<code>call_load_methods</code>得知，先调用主类的load方法(call_class_loads())，再调用分类的load方法<code>call_category_loads();</code></p><blockquote><p>补充一个小细节：在整理数组的时候，这个数组里面存放的是一个个结构体，结构体长这样</p></blockquote>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct loadable_class &#123;</span><br><span class="line">    Class cls;  &#x2F;&#x2F; may be nil  这里放元类对象（load是类方法所以存在元类对象里面）</span><br><span class="line">    IMP method;  &#x2F;&#x2F;&#x2F; 这里放的是load方法的函数指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct loadable_category &#123;</span><br><span class="line">    Category cat;  &#x2F;&#x2F; may be nil 这个是上面讲到的category_t类型的对象</span><br><span class="line">    IMP method; &#x2F;&#x2F;&#x2F; 这里放的是load方法的函数指针</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：runtime代码内有记录类的load方法是否曾经被加入到load数组过（RW_LOADED），如果被调用过了，就会跳过，这就是load方法只会执行一次的原因（但是你要是非要手动调用load方法那还是会执行的）</p><p><strong>重要：系统调用load方法不通过消息发送机制</strong>，可以查看<code>objc-loadmethod.mm</code>第177行如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* call_class_loads</span><br><span class="line">* Call all pending class +load methods.</span><br><span class="line">* If new classes become loadable, +load is NOT called for them.</span><br><span class="line">*</span><br><span class="line">* Called only by call_load_methods().</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">static void call_class_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Detach current loadable list.</span><br><span class="line">    struct loadable_class *classes &#x3D; loadable_classes;</span><br><span class="line">    int used &#x3D; loadable_classes_used;</span><br><span class="line">    loadable_classes &#x3D; nil;</span><br><span class="line">    loadable_classes_allocated &#x3D; 0;</span><br><span class="line">    loadable_classes_used &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Call all +loads for the detached list.</span><br><span class="line">    for (i &#x3D; 0; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls &#x3D; classes[i].cls;</span><br><span class="line">        load_method_t load_method &#x3D; (load_method_t)classes[i].method;</span><br><span class="line">        if (!cls) continue; </span><br><span class="line"></span><br><span class="line">        if (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 意为直接通过函数指针调用函数</span><br><span class="line">        (*load_method)(cls, @selector(load));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Destroy the detached list.</span><br><span class="line">    if (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="load方法的调用顺序"><a href="#load方法的调用顺序" class="headerlink" title="load方法的调用顺序"></a>load方法的调用顺序</h3><p>综上所述，分类也有load方法。调用顺序是：先调用父类load方法，再调用子类load方法，最后调用分类的load方法，如果有多个分类，那么先编译的，先调用。</p><p>所以上述Demo代码执行后输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person load</span><br><span class="line">Student load</span><br><span class="line">Person Test load</span><br><span class="line">Student Test load</span><br></pre></td></tr></table></figure><p>这里Person比Student先调用是因为他是父类，Person(Test)比Student(Test)先调用是因为它先编译</p><h3 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a>综上所述</h3><p>于是我们可以解答下面的问题</p><ol><li>类和分类都有+load方法</li><li>根据编译顺序，先调用父类+load，再调用子类+load，再调用分类+load(看编译顺序)</li><li>因为系统调用load方法时不通过消息发送机制，所以不存在子类load方法覆盖父类load方法的情况，但是，如果手动调用load方法（即通过消息发送机制调用方法），那么这时候就有继承的现象发生了，也就是子类会覆盖父类方法的实现。</li></ol><p>搞点复杂的事情</p><ol><li>父类实现，父类分类实现，子类不实现，子类分类实现<br/><br> 顺序：父类load，子类分类load、父类分类load<br/><br> 原因：本来应该调用子类load的，无奈子类load没实现，但是找到了子类分类，那么就调用子类分类的load，最后在调用父类分类load(因为分类要最晚调用，由于刚才子类分类被调用过了，所以这里没它事了)<br/><br> <strong>所以：不一定主类的load方法总比分类的load方法早调用，存在特殊情况</strong><br/><br/></li><li>父类不实现，父类分类实现，子类实现，子类分类实现<br/><br> 顺序：父类分类load，子类load，子类分类load<br/><br> 原因：跟上面的理由是一样的，父类没实现但是父类分类找到了那么就调用<br/><br> <strong>所以：父类的分类的load也可以比子类load方法早调用</strong></li></ol><h2 id="initialize方法"><a href="#initialize方法" class="headerlink" title="initialize方法"></a>initialize方法</h2><h3 id="先写个Demo"><a href="#先写个Demo" class="headerlink" title="先写个Demo"></a>先写个Demo</h3><p>父类：实现initialize方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;Person initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>父类的分类：实现initialize方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person(Test)</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;Person Text initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子类：实现initialize方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@implementation Student</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;Student initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子类的分类：实现initialize方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@implementation Student(Test)</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;Student Test initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="initialize方法的调用时机"><a href="#initialize方法的调用时机" class="headerlink" title="initialize方法的调用时机"></a>initialize方法的调用时机</h3><ul><li><p><code>+initialize</code>会在类第一次接受到消息的时候调用，即<code>objc_msgSend()</code>被触发的时候调用，这部分是汇编实现</p></li><li><p>runtime源码里面有一个<code>class_getInstanceMethod()</code>函数，用于查找方法，当找到要调用的方法之后，就会调用<code>initialize</code>方法，<code>class_getInstanceMethod()</code>内的主要实现为<code>lookUpImpOrForward()</code>函数的调用</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* class_getInstanceMethod.  Return the instance method for the</span><br><span class="line">* specified class and selector.</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">Method class_getInstanceMethod(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls  ||  !sel) return nil;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; This deliberately avoids +initialize because it historically did so.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; This implementation is a bit weird because it&#39;s the only place that </span><br><span class="line">    &#x2F;&#x2F; wants a Method instead of an IMP.</span><br><span class="line"></span><br><span class="line">    Method meth;</span><br><span class="line">    meth &#x3D; _cache_getMethod(cls, sel, _objc_msgForward_impcache);</span><br><span class="line">    if (meth &#x3D;&#x3D; (Method)1) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache contains forward:: . Stop searching.</span><br><span class="line">        return nil;</span><br><span class="line">    &#125; else if (meth) &#123;</span><br><span class="line">        return meth;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    &#x2F;&#x2F; Search method lists, try method resolver, etc.</span><br><span class="line">    lookUpImpOrForward(nil, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER);</span><br><span class="line"></span><br><span class="line">    meth &#x3D; _cache_getMethod(cls, sel, _objc_msgForward_impcache);</span><br><span class="line">    if (meth &#x3D;&#x3D; (Method)1) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache contains forward:: . Stop searching.</span><br><span class="line">        return nil;</span><br><span class="line">    &#125; else if (meth) &#123;</span><br><span class="line">        return meth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return _class_getMethod(cls, sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>lookUpImpOrForward()</code>函数实现内，有一判断条件为<code>if(slowpath(!cls-&gt;isInitialized())) &#123; ... &#125;</code> ，若该类已经调用过<code>+initialize</code>，那么就不会再调用，这就是<code>+initialize</code>只被系统调用一次的原因</p></li><li><p>经过一层层点击方法实现（流程见补充），最终我们可以在<code>objc-initialize.mm</code>内发现函数<code>callInitialize(Class cls)</code>，内部实现是<code>objc_msgSend</code>，如下</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  void callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ((void(*)(Class, SEL))objc_msgSend)(cls, @selector(initialize));</span><br><span class="line">    asm(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>补充：函数调用路径为<code>lookUpImpOrForward</code>-&gt;<code>realizeAndInitializeIfNeeded_locked</code>-&gt;<code>initializeAndLeaveLocked</code>-&gt;<code>initializeAndMaybeRelock</code>-&gt;<code>initializeNonMetaClass</code>-&gt;<code>callInitialize</code><br/>其中：<code>initializeNonMetaClass</code>函数实现内有一个递归，不断地传入<code>superclass</code>指针，去调用父类的<code>initialize</code>方法，直到<code>superclass</code>指针为空（或已经调用过<code>initialize</code>）为止，这就是先调用父类的<code>initialize</code>方法的原因</p></blockquote><h3 id="initialize方法的调用顺序"><a href="#initialize方法的调用顺序" class="headerlink" title="initialize方法的调用顺序"></a>initialize方法的调用顺序</h3><ul><li>先调用父类的<code>initialize</code>方法，再调用子类的<code>initialize</code></li></ul><h3 id="综上所述-1"><a href="#综上所述-1" class="headerlink" title="综上所述"></a>综上所述</h3><ol><li><code>initialize</code>是通过<code>objc_msgSend</code>方式调用的，所以会受分类、继承等等因素影响调用</li><li>如果子类没有实现<code>+initialize</code>，会调用父类的<code>+initiailize</code>（所以父类的<code>+initialize</code>可能会被调用多次）</li><li>如果分类实现了<code>+initialize</code>，就会覆盖主类的<code>+initialize</code>调用</li></ol><h2 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h2><p>假如我们要给一个类添加一个属性如下：<br><br><code>@property (copy, nonatomic) NSString *test;</code></p><h3 id="存值"><a href="#存值" class="headerlink" title="存值"></a>存值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT void</span><br><span class="line">objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,</span><br><span class="line">                         id _Nullable value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>解释</th></tr></thead><tbody><tr><td>object</td><td>要关联的对象，如果是在分类内给主类添加属性，那么这里就写<code>self</code></td></tr><tr><td>key</td><td>要用来标记这个属性的key，取值的时候也得靠这个key取</td></tr><tr><td>value</td><td>存储的内容</td></tr><tr><td>policy</td><td>存储策略（见下表）</td></tr></tbody></table><h4 id="objc-AssociationPolicy-存储策略"><a href="#objc-AssociationPolicy-存储策略" class="headerlink" title="objc_AssociationPolicy 存储策略"></a>objc_AssociationPolicy 存储策略</h4><table><thead><tr><th>策略枚举</th><th>对应修饰符</th></tr></thead><tbody><tr><td>OBJC_ASSOCIATION_ASSIGN</td><td>assign</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td>strong, nonatomic</td></tr><tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC</td><td>copy,nonatomic</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN</td><td>strong, atomic</td></tr><tr><td>OBJC_ASSOCIATION_COPY</td><td>copy,atomic</td></tr></tbody></table><blockquote><p>如果要存weak类型的对象怎么办？<br/>创建一个类，用<code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code>标记存在主类中，然后在这个新建的类里面再存放一个weak引用的属性</p></blockquote><h4 id="key有多少种填写形式"><a href="#key有多少种填写形式" class="headerlink" title="key有多少种填写形式"></a>key有多少种填写形式</h4><ol><li>声明全局变量<code>static const void *TestKey = &amp;TestKey;</code>,将<code>TestKey</code>的地址作为key的内容，不能直接写<code>const void *TestKey</code>，因为这么写等共同于<code>const void *TestKey = NULL</code>，要是以后添加别的属性，就会冲突，使用例子：</li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(self,TestKey,test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure><ol start="2"><li>声明全局变量<code>static const char TestKey</code>，同样将<code>TestKey</code>的地址作为key，好处是<code>char</code>只占用一个字节的内存大小，使用例子：</li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(self,&amp;TestKey,test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure><ol start="3"><li>因为OC内的字符串都存在常量区，所以通过字面量创建的相同字符串都是同个地址，所以我们也可以随便定义一个字符串去做key，使用例子：</li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(self,@&quot;Test&quot;,test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure><ol start="4"><li>我们也可以通过使用getter方法的方法编号去做key，使用例子：</li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(self,@selector(test),test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure><h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key);</span><br></pre></td></tr></table></figure><ul><li>object同上，一般分类里面就填self</li><li>key属性需要和上面设值的key属性一致</li></ul><ul><li>如果使用getter方法的方法编号去做key，有两种写法<ol><li><code>objc_getAssociatedObject(self, @selector(test))</code></li><li><code>objc_getAssociatedObject(self, _cmd)</code>，<code>_cmd</code>表示当前方法的方法地址</li></ol></li></ul><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p><img src="https://www.hualigs.cn/image/60bd149eb55dc.jpg" alt="图片来源自小码哥教程"></p><ul><li>runtime维护着一个名为<code>AssociationsManager</code>的类</li><li>类里面存放着一个字典，键是传入的对象（object参数），值是<code>ObjectAssociationMap</code>类的实例对象</li><li><code>ObjectAssociationMap</code>是一个字典，键是传入的key参数，值是<code>ObjcAssociation</code>类的实例对象</li><li><code>ObjcAssociation</code>有两个成员变量，<code>_policy</code>存放着传入的policy参数，<code>_value</code>存放着传入的value参数</li></ul><h3 id="综上所述-2"><a href="#综上所述-2" class="headerlink" title="综上所述"></a>综上所述</h3><ol><li>关联对象并不是存储在被关联对象的内存中</li><li>关联对象存储在全局统一的<code>AssociationsManager</code>中</li><li>设置关联对象（object参数）为nil，就相当于是移除关联对象</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文简述iOS中分类的底层实现和load方法、initialize方法在类和分类中的调用特性，还有如何通过关联对象的方式给分类添加属性，以及关联对象的底层实现原理&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- KVC</title>
    <link href="https://www.arclin.cn/post/34b9a649.html"/>
    <id>https://www.arclin.cn/post/34b9a649.html</id>
    <published>2021-05-30T03:59:00.000Z</published>
    <updated>2021-06-06T18:52:24.963Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述KVC的底层实现和KVC是否能触发KVO呢？</p><span id="more"></span><h2 id="KVC的使用"><a href="#KVC的使用" class="headerlink" title="KVC的使用"></a>KVC的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self.person setValue:@10 forKey:@&quot;age&quot;]</span><br><span class="line"></span><br><span class="line">[self.person setValue:@10 forKeyPath:@&quot;age&quot;]</span><br></pre></td></tr></table></figure><p>keyPath和key的区别是，keyPath可以使用路径的方式进行赋值，比如person对象内有cat模型属性，cat对象里面有age属性，那么就可以使用<code>[self.person setValue:@10 forKeyPath:@&quot;cat.age&quot;]</code>的方式使用KVC，而key方式只支持直接访问的方式赋值</p><h2 id="赋值过程"><a href="#赋值过程" class="headerlink" title="赋值过程"></a>赋值过程</h2><p><code>setValue:forKey</code>首先会先寻找<code>setKey:</code>方法，如果找不到，那么就会寻找<code>_setKey:</code>方法，类似下面这样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 优先找这个方法</span><br><span class="line">- （void）setAge:(int)age &#123;</span><br><span class="line">_age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 找不到上面那个方法的话，就找下面这儿方法</span><br><span class="line">- （void）_setAge:(int)age &#123;</span><br><span class="line">_age &#x3D; age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述两个方法都找不到，那么就会去访问类方法<code>+ (BOOL)accessInstanceVariablesDirectly</code>，询问是否允许直接访问成员变量，默认返回YES</p><ul><li><p>如果返回NO的话，那么程序会直接抛出异常<code>exception NSUnknownKeyException, reason:[XXX setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key age</code></p></li><li><p>如果返回YES，那么程序会去直接访问成员变量，查找的顺序是<code>_key、_isKey、key、isKey</code>，类似下面这样子</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    @public </span><br><span class="line">    int _age;</span><br><span class="line">    int _isAge;</span><br><span class="line">    int age;</span><br><span class="line">    int isAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果找到了成员变量，那么就直接赋值</li><li>如果找不到成员变量，那么就抛出上述异常</li></ol><h2 id="KVC是否会触发KVO"><a href="#KVC是否会触发KVO" class="headerlink" title="KVC是否会触发KVO"></a>KVC是否会触发KVO</h2><p>由于KVO是通过重写set方法的方式实现的，所以如果KVC找到了属性值并且通过set方法赋值的话，那么就自然会触发KVO</p><p>如果KVC找不到set方法，如果<code>+ (BOOL)accessInstanceVariablesDirectly</code>返回YES的话，那么他去访问成员方法的时候，即便这时候成员方法是没有实现set方法的，KVC依旧会去执行<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>方法，在执行<code>didChangeValueForKey:</code>的时候，自然KVO就被触发了</p><h2 id="valueForKey-的底层原理"><a href="#valueForKey-的底层原理" class="headerlink" title="valueForKey:的底层原理"></a>valueForKey:的底层原理</h2><p><code>valueForKey:</code>首先会根据<code>getKey、key、isKey、_key</code>顺序查找方法，找到了的话就调用，拿到返回值。</p><p>如果没有找到方法，那么就会去访问类方法<code>+ (BOOL)accessInstanceVariablesDirectly</code>，询问是否允许直接访问成员变量，默认返回YES</p><p>如果允许，那么按照<code>_key、_isKey、key、isKey</code>顺序查找成员变量，找到了的话就直接取值，找不到就抛出异常<code>NSUnknownKeyException</code>。</p><p>如果不允许，就抛出异常<code>NSUnknownKeyException</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲述KVC的底层实现和KVC是否能触发KVO呢？&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- KVO</title>
    <link href="https://www.arclin.cn/post/81c45883.html"/>
    <id>https://www.arclin.cn/post/81c45883.html</id>
    <published>2021-05-26T17:06:23.000Z</published>
    <updated>2021-06-06T18:52:24.965Z</updated>
    
    <content type="html"><![CDATA[<p>本文简述KVO的底层实现是怎么一回事</p><span id="more"></span><h1 id="如何使用KVO"><a href="#如何使用KVO" class="headerlink" title="如何使用KVO"></a>如何使用KVO</h1><p>举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self.person &#x3D; [[Person alloc] init];</span><br><span class="line">self.person.age &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 这个配置的值会直接影响监听方法的change字典里面带些什么值给你</span><br><span class="line">NSKeyValueObservingOptions options &#x3D; NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld;</span><br><span class="line"></span><br><span class="line">[self.person addObserver:self keyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 当监听对象的属性值发生改变时，就会调用这个方法</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 这里的context就是注册监听的时候传入的@“123”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部发生了什么"><a href="#内部发生了什么" class="headerlink" title="内部发生了什么"></a>内部发生了什么</h1><p>系统通过运行时机制，给<code>person</code>对象添加了一个父类，名为<code>NSKVONotifying_Person</code>(其他被监听的对象所生成的类也会遵循这个命名规则)，本质上是将<code>person</code>对象的isa指针指向了这个动态新建的类对象。</p><p>另外，这个新建的类对象是继承自<code>Person</code>的，也就是<code>NSKVONotifying_Person</code>的superclass指针指向了<code>Persond</code>的类对象。</p><h1 id="NSKVONotifying-类内部结构"><a href="#NSKVONotifying-类内部结构" class="headerlink" title="NSKVONotifying_*类内部结构"></a>NSKVONotifying_*类内部结构</h1><ul><li>isa指针</li><li>superclass指针</li><li>setAge:方法  因为监听的是age属性，所以重写了setAge方法，若监听的属性没有set方法，或者值改变的时候没有调用set方法，那么KVO无法生效</li><li>class:方法，主要是为了防止对象调用class方法的时候得到了这个动态生成的类对象，所以重写class方法，返回真正<code>的Person</code>类对象</li><li>_isKVOA方法，返回一个bool，用来判断这是不是一个KVO类</li><li>dealloc 进行一些收尾工作</li></ul><h2 id="重写的set方法的实现"><a href="#重写的set方法的实现" class="headerlink" title="重写的set方法的实现"></a>重写的set方法的实现</h2><p>大概是这么实现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAge:(int)age &#123;</span><br><span class="line">   _NSSetIntValueAnyNotify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _NSSetIntValueAnyNotify() </span><br><span class="line">&#123;</span><br><span class="line">   [self willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">   [super setAge:age];</span><br><span class="line">   [self didChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key &#123;</span><br><span class="line">   [observer observeValueForKeyPath:key ofObject:self change:nil context:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的方法<code>_NSSetIntValueAnyNotify</code>，看具体监听的属性类型而定，如果监听的是<code>double</code>类型，那么方法就会变成<code>_NSSetDoubleValueAnyNotify</code>，所以系统内置了很多这种类似的方法，统称为<code>_NSSet*ValueAnyNotify</code></p><ul><li><p>调用流程</p><ol><li>willChangeValueForKey:</li><li>setAge:</li><li>observeValueForKeyPath:ofObject:change:context:</li><li>didChangeValueForKey:</li></ol></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>利用Runtime API动态生成一个之类，并且让instance对象的isa指针指向这个全新的子类</p></li><li><p>当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAnyNotify函数</p><ul><li>willChangeValueForKey:</li><li>父类原来的setter</li><li>didChangeValueForKey:<ul><li>内部会触发监听器（Observer）的监听方法（observeValueForKeyPath:ofObject:change:context:）</li></ul></li></ul></li><li><p>如何手动触发KVO<br>  注册监听后，手动调用<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p></li><li><p>直接修改成员属性的值不会触发KVO，必须在前后分别补上<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文简述KVO的底层实现是怎么一回事&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- instance、class和meta-class</title>
    <link href="https://www.arclin.cn/post/fdd98f42.html"/>
    <id>https://www.arclin.cn/post/fdd98f42.html</id>
    <published>2021-05-25T16:22:27.000Z</published>
    <updated>2021-06-06T18:52:24.963Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲的是实例对象(instance)，类对象(class)，元类对象（meta-class）的内容和他们之间的联系</p><span id="more"></span><h1 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h1><p>实例对象内存储着成员变量的值</p><h1 id="class对象"><a href="#class对象" class="headerlink" title="class对象"></a>class对象</h1><h2 id="class对象的基本内容"><a href="#class对象的基本内容" class="headerlink" title="class对象的基本内容"></a>class对象的基本内容</h2><p>每个类在内存中有且只有一个class对象</p><p>class对象在内存中，存储的信息主要包括</p><ul><li>isa指针</li><li>superclass指针</li><li>类的属性信息（@property）、 类的对象方法信息（instance method）</li><li>类的协议信息（protocol）、类的成员变量信息（ivar）</li></ul><h2 id="class对象的结构"><a href="#class对象的结构" class="headerlink" title="class对象的结构"></a>class对象的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rw: readwrite</span><br><span class="line">ro: readonly</span><br><span class="line">t:   table</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">Class isa;</span><br><span class="line">Class superclass;</span><br><span class="line">cache_t cache; &#x2F;&#x2F; 方法缓存</span><br><span class="line">cache_data_bits_t bits; &#x2F;&#x2F; 用于获取具体类信息</span><br><span class="line"></span><br><span class="line">class_rw_t *data() &#123;</span><br><span class="line">   return bits.data();  &#x2F;&#x2F;  实际方法实现为 bits &amp; FAST_DATA_MASK  结果返回值为 class_rw_t类型的对象</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">unit32 flags;</span><br><span class="line">unit32 version;</span><br><span class="line">const class_ro_t *ro;&#x2F;&#x2F; 方法列表</span><br><span class="line">property_list_t *properties;&#x2F;&#x2F; 属性列表</span><br><span class="line">const protocol_list_t *protocols;&#x2F;&#x2F; 协议列表</span><br><span class="line">Class firstSubclass;</span><br><span class="line">Class nextSiblingClass;</span><br><span class="line">chat *demangledName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">uint32_t flags;</span><br><span class="line">unit32_t instanceStart;</span><br><span class="line">unit32_t instanceSize; &#x2F;&#x2F; instance对象占用的内存空间</span><br><span class="line"></span><br><span class="line">const uint8_t * ivarLayout;</span><br><span class="line">const chat * name; &#x2F;&#x2F; 类名</span><br><span class="line">method_list_t  * baseMethodList;</span><br><span class="line">protoocl_list_t * baseProtocols;</span><br><span class="line">const ivar_list_t *ivars;  &#x2F;&#x2F; 成员变量列表</span><br><span class="line">const uint8_t *weakIverLayout;</span><br><span class="line">property_list_t *baseProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关的几个函数"><a href="#相关的几个函数" class="headerlink" title="相关的几个函数"></a>相关的几个函数</h2><ol><li><code>Class objc_getClass(const chat *aClassName)</code><ol><li>传入字符串类名</li><li>返回对应的类对象</li></ol></li><li><code>Class object_getClass(id obj)</code>获取isa指向的对象<ol><li>传入的obj可能是instance对象、class对象、meta-class对象</li><li>返回值<ol><li>如果是instance对象，返回class对象</li><li>如果是class对象，返回meta-class对象</li><li>如果是meta-class对象，返回NSObject（基类）的meta-class对象</li></ol></li></ol></li><li> <code>- (Class)class</code>、<code>+ (Class)class</code> 返回的就是类对象</li></ol><h1 id="meta-class对象"><a href="#meta-class对象" class="headerlink" title="meta-class对象"></a>meta-class对象</h1><p>意思是用来描述类对象的对象，是一种特殊的类对象。</p><p>每个类在内存中有且只有一个meta-class对象</p><p>meta-class对象和class对象的内存接口是一样的，但是用途不一样，在内存中存储的信息主要包括</p><ul><li>isa指针</li><li>superclass指针</li><li>类的类方法信息</li></ul><h1 id="isa指针和spuerclass指针"><a href="#isa指针和spuerclass指针" class="headerlink" title="isa指针和spuerclass指针"></a>isa指针和spuerclass指针</h1><img src="https://i.loli.net/2021/05/26/pjxbn5vQ17hrmae.png" width="50%"><h2 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h2><p>instance的isa指向class</p><blockquote><p>当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用</p></blockquote><p>class的isa指向meta-class</p><blockquote><p>当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用 </p></blockquote><p>meta-class的isa指向基类（NSObject）的meta-class（NSObject的meta-class的isa指向自己的meta-class）</p><h2 id="superclass指针"><a href="#superclass指针" class="headerlink" title="superclass指针"></a>superclass指针</h2><p>举个例子，比如Student类继承自Person类，Person类继承自NSObject类：</p><p>Student的class的superclass指针指向父类的class对象，如果没有父类（NSObject），则superclass指针为空</p><p>Student的meta-class对象的superclass指针指向Person的meta-class</p><p>基类（NSObject）的meta-class的superclass指针指向class对象</p><h3 id="调用成员方法"><a href="#调用成员方法" class="headerlink" title="调用成员方法"></a>调用成员方法</h3><p>因为Student要调用成员方法的时候，需要找到class对象，因为class对象才存放着成员方法，找不到的话就通过superclass指针找到父类class对象看看里面有没有想要的成员方法</p><h3 id="调用类方法"><a href="#调用类方法" class="headerlink" title="调用类方法"></a>调用类方法</h3><p>当Student要调用Student的类方法的时候，就通过Student的class对象的isa找到Student的meta-class对象，然后找到类方法进行调用</p><p>当Student要调用Person的类方法的时候，就得先通过Student的class对象的isa找到Student的meta-class对象，然后通过Student的mata-class对象里面的superclass指针找到Person的meta-class对象，然后在里面找到Person的类方法进行调用</p><h3 id="调用init方法"><a href="#调用init方法" class="headerlink" title="调用init方法"></a>调用init方法</h3><p>比如现在Student对象要调用init方法，流程如下</p><ol><li>先通过对象自己的isa指针，找到Student的类对象</li><li>Student的类对象里面有superclass指针，那么就通过superclass指针拿到了Person的类对象</li><li>Person的类对象里面也有superclass指针，那么就通过superclass指针拿到NSObject的类对象</li><li>NSObject的类对象里面找到了init方法的相关信息，那么就可以进行调用了</li></ol><h3 id="调用不存在的类方法"><a href="#调用不存在的类方法" class="headerlink" title="调用不存在的类方法"></a>调用不存在的类方法</h3><p>Student调用一个不存在的类方法流程</p><ol><li>通过isa指针找到类对象</li><li>类对象的isa指针找到meta-class对象</li><li>meta-class找不到该类方法，通过superclass指针找到父类的meta-class对象</li><li>一直找，直到找到基类的meta-class对象，基类的meta-class的superclass指向基类的class对象</li><li>基类的class对象里面有对象方法，如果对象方法刚好跟准备调用的类方法同名，那么则会调用该对象方法，如果找不到，则开始抛出异常</li></ol><h2 id="ISA-MASK"><a href="#ISA-MASK" class="headerlink" title="ISA_MASK"></a>ISA_MASK</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if __arm64___</span><br><span class="line">#define ISA_MASK 0x000000ffffffff8ULL</span><br><span class="line">#elif __x86_64__</span><br><span class="line">#define  ISA_MASK 0x00007ffffffffff8ULL</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>实例对象从64位系统开始，isa不直接指向类对象的地址，isa需要进行一次位运算，才能计算出真实地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instance的 isa &amp; ISA_MASK -&gt; class对象</span><br><span class="line">class的isa &amp; ISA_MASK -&gt; meta_class 对象</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文讲的是实例对象(instance)，类对象(class)，元类对象（meta-class）的内容和他们之间的联系&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 底层原理 --- NSObject</title>
    <link href="https://www.arclin.cn/post/70f61b87.html"/>
    <id>https://www.arclin.cn/post/70f61b87.html</id>
    <published>2021-05-25T14:34:00.000Z</published>
    <updated>2021-06-06T18:52:24.963Z</updated>
    
    <content type="html"><![CDATA[<p>本文只是作为iOS底层原理课程的笔记用，所以均为结论性内容，如有疑问可在评论区进行探讨。</p><span id="more"></span><h2 id="NSObject的本质"><a href="#NSObject的本质" class="headerlink" title="NSObject的本质"></a>NSObject的本质</h2><h3 id="一个NSObject对象占用16个字节。"><a href="#一个NSObject对象占用16个字节。" class="headerlink" title="一个NSObject对象占用16个字节。"></a>一个NSObject对象占用16个字节。</h3><p>验证方法</p><ol><li><p>初始化一个<code>NSObject</code>对象<br> <code>NSObject *obj = [[NSObject alloc] init];</code></p></li><li><p>打印内存分配的量，得到16字节<br> <code>malloc_size((__bridge const void *)obj)</code> </p></li><li><p>但是实际上只使用了8个字节，因为使用<code>class_getInstanceSize([NSObject class])</code>得到8</p></li></ol><p><code>class_getInstanceSize</code>计算出了NSObject对象内的成员变量（即isa）的占用内存大小</p><h3 id="NSObject实质上是一个结构体对象"><a href="#NSObject实质上是一个结构体对象" class="headerlink" title="NSObject实质上是一个结构体对象"></a>NSObject实质上是一个结构体对象</h3><p>大概长这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为成员变量isa永远是对象（NSObject的子类对象）的第一个成员变量，所以对象的地址就是成员变量isa的地址</p><h3 id="NSObject的子类"><a href="#NSObject的子类" class="headerlink" title="NSObject的子类"></a>NSObject的子类</h3><p>比如有这么一个类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface Student : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">    int _no;</span><br><span class="line">    int _age;</span><br><span class="line">    int _height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student *stu &#x3D; [[Student alloc] init];</span><br></pre></td></tr></table></figure><p><code>class_getInstanceSize([Student class])</code> 得到 24（意思为这个类至少需要的内存）<br><code>malloc_size((__bridge const void *)stu)</code> 得到32（意思为系统分配给这个类的内存）</p><p>一般情况下我们更关心<code>malloc_size</code>得到的值</p><p>因为继承自<code>NSObject</code>，所以<code>Student</code>有一个<code>Class isa</code>属性，占用8个字节，<code>_no</code>、<code>_age</code>、<code>_height</code> 各占用4个字节，一共占用20个字节，</p><p>因为内存分配原则为<strong>最大成员所占内存</strong>（目前是isa 最大）的倍数，所以给够24个，这个叫做字节对齐</p><p>因为 <code>isa</code>、<code>_no</code>、<code>_age</code> 刚好够 16个字节了，这时候突然又来多了个<code>_height</code>，这时候就需要20个字节了 , 那么为了适配各个厂商的内存读取规则，又给他分配了16个（凑16的倍数），这个叫做内存对齐，所以一共给类分配了 32个字节</p><p>注：int 占用4个字节 double占用8个字节</p><p>分配原则：如果内存一行(16个字节)放不下，那么就直接开新的一行<br>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_no : Int </span><br><span class="line">_age : Double</span><br><span class="line">_height : Int</span><br></pre></td></tr></table></figure><p>第一行：<code>isa</code> :8个，<code>_no</code> 4个，第一行剩下4个字节的位置，不够放<code>_age</code>,但是够放<code>_height</code>，那就直接放<code>_height</code>，如果这时候<code>_height</code>是<code>Double</code>的话，没别的东西来占用这4个位置，那么就直接放弃，开辟下一行<br>第二行：前八个位置直接给<code>_age</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x108b0bb00: d1 81 00 00 01 80 1d 01  &lt;- isa   04 00 00 00 &lt;- age   00 00 00 00  &lt;- height ................</span><br><span class="line">0x108b0bb10: 00 00 00 00 00 00 00 00  &lt;- age 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure><h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h3><p>__sizeof()__方法是一个运算符，在编译期间就确定值，类似于宏替换，他的作用是计算传入的对象占用的内存的大小，如果传入的是类型（或者类名）的话，就计算类型占用的大小，比如传入一个对象的话，就是计算指向这个对象的指针的大小，指针占用的内存大小是8个字节，跟<code>class_getInstanceSize</code>的区别是<code>class_getInstanceSize</code>是计算类实例化后占用的大小。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文只是作为iOS底层原理课程的笔记用，所以均为结论性内容，如有疑问可在评论区进行探讨。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="底层原理" scheme="https://www.arclin.cn/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS动态加载字体</title>
    <link href="https://www.arclin.cn/post/f82939c6.html"/>
    <id>https://www.arclin.cn/post/f82939c6.html</id>
    <published>2021-03-17T02:42:42.000Z</published>
    <updated>2021-08-21T09:03:39.407Z</updated>
    
    <content type="html"><![CDATA[<p>当你某个在开发某个SDK时需要使用到特殊字体，因为无法修改应用的info.plist，所以这时候我们需要采用动态注册字体的方式加载字体，方法如下</p><span id="more"></span><ul><li><p>OC</p><p>  方法调用</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[UIFont fontWithName:&lt;#(nonnull NSString *)#&gt; size:&lt;#(CGFloat)#&gt;]</span><br></pre></td></tr></table></figure><p>  如果上述方法返回nil,则你需要注册你的字体</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSBundle *bundle &#x3D; [NSBundle bundleForClass:[self class]];</span><br><span class="line">NSURL *fontURL &#x3D; [bundle URLForResource:&lt;#fontName#&gt; withExtension:@&quot;otf&quot;&#x2F;*or TTF*&#x2F;];</span><br><span class="line">NSData *inData &#x3D; [NSData dataWithContentsOfURL:fontURL];</span><br><span class="line">CFErrorRef error;</span><br><span class="line">CGDataProviderRef provider &#x3D; CGDataProviderCreateWithCFData((CFDataRef)inData);</span><br><span class="line">CGFontRef font &#x3D; CGFontCreateWithDataProvider(provider);</span><br><span class="line">if (!CTFontManagerRegisterGraphicsFont(font, &amp;error)) &#123;</span><br><span class="line">CFStringRef errorDescription &#x3D; CFErrorCopyDescription(error);</span><br><span class="line">NSLog(@&quot;Failed to load font: %@&quot;, errorDescription);</span><br><span class="line">CFRelease(errorDescription);</span><br><span class="line">&#125;</span><br><span class="line">CFSafeRelease(font);</span><br><span class="line">CFSafeRelease(provider);</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void CFSafeRelease(CFTypeRef cf) &#123;</span><br><span class="line">    if (cf !&#x3D; NULL) &#123;</span><br><span class="line">        CFRelease(cf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Swift</p><p>  方法调用</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIFont</span>.customFont(name:<span class="string">&quot;xxx&quot;</span> size: <span class="number">12</span>)</span><br></pre></td></tr></table></figure>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIFont</span> </span>&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">customFont</span>(<span class="params">fontName</span>:<span class="type">String</span>, <span class="params">size</span>: <span class="type">CGFloat</span>)</span> -&gt; <span class="type">UIFont</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> font <span class="operator">=</span> <span class="type">UIFont</span>(name: fontName, size: size) &#123;</span><br><span class="line">        <span class="keyword">return</span> font</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">_</span> <span class="operator">=</span> <span class="keyword">self</span>.registerFont(bundle: <span class="type">Bundle</span>.<span class="keyword">init</span>(for: <span class="type">XXXX</span>.<span class="keyword">self</span>), fontName: fontName, fontExtension: <span class="string">&quot;otf&quot;</span>) <span class="comment">// 也可以写ttf,看具体格式</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> newFont <span class="operator">=</span> <span class="type">UIFont</span>(name: fontName, size: size) &#123;</span><br><span class="line">            <span class="keyword">return</span> newFont</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIFont</span>.customFont(ofSize: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">registerFont</span>(<span class="params">bundle</span>: <span class="type">Bundle</span>, <span class="params">fontName</span>: <span class="type">String</span>, <span class="params">fontExtension</span>: <span class="type">String</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> fontURL <span class="operator">=</span> bundle.url(forResource: fontName, withExtension: fontExtension) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">&quot;Couldn&#x27;t find font <span class="subst">\(fontName)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> fontDataProvider <span class="operator">=</span> <span class="type">CGDataProvider</span>(url: fontURL <span class="keyword">as</span> <span class="type">CFURL</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">&quot;Couldn&#x27;t load data from the font <span class="subst">\(fontName)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> font <span class="operator">=</span> <span class="type">CGFont</span>(fontDataProvider) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">&quot;Couldn&#x27;t create font from data&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> error: <span class="type">Unmanaged</span>&lt;<span class="type">CFError</span>&gt;?</span><br><span class="line">    <span class="keyword">let</span> success <span class="operator">=</span> <span class="type">CTFontManagerRegisterGraphicsFont</span>(font, <span class="operator">&amp;</span>error)</span><br><span class="line">    <span class="keyword">guard</span> success <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error registering font: maybe it was already registered.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>参考资料：<br>    <a href="https://stackoverflow.com/questions/12919513/how-do-i-add-a-custom-font-to-a-cocoapod">https://stackoverflow.com/questions/12919513/how-do-i-add-a-custom-font-to-a-cocoapod</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;当你某个在开发某个SDK时需要使用到特殊字体，因为无法修改应用的info.plist，所以这时候我们需要采用动态注册字体的方式加载字体，方法如下&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 14 App Clips</title>
    <link href="https://www.arclin.cn/post/a44df9c3.html"/>
    <id>https://www.arclin.cn/post/a44df9c3.html</id>
    <published>2020-11-25T02:08:18.000Z</published>
    <updated>2021-06-06T18:52:24.965Z</updated>
    
    <content type="html"><![CDATA[<p>本文将主要探讨App Clips开发流程 和 组件化、非组件化两种开发方式下如何复用代码的问题。</p><span id="more"></span><p>App Clips是iOS14系统的新特性之一，类似于小程序，用户可以在不下载App的情况下体验到App的部分功能，如网易严选的商品详情功能（<a href="https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw">https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw</a>），该功能适合做一些推广和引流的运营工作，另外苹果也提供的原生的浮窗样式，可以引导用户下载完整版App。</p><p>苹果官方文档：<a href="https://developer.apple.com/app-clips/">https://developer.apple.com/app-clips/</a></p><h3 id="目前已知的触发方式"><a href="#目前已知的触发方式" class="headerlink" title="目前已知的触发方式"></a>目前已知的触发方式</h3><ul><li><p>二维码</p><p>  必须使用iOS 14系统相机或者使用控制中心的读取二维码组件来扫码才能触发App Clips。</p></li><li><p>NFC Tags</p><p>  NFC标签感应，比如星巴克桌面内嵌的NFC Tags。</p></li><li><p>Safari App Banner</p><p>  当用户用iOS的Safari浏览器浏览相应的网址后，页面顶部会出现一个横幅，提示用户有App Clips可以用。</p></li><li><p>信息</p><p>  iOS系统自带的iMessage，当你在iMessage发送一个App Clips链接时，系统会自动把信息显示成一个App Clips的卡片。</p></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a13d29c7a17d471dbc551c416ce2ed57~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="开发前置工作"><a href="#开发前置工作" class="headerlink" title="开发前置工作"></a>开发前置工作</h3><h4 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h4><h5 id="创建App-Clips-ID"><a href="#创建App-Clips-ID" class="headerlink" title="创建App Clips ID"></a>创建App Clips ID</h5><ol><li>点击新增APP ID</li></ol><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d62145df226549428f600ace6f1b44cb~tplv-k3u1fbpfcp-zoom-1.image" ><ol start="2"><li>选择App Clip <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f93a07c34f7249b982f0cbca84bfcafe~tplv-k3u1fbpfcp-zoom-1.image" ><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da0c96044db46bb897aab6f71543c8d~tplv-k3u1fbpfcp-zoom-1.image" ></li></ol><ol start="3"><li>输入一串英文名，用于拼接在主工程的bundle id的后面，生成该clip的bundle id <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2ae0fb422f149d98589f36c80123315~tplv-k3u1fbpfcp-zoom-1.image" > </li><li>在Description内输入描述（不能使用特殊符号），并且在下方勾选App Clip能力，比如Apple Pay，Sign in with Apple，Push等等，<strong>Associated Domains必须勾选</strong><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33e78440190242efaa8dac9b47004393~tplv-k3u1fbpfcp-zoom-1.image" > </li><li>最后确认并点击右上方Register即可</li></ol><h5 id="创建Profiles"><a href="#创建Profiles" class="headerlink" title="创建Profiles"></a>创建Profiles</h5><p>流程跟创建App的Profiles一样，就是选择bundle id的时候改成Clip的bundle id 即可，同样有Development、AdHoc、Distribution三种类型</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68bfe6ee218047b7a3232058dcc2e006~tplv-k3u1fbpfcp-zoom-1.image" ><h5 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h5><p>如果需要其他NFC、地点等等的一些方式触发App Clip配置的话，参考这个苹果的文档<a href="https://help.apple.com/app-store-connect/#/dev5b665db74">https://help.apple.com/app-store-connect/#/dev5b665db74</a></p><h4 id="Apple-Store-Connect-配置图片和标题，描述"><a href="#Apple-Store-Connect-配置图片和标题，描述" class="headerlink" title="Apple Store Connect 配置图片和标题，描述"></a>Apple Store Connect 配置图片和标题，描述</h4><ol><li>需要一张1800 * 1200 的图片，用于显示在Clip的卡片上</li><li>副标题用于显示在卡片标题下的小字，如图所示<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b3e18f56f6d49219fc46f77dab1cef2~tplv-k3u1fbpfcp-zoom-1.image" width=30%></li><li>操作包括“打开”“查看”“开始游戏”，体现在卡片右边的蓝色按钮内的文案，根据你的产品类型进行选择就好</li></ol><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c14c35967084886bc3f4fce6e985fcb~tplv-k3u1fbpfcp-zoom-1.image" ><h4 id="配置apple-app-site-association-json"><a href="#配置apple-app-site-association-json" class="headerlink" title="配置apple-app-site-association.json"></a>配置apple-app-site-association.json</h4><p>假设你的开发者账号的Team Id是<code>A123</code>，Clips的bundle id是<code>com.abc.def.clips</code>，主工程的bundle id 是<code>com.abc.def</code>，则配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;appclips&quot;:&#123;</span><br><span class="line">        &quot;apps&quot;:[&quot;A123.com.abc.def.clips&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;applinks&quot;:&#123;</span><br><span class="line">        &quot;apps&quot;:[</span><br><span class="line">        ],</span><br><span class="line">        &quot;details&quot;:&#123;</span><br><span class="line">            &quot;A123.com.abc.def&quot;:&#123;</span><br><span class="line">                &quot;paths&quot;:[</span><br><span class="line">                    &quot;*&quot; &#x2F;&#x2F; 这里的Path根据实际情况配置即可</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;webcredentials&quot;:&#123;</span><br><span class="line">        &quot;apps&quot;:[</span><br><span class="line">            &quot;A123.com.abc.def&quot;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;activitycontinuation&quot;:&#123;</span><br><span class="line">        &quot;apps&quot;:[</span><br><span class="line">            &quot;A123.com.abc.def&quot;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后部署到你自己域名的根目录下，配置方法网上很多教程，这里贴上<a href="https://developer.apple.com/documentation/safariservices/supporting_associated_domains?language=objc">苹果官方文档</a></p><p>如果配置错了，那么上传包到苹果后台之后，就会显示无效域名<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05ddb4d106a349d28c1504762697a9eb~tplv-k3u1fbpfcp-zoom-1.image"></p><p>如果是json配置错误，那么配置正确后不用重新传包，等待苹果那边刷新缓存就好。</p><p>App Clip支持最多在三个域名的网页显示入口，到后面的工程配置那里会说明。</p><h4 id="前端页面添加meta标签"><a href="#前端页面添加meta标签" class="headerlink" title="前端页面添加meta标签"></a>前端页面添加meta标签</h4><p>如果要在H5页面显示Clips入口，加上一段meta标签即可</p><p>如果你的应用市场App id是 <code>123456</code>, Clips的bundle id 是 <code>com.abc.clips</code> 则应该配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;apple-itunes-app&quot; content&#x3D;&quot;app-id&#x3D;123456,app-clip-bundle-id&#x3D;com.abc.clips&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="开发工作"><a href="#开发工作" class="headerlink" title="开发工作"></a>开发工作</h3><h4 id="新建App-Clip-Target"><a href="#新建App-Clip-Target" class="headerlink" title="新建App Clip Target"></a>新建App Clip Target</h4><p>这里以OC工程为例</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9edc6108c0b64885b708ef5c9de8e1d0~tplv-k3u1fbpfcp-zoom-1.image" ><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa5c9c1032174d77a4db0518029b78dd~tplv-k3u1fbpfcp-zoom-1.image" ><h4 id="配置证书和Associated-Domains"><a href="#配置证书和Associated-Domains" class="headerlink" title="配置证书和Associated Domains"></a>配置证书和Associated Domains</h4><p>用刚才生成的证书去配置一下即可</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fbccb4eee1445ca9b680200358535e0~tplv-k3u1fbpfcp-zoom-1.image" ><p>添加Associated Domains，目的是打开对应域名网页后，页面上方能够出现Clip的入口。</p><p><strong>这里可以添加多个域名，注意每个域名都需要配置apple-app-site-association！！！</strong></p><p><strong>主工程的Target和Clip的Target都需要配置！！！</strong></p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5125ca96f15433b8205294e48906e13~tplv-k3u1fbpfcp-zoom-1.image" ><h4 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h4><p>创建完之后就会生成一个文件夹，里面就是我们熟悉的AppDelegate、SecneDelegate、Main.storyboard、Info.plist等文件，如果你不使用Storyboard进行界面搭建，那么也是跟之前的开发模式一样，删除info.plist内Application Scene Manifest，修改General-Deployment info - Main interface 为空，修改AppDelegate.m，在里面创建根控制器。</p><p>之后的操作就跟普通开发一样了，调试的话可以直接在Xcode上左上角选择Clip的target，然后就可以跑起来了。</p><p>另外，AppIcon是需要独立配置的，同样也是在Clip项目工程文件夹内Assets.xcassets。</p><h5 id="非组件化开发模式"><a href="#非组件化开发模式" class="headerlink" title="非组件化开发模式"></a>非组件化开发模式</h5><p>一般情况下我们是需要复用代码的，将代码内某些模块功能进行复用，然后直接用在Clip，这时候我们只需要在右侧Target Membership勾选新建的Clip Target即可。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2847eb910740229f410d0aa29f7bb5~tplv-k3u1fbpfcp-zoom-1.image" width=30%><p>同样的 相关的依赖到的文件也需要勾选Clip Target</p><h5 id="组件化开发模式-和-Podfile的配置"><a href="#组件化开发模式-和-Podfile的配置" class="headerlink" title="组件化开发模式 和 Podfile的配置"></a>组件化开发模式 和 Podfile的配置</h5><p>如果是在组件化开发模式下，那么就需要配置Podfile</p><p>在Podfile 底部新增代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class="line"># 你的私有pod仓库</span><br><span class="line">source &#39;https:&#x2F;&#x2F;git.xxx.com&#x2F;yourprivatepodspec&#x2F;Podspec.git&#39;</span><br><span class="line"></span><br><span class="line">target &#39;YourApp’ do</span><br><span class="line">    platform :ios, &#39;10.3&#39;</span><br><span class="line">    pod &quot;AFNetworking&quot;</span><br><span class="line">    pod &quot;SDWebImage&quot;</span><br><span class="line">    # 等等</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#39;YourApp_Clips&#39; do</span><br><span class="line">    platform :ios, &#39;10.3&#39;</span><br><span class="line">    pod &#39;ComponentA&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class="line">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class="line">    pod &quot;AFNetworking&quot;</span><br><span class="line">    pod &quot;SDWebImage&quot;</span><br><span class="line">    # 等等</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这样子相同的第三方pod会写两遍，所以我们可以优化成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class="line"># 你的私有pod仓库</span><br><span class="line">source &#39;https:&#x2F;&#x2F;git.xxx.com&#x2F;yourprivatepodspec&#x2F;Podspec.git&#39;</span><br><span class="line"></span><br><span class="line">def common_pods</span><br><span class="line">    pod &quot;AFNetworking&quot;</span><br><span class="line">    pod &quot;SDWebImage&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#39;YourApp’ do</span><br><span class="line">    platform :ios, &#39;10.3&#39;</span><br><span class="line">    common_pods</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#39;YourApp_Clips&#39; do</span><br><span class="line">    platform :ios, &#39;14.0&#39;</span><br><span class="line">    pod &#39;ComponentA&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class="line">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class="line">    common_pods</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="抽离模块时不同环境的代码复用问题"><a href="#抽离模块时不同环境的代码复用问题" class="headerlink" title="抽离模块时不同环境的代码复用问题"></a>抽离模块时不同环境的代码复用问题</h5><p>假如说A功能需要抽离出来放到Clip，但是A模块里面有需求是会跳转到B模块的，但是我并不希望Clip引入B模块，希望他能在这个地方提示用户下载完整App，那应该怎么做呢？</p><p>首先第一个事情，苹果提供了一个Api可以引导弹窗引导用户下载APP</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fec69fde9e64618819b1b526034d23b~tplv-k3u1fbpfcp-zoom-1.image" width=40%><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UIWindowScene *scene &#x3D; (UIWindowScene *)[[UIApplication sharedApplication].connectedScenes.allObjects firstObject];</span><br><span class="line">SKOverlayAppConfiguration *config &#x3D; [[SKOverlayAppConfiguration alloc] initWithAppIdentifier:@&quot;你的AppID&quot; position:SKOverlayPositionBottomRaised];</span><br><span class="line">SKOverlay *overlay &#x3D; [[SKOverlay alloc] initWithConfiguration:config];</span><br><span class="line">overlay.delegate &#x3D; self; &#x2F;&#x2F; 添加代理后可以监听弹窗的弹出和消失，可以在代理内添加埋点。</span><br><span class="line">[overlay presentInScene:scene];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 主动让弹窗消失</span><br><span class="line">&#x2F;&#x2F; [SKOverlay dismissOverlayInScene:scene];</span><br></pre></td></tr></table></figure><p>第二. 如何在模块内划分环境，区分是主App还是Clip</p><p>方法一：设计一个单例，添加一个枚举属性，分别在<code>主工程</code>的AppDelegate和<code>Clip</code>的AppDelegate内给单例的属性赋值，标记当前环境。然后在业务代码中获取单例的环境属性后进行判断。</p><p>方法二：有时候我们在Clip复用的模块代码内不需要import某些头文件，因为我们不需要这个功能，这时候单例的方法就不管用了，我们需要通过宏去判断。</p><p>如果代码不在pod组件内的话，只需要在Clip Target的<code>Build Settings</code> - <code>Preprocessor Macros</code>添加<code>APP_CLIPS</code>宏即可。</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7708c16f9c4247a9ab9ec393d01420b1~tplv-k3u1fbpfcp-zoom-1.image" ><p>如果是组件化的开发模式，代码在pod内部，那么就稍微有点麻烦，需要在对应podspec新增一个subspec，专门提供给clip使用，然后配置上宏定义</p><p><code>ComponentA.podspec</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">s.subspec &quot;App&quot; do |ss|</span><br><span class="line">    ss.source_files &#x3D; &quot;xxxxxx&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &quot;AppClip&quot; do |ss|</span><br><span class="line">    ss.source_files &#x3D; &quot;xxxxxx&quot;</span><br><span class="line">    ss.pod_target_xcconfig &#x3D; &#123; &#39;GCC_PREPROCESSOR_DEFINITIONS&#39; &#x3D;&gt; &#39;APP_CLIPS&#x3D;1&#39;&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>这里为什么要弄多一个App的subspec，因为如果主工程直接<code>pod ComponentA</code>的话，所有的subspec都会被引入，所以这里为了区分开，就加多了一个专门给主工程用的subspec</p></blockquote><p><code>Podfile</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def common_pods</span><br><span class="line">    pod &quot;AFNetworking&quot;</span><br><span class="line">    pod &quot;SDWebImage&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#39;YourApp’ do</span><br><span class="line">    platform :ios, &#39;10.3&#39;</span><br><span class="line">    common_pods</span><br><span class="line">    pod &#39;ComponentA&#x2F;App&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#39;YourApp_Clips&#39; do</span><br><span class="line">    platform :ios, &#39;14.0&#39;</span><br><span class="line">    pod &#39;ComponentA&#x2F;AppClip&#39;,   :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class="line">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class="line">    common_pods</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>通过以上方法，就可以用如下方式进行宏判断，区分当前环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef APP_CLIPS</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="测试工作"><a href="#测试工作" class="headerlink" title="测试工作"></a>测试工作</h3><h4 id="开发调试"><a href="#开发调试" class="headerlink" title="开发调试"></a>开发调试</h4><ul><li><p>可以选择Clip Target直接使用Xcode编译运行</p></li><li><p>可以使用真机扫描二维码，调起Clip卡片，但是前提是Clip要先在真机跑一遍。</p><ol><li>手机点击<code>设置-开发者-Local Experiences-Register Local Experience</code></li><li>输入域名、Clip的bundle id、标题、子标题，选择按钮标题、选择Clip弹出的卡片上的图片，然后点击存储即可。</li><li>将刚才输入的域名，去草料二维码等二维码生成网站生成一个二维码，然后手机相机扫描即可弹出卡片样式。</li><li>具体内容可以参考<a href="https://developer.apple.com/documentation/app_clips/testing_your_app_clip_s_launch_experience?language=objc">官方文档</a></li></ol></li></ul><h4 id="外部测试"><a href="#外部测试" class="headerlink" title="外部测试"></a>外部测试</h4><ol><li>可以通过Archive打Release环境的包（Debug状态下没有选择导出Clip ipa的选项，不知道是哪里配置问题，如果有知道的小伙伴可以评论区分享一下），然后单独导出Clip的ipa，上传到蒲公英或者Fir等分发平台，测试同事就可以下载安装测试了。</li><li>如果已经传到了TestFlight，那么也可以在TestFlight上直接点击打开小程序进行测试。</li></ol><h3 id="苹果官方提及的产品要求"><a href="#苹果官方提及的产品要求" class="headerlink" title="苹果官方提及的产品要求"></a>苹果官方提及的产品要求</h3><p>原文：<a href="https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/">https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/</a></p><p>划重点：</p><ol><li><p>请勿仅将App Clip用作营销用途，不能显示广告。</p></li><li><p>避免登录，避免不了的话尽可能使用Apple id登录</p></li><li><p>Clips启动后只有在8小时内才能接收推送</p></li></ol><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol><li><p>苹果文档说的App Clips 10M限制指的是哪个文件的10M</p><p> 经过测试后发现，应该是Release环境下Archive后，导出的Clips的ipa的大小，如果有误欢迎评论区指正。</p></li><li><p>Clips可以有登录功能吗？</p><p> 可以，但是苹果希望用户能不登录就使用App，如果要登录也首选Sign in with Apple登录的方式(iOS13特性)，但是我们可以学网易严选那样子苹果ID登录之后再弹出手机验证码绑定功能。</p></li><li><p>可以有内购吗？</p><p> 可以。</p></li><li><p>用户使用完Clips后，如果想再次进入，入口在哪儿？</p><p> 假如是网页打开的Clips，那么离开网页后，在桌面的”资源库”里可以找到这个Clips并重新打开。如果找不到就搜索资源库，总能搜到的。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将主要探讨App Clips开发流程 和 组件化、非组件化两种开发方式下如何复用代码的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="feature" scheme="https://www.arclin.cn/tags/feature/"/>
    
  </entry>
  
  <entry>
    <title>iOS 14新API</title>
    <link href="https://www.arclin.cn/post/36f1cd4f.html"/>
    <id>https://www.arclin.cn/post/36f1cd4f.html</id>
    <published>2020-06-29T03:08:18.000Z</published>
    <updated>2021-06-06T18:52:24.965Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 14 新API</p><span id="more"></span><h3 id="Control-Appearance-update"><a href="#Control-Appearance-update" class="headerlink" title="Control Appearance update"></a>Control Appearance update</h3><p>控件外观更新，比如UISlider、 UIProgressView、UIActivityIndicatorView，长得稍微有点不一样，不影响适配。</p><p><img src="https://s1.ax1x.com/2020/06/29/NfJ6zt.png"></p><p>UIPageControl样式改变并且可以自定义icon</p><p><img src="https://s1.ax1x.com/2020/06/29/NfYs7F.png"></p><p>自定义小心心icon和书签icon</p><p><img src="https://s1.ax1x.com/2020/06/29/NfYO1I.png"></p><h3 id="Color-Picker"><a href="#Color-Picker" class="headerlink" title="Color Picker"></a>Color Picker</h3><p>新增颜色选择器<code>UIColorPickerViewController</code></p><p>支持取色器 收藏常用颜色等等</p><p>可以配置是否支持调整透明度等等，具体配置项目参考api文档</p><p>建议Present弹出</p><p><a href="https://sm.ms/image/iz1WnGFImlUvkty" target="_blank"><img src="https://i.loli.net/2020/06/29/iz1WnGFImlUvkty.png" width=50% ></a></p><h3 id="Date-Picker"><a href="#Date-Picker" class="headerlink" title="Date Picker"></a>Date Picker</h3><p>UIDatePicker更新UI</p><p>两种样式</p><p>支持农历</p><p><a href="https://sm.ms/image/wMmTIykghRNqWQn" target="_blank"><img src="https://i.loli.net/2020/06/29/wMmTIykghRNqWQn.png" width=50% ></a></p><p><a href="https://sm.ms/image/uF3WonxPAsDyXaO" target="_blank"><img src="https://i.loli.net/2020/06/29/uF3WonxPAsDyXaO.png" width=50% ></a></p><h3 id="Menus"><a href="#Menus" class="headerlink" title="Menus"></a>Menus</h3><p>貌似可以替代我们常有的角标弹窗列表按钮需求</p><p>基于<code>UIButton</code>和<code>UIBarButtonItem</code>的新增的<code>menu</code>属性，可以配置长按或者单击(配置 <code>button.showsMenuAsPrimaryAction = true</code>)弹出菜单列表</p><p><a href="https://sm.ms/image/L1XmoD2d7EKj49Y" target="_blank"><img src="https://i.loli.net/2020/06/29/L1XmoD2d7EKj49Y.png" width=50% ></a></p><p><a href="https://sm.ms/image/ZflMaksQFDuKp3T" target="_blank"><img src="https://i.loli.net/2020/06/29/ZflMaksQFDuKp3T.png" width=50% ></a></p><p>UINavigationBar 的原生返回按钮长按会弹出菜单，可以跳回导航栏栈中的任意一个页面，按钮标题为前面控制器的标题</p><p><a href="https://sm.ms/image/FVdgXvpGeTBfYKZ" target="_blank"><img src="https://i.loli.net/2020/06/29/FVdgXvpGeTBfYKZ.png" width=50% ></a></p><p>更新弹出菜单内容，将会实时更新并自带系统动画：</p><p><code>updateVisibleMenu(_ block: (UIMenu) -&gt; UIMenu)</code></p><h3 id="UIActions"><a href="#UIActions" class="headerlink" title="UIActions"></a>UIActions</h3><p>UIBarButtonItem 新增 fixedSpace(width:) 和 flexibleSpace方法 去调节item之间的间隔，不用像之前那样子创建一个fixedSpace类型的UIBarButtonItem去占位</p><p>UIButton新增了一个初始化方法init(type:primaryAction:) type默认为.system 标题为primaryAction.title ，图片为 primaryAction.image</p><h3 id="WidgetKit"><a href="#WidgetKit" class="headerlink" title="WidgetKit"></a>WidgetKit</h3><p>iOS14 重大新特性之一 支持三种宽度的widget，具体内容另外开篇再讲<br><a href="https://sm.ms/image/eiXyvjhfgAqQURr" target="_blank"><img src="https://i.loli.net/2020/06/29/eiXyvjhfgAqQURr.png" width=50% ></a></p><h3 id="让你的app支持物理键盘"><a href="#让你的app支持物理键盘" class="headerlink" title="让你的app支持物理键盘"></a>让你的app支持物理键盘</h3><p><a href="https://developer.apple.com/documentation/uikit/keyboards_and_input/adding_hardware_keyboard_support_to_your_app">具体内容查看文档</a></p><h3 id="Asynchronously-Loading-Images-into-Table-and-Collection-Views"><a href="#Asynchronously-Loading-Images-into-Table-and-Collection-Views" class="headerlink" title="Asynchronously Loading Images into Table and Collection Views"></a>Asynchronously Loading Images into Table and Collection Views</h3><p><a href="https://developer.apple.com/documentation/uikit/uiimage/asynchronously_loading_images_into_table_and_collection_views">文档</a></p><p>tableView和CollectionView异步加载网络图片的API</p><h3 id="PHPicker-图片选择器"><a href="#PHPicker-图片选择器" class="headerlink" title="PHPicker 图片选择器"></a>PHPicker 图片选择器</h3><p>新的图片选择器，支持多选，不需要用户允许相册访问权限，可以选择图片（包括livePhoto）和视频</p><p><a href="https://sm.ms/image/R9fc3SZIlpLhuwB" target="_blank"><img src="https://i.loli.net/2020/06/29/R9fc3SZIlpLhuwB.png" width=50% ></a></p><h3 id="定位权限更新"><a href="#定位权限更新" class="headerlink" title="定位权限更新"></a>定位权限更新</h3><p>旧的定位权限弹窗如下：</p><p><a href="https://sm.ms/image/kSgBdY3hjRWG21E" target="_blank"><img src="https://i.loli.net/2020/06/29/kSgBdY3hjRWG21E.png" width=50% ></a></p><p>新的定位权限弹窗如下：</p><p><a href="https://sm.ms/image/svo9OnAS1BZdLDP" target="_blank"><img src="https://i.loli.net/2020/06/29/svo9OnAS1BZdLDP.png" width=50% ></a></p><p>多了个小地图，并且小地图的左上角多了个按钮，点击选择是否允许准确定位。</p><p>若不允许的话，开发者获取的定位会变成一个±5公里的范围，并且只能持续定位最多20分钟</p><p>通过一个枚举值得知是否用户选择了模糊定位：</p><p><a href="https://sm.ms/image/9gh6mbKL7VWe3uH" target="_blank"><img src="https://i.loli.net/2020/06/29/9gh6mbKL7VWe3uH.png" ></a></p><p>用户可以改变设置，是否允许app获取准确定位</p><p><a href="https://sm.ms/image/jsQr4xoevXNa2Ju" target="_blank"><img src="https://i.loli.net/2020/06/29/jsQr4xoevXNa2Ju.png" ></a></p><p>开发者可以通过在<code>info.plist</code>里面配置信息解释为何需要用户选择准确定位</p><p><a href="https://sm.ms/image/X5CRUopcnOHG3I2" target="_blank"><img src="https://i.loli.net/2020/06/29/X5CRUopcnOHG3I2.png" ></a></p><p>让隐私弹窗默认选择模糊定位</p><p><a href="https://sm.ms/image/UeLtJhGXOvbKmns" target="_blank"><img src="https://i.loli.net/2020/06/29/UeLtJhGXOvbKmns.png" width=50%></a></p><h3 id="UICollectionView重大更新"><a href="#UICollectionView重大更新" class="headerlink" title="UICollectionView重大更新"></a>UICollectionView重大更新</h3><p>UICollection从数据源协议到Cell都有了新的API，开发者可以为cell添加各种“附件”，已适配复杂的列表样式，如下第二张图，另外可以在collectionView上使用类似tableView的样式，如下图</p><p><a href="https://sm.ms/image/Iaho8TuHE1P4iRx" target="_blank"><img src="https://i.loli.net/2020/06/30/Iaho8TuHE1P4iRx.png" ></a></p><p><a href="https://sm.ms/image/taEDOVHfAk2LnQe" target="_blank"><img src="https://i.loli.net/2020/06/30/taEDOVHfAk2LnQe.png"  width=50% ></a></p><p>通过新的配置类，可以做成如下效果</p><p><a href="https://sm.ms/image/nlrR8VBkzqy2SdP" target="_blank"><img src="https://i.loli.net/2020/06/30/nlrR8VBkzqy2SdP.png"  width=50% ></a></p><p><a href="https://sm.ms/image/PhtUgJrCR2OTQwY" target="_blank"><img src="https://i.loli.net/2020/06/30/PhtUgJrCR2OTQwY.png"  width=50% ></a></p><p>新增一个UICollectionListViewCell，可以做出如下样式的cell</p><p><a href="https://sm.ms/image/jlZKFpCybNJPoET" target="_blank"><img src="https://i.loli.net/2020/06/30/jlZKFpCybNJPoET.png" width=50%  ></a></p><p>Cell的注册方式也有所改变，可以看出苹果从API层面已经进入MVVM架构模式了，注册cell需要带上对应的CellViewModel</p><p><a href="https://sm.ms/image/2awdL6yOmUzIGrZ" target="_blank"><img src="https://i.loli.net/2020/06/30/2awdL6yOmUzIGrZ.jpg" width=50% ></a></p><p>另外也支持像UITableViewCell的侧滑操作等等，详细内容将会另外开篇讲述。</p><p>具体查看<a href="https://developer.apple.com/videos/play/wwdc2020/10097/">视频</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;iOS 14 新API&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="feature" scheme="https://www.arclin.cn/tags/feature/"/>
    
  </entry>
  
  <entry>
    <title>依赖注入与Objection</title>
    <link href="https://www.arclin.cn/post/6ae5f77f.html"/>
    <id>https://www.arclin.cn/post/6ae5f77f.html</id>
    <published>2020-05-01T02:44:01.000Z</published>
    <updated>2021-06-06T18:52:24.970Z</updated>
    
    <content type="html"><![CDATA[<p>本文会说明iOS内依赖注入的概念和依赖注入框架Objection的一般使用</p><span id="more"></span><h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>首先先说明什么叫做依赖注入</p><p>比如AController跳转到BController,那么这时候BController就需要在AController内部进行实例化，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@implementation AController : UIViewController</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (void)jump </span><br><span class="line">&#123;</span><br><span class="line">BController *bController &#x3D; [[BController alloc] init];</span><br><span class="line">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这么做的话，当AController被封装成组件之后，BController的配置将会被限制，外部无法改变BController任何细节，所以我们 ** 稍 加 改 进 **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@implementation AController : UIViewController</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCreateBlock:(UIViewController *(^)(void))createBViewControllerBlock &#123;</span><br><span class="line">....</span><br><span class="line">self.createBViewControllerBlock &#x3D; createBViewControllerBlock;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jump </span><br><span class="line">&#123;</span><br><span class="line">UIViewController *bController &#x3D; self.createBViewControllerBlock();</span><br><span class="line">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[AController alloc] initWithCreateBlock:UIViewController* ^&#123;</span><br><span class="line">BController *bController &#x3D; [[BController alloc] initWithTitle:@&quot;xxx&quot;];</span><br><span class="line">return bController;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>将BController的创建通过Block暴露出来，AController内部不关心BController是如何被创建的，那么AController对BController的依赖将通过外部的Block进行注入。</p><p>这，就是依赖注入。</p><p>当然这是最简单的依赖注入，无法满足我们复杂的需求，所以有时候我们需要使用第三方框架，如<code>Objection</code>和<code>Typhoon</code></p><h4 id="Objection"><a href="#Objection" class="headerlink" title="Objection"></a>Objection</h4><p>接下来说明一下Objection的使用</p><p>Objection 是一个依赖注入框架，能够在你获取一个类的实例的时候，这个类内部的属性也同时会被实例化。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Car.h</span><br><span class="line"></span><br><span class="line">@class Engine,Break;</span><br><span class="line"></span><br><span class="line">@interface Car : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) Engine *engine;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) Break *breaks;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Car.m</span><br><span class="line"></span><br><span class="line">#import &lt;Objection&#x2F;Objection.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation Car</span><br><span class="line">objection_requires(@&quot;engine&quot;, @&quot;breaks&quot;)</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建一个默认注射器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSObjectionInjector *injector &#x3D; [JSObjection createInjector];</span><br><span class="line">[JSObjection setDefaultInjector:injector];</span><br></pre></td></tr></table></figure><p>实例化Car对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car *car &#x3D; [[JSObjection defaultInjector] getObject:[Car class]];</span><br></pre></td></tr></table></figure><p>这时候所依赖的<code>engine</code>对象和<code>breaks</code>对象都会通过<code>init</code>方法实例化</p><p>最后打印属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">car &lt;Car: 0x6000006d8480&gt; engine &lt;Engine: 0x6000004841b0&gt; breaks &lt;Break: 0x6000004841e0&gt;</span><br></pre></td></tr></table></figure><p>假如说Car对象不能通过<code>init</code>或者<code>initWithXXX</code>等自定义构造方法去实例化，那么我们需要指定方法，让注射器在指定的方法构建依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@implementation Car</span><br><span class="line">objection_requires(@&quot;engine&quot;, @&quot;breaks&quot;)</span><br><span class="line">- (void)awakeFromNib &#123;</span><br><span class="line">  [[JSObjection defaultInjector] injectDependencies:self];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>当Car被注射器初始化完成之后，会调用<code>- awakeFromObjection</code>方法，这里可以额外赋一些值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)awakeFromObjection </span><br><span class="line">&#123;</span><br><span class="line">self.test &#x3D; @&quot;111&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的说的都是直接init出来的对象，但是更多情况下我们需要指定构造方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation Car</span><br><span class="line">objection_initializer_sel(@selector(initWithObject:)) &#x2F;&#x2F; 该宏只需且只能出现一次</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithObject:(id)object</span><br><span class="line">&#123;</span><br><span class="line">    if (self &#x3D; [super init]) &#123;</span><br><span class="line">        self.test &#x3D; object;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>取出的时候加上<code>argumentList:</code>参数即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car *car &#x3D; [[JSObjection defaultInjector] getObject:[Car class] argumentList:@[@&quot;aaaa&quot;]];</span><br></pre></td></tr></table></figure><p>或者不想写<code>objection_initializer_sel()</code>宏的话<br>可以直接在取的方法那里改动一下变成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car *car &#x3D; [[JSObjection defaultInjector] getObject:[Car class] initializer:@selector(initWithObject:) argumentList:@[@&quot;aaaa&quot;]];</span><br></pre></td></tr></table></figure><p>效果也是一样的</p><h5 id="对象工厂"><a href="#对象工厂" class="headerlink" title="对象工厂"></a>对象工厂</h5><p>在Car中添加一个对象工厂属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic, strong) JSObjectFactory *objectFactory;</span><br></pre></td></tr></table></figure><p>然后标记注入里面加多一个<code>objectFactory</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objection_requires(@&quot;engine&quot;, @&quot;breaks&quot;,@&quot;objectFactory&quot;)</span><br></pre></td></tr></table></figure><p>然后你就可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id obj &#x3D; [self.objectFactory getObject:[Engine class]];</span><br></pre></td></tr></table></figure><p>获取到对应的对象</p><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>你可以创建一个继承自<code>JSObjectionModule</code>的模块，在里面绑定相对应的<code>事物</code>，便可直接取到对应的值</p><p>例如  一个协议和一个模块类，对象绑定了类名和这个类所遵循的协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@protocol APIService &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)api:(NSString *)params;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface ModuleA : JSObjectionModule</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ModuleA</span><br><span class="line"></span><br><span class="line">- (void)configure</span><br><span class="line">&#123;</span><br><span class="line">    [self bindClass:[MyAPIService class] toProtocol:@protocol(APIService)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时候注射器初始化方式改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSObjectionInjector *injectorA &#x3D; [JSObjection createInjector:ModuleA.new]; [JSObjection setDefaultInjector:injectorA];</span><br></pre></td></tr></table></figure><p>你就可以直接拿到对应遵循了这个协议的对象而不用通过ModuleA的实例对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyAPIService *delegate &#x3D; [injectorA getObject:@protocol(APIService)];</span><br></pre></td></tr></table></figure><p><strong>注意由于绑定的时候是用了bindClass:方法，所以每次取出都是不同的对象</strong></p><p>除了绑定对象类名和协议外，还可以绑定一个对象和绑定一个类名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@implementation ModuleA</span><br><span class="line"></span><br><span class="line">- (void)configure</span><br><span class="line">&#123;</span><br><span class="line">    [self bind:对象实例 toClass:[UIApplication class]];</span><br><span class="line">    [self bind:对象实例 toProtocol:@protocol(UIApplicationDelegate)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**注意由于绑定的时候是用了bind:方法，所以每次取出都是相同的对象 **</p><p>当对象被创建的时候，可以通过bindBlock:方法进行干涉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@implementation ModuleA</span><br><span class="line"></span><br><span class="line">- (void)configure</span><br><span class="line">&#123;</span><br><span class="line">    [self bindClass:[MyAPIService class] toProtocol:@protocol(APIService)];</span><br><span class="line">    [self bindBlock:^id(JSObjectionInjector *context) &#123;</span><br><span class="line">        MyAPIService *service &#x3D; [[MyAPIService alloc] init];</span><br><span class="line">        service.buildByMySelf &#x3D; YES;</span><br><span class="line">        return service;</span><br><span class="line">    &#125; toClass:[MyAPIService class]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>上面这个例子表示MyAPIService被实例化后都会带上<code>buildByMySelf = YES</code></p><p>但是用这种方法的话，假如用注射器取出对象的时候带上了参数，那我们就没办法拿到参数了，所以我们需要用到<code>ObjectionProvider</code>协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@interface ProviderA : JSObjectionModule&lt;JSObjectionProvider&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ProviderA</span><br><span class="line">- (id)provide:(JSObjectionInjector *)context arguments:(NSArray *)arguments</span><br><span class="line">&#123;</span><br><span class="line">    MyAPIService *service &#x3D; [[MyAPIService alloc] init];</span><br><span class="line">    service.buildByProvider &#x3D; YES;</span><br><span class="line">    service.arguments &#x3D; arguments;</span><br><span class="line">    return service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)configure</span><br><span class="line">&#123;</span><br><span class="line">[self bindProvider:[ModuleA new] toClass:MyAPIService.class];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这样子就能手动构建对象并且得到参数了</p><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>上面提及的<code>bindClass:</code>、<code>bindBlock:</code>、<code>bindProvider:</code>这些方法，都有一个拓展参数<code>inScope:(JSObjectionScope)scope;</code></p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[self bindClass:[MyAPIService class] toProtocol:@protocol(APIService) inScope:JSObjectionScopeSingleton named:@&quot;&quot;];</span><br><span class="line"></span><br><span class="line">[self bindBlock:^id(JSObjectionInjector *context) &#123;</span><br><span class="line">MyAPIService *service &#x3D; [[MyAPIService alloc] init];</span><br><span class="line">service.buildByMySelf &#x3D; YES;</span><br><span class="line">return service;</span><br><span class="line">&#125; toClass:[MyAPIService class] inScope:JSObjectionScopeSingleton named:@&quot;&quot;];</span><br><span class="line"></span><br><span class="line">[self bindProvider:[ModuleA new] toClass:MyAPIService.class inScope:JSObjectionScopeSingleton];</span><br></pre></td></tr></table></figure><p><code>JSObjectionScopeSingleton</code>意味着注射器取出来的都是同个对象，<br><code>JSObjectionScopeNormal</code>意味着注射器取出来的是不同对象。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Objection 帮助你实现** 依赖注入 **，你只需要完成两件事情，配置依赖关系和获取依赖对象。配置依赖关系时，你可以使用几个常用的宏来快速的完成依赖关系的配置，另外你还可以使用模块的概念来完成更多的绑定操作，它允许你将某些类或某些协议接口绑定到某个或某一类的对象上，在配置完成后，你就可以使用关键的 injector 注入器获取到你所需要的对象。</p><p>Objection 像是一种字典容器，通过多种形式将 value 和 key 关联起来，在完成配置之后，你只需要关注你通过何种 key 获取到需要的 value 即可。Objection 最主要的功能之一就是面向接口编程的实现，在上面的示例中也进行了演示，面向接口编程是一种非常重要的编程思想。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文会说明iOS内依赖注入的概念和依赖注入框架Objection的一般使用&lt;/p&gt;</summary>
    
    
    
    <category term="iOS" scheme="https://www.arclin.cn/categories/iOS/"/>
    
    
    <category term="iOS" scheme="https://www.arclin.cn/tags/iOS/"/>
    
    <category term="架构" scheme="https://www.arclin.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
