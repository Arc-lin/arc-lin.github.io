<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2016-Dankal-iOS-MySummary</title>
    <url>/post/61929cc2.html</url>
    <content><![CDATA[<p>总结2016在 Dankal 工作过程中学习到的东西</p>
<span id="more"></span>

<h3 id="Main-Argument-主要论点"><a href="#Main-Argument-主要论点" class="headerlink" title="Main Argument 主要论点"></a>Main Argument 主要论点</h3><p>中介者<br>组件化<br>封装<br>MVVM<br>ReactiveCocoa</p>
<h3 id="基于MVC的组件化设计-CTMediator-（CTNetworking-gt-DKNetworking-gt-DKHTTPTool）"><a href="#基于MVC的组件化设计-CTMediator-（CTNetworking-gt-DKNetworking-gt-DKHTTPTool）" class="headerlink" title="基于MVC的组件化设计 CTMediator + （CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool）"></a>基于MVC的组件化设计 CTMediator + （CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool）</h3><p>CTMediator和CTNetworking 是我在5-6月份左右看的一套源码，出处是这里,然后去年年底作者又发布了<a href="http://casatwy.com/modulization_in_action.html">基于 CTMediator工程实践</a>。总的设计思想如下：</p>
<h3 id="组件逻辑"><a href="#组件逻辑" class="headerlink" title="组件逻辑"></a>组件逻辑</h3><ul>
<li>CTMediator 是一种组件化方案，主要是针对大型项目多人开发情况下的一种方案。路由方式是 Targer-Action，通过这种方式进行模块之间的沟通，模块使用私有 pod 进行封装（这个是在第二篇的实践中提出来的），因为目前我们还没接触过这种大型的项目，所以一直停留在理论阶段（也就是虽然我看懂了源码的设计思想但是却没得地方实现），后来启动了觅书项目，打算尝试这种设计，结果发现过于大材小用了。模块的创建要先通过中介者进行注册，调用要通过中介者进行调用，总结一下大概就像这样子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             --------------------------------------</span><br><span class="line">             | [CTMediator sharedInstance]        |</span><br><span class="line">             |                                    |</span><br><span class="line">             |                openUrl:       &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  (AppDelegate)  &lt;&lt;&lt;&lt;  Call From Other App With URL</span><br><span class="line">             |                                    |</span><br><span class="line">             |                   |                |</span><br><span class="line">             |                   |&#x2F;               |</span><br><span class="line">             |                parseUrl            |</span><br><span class="line">             |                                    |</span><br><span class="line">             |                   |                |</span><br><span class="line">.................................|...............................</span><br><span class="line">             |                   |                |</span><br><span class="line">             |                   |&#x2F;               |</span><br><span class="line">             |  performTarget:action:params: &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  Call From Native Module</span><br><span class="line">             |                   |&#x2F;               |</span><br><span class="line">             |             -------------          |</span><br><span class="line">             |             |  runtime  |          |</span><br><span class="line">             |             -------------          |</span><br><span class="line">             ---------------.---------.------------</span><br><span class="line">                           .           .</span><br><span class="line">                          .             .</span><br><span class="line">-------------------------------      --------------------------------</span><br><span class="line">|                       ·     |      |    ·                         |</span><br><span class="line">|                     ·       |      |     ·                        |</span><br><span class="line">|           Target            |      |           Target             |</span><br><span class="line">|                             |      |                              |</span><br><span class="line">|         &#x2F;   |   \           |      |         &#x2F;   |   \            |</span><br><span class="line">|        &#x2F;    |    \          |      |        &#x2F;    |    \           |</span><br><span class="line">|                             |      |                              |</span><br><span class="line">|   Action Action Action ...  |      |   Action Action Action ...   |</span><br><span class="line">|                             |      |                              |</span><br><span class="line">|Service  A                   |      | Service  B                   |</span><br><span class="line">-------------------------------      --------------------------------</span><br></pre></td></tr></table></figure>

<p>这里面包括了内部调用和远程应用调用，远程应用调用因为我们目前还用不着所以先不管，内部调用的流程为了方便理解我举个例子，fromController通过performTarget:action:params:方法传入toController类名和在toController要执行的方法和所需的参数，这样子组件之间就实现了解耦，fromController 只需要知道他想去的地方是 toController和要给什么值出去，甚至这个 controller 存不存在都无所谓，而 toController 只需要遵循协议方法/重写父类方法去的到参数即可，然后里面就可以直接调这个参数，并且这一系列跳转规则和传参规则都通过 CTMediator 中介者去控制。</p>
<h3 id="服务层（Service-Layer）-或者叫-业务层（Business-Layer）"><a href="#服务层（Service-Layer）-或者叫-业务层（Business-Layer）" class="headerlink" title="服务层（Service Layer） 或者叫 业务层（Business Layer）"></a>服务层（Service Layer） 或者叫 业务层（Business Layer）</h3><p>刚刚总结了一下CTMediator的组件间的逻辑,现在来总结一下业务层与 ViewController 层之间的设计.因为虽然是 MVC，那当然也得尽量避免 Mess View Controller ,Service 在这里可以理解为数据仓库+业务逻辑仓库，为的是令ViewController中避免出现像数据 A处理判断完才显示到控件上的情况，尽量能把最直接的数据给 ViewController 显示,利用像下图这种方式，业务层暴露出 Target 和 action供外界调用，调用方法后就进入了CTMediator 进行处理，接下来的事情就像我上面说的一样了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         --------------------------------</span><br><span class="line">         |           Service  A         |</span><br><span class="line">         ---  ----------  ----------  ---</span><br><span class="line">           |  |        |  |        |  |</span><br><span class="line">...........|  |........|  |........|  |...........</span><br><span class="line">.          |  |        |  |        |  |          .</span><br><span class="line">.        ---  ---    ---  ---    ---  ---        .</span><br><span class="line">.        |action|    |action|    |action|        .</span><br><span class="line">.        ---|----    -----|--    --|-----        .</span><br><span class="line">.           |             |        |             .</span><br><span class="line">.           |             |        |             .</span><br><span class="line">.       ----|------     --|--------|--           .</span><br><span class="line">.       |Target_A1|     |  Target_A2 |           .</span><br><span class="line">.       -----------     --------------           .</span><br><span class="line">..................................................</span><br></pre></td></tr></table></figure>

<h3 id="CTNetworking-gt-DKNetworking-gt-DKHTTPTool"><a href="#CTNetworking-gt-DKNetworking-gt-DKHTTPTool" class="headerlink" title="CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool"></a>CTNetworking -&gt; DKNetworking -&gt; DKHTTPTool</h3><ul>
<li><p>CTNetworking 是一个基于AFNetworking的开源网络层组件，经过改装之后我组装出了 DKNetworking（虽然后面发现有 RAC神器之后就觉得这个东西不够轻便了）。</p>
</li>
<li><p>CTNetworking 解决了以下几个问题</p>
<ul>
<li>使用哪种交互模式来跟业务层做对接？</li>
<li>是否有必要将API返回的数据封装成对象然后再交付给业务层？</li>
<li>使用集约化调用方式还是离散型调用方式去调用API？</li>
</ul>
</li>
<li><p>上面三个问题分别给出的答案是</p>
<ul>
<li>代理模式</li>
<li>没必要</li>
<li>离散型</li>
</ul>
</li>
<li><p>CTNetworking考虑的东西相当地多，除了上面几个问题之外，还考虑到了网络层安全机制（数据传输，HTTPS）,链接环节的优化（链接传输量和链接复用）等，一开始看源码也是看的很懵逼</p>
</li>
<li><p>通过协议的方式进行组件内的方法封装</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>协议名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>CTAPIManagerApiCallBackDelegate</td>
<td>回调协议</td>
</tr>
<tr>
<td>CTAPIManagerCallbackDataReformer</td>
<td>负责重新组装API数据的对象</td>
</tr>
<tr>
<td>CTAPIManagerValidator</td>
<td>验证器验证参数和返回</td>
</tr>
<tr>
<td>CTAPIManagerParamSourceDelegate</td>
<td>参数源</td>
</tr>
<tr>
<td>CTAPIManager</td>
<td>CTAPIBaseManager的派生类必须符合这个protocal</td>
</tr>
<tr>
<td>CTAPIManagerInterceptor</td>
<td>拦截器，拦截参数和回调</td>
</tr>
</tbody></table>
<ul>
<li><p>用协议的好处就是各取所需。当你想要统一管理所有回调的时候，那你这个类只要遵循<code>CTAPIManagerApiCallBackDelegate</code>代理和实现对应的方法，如果你这个类想要拦截参数，那么就遵循<code>CTAPIManagerInterceptor</code>协议并实现对应的方法，大抵就是这种思想，然后底层就会进行各种判断并拼接各个协议的方法的返回值，最后发出请求，得到回调然后处理值并返回出去。</p>
</li>
<li><p>CTNetworking 框架没有使用数据模型，原因就是认为模型嵌入模型的时候处理数据很麻烦，另外模型的复用性很差，容易出现类型爆炸，提高维护成本，还有就是不够NSDictionary、NSArray直观,最最重要的一点就是同一API的数据被不同View展示时，难以控制数据转化的代码，它们有可能会散落在任何需要的地方。所以框架使用了 Reformer 的方法去处理返回的数据（NSDictionary）转成 View 需要的数据（NSDictionary）。</p>
</li>
<li><p>DKNetworking 把 Refromer 部分的实现给改了，依赖了 MJExtension，去实现数据模型数组，因为总感觉NSDictionary很麻烦，难维护就难维护吧，反正项目也不大。</p>
</li>
<li><p>DKHTTPTool 是我在近期集成出来的框架，主要特性包括：</p>
<ul>
<li>支持缓存策略选择</li>
<li>支持链式调用</li>
<li>支持 RACSignal 返回</li>
<li>支持拦截器、验证器</li>
<li>支持直观的Logger输出</li>
<li>支持全局请求头、请求参数</li>
<li>服务器异常直接弹出异常数据而不是一坨 NSData</li>
<li>支持错误码表，统一处理错误</li>
</ul>
</li>
</ul>
<p>还有其他的吗？忘记了<br>总的来说，这个还是挺管用的,毕竟能支持 RAC,符合我们现在的<br>MVVM+ReactiveCocoa的架构</p>
<h3 id="MVVM-ReactiveCocoa"><a href="#MVVM-ReactiveCocoa" class="headerlink" title="MVVM+ReactiveCocoa"></a>MVVM+ReactiveCocoa</h3><ul>
<li>ReactiveCocoa 博大精深，以致于现在都用不到它提供的功能的一半</li>
<li>第二份优秀的源码（虽然跑不起来）<a href="https://github.com/leichunfeng/MVVMReactiveCocoa">MVVMReactiveCocoa</a></li>
<li>产出成品<a href="https://coding.net/u/Arclin/p/Poi/git">Poi</a></li>
</ul>
<h3 id="Navigation-With-ViewModel"><a href="#Navigation-With-ViewModel" class="headerlink" title="Navigation-With-ViewModel"></a>Navigation-With-ViewModel</h3><p> 使用 MVVM 模式应该注意的问题</p>
<ul>
<li>以 ViewModel 为驱动引导着整个应用而不是 ViewController</li>
<li>ViewModel 中不应该引入任何 UIKit 框架</li>
<li>模块与模块间通过 服务总线 去沟通 , 减少模块之间的耦合</li>
</ul>
<p>先看看用 ViewModel 进行 push操作的流程</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------------------------------    </span><br><span class="line">|        ViewModel A           |   </span><br><span class="line">---  ----------  ----------  ---   </span><br><span class="line">	|</span><br><span class="line">	| </span><br><span class="line">[- initWithService:params:]</span><br><span class="line">	| ---------------</span><br><span class="line">	| | service bus | --- &gt; - pushViewModel: animated: </span><br><span class="line">	| ---------------                 |</span><br><span class="line">	|			             （HOOK）[rac_responseToSelector:]</span><br><span class="line">	|			                     |&#x2F;</span><br><span class="line">	|			               &lt;DKNavigationProtocol&gt;-- @&#123; viewModel:viewController&#125;---&gt;navigationController [pushViewController:animated:]</span><br><span class="line">	|&#x2F;</span><br><span class="line"> --------------------------------</span><br><span class="line"> |        ViewModel B           |</span><br><span class="line"> ---  ----------  ----------  ---</span><br></pre></td></tr></table></figure>

<p>说明： ViewModelA 与 ViewControllerA ，ViewModelB 与 ViewControllerB 在 Router 里面通过字典的方式绑定在了一起，然后通过 RAC的方法监听pushViewModel: animated: 方法的执行，然后通过字典得到viewController从而进行真正的 push 操作，大概就是这样子</p>
<h3 id="抽出父类和ReactiveCocoa"><a href="#抽出父类和ReactiveCocoa" class="headerlink" title="抽出父类和ReactiveCocoa"></a>抽出父类和ReactiveCocoa</h3><p>MVVMReactiveCocoa 通过封装父类的方式来实现这个架构，这些父类已经被我抽出来了，过几天会传上去，然后先写一些使用说明</p>
<ol>
<li>每个 Vc 对应一个 ViewModel</li>
<li>TableViewController必须对应 ViewModel</li>
<li>ViewModel 的初始化方法在 - initliazed 中</li>
<li>初始化之前添加一些额外的方法，需要重写 - initWithServer:params:</li>
<li>DKTableViewController是一个二维数组，里面封装的是 viewmodel</li>
<li>cell 要遵循 DKReactiveView 协议</li>
<li>绑定 cell与 viewModel 就在 ViewController里面重写 configureCell:withObject</li>
<li>待补充</li>
</ol>
<p>ReativeCocoa 主要是用来实现 MVVM 的融合剂，当然也不一定要用 RAC去实现 MVVM,说实话 RAC 的学习成本还是相当高的，目前已经在尝试 DKRACHTTPTool,用纯 RAC 的方式去实现网络层和数据持久层的封装，另外还有些异常处理之类的,在这里面使用了filter: ignore: thottle: startWith: doNext: catch: try: doComplete: map: flattenMap: flatten: 等等的方法，非常好使，其他的可以看看我的几篇笔记”使用RAC-DKHTTPTool实践”、”RACCommand使用注意”</p>
<p>最近的一个个人项目 Poi 就实践了这个架构。UI 结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   	    --------------------------------</span><br><span class="line">            |     NavigationConroller0     |</span><br><span class="line">            ---  ----------  ----------  ---</span><br><span class="line">			    |</span><br><span class="line"> 	    --------------------------------</span><br><span class="line">            |       TabBarController       |</span><br><span class="line">            ---  ----------  ----------  ---</span><br><span class="line">		|			 |</span><br><span class="line">--------------------------------     --------------------------------   </span><br><span class="line">|     NavigationConroller1     |     |     NavigationConroller2     |</span><br><span class="line">---  ----------  ----------  ---     ---  ----------  ----------  ---</span><br><span class="line">		|                   		    |</span><br><span class="line">--------------------------------     --------------------------------</span><br><span class="line">|       ViewConroller1         |     |       ViewConroller2         |</span><br><span class="line">---  ----------  ----------  --      --------------------------------</span><br></pre></td></tr></table></figure>

<p>默认整个应用的跳转用的是NavigationConroller0，这样子做的原因是使用了一个第三方框架，为了可以在TabBarController中滑动切换。<br>当 pushViewModel 执行的时候，有一个 NavigationStack 会拿到最底部的 NavigationController 进行 push，如果 modal 出一个 navigationController,那么这个 navigationcontroller 将会压入NavigationStack ,然后这个 modal 出来的 viewController 后面的页面跳转就用这个 stack最上层的 NavigationController，dismiss 之后就会就会从栈中移除这个 NavigationController</p>
<p>大概就是长这样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------------------------------</span><br><span class="line">|     NavigationConroller0     |  </span><br><span class="line">---  ----------  ----------  ---    </span><br><span class="line">		 |	stack + 1	push</span><br><span class="line">--------------------------------    </span><br><span class="line">|       TabBarController       |    </span><br><span class="line">---  ----------  ----------  ---  </span><br><span class="line">		 |		           </span><br><span class="line">--------------------------------   </span><br><span class="line">|     NavigationConroller1     |    </span><br><span class="line">---  ----------  ----------  ---    </span><br><span class="line">		 |      nv0 push     </span><br><span class="line">--------------------------------    </span><br><span class="line">|       ViewConroller1         |    </span><br><span class="line">---  ----------  ----------  ---	  </span><br><span class="line">		 |   	v1 modal</span><br><span class="line">--------------------------------    </span><br><span class="line">|      NavigationConroller2    |    </span><br><span class="line">---  ----------  ----------  ---	  </span><br><span class="line">		 |     stack + 1  push   </span><br><span class="line">--------------------------------    </span><br><span class="line">|      ViewConroller2	       |    </span><br><span class="line">---  ----------  ----------  ---	</span><br><span class="line">		| dismiss</span><br><span class="line">	stack - 1 pop</span><br></pre></td></tr></table></figure>

<h3 id="MVVM-WithOut-ReacitveCocoa"><a href="#MVVM-WithOut-ReacitveCocoa" class="headerlink" title="MVVM WithOut ReacitveCocoa"></a>MVVM WithOut ReacitveCocoa</h3><p>用 Block 的方式代替 Reactive 的绑定功能。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>BugReporter For iOS<ul>
<li>和思华一起开发的基于 iOS 的 bug自动反馈系统，一旦发生崩溃事故就会给开发者发送邮件</li>
</ul>
</li>
<li>自动部署系统Jenkines</li>
<li>JSPatch 热修复平台</li>
<li>UMeng 用户数据统计</li>
<li>等等</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>AVFoundation录制视频没声音?</title>
    <url>/post/efd905d7.html</url>
    <content><![CDATA[<p>先说结论 , 加一行代码 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_captureMovieFileOutput.movieFragmentInterval &#x3D; kCMTimeInvalid</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>看看<code>movieFragmentInterval</code> 属性的说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*!</span><br><span class="line"> @property movieFragmentInterval</span><br><span class="line"> @abstract</span><br><span class="line">    Specifies the frequency with which movie fragments should be written.</span><br><span class="line"></span><br><span class="line"> @discussion</span><br><span class="line">    When movie fragments are used, a partially written QuickTime movie file whose writing is unexpectedly interrupted can be successfully opened and played up to multiples of the specified time interval. A value of kCMTimeInvalid indicates that movie fragments should not be used, but that only a movie atom describing all of the media in the file should be written. The default value of this property is ten seconds.</span><br><span class="line"></span><br><span class="line">    Changing the value of this property will not affect the movie fragment interval of the file currently being written, if there is one.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property(nonatomic) CMTime movieFragmentInterval;</span><br></pre></td></tr></table></figure>

<p>用拙略的英语水平翻译一下就是,<code>movieFragmentInterval</code>这东西代表一个时间间隔,每隔x秒就会把视频片段写入内存,这是为了保证当意外中断视频文件写入的时候还可以有一个可以播放的视频片段,默认是十秒,如果你给他赋了这个值<code>kCMTimeInvalid</code>,就表示要一直写入直到调用某个方法结束视频录制,之后他就会给视频文件加上文件尾部,所以如果没有设置这个值的话,十秒到二十秒的视频中间就会出现没声音的状况.</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>ALAsset-Type:Unknown的问题</title>
    <url>/post/a8ea2211.html</url>
    <content><![CDATA[<ul>
<li>利用ALAssetsLibrary时候，将得到的<code>ALAsset</code>存到数组里，会出现<code>ALAsset - Type:Unknown, URLs:(null)</code>的问题</li>
</ul>
<p>解决方案：初始化ALAssetsLibrary的时候，不要用alloc-init，用一个单例，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (ALAssetsLibrary *)defaultAssetsLibrary</span><br><span class="line">&#123;</span><br><span class="line">    static dispatch_once_t pred &#x3D; 0;</span><br><span class="line">    static ALAssetsLibrary *library &#x3D; nil;</span><br><span class="line">    dispatch_once(&amp;pred,</span><br><span class="line">                  ^&#123;</span><br><span class="line">                      library &#x3D; [[ALAssetsLibrary alloc] init];</span><br><span class="line">                  &#125;);</span><br><span class="line">    return library;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础</title>
    <url>/post/f9a964a9.html</url>
    <content><![CDATA[<p>在iOS开发过程中，有时候会用到一些C++的库，为了避免大家用到这种库的时候一脸懵逼，这里总结一些基础知识，不写C++没关系，起码当库出了什么问题的时候至少能看懂逻辑（或许吧）。</p>
<p>这里全部都是基础语法知识，没事的时候可以看看熟悉一下。</p>
<span id="more"></span>

<h2 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h2><p>略</p>
<p>还是简单说一下：<code>.</code>是对象访问属性的操作符，<code>-&gt;</code>是指针访问指针属性的操作符，<br><code>(*a).b</code>=&gt;<code>a-&gt;b</code></p>
<h2 id="权限访问"><a href="#权限访问" class="headerlink" title="权限访问"></a>权限访问</h2><p>public:   可以被任意实体访问</p>
<p>protected:只允许子类及本类的成员函数访问</p>
<p>private:只允许本类的成员函数访问</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>跟Swift差不多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int func (int a , int b &#x3D; 10, int c &#x3D; 10); &#x2F;&#x2F; 声明中有默认参数，实现中不能有默认参数，比如下面这么写就会报错</span><br><span class="line">&#x2F;&#x2F; 声明和实现只能其中一个有默认参数</span><br><span class="line">int func (int a , int b &#x3D; 10, int c &#x3D; 10) &#123; &#x2F;&#x2F; 形参默认值，当b有默认值的时候，后面的参数都需要有默认值，不能b有c没有，但是可以c有b没有</span><br><span class="line">	 return a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="占位参数（没啥用）"><a href="#占位参数（没啥用）" class="headerlink" title="占位参数（没啥用）"></a>占位参数（没啥用）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void func(int a,int &#x3D; 0) &#123; &#x2F;&#x2F; 占位参数可以有默认参数，也可以没有</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(1,2);</span><br></pre></td></tr></table></figure>

<p>其实主要是用与兼容C语言的不规范写法，因为在C语言中，传参个数可以比函数声明的参数个数还多，比如<code>func(1,2,3,4,5)</code>,会警告但是不会报错，但是C++这么写就会报错，所以为了兼容C语言的调用方式，就用占位参数，占个位但是不用它，这样子就不会报错。</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>同一个作用域，函数名相同，参数个数不同/类型不同/顺序不同</p>
<p><strong>函数的返回值不可以作为函数重载的条件</strong></p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void func() &#123;&#125;</span><br><span class="line">void func(int a) &#123;&#125;</span><br><span class="line">void func(double a) &#123;&#125;</span><br><span class="line">void func(int a, double b) &#123;&#125;</span><br><span class="line">void func(double a, int b) &#123;&#125;</span><br><span class="line">int func() &#123;&#125; &#x2F;&#x2F; 这个会报错</span><br></pre></td></tr></table></figure>

<h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 引用作为重载的条件</span><br><span class="line">void func(int &amp;a) &#123; &#x2F;&#x2F; 方法1</span><br><span class="line">	cout &lt;&lt; &quot;func(int &amp;a)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void func(cont int &amp;a) &#123;  &#x2F;&#x2F; 方法2</span><br><span class="line">	cout &lt;&lt; &quot;func(cont int &amp;a)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a &#x3D; 10;</span><br><span class="line">func(a); &#x2F;&#x2F; 方法1</span><br><span class="line"></span><br><span class="line">func(10); &#x2F;&#x2F; 方法2 因为 const int &amp;a &#x3D; 10; 合法，int &amp;a &#x3D; 10; 不合法</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数重载碰到默认参数</span><br><span class="line">void func2(int a) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;func2(int a)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func2(int a,int b &#x3D; 10) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;func2(int a, int b)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func2(10); &#x2F;&#x2F; 出现歧义（二义性），两个方法都能走，报错，所以建议函数重载的时候不要带默认参数</span><br></pre></td></tr></table></figure>

<h2 id="struct-和-class-的区别"><a href="#struct-和-class-的区别" class="headerlink" title="struct 和 class 的区别"></a>struct 和 class 的区别</h2><p><code>struct</code>默认权限为<code>public</code><br><code>class</code>默认权限为<code>private</code></p>
<h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Person() &#123;</span><br><span class="line">       cout &lt;&lt; &quot;默认构造函数：系统会默认生成&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	Person(int age) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;带参数构造函数，写了这个系统就不生成无参构造函数&quot; &lt;&lt; endl;</span><br><span class="line">		this-&gt;_age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Person(int age) : _height(15) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;初始化部分参数的构造函数&quot; &lt;&lt; endl;</span><br><span class="line">		this-&gt;_age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Person(int age, int height) : _height(height) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;初始化部分参数的构造函数,并且顺便赋值了_height属性&quot; &lt;&lt; endl;</span><br><span class="line">		this-&gt;_age &#x3D; age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Person(const Person &amp;person) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;浅拷贝函数：系统会默认生成&quot; &lt;&lt; endl;</span><br><span class="line">		&#x2F;&#x2F; 如果要深拷贝的话自己手动生成、赋值对象属性。</span><br><span class="line">		&#x2F;&#x2F;如果自己写拷贝构造函数的话，系统不提供其他普通构造函数（有&#x2F;无参）</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	~Person() &#123;</span><br><span class="line">       cout&lt;&lt;&quot;析构函数：系统默认生成&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;int age; &#x2F;&#x2F; 不建议使用跟形参同名的成员变量</span><br><span class="line">	int _age; &#x2F;&#x2F; 带个下划线吧</span><br><span class="line">	int _height;</span><br><span class="line">	SomeClass property; &#x2F;&#x2F; 别的类的属性：构造时会优先进入该类构造函数，析构时会优先进入Person的析构函数，再走这个类的析构函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	Person p1; &#x2F;&#x2F; 这样子就实例化了</span><br><span class="line">	Person p2(11); &#x2F;&#x2F; age &#x3D; 11</span><br><span class="line">	Person p3(11,160); &#x2F;&#x2F; age &#x3D; 11 height &#x3D; 160</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式调用函数"><a href="#链式调用函数" class="headerlink" title="链式调用函数"></a>链式调用函数</h2><p>在上面的Person类内加多这么一个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person&amp; addAge(Person &amp;p) &#123;</span><br><span class="line">	this-&gt;_age +&#x3D; p._Age;</span><br><span class="line">	return *this; &#x2F;&#x2F; 返回当前对象指针！！！</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person pp(20);</span><br><span class="line">Person pp2(10);</span><br><span class="line">pp.addAge(pp2).addAge(pp2).addAge(pp2); &#x2F;&#x2F; 爽快地链式调用</span><br></pre></td></tr></table></figure>

<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	static void func() &#123;</span><br><span class="line">		cout &lt;&lt; &quot;静态方法只能访问静态常量&quot; &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	static int test;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	Person p;</span><br><span class="line">	p.func(); &#x2F;&#x2F; 可以这么调</span><br><span class="line">	Person::func(); &#x2F;&#x2F; 也可以通过类名直接调</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常函数和常对象"><a href="#常函数和常对象" class="headerlink" title="常函数和常对象"></a>常函数和常对象</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">	void funcA() const &#123;</span><br><span class="line">&#x2F;&#x2F;		this-&gt;_name &#x3D; &quot;test&quot;;  常函数不可以访问普通成员属性</span><br><span class="line">		this-&gt;_age &#x3D; 1; &#x2F;&#x2F;常函数可以访问被mutable修饰的成员属性</span><br><span class="line">	&#125;</span><br><span class="line">	string _name;</span><br><span class="line">	mutable int _age;</span><br><span class="line">	</span><br><span class="line">	void funcB() &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	const Person p;</span><br><span class="line">&#x2F;&#x2F;	p.funcB(); &#x2F;&#x2F; 常对象不能访问普通函数</span><br><span class="line">	p.funcA(); &#x2F;&#x2F; 常对象只能访问常函数</span><br><span class="line">	reutrn 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在类外部实现函数"><a href="#在类外部实现函数" class="headerlink" title="在类外部实现函数"></a>在类外部实现函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public: &#x2F;&#x2F; 需要是public函数才可以这么玩</span><br><span class="line">	Person(); &#x2F;&#x2F; 要在外部实现的都得事先声明</span><br><span class="line">	void test();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person::Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Person::test() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>友元函数可以访问被<code>private</code>修饰的属性</p>
<h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Building &#123;</span><br><span class="line">    &#x2F;&#x2F; 友元函数 可以访问私有属性</span><br><span class="line">    friend void visitor(Building &amp;building);</span><br><span class="line">public:</span><br><span class="line">    Building() &#123;</span><br><span class="line">        m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class="line">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_SittingRoom;</span><br><span class="line">private:</span><br><span class="line">    string m_Bedroom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void visitor(Building &amp;building) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_SittingRoom &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_Bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>顺带一提：如果入参是引用的话（<code>&amp;building</code>）,那么可以直接通过点语法访问成员属性，如果入参是指针的话（<code>*building</code>），那么就通过<code>-&gt;</code>访问，如（building-&gt;m_Bedroom）</p>
</blockquote>
<blockquote>
<p>顺带再提，两种函数声明和调用方式的不同</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void visitor(Building &amp;building) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building.m_SittingRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void visitor2(Building *building) &#123;</span><br><span class="line">    cout &lt;&lt; &quot;全局函数&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    </span><br><span class="line">    Building building;  &#x2F;&#x2F; 生成对象</span><br><span class="line">    visitor(building);  &#x2F;&#x2F; 直接传对象</span><br><span class="line">    visitor2(&amp;building); &#x2F;&#x2F; 传对象地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Building &#123;</span><br><span class="line">    friend class Visitor; &#x2F;&#x2F; 这个类下的所有函数都可以访问它的私有属性</span><br><span class="line">public:</span><br><span class="line">    Building() &#123;</span><br><span class="line">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    string m_Bedroom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Visitor</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	Visitor() &#123;</span><br><span class="line">		building &#x3D; new Building;</span><br><span class="line">	&#125;</span><br><span class="line">	void visit();</span><br><span class="line">	Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Visitor::visit() &#123;</span><br><span class="line">	cout &lt;&lt; building-&gt;m_Bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	Visitor v;</span><br><span class="line">	v.visit();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="成员函数做友元函数"><a href="#成员函数做友元函数" class="headerlink" title="成员函数做友元函数"></a>成员函数做友元函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class Visitor</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Visitor();</span><br><span class="line">    void visit();</span><br><span class="line">    Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Building &#123;</span><br><span class="line">    friend void Visitor::visit(); &#x2F;&#x2F; 指定Visitor的visit成员函数可以访问私有属性</span><br><span class="line">public:</span><br><span class="line">    Building() &#123;</span><br><span class="line">        m_Bedroom &#x3D; &quot;卧室&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    string m_Bedroom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为什么这个构造函数要写外面，不能写里面？</span><br><span class="line">&#x2F;&#x2F; 因为Visitor需要在Building上面定义，不然不给定义Visitor上的友元函数，然后因为Visitor内有Building的属性，所以要声明一下class Building; 但是因为只是声明没有实现，所以就不能new Building;了，那就只能把这个通过类外实现的方式写在Building定义的下面。</span><br><span class="line">Visitor::Visitor() &#123;  </span><br><span class="line">    building &#x3D; new Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Visitor::visit() &#123;</span><br><span class="line">    cout &lt;&lt; building-&gt;m_Bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Visitor v;</span><br><span class="line">    v.visit();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>跟Swift差不多</p>
<h3 id="成员函数的运算符重载"><a href="#成员函数的运算符重载" class="headerlink" title="成员函数的运算符重载"></a>成员函数的运算符重载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    Animal operator + (Animal &amp;a) &#123;</span><br><span class="line">        Animal temp;</span><br><span class="line">        temp.m_A &#x3D; this -&gt; m_A + a.m_A;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125;</span><br><span class="line">    int m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal a;</span><br><span class="line">a.m_A &#x3D; 1;</span><br><span class="line">Animal b;</span><br><span class="line">b.m_A &#x3D; 2;</span><br><span class="line">Animal c &#x3D; a + b;</span><br><span class="line">cout &lt;&lt; c.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 3</span><br></pre></td></tr></table></figure>

<p>本质：<code>Animal c = a.operator+(b);</code></p>
<h3 id="全局函数的运算符重载"><a href="#全局函数的运算符重载" class="headerlink" title="全局函数的运算符重载"></a>全局函数的运算符重载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Animal operator - (Animal &amp;a, Animal &amp;b) &#123;</span><br><span class="line">    Animal temp;</span><br><span class="line">    temp.m_A &#x3D; a.m_A - b.m_A;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal a;</span><br><span class="line">a.m_A &#x3D; 1;</span><br><span class="line">Animal b;</span><br><span class="line">b.m_A &#x3D; 2;</span><br><span class="line">Animal c &#x3D; a - b;</span><br><span class="line">cout &lt;&lt; c.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 -1</span><br></pre></td></tr></table></figure>

<p>本质：<code>Animal c = operator-(a,b);</code></p>
<h3 id="运算符重载也可以发生函数重载"><a href="#运算符重载也可以发生函数重载" class="headerlink" title="运算符重载也可以发生函数重载"></a>运算符重载也可以发生函数重载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Animal operator + (int a, Animal &amp;b) &#123;</span><br><span class="line">    Animal temp;</span><br><span class="line">    temp.m_A &#x3D; a + b.m_A;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line">Animal a;</span><br><span class="line">a.m_A &#x3D; 1;</span><br><span class="line">Animal d &#x3D; 10 + a;</span><br><span class="line">cout &lt;&lt; d.m_A &lt;&lt; endl; &#x2F;&#x2F; 输出 11</span><br></pre></td></tr></table></figure>

<p>本质：<code>Animal d = operator+(10,a);</code></p>
<h3 id="左移运算符重载（比较常见输出对象细节）"><a href="#左移运算符重载（比较常见输出对象细节）" class="headerlink" title="左移运算符重载（比较常见输出对象细节）"></a>左移运算符重载（比较常见输出对象细节）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyInteger &#123;</span><br><span class="line">    friend ostream&amp; operator&lt;&lt;(ostream&amp; cout,MyInteger myInt);</span><br><span class="line">public:</span><br><span class="line">    MyInteger() &#123;</span><br><span class="line">        this-&gt;my_int &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    int my_int;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 必须是全局函数重载 ostream是cout的类型，为了能链式调用所以返回引用ostream&amp;</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; cout,MyInteger myInt) &#123;</span><br><span class="line">    cout &lt;&lt; myInt.my_int; &#x2F;&#x2F; 返回对象细节</span><br><span class="line">    return cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyInteger myInt;</span><br><span class="line">    cout &lt;&lt; myInt &lt;&lt; endl; &#x2F;&#x2F; 输出 my_int 的值 0</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><p>Swift经常使用，参见<code>Equable</code>，<code>Comparable</code>协议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    bool operator&#x3D;&#x3D;(Person &amp;p) &#123;</span><br><span class="line">        if (this-&gt;m_Name &#x3D;&#x3D; p.m_Name) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator!&#x3D;(Person &amp;p) &#123;</span><br><span class="line">        if (this-&gt;m_Name !&#x3D; p.m_Name) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	Person p1; p1.m_Name &#x3D; &quot;A&quot;;</span><br><span class="line">    Person p2; p2.m_Name &#x3D; &quot;A&quot;;</span><br><span class="line">    if (p1 &#x3D;&#x3D; p2) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Equal&quot; &lt;&lt; endl; &#x2F;&#x2F; 输出</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Different&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (p1 !&#x3D; p2) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Different&quot; &lt;&lt; endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Equal&quot; &lt;&lt; endl; &#x2F;&#x2F; 输出</span><br><span class="line">    &#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数调用运算符的重载（骚操作）"><a href="#函数调用运算符的重载（骚操作）" class="headerlink" title="函数调用运算符的重载（骚操作）"></a>函数调用运算符的重载（骚操作）</h3><p>因为用起来很像函数，所以又叫做仿函数，STL里相当多这种骚操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyInteger &#123;</span><br><span class="line">	int operator()(int a,int b) &#123;</span><br><span class="line">        return a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    &#x2F;&#x2F; MyInteger() ：匿名对象</span><br><span class="line">    int result &#x3D; MyInteger()(1,2);</span><br><span class="line"></span><br><span class="line">    MyInteger i;</span><br><span class="line">    int result2 &#x3D; i(5,2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;  &#x2F;&#x2F; 5</span><br><span class="line">    cout &lt;&lt; result2 &lt;&lt; endl; &#x2F;&#x2F; 7</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>C++有多继承，灰常厉害</p>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>三种继承方式<code>public</code>,<code>protected</code>,<code>private</code>，决定着继承下来的属性和方法以什么形式修饰，<code>class</code>默认<code>private</code>,<code>struct</code>默认<code>public</code>（没错，C++中结构体可以被继承）<br>父类的所有非静态属性会被继承，包括<code>private</code>类型的，但是<code>private</code>类型的默认隐藏，子类无法访问。</p>
<p>继承语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SubClass : public SuperClass &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h3><p>父类先构造，子类先析构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">superClass()</span><br><span class="line">subClass()</span><br><span class="line">~subClass()</span><br><span class="line">~superClass()</span><br></pre></td></tr></table></figure>

<h3 id="同名属性-函数-静态属性-静态函数的访问"><a href="#同名属性-函数-静态属性-静态函数的访问" class="headerlink" title="同名属性/函数/静态属性/静态函数的访问"></a>同名属性/函数/静态属性/静态函数的访问</h3><p>假如子类和父类拥有相同的名字的属性/函数/静态属性/静态函数，则直接调用子类对象的话都是访问子类的，如果要访问父类的话要添加作用域。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    int _a &#x3D; 1;</span><br><span class="line">    static int _b;</span><br><span class="line">    static void staticFunc() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base staticFunc()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Func() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Base Func()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int Base::_b &#x3D; 10; &#x2F;&#x2F; 静态成员变量要在外面赋值</span><br><span class="line"></span><br><span class="line">class Sub1 : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    int _a &#x3D; 2;</span><br><span class="line">    static int _b;</span><br><span class="line">    static void staticFunc() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;SubClass staticFunc()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void Func() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;SucClass Func()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int Sub1::_b &#x3D; 20;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    Sub1 s;</span><br><span class="line">    &#x2F;&#x2F; 直接调用</span><br><span class="line">    cout &lt;&lt; s._a &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; 调用父类的</span><br><span class="line">    cout &lt;&lt; s.Base::_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 静态直接调用</span><br><span class="line">    cout &lt;&lt; s._b &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; 静态调用父类的</span><br><span class="line">    cout &lt;&lt; s.Base::_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 静态直接调用</span><br><span class="line">    cout &lt;&lt; Sub1::_b &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F; 静态调用父类的</span><br><span class="line">    cout &lt;&lt; Sub1::Base::_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 直接调用</span><br><span class="line">    s.Func();</span><br><span class="line">    &#x2F;&#x2F; 调用父类的</span><br><span class="line">    s.Base::Func();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 静态直接调用</span><br><span class="line">    s.staticFunc();</span><br><span class="line">    &#x2F;&#x2F; 静态调用父类的</span><br><span class="line">    s.Base::staticFunc();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 静态直接调用</span><br><span class="line">    Sub1::staticFunc();</span><br><span class="line">    &#x2F;&#x2F; 静态调用父类的</span><br><span class="line">    Sub1::Base::staticFunc();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>不建议使用，因为麻烦事多</p>
<p>语法：(参照上面的代码)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Other &#123;</span><br><span class="line">public:</span><br><span class="line">    void Func() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Ohter Func()&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;...略</span><br><span class="line">class Sub1 : public Base , public Other &#123;</span><br><span class="line">&#x2F;&#x2F;...略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当多个父类中出现同名属性/方法时，需要加作用域指定父类<code>s.Base::Func(); / s.Other::Func();</code></p>
<h3 id="菱形继承（钻石继承）"><a href="#菱形继承（钻石继承）" class="headerlink" title="菱形继承（钻石继承）"></a>菱形继承（钻石继承）</h3><p>两个子类继承同一个基类，<br>又有某个类同时继承着两个子类</p>
<p>举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Base &#123; int age &#125;;</span><br><span class="line"></span><br><span class="line">class Sub1: public Base &#123;&#125;;</span><br><span class="line">class Sub2: public Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">class SubSub: public Sub1, public Sub2 &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这时候SubSub会有两个父类，有两份 age 属性，造成资源浪费</p>
<p>这时候用虚继承(<code>virtual</code>)解决问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Base &#123; public: int age &#125;; &#x2F;&#x2F; 这时候成为虚基类</span><br><span class="line"></span><br><span class="line">class Sub1: virtual public Base &#123;&#125;;</span><br><span class="line">class Sub2: virtual public Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">class SubSub: public Sub1, public Sub2 &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>这时候age属性成为共享属性，最后谁改了就是谁的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SubSub s;</span><br><span class="line">s.Sub1::age &#x3D; 1;</span><br><span class="line">s.Sub2::age &#x3D; 10;</span><br><span class="line">cout &lt;&lt; s.Sub1::age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br><span class="line">cout &lt;&lt; s.Sub2::age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br><span class="line">cout &lt;&lt; s.age &lt;&lt; endl; &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>C++中，多态分两类</p>
<p>静态多态：函数重载和运算符重载属于静态多态，复用函数名<br>动态多态：子类和虚函数实现运行时多态</p>
<p>区别：</p>
<p>静态多态的函数地址早绑定，编译阶段确定函数地址<br>动态多态的函数地址晚绑定，运行阶段确定函数地址</p>
<p>动态多态满足条件：</p>
<ol>
<li>有继承关系</li>
<li>子类重写父类虚函数</li>
</ol>
<p>动态多态使用<br>父类的指针或者引用指向子类对象</p>
<p>静态多态举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    void speak() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Animal Speak&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Cat: public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void speak() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;Cat Speak&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void SomeoneSpeak(Animal &amp;animal) &#123;</span><br><span class="line">    animal.speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Cat c;</span><br><span class="line">    SomeoneSpeak(c); &#x2F;&#x2F; 由于SomeoneSpeak(Animal &amp;animal)，编译期间已经确定入参类型，所以输出 Animal Speak</span><br></pre></td></tr></table></figure>

<p>如果想输出<code>Cat Speak</code>，只需进行如下修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void speak() &#123; &#x2F;&#x2F; 虚函数，可以告知由于SomeoneSpeak(Animal &amp;animal)运行时再确定入参类型</span><br><span class="line">        cout &lt;&lt; &quot;Animal Speak&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>经常地，这种情况下也是动态多态，最后会输出<code>Cat Speak</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Animal *a &#x3D; new Cat;</span><br><span class="line">a-&gt;speak();</span><br></pre></td></tr></table></figure>

<h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>父类的虚函数的实现没什么意义，所以上面的虚函数代码改写为<code>纯虚函数</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtual void speak() &#x3D; 0;</span><br></pre></td></tr></table></figure>

<p>当类中有了纯虚函数，则这个类称为<code>抽象类</code></p>
<p>抽象类<strong>无法实例化对象</strong>，并且<strong>子类必须重写父类的纯虚函数</strong>，否则也成为<code>抽象类</code></p>
<h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>当子类在堆区创建数据的时候，需要手动释放，父类需要添加虚析构或者纯虚析构函数，否则子类可能不走析构函数</p>
<p>比如上面的<code>Animate</code>父类，我们补充一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ~Animal() &#x3D; 0; &#x2F;&#x2F; 纯虚析构</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~Animal() &#123; &#x2F;&#x2F; 析构实现</span><br><span class="line">    cout &lt;&lt; &quot;Animal is Delete&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>文件打开方式</p>
<p><code>ios::in</code>:读文件<br><code>ios::out</code>:写文件<br><code>ios::ate</code>:初始位置，文件尾<br><code>ios:app</code>:追加写文件<br><code>ios:trunc</code>:如果文件存在先删除，再创建<br><code>ios:binary</code>:二进制方式</p>
<p>同时两种方式则使用<code>|</code>的方式，比如<code>ios::in|ios:binary</code></p>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ofstream stream;</span><br><span class="line"></span><br><span class="line">stream.open(&quot;Test.txt&quot;,ios::out);</span><br><span class="line"></span><br><span class="line">stream &lt;&lt; &quot;Line 1&quot; &lt;&lt; endl;</span><br><span class="line">stream &lt;&lt; &quot;Line 2&quot; &lt;&lt; endl;</span><br><span class="line">stream &lt;&lt; &quot;Line 3&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">stream.close();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(&quot;Test.txt&quot;,ios::out);</span><br><span class="line"></span><br><span class="line">if(!ifs.is_open()) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;打开文件失败&quot; &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string buf;</span><br><span class="line">while (getline(ifs, buf)) &#123; &#x2F;&#x2F; 一行行读取</span><br><span class="line">	cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.close();</span><br></pre></td></tr></table></figure>

<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h3 id="构建类模板与类模板做参数"><a href="#构建类模板与类模板做参数" class="headerlink" title="构建类模板与类模板做参数"></a>构建类模板与类模板做参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class NameType,class AgeType&gt;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    Person(NameType name, AgeType age) &#123;</span><br><span class="line">        this-&gt;_age &#x3D; age;</span><br><span class="line">        this-&gt;_name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    AgeType _age;</span><br><span class="line">    NameType _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 不会自动类型推导，需要自己显式声明类型</span><br><span class="line">    Person&lt;string,int&gt; p(&quot;Haha&quot;,123);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; p._name &lt;&lt; &quot; &quot; &lt;&lt; p._age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以给类模板添加默认类型</p>
<p><code>template&lt;class NameType,class AgeType = int&gt;</code></p>
<p>这样子调用的时候就可以不全声明类型了</p>
<p><code>Person&lt;string&gt; p(&quot;Haha&quot;,123);</code></p>
<p>类模板做参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 指定类型的类模板做参数</span><br><span class="line">void print(Person&lt;string,int&gt; &amp;p) &#123;</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模板化参数的类模板做参数</span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">void print2(Person&lt;T1, T2&gt; &amp;p) &#123;</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 模板化类做参数</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void print3(T &amp;p) &#123;</span><br><span class="line">    p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Person&lt;string,int&gt; p(&quot;Haha&quot;,123);</span><br><span class="line">    print(p);</span><br><span class="line">    print2(p);</span><br><span class="line">    print3(p);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h3><p>继承时需要指定类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SubClass: public Base&lt;int&gt; &#123; &#x2F;&#x2F; 指定T的类型</span><br><span class="line">public:</span><br><span class="line">    void print() &#123;</span><br><span class="line">        cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果不想指定类型，那么可以模板化子类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class SubClass: public Base&lt;T1&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    SubClass(T1 a, T2 b) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    T2 k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	SubClass&lt;string, int&gt; c(&quot;String&quot;,1);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="STL-之-Vector容器"><a href="#STL-之-Vector容器" class="headerlink" title="STL 之 Vector容器"></a>STL 之 Vector容器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v1; &#x2F;&#x2F; 初始化指定容器内元素类型</span><br><span class="line">v1.assign(10, 1); &#x2F;&#x2F; 插入10个1，也可以传入其他vector,比如v1.assign(v0.begin,v0.end); 或者直接 v1 &#x3D; v0; 只要保证是同种类型就好</span><br><span class="line">for (vector&lt;int&gt;::iterator i &#x3D; v1.begin(); i !&#x3D; v1.end() ; i++) &#123;</span><br><span class="line">	cout &lt;&lt; *i &lt;&lt; endl;</span><br><span class="line">&#125; &#x2F;&#x2F; 打印10个1</span><br><span class="line">cout &lt;&lt; &quot;Size &#x3D; &quot; &lt;&lt; v1.size() &lt;&lt; endl; &#x2F;&#x2F; 长度 10</span><br><span class="line">cout &lt;&lt; &quot;isEmpty &#x3D; &quot; &lt;&lt; v1.empty() &lt;&lt; endl; &#x2F;&#x2F; 判空 0</span><br><span class="line">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 容量 10</span><br><span class="line">v1.resize(20,20); &#x2F;&#x2F; 调整容量为20，多出来的位置用20填充，这里的20可以不传，默认0</span><br><span class="line">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 现在容量变成20</span><br><span class="line"></span><br><span class="line">v1.pop_back(); &#x2F;&#x2F; 删除最后一个元素</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;Size &#x3D; &quot; &lt;&lt; v1.size() &lt;&lt; endl; &#x2F;&#x2F; 长度 19</span><br><span class="line">cout &lt;&lt; &quot;capacity &#x3D; &quot; &lt;&lt; v1.capacity() &lt;&lt; endl; &#x2F;&#x2F; 容量不变 20</span><br><span class="line"></span><br><span class="line">v1.insert(v1.begin() + 1, 199); &#x2F;&#x2F; 下标为1的位置插入元素199</span><br><span class="line">v1.insert(v1.begin() + 1, 2, 199); &#x2F;&#x2F; 下标为1的位置插入两个元素199</span><br><span class="line">v1.erase(v1.begin() + 2); &#x2F;&#x2F; 删除第二个元素</span><br><span class="line">v1.erase(v1.begin() + 2 , v1.begin() + 3); &#x2F;&#x2F; 删除第二个到第三个元素</span><br><span class="line">v1.clear(); &#x2F;&#x2F; 清空容器</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;第二个元素是&quot; &lt;&lt; v1.at(1) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;第三个元素是&quot; &lt;&lt; v1[2] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;第一个元素&quot; &lt;&lt; v1.front() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;最后一个元素&quot; &lt;&lt; v1.back() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v1.reverse(100000); &#x2F;&#x2F; 预留空间，减少以后动态拓展的次数</span><br><span class="line"></span><br><span class="line">v1.swap(v0); &#x2F;&#x2F; 交换元素，假如v1的预留空间很大，可以通过交换一个小预留空间的容器达到压缩内存的效果</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>AppDelegate事件分发</title>
    <url>/post/7e5c9fa9.html</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>当App发展庞大的时候，势必会导致AppDelegate类的庞大，所以如何去优化AppDelegate成为组件化工作中的主要部分之一。</p>
<span id="more"></span>

<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>举个例子，比如App中拥有</p>
<ol>
<li>用户管理组件</li>
<li>首页组件</li>
<li>消息组件</li>
</ol>
<p>那么他们分别需要在<code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>中实现</p>
<ol>
<li>访问接口更新用户信息</li>
<li>配置首页弹窗</li>
<li>访问接口获取用户未读消息数</li>
</ol>
<p>假设这三个事件之间无关联，只是在初始化自己的模块后做准备工作，但是同时他们堆叠在同一个方法内，必然会导致方法臃肿。设想另外一个场景，假如开发者A只负责维护AppDelegate及主工程项目，开发者B只负责维护用户管理组件，那么开发者B要在App初始化的时候，再加入一个<code>将用户信息传到大数据中心统计</code>的功能，那么由于他不拥有<code>AppDelegate</code>的修改权限，只能让A排期去协助工作，同理可得，当组件变多，团队庞大的时候，开发者A将会有很多协助工作要做，这就是这次要讨论的问题。</p>
<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>是否可以将组件的初始化安排到组件内部中，而不在AppDelegate类中直接进行维护呢？</p>
<p>想法1. 组件新增一个类，然后在该类里面进行初始化。AppDelegate import 这个类，调用这个类中的方法。</p>
<p>缺点：AppDelegate需要耦合该组件，如果要去掉该组件或者新增别的组件，AppDelegate需要增加维护成本。</p>
<p>想法2. AppDelegate主动分发事件，用通知的形式分发给每个组件消息。</p>
<p>缺点：由于组件无法依赖主工程，所以通知名无法维护，另外通知会分发到不需要在AppDelgate初始化的组件，属于通知滥用。</p>
<p>想法3. AppDelegate主动分发事件，组件新增一个类，将AppDelegate事件通过协议的方式分发到这个类中，类遵循该协议。</p>
<p>缺点：技术上不可行，无法得知哪些类实现了协议。</p>
<p>想法4. 组件新增一个类，在<code>+ (void)load</code>中将类名注册进入管理类，AppDelegate执行的时候取出所有类名，进行实例化和事件分发。</p>
<p>缺点：在<code>+ (void)load</code>中进行工作会增加App启动耗时</p>
<p>想法5. 组件新增一个类，在主工程维护一个plist，将类名写进该plist，AppDelegate执行的时候取出所有类名，进行实例化和事件分发。</p>
<p>缺点：plist在主工程，同样无法满足无缝对接的需求，A同事仍然需要对接维护。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>目前能得出的最优解决方案：</p>
<p>将类名注入mach-o文件中，在编译期写入，在AppDelegate事件分发的时候取出并实例化，不占用App启动耗时，也不用维护多一个plist文件。</p>
<h2 id="试验"><a href="#试验" class="headerlink" title="试验"></a>试验</h2><ol>
<li><p>新建 MacOS - Command Line Tool 项目，命名为<code>TestC</code></p>
</li>
<li><p>加入我们想注入字符串<code>ModuleAModule</code>,将其存储在名为<code>TestModes</code>的section内，那么在main.m中写如下代码：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char * kModuleAModule_mod __attribute((used, section(&quot;__DATA, &quot;&quot;TestModes&quot;&quot; &quot;))) &#x3D; &quot;&quot;&quot;ModuleAModule&quot;&quot;&quot;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">	&#x2F;&#x2F; insert code here...</span><br><span class="line">	printf(&quot;Hello, World!\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>输出这个mach-o文件的所有segment和section<code>otool -l TestC</code></p>
<p> 部分结果：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Section</span><br><span class="line">  sectname TestModes</span><br><span class="line">   segname __DATA</span><br><span class="line">	  addr 0x0000000100002008</span><br><span class="line">	  size 0x0000000000000008</span><br><span class="line">	offset 8200</span><br><span class="line">	 align 2^3 (8)</span><br><span class="line">	reloff 0</span><br><span class="line">	nreloc 0</span><br><span class="line">	 flags 0x00000000</span><br><span class="line"> reserved1 0</span><br><span class="line"> reserved2 0</span><br></pre></td></tr></table></figure>
<p> 看到了<code>Test Modes</code>了，继续看一下section的内容<code>otool -s __DATA TestModes TestC</code></p>
<p> 结果</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	TestC:</span><br><span class="line">Contents of (__DATA,TestModes) section</span><br><span class="line">0000000100002008	92 0f 00 00 01 00 00 00 </span><br></pre></td></tr></table></figure>
<p> 发现<code>0000000100002008</code>这个地址可能是我们要的东西，再看看这个地址里有啥<br> <code>otool -V -s __TEXT __cstring TestC </code>打印所有字符串数据内容<br> 看到了</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Contents of (__TEXT,__cstring) section</span><br><span class="line">	0000000100000f92  ModuleAModule</span><br><span class="line">	0000000100000fa0  Hello, World!\n</span><br></pre></td></tr></table></figure>
<p> 找到了我们想注入的类名<code>ModuleAModule</code><br> 这样，类名就被存储在mach-o文件的section中了。</p>
</li>
<li><p>取出类名， 代码如下</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSArray&lt;NSString *&gt;* readConfiguration(char *sectionName,const struct mach_header *mhp)</span><br><span class="line">&#123;</span><br><span class="line">	NSMutableArray *configs &#x3D; [NSMutableArray array];</span><br><span class="line">	unsigned long size &#x3D; 0;</span><br><span class="line">#ifndef __LP64__</span><br><span class="line">	uintptr_t *memory &#x3D; (uintptr_t*)getsectiondata(mhp, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#else</span><br><span class="line">	const struct mach_header_64 *mhp64 &#x3D; (const struct mach_header_64 *)mhp;</span><br><span class="line">	uintptr_t *memory &#x3D; (uintptr_t*)getsectiondata(mhp64, SEG_DATA, sectionName, &amp;size);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	unsigned long counter &#x3D; size&#x2F;sizeof(void*);</span><br><span class="line">	for(int idx &#x3D; 0; idx &lt; counter; ++idx)&#123;</span><br><span class="line">		char *string &#x3D; (char*)memory[idx];</span><br><span class="line">		NSString *str &#x3D; [NSString stringWithUTF8String:string];</span><br><span class="line">		if(!str)continue;</span><br><span class="line">		if(str) [configs addObject:str];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return configs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void dyld_callback(const struct mach_header *mhp, intptr_t vmaddr_slide)</span><br><span class="line">&#123;</span><br><span class="line">	NSArray *mods &#x3D; readConfiguration(&quot;TestModes&quot;, mhp);</span><br><span class="line">	for (NSString *modName in mods) &#123;</span><br><span class="line">		if (modName) &#123;</span><br><span class="line">			NSLog(@&quot;取得：%@&quot;,modName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line">void initProphet() &#123;</span><br><span class="line">	_dyld_register_func_for_add_image(dyld_callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当一个函数被<code>__attribute__((constructor))</code>修饰时，表示这个函数是这个镜像的初始化函数，在镜像被加载时，首先会调用这个函数。（镜像指的是mach-o和动态共享库，在工程运行时，可以使用lldb命令<code>image list</code>查看这个工程中加载的所有镜像。）<br>上述代码表示<code>initProphet</code>函数被指定为mach-o的初始化函数，当dyld（动态链接器）加载mach-o时，执行<code>initProphet</code>函数，其执行时机在main函数和类的load方法之前。</p>
<p> 当<code>_dyld_register_func_for_add_image(dyld_callback);</code>被执行时，如果已经加载了镜像，则每存在一个已经加载的镜像就执行一次<code>dyld_callback</code>函数，在此之后，每当有一个新的镜像被加载时，也会执行一次<code>dyld_callback</code>函数。<br>（<code>dyld_callback</code>函数在镜像的初始化函数之前被调用，mach-o是第一个被加载的镜像，调用顺序是：<code>load mach-o -&gt; initProphet -&gt; dyld_callback -&gt; load other_image -&gt; dyld_callback -&gt; other_image_initializers -&gt; ......</code>）</p>
<p> 所以，当程序启动时，会多次调用dyld_callback函数。<br> 在dyld_callback函数中，使用下列函数来获取[步骤2]中存储的类名</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extern uint8_t *getsectiondata(</span><br><span class="line">   const struct mach_header_64 *mhp,</span><br><span class="line">   const char *segname,</span><br><span class="line">   const char *sectname,</span><br><span class="line">   unsigned long *size);</span><br></pre></td></tr></table></figure>
<p> segname的值为<code>__DATA</code>，sectname的值为<code>TestMods</code></p>
</li>
</ol>
<h2 id="封装组件"><a href="#封装组件" class="headerlink" title="封装组件"></a>封装组件</h2><p>有了上面的指导思想，那么我们就可以封装组件了，具体内容见<a href="https://github.com/Arc-lin/ALComponentManager">ALComponentManager</a></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="AppDelegate继承自ALAppDelegate"><a href="#AppDelegate继承自ALAppDelegate" class="headerlink" title="AppDelegate继承自ALAppDelegate"></a>AppDelegate继承自ALAppDelegate</h4><p>只需要在实现<code>UIApplicationDelegate</code>的方法内部调用super方法即可，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [super application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillResignActive:(UIApplication *)application</span><br><span class="line">&#123;</span><br><span class="line">    [super applicationWillResignActive:application];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="AppDelegate继承自UIResponder"><a href="#AppDelegate继承自UIResponder" class="headerlink" title="AppDelegate继承自UIResponder"></a>AppDelegate继承自UIResponder</h4><p>在AppDelegate的各个方法做分发埋点，触发到埋点后事件会分发到各个组件类里面</p>
<p>如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions;</span><br></pre></td></tr></table></figure>
<p>埋点如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">  &#123;</span><br><span class="line">      [[ALComponentManager sharedManager] triggerEvent:ALSetupEvent];</span><br><span class="line">      [[ALComponentManager sharedManager] triggerEvent:ALInitEvent];</span><br><span class="line"></span><br><span class="line">      dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          [[ALComponentManager sharedManager] triggerEvent:ALSplashEvent];</span><br><span class="line">      &#125;);</span><br><span class="line">  #if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;&#x3D; 100000</span><br><span class="line">      if ([UIDevice currentDevice].systemVersion.floatValue &gt;&#x3D; 10.0f) &#123;</span><br><span class="line">          [UNUserNotificationCenter currentNotificationCenter].delegate &#x3D; self;</span><br><span class="line">      &#125;</span><br><span class="line">  #endif</span><br><span class="line">      return YES;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其他埋点见组件Demo</p>
<h4 id="给每个组件创建组件管理类"><a href="#给每个组件创建组件管理类" class="headerlink" title="给每个组件创建组件管理类"></a>给每个组件创建组件管理类</h4><ol>
<li><p>给每个组件创建一个类并写上注解，如<code>ALComponentA.m</code></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ALMod(ALComponentA);</span><br><span class="line">@interface ALComponentA()&lt;ALComponentProtocol&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ALComponentA</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现协议<code>ALComponentProtocol</code>和需要的协议方法。<br> 这个协议里面蕴含了基本所有的<code>AppDelegate</code>方法，当然要触发这些方法都是要预先在AppDelegate写上埋点。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation ALComponentA</span><br><span class="line"></span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">	NSLog(@&quot;Component A Load&quot;);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">	if (self &#x3D; [super init]) &#123;</span><br><span class="line">		NSLog(@&quot;ComponentA Init&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)modSetUp:(ALContext *)context</span><br><span class="line">&#123;</span><br><span class="line">	NSLog(@&quot;ComponentA setup&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来你就可以尝试使用了。</p>
</li>
</ol>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>要是组件间的初始化互相依赖怎么办？</p>
<p>还能怎么办，已经违背了组件隔离的原则，就只能按原来的方法处理了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/alibaba/BeeHive">BeeHive</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>DKLogger--iOS日志管理框架</title>
    <url>/post/abce56f1.html</url>
    <content><![CDATA[<p>用于管理iOS的Log信息的框架</p>
<span id="more"></span>
<p>可以用在平时的调试中,另外如果app在用户使用过程中发生一些意外事件或者程序崩溃事件,那我们也可以通过服务器的文件得知问题所在</p>
<p>特性</p>
<ul>
<li>支持四个Log等级 <code>DEBUG</code>,<code>INFO</code>,<code>WARN</code>,<code>ERROR</code></li>
<li>支持储存Log文件到本地和上传到服务器</li>
<li>支持自定义打印Log类型和写入Log类型</li>
<li>支持捕获&amp;发送崩溃信息</li>
<li>在界面长按2秒可以查看Log信息</li>
<li>可以获取用户的在App内的查看轨迹(进入了哪些控制器)</li>
<li>崩溃的时候重启RunLoop,进入ANR状态,不闪退</li>
<li>支持服务器端同步显示Log信息(建议搭建本地服务器,因为这样子Log发送快)</li>
</ul>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DKLog(@&quot;...&quot;); 普通log</span><br><span class="line">DKInfoLog(@&quot;...&quot;); 包含特殊信息的log</span><br><span class="line">DKWRANLog(@&quot;...&quot;); 警告log</span><br><span class="line">DKERRLog(@&quot;...&quot;); 错误log</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**	</span><br><span class="line"> 初始化: 创建Txt的Log文件并写入输出</span><br><span class="line"> </span><br><span class="line"> @param path  文件夹路径,默认Documents</span><br><span class="line"> @param url   上传log地址 当发生崩溃事故的时候就会提示用户是否上传Log到服务器</span><br><span class="line"> @param debug 调试模式 *&#x2F;</span><br><span class="line">- (void)registerLoggerInPath:(NSString *)path uploadUrlStr:(NSString *)url debug:(BOOL)debug;</span><br><span class="line">eg:</span><br><span class="line">[[DKSharedLogger registerLoggerInPath:[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] uploadUrlStr:@&quot;http:&#x2F;&#x2F;192.168.1.91&#x2F;public&#x2F;index&#x2F;Index&#x2F;hello&quot; debug:YES];</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DKSharedLogger printLevel:DKLoggerLevelInfo|DKLoggerLevelWARN]; 在控制器只打印Info和Warn等级的Log</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DKSharedLogger saveLevel:DKLoggerLevelError|DKLoggerLevelInfo]; 在文件中之写入Info和Error等级的Log</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DK_VAR_DUMP(arr); 查看对象信息,例如变量arr</span><br></pre></td></tr></table></figure>

<p>长按界面2秒弹出log信息界面</p>
<p><img src="https://github.com/Arc-lin/BlogImage/blob/master/1011.png?raw=true"></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Dankal_iOS崩溃信息提交</title>
    <url>/post/afeed214.html</url>
    <content><![CDATA[<p>Dankal_iOS 崩溃信息提交</p>
<span id="more"></span>

<ol>
<li>获取到崩溃信息（异常原因，异常方法，异常类名，堆栈）</li>
<li>获取到本机信息（型号，系统）</li>
<li>保存为 plist到本地</li>
<li>下次启动应用的时候发送信息到服务器(POST发送，记得添加 token 到HEADER)</li>
<li>发送完之后删除掉 plist 文件</li>
</ol>
<hr>
<h2 id="如何捕获崩溃信息"><a href="#如何捕获崩溃信息" class="headerlink" title="如何捕获崩溃信息"></a>如何捕获崩溃信息</h2><p>C 语言捕获</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;libkern&#x2F;OSAtomic.h&gt;</span><br><span class="line">#include &lt;execinfo.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 系统信号截获处理方法</span><br><span class="line">void signalHandler(int signal);</span><br><span class="line">&#x2F;&#x2F; 异常截获处理方法</span><br><span class="line">void exceptionHandler(NSException *exception);</span><br><span class="line">const int32_t _uncaughtExceptionMaximum &#x3D; 20;</span><br><span class="line"></span><br><span class="line">NSString * const UncaughtExceptionHandlerSignalKey &#x3D; @&quot;UncaughtExceptionHandlerSignalKey&quot;;</span><br><span class="line">NSString *const SingalExceptionHandlerAddressesKey &#x3D; @&quot;SingalExceptionHandlerAddressesKey&quot;;</span><br><span class="line">NSString *const ExceptionHandlerAddressesKey &#x3D; @&quot;ExceptionHandlerAddressesKey&quot;;</span><br><span class="line"></span><br><span class="line">void signalHandler(int signal)</span><br><span class="line">&#123;</span><br><span class="line">    volatile int32_t _uncaughtExceptionCount &#x3D; 0;</span><br><span class="line">    int32_t exceptionCount &#x3D; OSAtomicIncrement32(&amp;_uncaughtExceptionCount);</span><br><span class="line">    if (exceptionCount &gt; _uncaughtExceptionMaximum) &#x2F;&#x2F; 如果太多不用处理</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 获取信息</span><br><span class="line">    NSMutableDictionary *userInfo &#x3D;</span><br><span class="line">    [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:signal] forKey:UncaughtExceptionHandlerSignalKey];</span><br><span class="line">    </span><br><span class="line">    NSArray *callStack &#x3D; [DKUncaughtExceptionHandler backtrace];</span><br><span class="line">    [userInfo  setObject:callStack  forKey:SingalExceptionHandlerAddressesKey];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void exceptionHandler(NSException *exception)</span><br><span class="line">&#123;</span><br><span class="line">    volatile int32_t _uncaughtExceptionCount &#x3D; 0;</span><br><span class="line">    int32_t exceptionCount &#x3D; OSAtomicIncrement32(&amp;_uncaughtExceptionCount);</span><br><span class="line">    if (exceptionCount &gt; _uncaughtExceptionMaximum) &#x2F;&#x2F; 如果太多不用处理</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSArray *callStack &#x3D; [DKUncaughtExceptionHandler backtrace];</span><br><span class="line">    NSMutableDictionary *userInfo &#x3D;[NSMutableDictionary dictionaryWithDictionary:[exception userInfo]];</span><br><span class="line">    [userInfo setObject:callStack forKey:ExceptionHandlerAddressesKey];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 保存信息到本地</span><br><span class="line">    NSString *path &#x3D; [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] stringByAppendingPathComponent:@&quot;crash.plist&quot;];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 获取本机信息</span><br><span class="line">    struct utsname systemInfo;</span><br><span class="line">    uname(&amp;systemInfo);</span><br><span class="line">    </span><br><span class="line">    NSDictionary *crashInfo &#x3D; @&#123;@&quot;crash_time&quot;:[NSDate dateStringWithDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;],</span><br><span class="line">                                @&quot;device_type&quot;: [DKUncaughtExceptionHandler deviceVersion:[NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding]],</span><br><span class="line">                                @&quot;device_system&quot;: [UIDevice currentDevice].systemVersion,</span><br><span class="line">                                @&quot;crash_type&quot;:exception.name,</span><br><span class="line">                                @&quot;crash_reason&quot;:exception.reason,</span><br><span class="line">                                @&quot;crash_stack&quot;:userInfo.descriptionInStringsFileFormat&#125;;</span><br><span class="line">    [crashInfo writeToFile:path atomically:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="OC-部分获取调用堆栈和注册崩溃拦截"><a href="#OC-部分获取调用堆栈和注册崩溃拦截" class="headerlink" title="OC 部分获取调用堆栈和注册崩溃拦截"></a>OC 部分获取调用堆栈和注册崩溃拦截</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取调用堆栈</span><br><span class="line">+ (NSArray *)backtrace</span><br><span class="line">&#123;</span><br><span class="line">    void* callstack[128];</span><br><span class="line">    int frames &#x3D; backtrace(callstack, 128);</span><br><span class="line">    char **strs &#x3D; backtrace_symbols(callstack,frames);</span><br><span class="line">    </span><br><span class="line">    NSMutableArray *backtrace &#x3D; [NSMutableArray arrayWithCapacity:frames];</span><br><span class="line">    for (int i&#x3D;0;i&lt;frames;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        [backtrace addObject:[NSString stringWithUTF8String:strs[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    free(strs);</span><br><span class="line">    </span><br><span class="line">    return backtrace;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册崩溃拦截</span><br><span class="line">- (void)installExceptionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSSetUncaughtExceptionHandler(&amp;exceptionHandler);</span><br><span class="line">    signal(SIGHUP, signalHandler);</span><br><span class="line">    signal(SIGINT, signalHandler);</span><br><span class="line">    signal(SIGQUIT, signalHandler);</span><br><span class="line">    </span><br><span class="line">    signal(SIGABRT, signalHandler);</span><br><span class="line">    signal(SIGILL, signalHandler);</span><br><span class="line">    signal(SIGSEGV, signalHandler);</span><br><span class="line">    signal(SIGFPE, signalHandler);</span><br><span class="line">    signal(SIGBUS, signalHandler);</span><br><span class="line">    signal(SIGPIPE, signalHandler);</span><br><span class="line">    </span><br><span class="line">    NSString *path &#x3D; [[NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents&quot;] stringByAppendingPathComponent:@&quot;crash.plist&quot;];</span><br><span class="line">    if([[NSFileManager defaultManager] fileExistsAtPath:path])&#123;</span><br><span class="line">        NSDictionary *params &#x3D; [[NSDictionary alloc] initWithContentsOfFile:path];</span><br><span class="line">        [DKHTTPTool POST:去看 Coding 的Crash Reporter项目说明文档  parameters:params header:@&#123;@&quot;token&quot;:去看 Coding的Crash Reporter项目说明文档&#125; responseBlock:^(DKResponse *response) &#123;</span><br><span class="line">            if (!response.error) &#123;</span><br><span class="line">                NSError *error;</span><br><span class="line">                [[NSFileManager defaultManager] removeItemAtPath:path error:&amp;error];</span><br><span class="line">                if(error)DKLog(@&quot;%@&quot;,error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发送请求的AFN封装方法"><a href="#发送请求的AFN封装方法" class="headerlink" title="发送请求的AFN封装方法"></a>发送请求的AFN封装方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (void)POST:(NSString *)URLString parameters:(id)parameters header:(NSDictionary *)headerField responseBlock:(DKHTTPResponseBlock)block</span><br><span class="line">&#123;</span><br><span class="line">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];</span><br><span class="line">    AFHTTPRequestSerializer *requestSerializer &#x3D;  [AFJSONRequestSerializer serializer];</span><br><span class="line">    [headerField enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        [requestSerializer setValue:obj forHTTPHeaderField:key];</span><br><span class="line">    &#125;];</span><br><span class="line">    mgr.requestSerializer &#x3D; requestSerializer;</span><br><span class="line">    [mgr POST:URLString parameters:parameters  progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject];</span><br><span class="line">        resp.rawData &#x3D; responseObject;</span><br><span class="line">        if(block)&#123;</span><br><span class="line">            block(resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">        DKResponse *resp &#x3D; [[DKResponse alloc] init];</span><br><span class="line">        resp.error &#x3D; error;</span><br><span class="line">        if (block) &#123;</span><br><span class="line">            block(resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125; </span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line"></span><br><span class="line">## 在 AppDelegte内注册</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions<br>{<br>[[[DKUncaughtExceptionHandler alloc] init] installExceptionHandler];<br>  return YES:<br>}<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## iOS设备测试编号转机型</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>(NSString *) deviceVersion:(NSString *)deviceString<br>{<br>  //iPhone<br>  if ([deviceString isEqualToString:@”iPhone1,1”])    return @”iPhone 1G”;<br>  if ([deviceString isEqualToString:@”iPhone1,2”])    return @”iPhone 3G”;<br>  if ([deviceString isEqualToString:@”iPhone2,1”])    return @”iPhone 3GS”;<br>  if ([deviceString isEqualToString:@”iPhone3,1”])    return @”iPhone 4”;<br>  if ([deviceString isEqualToString:@”iPhone3,2”])    return @”Verizon iPhone 4”;<br>  if ([deviceString isEqualToString:@”iPhone4,1”])    return @”iPhone 4S”;<br>  if ([deviceString isEqualToString:@”iPhone5,1”])    return @”iPhone 5”;<br>  if ([deviceString isEqualToString:@”iPhone5,2”])    return @”iPhone 5”;<br>  if ([deviceString isEqualToString:@”iPhone5,3”])    return @”iPhone 5C”;<br>  if ([deviceString isEqualToString:@”iPhone5,4”])    return @”iPhone 5C”;<br>  if ([deviceString isEqualToString:@”iPhone6,1”])    return @”iPhone 5S”;<br>  if ([deviceString isEqualToString:@”iPhone6,2”])    return @”iPhone 5S”;<br>  if ([deviceString isEqualToString:@”iPhone7,1”])    return @”iPhone 6 Plus”;<br>  if ([deviceString isEqualToString:@”iPhone7,2”])    return @”iPhone 6”;<br>  if ([deviceString isEqualToString:@”iPhone8,1”])    return @”iPhone 6s”;<br>  if ([deviceString isEqualToString:@”iPhone8,2”])    return @”iPhone 6s Plus”;<br>  if ([deviceString isEqualToString:@”iPhone8,4”])    return @”iPhone SE”;<br>  if ([deviceString isEqualToString:@”iPhone9,1”])    return @”iPhone 7”;<br>  if ([deviceString isEqualToString:@”iPhone9,3”])    return @”iPhone 7”;<br>  if ([deviceString isEqualToString:@”iPhone9,2”])    return @”iPhone 7 Plus”;<br>  if ([deviceString isEqualToString:@”iPhone9,4”])    return @”iPhone 7 Plus”;  //iPod<br>  if ([deviceString isEqualToString:@”iPod1,1”])      return @”iPod Touch 1G”;<br>  if ([deviceString isEqualToString:@”iPod2,1”])      return @”iPod Touch 2G”;<br>  if ([deviceString isEqualToString:@”iPod3,1”])      return @”iPod Touch 3G”;<br>  if ([deviceString isEqualToString:@”iPod4,1”])      return @”iPod Touch 4G”;<br>  if ([deviceString isEqualToString:@”iPod5,1”])      return @”iPod Touch 5G”;  //iPad<br>  if ([deviceString isEqualToString:@”iPad1,1”])      return @”iPad”;<br>  if ([deviceString isEqualToString:@”iPad2,1”])      return @”iPad 2 (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad2,2”])      return @”iPad 2 (GSM)”;<br>  if ([deviceString isEqualToString:@”iPad2,3”])      return @”iPad 2 (CDMA)”;<br>  if ([deviceString isEqualToString:@”iPad2,4”])      return @”iPad 2 (32nm)”;<br>  if ([deviceString isEqualToString:@”iPad2,5”])      return @”iPad mini (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad2,6”])      return @”iPad mini (GSM)”;<br>  if ([deviceString isEqualToString:@”iPad2,7”])      return @”iPad mini (CDMA)”;  if ([deviceString isEqualToString:@”iPad3,1”])      return @”iPad 3(WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad3,2”])      return @”iPad 3(CDMA)”;<br>  if ([deviceString isEqualToString:@”iPad3,3”])      return @”iPad 3(4G)”;<br>  if ([deviceString isEqualToString:@”iPad3,4”])      return @”iPad 4 (WiFi)”;<br>  if ([deviceString isEqualToString:@”iPad3,5”])      return @”iPad 4 (4G)”;<br>  if ([deviceString isEqualToString:@”iPad3,6”])      return @”iPad 4 (CDMA)”;  if ([deviceString isEqualToString:@”iPad4,1”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad4,2”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad4,3”])      return @”iPad Air”;<br>  if ([deviceString isEqualToString:@”iPad5,3”])      return @”iPad Air 2”;<br>  if ([deviceString isEqualToString:@”iPad5,4”])      return @”iPad Air 2”;<br>  if ([deviceString isEqualToString:@”i386”])         return @”Simulator”;<br>  if ([deviceString isEqualToString:@”x86_64”])       return @”Simulator”;  if ([deviceString isEqualToString:@”iPad4,4”]<pre><code>  ||[deviceString isEqualToString:@&quot;iPad4,5&quot;]
  ||[deviceString isEqualToString:@&quot;iPad4,6&quot;])      return @&quot;iPad mini 2&quot;;
</code></pre>
  if ([deviceString isEqualToString:@”iPad4,7”]<pre><code>  ||[deviceString isEqualToString:@&quot;iPad4,8&quot;]
  ||[deviceString isEqualToString:@&quot;iPad4,9&quot;])      return @&quot;iPad mini 3&quot;;
</code></pre>
  return deviceString;<br>}<br>```</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Express学习笔记</title>
    <url>/post/dcb90c85.html</url>
    <content><![CDATA[<p>Express 是 Node.js 的一个轻量级web框架,目前使用EJS模板引擎,该笔记持续更新</p>
<span id="more"></span>

<h2 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h2><p>使用supervisor监听文件改变然后自动重启node服务器,这样子就不用每改一次代码run一遍服务器了</p>
<p><code>sudo npm install -g supervisor</code></p>
<h3 id="WebStrom配置supervisor"><a href="#WebStrom配置supervisor" class="headerlink" title="WebStrom配置supervisor"></a>WebStrom配置supervisor</h3><p>文件目录结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── app.js        项目入口及程序启动文件。</span><br><span class="line">├── bin</span><br><span class="line">│   └── www       存放启动项目的脚本文件，默认www。</span><br><span class="line">├── package.json  项目依赖配置及开发者信息。</span><br><span class="line">├── public        静态资源文件夹，默认images、javascripts、stylesheets。</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── javascripts</span><br><span class="line">│   └── stylesheets</span><br><span class="line">├── routes        路由文件相当于MVC中的Controller，默认index.js、users.js。</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── users.js</span><br><span class="line">└── views         页面文件，相当于MVC中的view，Ejs模板默认error.ejs、index.ejs</span><br><span class="line">    ├── error.ejs</span><br><span class="line">    └── index.ejs</span><br></pre></td></tr></table></figure>

<p>项目依赖配置 <code>package.json</code></p>
<p><code>package.json</code> 里面有项目依赖配置及开发者信息。<br>在dependencies后面写上依赖的包名和版本号,然后在项目根目录执行npm install就可以像cocopods一样一次性安装包依赖</p>
<h2 id="路由-Routes"><a href="#路由-Routes" class="headerlink" title="路由 Routes"></a>路由 Routes</h2><p>路由用来处理URL的访问</p>
<p><code>index.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var express &#x3D; require(&#39;express&#39;);   获取express对象</span><br><span class="line">var router &#x3D; express.Router();      获取router对象</span><br></pre></td></tr></table></figure>

<p>router有get(),post(),put(),delete()对象,代表接受的请求方式,对应查,增,改,删</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.get(&#39;&#x2F;getSomething&#39;,function(req,res,next) &#123;&#125;);</span><br><span class="line">router.post(&#39;&#x2F;post&#39;, function (req,res) &#123;&#125;);</span><br><span class="line">router.put(&#39;&#x2F;put&#39;,function(req,res,next) &#123;&#125;);</span><br><span class="line">router.delete(&#39;&#x2F;delete&#39;,function(req,res,next) &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>方法中第一个参数意味着请求路径,例如第一个的请求路径是<code>http://localhost:3000/getSomething</code>,第二个参数是获取请求内容和准备返回的响应体.</p>
<h2 id="Request获取请求参数"><a href="#Request获取请求参数" class="headerlink" title="Request获取请求参数"></a>Request获取请求参数</h2><p>例如请求发送了id参数,则<code>var id = req.params.id;</code>可以取得<br>Response返回响应体</p>
<p><code>send()</code>方法向浏览器发送一个响应信息<br>例如想返回一个json,则res.send({test:id = ${id},name = ${name}});<br>当参数为一个Number时，并且没有上面提到的任何一条在响应体里，Express会帮你设置一个响应 体，比如：200会返回字符”OK”。<br>res.send(200); // OK<br>res.send(404); // Not Found<br>res.send(500); // Internal Server Error</p>
<h2 id="Response重定向"><a href="#Response重定向" class="headerlink" title="Response重定向"></a>Response重定向</h2><p><code>res.redirect(&quot;http://www.hubwiz.com&quot;);</code></p>
<h2 id="Response渲染页面"><a href="#Response渲染页面" class="headerlink" title="Response渲染页面"></a>Response渲染页面</h2><p>如果想渲染<code>hello.ejs</code>页面,<code>res.render(&#39;hello&#39;,&#123;title:&quot;MySQL&quot;,test_params:&#39;aaa&#39;&#125;);</code><br><code>hello.ejs</code>页面通过<code>&lt;%= title %&gt;</code>的方式取得title等参数</p>
<p>Request获取主机名,路径名</p>
<p><code>req.host</code>获取主机名，<code>req.path</code>获取请求路径名</p>
<h2 id="restful-方式路由"><a href="#restful-方式路由" class="headerlink" title="restful 方式路由"></a>restful 方式路由</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.post(&#39;&#x2F;restful&#x2F;:id&#x2F;name&#x2F;:name&#39;, function (req,res) &#123;</span><br><span class="line">  var id  &#x3D; req.params.id;</span><br><span class="line">  var name &#x3D; req.params.name;</span><br><span class="line">  console.log(JSON.stringify(req.params));</span><br><span class="line">  res.send(&#123;test:&#96;id &#x3D; $&#123;id&#125;,name &#x3D; $&#123;name&#125;&#96;&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">JSON.stringify() 把js对象转成json</span><br></pre></td></tr></table></figure>

<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>安装MySQL</p>
<p><code>$ npm install mysql</code></p>
<p>引入MySQL并配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mysql      &#x3D; require(&#39;mysql&#39;);</span><br><span class="line">var connection &#x3D; mysql.createConnection(&#123;</span><br><span class="line">    host     : &#39;localhost&#39;,</span><br><span class="line">    user     : &#39;root&#39;,</span><br><span class="line">    password : &#39;123456&#39;,</span><br><span class="line">    database : &#39;csdn_test&#39;,</span><br><span class="line">    port     : 3306</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>连接数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.connect()</span><br></pre></td></tr></table></figure>

<p>这个方法可以接受一个回调用来判断是否连接成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.connect(function(err) &#123;</span><br><span class="line">    if (!err) &#123;</span><br><span class="line">   		&#x2F;&#x2F; 连接成功</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 连接失败 </span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line">connection.end();</span><br></pre></td></tr></table></figure>

<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connection.query(&#39;SELECT 1 + 1 AS solution&#39;, function(err, rows, fields) &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(&#39;The solution is: &#39;, rows[0].solution);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同上,接受一个回调来判断是否成功关闭连接</p>
<p><code>connection.end(err =&gt; console.log(</code>连接中断${err}`));’</p>
<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>安装</p>
<p><code>npm install -g mongoose</code><br>配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">var options &#x3D; &#123;</span><br><span class="line">    db_user: &quot;root&quot;,</span><br><span class="line">    db_pwd: &quot;123456&quot;,</span><br><span class="line">    db_host: &quot;localhost&quot;,</span><br><span class="line">    db_port: 27017,</span><br><span class="line">    db_name: &quot;csdn_test&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var dbURL &#x3D; &quot;mongodb:&#x2F;&#x2F;&quot; + options.db_user + &quot;:&quot; + options.db_pwd + &quot;@&quot; + options.db_host + &quot;:&quot; + options.db_port + &quot;&#x2F;&quot; + options.db_name;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 连接</span><br><span class="line">mongoose.connect(dbURL);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听连接事件</span><br><span class="line">mongoose.connection.on(&#39;connected&#39;, function (err) &#123;</span><br><span class="line">    if (err) logger.error(&#39;Database connection failure&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听错误事件</span><br><span class="line">mongoose.connection.on(&#39;error&#39;, function (err) &#123;</span><br><span class="line">    logger.error(&#39;Mongoose connected error &#39; + err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听断开事件</span><br><span class="line">mongoose.connection.on(&#39;disconnected&#39;, function () &#123;</span><br><span class="line">    logger.error(&#39;Mongoose disconnected&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">查询</span><br><span class="line"></span><br><span class="line">mongoose.collection(&#39;mamals&#39;).find().toArray(function(err, result) &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其他方法以后遇到再补充.</p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins+Git+Cocoapods+Fir.im实现iOS应用持续集成</title>
    <url>/post/13ecfb47.html</url>
    <content><![CDATA[<p>Jenkins 可以定时检测 Git 上的某个分支的代码，打包生成 ipa 后直接上传到 Fir.im</p>
<span id="more"></span>

<h3 id="安装-Jenkins"><a href="#安装-Jenkins" class="headerlink" title="安装 Jenkins"></a>安装 Jenkins</h3><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4><p>Jenkins 是基于 Java 的一个应用，所以你需要先有JDK ，安装 JDK 网上有很多资料这里就跳过了</p>
<p>使用 Brew 安装 Jenkins</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install jenkins</span><br></pre></td></tr></table></figure>

<h3 id="启动-Jenkins"><a href="#启动-Jenkins" class="headerlink" title="启动 Jenkins"></a>启动 Jenkins</h3><p><code>jenkins</code> 或者 <code>java -jar /usr/local/opt/jenkins/libexec/jenkins.war --httpPort=8088</code> 这种方法可以指定端口号执行</p>
<p>如果想自动启动，需要先执行以下命令，创建启动项<br><code>ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents</code></p>
<p>可以编辑一下<code>~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</code>这个文件<br><code>open ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</code></p>
<p>想要让局域网都可以访问，需要把<code>–httpListenAddress=127.0.0.1</code>改成自己的局域网IP</p>
<p>手动启动启动项可以执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">launchctl load ~&#x2F;Library&#x2F;LaunchAgents&#x2F;homebrew.mxcl.jenkins.plist</span><br></pre></td></tr></table></figure>

<h3 id="配置Xcode项目"><a href="#配置Xcode项目" class="headerlink" title="配置Xcode项目"></a>配置Xcode项目</h3><p>使用 CocoaPods<br>终端进入已有项目的目录下，执行</p>
<p>填写 podfile 类似下面这样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">target &#39;TestJenkins&#39; do</span><br><span class="line">	pod &#39;MJExtension&#39;</span><br><span class="line">  target &#39;TestJenkinsTests&#39; do</span><br><span class="line">    inherit! :search_paths</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>然后执行 <code>pod install</code></p>
<p>执行完成之后打开<code>TestJenkins.xcworkspace</code></p>
<p>打开 <code>Product - Scheme - Manage Scheme</code></p>
<p>把 <code>Share</code> 下面的勾都打上</p>
<p><img src="https://raw.githubusercontent.com/Arc-lin/BlogImage/master/888.png"></p>
<h3 id="上传到Git"><a href="#上传到Git" class="headerlink" title="上传到Git"></a>上传到Git</h3><p>在终端进入该项目根目录，执行<code>git init</code></p>
<p>在 Git托管平台上新建一个项目，得到 git 远程仓库地址，然后在项目中添加该远程地址</p>
<p><code>git remote add origin git@git.coding.net:Arclin/TestJenkins.git</code></p>
<p>新的项目或许还需要<code>git pull origin master</code> pull一下Readme等东西</p>
<ol>
<li><code>git add . </code> 添加项目文件</li>
<li><code>git git commit -m &quot;initial&quot;</code> 提交更改</li>
<li><code>git push origin master</code> 推送到 master远程分支</li>
</ol>
<h3 id="配置-Jenkins"><a href="#配置-Jenkins" class="headerlink" title="配置 Jenkins"></a>配置 Jenkins</h3><p>在浏览器中打开 Jenkins,比如我指定了8088端口的话，那就打开<code>http://localhost:8088/</code>,然后根据提示安装，注意里面有一个选择插件的界面，根据需要选择就好。</p>
<h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><p>系统管理 - 插件管理 可以安装插件,建议安装</p>
<ul>
<li>Git Server Plugin  </li>
<li>Git Client Plugin  </li>
<li>fir-plugin  （安装教程看 <a href="http://www.jianshu.com/p/9a245918a219%EF%BC%89">http://www.jianshu.com/p/9a245918a219）</a></li>
<li>Xcode integration</li>
<li>Keychains and Provisioning Profiles Management</li>
</ul>
<p>下面我们就会用上这些插件</p>
<h4 id="新建一个Job"><a href="#新建一个Job" class="headerlink" title="新建一个Job"></a>新建一个Job</h4><p><img src="https://raw.githubusercontent.com/Arc-lin/BlogImage/master/999.png"></p>
<p>进行一系列配置<br>设置包的保留天数还有天数。</p>
<p><img src="https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1001.png"></p>
<p>源码管理</p>
<p><img src="https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1002.png"></p>
<p>要先配置SSH Key，在Jenkins的证书管理中添加SSH。在Jenkins管理页面，选择“Credentials”，然后选择“Global credentials (unrestricted)”，点击“Add Credentials”，如下图所示，我们填写自己的SSH信息，然后点击“Save”，这样就把SSH添加到Jenkins的全局域中去了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-6d1b6f56e4dac318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>构建触发器<br>构建触发器设置这里是设置自动化测试的地方。这里涉及的内容很多，暂时我也没有深入研究，这里暂时先不设置。有自动化测试需求的可以好好研究研究这里的设置。</p>
<p>不过这里有两个配置还是需要是配置的</p>
<p>Poll SCM (poll source code management) 轮询源码管理<br>需要设置源码的路径才能起到轮询的效果。一般设置为类似结果： 0/5 每5分钟轮询一次<br>Build periodically (定时build)<br>一般设置为类似： 00 20 * 每天 20点执行定时build 。当然两者的设置都是一样可以通用的。</p>
<p>格式是这样的</p>
<p>分钟(0-59) 小时(0-23) 日期(1-31) 月(1-12) 周几(0-7,0和7都是周日)</p>
<p>例如 <code>H/10 * * * *</code> 就是每十分钟一次</p>
<h4 id="构建环境"><a href="#构建环境" class="headerlink" title="构建环境"></a>构建环境</h4><p>iOS打包需要签名文件和证书，所以这部分我们勾选“Keychains and Code Signing Identities”和“Mobile Provisioning Profiles”。</p>
<p>在这之前</p>
<p>在系统设置中进入Keychains and Provisioning Profiles Management页面，点击“浏览”按钮，分别上传自己的keychain和证书（是这里需要的Keychain，并不是cer证书文件。这个Keychain其实在/Users/管理员用户名/Library/keychains/login.keychain,当把这个Keychain设置好了之后，Jenkins会把这个Keychain拷贝到/Users/Shared/Jenkins/Library/keychains这里，(Library是隐藏文件)。Provisioning Profiles文件也直接拷贝到/Users/Shared/Jenkins/Library/MobileDevice文件目录下）。上传成功后，我们再为keychain指明签名文件的名称。点击“Add Code Signing Identity”，最后添加成功后如下图所示</p>
<p><img src="https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1003.png"></p>
<p>password 填写你的用户密码</p>
<p>Code Signing Identity 的内容来源是这里</p>
<p><img src="https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_1.png?version=1&modificationDate=1375867279000"></p>
<p><img src="https://wiki.jenkins-ci.org/download/attachments/68386839/codesigning_Key_2.png?version=2&modificationDate=1375868440000"></p>
<p>Provision Profiles Directory Path 的内容填上</p>
<p><code>/Users/Shared/Jenkins/Library/MobileDevice</code></p>
<p><img src="https://wiki.jenkins-ci.org/download/attachments/68386839/Screen+Shot+2013-08-07+at+14.17.05.png?version=1&modificationDate=1375877888000"></p>
<p>回到项目配置</p>
<p>这样子填写</p>
<p><img src="https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1004.png"></p>
<h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p>点击”增加构建步骤”,先后选择 XCode 和 Execute Shell</p>
<p>XCode 配置如下</p>
<p><img src="https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1005.png"><br><img src="https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1006.png"><br><img src="https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1007.png"></p>
<p>Execute Shell 只要写入这个命令就好</p>
<p><code>fir publish /Users/Arclin/.jenkins/workspace/TestJenkins/build/TestJenkins.ipa --token=你的fir.im Token</code></p>
<p>如果没安装 fir 命令行工具的话</p>
<p>用<code>gem install fir-cli</code> 安装<br>如果发现问题就看这里</p>
<p><img src="https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1008.png"></p>
<p>然后保存回到Jenkins项目首页，点击立即构建，然后如果成功的话就会像下图那样子</p>
<p><img src="https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1009.png"></p>
<p><img src="https://raw.githubusercontent.com/Arc-lin/BlogImage/master/1010.png"></p>
<p>每隔一个触发器设定的时间，他就会检查一下 git 上面的代码，如果有发现更新就会自动 pull然后打包并上传到 fir.im</p>
<p>结束</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Git</tag>
        <tag>Cocoapods</tag>
        <tag>Fir</tag>
      </tags>
  </entry>
  <entry>
    <title>Let’s Encrypt 免费https</title>
    <url>/post/feddc8a5.html</url>
    <content><![CDATA[<p>在服务器配置免费的CA证书</p>
<span id="more"></span>

<p>下载源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;letsencrypt&#x2F;letsencrypt</span><br></pre></td></tr></table></figure>

<p>生成证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd letsencrypt&#x2F;</span><br><span class="line"></span><br><span class="line">.&#x2F;letsencrypt-auto certonly --standalone --email arclin@dankal.cn -d arclin.me -d g.arclin.me </span><br></pre></td></tr></table></figure>

<p>默认有效期90天</p>
<p>自动续期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;letsencrypt-auto certonly --renew-by-default --email arclin@dankal.cn -d arclin.me -d g.arclin.me</span><br></pre></td></tr></table></figure>

<p>报错及解决</p>
<ul>
<li><p>报错<br>Problem binding to port 443: Could not bind to IPv4 or IPv6.</p>
</li>
<li><p>解决<br>停止443端口<br>比如 关闭ShadowSocks服务(ssserver)  关闭nginx</p>
</li>
<li><p>报错<br>Failed authorization procedure. arclin.me (tls-sni-01): urn:acme:error:connection :: The server could not connect to the client to verify the domain :: Connection refused</p>
</li>
<li><p>解决<br>在DNSPod 绑定 arclin.me域名到本服务器</p>
</li>
</ul>
<p>修改Nginx 配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name g.arclin.me;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen 443 ssl http2; #443这里是https的端口  开启http2服务需要安装http_v2_module模块</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;fullchain.pem;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;privkey.pem;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        google on;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>重启服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">nginx -s reload</span><br><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Let&#39;s Encrypt</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB笔记</title>
    <url>/post/b3b38c86.html</url>
    <content><![CDATA[<p>MongoDB笔记</p>
<span id="more"></span>

<p>OS X安装</p>
<p><code>brew install mongodb</code></p>
<p>进入mongodb</p>
<p><code>mongo</code></p>
<p>查看所有数据库</p>
<p><code>db</code></p>
<p>查看所有<em>有数据的</em>数据库并带上内存信息</p>
<p><code>show dbs</code></p>
<p>创建/进入某个数据库</p>
<p><code>use DATABASE_NAME</code></p>
<p>删除数据库(需要先<code>use DATABASE_NAME</code> 进入数据库)</p>
<p><code>db.dropDatabase()</code></p>
<p>插入数据</p>
<p><code>db.DATABASE_NAME.insert(&#123;“COLUMN_NAME”:”VALUE”,”COLUMN_NAME_SECOND”:”SECOND_VALUE”&#125;)</code></p>
<p>查询所有数据</p>
<p><code>db.DATABASE_NAME.find()</code></p>
<p>查询所有数据并pretty形式打印</p>
<p><code>db.DATABASE_NAME.find().pretty()</code></p>
<p>更新满足条件的第一条数据</p>
<p><code>db.DATABASE_NAME.update(&#123;‘条件字段’:’条件值’&#125;,&#123;$set:&#123;‘更新字段’:’更新值’,‘更新字段2’:’更新值2’&#125;&#125;)</code></p>
<p>更新满足条件的所有数据</p>
<p><code>db.DATABASE_NAME.update(&#123;‘条件字段’:’条件值’&#125;,&#123;$set:&#123;‘更新字段’:’更新值’,‘更新字段2’:’更新值2’&#125;,&#123;multi:true&#125;&#125;)</code></p>
<p>替换整条数据的内容(根据ID查找)</p>
<p><code>db.DATABASE_NAME.save(&#123;“_id”:ObjectId(“xxxxx”),”要替换的字段名”:”要替换的字段名”,”要替换的字段名2”:”要替换的字段名2”&#125;)</code></p>
<p>删除数据</p>
<p><code>db.DATABASE_NAME.remove(&#123;‘条件字段’:’条件值’&#125;)</code></p>
<p>删除第一条找到的记录</p>
<p><code>db.DATABASE_NAME.remove(&#123;‘条件字段’:’条件值’&#125;,1)</code></p>
<p>删除所有数据(请空表)</p>
<p><code>db.DATABASE_NAME.remove(&#123;&#125;)</code></p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>NavigationController的RootViewController和子ViewController的状态栏颜色不一样或者状态栏显示异常</title>
    <url>/post/cacc49a3.html</url>
    <content><![CDATA[<p>如果NavigationController的状态栏颜色跟子ViewController的状态栏颜色不一样，那么就像下面这么写</p>
<p>在UINavigationController的子类写这个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UIViewController *)childViewControllerForStatusBarStyle&#123;</span><br><span class="line">    return self.topViewController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins上蒲公英插件中update description 无法自动写入commit message问题解决</title>
    <url>/post/5fcbb764.html</url>
    <content><![CDATA[<p>花了一天时间解决这个问题，找了好多资料都没找到，最后终于想到了办法。</p>
<span id="more"></span>

<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在Jenkins上使用蒲公英上传软件安装包有两种方法，一种是使用命令行的方式<br>类似下面这种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IPANAME&#x3D;&quot;jinkens-myapp&quot;</span><br><span class="line">fastlane gym --export_method ad-hoc --output_name $&#123;IPANAME&#125;</span><br><span class="line"></span><br><span class="line">MSG&#x3D;&#96;git log -1 --pretty&#x3D;%B&#96;</span><br><span class="line">PASSWORD&#x3D;123456</span><br><span class="line">curl -F &quot;file&#x3D;@$&#123;IPANAME&#125;&quot; -F &quot;uKey&#x3D;USER_KEY&quot; -F &quot;_api_key&#x3D;API_KEY&quot; -F &quot;updateDescription&#x3D;$&#123;MSG&#125;&quot; -F &quot;password&#x3D;$&#123;PASSWORD&#125;&quot; https:&#x2F;&#x2F;qiniu-storage.pgyer.com&#x2F;apiv1&#x2F;app&#x2F;upload</span><br></pre></td></tr></table></figure>

<p>这种方式的话就可以直接通过命令行获得<code>commit message</code>作为版本更新说明，但是缺点是无法直接通过环境变量获得上传后的App的各种信息，比如安装包地址，app二维码图片的等等。</p>
<p>第二种方式是通过蒲公英在Jenkins上发布的插件<code>Upload to pgyer</code>，优点是上传后的各种App的信息都会被注入到环境变量中，可以在邮件模板中直接调用。缺点是Upload description必须写死为某个值，或者使用某个环境变量，但是Jenkins的Git插件又不提供给你最后一条<code>commit message</code>的环境变量。</p>
<p>所以说为了结合两种方式的优点，想出了如下办法解决了。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol>
<li>安装插件    <code>Environment Injector Plugin</code></li>
<li>构建步骤添加<code>Execute Shell</code>，填写 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 把commit message写入文件中</span><br><span class="line">MSG&#x3D;$(git log -1 --pretty&#x3D;%B)</span><br><span class="line">echo &quot;commitMessage&#x3D;&quot;$&#123;MSG&#125; &gt; commitMessage.txt</span><br></pre></td></tr></table></figure></li>
<li>构件步骤中添加<code>Inject Environment variables</code>，<code>Properties File Path</code>填写<code>$&#123;WORKSPACE&#125;/commitMessage.txt</code>(也有可能是别的路径，不要写错了)</li>
<li>最后在蒲公英插件<code>Upload to pgyer</code>上<code>updateDescription</code>中填写<code>$&#123;commitMessage&#125;</code></li>
</ol>
<p>就这样子就可以了，就是把message写到文件中，然后通过文件注入环境变量，然后蒲公英插件再去用就行了。</p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js学习笔记</title>
    <url>/post/1aafa723.html</url>
    <content><![CDATA[<p>Node.js的学习笔记,持续更新</p>
<span id="more"></span>

<blockquote>
<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型</p>
<p>事件驱动</p>
<blockquote>
<p>所谓事件驱动，简单地说就是你点什么按钮（即产生什么事件），电脑执行什么操作（即调用什么函数）.当然事件不仅限于用户的操作. 事件驱动的核心自然是事件。从事件角度说，事件驱动程序的基本结构是由一个事件收集器、一个事件发送器和一个_事件处理器组成。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>事件收集器专门负责收集所有事件，包括来自用户的（如鼠标、键盘事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。<br>事件发送器负责将收集器收集到的事件分发到目标对象中。<br>事件处理器做具体的事件响应工作，它往往要到实现阶段才完全确定，因而需要运用虚函数机制（函数名往往取为类似于HandleMsg的一个名字）。对于框架的使用者来说，他们唯一能够看到的是事件处理器。这也是他们所关心的内容。</p>
</blockquote>
</blockquote>
<blockquote>
<p>非阻塞式 I/O</p>
</blockquote>
<blockquote>
<blockquote>
<p>I/O 即Input/Output 的缩写</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。<br>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。<br>在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
</blockquote>
</blockquote>
<h2 id="let-var-const"><a href="#let-var-const" class="headerlink" title="let var const"></a>let var const</h2><p><code>let</code> 允许把变量的作用域限制在块级域中。与 <code>var</code> 不同处是：<code>var</code> 申明变量要么是全局的，要么是函数级的，而无法是块级的。</p>
<p><code>let</code>的作用域是块，而<code>var</code>的作用域是函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">for (let i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">  console.log(i); &#x2F;&#x2F; 0, 1, 2, 3, 4 ... 9</span><br><span class="line">&#125;</span><br><span class="line">console.log(i); &#x2F;&#x2F; i is not defined</span><br><span class="line">const这个声明创建一个常量,可以全局或局部的函数声明,不可以被重新赋值.</span><br></pre></td></tr></table></figure>

<h2 id="Map-WeakMap-Set-WeakSet"><a href="#Map-WeakMap-Set-WeakSet" class="headerlink" title="Map WeakMap Set WeakSet"></a>Map WeakMap Set WeakSet</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map原生提供三个遍历器生成函数和一个遍历方法。</p>
<p><code>keys()</code> 返回键名的遍历器。<br><code>values()</code> 返回键值的遍历器。<br><code>entries()</code> 返回所有成员的遍历器。<br><code>forEach()</code> 遍历Map的所有成员。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myMap &#x3D; new Map();</span><br><span class="line">myMap.set(0, &quot;zero&quot;);</span><br><span class="line">myMap.set(1, &quot;one&quot;);</span><br><span class="line"> </span><br><span class="line">for (var key of myMap.keys()) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0 1</span><br><span class="line"> </span><br><span class="line">for (var value of myMap.values()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; zero one</span><br><span class="line"> </span><br><span class="line">for (var item of myMap.entries()) &#123;</span><br><span class="line">  console.log(item[0] + &quot; &#x3D; &quot; + item[1]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0 &#x3D; zero 1 &#x3D; one</span><br><span class="line"> </span><br><span class="line">myMap.forEach(function(value, key) &#123;</span><br><span class="line">  console.log(key + &quot; &#x3D; &quot; + value);</span><br><span class="line">&#125;, myMap)</span><br><span class="line">&#x2F;&#x2F; 0 &#x3D; zero 1 &#x3D; one</span><br></pre></td></tr></table></figure>

<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。<br>WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。<br>WeakMap只有四个方法可用：get()、set()、has()、delete()。</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><code>add(value)</code> 添加某个值，返回Set结构本身。<br><code>delete(value)</code> 删除某个值，返回一个布尔值，表示删除是否成功。<br><code>has(value)</code> 返回一个布尔值，表示该值是否为Set的成员。<br><code>clear()</code> 清除所有成员，没有返回值。 上面这些属性和方法的实例如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s &#x3D; new Set();</span><br><span class="line">s.add(1).add(2).add(2);</span><br><span class="line">&#x2F;&#x2F; 注意2被加入了两次</span><br><span class="line">console.log(s.size); &#x2F;&#x2F; 2</span><br><span class="line">console.log(s.has(1)); &#x2F;&#x2F; true</span><br><span class="line">console.log(s.has(2)); &#x2F;&#x2F; true</span><br><span class="line">console.log(s.has(3)); &#x2F;&#x2F; false</span><br><span class="line">console.log(s.delete(2));</span><br><span class="line">console.log(s.has(2)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>Set的遍历跟Map差不多,但是如果使用<code>set.entries()</code>去遍历的话,出来的结果会是像这样子[“red”, “red”] [“green”, “green”] [“blue”, “blue”],包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。</p>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><p>weakSet和WeakMap的道理也差不多,WeakSet的成员只能是对象，而不能是其他类型的值.WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用<br>WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var ws &#x3D; new WeakSet();</span><br><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">var foo &#x3D; &#123;&#125;;</span><br><span class="line">ws.add(obj);</span><br><span class="line">ws.has(foo);    &#x2F;&#x2F; false</span><br><span class="line">WeakSet没有size属性，没有办法遍历它的成员。</span><br><span class="line">ws.size &#x2F;&#x2F; undefined</span><br><span class="line">ws.forEach &#x2F;&#x2F; undefined</span><br><span class="line">ws.forEach(function(item)&#123; console.log(&#39;WeakSet has &#39; + item)&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; TypeError: undefined is not a function</span><br></pre></td></tr></table></figure>
<h2 id="Generator-Promise-Symbol"><a href="#Generator-Promise-Symbol" class="headerlink" title="Generator Promise Symbol"></a>Generator Promise Symbol</h2><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。</p>
<p>执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* helloWorldGenerator() &#123;</span><br><span class="line">  yield &#39;hello&#39;;</span><br><span class="line">  yield &#39;world&#39;;</span><br><span class="line">  return &#39;ending&#39;;</span><br><span class="line">&#125;</span><br><span class="line">var hw &#x3D; helloWorldGenerator();</span><br><span class="line">console.log(hw.next()); \\ &#123; value: &#39;hello&#39;, done: false &#125;</span><br><span class="line">console.log(hw.next()); \\ &#123; value: &#39;world&#39;, done: false &#125;</span><br><span class="line">console.log(hw.next()); \\ &#123; value: &#39;ending&#39;, done: true &#125;</span><br><span class="line">console.log(hw.next()); \\ &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>

<p><code>yield</code> 意为’产出’ 是用来定义不同的内部状态,调用next()方法的时候会返回Generator的下一个状态,直到return为止,输出的done中的值表示Generator函数是否已经执行结束.</p>
<p><code>yield *</code> 语句 : 用来在一个Generator中执行另外一个Generator函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* anotherGenerator(i) &#123;</span><br><span class="line">  yield i + 1;</span><br><span class="line">  yield i + 2;</span><br><span class="line">  yield i + 3;</span><br><span class="line">&#125;</span><br><span class="line">function* generator(i)&#123;</span><br><span class="line">  yield i;</span><br><span class="line">  yield* anotherGenerator(i);</span><br><span class="line">  yield i + 10;</span><br><span class="line">&#125;</span><br><span class="line">var gen &#x3D; generator(10);</span><br><span class="line">console.log(gen.next().value); &#x2F;&#x2F; 10</span><br><span class="line">console.log(gen.next().value); &#x2F;&#x2F; 11</span><br><span class="line">console.log(gen.next().value); &#x2F;&#x2F; 12</span><br><span class="line">console.log(gen.next().value); &#x2F;&#x2F; 13</span><br><span class="line">console.log(gen.next().value); &#x2F;&#x2F; 20</span><br></pre></td></tr></table></figure>
<p>运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise 是一个构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">  &#x2F;&#x2F; ... some code</span><br><span class="line">  if (&#x2F;* 异步操作成功 *&#x2F;)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Promise函数自带两个参数: <code>resolve</code>意为返回一个成功的回调,<code>reject</code>意为返回一个错误的回调<br>然后订阅回调的方法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise.then(function(value) &#123;</span><br><span class="line">  &#x2F;&#x2F; success</span><br><span class="line">&#125;, function(value) &#123;</span><br><span class="line">  &#x2F;&#x2F; failure</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>PS: 这个函数很像OC的block方法,上面的函数就类似OC的如下写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)promise:(void(^)(id success))resolve failure:(void(^)(id failure))reject &#123;</span><br><span class="line">	if(...)&#123;</span><br><span class="line">		resolve(resolveValue);</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">		reject(rejectValue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;订阅</span><br><span class="line">[self promise:^(id success)&#123;</span><br><span class="line">	NSLog(success);</span><br><span class="line">&#125; failure:^(id failure)&#123;</span><br><span class="line">	NSLog(failure);</span><br><span class="line">&#125;];</span><br><span class="line">&#x2F;&#x2F; 纯脑补,也不知道有没有写对</span><br></pre></td></tr></table></figure>

<h4 id="catch-方法"><a href="#catch-方法" class="headerlink" title="catch() 方法"></a>catch() 方法</h4><p>专门用来捕获异常的回调,会捕获到<code>then()</code>的第二个参数的回调</p>
<p>如果在<code>then()</code>中使用了throw xxx;语句,那么也会走<code>catch()</code>回调</p>
<p><code>catch()</code>和<code>then()</code>方法都会返回Promise对象,所以可以链式调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise.then(function(value) &#123;</span><br><span class="line">    console.log(value);      </span><br><span class="line">&#125;,null).catch(function(value)&#123;</span><br><span class="line">	console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>OR</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p1.then(function(value) &#123;</span><br><span class="line">  console.log(value); &#x2F;&#x2F; &quot;成功!&quot;</span><br><span class="line">  throw &quot;哦，不!&quot;;</span><br><span class="line">&#125;).catch(function(e) &#123;</span><br><span class="line">  console.log(e); &#x2F;&#x2F; &quot;哦，不!&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>你还可以<code>then()</code>完再<code>then()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p2 &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">  resolve(1);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p2.then(function(value) &#123;</span><br><span class="line">  console.log(value); &#x2F;&#x2F; 1</span><br><span class="line">  return value + 1;</span><br><span class="line">&#125;).then(function(value) &#123;</span><br><span class="line">  console.log(value); &#x2F;&#x2F; 2</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="all-方法"><a href="#all-方法" class="headerlink" title="all() 方法"></a>all() 方法</h4><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var p &#x3D; Promise.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>

<p>只要有一个reject了,那么p就会抛出失败的回调,只有全部都resolve了,才会抛出成功的回调</p>
<h4 id="race-方法"><a href="#race-方法" class="headerlink" title="race() 方法"></a>race() 方法</h4><p>顾名思义 赛跑</p>
<p>同样是来绑定多个Promise实例,不同的是谁先返回就走谁的回调,如果p1五秒后发失败回调,p2一秒后发成功回调,那么Promise.race([p1, p2])就等于p2.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.race([p1, p2]).then(function(value) &#123;</span><br><span class="line">  console.log(value); &#x2F;&#x2F; &quot;two&quot;</span><br><span class="line">  &#x2F;&#x2F; Both resolve, but p2 is faster</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>符号</p>
<p>用Symbol生成的对象,绝对不会重复!!!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s1 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class="line">var s2 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class="line">console.log(s1 &#x3D;&#x3D;&#x3D; s2); &#x2F;&#x2F; false</span><br><span class="line">getOwnPropertySymbols()</span><br></pre></td></tr></table></figure>

<p>这个方法可以获得对象的所有Symbol类型的成员属性名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">var a &#x3D; Symbol(&#39;a&#39;);</span><br><span class="line">var b &#x3D; Symbol(&#39;b&#39;);</span><br><span class="line"> </span><br><span class="line">obj[a] &#x3D; &#39;Hello&#39;;</span><br><span class="line">obj[b] &#x3D; &#39;World&#39;;</span><br><span class="line">var objectSymbols &#x3D; Object.getOwnPropertySymbols(obj);</span><br><span class="line">console.log(objectSymbols);</span><br><span class="line">&#x2F;&#x2F; [Symbol(a), Symbol(b)]</span><br></pre></td></tr></table></figure>

<h4 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a>Symbol.for()</h4><p>这个方法用来搜索之前有没有定义过某个Symbol名,如果有的话就返回值没有的话就就新建一个Symbol,有种取缓存的感觉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var s1 &#x3D; Symbol.for(&#39;foo&#39;); &#x2F;&#x2F; 定义一下</span><br><span class="line">var s2 &#x3D; Symbol.for(&#39;foo&#39;); &#x2F;&#x2F; 取出之前定义的值</span><br><span class="line">console.log(s1 &#x3D;&#x3D;&#x3D; s2); &#x2F;&#x2F; true</span><br><span class="line">Symbol.keyFor()</span><br><span class="line">跟上面的是相反的,通过值来取键</span><br><span class="line"></span><br><span class="line">var s1 &#x3D; Symbol.for(&quot;foo&quot;);</span><br><span class="line">Symbol.keyFor(s1) &#x2F;&#x2F; &quot;foo&quot;</span><br><span class="line"> </span><br><span class="line">var s2 &#x3D; Symbol(&quot;foo&quot;);</span><br><span class="line">Symbol.keyFor(s2) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>其实就是简写方法而已</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var  f &#x3D; function(v1,v2) &#123;</span><br><span class="line">	return v1+v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var f &#x3D; (v1,v2) &#x3D;&gt; v1+v2;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。<br>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。<br>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用<code>Rest</code>参数代替。<br>不可以使用<code>yield</code>命令，因此箭头函数不能用作Generator函数。</p>
<h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><h3 id="方式一-使用-http-request"><a href="#方式一-使用-http-request" class="headerlink" title="方式一 使用 http.request()"></a>方式一 使用 http.request()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var http &#x3D; require(&#39;http&#39;);  </span><br><span class="line">  </span><br><span class="line">var qs &#x3D; require(&#39;querystring&#39;);  </span><br><span class="line">  </span><br><span class="line">var data &#x3D; &#123;  </span><br><span class="line">    a: 123,  </span><br><span class="line">    time: new Date().getTime()&#125;;&#x2F;&#x2F;这是需要提交的数据  </span><br><span class="line">    </span><br><span class="line">var content &#x3D; qs.stringify(data);   </span><br><span class="line">var options &#x3D; &#123;  </span><br><span class="line">    hostname: &#39;127.0.0.1&#39;,  </span><br><span class="line">    port: 10086,  </span><br><span class="line">    path: &#39;&#x2F;pay&#x2F;pay_callback?&#39; + content,  </span><br><span class="line">    method: &#39;GET&#39;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">var req &#x3D; http.request(options, function (res) &#123;  </span><br><span class="line">    console.log(&#39;STATUS: &#39; + res.statusCode);  </span><br><span class="line">    console.log(&#39;HEADERS: &#39; + JSON.stringify(res.headers));  </span><br><span class="line">    res.setEncoding(&#39;utf8&#39;);  </span><br><span class="line">    res.on(&#39;data&#39;, function (chunk) &#123;  </span><br><span class="line">        console.log(&#39;BODY: &#39; + chunk);  </span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">req.on(&#39;error&#39;, function (e) &#123;  </span><br><span class="line">    console.log(&#39;problem with request: &#39; + e.message);  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>

<h3 id="方式二-使用-http-get-发送GET请求"><a href="#方式二-使用-http-get-发送GET请求" class="headerlink" title="方式二 使用 http.get() 发送GET请求"></a>方式二 使用 http.get() 发送GET请求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var httpRequest &#x3D; http.get(&#39;http:&#x2F;&#x2F;localhost:8088&#x2F;tempFile&#x2F;LocalData.json&#39;,function(request,response)&#123;</span><br><span class="line">      var html&#x3D;&#39;&#39;;</span><br><span class="line">      request.on(&#39;data&#39;,function(data)&#123;</span><br><span class="line">        	html+&#x3D;data;</span><br><span class="line">      &#125;);</span><br><span class="line">      request.on(&#39;end&#39;,function()&#123;</span><br><span class="line">			console.log(html);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>学习资料来自:<a href="http://www.hubwiz.com/">http://www.hubwiz.com</a> 等</p>
</blockquote>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 内容替换模块 http_substitutions_filter_module</title>
    <url>/post/e35ccdb6.html</url>
    <content><![CDATA[<p>在镜像了某个网站之后,想要改变这个网站上某些元素的显示内容, 这是我们可以使用nginx的一个第三方模块<code>http_substitutions_filter_module</code></p>
<span id="more"></span>

<p>修改nginx配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name g.arclin.me;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;fullchain.pem;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;arclin.me&#x2F;privkey.pem;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        subs_filter Google\s提供 Arclin提供 r;</span><br><span class="line">        google on;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>RACCommand使用注意</title>
    <url>/post/79533f9e.html</url>
    <content><![CDATA[<p>RACCommand使用注意</p>
<span id="more"></span>

<ol>
<li><code>signalBlock</code>必须要返回一个信号，不能传nil. </li>
<li>如果不想要传递信号，直接创建空的信号<code>[RACSignal empty]</code>;</li>
<li>RACCommand中信号如果数据传递完，必须调用<code>[subscriber sendCompleted]</code>，这时命令才会执行完毕，否则永远处于执行中。</li>
<li><code>RACCommand</code>需要被强引用，否则接收不到<code>RACCommand</code>中的信号，因此RACCommand中的信号是延迟发送的。</li>
</ol>
<ul>
<li><p><code>RACCommand</code>设计思想：内部signalBlock为什么要返回一个信号，这个信号有什么用。</p>
<ol>
<li>在RAC开发中，通常会把网络请求封装到<code>RACCommand</code>，直接执行某个RACCommand就能发送请求。</li>
<li>当<code>RACCommand</code>内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。</li>
</ol>
</li>
<li><p>如何拿到RACCommand中返回信号发出的数据。</p>
<ol>
<li>RACCommand有个执行信号源<code>executionSignals</code>，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。</li>
<li>订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。</li>
</ol>
</li>
<li><p>监听当前命令是否正在执行<code>executing</code></p>
</li>
<li><p>使用场景,监听按钮点击，网络请求</p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Reactive Cocoa</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative ListView flexWrap不起作用解决办法</title>
    <url>/post/11785d19.html</url>
    <content><![CDATA[<p><code>flexWrap:’wrap’ </code>作用是让超出页面的元素进行换行显示,但是在RN 0.28之后就发生了改变</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>RN0.28之前</th>
<th>RN0.28之后</th>
</tr>
</thead>
<tbody><tr>
<td>contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems: ‘stretch’,<br/>// 屏幕宽度<br/>width:width,<br/>},</td>
<td>contentViewStyle:<br/>{<br/>flexDirection:’row’,<br/>flexWrap:’wrap’,<br/>alignItems:’flex-start’,<br/>// 屏幕宽度<br/> width:width,<br/>},</td>
</tr>
</tbody></table>
<p><code>alignItems: ‘stretch’</code> 变成了 <code>alignItems:’flex-start’</code>,</p>
<p>但是现在的教程基本上不会加上<code>alignItems</code>…只有一个<code>flexWrap</code>,但是放到现在就实现不了了</p>
]]></content>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>React Native真机运行</title>
    <url>/post/7724d1af.html</url>
    <content><![CDATA[<p>三步即可</p>
<p>在项目根目录使用终端执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;localhost:8081&#x2F;index.ios.bundle -o main.jsbundle</span><br></pre></td></tr></table></figure>

<p><code>AppDelegate.m</code> 找到这一行并注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jsCodeLocation &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;localhost:8081&#x2F;index.ios.bundle?platform&#x3D;ios&amp;dev&#x3D;true&quot;];</span><br></pre></td></tr></table></figure>

<p><code>AppDelegate.m</code> 写上或反注释这一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jsCodeLocation &#x3D; [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative与iOS原生代码之间传值</title>
    <url>/post/a8a5ff12.html</url>
    <content><![CDATA[<p>本文包含两部分:</p>
<ul>
<li>原生传值到RN</li>
<li>RN传值到原生</li>
</ul>
<span id="more"></span>

<h3 id="原生传值到RN"><a href="#原生传值到RN" class="headerlink" title="原生传值到RN"></a>原生传值到RN</h3><p>加载<code>RCTRootView</code>的时候在<code>initialProperties</code>内传值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSDictionary *params &#x3D; @&#123;@&quot;image&quot;:@&quot;https:&#x2F;&#x2F;dn-coding-net-production-static.qbox.me&#x2F;ac823dee-6303-4745-9216-711ab4d83753.png?imageMogr2&#x2F;auto-orient&#x2F;format&#x2F;png&#x2F;crop&#x2F;!651x651a0a0&quot;&#125;;</span><br><span class="line"></span><br><span class="line">RCTRootView * rootView &#x3D; [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class="line">                                                         moduleName:@&quot;Test&quot;</span><br><span class="line">                                                  initialProperties:params</span><br><span class="line">                                                      launchOptions:nil];</span><br></pre></td></tr></table></figure>

<p>发送的值可以在<code>this.props</code>内得到,像上面的例子就是<code>this.props.image</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;View style&#x3D;&#123;[styles.tabContent,&#123;backgroundColor:color&#125;]&#125;&gt;</span><br><span class="line">            &lt;Text style&#x3D;&#123;styles.tabText&#125;&gt;&#123;pageText&#125;&lt;&#x2F;Text&gt;</span><br><span class="line">            &lt;Text style&#x3D;&#123;styles.tabText&#125;&gt;第&#123;num&#125;次重复渲染&#123;pageText&#125;&lt;&#x2F;Text&gt;</span><br><span class="line">            &lt;Text stype&#x3D;&#123;styles.tabText&#125;&gt;&#123;this._renderImage(this.props.image)&#125;&lt;&#x2F;Text&gt;</span><br><span class="line">&lt;&#x2F;View&gt;</span><br></pre></td></tr></table></figure>

<h3 id="RN传值到原生"><a href="#RN传值到原生" class="headerlink" title="RN传值到原生"></a>RN传值到原生</h3><p>原生代码实现协议<code>RCTBridgeModule</code>,如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;React&#x2F;RCTBridgeModule.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ReactViewController : UIViewController&lt;RCTBridgeModule&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>添加方法,下面代码中的<code>testPassValue</code>给这个Controller声明一个<code>testPassValue</code>方法,在RN中可以调用这个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 导出模块</span><br><span class="line">RCT_EXPORT_MODULE(); &#x2F;&#x2F; 此处不添加参数默认为这个类的类名</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_METHOD(testPassValue:(NSString *)value)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RN中调用原生的<code>testPassValue</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    NativeModules,</span><br><span class="line">&#125; from &#39;react-native&#39;;</span><br><span class="line"></span><br><span class="line">var ReactViewController &#x3D; NativeModules.ReactViewController;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方法调用</span><br><span class="line">ReactViewController.testPassValue(&#39;I pass this value to controller&#39;);</span><br></pre></td></tr></table></figure>

<p>注意: RN调用原生方法的时候,如果涉及到UI操作,记得使用<code>dispatch_async(dispatch_get_main_queue(), ^&#123;&#125;);</code>拉回主线程,另外在被调用方法中调用的self的地址和真正的这个controller的地址是不一样的,所以在进入RN的controller的时候要把self保存起来,比如另外创建一个单例之类的,然后RN回调原生的时候取出控制器对象才可使用.</p>
<p>类似下面这个例子是pop掉RN所在的控制器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 保存到单例</span><br><span class="line">    [RNSingleton sharedInstance].rnvc &#x3D; self;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">    self.navigationController.navigationBarHidden &#x3D; YES;</span><br><span class="line">    NSString * strUrl &#x3D; @&quot;http:&#x2F;&#x2F;localhost:8081&#x2F;index.ios.bundle?platform&#x3D;ios&amp;dev&#x3D;true&quot;;</span><br><span class="line">    NSURL * jsCodeLocation &#x3D; [NSURL URLWithString:strUrl];</span><br><span class="line">    </span><br><span class="line">    RCTRootView * rootView &#x3D; [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class="line">                                                         moduleName:@&quot;Test&quot;</span><br><span class="line">                                                  initialProperties:self.params</span><br><span class="line">                                                      launchOptions:nil];</span><br><span class="line">    self.view &#x3D; rootView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 导出模块</span><br><span class="line">RCT_EXPORT_MODULE(); &#x2F;&#x2F; 此处不添加参数默认为这个类的类名</span><br><span class="line"></span><br><span class="line">RCT_EXPORT_METHOD(testPassValue:(NSString *)value)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,value);</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[RNSingleton sharedInstance].rnvc.navigationController popViewControllerAnimated:YES];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative网络请求</title>
    <url>/post/b6bd206a.html</url>
    <content><![CDATA[<p>关于React Native 的网络请求的总结</p>
<span id="more"></span>

<p>因为这里使用的是<code>fetch()</code>方法,返回的是一个<code>Promise</code>对象,所以可以使用<code>then()</code>和<code>catch()</code>方法进行链式调用,也可以用<code>all()</code>,<code>race()</code> 去包装多个请求</p>
<p>具体的话可以看这里</p>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fetch(&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;get&quot;)</span><br><span class="line">	.then((response) &#x3D;&gt; response.json()) &#x2F;&#x2F; 这里取出响应体的JSON数据并返回</span><br><span class="line">	.then((responseJSON) &#x3D;&gt; &#123; &#x2F;&#x2F; 处理上面返回的JSON数据</span><br><span class="line">		&#x2F;&#x2F; do something</span><br><span class="line">		</span><br><span class="line">	&#125;)</span><br><span class="line">	.catch((err) &#x3D;&gt; &#123; &#x2F;&#x2F; 捕获错误</span><br><span class="line">		&#x2F;&#x2F; catch err</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>网上说有两种,不过我一般用第二种比较多</p>
<h4 id="application-json"><a href="#application-json" class="headerlink" title="application/json"></a>application/json</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fetchOptions &#x3D; &#123;</span><br><span class="line">           method: &#39;POST&#39;,</span><br><span class="line">           headers: &#123;</span><br><span class="line">               &#39;Accept&#39;: &#39;application&#x2F;json&#39;,</span><br><span class="line">               &#x2F;&#x2F;json形式</span><br><span class="line">               &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;</span><br><span class="line">           &#125;,</span><br><span class="line">           body:JSON.stringify(&#39;data&#x3D;test&#39;) &#x2F;&#x2F; 这里是请求参数,键值对形式</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">fetch(&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;post&quot;, fetchOptions)</span><br><span class="line">   .then((response) &#x3D;&gt; response.json())</span><br><span class="line">   .then((responseText) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(responseText);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> var fetchOptions &#x3D; &#123;</span><br><span class="line">           method: &#39;POST&#39;,</span><br><span class="line">           headers: &#123;</span><br><span class="line">               &#39;Accept&#39;: &#39;application&#x2F;json&#39;,</span><br><span class="line">               &#x2F;&#x2F;表单</span><br><span class="line">               &#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39;</span><br><span class="line">           &#125;,</span><br><span class="line">           body:&#39;data&#x3D;test&#39; &#x2F;&#x2F; 这里是请求参数,键值对形式</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">fetch(&quot;http:&#x2F;&#x2F;localhost:3000&#x2F;post&quot;, fetchOptions)</span><br><span class="line">   .then((response) &#x3D;&gt; response.json())</span><br><span class="line">   .then((responseText) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(responseText);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>如果使用的是Restful的API的话,那么只要把上面<code>fetchOption</code>里面的<code>method</code>改成对应的方法就好.</p>
<p>当然,封装一个网络请求工具是有必要的,等我有时间写一下.</p>
]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title>RAC关于cell上的按钮点击后会重复发送信号的问题</title>
    <url>/post/452efb32.html</url>
    <content><![CDATA[<p>关于cell上的按钮点击后会重复发送信号的问题</p>
<p>RAC给<code>UITableViewCell</code>提供了一个方法：<code>rac_prepareForReuseSignal</code>，它的作用是当Cell即将要被重用时，告诉Cell。想象Cell上有多个button，Cell在初始化时给每个button都<code>addTarget:action:forControlEvents</code>，被重用时需要先移除这些target，下面这段代码就可以很方便地解决这个问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[[self.cancelButton</span><br><span class="line">    rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">    takeUntil:self.rac_prepareForReuseSignal]</span><br><span class="line">    subscribeNext:^(UIButton *x) &#123;</span><br><span class="line">    &#x2F;&#x2F; do other things</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Sign in with Apple接入指南</title>
    <url>/post/ac0a85bd.html</url>
    <content><![CDATA[<p>如果你的应用接入了第三方登陆，那么请同时接入苹果登录。</p>
<span id="more"></span>

<p><a href="https://developer.apple.com/app-store/review/guidelines/#sign-in-with-apple">苹果审核指南的相关内容</a><br><a href="https://developer.apple.com/news/?id=09122019b">新闻：2020年4月前需要适配好苹果登录</a></p>
<h2 id="简单接入"><a href="#简单接入" class="headerlink" title="简单接入"></a>简单接入</h2><p><a href="https://developer.apple.com/sign-in-with-apple/">苹果登录官方文档</a></p>
<p>流程：</p>
<p>用户点击按钮 — 调起苹果登录 — 授权成功 — 获取唯一标识符和其他信息 — 返回给后端 — 后端注册/登录 — 返回token — 登录成功</p>
<h3 id="必要的工作"><a href="#必要的工作" class="headerlink" title="必要的工作"></a>必要的工作</h3><ol>
<li><p>首先去苹果后台开启<code>Sign in with apple</code>选项，然后重新导出<code>provisionprofile</code>证书</p>
</li>
<li><p>授权</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ASAuthorizationAppleIDProvider *provider &#x3D; [[ASAuthorizationAppleIDProvider alloc] init];</span><br><span class="line">ASAuthorizationAppleIDRequest *request &#x3D; [provider createRequest];</span><br><span class="line">request.requestedScopes &#x3D; @[ASAuthorizationScopeFullName, ASAuthorizationScopeEmail];</span><br><span class="line"></span><br><span class="line">NSMutableArray &lt;ASAuthorizationRequest *&gt;* array &#x3D; [NSMutableArray arrayWithCapacity:2];</span><br><span class="line">if (request) [array addObject:request];</span><br><span class="line"></span><br><span class="line">NSArray&lt;ASAuthorizationRequest *&gt; *requests &#x3D; [array copy];</span><br><span class="line">ASAuthorizationController *authorizationController &#x3D; [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];</span><br><span class="line">authorizationController.delegate &#x3D; self;</span><br><span class="line">authorizationController.presentationContextProvider &#x3D; input;</span><br><span class="line">[authorizationController performRequests];</span><br></pre></td></tr></table></figure></li>
<li><p>回调，遵循回调<code>ASAuthorizationControllerPresentationContextProviding</code></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization API_AVAILABLE(ios(13.0))</span><br><span class="line">&#123;</span><br><span class="line">if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) &#123;</span><br><span class="line">	&#x2F;&#x2F; 用户登录使用ASAuthorizationAppleIDCredential</span><br><span class="line">	ASAuthorizationAppleIDCredential *appleIDCredential &#x3D; (ASAuthorizationAppleIDCredential *)authorization.credential;</span><br><span class="line">	NSString *user &#x3D; appleIDCredential.user;</span><br><span class="line">	NSString *namePerfix &#x3D; appleIDCredential.fullName.namePrefix;</span><br><span class="line">	NSString *givenName &#x3D; appleIDCredential.fullName.givenName;</span><br><span class="line">	NSString *middleName &#x3D; appleIDCredential.fullName.middleName;</span><br><span class="line">	NSString *familyName &#x3D; appleIDCredential.fullName.familyName;</span><br><span class="line">	NSString *nameSuffix &#x3D; appleIDCredential.fullName.nameSuffix;</span><br><span class="line">	NSString *email &#x3D; appleIDCredential.email;</span><br><span class="line">	NSString *nickname &#x3D; appleIDCredential.fullName.nickname;</span><br><span class="line"></span><br><span class="line">	if (!nickname || nickname.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		nickname &#x3D; [NSString stringWithFormat:@&quot;%@%@%@%@%@&quot;,namePerfix?:@&quot;&quot;,familyName?:@&quot;&quot;,givenName?:@&quot;&quot;,middleName?:@&quot;&quot;,nameSuffix?:@&quot;&quot;];</span><br><span class="line">	&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	[self.errorSubject sendNext:LMError(@&quot;授权信息有误&quot;)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithError:(NSError *)error API_AVAILABLE(ios(13.0))</span><br><span class="line">&#123;</span><br><span class="line">NSString *errorMsg &#x3D; nil;</span><br><span class="line">switch (error.code) &#123;</span><br><span class="line">	case ASAuthorizationErrorCanceled:</span><br><span class="line">			errorMsg &#x3D; @&quot;用户取消了授权请求&quot;;</span><br><span class="line">			return;</span><br><span class="line">		case ASAuthorizationErrorFailed:</span><br><span class="line">			errorMsg &#x3D; @&quot;授权请求失败&quot;;</span><br><span class="line">			break;</span><br><span class="line">		case ASAuthorizationErrorInvalidResponse:</span><br><span class="line">			errorMsg &#x3D; @&quot;授权请求响应无效&quot;;</span><br><span class="line">			break;</span><br><span class="line">		case ASAuthorizationErrorNotHandled:</span><br><span class="line">			errorMsg &#x3D; @&quot;未能处理授权请求&quot;;</span><br><span class="line">			break;</span><br><span class="line">		case ASAuthorizationErrorUnknown:</span><br><span class="line">			errorMsg &#x3D; @&quot;授权请求失败未知原因&quot;;</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	[self.errorSubject sendNext:LMError(errorMsg)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="其他可选项"><a href="#其他可选项" class="headerlink" title="其他可选项"></a>其他可选项</h2><h3 id="苹果提供的登录按钮"><a href="#苹果提供的登录按钮" class="headerlink" title="苹果提供的登录按钮"></a>苹果提供的登录按钮</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ASAuthorizationAppleIDButton *button &#x3D; [ASAuthorizationAppleIDButton buttonWithType:ASAuthorizationAppleIDButtonTypeSignIn style:ASAuthorizationAppleIDButtonStyleWhiteOutline];</span><br></pre></td></tr></table></figure>

<p>其中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonType) &#123;</span><br><span class="line">    ASAuthorizationAppleIDButtonTypeSignIn, &#x2F;&#x2F; 按钮文字显示 ：通过Apple登录</span><br><span class="line">    ASAuthorizationAppleIDButtonTypeContinue, &#x2F;&#x2F; 按钮文字显示 ：通过Apple继续</span><br><span class="line"></span><br><span class="line">    ASAuthorizationAppleIDButtonTypeDefault &#x3D; &#x2F;&#x2F; 默认第一个 ASAuthorizationAppleIDButtonTypeSignIn,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, ASAuthorizationAppleIDButtonStyle) &#123;</span><br><span class="line">    ASAuthorizationAppleIDButtonStyleWhite, &#x2F;&#x2F; 白底黑字</span><br><span class="line">    ASAuthorizationAppleIDButtonStyleWhiteOutline, &#x2F;&#x2F; 黑字白框</span><br><span class="line">    ASAuthorizationAppleIDButtonStyleBlack, &#x2F;&#x2F; 黑底白字</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="授权成功的回调可以来自于其他地方"><a href="#授权成功的回调可以来自于其他地方" class="headerlink" title="授权成功的回调可以来自于其他地方"></a>授权成功的回调可以来自于其他地方</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;! 授权成功地回调</span><br><span class="line">- (void)authorizationController:(ASAuthorizationController *)controller didCompleteWithAuthorization:(ASAuthorization *)authorization  API_AVAILABLE(ios(13.0))&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    NSLog(@&quot;%@&quot;, controller);</span><br><span class="line">    NSLog(@&quot;%@&quot;, authorization);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;authorization.credential：%@&quot;, authorization.credential);</span><br><span class="line">    </span><br><span class="line">    NSMutableString *mStr &#x3D; [NSMutableString string];</span><br><span class="line">    mStr &#x3D; [_appleIDInfoTextView.text mutableCopy];</span><br><span class="line">    </span><br><span class="line">    if ([authorization.credential isKindOfClass:[ASAuthorizationAppleIDCredential class]]) &#123;</span><br><span class="line">        &#x2F;&#x2F; 用户登录使用ASAuthorizationAppleIDCredential</span><br><span class="line">        ASAuthorizationAppleIDCredential *appleIDCredential &#x3D; authorization.credential;</span><br><span class="line">        NSString *user &#x3D; appleIDCredential.user;</span><br><span class="line">        &#x2F;&#x2F;  最好使用钥匙串的方式保存用户的唯一信息 这里暂且处于测试阶段，用NSUserDefaults</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] setValue:user forKey:QiShareCurrentIdentifier];</span><br><span class="line">        [mStr appendString:user?:@&quot;&quot;];</span><br><span class="line">        NSString *familyName &#x3D; appleIDCredential.fullName.familyName;</span><br><span class="line">        [mStr appendString:familyName?:@&quot;&quot;];</span><br><span class="line">        NSString *givenName &#x3D; appleIDCredential.fullName.givenName;</span><br><span class="line">        [mStr appendString:givenName?:@&quot;&quot;];</span><br><span class="line">        NSString *email &#x3D; appleIDCredential.email;</span><br><span class="line">        [mStr appendString:email?:@&quot;&quot;];</span><br><span class="line">        NSLog(@&quot;mStr：%@&quot;, mStr);</span><br><span class="line">        [mStr appendString:@&quot;\n&quot;];</span><br><span class="line">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class="line">        </span><br><span class="line">    &#125; else if ([authorization.credential isKindOfClass:[ASPasswordCredential class]]) &#123;</span><br><span class="line">        &#x2F;&#x2F; 用户登录使用现有的密码凭证</span><br><span class="line">        ASPasswordCredential *passwordCredential &#x3D; authorization.credential;</span><br><span class="line">        &#x2F;&#x2F; 密码凭证对象的用户标识 用户的唯一标识</span><br><span class="line">        NSString *user &#x3D; passwordCredential.user;</span><br><span class="line">        &#x2F;&#x2F; 密码凭证对象的密码</span><br><span class="line">        NSString *password &#x3D; passwordCredential.password;</span><br><span class="line">        [mStr appendString:user?:@&quot;&quot;];</span><br><span class="line">        [mStr appendString:password?:@&quot;&quot;];</span><br><span class="line">        [mStr appendString:@&quot;\n&quot;];</span><br><span class="line">        NSLog(@&quot;mStr：%@&quot;, mStr);</span><br><span class="line">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;授权信息均不符&quot;);</span><br><span class="line">        mStr &#x3D; [@&quot;授权信息均不符&quot; mutableCopy];</span><br><span class="line">        _appleIDInfoTextView.text &#x3D; mStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="已经使用Sign-In-With-Apple登录过app的用户"><a href="#已经使用Sign-In-With-Apple登录过app的用户" class="headerlink" title="已经使用Sign In With Apple登录过app的用户"></a>已经使用Sign In With Apple登录过app的用户</h3><p>执行已经登录过的场景。如果设备中存在iCloud Keychain 凭证或者AppleID 凭证提示用户直接使用TouchID或FaceID登录即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)perfomExistingAccountSetupFlows &#123;</span><br><span class="line">    if (@available(iOS 13.0, *)) &#123;</span><br><span class="line">        &#x2F;&#x2F; A mechanism for generating requests to authenticate users based on their Apple ID.</span><br><span class="line">        &#x2F;&#x2F; 基于用户的Apple ID授权用户，生成用户授权请求的一种机制</span><br><span class="line">        ASAuthorizationAppleIDProvider *appleIDProvider &#x3D; [ASAuthorizationAppleIDProvider new];</span><br><span class="line">        &#x2F;&#x2F; An OpenID authorization request that relies on the user’s Apple ID.</span><br><span class="line">        &#x2F;&#x2F; 授权请求依赖于用于的AppleID</span><br><span class="line">        ASAuthorizationAppleIDRequest *authAppleIDRequest &#x3D; [appleIDProvider createRequest];</span><br><span class="line">        &#x2F;&#x2F; A mechanism for generating requests to perform keychain credential sharing.</span><br><span class="line">        &#x2F;&#x2F; 为了执行钥匙串凭证分享生成请求的一种机制</span><br><span class="line">        ASAuthorizationPasswordRequest *passwordRequest &#x3D; [[ASAuthorizationPasswordProvider new] createRequest];</span><br><span class="line">        </span><br><span class="line">        NSMutableArray &lt;ASAuthorizationRequest *&gt;* mArr &#x3D; [NSMutableArray arrayWithCapacity:2];</span><br><span class="line">        if (authAppleIDRequest) &#123;</span><br><span class="line">            [mArr addObject:authAppleIDRequest];</span><br><span class="line">        &#125;</span><br><span class="line">        if (passwordRequest) &#123;</span><br><span class="line">            [mArr addObject:passwordRequest];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; ASAuthorizationRequest：A base class for different kinds of authorization requests.</span><br><span class="line">        &#x2F;&#x2F; ASAuthorizationRequest：对于不同种类授权请求的基类</span><br><span class="line">        NSArray &lt;ASAuthorizationRequest *&gt;* requests &#x3D; [mArr copy];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; A controller that manages authorization requests created by a provider.</span><br><span class="line">        &#x2F;&#x2F; 由ASAuthorizationAppleIDProvider创建的授权请求 管理授权请求的控制器</span><br><span class="line">        &#x2F;&#x2F; Creates a controller from a collection of authorization requests.</span><br><span class="line">        &#x2F;&#x2F; 从一系列授权请求中创建授权控制器</span><br><span class="line">        ASAuthorizationController *authorizationController &#x3D; [[ASAuthorizationController alloc] initWithAuthorizationRequests:requests];</span><br><span class="line">        &#x2F;&#x2F; A delegate that the authorization controller informs about the success or failure of an authorization attempt.</span><br><span class="line">        &#x2F;&#x2F; 设置授权控制器通知授权请求的成功与失败的代理</span><br><span class="line">        authorizationController.delegate &#x3D; self;</span><br><span class="line">        &#x2F;&#x2F; A delegate that provides a display context in which the system can present an authorization interface to the user.</span><br><span class="line">        &#x2F;&#x2F; 设置提供 展示上下文的代理，在这个上下文中 系统可以展示授权界面给用户</span><br><span class="line">        authorizationController.presentationContextProvider &#x3D; self;</span><br><span class="line">        &#x2F;&#x2F; starts the authorization flows named during controller initialization.</span><br><span class="line">        &#x2F;&#x2F; 在控制器初始化期间启动授权流</span><br><span class="line">        [authorizationController performRequests];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="监听授权状态变化"><a href="#监听授权状态变化" class="headerlink" title="监听授权状态变化"></a>监听授权状态变化</h3><p>监听授权状态改变，并且做出相应处理。授权状态有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ASAuthorizationAppleIDProviderCredentialRevoked：授权状态失效（用户停止使用AppID 登录App）</span><br><span class="line">ASAuthorizationAppleIDProviderCredentialAuthorized：已授权(已使用AppleID 登录过App）</span><br><span class="line">ASAuthorizationAppleIDProviderCredentialNotFound：授权凭证缺失（可能是使用AppleID 登录过App）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;! 观察授权状态</span><br><span class="line">- (void)observeAuthticationState &#123;</span><br><span class="line">    </span><br><span class="line">    if (@available(iOS 13.0, *)) &#123;</span><br><span class="line">        &#x2F;&#x2F; A mechanism for generating requests to authenticate users based on their Apple ID.</span><br><span class="line">        &#x2F;&#x2F; 基于用户的Apple ID 生成授权用户请求的机制</span><br><span class="line">        ASAuthorizationAppleIDProvider *appleIDProvider &#x3D; [ASAuthorizationAppleIDProvider new];</span><br><span class="line">        &#x2F;&#x2F; 注意 存储用户标识信息需要使用钥匙串来存储 这里笔者简单期间 使用NSUserDefaults 做的简单示例</span><br><span class="line">        NSString *userIdentifier &#x3D; [[NSUserDefaults standardUserDefaults] valueForKey:QiShareCurrentIdentifier];</span><br><span class="line">        </span><br><span class="line">        if (userIdentifier) &#123;</span><br><span class="line">            NSString* __block errorMsg &#x3D; nil;</span><br><span class="line">            &#x2F;&#x2F;Returns the credential state for the given user in a completion handler.</span><br><span class="line">            &#x2F;&#x2F; 在回调中返回用户的授权状态</span><br><span class="line">            [appleIDProvider getCredentialStateForUserID:userIdentifier completion:^(ASAuthorizationAppleIDProviderCredentialState credentialState, NSError * _Nullable error) &#123;</span><br><span class="line">                switch (credentialState) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 苹果证书的授权状态</span><br><span class="line">                    case ASAuthorizationAppleIDProviderCredentialRevoked:</span><br><span class="line">                        &#x2F;&#x2F; 苹果授权凭证失效</span><br><span class="line">                        errorMsg &#x3D; @&quot;苹果授权凭证失效&quot;;</span><br><span class="line">                        break;</span><br><span class="line">                    case ASAuthorizationAppleIDProviderCredentialAuthorized:</span><br><span class="line">                        &#x2F;&#x2F; 苹果授权凭证状态良好</span><br><span class="line">                        errorMsg &#x3D; @&quot;苹果授权凭证状态良好&quot;;</span><br><span class="line">                        break;</span><br><span class="line">                    case ASAuthorizationAppleIDProviderCredentialNotFound:</span><br><span class="line">                        &#x2F;&#x2F; 未发现苹果授权凭证</span><br><span class="line">                        errorMsg &#x3D; @&quot;未发现苹果授权凭证&quot;;</span><br><span class="line">                        &#x2F;&#x2F; 可以引导用户重新登录</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    NSLog(@&quot;SignInWithApple授权状态变化情况&quot;);</span><br><span class="line">                    NSLog(@&quot;%@&quot;, errorMsg);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用通知的方式检测是否授权应用支持Sign In With Apple变化情况。如下的代码可以根据自己的业务场景去考虑放置的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;! 添加苹果登录的状态通知</span><br><span class="line">- (void)observeAppleSignInState &#123;</span><br><span class="line">    if (@available(iOS 13.0, *)) &#123;</span><br><span class="line">        NSNotificationCenter *center &#x3D; [NSNotificationCenter defaultCenter];</span><br><span class="line">        [center addObserver:self selector:@selector(handleSignInWithAppleStateChanged:) name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;! 观察SignInWithApple状态改变</span><br><span class="line">- (void)handleSignInWithAppleStateChanged:(id)noti &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">    NSLog(@&quot;%@&quot;, noti);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    </span><br><span class="line">    if (@available(iOS 13.0, *)) &#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] removeObserver:self name:ASAuthorizationAppleIDProviderCredentialRevokedNotification object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重要（Important！）"><a href="#重要（Important！）" class="headerlink" title="重要（Important！）"></a>重要（Important！）</h2><ol>
<li>最好使用苹果提供的按钮 <code>ASAuthorizationAppleIDButton</code> （只有黑白两种颜色）</li>
<li>不用他的按钮的话建议使用显眼的颜色 </li>
<li>尽量放在显眼位置（第一位）</li>
<li><strong>不能比其他任何登录按钮要小</strong></li>
<li>保证登录页面一屏就能看到苹果登录按钮，不能滚动后才能看到</li>
<li>按钮的最小宽高有需求（看<a href="https://developer.apple.com/design/human-interface-guidelines/sign-in-with-apple/overview/">苹果人机交互指南相关文档</a>）</li>
<li>如果登录后要绑定手机的话，就在备注里面写好 依据来源 <a href="http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm">http://www.cac.gov.cn/2016-11/07/c_1119867116_2.htm</a>  指明(截图)第二十四条（苹果一般不会打开网页，建议下载个pdf给他）</li>
<li>如果不好好跟苹果爸爸的规矩来，那么可能会吃到2.1和4.0 (不要问我为什么知道)</li>
</ol>
<p>(更新至2019/11/01)</p>
<table>
<thead>
<tr>
<th>最小宽度</th>
<th>最小高度</th>
<th>最小间距</th>
</tr>
</thead>
<tbody><tr>
<td>140pt (140px @1x, 280px @2x)</td>
<td>30pt (30px @1x, 60px @2x)</td>
<td>1/10 of the button’s height）</td>
</tr>
</tbody></table>
<h2 id="参考其他教程"><a href="#参考其他教程" class="headerlink" title="参考其他教程"></a>参考其他教程</h2><p><a href="https://juejin.im/post/5d8c64d151882509606d6b17">掘金</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Salesforce SDK Bug</title>
    <url>/post/e88dc875.html</url>
    <content><![CDATA[<p>Salesforce SDK 有几个bug 不修复的话跑不起来 所以在这里记录一下</p>
<span id="more"></span>

<ol>
<li><code>SFOAuthCoordinator</code> 960行 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ([self isRedirectURL:requestUrl]) &#123;</span><br><span class="line">     [self handleUserAgentResponse:url];</span><br><span class="line">     decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">     return;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>SFSDKLoginHostListViewController</code> <code>viewDidLoad</code>最下面的注册cell移动到<code>viewDidLoad</code>的第一行</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Salesforce</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI指南</title>
    <url>/post/f6762f39.html</url>
    <content><![CDATA[<p>iOS 13 SwiftUI 指南</p>
<span id="more"></span>

<h3 id="布局方向"><a href="#布局方向" class="headerlink" title="布局方向"></a>布局方向</h3><h4 id="VStack-垂直布局"><a href="#VStack-垂直布局" class="headerlink" title="VStack 垂直布局"></a>VStack 垂直布局</h4><p>默认垂直方向居中布局</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VStack &#123;</span><br><span class="line">	Text(&quot;默认居中&quot;)</span><br><span class="line">	Text(&quot;Hello, World!&quot;)</span><br><span class="line">	Text(&quot;Hello, World Again!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对齐方向参数可选(<code>.leading</code>,<code>.trailing</code>,<code>.center</code>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VStack(alignment:.leading) &#123;</span><br><span class="line">	Text(&quot;左对齐&quot;)</span><br><span class="line">	Text(&quot;Hello, World!&quot;)</span><br><span class="line">	Text(&quot;Hello, World Again!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HStack-水平布局"><a href="#HStack-水平布局" class="headerlink" title="HStack 水平布局"></a>HStack 水平布局</h4><p>默认水平方向居中布局</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HStack &#123;</span><br><span class="line">	Text(&quot;默认居中&quot;)</span><br><span class="line">	Text(&quot;Hello, World!&quot;)</span><br><span class="line">	Text(&quot;Hello, World Again!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对齐方向参数可选(<code>.top</code>,<code>.bottom</code>,<code>.center</code>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HStack(alignment:.bottom) &#123;</span><br><span class="line">	Text(&quot;左对齐&quot;)</span><br><span class="line">	Text(&quot;Hello, World!&quot;)</span><br><span class="line">	Text(&quot;Hello, World Again!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ZStack-前后布局"><a href="#ZStack-前后布局" class="headerlink" title="ZStack 前后布局"></a>ZStack 前后布局</h3><p>代码下面内容的盖住上面的内容</p>
<p>默认水平居中&amp;垂直居中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZStack &#123;</span><br><span class="line">	Text(&quot;默认居中&quot;)</span><br><span class="line">	Text(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对齐方向参数可选(<code>.leading</code>,<code>.trailing</code>,<code>.top</code>,<code>.bottom</code>,<code>.topLeading</code>,<code>.topTrailing</code>,<code>.bottomLeading</code>,<code>.bottomTrailing</code>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZStack(alignment:.bottom) &#123;</span><br><span class="line">	Text(&quot;底部对齐&quot;)</span><br><span class="line">	Text(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h3><p>内边距，用来撑开你的布局</p>
<p>默认撑开上下左右各16pt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZStack&#123;</span><br><span class="line">	Text(&quot;默认居中&quot;).padding()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以指定哪个位置撑开和数值大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZStack&#123;</span><br><span class="line">	Text(&quot;默认居中&quot;).padding(20) &#x2F;&#x2F; 上下左右均撑开20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZStack&#123;</span><br><span class="line">	Text(&quot;默认居中&quot;).padding(.leading: 20) &#x2F;&#x2F; 左边撑开20，其他同理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZStack&#123;</span><br><span class="line">	Text(&quot;默认居中&quot;).padding([.leading,.trailing],50).fixedSize() &#x2F;&#x2F; 左边和右边都撑开50，其他同理，fixedSize意思等同于UILabel的sizeToFit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZStack&#123;</span><br><span class="line">	Text(&quot;默认居中&quot;).padding(.leading, 10).padding(.top, 20) &#x2F;&#x2F; 左边10，上边20，其他同理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spacer"><a href="#Spacer" class="headerlink" title="Spacer"></a>Spacer</h3><p>用来填充空位。</p>
<p>因为SwiftUI不像原来的UI开发，是先设置好frame,再往里面添加东西，相反，他是一种先紧紧包住控件，然后通过padding、spacer等元素去“撑开”视图的思想。所以，Spacer在这里有点类似于UIBarButtonItem里的那个<code>UIBarButtonSystemItemFlexibleSpace</code>,就是把东西给撑开。</p>
<p>举个例子</p>
<p>水平界面这时候布局紧紧包裹着Text控件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HStack &#123;</span><br><span class="line">	Text(&quot;Hello, World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这时候加一个Spacer,那么Text控件就会靠左，右边部分会被Spacer把剩余空隙填满</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HStack &#123;</span><br><span class="line">	Text(&quot;Hello, World!&quot;)</span><br><span class="line">	Spacer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理如果是<code>VStack</code>，写在下面的话，自然就会把Text控件往上顶，然后把剩余屏幕部分填满。</p>
<h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p>直接输入图片名就可以引用本地图片<br><code>Image(&quot;bg_nuanxin_mask&quot;)</code></p>
<h4 id="resizeable"><a href="#resizeable" class="headerlink" title="resizeable"></a>resizeable</h4><p><code>Image(&quot;bg_nuanxin_mask&quot;).resizable()</code></p>
<p>把图片撑开</p>
<h3 id="隐藏NavigationBar"><a href="#隐藏NavigationBar" class="headerlink" title="隐藏NavigationBar"></a>隐藏NavigationBar</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NavigationView &#123;</span><br><span class="line">	ZStack &#123;</span><br><span class="line">		&#x2F;&#x2F;...</span><br><span class="line">	&#125;</span><br><span class="line">	.navigationBarHidden(true)</span><br><span class="line">	.navigationBarTitle(&quot;&quot;)</span><br><span class="line">	.navigationBarBackButtonHidden(true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这个界面不显示，下个界面要显示导航栏"><a href="#这个界面不显示，下个界面要显示导航栏" class="headerlink" title="这个界面不显示，下个界面要显示导航栏"></a>这个界面不显示，下个界面要显示导航栏</h4><p>当前页面声明一个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@State private var navBarHidden &#x3D; true</span><br></pre></td></tr></table></figure>

<p>目标页面加一个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Binding var navBarHidden : Bool</span><br></pre></td></tr></table></figure>

<p>传值过去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NavigationLink(destination:xxxx, navBarHidden: $navBarHidden)) &#123;</span><br><span class="line">   xxxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目标页面处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var body: some View &#123;</span><br><span class="line">	WebView(webUrl:&quot;https:&#x2F;&#x2F;www.baidu.com&quot;,title: $title)</span><br><span class="line">	.onAppear &#123;</span><br><span class="line">		self.navBarHidden &#x3D; false</span><br><span class="line">	&#125;</span><br><span class="line">	.onDisappear &#123;</span><br><span class="line">		self.navBarHidden &#x3D; true</span><br><span class="line">	&#125;</span><br><span class="line">	.navigationBarTitle(Text(title),displayMode: .inline)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="导航栏标题样式"><a href="#导航栏标题样式" class="headerlink" title="导航栏标题样式"></a>导航栏标题样式</h4><p>普通</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.navigationBarTitle(Text(title),displayMode: .inline)</span><br></pre></td></tr></table></figure>

<p>特大</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.navigationBarTitle(Text(title),displayMode: .large)</span><br></pre></td></tr></table></figure>

<p>随滚动自动变化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.navigationBarTitle(Text(title),displayMode: .automatic)</span><br></pre></td></tr></table></figure>

<h3 id="需要用到的一些快捷键"><a href="#需要用到的一些快捷键" class="headerlink" title="需要用到的一些快捷键"></a>需要用到的一些快捷键</h3><p>cmd + ctrl + 鼠标左键+控件/布局  =  调出菜单<br>ctrl + i = 代码缩进调整    </p>
<p>待续</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell 笔记</title>
    <url>/post/cfe784af.html</url>
    <content><![CDATA[<p>Shell 笔记，有机会写就会继续补充</p>
<span id="more"></span>

<ol>
<li>if语句的中括号要留空格  <code>if空格[空格 判断语句 空格]; then xxx fi</code> </li>
<li>判断买某个路径是否是文件夹  <code>if [ -d “./xxx” ]; then xxx fi</code></li>
<li>建立一个数组 <code>check=(&quot;Wechat&quot; &quot;Ali&quot; &quot;Union&quot; &quot;Pay&quot;)</code></li>
<li>声明一个函数, 并取得第一个参数 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function xxx() &#123;</span><br><span class="line">	dir&#x3D;$1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>获得某个后缀名的文件 <code>directory=./$&#123;d%.*&#125;&quot;.app&quot;</code></li>
<li>执行某个命令但不输出到控制台 <code>unzip $xxx &gt; /dev/null 2&gt;&amp;1</code></li>
<li>声明某个变量为局部变量，使用<code>local</code>关键字 <code>local dir=$1</code></li>
<li>大写转小写 <code>local file_name_lower=$(echo $file_name | tr &#39;A-Z&#39; &#39;a-z&#39;)</code></li>
<li>小写转大写 <code>local file_name_lower=$(echo $file_name | tr &#39;a-z&#39; &#39;A-Z&#39;)</code></li>
<li>遍历数组<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for item in $&#123;check[@]&#125;; do</span><br><span class="line">    echo $item</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
<li>字符串A是否包含字符串B <code>if[[ $A =~ $B ]]; then xxx fi</code></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title> UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃的问题</title>
    <url>/post/1787ee1c.html</url>
    <content><![CDATA[<p>UISplitViewController在竖屏情况下叫出PopoverView后Dissmiss崩溃</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-[UIPopoverController dealloc] reached while popover is still visible.</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>错误的大体意思是：popover在仍旧可见的时候被销毁了（调用了dealloc）</p>
<p>从错误可以得出的结论<br>当popover仍旧可见的时候，不准销毁popover对象<br>在销<br>毁popover对象之前，一定先让popover消失（不可见）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (retain, nonatomic) UIPopoverController *popoverController;</span><br><span class="line"></span><br><span class="line">- (void)splitViewController:(UISplitViewController *)svc willHideViewController:(UIViewController *)aViewController withBarButtonItem:(UIBarButtonItem *)barButtonItem forPopoverController:(UIPopoverController *)pc</span><br><span class="line">&#123;</span><br><span class="line">    self.popoverController &#x3D; pc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dismissViewControllerAnimated:(BOOL)flag completion:(void (^)(void))completion</span><br><span class="line">&#123;</span><br><span class="line">    [self.popoverController dismissPopoverAnimated:YES];</span><br><span class="line">    [super dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>URLWithString返回空</title>
    <url>/post/890a3088.html</url>
    <content><![CDATA[<p><code>[NSURL URLWithString:@”…………”]</code> 返回空 nil<br>但是貌似汉字或者空格等无法被识别，String不被认为是URLString，这个NSURL的值也就一直是nil<br>要怎样才能够让它识别呢？<br>解决方法如下 ：</p>
<ol>
<li>转换编码</li>
</ol>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str1 &#x3D; [str1 stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">NSURL *url &#x3D; [NSURL URLWithString:[Tool returnFormatString:str1]];</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>除去空格</li>
</ol>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+(NSString *)returnFormatString:(NSString *)str</span><br><span class="line">&#123;</span><br><span class="line">    return [str stringByReplacingOccurrencesOfString:@&quot; &quot;withString:@&quot; &quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> NSLog(@&quot;URL&#x3D;&#x3D;%@&quot;,url);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactiveCocoa解决异步串行任务执行中多层嵌套/递归的问题</title>
    <url>/post/5f5664e4.html</url>
    <content><![CDATA[<p>因为在项目中遇到了一个异步的串行任务执行的问题,通过ReactiveCocoa解决了,所以在这里记录一下</p>
<span id="more"></span>

<p>首先是一个第三方的API,这个API会进行一个网络请求,并且使用block进行回调.批量执行并且是串行执行.<br>如果不用RAC,我们可以通过递归,当任务一结束的时候递归执行任务二,以达到串行的效果,然后判断索引达到最后的时候跳出递归,但这种操作如果一多容易造成栈溢出,所以用RAC的优化如下.</p>
<p>首先使用一个<code>RACSignal</code>包装API,如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (RACSignal *)deleteWithId:(NSString *)identifier</span><br><span class="line">&#123;</span><br><span class="line">    RACSignal *signal &#x3D; [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        GTLQueryDrive *query &#x3D; [GTLQueryDrive queryForFilesDeleteWithFileId:identifier];</span><br><span class="line">        [self.service executeQuery:query completionHandler:^(GTLServiceTicket *ticket, id object, NSError *error) &#123;</span><br><span class="line">            if(!error) &#123;</span><br><span class="line">                [subscriber sendNext:nil];</span><br><span class="line">                [subscriber sendCompleted];</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                [subscriber sendError:error]; &#x2F;&#x2F; 失败的时候抛出异常</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    return signal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来把多个任务组装成一个数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray *signals &#x3D; [NSMutableArray array];</span><br><span class="line">for (NSString *identifier in identifiers) &#123;</span><br><span class="line">    RACSignal * signal &#x3D; [self deleteWithId:identifier];</span><br><span class="line">    [signals addObject:signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后使用<code>RACSignal</code>的<code>concat</code>方法</p>
<p><code>concat</code>会顺序执行数组中的信号内容,上一个signal的信号<code>sendComplete</code>之后下一个信号内容才会开始执行</p>
<p>因为我们要在任务全部执行完成的时候发送一个回调和任务执行到一半的时候抛出异常停止任务和队列.<br>所以我们顺便加一个<code>doCompleted</code>和<code>catch</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSignal *concatSignal &#x3D; [[[RACSignal concat:signals] doCompleted:^&#123;</span><br><span class="line">       completeBlock(nil); &#x2F;&#x2F; 回调告诉前台说所有任务都完成了</span><br><span class="line">   &#125;] catch:^RACSignal *(NSError *error) &#123;</span><br><span class="line">       completeBlock(error); &#x2F;&#x2F; 回调告诉前台说异常了</span><br><span class="line">       return [RACSignal empty]; &#x2F;&#x2F; 停止当前和接下来的任务的执行</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>

<p>如果你要订阅concatSignal信号的时候用到了UI刷新或者其他需要在主线程执行的任务,那么这里可以加多一个<code>deliverOn:[RACScheduler mainThreadScheduler]]</code></p>
<p>所以最后的信号可能是这样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSignal *concatSignal &#x3D; [[[[RACSignal concat:signals] doCompleted:^&#123;</span><br><span class="line">    completeBlock(nil);</span><br><span class="line">&#125;] catch:^RACSignal *(NSError *error) &#123;</span><br><span class="line">    completeBlock(error);</span><br><span class="line">    return [RACSignal empty];</span><br><span class="line">&#125;] deliverOn:[RACScheduler mainThreadScheduler]];</span><br></pre></td></tr></table></figure>

<p>那订阅信号就简单了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[concatSignal subscribeNext:^(id x) &#123;</span><br><span class="line">    DKLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>执行的时候他会根据数组的顺序一个个执行信号内的内容,这样子写起来也好看了很多.</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Reactive Cocoa</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache强制https </title>
    <url>/post/f6ce3122.html</url>
    <content><![CDATA[<p>当用户访问http的地址的时候，Apache如何强制跳转到https地址</p>
<span id="more"></span>

<p>修改httpd.conf</p>
<ol>
<li>LoadModule rewrite_module modules/mod_rewrite.so 这个拓展貌似是已经被加载了；</li>
<li>修改Apache默认项目路径的这个</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>其实是修改为项目发布的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;html&#x2F;app&#x2F;src&#x2F;htdocs_www&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>改为All</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AllowOverride All</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># </span><br><span class="line"># Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, </span><br><span class="line"># or any combination of: </span><br><span class="line"># Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews </span><br><span class="line"># </span><br><span class="line"># Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; </span><br><span class="line"># doesn&#39;t give it to you. </span><br><span class="line"># </span><br><span class="line"># The Options directive is both complicated and important. Please see </span><br><span class="line"># http:&#x2F;&#x2F;httpd.apache.org&#x2F;docs&#x2F;2.2&#x2F;mod&#x2F;core.html</span><br><span class="line"># options </span><br><span class="line"># for more information. </span><br><span class="line"># Options Indexes FollowSymLinks </span><br><span class="line"># </span><br><span class="line"># AllowOverride controls what directives may be placed in .htaccess files. </span><br><span class="line"># It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: </span><br><span class="line"># Options FileInfo AuthConfig Limit </span><br><span class="line"># </span><br><span class="line"># </span><br><span class="line"># Controls who can get stuff from this server. </span><br><span class="line"># </span><br><span class="line">Order allow,deny </span><br><span class="line">Allow from all</span><br></pre></td></tr></table></figure>

<p>添加三行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RewriteEngine on</span><br><span class="line">RewriteCond %&#123;SERVER_PORT&#125; !^443$</span><br><span class="line">RewriteRule ^(.*)?$ https:&#x2F;&#x2F;%&#123;SERVER_NAME&#125;&#x2F;$1 [L,R]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue学习笔记</title>
    <url>/post/71513ccb.html</url>
    <content><![CDATA[<p>Vue.js 是一个用于构建用户界面的渐进式前端框架</p>
<span id="more"></span>

<h2 id="安装-vue-cli-命令行工具"><a href="#安装-vue-cli-命令行工具" class="headerlink" title="安装 vue-cli 命令行工具"></a>安装 vue-cli 命令行工具</h2><p> 安装Vue<br><code>npm install -g vue-cli</code></p>
<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>vue init webpack-simple 项目名</p>
<p>项目模板有很多种,这里用了webpack-simple webpack-simple 没有包括Eslint检查功能等等功能，webpack有,但是普通项目用webpack-simple就足够了.</p>
<p>构造Vue实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  &#x2F;&#x2F; 选项</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload&#x3D;function()&#123;</span><br><span class="line"> &#x2F;&#x2F;在这里面写Vue.js代码</span><br><span class="line"> new Vue(&#123;</span><br><span class="line">  el: &#39;#demo&#39;, &#x2F;&#x2F; 需要渲染的DOM元素</span><br><span class="line">  data: &#123;		 &#x2F;&#x2F; 渲染的数据,key-value方式</span><br><span class="line">    message: &#39;Hello Vue.js!&#39; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;----------------</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTML中数据绑定"><a href="#HTML中数据绑定" class="headerlink" title="HTML中数据绑定"></a>HTML中数据绑定</h2><h3 id="单次插值"><a href="#单次插值" class="headerlink" title="单次插值"></a>单次插值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;Message: &#123;&#123; message &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<p>如果想要单次插值,即今后的数据变化就不会再引起插值更新,加个 *</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;This will never change: &#123;&#123;* message &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">var data&#x3D;&#123;message:&#39;Hello Vue.js!&#39;&#125;;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#demo&#39;,</span><br><span class="line">  data: data</span><br><span class="line"> &#125;)</span><br><span class="line">data.message &#x3D;&quot;Hello World!&quot;;</span><br><span class="line">data.message &#x3D;&quot;Hello&quot;; &#x2F;&#x2F; 再次改变时候,第二个元素内的值不会变化</span><br><span class="line"></span><br><span class="line">HTML</span><br><span class="line"></span><br><span class="line">&lt;span&gt;This will never change: &#123;&#123; message &#125;&#125;&lt;&#x2F;span&gt;&lt;br&gt;</span><br><span class="line">&lt;span&gt;This will never change: &#123;&#123;* message &#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<h3 id="嵌入HTML"><a href="#嵌入HTML" class="headerlink" title="嵌入HTML"></a>嵌入HTML</h3><p>三个大括号表示不是插入文本而是html标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTML</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;&#123;&#123; msg &#125;&#125;&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">var data&#x3D;&#123;msg:&#39;&lt;p&gt;Hello Vue.js!&lt;&#x2F;p&gt;&#39;&#125;;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#39;#demo&#39;,</span><br><span class="line">    data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="HTMl特性"><a href="#HTMl特性" class="headerlink" title="HTMl特性"></a>HTMl特性</h3><p>比如说修改某个元素的id属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTML</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;&#123;&#123; id &#125;&#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">var data&#x3D;&#123;id:&#39;demo&#39;&#125;;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;div&#39;,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="JavaScript表达式"><a href="#JavaScript表达式" class="headerlink" title="JavaScript表达式"></a>JavaScript表达式</h3><p>绑定的数据支持JavaScript表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">window.onload&#x3D;function()&#123;</span><br><span class="line"> &#x2F;&#x2F;在这里面写Vue.js代码</span><br><span class="line"> var data&#x3D;&#123;message:&#39;Hello &#39;,number:3,ok:true&#125;;</span><br><span class="line"> new Vue(&#123;</span><br><span class="line">  el: &#39;#demo&#39;,</span><br><span class="line">  data: data</span><br><span class="line"> &#125;)</span><br><span class="line"> &#x2F;&#x2F;----------------</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&#39;demo&#39;&gt;</span><br><span class="line">&#123;&#123; number + 1 &#125;&#125;&lt;br&#x2F;&gt;</span><br><span class="line">&#123;&#123; ok ? &#39;YES&#39; : &#39;NO&#39; &#125;&#125;&lt;br&#x2F;&gt;</span><br><span class="line">&#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">olleH</span><br></pre></td></tr></table></figure>

<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>使用管道符 |</p>
<p>将message内的全部转换为小写字母</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; message | lowercase &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>转为小写字母后,首字母大写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;msg | lowercase | capitalize&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>此外还有大写过滤器<code>uppercase</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JS</span><br><span class="line"> var data&#x3D;&#123;msg:&#39;heLLO!&#39;&#125;;</span><br><span class="line"> new Vue(&#123;</span><br><span class="line">  el: &#39;#demo&#39;,</span><br><span class="line">  data: data</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello</span><br></pre></td></tr></table></figure>

<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>渲染数据的时候的逻辑表达式<br>v-text v-html v-model v-on v-else</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">var data&#x3D;&#123;msg:0&#125;;</span><br><span class="line"> new Vue(&#123;</span><br><span class="line">  el: &#39;#demo&#39;,</span><br><span class="line">  data: data</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<p>当msg的值为1的时候才打印Hello!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTML</span><br><span class="line">&lt;p v-if&#x3D;&quot;msg&quot;&gt;Hello!&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>在模板中表达式非常便利，但是它们实际上只用于简单的操作。模板是为了描述视图的结构。在模板中放入太多的逻辑会让模板过重且难以维护。这就是为什么 Vue.js 将绑定表达式限制为一个表达式。如果需要多于一个表达式的逻辑，应当使用计算属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JS</span><br><span class="line"></span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">  el: &#39;#example&#39;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: 1</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    &#x2F;&#x2F; 一个计算属性的 getter</span><br><span class="line">    b: function () &#123;</span><br><span class="line">      &#x2F;&#x2F; &#96;this&#96; 指向 vm 实例</span><br><span class="line">      return this.a + 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTML</span><br><span class="line"></span><br><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">  a&#x3D;&#123;&#123; a &#125;&#125;, b&#x3D;&#123;&#123; b &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">a&#x3D;1, b&#x3D;2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode 添加Target</title>
    <url>/post/8cafabb2.html</url>
    <content><![CDATA[<p>在区分开发环境和测试环境或生产环境的时候经常需要在XCode 添加Target, 所以在此记录一下</p>
<span id="more"></span>

<ol>
<li>Duplicate target</li>
<li>Change DisplayName &amp; Bundle Identifier</li>
<li>A copy-info.plist，默认生成在程序环境根目录，也就是<code>A.xcodeproj</code>的同级目录中，如果想放到里层（比如与<code>A-info.plist</code>放在同级目录），可以先在Xcode删除<code>A copy-info.plist</code>索引，然后拷贝文件到制定目录中，然后更名为<code>B-info.plist</code>，在add到project中。在<code>Project</code>的<code>Build Settings</code>中，修改<code>Info.plist</code> File选项为<code>B-info.plist</code>的目录（相对路径）,这样就可以看到Info页了（就是B-info.plist），接着修改<code>ProductName</code>和<code>Bundle identifier</code>，使之成为另一个app。<code>Prefix Header的路径</code>，视具体需求而定是否要修改，如果两个target可以公用同一个<code>Prefix Header</code>，那么就不需要修改这里的路径</li>
<li>修改scheme，在调试的Stop按钮边上，我们可以选择本工程中所有的target来做编译，如果不修改，在这里选择出来的名字就是A copy，为了与新建的target统一起来，同样也要修改这里的名字。点击scheme选择区，然后选Manager Scheme，找到A copy，然后改成你需要的名字，比如B</li>
<li>生成一个新的target，一定会与原target有区别，这里可以定义预编译宏，来区分两个版本的不同代码，预编译宏可以在Build Settings中Preprocessor Macros定义，比如在我们新建的target B中定义预编译宏MACRO，然后在代码中通过<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if defined (MACRO)</span><br><span class="line">&#x2F;&#x2F;target  B需要执行的代码</span><br><span class="line">#else</span><br><span class="line">&#x2F;&#x2F;target A需要执行的代码</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
来区分</li>
<li>其他：Build Phases（各target编译所包含的内容，需要注意的是，如果创建了target B后，再往A里面添加资源或文件，target B中不会自动增加这些资源，需要手动添加）<ul>
<li>Compile Sources<br>需要编译的代码文件</li>
<li>Link Binary With Libraries<br>编译所依赖的库</li>
<li>Copy Bundle Resources<br>编译需要的资源<br>每个target可以根据具体需要增减里面的内容</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>frp 内网穿透</title>
    <url>/post/b72542c2.html</url>
    <content><![CDATA[<p>frp 内网穿透</p>
<span id="more"></span>

<p><a href="https://github.com/fatedier/frp/blob/master/README_zh.md">文档</a></p>
<h3 id="服务器CentOS下载安装"><a href="#服务器CentOS下载安装" class="headerlink" title="服务器CentOS下载安装"></a>服务器CentOS下载安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.13.0&#x2F;frp_0.13.0_linux_amd64.tar.gz</span><br><span class="line">tar -zxvf frp_0.13.0_linux_amd64.tar.gz</span><br><span class="line">cd frp_0.13.0_linux_amd64.tar.gz</span><br><span class="line">rm -f frpc</span><br><span class="line">rm -f frpc.ini</span><br><span class="line">vi frps.ini</span><br></pre></td></tr></table></figure>

<p>编辑frps.ini</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">vhost_http_port &#x3D; 8001 # http访问端口</span><br><span class="line">bind_port &#x3D; 8009 # 远程响应的地址</span><br><span class="line">dashboard_port &#x3D; 8002 #控制面板端口号</span><br><span class="line"># dashboard 用户名密码，默认都为 admin</span><br><span class="line">dashboard_user &#x3D; admin</span><br><span class="line">dashboard_pwd &#x3D; admin</span><br></pre></td></tr></table></figure>

<h3 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;frps -c .&#x2F;frps.ini</span><br></pre></td></tr></table></figure>

<h3 id="Mac客户端下载"><a href="#Mac客户端下载" class="headerlink" title="Mac客户端下载"></a>Mac客户端下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.13.0&#x2F;frp_0.13.0_darwin_amd64.tar.gz</span><br><span class="line">tar -zxvf frp_0.13.0_darwin_amd64.tar.gz</span><br><span class="line">cd frp_0.13.0_darwin_amd64.tar.gz</span><br><span class="line">rm -f frps</span><br><span class="line">rm -f frps.ini</span><br><span class="line">vi frpc.ini</span><br></pre></td></tr></table></figure>

<p>编辑frpc.ini</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr &#x3D; 120.78.175.51 # 远程服务器地址</span><br><span class="line">server_port &#x3D; 8009 # 服务端填写的bind_port</span><br><span class="line"></span><br><span class="line">[web]</span><br><span class="line">type &#x3D; http </span><br><span class="line">local_port &#x3D; 3000 # 本地要映射的端口</span><br><span class="line">custom_domains &#x3D; frp.arclin.me # 自定义的域名,需要在dnspod绑定远程主机地址</span><br></pre></td></tr></table></figure>

<h3 id="客户端运行"><a href="#客户端运行" class="headerlink" title="客户端运行"></a>客户端运行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;frpc -c .&#x2F;frpc.ini</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title>docker笔记</title>
    <url>/post/4417b09c.html</url>
    <content><![CDATA[<p>docker学习笔记</p>
<span id="more"></span>

<p>docker是一种类似虚拟机的存在</p>
<p>// 查看本机docker信息</p>
<p><code>docker info</code></p>
<p>// 运行hello world</p>
<p><code>docker run centos:6.7 /bin/echo &quot;Hello World&quot;</code></p>
<p>//  -t 进入伪终端<br>//  -i 允许你对容器内的标准输入 (STDIN) 进行交互。 </p>
<p><code>docker run -i -t centos:6.7 /bin/bash</code></p>
<p>// -d 后台模式</p>
<p><code> docker run -d centos:6.7 /bin/sh -c &quot;while true;do echo hello world; sleep 1; done&quot;</code></p>
<p>//  查看当前运行的容器</p>
<p><code>docker ps</code></p>
<p>// -l 最近创建的容器</p>
<p><code>docker ps -l</code></p>
<p>// -a 所有容器</p>
<p><code>docker ps -a</code></p>
<p>// 查看运行log</p>
<p><code>docker logs 2b1b7a428627</code></p>
<p>//或</p>
<p><code>docker logs angry_austin</code></p>
<p>// 具体参数看ps的内容进行替换</p>
<p>// 停止容器</p>
<p><code>docker stop angry_austin</code></p>
<p>// 删除容器</p>
<p><code>docker rm awesome_bardeen</code></p>
<p>// 进入容器终端 允许标准输入</p>
<p><code>docker exec -it practical_fermat /bin/bash</code></p>
<p>中间的参数是容器名</p>
<p>// 拉取镜像 (如:httpd)</p>
<p><code>docker pull httpd</code></p>
<p>// 指定端口运行容器</p>
<p><code>docker run -d -p 5000:5001 httpd</code></p>
<p>// 提交新的镜像并添加tag v2 </p>
<p><code>docker commit -m &quot;has update&quot; -a=&quot;arclin&quot; 000c5746fa52 arclin/centos:v2</code></p>
<p>// 添加标签dev  中间那串是容器id</p>
<p><code>docker tag d 607e5fac1115 arclin/centos:dev</code></p>
<p>// 删除标签 6.7</p>
<p><code>docker rmi -f arclin/centos:6.7</code></p>
<p>// 指定端口运行  8080 是本地端口 80是容器端口 -d 是后台运行的意思</p>
<p><code>docker run -d -p 8080:80 httpd</code></p>
<p>// 随机端口运行 -P</p>
<p><code>docker run -d -P  httpd</code></p>
<p>// 查看容器practical_fermat的80端口被绑定到本机的哪个端口上了</p>
<p><code>docker port practical_fermat 80</code></p>
<p>// 运行的时候顺便给容器命名</p>
<p><code>docker run -d -P --name testName httpd</code></p>
<p>// 给容器重命名</p>
<p><code>docker rename practical_fermat test_httpd</code></p>
<p>// 运行nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 81:80 --name mynginx -v $PWD&#x2F;www:&#x2F;www -v </span><br><span class="line"></span><br><span class="line">$PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf -v $PWD&#x2F;logs:&#x2F;wwwlogs  -d nginx  </span><br><span class="line">-p 81:80：将容器的80端口映射到主机的81端口</span><br><span class="line">--name mynginx：将容器命名为mynginx</span><br><span class="line">-v $PWD&#x2F;www:&#x2F;www：将主机中当前目录下的www挂载到容器的&#x2F;www</span><br><span class="line">-v $PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf：将主机中当前目录下的nginx.conf挂载到容器的&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">-v $PWD&#x2F;logs:&#x2F;wwwlogs：将主机中当前目录下的logs挂载到容器的&#x2F;wwwlogs</span><br></pre></td></tr></table></figure>

<p>// 查看nginx的文件系统</p>
<p><code>docker inspect mynginx | grep Mounts -A 20</code></p>
<p>// 安装Apache</p>
<p><code>mkdir -p  ~/apache/www ~/apache/logs ~/apache/conf </code></p>
<p>// 运行Apache</p>
<p><code>docker run -p 80:80 -v $PWD/www/:/usr/local/apache2/htdocs/ -v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf -v $PWD/logs/:/usr/local/apache2/logs/ -d httpd</code></p>
<p>// 删除所有容器</p>
<p><code>sudo docker rm $(docker ps -a -q)</code></p>
<p>// 下载容器内的文件</p>
<p><code>docker cp ecef8319d2c8:/root/test.txt /root/</code></p>
<p>// 上传文件到容器中</p>
<p><code>docker cp /root/test.txt ecef8319d2c8:/root/</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 底层原理 --- Block、__block及其底层实现</title>
    <url>/post/8275b854.html</url>
    <content><![CDATA[<p>本文主要简述Block、__block的本质是什么东西，文章涉及循环引用等开发常见问题，需要重点关注。</p>
<span id="more"></span>


<h2 id="先写一个最简单的block"><a href="#先写一个最简单的block" class="headerlink" title="先写一个最简单的block"></a>先写一个最简单的block</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Block&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">block();</span><br></pre></td></tr></table></figure>

<p>使用命令行将<code>main.m</code>文件编译成C++文件<br/><br><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m </code></p>
<p>编译完成后，上述代码会变成以下结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void(*block)(void) &#x3D; &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br></pre></td></tr></table></figure>

<p>可以看出是生成了一个<code>__main_block_impl_0</code>结构体类型的对象，参数1为<code>__main_block_func_0</code>，参数2为<code>&amp;__main_block_desc_0_DATA</code></p>
<h2 id="block的底层结构"><a href="#block的底层结构" class="headerlink" title="block的底层结构"></a>block的底层结构</h2><p>接下来查看一下<code>__main_block_impl_0</code>是什么东西</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; block的结构体，引用了两个结构体和实现了一个构造方法</span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags&#x3D;0) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; block的结构体引用的第一个结构体</span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; block的结构体引用的第二个结构体，第一个参数赋值了0，第二个参数赋值了__main_block_impl_0的结构体大小</span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>

<p>所以拼接一下可以看出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  void *isa;</span><br><span class="line">  int Flags;</span><br><span class="line">  int Reserved;</span><br><span class="line">  void *FuncPtr;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags&#x3D;0) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><em><strong>结论1：block本质上是一个OC对象，它内部也有个isa指针</strong></em></li>
</ul>
<p>接下来看看构造方法，第一个参数是<code>void *fp</code>意为<code>function pointer</code>函数指针，所以我们回去看看这里传了什么值进去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void(*block)(void) &#x3D; &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure>

<p>是<code>__main_block_func_0</code>，那我们再看看<code>__main_block_func_0</code>是什么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">	NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_34b858_mi_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出我们在block内写的代码被封装成了一个函数</p>
<ul>
<li><em><strong>结论2：block是封装了函数调用以及函数调用环境的OC对象</strong></em></li>
</ul>
<p>最后，看一下block的调用，被编译成了下述结构（这里我们去掉强制转换）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(block)-&gt;FuncPtr(block);</span><br></pre></td></tr></table></figure>

<p>可以看出，是取出了变量中的<code>FuncPtr</code>成员变量，得到函数指针后把自己传进去，这样子就完成了block的调用</p>
<h2 id="block捕获外部变量"><a href="#block捕获外部变量" class="headerlink" title="block捕获外部变量"></a>block捕获外部变量</h2><p>从上面的分析我们可以得知，局部变量的定义和使用，是在两个函数中进行的，所以为了能够给让变量跨函数访问，block需要捕获该变量 </p>
<h3 id="局部auto类型的变量捕获"><a href="#局部auto类型的变量捕获" class="headerlink" title="局部auto类型的变量捕获"></a>局部auto类型的变量捕获</h3><p><strong>auto ： 自动变量，离开作用域自动销毁</strong></p>
<p>平常我们定义的局部变量，默认都是<code>auto</code>修饰的</p>
<p>先写一个简单的demo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int age &#x3D; 10; &#x2F;&#x2F; 等价于 auto int age &#x3D; 10;</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Block %d&quot;,age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编译后变成如下结构(去掉强制转换)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int age &#x3D; 10;</span><br><span class="line">void(*block)(void) &#x3D; &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br></pre></td></tr></table></figure>

<p><code>__main_block_impl_0</code>也发生了变化，可以看到多了一个<code>age</code>成员变量，所以构造函数也多了一个参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int age;</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags&#x3D;0) : age(_age) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>age(_age)</code>这个语法意为将构造方法传进来的<code>_age</code>赋值到自己的的成员变量<code>age</code>，这个过程我们称作变量的<strong>捕获</strong></p>
<p>block内编译后的函数<code>__main_block_func_0</code>也发生了变化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int age &#x3D; __cself-&gt;age; &#x2F;&#x2F; bound by copy</span><br><span class="line">   NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_5fd8ec_mi_0,age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出函数内取出了结构体内的<code>age</code>成员变量，然后交给<code>NSLog</code>使用</p>
<p>由此可知，block在定义的时候就会把外部传进来的参数给存储一遍，然后调用的时候在从block对象中取出来，所以这就意味着<strong>被block捕获的变量，在被捕获后如果修改了值，是不会应用到block中的</strong>，举例如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int age &#x3D; 10;</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;age &#x3D; %d&quot;,age);</span><br><span class="line">&#125;;</span><br><span class="line">age &#x3D; 20;</span><br><span class="line">block(); &#x2F;&#x2F; 调用这个方法只会输出age &#x3D; 10，因为age被捕获时是10，所以后面就算改了值也没用</span><br></pre></td></tr></table></figure>

<h3 id="局部static类型的变量捕获"><a href="#局部static类型的变量捕获" class="headerlink" title="局部static类型的变量捕获"></a>局部static类型的变量捕获</h3><p>把上面的<code>age</code>变量加一个<code>static</code>修饰符试试看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int age &#x3D; 10;</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;age &#x3D; %d&quot;,age);</span><br><span class="line">&#125;;</span><br><span class="line">age &#x3D; 20;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure>

<p>结果会输出<code>age = 20</code>，原因是静态变量会将<code>static</code>修饰的对象转为block的指针类型的成员属性，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  int *age;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  int *age &#x3D; __cself-&gt;age; &#x2F;&#x2F; bound by copy</span><br><span class="line">  NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_bb86ee_mi_0,(*age));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为是指针传递，所以当指针指向的内容变化时，打印出来的值也就会变化了</p>
<h3 id="全局变量不捕获"><a href="#全局变量不捕获" class="headerlink" title="全局变量不捕获"></a>全局变量不捕获</h3><p>全局<code>static</code>变量不捕获，因为全局<code>static</code>变量大家都能访问，所以函数内可以直接读取值</p>
<h3 id="block内的self会被捕获吗"><a href="#block内的self会被捕获吗" class="headerlink" title="block内的self会被捕获吗"></a>block内的self会被捕获吗</h3><p>会，我们来举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)test &#123;</span><br><span class="line">	void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    	NSLog(@&quot;%@&quot;,self); </span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>test</code>方法会添加两个隐含的参数，编译后如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void _I_Person_Test(Person *self, SEL _cmd) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这就是为什么我们能在方法内访问<code>self</code>和<code>_cmd</code>的原因，因为方法会传进来<code>self</code>参数，又因为参数是局部变量，又因为局部变量会被捕获，所以<code>self</code>参数会被捕获，捕获后大概长这样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  Person *self;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Block的类型"><a href="#Block的类型" class="headerlink" title="Block的类型"></a>Block的类型</h2><p>Block有三种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型</p>
<table>
<thead>
<tr>
<th>存储区域</th>
<th>类名</th>
<th>特点</th>
<th>调用copy后的效果</th>
</tr>
</thead>
<tbody><tr>
<td>数据区域 .data区</td>
<td><code>__NSGlobalBlock__</code></td>
<td>没有访问auto变量</td>
<td>无效果</td>
</tr>
<tr>
<td>栈区</td>
<td><code>__NSStackBlock__</code></td>
<td>访问了auto变量</td>
<td>从栈复制到堆</td>
</tr>
<tr>
<td>堆区</td>
<td><code>__NSMallocBlock__</code></td>
<td><code>__NSStackBlock__</code>调用了copy</td>
<td>引用计数增加</td>
</tr>
</tbody></table>
<h3 id="NSGlobalBlock"><a href="#NSGlobalBlock" class="headerlink" title="__NSGlobalBlock__"></a><code>__NSGlobalBlock__</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Hello world&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="NSStackBlock"><a href="#NSStackBlock" class="headerlink" title="__NSStackBlock__"></a><code>__NSStackBlock__</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int age &#x3D; 20;</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">   NSLog(@&quot;Block %d&quot;,age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为在ARC环境下，栈区block会自动copy，所以要测试这个类型的时候，需要使用MRC环境</p>
<p><strong>栈区数据的特点是会自动销毁，离开了作用域，数据都会销毁</strong></p>
<p><strong>栈区block存在的问题是，捕获的变量会存放在栈区，所以一旦离开了作用域，捕获的内容就销毁了，将来再去访问这个block内捕获的变量，访问到的可能就是一个未知的内容</strong></p>
<p>以下情况编译器会自动将栈上的block复制到堆上：</p>
<ol>
<li>block作为函数返回值时，比如 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef void(^Block)(void);</span><br><span class="line">Block myBlock() &#123;</span><br><span class="line">	int age &#x3D; 10</span><br><span class="line">    return ^&#123;</span><br><span class="line">    	NSLog(@&quot;---------%d&quot;,age);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将block赋值给__strong指针时<ul>
<li>__strong是是id类型和对象类型默认的所有权修饰符，所以平时在ARC环境下写的引用外部auto局部变量的block都会自动copy到堆中，原因是block默认被__strong修饰了</li>
</ul>
</li>
<li>block作为Cocoa API中方法名含有usingBlock的方法参数时<ul>
<li>比如NSArray的<code>enumerateObjectsUsingBlock:</code>方法，block传进去之后就会被copy一下</li>
</ul>
</li>
<li>block作为GCD API的方法参数时<ul>
<li>比如GCD的<code>dispatch_after(dispatch_time_t when, dispatch_queue_t queue,   dispatch_block_t block);</code>方法，block传进去之后就会被copy一下</li>
</ul>
</li>
</ol>
<h3 id="NSMallocBlock"><a href="#NSMallocBlock" class="headerlink" title="__NSMallocBlock__"></a><code>__NSMallocBlock__</code></h3><p>将<code>__NSStackBlock__</code>进行一次copy，即可得到<code>__NSMallocBlock__</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int age &#x3D; 20;</span><br><span class="line">void(^block)(void) &#x3D; [^&#123;</span><br><span class="line">   NSLog(@&quot;Block %d&quot;,age);</span><br><span class="line">&#125; copy];</span><br></pre></td></tr></table></figure>


<h2 id="捕获对象类型的auto变量"><a href="#捕获对象类型的auto变量" class="headerlink" title="捕获对象类型的auto变量"></a>捕获对象类型的auto变量</h2><p>当block内部访问了对象类型的auto变量时，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Person %@&quot;,person);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure>
<p>我们在ARC环境下编译，这时候block会在堆上（因为被自动copy了），执行命令行<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m</code>，会发现block结构体的person属性多了一个<code>__strong</code>的修饰符，证明他被block强持有了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  ...</span><br><span class="line">  Person *__strong person;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们如果编译的时候去掉<code>-fobjc-arc</code>，默认就是MRC环境了，这时候block会在栈上，查看编译后的c++文件发现不会有<code>__strong</code>修饰符，如果我们在block执行前加一行<code>[person release]</code>，那么这时候<code>person</code>就会直接释放，证明block没有持有<code>person变量</code></p>
<ul>
<li>结论1：如果block是在栈上，将不会对auto变量产生强引用</li>
</ul>
<p>如果我们给person添加<code>__weak</code>修饰符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__weak Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;Person %@&quot;,person);</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure>

<p>则block将会对person对象进行弱引用，编译后如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  ...</span><br><span class="line">  Person *__weak person;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以使用<code>__weak</code>修饰符可以避免block对外部变量的强引用操作</p>
<p>我们来看看block的结构体内的<code>__main_block_desc_0</code>是个什么东西</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA &#x3D; &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br></pre></td></tr></table></figure>

<p>可以发现，多了两个函数指针，<code>copy</code>和<code>dispose</code>，分别指向<code>__main_block_copy_0</code>和<code>__main_block_dispose_0</code></p>
<p>这两个函数的实现如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">	_Block_object_assign((void*)&amp;dst-&gt;person, (void*)src-&gt;person, 3&#x2F;*BLOCK_FIELD_IS_OBJECT*&#x2F;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class="line">	_Block_object_dispose((void*)src-&gt;person, 3&#x2F;*BLOCK_FIELD_IS_OBJECT*&#x2F;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_Block_object_assign</code>函数内部会对person进行引用计数器的操作，如果<code>__main_block_impl_0</code>结构体内person指针是<code>__strong</code>类型，则为强引用，引用计数+1，如果<code>__main_block_impl_0</code>结构体内person指针是<code>__weak</code>类型，则为弱引用，引用计数不变。</p>
<p><code>_Block_object_dispose</code>会对person对象做释放操作，类似于release，也就是断开对person对象的引用，而person究竟是否被释放还是取决于person对象自己的引用计数</p>
<ul>
<li>结论2：如果block被拷贝到堆上<ul>
<li>会调用block内部的copy函数</li>
<li>copy函数内部会调用_Block_object_assign函数</li>
<li>_Block_object_assign函数会根据auto变量的修饰符（<code>__strong</code>，<code>__weak</code>，<code>__unsafe_unretained</code>）做出相应的操作，类似于retain(形成强引用、弱引用)</li>
</ul>
<blockquote>
<p>__unsafe_unretained修饰的变量不会增加引用计数，当销毁时，该指针不会置空，会造成不安全的情况。</p>
</blockquote>
</li>
<li>结论3：如果block从堆上移除<ul>
<li>会调用block内部的dispose函数</li>
<li>dispose函数内部会调用_Block_object_assign函数</li>
<li>_Block_object_dispose函数会自动释放引用的auto变量，类似于release</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>函数</th>
<th>调用时机</th>
</tr>
</thead>
<tbody><tr>
<td>copy函数</td>
<td>栈上的Block复制到堆时</td>
</tr>
<tr>
<td>dispose函数</td>
<td>堆上的Block被废弃时</td>
</tr>
</tbody></table>
<h2 id="block"><a href="#block" class="headerlink" title="__block"></a>__block</h2><p>一般情况下我们是无法改变block捕获的外部的值的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">	person &#x3D; nil;  &#x2F;&#x2F;&#x2F; 这种情况是会编译失败的</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure>

<p>从上面的内容我们也可以知道原因。就是因为外部的person所在的内存空间和block内（单独开辟了一个函数）的内存空间不在同一个位置，所以block内是访问不到的外部的person的。</p>
<p>但是我们如果添加了<code>__block</code>关键字的话，就可以访问了，所以我们编译一下看看添加<code>__block</code>之后的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__block Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">	person &#x3D; nil;  &#x2F;&#x2F; 编译成功</span><br><span class="line">&#125;;</span><br><span class="line">block();</span><br></pre></td></tr></table></figure>

<p>编译后长这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">  struct __block_impl impl;</span><br><span class="line">  struct __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_person_0 *person; &#x2F;&#x2F; by ref</span><br><span class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_person_0 *_person, int flags&#x3D;0) : person(_person-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa &#x3D; &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags &#x3D; flags;</span><br><span class="line">    impl.FuncPtr &#x3D; fp;</span><br><span class="line">    Desc &#x3D; desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到person对象被封装成了一个<code>__Block_byref_person_0 *</code>类型的属性</p>
<p>继续看看<code>__Block_byref_person_0</code>是什么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __Block_byref_person_0 &#123;</span><br><span class="line">  void *__isa;</span><br><span class="line">__Block_byref_person_0 *__forwarding;</span><br><span class="line"> int __flags;</span><br><span class="line"> int __size;</span><br><span class="line"> void (*__Block_byref_id_object_copy)(void*, void*);</span><br><span class="line"> void (*__Block_byref_id_object_dispose)(void*);</span><br><span class="line"> Person *__strong person;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>__Block_byref_person_0</code>有isa指针，是一个OC对象，里面有一个强引用的person对象（指向的内容等同于外面的person指针指向的内容），和我们熟悉的<code>__Block_byref_id_object_copy</code>和<code>__Block_byref_id_object_dispose</code>方法用于处理内存管理问题，还有指向自身的<code>forwarding</code>指针（这个指针指向对象自身），<code>flag</code>和<code>size</code>，分别表示标记位和这个结构体的占用内存空间大小。</p>
<p>person被封装成了结构体对象之后，原先的block函数就变成了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">	__Block_byref_person_0 *person &#x3D; __cself-&gt;person; &#x2F;&#x2F; bound by ref</span><br><span class="line">	(person-&gt;__forwarding-&gt;person) &#x3D; __null;</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jj_276qbs652l5ckj94jfcx28jh0000gn_T_main_250618_mi_0,(person-&gt;__forwarding-&gt;person));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，但我们要改变person指针的值的时候，首先是取出person对象，即<code>__Block_byref_person_0 *person</code>，然后再通过<code>forwarding</code>指针拿到自己，再拿到最里面的person，最后就可以修改了。</p>
<ol>
<li><p>通过内存打印，我们可以得知<code>__Block_byref_person_0</code>内的person对象和外部的person对象的地址是一致的，所以我们在block内修改外部的person就是相当于修改<code>__Block_byref_person_0</code>内的person对象</p>
</li>
<li><p>为什么要绕一个圈，不直接<code>person-&gt;person</code>而是要<code>person-&gt;__forwarding-&gt;person</code>？原因是防止block从栈复制到堆之后，栈上面的block访问person访问到的是栈上的person而不是堆上的person，所以栈上的forwarding指针要指向堆的block，这样子就能一直访问到堆上的person了</p>
</li>
<li><p>封装的<code>__Block_byref_person_0</code>结构体内的<code>__Block_byref_id_object_copy</code>函数会管理他自己的person对象的内存，实现代码如下:<br> <code>_Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);</code>，这里的40是person对象的偏移值，可以看到结构体内person前面的4个指针加2个整型刚好40个字节。</p>
</li>
<li><p><code>__Block_byref_person_0</code>在<code>__main_block_impl_0</code>内必定是强引用，跟我们上面所说的不一样，就算在<code>__block</code>之前再添加<code>__weak</code>修饰，<code>__Block_byref_person_0</code>在<code>__main_block_impl_0</code>内依旧是强引用，加上<code>__weak</code>修饰受影响的只有<code>__Block_byref_person_0</code>内的person指针的引用方式</p>
</li>
</ol>
<blockquote>
<p>注意：MRC环境下，__block 不会对变量造成强引用，即以下情况person会提前释放</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__block Person *person &#x3D; [Person new];</span><br><span class="line">void(^block)(void) &#x3D; ^&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,person);</span><br><span class="line">&#125;;</span><br><span class="line">block(); &#x2F;&#x2F;&#x2F; 这时候person已经释放了</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：__block只能用于修饰auto变量，不能修饰全局变量和静态（static）变量</p>
</blockquote>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><h3 id="循环引用的发生原因与解决方式"><a href="#循环引用的发生原因与解决方式" class="headerlink" title="循环引用的发生原因与解决方式"></a>循环引用的发生原因与解决方式</h3><ul>
<li><p>以下代码会产生循环引用</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"> @property (nonatomic, copy) void(^block)(void);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person *person &#x3D; [Person alloc] init];</span><br><span class="line">person.age &#x3D; 10;</span><br><span class="line">person.block &#x3D; ^&#123;</span><br><span class="line">	NSLog(@&quot;age is %d&quot;,person.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  原因是person.block捕获了person，person又持有着block，也就是block内部对person存在一个强引用，person对block也存在一个强引用，所以均无法释放。</p>
</li>
<li><p>在定义person指针的时候添加<code>__weak</code>修饰符或者<code>__unsafe_unretain</code>修饰符，就可以让block在捕获person的时候弱引用person，这样子就不会造成循环引用了.</p>
  <img src="https://z3.ax1x.com/2021/06/13/2I2lPU.png" alt="2I2lPU.png" border="0" width="50%" />
  
> __weak: 不会产生强引用，指向的对象销毁时，会自动让指针至nil，不支持MRC
 
> __unsafe_unretain: 不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变，变成野指针，支持MRC</li>
<li><p>在定义person指针的时候添加<code>__block</code>修饰符也可以解决循环引用问题，但前提是需要调用block并手动将person指针置为nil，如下</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__block Person *person &#x3D; [Person alloc] init];</span><br><span class="line">person.age &#x3D; 10;</span><br><span class="line">person.block &#x3D; ^&#123;</span><br><span class="line">	NSLog(@&quot;age is %d&quot;,person.age);</span><br><span class="line">       person &#x3D; nil;</span><br><span class="line">&#125;;</span><br><span class="line">   person.block();</span><br></pre></td></tr></table></figure>
<p>  为什么这样子可以解决循环引用呢?首先先分析一下内存结构</p>
<ul>
<li>peron持有block</li>
<li>block持有__block对象</li>
<li>__block持有着person</li>
<li>peron又持有着block</li>
<li>…</li>
</ul>
<p>  所以这里是三个对象相互持有形成一个三角形关系</p>
  <img src="https://z3.ax1x.com/2021/06/13/2IcLXn.png" alt="2IcLXn.png" border="0" width="30%"/>
  
  当block执行，person = nil，解除了`__block`变量对person的引用的时候，循环引用就不再存在了
  
  <img src="https://z3.ax1x.com/2021/06/13/2IgCp4.png" alt="2IgCp4.png" border="0" width="30%"/>

<ul>
<li>MRC环境下，由于**__block不会对变量造成强引用**，所以直接用__block修饰指针也可以达到以上效果</li>
</ul>
</li>
</ul>
<h3 id="为什么block做属性不常用weak而是用copy"><a href="#为什么block做属性不常用weak而是用copy" class="headerlink" title="为什么block做属性不常用weak而是用copy"></a>为什么block做属性不常用weak而是用copy</h3><p>如果上述例子使用weak修饰block的话，那么block会在栈中，block里面的person也会在栈中，所以离开了作用域的话，里面的person就会销毁，从而无法使用。</p>
<p>如果你希望block做完事情就释放，比如发送一个通知，修改某个单例类的属性，没有引用外部局部变量，那么用weak就可以节约内存空间</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS-定位总结</title>
    <url>/post/2684222a.html</url>
    <content><![CDATA[<p>iOS-定位总结</p>
<span id="more"></span>

<p>info.plist 请求用户位置授权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;&#x2F;key&gt;</span><br><span class="line">	&lt;string&gt;需要使用位置&lt;&#x2F;string&gt;</span><br><span class="line">&lt;key&gt;NSLocationAlwaysUsageDescription&lt;&#x2F;key&gt;</span><br><span class="line">	&lt;string&gt;需要使用位置&lt;&#x2F;string&gt;</span><br></pre></td></tr></table></figure>

<p>代码</p>
<p>language: 要生成的位置信息的语言（’China‘还是’中国‘）</p>
<ul>
<li>中文 : @”zh-hans”</li>
<li>英文 : @”en”</li>
<li>日文 : @”jp”</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface DKLocation()&lt;CLLocationManagerDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic,strong) CLLocationManager *locationManager;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation DKLocation</span><br><span class="line">- (void)locationWithLanguage:(NSString *)language location:(void(^)(NSString *country,NSString *province))location</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    [[self rac_signalForSelector:@selector(locationManager:didUpdateToLocation:fromLocation:) fromProtocol:@protocol(CLLocationManagerDelegate)] subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class="line">        &#x2F;&#x2F; 停止位置更新</span><br><span class="line">        CLLocationManager *manager &#x3D; tuple.first;</span><br><span class="line">        CLLocation *newLocation &#x3D; tuple.second;</span><br><span class="line">        </span><br><span class="line">        [manager stopUpdatingLocation];</span><br><span class="line">        [_locationManager stopUpdatingLocation];</span><br><span class="line">        _locationManager.delegate &#x3D; nil;</span><br><span class="line">        &#x2F;&#x2F; 保存 Device 的现语言</span><br><span class="line">        NSString *userDefaultLanguages &#x3D; DKUserDefaults(kAppLanguage);</span><br><span class="line">        &#x2F;&#x2F; 强制 成 英文</span><br><span class="line">        [[NSUserDefaults standardUserDefaults] setObject:[NSArray arrayWithObjects:language,nil] forKey:@&quot;AppleLanguages&quot;];</span><br><span class="line">        &#x2F;&#x2F; 逆地理编码</span><br><span class="line">        CLGeocoder * geoCoder &#x3D; [[CLGeocoder alloc] init];</span><br><span class="line">        [geoCoder reverseGeocodeLocation:newLocation completionHandler:^(NSArray *placemarks, NSError *error) &#123;</span><br><span class="line">            if(!error)&#123;</span><br><span class="line">                for (CLPlacemark * placemark in placemarks) &#123;</span><br><span class="line">                    NSString *provinceName &#x3D; placemark.administrativeArea;</span><br><span class="line">                    NSString *country &#x3D; placemark.country;</span><br><span class="line">                    location(country,provinceName);</span><br><span class="line">                    DKLog(@&quot;%@%@&quot;,country,provinceName);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 还原Device 的语言</span><br><span class="line">            [[NSUserDefaults standardUserDefaults] setObject:@[userDefaultLanguages] forKey:@&quot;AppleLanguages&quot;];</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 初始化定位管理器</span><br><span class="line">    _locationManager &#x3D; [[CLLocationManager alloc] init];</span><br><span class="line">    _locationManager.delegate &#x3D; self;</span><br><span class="line">    &#x2F;&#x2F; 设置定位精确度到米</span><br><span class="line">    _locationManager.desiredAccuracy &#x3D; kCLLocationAccuracyBest;</span><br><span class="line">    &#x2F;&#x2F; 设置过滤器为无</span><br><span class="line">    _locationManager.distanceFilter &#x3D; kCLDistanceFilterNone;</span><br><span class="line">    if ([_locationManager respondsToSelector:@selector(requestAlwaysAuthorization)]) &#123;</span><br><span class="line">        [_locationManager requestAlwaysAuthorization];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;开始定位，不断调用其代理方法</span><br><span class="line">    [_locationManager startUpdatingLocation];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 底层原理 --- Category、+load、+initialize和关联对象</title>
    <url>/post/2397c268.html</url>
    <content><![CDATA[<p>本文简述iOS中分类的底层实现和load方法、initialize方法在类和分类中的调用特性，还有如何通过关联对象的方式给分类添加属性，以及关联对象的底层实现原理</p>
<span id="more"></span>


<h2 id="分类（Category）"><a href="#分类（Category）" class="headerlink" title="分类（Category）"></a>分类（Category）</h2><h3 id="先写一个Demo"><a href="#先写一个Demo" class="headerlink" title="先写一个Demo"></a>先写一个Demo</h3><p>新建一个命令行工程，在main.m中写几个类</p>
<p>父类：写一个run方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line"></span><br><span class="line">- (void)run;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>父类的分类：写一个eat方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface Person(Test) </span><br><span class="line"></span><br><span class="line">- (void)eat;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据经验可知道，现在Peron对象拥有了run方法和eat方法</p>
<h3 id="分类的底层结构"><a href="#分类的底层结构" class="headerlink" title="分类的底层结构"></a>分类的底层结构</h3><p>输入命令行</p>
<p><code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code></p>
<p>接下来同级目录下就会多出一个编译后的文件<code>main.cpp</code>，查看后发现<code>Person(Test) </code>分类被编译成了如下变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct _category_t _OBJC_$_CATEGORY_Person_$_Test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) &#x3D; </span><br><span class="line">&#123;</span><br><span class="line">	&quot;Person&quot;,</span><br><span class="line">	0, &#x2F;&#x2F; &amp;OBJC_CLASS_$_Person,</span><br><span class="line">	(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Test,</span><br><span class="line">	0,</span><br><span class="line">	0,</span><br><span class="line">	0,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个变量的类型是<code>static struct _category_t</code>，名字是<code>_OBJC_$_CATEGORY_Person_$_Test</code>，等于号后面是一个初始化结构体的过程，可以看到要实例化这个结构体需要6个参数，所以查看<code>_category_t</code>的结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct _category_t &#123;</span><br><span class="line">	const char *name; &#x2F;&#x2F;&#x2F; 原来的类的名字</span><br><span class="line">	struct _class_t *cls; &#x2F;&#x2F;&#x2F; 类对象</span><br><span class="line">	const struct _method_list_t *instance_methods; &#x2F;&#x2F;&#x2F; 实例方法数组</span><br><span class="line">	const struct _method_list_t *class_methods; &#x2F;&#x2F;&#x2F; 类方法数组</span><br><span class="line">	const struct _protocol_list_t *protocols; &#x2F;&#x2F;&#x2F; 遵循的协议数组</span><br><span class="line">	const struct _prop_list_t *properties; &#x2F;&#x2F;&#x2F; 属性数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由此可知，<strong>分类可以定义实例方法，可以定义类方法，可以遵循协议，可以添加属性，但是不能添加成员变量！因为分类的结构里面没有存储成员变量的地方.</strong></p>
<h3 id="程序通过runtime动态将分类合并到类对象、元类对象中"><a href="#程序通过runtime动态将分类合并到类对象、元类对象中" class="headerlink" title="程序通过runtime动态将分类合并到类对象、元类对象中"></a>程序通过runtime动态将分类合并到类对象、元类对象中</h3><p>分类中的方法是在运行时才添加到类对象和元类对象中的，而不是编译的时候添加的，编译之后只是多了几个类型为<code>_category_t</code>的结构体变量。</p>
<p>合并的过程可以在runtime源码（objc4-818.2）中<code>objc-runtime-new.mm</code>的<code>load_categories_nolock</code>函数中看到，这里不展开流程，直接说结论。</p>
<p>合并过程是这样子的，首先我们知道原来的类（我们就叫他主类吧）对象是存放着成员方法的，主类的元类对象是放着类方法的，因为类对象和元类对象结构是一样的，所以我们就讨论成员方法就好了。</p>
<p>其次呢，runtime先根据分类方法的数量在数组里面开辟空间，然后把分类方法塞到原来的成员方法数组的前端，这样子合并就完成了，其他类方法、协议、属性等数组，也是同样的过程。</p>
<p>所以最后在<strong>类对象的方法列表数组里面，排在前面的是分类方法，后面才是主类的方法。如果有多个分类的话，那么后编译的分类的成员方法会插在数组的前面（因为插入数组的时候是倒序插入）</strong>。</p>
<p>有了上述结论 我们就可以解释很多事情了。</p>
<h4 id="如果分类实现了主类的方法会怎么样"><a href="#如果分类实现了主类的方法会怎么样" class="headerlink" title="如果分类实现了主类的方法会怎么样"></a>如果分类实现了主类的方法会怎么样</h4><p>根据上述结论，系统在找对应的调用方法的时候，会先找到分类的方法，所以主类的方法没有机会被调用到。</p>
<h4 id="如果多个分类都实现了同个主类的方法"><a href="#如果多个分类都实现了同个主类的方法" class="headerlink" title="如果多个分类都实现了同个主类的方法"></a>如果多个分类都实现了同个主类的方法</h4><p>根据上述结论，后编译的分类的成员方法会插在方法列表的前面，所以谁后编译，就调用谁</p>
<h4 id="如果子类或者子类的分类实现了父类的分类方法"><a href="#如果子类或者子类的分类实现了父类的分类方法" class="headerlink" title="如果子类或者子类的分类实现了父类的分类方法"></a>如果子类或者子类的分类实现了父类的分类方法</h4><p>根据上述结论和结合我们以前所学知识，最后子类实例对象会去子类的类对象里面寻找方法并调用，使用<code>super</code>关键字调用方法的话，则会去到父类的类对象内找方法。</p>
<h3 id="Category跟Class-Extension的区别"><a href="#Category跟Class-Extension的区别" class="headerlink" title="Category跟Class Extension的区别"></a>Category跟Class Extension的区别</h3><ul>
<li>Class Extension是编译的时候，它的数据就已经包含在类信息中</li>
<li>Category 是在运行时才会讲数据合并到类信息中</li>
</ul>
<h2 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h2><h3 id="先写一个Demo-1"><a href="#先写一个Demo-1" class="headerlink" title="先写一个Demo"></a>先写一个Demo</h3><p>父类：实现load方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Person load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>父类的分类：实现load方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Person(Test)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Person Text load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>子类：实现load方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Student</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Student load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>子类的分类：实现load方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Student(Test)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog(@&quot;Student Test load&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h3 id="load方法的调用时机"><a href="#load方法的调用时机" class="headerlink" title="load方法的调用时机"></a>load方法的调用时机</h3><p>通过runtime源码（objc4-818.2）<code>objc-runtime-new.mm</code>第3233行得知，load方法是在加载镜像(load_images)的时候调用的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    if (!didInitialAttachCategories &amp;&amp; didCallDyldNotifyRegister) &#123;</span><br><span class="line">        didInitialAttachCategories &#x3D; true;</span><br><span class="line">        loadAllCategories();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Return without taking locks if there are no +load methods here.</span><br><span class="line">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Discover load methods</span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((const headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Call +load methods (without runtimeLock - re-entrant)</span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充小细节：从<code>load_images</code>函数可以看到，加载分类<code>loadAllCategories()</code>早于调用load方法<code>call_load_methods()</code>，也就是元类对象中的类方法列表内，分类的load方法会在主类的load方法之前</p>
</blockquote>
<p>在调用load方法之前，首先要通过<code>prepare_load_methods</code>函数整理出一个数组，这个数组会决定主类的load方法的调用顺序</p>
<p>从<code>prepare_load_methods</code>函数中调用的<code>schedule_class_load</code>函数的内部实现我们可以知道，父类会先被加入到数组中，其次才是主类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* prepare_load_methods</span><br><span class="line">* Schedule +load for classes in this image, any un-+load-ed </span><br><span class="line">* superclasses in other images, and any categories in this image.</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">&#x2F;&#x2F; Recursively schedule +load for cls and any un-+load-ed superclasses.</span><br><span class="line">&#x2F;&#x2F; cls must already be connected.</span><br><span class="line">static void schedule_class_load(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls) return;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());  &#x2F;&#x2F; _read_images should realize</span><br><span class="line"></span><br><span class="line">    if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Ensure superclass-first ordering</span><br><span class="line">    schedule_class_load(cls-&gt;getSuperclass());</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们回到最开始的地方（load_images），通过<code>objc-loadmethod.mm</code>第337行<code>call_load_methods</code>得知，先调用主类的load方法(call_class_loads())，再调用分类的load方法<code>call_category_loads();</code></p>
<blockquote>
<p>补充一个小细节：在整理数组的时候，这个数组里面存放的是一个个结构体，结构体长这样</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct loadable_class &#123;</span><br><span class="line">    Class cls;  &#x2F;&#x2F; may be nil  这里放元类对象（load是类方法所以存在元类对象里面）</span><br><span class="line">    IMP method;  &#x2F;&#x2F;&#x2F; 这里放的是load方法的函数指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct loadable_category &#123;</span><br><span class="line">    Category cat;  &#x2F;&#x2F; may be nil 这个是上面讲到的category_t类型的对象</span><br><span class="line">    IMP method; &#x2F;&#x2F;&#x2F; 这里放的是load方法的函数指针</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：runtime代码内有记录类的load方法是否曾经被加入到load数组过（RW_LOADED），如果被调用过了，就会跳过，这就是load方法只会执行一次的原因（但是你要是非要手动调用load方法那还是会执行的）</p>
<p><strong>重要：系统调用load方法不通过消息发送机制</strong>，可以查看<code>objc-loadmethod.mm</code>第177行如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* call_class_loads</span><br><span class="line">* Call all pending class +load methods.</span><br><span class="line">* If new classes become loadable, +load is NOT called for them.</span><br><span class="line">*</span><br><span class="line">* Called only by call_load_methods().</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">static void call_class_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Detach current loadable list.</span><br><span class="line">    struct loadable_class *classes &#x3D; loadable_classes;</span><br><span class="line">    int used &#x3D; loadable_classes_used;</span><br><span class="line">    loadable_classes &#x3D; nil;</span><br><span class="line">    loadable_classes_allocated &#x3D; 0;</span><br><span class="line">    loadable_classes_used &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Call all +loads for the detached list.</span><br><span class="line">    for (i &#x3D; 0; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls &#x3D; classes[i].cls;</span><br><span class="line">        load_method_t load_method &#x3D; (load_method_t)classes[i].method;</span><br><span class="line">        if (!cls) continue; </span><br><span class="line"></span><br><span class="line">        if (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(&quot;LOAD: +[%s load]\n&quot;, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 意为直接通过函数指针调用函数</span><br><span class="line">        (*load_method)(cls, @selector(load));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Destroy the detached list.</span><br><span class="line">    if (classes) free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="load方法的调用顺序"><a href="#load方法的调用顺序" class="headerlink" title="load方法的调用顺序"></a>load方法的调用顺序</h3><p>综上所述，分类也有load方法。调用顺序是：先调用父类load方法，再调用子类load方法，最后调用分类的load方法，如果有多个分类，那么先编译的，先调用。</p>
<p>所以上述Demo代码执行后输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person load</span><br><span class="line">Student load</span><br><span class="line">Person Test load</span><br><span class="line">Student Test load</span><br></pre></td></tr></table></figure>

<p>这里Person比Student先调用是因为他是父类，Person(Test)比Student(Test)先调用是因为它先编译</p>
<h3 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a>综上所述</h3><p>于是我们可以解答下面的问题</p>
<ol>
<li>类和分类都有+load方法</li>
<li>根据编译顺序，先调用父类+load，再调用子类+load，再调用分类+load(看编译顺序)</li>
<li>因为系统调用load方法时不通过消息发送机制，所以不存在子类load方法覆盖父类load方法的情况，但是，如果手动调用load方法（即通过消息发送机制调用方法），那么这时候就有继承的现象发生了，也就是子类会覆盖父类方法的实现。</li>
</ol>
<p>搞点复杂的事情</p>
<ol>
<li>父类实现，父类分类实现，子类不实现，子类分类实现<br/><br> 顺序：父类load，子类分类load、父类分类load<br/><br> 原因：本来应该调用子类load的，无奈子类load没实现，但是找到了子类分类，那么就调用子类分类的load，最后在调用父类分类load(因为分类要最晚调用，由于刚才子类分类被调用过了，所以这里没它事了)<br/><br> <strong>所以：不一定主类的load方法总比分类的load方法早调用，存在特殊情况</strong><br/><br/></li>
<li>父类不实现，父类分类实现，子类实现，子类分类实现<br/><br> 顺序：父类分类load，子类load，子类分类load<br/><br> 原因：跟上面的理由是一样的，父类没实现但是父类分类找到了那么就调用<br/><br> <strong>所以：父类的分类的load也可以比子类load方法早调用</strong></li>
</ol>
<h2 id="initialize方法"><a href="#initialize方法" class="headerlink" title="initialize方法"></a>initialize方法</h2><h3 id="先写个Demo"><a href="#先写个Demo" class="headerlink" title="先写个Demo"></a>先写个Demo</h3><p>父类：实现initialize方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;Person initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>父类的分类：实现initialize方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Person(Test)</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;Person Text initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>子类：实现initialize方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Student</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;Student initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>子类的分类：实现initialize方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Student(Test)</span><br><span class="line"></span><br><span class="line">+ (void)initialize &#123;</span><br><span class="line">    NSLog(@&quot;Student Test initialize&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h3 id="initialize方法的调用时机"><a href="#initialize方法的调用时机" class="headerlink" title="initialize方法的调用时机"></a>initialize方法的调用时机</h3><ul>
<li><p><code>+initialize</code>会在类第一次接受到消息的时候调用，即<code>objc_msgSend()</code>被触发的时候调用，这部分是汇编实现</p>
</li>
<li><p>runtime源码里面有一个<code>class_getInstanceMethod()</code>函数，用于查找方法，当找到要调用的方法之后，就会调用<code>initialize</code>方法，<code>class_getInstanceMethod()</code>内的主要实现为<code>lookUpImpOrForward()</code>函数的调用</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* class_getInstanceMethod.  Return the instance method for the</span><br><span class="line">* specified class and selector.</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">Method class_getInstanceMethod(Class cls, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cls  ||  !sel) return nil;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; This deliberately avoids +initialize because it historically did so.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; This implementation is a bit weird because it&#39;s the only place that </span><br><span class="line">    &#x2F;&#x2F; wants a Method instead of an IMP.</span><br><span class="line"></span><br><span class="line">    Method meth;</span><br><span class="line">    meth &#x3D; _cache_getMethod(cls, sel, _objc_msgForward_impcache);</span><br><span class="line">    if (meth &#x3D;&#x3D; (Method)1) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache contains forward:: . Stop searching.</span><br><span class="line">        return nil;</span><br><span class="line">    &#125; else if (meth) &#123;</span><br><span class="line">        return meth;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    &#x2F;&#x2F; Search method lists, try method resolver, etc.</span><br><span class="line">    lookUpImpOrForward(nil, sel, cls, LOOKUP_INITIALIZE | LOOKUP_RESOLVER);</span><br><span class="line"></span><br><span class="line">    meth &#x3D; _cache_getMethod(cls, sel, _objc_msgForward_impcache);</span><br><span class="line">    if (meth &#x3D;&#x3D; (Method)1) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache contains forward:: . Stop searching.</span><br><span class="line">        return nil;</span><br><span class="line">    &#125; else if (meth) &#123;</span><br><span class="line">        return meth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return _class_getMethod(cls, sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>lookUpImpOrForward()</code>函数实现内，有一判断条件为<code>if(slowpath(!cls-&gt;isInitialized())) &#123; ... &#125;</code> ，若该类已经调用过<code>+initialize</code>，那么就不会再调用，这就是<code>+initialize</code>只被系统调用一次的原因</p>
</li>
<li><p>经过一层层点击方法实现（流程见补充），最终我们可以在<code>objc-initialize.mm</code>内发现函数<code>callInitialize(Class cls)</code>，内部实现是<code>objc_msgSend</code>，如下</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  void callInitialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ((void(*)(Class, SEL))objc_msgSend)(cls, @selector(initialize));</span><br><span class="line">    asm(&quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充：函数调用路径为<code>lookUpImpOrForward</code>-&gt;<code>realizeAndInitializeIfNeeded_locked</code>-&gt;<code>initializeAndLeaveLocked</code>-&gt;<code>initializeAndMaybeRelock</code>-&gt;<code>initializeNonMetaClass</code>-&gt;<code>callInitialize</code><br/>其中：<code>initializeNonMetaClass</code>函数实现内有一个递归，不断地传入<code>superclass</code>指针，去调用父类的<code>initialize</code>方法，直到<code>superclass</code>指针为空（或已经调用过<code>initialize</code>）为止，这就是先调用父类的<code>initialize</code>方法的原因</p>
</blockquote>
<h3 id="initialize方法的调用顺序"><a href="#initialize方法的调用顺序" class="headerlink" title="initialize方法的调用顺序"></a>initialize方法的调用顺序</h3><ul>
<li>先调用父类的<code>initialize</code>方法，再调用子类的<code>initialize</code></li>
</ul>
<h3 id="综上所述-1"><a href="#综上所述-1" class="headerlink" title="综上所述"></a>综上所述</h3><ol>
<li><code>initialize</code>是通过<code>objc_msgSend</code>方式调用的，所以会受分类、继承等等因素影响调用</li>
<li>如果子类没有实现<code>+initialize</code>，会调用父类的<code>+initiailize</code>（所以父类的<code>+initialize</code>可能会被调用多次）</li>
<li>如果分类实现了<code>+initialize</code>，就会覆盖主类的<code>+initialize</code>调用</li>
</ol>
<h2 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h2><p>假如我们要给一个类添加一个属性如下：<br><br><code>@property (copy, nonatomic) NSString *test;</code></p>
<h3 id="存值"><a href="#存值" class="headerlink" title="存值"></a>存值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OBJC_EXPORT void</span><br><span class="line">objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,</span><br><span class="line">                         id _Nullable value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>object</td>
<td>要关联的对象，如果是在分类内给主类添加属性，那么这里就写<code>self</code></td>
</tr>
<tr>
<td>key</td>
<td>要用来标记这个属性的key，取值的时候也得靠这个key取</td>
</tr>
<tr>
<td>value</td>
<td>存储的内容</td>
</tr>
<tr>
<td>policy</td>
<td>存储策略（见下表）</td>
</tr>
</tbody></table>
<h4 id="objc-AssociationPolicy-存储策略"><a href="#objc-AssociationPolicy-存储策略" class="headerlink" title="objc_AssociationPolicy 存储策略"></a>objc_AssociationPolicy 存储策略</h4><table>
<thead>
<tr>
<th>策略枚举</th>
<th>对应修饰符</th>
</tr>
</thead>
<tbody><tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td>assign</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>strong, nonatomic</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>copy,nonatomic</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>strong, atomic</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>copy,atomic</td>
</tr>
</tbody></table>
<blockquote>
<p>如果要存weak类型的对象怎么办？<br/>创建一个类，用<code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code>标记存在主类中，然后在这个新建的类里面再存放一个weak引用的属性</p>
</blockquote>
<h4 id="key有多少种填写形式"><a href="#key有多少种填写形式" class="headerlink" title="key有多少种填写形式"></a>key有多少种填写形式</h4><ol>
<li>声明全局变量<code>static const void *TestKey = &amp;TestKey;</code>,将<code>TestKey</code>的地址作为key的内容，不能直接写<code>const void *TestKey</code>，因为这么写等共同于<code>const void *TestKey = NULL</code>，要是以后添加别的属性，就会冲突，使用例子：</li>
</ol>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc_setAssociatedObject(self,TestKey,test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>声明全局变量<code>static const char TestKey</code>，同样将<code>TestKey</code>的地址作为key，好处是<code>char</code>只占用一个字节的内存大小，使用例子：</li>
</ol>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc_setAssociatedObject(self,&amp;TestKey,test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>因为OC内的字符串都存在常量区，所以通过字面量创建的相同字符串都是同个地址，所以我们也可以随便定义一个字符串去做key，使用例子：</li>
</ol>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc_setAssociatedObject(self,@&quot;Test&quot;,test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>我们也可以通过使用getter方法的方法编号去做key，使用例子：</li>
</ol>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc_setAssociatedObject(self,@selector(test),test,OBJC_ASSOCIATION_COPY_NONATOMIC)</span><br></pre></td></tr></table></figure>
<h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key);</span><br></pre></td></tr></table></figure>


<ul>
<li>object同上，一般分类里面就填self</li>
<li>key属性需要和上面设值的key属性一致</li>
</ul>
<ul>
<li>如果使用getter方法的方法编号去做key，有两种写法<ol>
<li><code>objc_getAssociatedObject(self, @selector(test))</code></li>
<li><code>objc_getAssociatedObject(self, _cmd)</code>，<code>_cmd</code>表示当前方法的方法地址</li>
</ol>
</li>
</ul>
<h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p><img src="https://www.hualigs.cn/image/60bd149eb55dc.jpg" alt="图片来源自小码哥教程"></p>
<ul>
<li>runtime维护着一个名为<code>AssociationsManager</code>的类</li>
<li>类里面存放着一个字典，键是传入的对象（object参数），值是<code>ObjectAssociationMap</code>类的实例对象</li>
<li><code>ObjectAssociationMap</code>是一个字典，键是传入的key参数，值是<code>ObjcAssociation</code>类的实例对象</li>
<li><code>ObjcAssociation</code>有两个成员变量，<code>_policy</code>存放着传入的policy参数，<code>_value</code>存放着传入的value参数</li>
</ul>
<h3 id="综上所述-2"><a href="#综上所述-2" class="headerlink" title="综上所述"></a>综上所述</h3><ol>
<li>关联对象并不是存储在被关联对象的内存中</li>
<li>关联对象存储在全局统一的<code>AssociationsManager</code>中</li>
<li>设置关联对象（object参数）为nil，就相当于是移除关联对象</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>WordPress常用函数</title>
    <url>/post/3fd5c9ca.html</url>
    <content><![CDATA[<p>wordpress自定义主题的时候需要用到的函数</p>
<span id="more"></span>

<p><a href="https://codex.wordpress.org/zh-cn:%E6%A8%A1%E6%9D%BF%E6%A0%87%E7%AD%BE">参考文档</a></p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>bloginfo()</td>
<td>可以拿到博客的信息,name,description,version,特别注意bloginfo(‘stylesheet_url’);会直接找到根目录下的style.css文件,这个页面的样式表</td>
</tr>
<tr>
<td>wp_head()</td>
<td>一般放在header.php,会有很多东西引入进去</td>
</tr>
<tr>
<td>wp_title()</td>
<td>网站标题</td>
</tr>
<tr>
<td>get_header()</td>
<td>检查同目录下是否有header.php,有的话就会调用这个文件作为页面头部</td>
</tr>
<tr>
<td>get_sidebar()</td>
<td>检查sidebar.php,调用作为侧边栏</td>
</tr>
<tr>
<td>get_footer()</td>
<td>检查footer.php,调用作为底部栏</td>
</tr>
<tr>
<td>have_posts()</td>
<td>判断是否有日志</td>
</tr>
<tr>
<td>the_post()</td>
<td>调用一篇具体的日志,和主循环配合使用</td>
</tr>
<tr>
<td>the_permalink()</td>
<td>每篇日志地址</td>
</tr>
<tr>
<td>the_title()</td>
<td>日志标题</td>
</tr>
<tr>
<td>the_content()</td>
<td>日志内容</td>
</tr>
<tr>
<td>_e()</td>
<td>框架里面有语言文件,这里是调用语言文件内对应文字,使用类似这样子_e(“Archives”),中文页面下显示归档,英文页面下显示Archives</td>
</tr>
<tr>
<td>the_category()</td>
<td>分类,这个函数里面有一个参数,可以表示用什么符号去分割多个分类名,例如the_category(‘,’)</td>
</tr>
<tr>
<td>the_author()</td>
<td>作者名</td>
</tr>
<tr>
<td>the_excerpt()</td>
<td>日志摘要</td>
</tr>
<tr>
<td>comments_popup_link(‘No Comments »’, ‘1 Comment »’, ‘% Comments »’);</td>
<td>当弹出留言的功能激活的话，comments_popup_link() 调用一个弹出的留言窗口，如果没有激活，comments_popup_link() 则只是简单的显示留言列表。No Comments » 是在没有留言的时候显示的。1 Comment » 是用于当刚好只有1条留言时候。% Comments &187; 是用于当有多于一条留言的时候。比如：8 Comments »。百分号 % 用来显示数字。» 是用来显示一个双层箭头 »。</td>
</tr>
<tr>
<td>edit_post_link(‘Edit’, ‘&amp;124’, ”);</td>
<td>这个只有当我们以管理员或者作者身份登录的的时候才可见。</td>
</tr>
<tr>
<td>edit_post_link()</td>
<td>只是简单显示一个可以用来编辑当前日志的编辑链接，这样就可以让我们不必去管理界面搜寻该日志就能直接编辑。</td>
</tr>
<tr>
<td>edit_post_link()</td>
<td>有三个参数。第一个是用来确定哪个词你将用在编辑链接的链接标题。如果你使用 Edit post，那么将显示 Edit post 而不是 Edit。第二个参数是用来显示在链接前面的字符，在这里是竖线，代码就是&124;。第三个参数是用于显示在编辑链接后面的字符，在这里没有使用。登录 WordPress 之后，再返回到首页就可以看到“Edit”的链接和一条竖线。</td>
</tr>
<tr>
<td>posts_nav_link(‘中间页’, ‘&lt;&lt;上一页’, ‘下一页&gt;&gt;’)</td>
<td>调用后一页和前一页的链接,3个参数，分别给链接的中间，前面和后面的设置字符</td>
</tr>
<tr>
<td>previous_post_link(‘%link’)</td>
<td>上一篇日志</td>
</tr>
<tr>
<td>next_post_link(‘%link’)</td>
<td>下一篇日志</td>
</tr>
<tr>
<td>wp_list_pages()</td>
<td>展示页面列表,如果参数里面填<code>title_li=&lt;h2&gt;Pages&lt;/h2&gt;&amp;depth=3</code>,可以设置title的样式,depth指的是页面的展示深度</td>
</tr>
<tr>
<td>wp_list_cats()</td>
<td>展示分类列表,参数可填<code>sort_column=name&amp;optioncount=1&amp;hierarchical=0</code>,分别是设置排序根据,是否显示文章个数,以分层缩进的方式显示分类列表</td>
</tr>
<tr>
<td>get_links_list();</td>
<td>友情链接列表,在后台装插件之后就可以用了</td>
</tr>
<tr>
<td>wp_get_archives()</td>
<td>意思跟上面的差不多,也是有参数,获取的是文章归档列表,参数填type=daily的话就是按日期分,monthly按月分,yearly按年分,format=link以链接形式显示</td>
</tr>
<tr>
<td>wp_loginout()</td>
<td>退出登录链接</td>
</tr>
<tr>
<td>wp_register()</td>
<td>注册链接</td>
</tr>
<tr>
<td>wp_meta()</td>
<td>显示管理员的相关控制信息</td>
</tr>
<tr>
<td>get_calendar()</td>
<td>显示一个日历</td>
</tr>
<tr>
<td>include(TEMPLATEPATH . ‘/searchform.php’)</td>
<td>导入某个自定义文件,像左边就是/searchform.php文件</td>
</tr>
</tbody></table>
<h3 id="判断是否有日志并循环输出日志"><a href="#判断是否有日志并循环输出日志" class="headerlink" title="判断是否有日志并循环输出日志"></a>判断是否有日志并循环输出日志</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php if(have_posts()) : ?&gt; &lt;!--检查是否有日志--&gt;</span><br><span class="line">	&lt;?php while(have_posts()) : the_post(); ?&gt; &lt;!--循环输出日志--&gt;</span><br><span class="line">			&lt;div class&#x3D;&quot;post&quot; id&#x3D;&quot;post-&lt;?php the_ID(); ?&gt;&quot;&gt;</span><br><span class="line">				&lt;h2&gt;&lt;a href&#x3D;&quot;&lt;?php the_permalink(); ?&gt;&quot; title&#x3D;&quot;&lt;?php the_title(); ?&gt;&quot;&gt;&lt;?php the_title(); ?&gt;&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;&lt;!--日志标题--&gt;</span><br><span class="line">				&lt;div class&#x3D;&#39;entry&#39;&gt;</span><br><span class="line">				&lt;?php the_content(); ?&gt;</span><br><span class="line">			&lt;&#x2F;div&gt;</span><br><span class="line">			&lt;p class&#x3D;&quot;postmetadata&quot;&gt;</span><br><span class="line">			&lt;?php _e(&#39;Filed under&amp;#58;&#39;); ?&gt; &lt;?php the_category(&#39;, &#39;) ?&gt; &lt;?php _e(&#39;by&#39;); ?&gt; &lt;?php  the_author(); ?&gt;&lt;br &#x2F;&gt;</span><br><span class="line">			&lt;?php comments_popup_link(&#39;No Comments &amp;#187;&#39;, &#39;1 Comment &amp;#187;&#39;, &#39;% Comments &amp;#187;&#39;); ?&gt; &lt;?php edit_post_link(&#39;Edit&#39;, &#39; &amp;#124; &#39;, &#39;&#39;); ?&gt;</span><br><span class="line">			&lt;&#x2F;p&gt;</span><br><span class="line">			&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;?php endwhile; ?&gt;</span><br><span class="line">	&lt;div class&#x3D;&quot;navigation&quot;&gt;</span><br><span class="line">			&lt;?php posts_nav_link(&#39;index&#39;, &#39;&lt;&lt;上一页&#39;, &#39;下一页&gt;&gt;&#39;); ?&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;?php else : ?&gt; &lt;!--如果没有日志--&gt;</span><br><span class="line">	&lt;div class &#x3D; &quot;post&quot;&gt;</span><br><span class="line">		&lt;h2&gt;&lt;?php _e(&quot;Not Found&quot;); ?&gt;&lt;&#x2F;h2&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&lt;?php endif; ?&gt;</span><br></pre></td></tr></table></figure>

<h3 id="搜索框"><a href="#搜索框" class="headerlink" title="搜索框"></a>搜索框</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form method&#x3D;&quot;get&quot; id&#x3D;&quot;searchform&quot; action&#x3D;&quot;&lt;?php bloginfo(&#39;home&#39;); ?&gt;&#x2F;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line"></span><br><span class="line">	&lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;&lt;?php echo wp_specialchars($s, 1); ?&gt;&quot; name&#x3D;&quot;s&quot; id&#x3D;&quot;s&quot; size&#x3D;&quot;15&quot; &#x2F;&gt;&lt;br &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;input type&#x3D;&quot;submit&quot; id&#x3D;&quot;searchsubmit&quot; value&#x3D;&quot;Search&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 底层原理 --- KVC</title>
    <url>/post/34b9a649.html</url>
    <content><![CDATA[<p>本文讲述KVC的底层实现和KVC是否能触发KVO呢？</p>
<span id="more"></span>

<h2 id="KVC的使用"><a href="#KVC的使用" class="headerlink" title="KVC的使用"></a>KVC的使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self.person setValue:@10 forKey:@&quot;age&quot;]</span><br><span class="line"></span><br><span class="line">[self.person setValue:@10 forKeyPath:@&quot;age&quot;]</span><br></pre></td></tr></table></figure>

<p>keyPath和key的区别是，keyPath可以使用路径的方式进行赋值，比如person对象内有cat模型属性，cat对象里面有age属性，那么就可以使用<code>[self.person setValue:@10 forKeyPath:@&quot;cat.age&quot;]</code>的方式使用KVC，而key方式只支持直接访问的方式赋值</p>
<h2 id="赋值过程"><a href="#赋值过程" class="headerlink" title="赋值过程"></a>赋值过程</h2><p><code>setValue:forKey</code>首先会先寻找<code>setKey:</code>方法，如果找不到，那么就会寻找<code>_setKey:</code>方法，类似下面这样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 优先找这个方法</span><br><span class="line">- （void）setAge:(int)age &#123;</span><br><span class="line">	_age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 找不到上面那个方法的话，就找下面这儿方法</span><br><span class="line">- （void）_setAge:(int)age &#123;</span><br><span class="line">	_age &#x3D; age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上述两个方法都找不到，那么就会去访问类方法<code>+ (BOOL)accessInstanceVariablesDirectly</code>，询问是否允许直接访问成员变量，默认返回YES</p>
<ul>
<li><p>如果返回NO的话，那么程序会直接抛出异常<code>exception NSUnknownKeyException, reason:[XXX setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key age</code></p>
</li>
<li><p>如果返回YES，那么程序会去直接访问成员变量，查找的顺序是<code>_key、_isKey、key、isKey</code>，类似下面这样子</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    @public </span><br><span class="line">    int _age;</span><br><span class="line">    int _isAge;</span><br><span class="line">    int age;</span><br><span class="line">    int isAge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果找到了成员变量，那么就直接赋值</li>
<li>如果找不到成员变量，那么就抛出上述异常</li>
</ol>
<h2 id="KVC是否会触发KVO"><a href="#KVC是否会触发KVO" class="headerlink" title="KVC是否会触发KVO"></a>KVC是否会触发KVO</h2><p>由于KVO是通过重写set方法的方式实现的，所以如果KVC找到了属性值并且通过set方法赋值的话，那么就自然会触发KVO</p>
<p>如果KVC找不到set方法，如果<code>+ (BOOL)accessInstanceVariablesDirectly</code>返回YES的话，那么他去访问成员方法的时候，即便这时候成员方法是没有实现set方法的，KVC依旧会去执行<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>方法，在执行<code>didChangeValueForKey:</code>的时候，自然KVO就被触发了</p>
<h2 id="valueForKey-的底层原理"><a href="#valueForKey-的底层原理" class="headerlink" title="valueForKey:的底层原理"></a>valueForKey:的底层原理</h2><p><code>valueForKey:</code>首先会根据<code>getKey、key、isKey、_key</code>顺序查找方法，找到了的话就调用，拿到返回值。</p>
<p>如果没有找到方法，那么就会去访问类方法<code>+ (BOOL)accessInstanceVariablesDirectly</code>，询问是否允许直接访问成员变量，默认返回YES</p>
<p>如果允许，那么按照<code>_key、_isKey、key、isKey</code>顺序查找成员变量，找到了的话就直接取值，找不到就抛出异常<code>NSUnknownKeyException</code>。</p>
<p>如果不允许，就抛出异常<code>NSUnknownKeyException</code></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 底层原理 --- KVO</title>
    <url>/post/81c45883.html</url>
    <content><![CDATA[<p>本文简述KVO的底层实现是怎么一回事</p>
<span id="more"></span>

<h1 id="如何使用KVO"><a href="#如何使用KVO" class="headerlink" title="如何使用KVO"></a>如何使用KVO</h1><p>举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.person &#x3D; [[Person alloc] init];</span><br><span class="line">self.person.age &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; 这个配置的值会直接影响监听方法的change字典里面带些什么值给你</span><br><span class="line">NSKeyValueObservingOptions options &#x3D; NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld;</span><br><span class="line"></span><br><span class="line">[self.person addObserver:self keyPath:@&quot;age&quot; options:options context:@&quot;123&quot;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 当监听对象的属性值发生改变时，就会调用这个方法</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">	&#x2F;&#x2F;&#x2F; 这里的context就是注册监听的时候传入的@“123”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内部发生了什么"><a href="#内部发生了什么" class="headerlink" title="内部发生了什么"></a>内部发生了什么</h1><p>系统通过运行时机制，给<code>person</code>对象添加了一个父类，名为<code>NSKVONotifying_Person</code>(其他被监听的对象所生成的类也会遵循这个命名规则)，本质上是将<code>person</code>对象的isa指针指向了这个动态新建的类对象。</p>
<p>另外，这个新建的类对象是继承自<code>Person</code>的，也就是<code>NSKVONotifying_Person</code>的superclass指针指向了<code>Persond</code>的类对象。</p>
<h1 id="NSKVONotifying-类内部结构"><a href="#NSKVONotifying-类内部结构" class="headerlink" title="NSKVONotifying_*类内部结构"></a>NSKVONotifying_*类内部结构</h1><ul>
<li>isa指针</li>
<li>superclass指针</li>
<li>setAge:方法  因为监听的是age属性，所以重写了setAge方法，若监听的属性没有set方法，或者值改变的时候没有调用set方法，那么KVO无法生效</li>
<li>class:方法，主要是为了防止对象调用class方法的时候得到了这个动态生成的类对象，所以重写class方法，返回真正<code>的Person</code>类对象</li>
<li>_isKVOA方法，返回一个bool，用来判断这是不是一个KVO类</li>
<li>dealloc 进行一些收尾工作</li>
</ul>
<h2 id="重写的set方法的实现"><a href="#重写的set方法的实现" class="headerlink" title="重写的set方法的实现"></a>重写的set方法的实现</h2><p>大概是这么实现的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setAge:(int)age &#123;</span><br><span class="line">   _NSSetIntValueAnyNotify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _NSSetIntValueAnyNotify() </span><br><span class="line">&#123;</span><br><span class="line">   [self willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">   [super setAge:age];</span><br><span class="line">   [self didChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key &#123;</span><br><span class="line">   [observer observeValueForKeyPath:key ofObject:self change:nil context:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的方法<code>_NSSetIntValueAnyNotify</code>，看具体监听的属性类型而定，如果监听的是<code>double</code>类型，那么方法就会变成<code>_NSSetDoubleValueAnyNotify</code>，所以系统内置了很多这种类似的方法，统称为<code>_NSSet*ValueAnyNotify</code></p>
<ul>
<li><p>调用流程</p>
<ol>
<li>willChangeValueForKey:</li>
<li>setAge:</li>
<li>observeValueForKeyPath:ofObject:change:context:</li>
<li>didChangeValueForKey:</li>
</ol>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>利用Runtime API动态生成一个之类，并且让instance对象的isa指针指向这个全新的子类</p>
</li>
<li><p>当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAnyNotify函数</p>
<ul>
<li>willChangeValueForKey:</li>
<li>父类原来的setter</li>
<li>didChangeValueForKey:<ul>
<li>内部会触发监听器（Observer）的监听方法（observeValueForKeyPath:ofObject:change:context:）</li>
</ul>
</li>
</ul>
</li>
<li><p>如何手动触发KVO<br>  注册监听后，手动调用<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p>
</li>
<li><p>直接修改成员属性的值不会触发KVO，必须在前后分别补上<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 底层原理 --- NSObject</title>
    <url>/post/70f61b87.html</url>
    <content><![CDATA[<p>本文只是作为iOS底层原理课程的笔记用，所以均为结论性内容，如有疑问可在评论区进行探讨。</p>
<span id="more"></span>

<h2 id="NSObject的本质"><a href="#NSObject的本质" class="headerlink" title="NSObject的本质"></a>NSObject的本质</h2><h3 id="一个NSObject对象占用16个字节。"><a href="#一个NSObject对象占用16个字节。" class="headerlink" title="一个NSObject对象占用16个字节。"></a>一个NSObject对象占用16个字节。</h3><p>验证方法</p>
<ol>
<li><p>初始化一个<code>NSObject</code>对象<br> <code>NSObject *obj = [[NSObject alloc] init];</code></p>
</li>
<li><p>打印内存分配的量，得到16字节<br> <code>malloc_size((__bridge const void *)obj)</code> </p>
</li>
<li><p>但是实际上只使用了8个字节，因为使用<code>class_getInstanceSize([NSObject class])</code>得到8</p>
</li>
</ol>
<p><code>class_getInstanceSize</code>计算出了NSObject对象内的成员变量（即isa）的占用内存大小</p>
<h3 id="NSObject实质上是一个结构体对象"><a href="#NSObject实质上是一个结构体对象" class="headerlink" title="NSObject实质上是一个结构体对象"></a>NSObject实质上是一个结构体对象</h3><p>大概长这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct NSObject_IMPL &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为成员变量isa永远是对象（NSObject的子类对象）的第一个成员变量，所以对象的地址就是成员变量isa的地址</p>
<h3 id="NSObject的子类"><a href="#NSObject的子类" class="headerlink" title="NSObject的子类"></a>NSObject的子类</h3><p>比如有这么一个类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface Student : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">    int _no;</span><br><span class="line">    int _age;</span><br><span class="line">    int _height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student *stu &#x3D; [[Student alloc] init];</span><br></pre></td></tr></table></figure>

<p><code>class_getInstanceSize([Student class])</code> 得到 24（意思为这个类至少需要的内存）<br><code>malloc_size((__bridge const void *)stu)</code> 得到32（意思为系统分配给这个类的内存）</p>
<p>一般情况下我们更关心<code>malloc_size</code>得到的值</p>
<p>因为继承自<code>NSObject</code>，所以<code>Student</code>有一个<code>Class isa</code>属性，占用8个字节，<code>_no</code>、<code>_age</code>、<code>_height</code> 各占用4个字节，一共占用20个字节，</p>
<p>因为内存分配原则为<strong>最大成员所占内存</strong>（目前是isa 最大）的倍数，所以给够24个，这个叫做字节对齐</p>
<p>因为 <code>isa</code>、<code>_no</code>、<code>_age</code> 刚好够 16个字节了，这时候突然又来多了个<code>_height</code>，这时候就需要20个字节了 , 那么为了适配各个厂商的内存读取规则，又给他分配了16个（凑16的倍数），这个叫做内存对齐，所以一共给类分配了 32个字节</p>
<p>注：int 占用4个字节 double占用8个字节</p>
<p>分配原则：如果内存一行(16个字节)放不下，那么就直接开新的一行<br>比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_no : Int </span><br><span class="line">_age : Double</span><br><span class="line">_height : Int</span><br></pre></td></tr></table></figure>

<p>第一行：<code>isa</code> :8个，<code>_no</code> 4个，第一行剩下4个字节的位置，不够放<code>_age</code>,但是够放<code>_height</code>，那就直接放<code>_height</code>，如果这时候<code>_height</code>是<code>Double</code>的话，没别的东西来占用这4个位置，那么就直接放弃，开辟下一行<br>第二行：前八个位置直接给<code>_age</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x108b0bb00: d1 81 00 00 01 80 1d 01  &lt;- isa   04 00 00 00 &lt;- age   00 00 00 00  &lt;- height ................</span><br><span class="line">0x108b0bb10: 00 00 00 00 00 00 00 00  &lt;- age 00 00 00 00 00 00 00 00  ................</span><br></pre></td></tr></table></figure>

<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h3><p>__sizeof()__方法是一个运算符，在编译期间就确定值，类似于宏替换，他的作用是计算传入的对象占用的内存的大小，如果传入的是类型（或者类名）的话，就计算类型占用的大小，比如传入一个对象的话，就是计算指向这个对象的指针的大小，指针占用的内存大小是8个字节，跟<code>class_getInstanceSize</code>的区别是<code>class_getInstanceSize</code>是计算类实例化后占用的大小。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 底层原理 --- instance、class和meta-class</title>
    <url>/post/fdd98f42.html</url>
    <content><![CDATA[<p>本文讲的是实例对象(instance)，类对象(class)，元类对象（meta-class）的内容和他们之间的联系</p>
<span id="more"></span>

<h1 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h1><p>实例对象内存储着成员变量的值</p>
<h1 id="class对象"><a href="#class对象" class="headerlink" title="class对象"></a>class对象</h1><h2 id="class对象的基本内容"><a href="#class对象的基本内容" class="headerlink" title="class对象的基本内容"></a>class对象的基本内容</h2><p>每个类在内存中有且只有一个class对象</p>
<p>class对象在内存中，存储的信息主要包括</p>
<ul>
<li>isa指针</li>
<li>superclass指针</li>
<li>类的属性信息（@property）、 类的对象方法信息（instance method）</li>
<li>类的协议信息（protocol）、类的成员变量信息（ivar）</li>
</ul>
<h2 id="class对象的结构"><a href="#class对象的结构" class="headerlink" title="class对象的结构"></a>class对象的结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rw: readwrite</span><br><span class="line">ro: readonly</span><br><span class="line">t:   table</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">	Class isa;</span><br><span class="line">	Class superclass;</span><br><span class="line">	cache_t cache; 	&#x2F;&#x2F; 方法缓存</span><br><span class="line">	cache_data_bits_t bits; &#x2F;&#x2F; 用于获取具体类信息</span><br><span class="line">	</span><br><span class="line">	class_rw_t *data() &#123;</span><br><span class="line">	   return bits.data();  &#x2F;&#x2F;  实际方法实现为 bits &amp; FAST_DATA_MASK  结果返回值为 class_rw_t类型的对象</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct class_rw_t &#123;</span><br><span class="line">	unit32 flags;</span><br><span class="line">	unit32 version;</span><br><span class="line">	const class_ro_t *ro;			&#x2F;&#x2F; 方法列表</span><br><span class="line">	property_list_t *properties;		&#x2F;&#x2F; 属性列表</span><br><span class="line">	const protocol_list_t *protocols;	&#x2F;&#x2F; 协议列表</span><br><span class="line">	Class firstSubclass;</span><br><span class="line">	Class nextSiblingClass;</span><br><span class="line">	chat *demangledName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct class_ro_t &#123;</span><br><span class="line">	uint32_t flags;</span><br><span class="line">	unit32_t instanceStart;</span><br><span class="line">	unit32_t instanceSize; 			&#x2F;&#x2F; instance对象占用的内存空间</span><br><span class="line">	</span><br><span class="line">	const uint8_t * ivarLayout;</span><br><span class="line">	const chat * name; 			&#x2F;&#x2F; 类名</span><br><span class="line">	method_list_t  * baseMethodList;</span><br><span class="line">	protoocl_list_t * baseProtocols;</span><br><span class="line">	const ivar_list_t *ivars;		  &#x2F;&#x2F; 成员变量列表</span><br><span class="line">	const uint8_t *weakIverLayout;</span><br><span class="line">	property_list_t *baseProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相关的几个函数"><a href="#相关的几个函数" class="headerlink" title="相关的几个函数"></a>相关的几个函数</h2><ol>
<li><code>Class objc_getClass(const chat *aClassName)</code><ol>
<li>传入字符串类名</li>
<li>返回对应的类对象</li>
</ol>
</li>
<li><code>Class object_getClass(id obj)</code>获取isa指向的对象<ol>
<li>传入的obj可能是instance对象、class对象、meta-class对象</li>
<li>返回值<ol>
<li>如果是instance对象，返回class对象</li>
<li>如果是class对象，返回meta-class对象</li>
<li>如果是meta-class对象，返回NSObject（基类）的meta-class对象</li>
</ol>
</li>
</ol>
</li>
<li> <code>- (Class)class</code>、<code>+ (Class)class</code> 返回的就是类对象</li>
</ol>
<h1 id="meta-class对象"><a href="#meta-class对象" class="headerlink" title="meta-class对象"></a>meta-class对象</h1><p>意思是用来描述类对象的对象，是一种特殊的类对象。</p>
<p>每个类在内存中有且只有一个meta-class对象</p>
<p>meta-class对象和class对象的内存接口是一样的，但是用途不一样，在内存中存储的信息主要包括</p>
<ul>
<li>isa指针</li>
<li>superclass指针</li>
<li>类的类方法信息</li>
</ul>
<h1 id="isa指针和spuerclass指针"><a href="#isa指针和spuerclass指针" class="headerlink" title="isa指针和spuerclass指针"></a>isa指针和spuerclass指针</h1><img src="https://i.loli.net/2021/05/26/pjxbn5vQ17hrmae.png" width="50%">


<h2 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h2><p>instance的isa指向class</p>
<blockquote>
<p>当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用</p>
</blockquote>
<p>class的isa指向meta-class</p>
<blockquote>
<p>当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用 </p>
</blockquote>
<p>meta-class的isa指向基类（NSObject）的meta-class（NSObject的meta-class的isa指向自己的meta-class）</p>
<h2 id="superclass指针"><a href="#superclass指针" class="headerlink" title="superclass指针"></a>superclass指针</h2><p>举个例子，比如Student类继承自Person类，Person类继承自NSObject类：</p>
<p>Student的class的superclass指针指向父类的class对象，如果没有父类（NSObject），则superclass指针为空</p>
<p>Student的meta-class对象的superclass指针指向Person的meta-class</p>
<p>基类（NSObject）的meta-class的superclass指针指向class对象</p>
<h3 id="调用成员方法"><a href="#调用成员方法" class="headerlink" title="调用成员方法"></a>调用成员方法</h3><p>因为Student要调用成员方法的时候，需要找到class对象，因为class对象才存放着成员方法，找不到的话就通过superclass指针找到父类class对象看看里面有没有想要的成员方法</p>
<h3 id="调用类方法"><a href="#调用类方法" class="headerlink" title="调用类方法"></a>调用类方法</h3><p>当Student要调用Student的类方法的时候，就通过Student的class对象的isa找到Student的meta-class对象，然后找到类方法进行调用</p>
<p>当Student要调用Person的类方法的时候，就得先通过Student的class对象的isa找到Student的meta-class对象，然后通过Student的mata-class对象里面的superclass指针找到Person的meta-class对象，然后在里面找到Person的类方法进行调用</p>
<h3 id="调用init方法"><a href="#调用init方法" class="headerlink" title="调用init方法"></a>调用init方法</h3><p>比如现在Student对象要调用init方法，流程如下</p>
<ol>
<li>先通过对象自己的isa指针，找到Student的类对象</li>
<li>Student的类对象里面有superclass指针，那么就通过superclass指针拿到了Person的类对象</li>
<li>Person的类对象里面也有superclass指针，那么就通过superclass指针拿到NSObject的类对象</li>
<li>NSObject的类对象里面找到了init方法的相关信息，那么就可以进行调用了</li>
</ol>
<h3 id="调用不存在的类方法"><a href="#调用不存在的类方法" class="headerlink" title="调用不存在的类方法"></a>调用不存在的类方法</h3><p>Student调用一个不存在的类方法流程</p>
<ol>
<li>通过isa指针找到类对象</li>
<li>类对象的isa指针找到meta-class对象</li>
<li>meta-class找不到该类方法，通过superclass指针找到父类的meta-class对象</li>
<li>一直找，直到找到基类的meta-class对象，基类的meta-class的superclass指向基类的class对象</li>
<li>基类的class对象里面有对象方法，如果对象方法刚好跟准备调用的类方法同名，那么则会调用该对象方法，如果找不到，则开始抛出异常</li>
</ol>
<h2 id="ISA-MASK"><a href="#ISA-MASK" class="headerlink" title="ISA_MASK"></a>ISA_MASK</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if __arm64___</span><br><span class="line">#define ISA_MASK 0x000000ffffffff8ULL</span><br><span class="line">#elif __x86_64__</span><br><span class="line">#define  ISA_MASK 0x00007ffffffffff8ULL</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>实例对象从64位系统开始，isa不直接指向类对象的地址，isa需要进行一次位运算，才能计算出真实地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">instance的 isa &amp; ISA_MASK -&gt; class对象</span><br><span class="line">class的isa &amp; ISA_MASK -&gt; meta_class 对象</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 底层原理 --- isa指针</title>
    <url>/post/78ececc4.html</url>
    <content><![CDATA[<p>本文讲述isa指针在runtime内部的底层实现和isa的优化方式</p>
<span id="more"></span>

<h2 id="isa指针的底层实现"><a href="#isa指针的底层实现" class="headerlink" title="isa指针的底层实现"></a>isa指针的底层实现</h2><ul>
<li><p>在arm64架构出现之前，isa就是一个普通的指针(<code>Class isa</code>)，存储着Class,Meta-Class对象的内存地址</p>
</li>
<li><p>从arm64架构开始，对isa进行了优化，变成了一个共用体，还使用位域来存储更多的信息</p>
</li>
<li><p>isa指针的结构如下（objc4-818.2）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">union isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    struct &#123;</span><br><span class="line">        uintptr_t nonpointer        : 1; </span><br><span class="line">        uintptr_t has_assoc         : 1;</span><br><span class="line">        uintptr_t has_cxx_dtor      : 1;</span><br><span class="line">        uintptr_t shiftcls          : 33;</span><br><span class="line">        uintptr_t magic             : 6;</span><br><span class="line">        uintptr_t weakly_referenced : 1;</span><br><span class="line">        uintptr_t unused            : 1;</span><br><span class="line">        uintptr_t has_sidetable_rc  : 1;</span><br><span class="line">        uintptr_t extra_rc          : 19</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    bool isDeallocating() &#123;</span><br><span class="line">        return extra_rc &#x3D;&#x3D; 0 &amp;&amp; has_sidetable_rc &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    void setDeallocating() &#123;</span><br><span class="line">        extra_rc &#x3D; 0;</span><br><span class="line">        has_sidetable_rc &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setClass(Class cls, objc_object *obj);</span><br><span class="line">    Class getClass(bool authenticated);</span><br><span class="line">    Class getDecodedClass(bool authenticated);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先，共用体同结构体一样，是拥有成员变量的，但是不同的点在于所有成员变量共用一块内存，也就是说当一个成员变量有值时，其他成员变量都成了装饰。</p>
<p>在runtime中，我们只需要用到<code>uintptr_t bits</code>，<code>uintptr_t</code>是<code>unsigned long</code>的别名，在64位系统下占用8个字节，共64位</p>
<p>共用体内的<code>struct &#123; ... &#125;</code> 是为了增加可读性而添加的，它描述了<code>bits</code>里面存放了什么信息，我们一个个说明一下</p>
<blockquote>
<p>补充说明： 结构体内的冒号后面的数字表示这个成员所占的位数，举个例子，本来<code>char name</code>作为一个成员变量，是会占用一个字节，也就是8个二进制位，如果有3个这样子的成员变量，那么这个结构体就会占用3个字节，如果我们在这个成员变量的后面添加了一个数字，去限制这个成员变量所占的位数，比如<code>char name : 1</code>，那么三个这样子的成员变量就一共占用3个二进制位，也就是不到一个字节，因为系统分配内存的最小单位为1个字节，所以这个结构体就占用1个字节，这么做我们就可以节约2个字节了，这种技术叫做<strong>位域</strong>。</p>
</blockquote>
<ul>
<li>nonpointer<ul>
<li>0代表普通的指针，存储着Class、Meta-Class对象的内存地址</li>
<li>1代表优化过，使用位域存储着更多的信息</li>
</ul>
</li>
<li>has_assoc<ul>
<li>是否有设置过关联对象（注意是“设置过”，就算以后关联对象移除了，它还会是true），如果没有，会释放得更快</li>
</ul>
</li>
<li>has_cxx_dtor<ul>
<li>是否有C++的析构函数（.cxx_destruct），如果没有，会释放得更快</li>
</ul>
</li>
</ul>
<p>上面两个<code>会释放得更快</code>的原因是，在对象销毁的时候，会调用runtime里面的这个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        &#x2F;&#x2F; Read all of the flags at once for performance.</span><br><span class="line">        bool cxx &#x3D; obj-&gt;hasCxxDtor();</span><br><span class="line">        bool assoc &#x3D; obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; This order is important.</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        if (assoc) _object_remove_assocations(obj, &#x2F;*deallocating*&#x2F;true);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到如果<code>has_assoc</code>或者<code>has_cxx_dtor</code>的话，就不会进入判断为true的逻辑，函数会运行得更快</p>
<ul>
<li>shiftcls<ul>
<li>存储着Class、Meta-Class对象的内存信息</li>
</ul>
</li>
<li>magic<ul>
<li>用于在调试时分辨对象是否未完成初始化</li>
</ul>
</li>
<li>weakly_referenced<ul>
<li>是否有被弱引用指向过（同样注意“指向过”，有过即为true），如果没有，释放时会更快</li>
</ul>
</li>
</ul>
<p>“会释放得更快”是因为对象销毁时调用了如下runtime源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NEVER_INLINE void</span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    SideTable&amp; table &#x3D; SideTables()[this];</span><br><span class="line">    table.lock();</span><br><span class="line">    if (isa.weakly_referenced) &#123;</span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)this);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.erase(this);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>deallocating<ul>
<li>对象是否正在释放</li>
</ul>
</li>
<li>extra_rc <ul>
<li>里面存储的值是引用计数器减1后的值</li>
</ul>
</li>
<li>has_sitdtable_rc<ul>
<li>引用计数器是否过大无法存储在isa中</li>
<li>如果为1，那么引用计数器会存储在一个叫做SideTable的类的属性中</li>
</ul>
</li>
</ul>
<h2 id="如何从isa指针中取出对应的信息"><a href="#如何从isa指针中取出对应的信息" class="headerlink" title="如何从isa指针中取出对应的信息"></a>如何从isa指针中取出对应的信息</h2><p>isa是通过位运算来取出和存入信息的。</p>
<ul>
<li>我们以取出<code>shiftcls</code>内的类信息为例</li>
</ul>
<p>首先isa里面的bits存储着64个二进制位，然后其中<code>shiftcls</code>是使用了33个（从上面的共用体里面的位域看出），当系统需要取出对应信息的时候，就使用<code>ISA_MASK</code>（ISA掩码）跟bits做一次与运算，举个例子，bits的十六进制地址为<code>0x011d8001000083a5</code></p>
<blockquote>
<p>补充： ISA_MASK在arm64下的值为<code>0x0000000ffffffff8ULL</code>，下面我们把他转成二进制</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>8</th>
<th>16</th>
<th>24</th>
<th>32</th>
<th>40</th>
<th>48</th>
<th>56</th>
<th>64</th>
</tr>
</thead>
<tbody><tr>
<td>bits<br>(0x011d8001000083a5)</td>
<td>1010 0101</td>
<td>1100 0001</td>
<td>0000 0000</td>
<td>0000 0000</td>
<td>1000 0000</td>
<td>0000 0001</td>
<td>1011 1000</td>
<td>1000 0000</td>
</tr>
<tr>
<td>ISA_MASK<br>(0x0000000ffffffff8)</td>
<td>0001 1111</td>
<td>1111 1111</td>
<td>1111 1111</td>
<td>1111 1111</td>
<td>1111 0000</td>
<td>0000 0000</td>
<td>0000 0000</td>
<td>0000 0000</td>
</tr>
<tr>
<td>与运算后的结果<br>(0x00000001000083a0)</td>
<td>0000 0101</td>
<td>1100 0001</td>
<td>0000 0000</td>
<td>0000 0000</td>
<td>1000 0000</td>
<td>0000 0000</td>
<td>0000 0000</td>
<td>0000 0000</td>
</tr>
</tbody></table>
<p>我们可以来验证一下</p>
<img src="https://z3.ax1x.com/2021/06/15/2qoart.png" width="80%">


<p>可以看到 isa一开始的值跟<code>[person class]</code>的值是不相同的，跟<code>ISA_MASK</code>进行一次与运算之后就相同了，所以可以看出实例对象的isa不是直接指向类对象的，是需要进行一次运算取出来的。</p>
<ul>
<li>其他的信息如<code>nonpointer</code>等，取出的方式也类似这样，这么做的好处是充分利用了64个二进制位的内存，而不用像以前一样一个属性就占用了多个字节，造成二进制位的浪费。</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 13新API</title>
    <url>/post/f356f3c1.html</url>
    <content><![CDATA[<p>可能会用到的iOS13新Api</p>
<span id="more"></span>

<h2 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h2><h3 id="截图转PDF"><a href="#截图转PDF" class="headerlink" title="截图转PDF"></a>截图转PDF</h3><p>safari可以长截图了<br><img width=20% src="https://i.loli.net/2019/10/24/iHxWAqL63E2ZfMY.jpg"></p>
<p>然后我们可以把<code>UIScrollView</code>的截图转成PDF</p>
<p><a href="https://developer.apple.com/documentation/uikit/uiscreenshotservicedelegate">文档</a></p>
<h3 id="双指滑动手势"><a href="#双指滑动手势" class="headerlink" title="双指滑动手势"></a>双指滑动手势</h3><p><img src="https://i.loli.net/2019/10/24/FbSEV8WCXcQRrf9.gif"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 是否允许多指选中</span><br><span class="line">optional func tableView(_ tableView: UITableView, shouldBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) -&gt; Bool</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;多指选中开始，这里可以做一些UI修改，比如修改导航栏上按钮的文本</span><br><span class="line">optional func tableView(_ tableView: UITableView, didBeginMultipleSelectionInteractionAtIndexPath indexPath: IndexPath) </span><br></pre></td></tr></table></figure>

<h3 id="深色模式"><a href="#深色模式" class="headerlink" title="深色模式"></a>深色模式</h3><p>见<a href="https://www.jianshu.com/p/176537b0d9dd">文章</a></p>
<h2 id="Framework类"><a href="#Framework类" class="headerlink" title="Framework类"></a>Framework类</h2><h3 id="Multiple-UI-Instances"><a href="#Multiple-UI-Instances" class="headerlink" title="Multiple UI Instances"></a>Multiple UI Instances</h3><p>可以支持一个界面同时展示多个控制器（不是父子控制器那种）<br>在iPad上可以使用</p>
<p><img src="https://docs-assets.developer.apple.com/published/8ce996907a/fc0975ae-c186-438c-abdd-5280f650c377.png"></p>
<p>主要类<code>UIScene</code></p>
<p><a href="https://developer.apple.com/documentation/uikit/app_and_environment">文档</a></p>
<h3 id="BackgroundTasks"><a href="#BackgroundTasks" class="headerlink" title="BackgroundTasks"></a>BackgroundTasks</h3><p>好消息~ 现在维持后台不被杀可以直接用这个API了，以前的会用后台获取定位和播放静音音乐的方式，但是现在只要注册后台就可以了，但是还是只有短期，长时间的话可能会要求充电状态或者持续的网络状态。</p>
<p><a href="https://developer.apple.com/documentation/backgroundtasks/">文档</a></p>
<h3 id="Camera-Capture"><a href="#Camera-Capture" class="headerlink" title="Camera Capture"></a>Camera Capture</h3><p>现在可以同时使用前后摄像头，可以进行分割遮罩，可以识别出头发，皮肤，牙齿</p>
<p><a href="https://developer.apple.com/documentation/avfoundation/avcapturemulticamsession/">文档1</a></p>
<p><a href="https://developer.apple.com/documentation/avfoundation/avsemanticsegmentationmatte/">文档2</a></p>
<h3 id="Combine"><a href="#Combine" class="headerlink" title="Combine"></a>Combine</h3><p>官方版RxSwift，主要是配合SwiftUI使用</p>
<p><a href="https://developer.apple.com/documentation/combine/">文档</a></p>
<h3 id="Core-Haptics"><a href="#Core-Haptics" class="headerlink" title="Core Haptics"></a>Core Haptics</h3><p>可以在UI交互的时候给点小触觉反馈，比如打开关闭UISwitch的时候小震动一下，或者播放点声音之类的</p>
<p><a href="https://developer.apple.com/documentation/corehaptics/">文档</a></p>
<h3 id="Apple-CryptoKit"><a href="#Apple-CryptoKit" class="headerlink" title="Apple CryptoKit"></a>Apple CryptoKit</h3><p>好消息，苹果自带HMAC、SHA、AES、NIST加密算法啦</p>
<p><a href="https://developer.apple.com/documentation/cryptokit/">文档</a></p>
<h3 id="VisionKit"><a href="#VisionKit" class="headerlink" title="VisionKit"></a>VisionKit</h3><p>好消息，苹果自带图片转文字功能啦</p>
<p><a href="https://developer.apple.com/documentation/visionkit/">文档</a></p>
<h3 id="MetricKit"><a href="#MetricKit" class="headerlink" title="MetricKit"></a>MetricKit</h3><p>用来收集用户设备信息的，主要是使用App的过程中的耗电，CPU等等性能指标，可以依据这些优化你的App</p>
<p><a href="https://developer.apple.com/documentation/metrickit/">文档</a></p>
<h3 id="PencilKit"><a href="#PencilKit" class="headerlink" title="PencilKit"></a>PencilKit</h3><p>iPad上跟Apple Pencil交互的API</p>
<p><a href="https://developer.apple.com/documentation/pencilkit/">文档</a></p>
<h3 id="Vision"><a href="#Vision" class="headerlink" title="Vision"></a>Vision</h3><p>图像识别相关framework<br>iOS11的功能：面部和面部界标检测，条形码识别，图像配准以及一般特征跟踪。</p>
<p>iOS13的新功能：</p>
<ol>
<li>对图像进行显著性分析。</li>
<li>在图像中检测人类和动物。</li>
<li>对图像进行分类和搜索。</li>
<li>分析图像与特征打印的相似性。</li>
<li>对文档执行文本识别。</li>
</ol>
<p><a href="https://developer.apple.com/documentation/vision/">文档</a></p>
<h3 id="Sign-in-with-Apple"><a href="#Sign-in-with-Apple" class="headerlink" title="Sign in with Apple"></a>Sign in with Apple</h3><p>苹果登录</p>
<p><a href="https://developer.apple.com/sign-in-with-apple/get-started/">文档</a></p>
<h3 id="SF-Symbols"><a href="#SF-Symbols" class="headerlink" title="SF Symbols"></a>SF Symbols</h3><p>可以用来显示矢量图</p>
<p><a href="https://developer.apple.com/documentation/uikit/uiimage/configuring_and_displaying_symbol_images_in_your_ui/">文档</a></p>
<h3 id="Bring-Your-iPad-App-to-Mac"><a href="#Bring-Your-iPad-App-to-Mac" class="headerlink" title="Bring Your iPad App to Mac"></a>Bring Your iPad App to Mac</h3><p>直接把iPad App 迁移到 Mac，不过还是要做适配的，下面文档会有一些适配规则，以兼容两个端</p>
<p><a href="https://developer.apple.com/design/human-interface-guidelines/ios/overview/mac-catalyst/">参考</a></p>
<p><a href="https://developer.apple.com/documentation/xcode/creating_a_mac_version_of_your_ipad_app">文档1</a></p>
<p><a href="https://developer.apple.com/documentation/uikit/mac_catalyst/optimizing_your_ipad_app_for_mac">文档2</a></p>
<h3 id="ARKit-3"><a href="#ARKit-3" class="headerlink" title="ARKit 3"></a>ARKit 3</h3><p>应该大家都知道ARKit，这次主要是多了些新特性，包括动态捕捉动作，同时捕捉多个面部，同时开启前后摄像头等。</p>
<p><a href="https://developer.apple.com/documentation/arkit/">文档</a></p>
<h3 id="RealityKit"><a href="#RealityKit" class="headerlink" title="RealityKit"></a>RealityKit</h3><p>3D模型搭建、展示用</p>
<p><a href="https://developer.apple.com/documentation/realitykit/">文档</a></p>
<h3 id="Core-ML-3"><a href="#Core-ML-3" class="headerlink" title="Core ML 3"></a>Core ML 3</h3><p>升级版机器学习套件</p>
<p><a href="https://developer.apple.com/documentation/coreml/">文档</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>feature</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 14 App Clips</title>
    <url>/post/a44df9c3.html</url>
    <content><![CDATA[<p>本文将主要探讨App Clips开发流程 和 组件化、非组件化两种开发方式下如何复用代码的问题。</p>
<span id="more"></span>

<p>App Clips是iOS14系统的新特性之一，类似于小程序，用户可以在不下载App的情况下体验到App的部分功能，如网易严选的商品详情功能（<a href="https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw">https://m.you.163.com/item/detail?id=1615007#/?_k=yz97vw</a>），该功能适合做一些推广和引流的运营工作，另外苹果也提供的原生的浮窗样式，可以引导用户下载完整版App。</p>
<p>苹果官方文档：<a href="https://developer.apple.com/app-clips/">https://developer.apple.com/app-clips/</a></p>
<h3 id="目前已知的触发方式"><a href="#目前已知的触发方式" class="headerlink" title="目前已知的触发方式"></a>目前已知的触发方式</h3><ul>
<li><p>二维码</p>
<p>  必须使用iOS 14系统相机或者使用控制中心的读取二维码组件来扫码才能触发App Clips。</p>
</li>
<li><p>NFC Tags</p>
<p>  NFC标签感应，比如星巴克桌面内嵌的NFC Tags。</p>
</li>
<li><p>Safari App Banner</p>
<p>  当用户用iOS的Safari浏览器浏览相应的网址后，页面顶部会出现一个横幅，提示用户有App Clips可以用。</p>
</li>
<li><p>信息</p>
<p>  iOS系统自带的iMessage，当你在iMessage发送一个App Clips链接时，系统会自动把信息显示成一个App Clips的卡片。</p>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a13d29c7a17d471dbc551c416ce2ed57~tplv-k3u1fbpfcp-watermark.image"></p>
<h3 id="开发前置工作"><a href="#开发前置工作" class="headerlink" title="开发前置工作"></a>开发前置工作</h3><h4 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h4><h5 id="创建App-Clips-ID"><a href="#创建App-Clips-ID" class="headerlink" title="创建App Clips ID"></a>创建App Clips ID</h5><ol>
<li>点击新增APP ID</li>
</ol>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d62145df226549428f600ace6f1b44cb~tplv-k3u1fbpfcp-zoom-1.image" >

<ol start="2">
<li>选择App Clip <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f93a07c34f7249b982f0cbca84bfcafe~tplv-k3u1fbpfcp-zoom-1.image" >
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da0c96044db46bb897aab6f71543c8d~tplv-k3u1fbpfcp-zoom-1.image" ></li>
</ol>
<ol start="3">
<li>输入一串英文名，用于拼接在主工程的bundle id的后面，生成该clip的bundle id <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2ae0fb422f149d98589f36c80123315~tplv-k3u1fbpfcp-zoom-1.image" >
 </li>
<li>在Description内输入描述（不能使用特殊符号），并且在下方勾选App Clip能力，比如Apple Pay，Sign in with Apple，Push等等，<strong>Associated Domains必须勾选</strong><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33e78440190242efaa8dac9b47004393~tplv-k3u1fbpfcp-zoom-1.image" >
 </li>
<li>最后确认并点击右上方Register即可</li>
</ol>
<h5 id="创建Profiles"><a href="#创建Profiles" class="headerlink" title="创建Profiles"></a>创建Profiles</h5><p>流程跟创建App的Profiles一样，就是选择bundle id的时候改成Clip的bundle id 即可，同样有Development、AdHoc、Distribution三种类型</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68bfe6ee218047b7a3232058dcc2e006~tplv-k3u1fbpfcp-zoom-1.image" >

<h5 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h5><p>如果需要其他NFC、地点等等的一些方式触发App Clip配置的话，参考这个苹果的文档<a href="https://help.apple.com/app-store-connect/#/dev5b665db74">https://help.apple.com/app-store-connect/#/dev5b665db74</a></p>
<h4 id="Apple-Store-Connect-配置图片和标题，描述"><a href="#Apple-Store-Connect-配置图片和标题，描述" class="headerlink" title="Apple Store Connect 配置图片和标题，描述"></a>Apple Store Connect 配置图片和标题，描述</h4><ol>
<li>需要一张1800 * 1200 的图片，用于显示在Clip的卡片上</li>
<li>副标题用于显示在卡片标题下的小字，如图所示<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b3e18f56f6d49219fc46f77dab1cef2~tplv-k3u1fbpfcp-zoom-1.image" width=30%></li>
<li>操作包括“打开”“查看”“开始游戏”，体现在卡片右边的蓝色按钮内的文案，根据你的产品类型进行选择就好</li>
</ol>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c14c35967084886bc3f4fce6e985fcb~tplv-k3u1fbpfcp-zoom-1.image" >


<h4 id="配置apple-app-site-association-json"><a href="#配置apple-app-site-association-json" class="headerlink" title="配置apple-app-site-association.json"></a>配置apple-app-site-association.json</h4><p>假设你的开发者账号的Team Id是<code>A123</code>，Clips的bundle id是<code>com.abc.def.clips</code>，主工程的bundle id 是<code>com.abc.def</code>，则配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;appclips&quot;:&#123;</span><br><span class="line">        &quot;apps&quot;:[&quot;A123.com.abc.def.clips&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;applinks&quot;:&#123;</span><br><span class="line">        &quot;apps&quot;:[</span><br><span class="line">        ],</span><br><span class="line">        &quot;details&quot;:&#123;</span><br><span class="line">            &quot;A123.com.abc.def&quot;:&#123;</span><br><span class="line">                &quot;paths&quot;:[</span><br><span class="line">                    &quot;*&quot; &#x2F;&#x2F; 这里的Path根据实际情况配置即可</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;webcredentials&quot;:&#123;</span><br><span class="line">        &quot;apps&quot;:[</span><br><span class="line">            &quot;A123.com.abc.def&quot;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;activitycontinuation&quot;:&#123;</span><br><span class="line">        &quot;apps&quot;:[</span><br><span class="line">            &quot;A123.com.abc.def&quot;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后部署到你自己域名的根目录下，配置方法网上很多教程，这里贴上<a href="https://developer.apple.com/documentation/safariservices/supporting_associated_domains?language=objc">苹果官方文档</a></p>
<p>如果配置错了，那么上传包到苹果后台之后，就会显示无效域名<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05ddb4d106a349d28c1504762697a9eb~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>如果是json配置错误，那么配置正确后不用重新传包，等待苹果那边刷新缓存就好。</p>
<p>App Clip支持最多在三个域名的网页显示入口，到后面的工程配置那里会说明。</p>
<h4 id="前端页面添加meta标签"><a href="#前端页面添加meta标签" class="headerlink" title="前端页面添加meta标签"></a>前端页面添加meta标签</h4><p>如果要在H5页面显示Clips入口，加上一段meta标签即可</p>
<p>如果你的应用市场App id是 <code>123456</code>, Clips的bundle id 是 <code>com.abc.clips</code> 则应该配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;apple-itunes-app&quot; content&#x3D;&quot;app-id&#x3D;123456,app-clip-bundle-id&#x3D;com.abc.clips&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="开发工作"><a href="#开发工作" class="headerlink" title="开发工作"></a>开发工作</h3><h4 id="新建App-Clip-Target"><a href="#新建App-Clip-Target" class="headerlink" title="新建App Clip Target"></a>新建App Clip Target</h4><p>这里以OC工程为例</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9edc6108c0b64885b708ef5c9de8e1d0~tplv-k3u1fbpfcp-zoom-1.image" >
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa5c9c1032174d77a4db0518029b78dd~tplv-k3u1fbpfcp-zoom-1.image" >

<h4 id="配置证书和Associated-Domains"><a href="#配置证书和Associated-Domains" class="headerlink" title="配置证书和Associated Domains"></a>配置证书和Associated Domains</h4><p>用刚才生成的证书去配置一下即可</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fbccb4eee1445ca9b680200358535e0~tplv-k3u1fbpfcp-zoom-1.image" >

<p>添加Associated Domains，目的是打开对应域名网页后，页面上方能够出现Clip的入口。</p>
<p><strong>这里可以添加多个域名，注意每个域名都需要配置apple-app-site-association！！！</strong></p>
<p><strong>主工程的Target和Clip的Target都需要配置！！！</strong></p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5125ca96f15433b8205294e48906e13~tplv-k3u1fbpfcp-zoom-1.image" >

<h4 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h4><p>创建完之后就会生成一个文件夹，里面就是我们熟悉的AppDelegate、SecneDelegate、Main.storyboard、Info.plist等文件，如果你不使用Storyboard进行界面搭建，那么也是跟之前的开发模式一样，删除info.plist内Application Scene Manifest，修改General-Deployment info - Main interface 为空，修改AppDelegate.m，在里面创建根控制器。</p>
<p>之后的操作就跟普通开发一样了，调试的话可以直接在Xcode上左上角选择Clip的target，然后就可以跑起来了。</p>
<p>另外，AppIcon是需要独立配置的，同样也是在Clip项目工程文件夹内Assets.xcassets。</p>
<h5 id="非组件化开发模式"><a href="#非组件化开发模式" class="headerlink" title="非组件化开发模式"></a>非组件化开发模式</h5><p>一般情况下我们是需要复用代码的，将代码内某些模块功能进行复用，然后直接用在Clip，这时候我们只需要在右侧Target Membership勾选新建的Clip Target即可。</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c2847eb910740229f410d0aa29f7bb5~tplv-k3u1fbpfcp-zoom-1.image" width=30%>

<p>同样的 相关的依赖到的文件也需要勾选Clip Target</p>
<h5 id="组件化开发模式-和-Podfile的配置"><a href="#组件化开发模式-和-Podfile的配置" class="headerlink" title="组件化开发模式 和 Podfile的配置"></a>组件化开发模式 和 Podfile的配置</h5><p>如果是在组件化开发模式下，那么就需要配置Podfile</p>
<p>在Podfile 底部新增代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class="line"># 你的私有pod仓库</span><br><span class="line">source &#39;https:&#x2F;&#x2F;git.xxx.com&#x2F;yourprivatepodspec&#x2F;Podspec.git&#39;</span><br><span class="line"></span><br><span class="line">target &#39;YourApp’ do</span><br><span class="line">    platform :ios, &#39;10.3&#39;</span><br><span class="line">    pod &quot;AFNetworking&quot;</span><br><span class="line">    pod &quot;SDWebImage&quot;</span><br><span class="line">    # 等等</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#39;YourApp_Clips&#39; do</span><br><span class="line">    platform :ios, &#39;10.3&#39;</span><br><span class="line">    pod &#39;ComponentA&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class="line">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class="line">    pod &quot;AFNetworking&quot;</span><br><span class="line">    pod &quot;SDWebImage&quot;</span><br><span class="line">    # 等等</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是这样子相同的第三方pod会写两遍，所以我们可以优化成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39;</span><br><span class="line"># 你的私有pod仓库</span><br><span class="line">source &#39;https:&#x2F;&#x2F;git.xxx.com&#x2F;yourprivatepodspec&#x2F;Podspec.git&#39;</span><br><span class="line"></span><br><span class="line">def common_pods</span><br><span class="line">    pod &quot;AFNetworking&quot;</span><br><span class="line">    pod &quot;SDWebImage&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#39;YourApp’ do</span><br><span class="line">    platform :ios, &#39;10.3&#39;</span><br><span class="line">    common_pods</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#39;YourApp_Clips&#39; do</span><br><span class="line">    platform :ios, &#39;14.0&#39;</span><br><span class="line">    pod &#39;ComponentA&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class="line">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class="line">    common_pods</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="抽离模块时不同环境的代码复用问题"><a href="#抽离模块时不同环境的代码复用问题" class="headerlink" title="抽离模块时不同环境的代码复用问题"></a>抽离模块时不同环境的代码复用问题</h5><p>假如说A功能需要抽离出来放到Clip，但是A模块里面有需求是会跳转到B模块的，但是我并不希望Clip引入B模块，希望他能在这个地方提示用户下载完整App，那应该怎么做呢？</p>
<p>首先第一个事情，苹果提供了一个Api可以引导弹窗引导用户下载APP</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fec69fde9e64618819b1b526034d23b~tplv-k3u1fbpfcp-zoom-1.image" width=40%>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIWindowScene *scene &#x3D; (UIWindowScene *)[[UIApplication sharedApplication].connectedScenes.allObjects firstObject];</span><br><span class="line">SKOverlayAppConfiguration *config &#x3D; [[SKOverlayAppConfiguration alloc] initWithAppIdentifier:@&quot;你的AppID&quot; position:SKOverlayPositionBottomRaised];</span><br><span class="line">SKOverlay *overlay &#x3D; [[SKOverlay alloc] initWithConfiguration:config];</span><br><span class="line">overlay.delegate &#x3D; self; &#x2F;&#x2F; 添加代理后可以监听弹窗的弹出和消失，可以在代理内添加埋点。</span><br><span class="line">[overlay presentInScene:scene];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 主动让弹窗消失</span><br><span class="line">&#x2F;&#x2F; [SKOverlay dismissOverlayInScene:scene];</span><br></pre></td></tr></table></figure>

<p>第二. 如何在模块内划分环境，区分是主App还是Clip</p>
<p>方法一：设计一个单例，添加一个枚举属性，分别在<code>主工程</code>的AppDelegate和<code>Clip</code>的AppDelegate内给单例的属性赋值，标记当前环境。然后在业务代码中获取单例的环境属性后进行判断。</p>
<p>方法二：有时候我们在Clip复用的模块代码内不需要import某些头文件，因为我们不需要这个功能，这时候单例的方法就不管用了，我们需要通过宏去判断。</p>
<p>如果代码不在pod组件内的话，只需要在Clip Target的<code>Build Settings</code> - <code>Preprocessor Macros</code>添加<code>APP_CLIPS</code>宏即可。</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7708c16f9c4247a9ab9ec393d01420b1~tplv-k3u1fbpfcp-zoom-1.image" >

<p>如果是组件化的开发模式，代码在pod内部，那么就稍微有点麻烦，需要在对应podspec新增一个subspec，专门提供给clip使用，然后配置上宏定义</p>
<p><code>ComponentA.podspec</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">s.subspec &quot;App&quot; do |ss|</span><br><span class="line">    ss.source_files &#x3D; &quot;xxxxxx&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">s.subspec &quot;AppClip&quot; do |ss|</span><br><span class="line">    ss.source_files &#x3D; &quot;xxxxxx&quot;</span><br><span class="line">    ss.pod_target_xcconfig &#x3D; &#123; &#39;GCC_PREPROCESSOR_DEFINITIONS&#39; &#x3D;&gt; &#39;APP_CLIPS&#x3D;1&#39;&#125;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里为什么要弄多一个App的subspec，因为如果主工程直接<code>pod ComponentA</code>的话，所有的subspec都会被引入，所以这里为了区分开，就加多了一个专门给主工程用的subspec</p>
</blockquote>
<p><code>Podfile</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def common_pods</span><br><span class="line">    pod &quot;AFNetworking&quot;</span><br><span class="line">    pod &quot;SDWebImage&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#39;YourApp’ do</span><br><span class="line">    platform :ios, &#39;10.3&#39;</span><br><span class="line">    common_pods</span><br><span class="line">    pod &#39;ComponentA&#x2F;App&#39;,           :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target &#39;YourApp_Clips&#39; do</span><br><span class="line">    platform :ios, &#39;14.0&#39;</span><br><span class="line">    pod &#39;ComponentA&#x2F;AppClip&#39;,   :path&#x3D;&gt; &#39;..&#x2F;ComponentA&#39;</span><br><span class="line">    pod &quot;ComponentB&quot;,           :path&#x3D;&gt;&quot;..&#x2F;ComponentB&quot;</span><br><span class="line">    common_pods</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>通过以上方法，就可以用如下方式进行宏判断，区分当前环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifdef APP_CLIPS</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h3 id="测试工作"><a href="#测试工作" class="headerlink" title="测试工作"></a>测试工作</h3><h4 id="开发调试"><a href="#开发调试" class="headerlink" title="开发调试"></a>开发调试</h4><ul>
<li><p>可以选择Clip Target直接使用Xcode编译运行</p>
</li>
<li><p>可以使用真机扫描二维码，调起Clip卡片，但是前提是Clip要先在真机跑一遍。</p>
<ol>
<li>手机点击<code>设置-开发者-Local Experiences-Register Local Experience</code></li>
<li>输入域名、Clip的bundle id、标题、子标题，选择按钮标题、选择Clip弹出的卡片上的图片，然后点击存储即可。</li>
<li>将刚才输入的域名，去草料二维码等二维码生成网站生成一个二维码，然后手机相机扫描即可弹出卡片样式。</li>
<li>具体内容可以参考<a href="https://developer.apple.com/documentation/app_clips/testing_your_app_clip_s_launch_experience?language=objc">官方文档</a></li>
</ol>
</li>
</ul>
<h4 id="外部测试"><a href="#外部测试" class="headerlink" title="外部测试"></a>外部测试</h4><ol>
<li>可以通过Archive打Release环境的包（Debug状态下没有选择导出Clip ipa的选项，不知道是哪里配置问题，如果有知道的小伙伴可以评论区分享一下），然后单独导出Clip的ipa，上传到蒲公英或者Fir等分发平台，测试同事就可以下载安装测试了。</li>
<li>如果已经传到了TestFlight，那么也可以在TestFlight上直接点击打开小程序进行测试。</li>
</ol>
<h3 id="苹果官方提及的产品要求"><a href="#苹果官方提及的产品要求" class="headerlink" title="苹果官方提及的产品要求"></a>苹果官方提及的产品要求</h3><p>原文：<a href="https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/">https://developer.apple.com/design/human-interface-guidelines/app-clips/overview/</a></p>
<p>划重点：</p>
<ol>
<li><p>请勿仅将App Clip用作营销用途，不能显示广告。</p>
</li>
<li><p>避免登录，避免不了的话尽可能使用Apple id登录</p>
</li>
<li><p>Clips启动后只有在8小时内才能接收推送</p>
</li>
</ol>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol>
<li><p>苹果文档说的App Clips 10M限制指的是哪个文件的10M</p>
<p> 经过测试后发现，应该是Release环境下Archive后，导出的Clips的ipa的大小，如果有误欢迎评论区指正。</p>
</li>
<li><p>Clips可以有登录功能吗？</p>
<p> 可以，但是苹果希望用户能不登录就使用App，如果要登录也首选Sign in with Apple登录的方式(iOS13特性)，但是我们可以学网易严选那样子苹果ID登录之后再弹出手机验证码绑定功能。</p>
</li>
<li><p>可以有内购吗？</p>
<p> 可以。</p>
</li>
<li><p>用户使用完Clips后，如果想再次进入，入口在哪儿？</p>
<p> 假如是网页打开的Clips，那么离开网页后，在桌面的”资源库”里可以找到这个Clips并重新打开。如果找不到就搜索资源库，总能搜到的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>feature</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS12 新玩具ShortCut(捷径)使用</title>
    <url>/post/0.html</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>升级iOS12之后可以在<code>设置-Siri</code>与搜索 中发现一个 <code>捷径</code> 功能, 所谓ShortCut就是其英文翻译<br>其作用就是让用户自定义一个一句话或者短语, 然后可以触发app做一系列动作</p>
<span id="more"></span>

<h3 id="接入"><a href="#接入" class="headerlink" title="接入"></a>接入</h3><p>ShortCut分为两种, 一种是在手机的<code>Spotlight</code>上搜索某个关键字的时候可以搜索到你的app, 这个关键字就是ShortCut的一种(文字输入), 你需要使用<code>NSUserActivity</code>去实现这个功能</p>
<blockquote>
<p>依赖 <code>CoreSpotlight</code> <code>CoreServices</code></p>
</blockquote>
<p>另外一种叫做 <code>Intent</code>(语音输入), 需要添加一个IntentExtension和IntentExtensionUI, 然后在主Target添加一个intentdefinition文件, 详细的配置大家可以参考<br><a href="https://juejin.im/post/5b2077d8f265da6e45549c68">文章1</a><br><a href="http://www.cnblogs.com/czjie2010/p/czjie.html">文章2</a></p>
<blockquote>
<p>依赖<code>Intents</code> <code>IntentsUI</code></p>
</blockquote>
<h3 id="最简单的配置操作步骤"><a href="#最简单的配置操作步骤" class="headerlink" title="最简单的配置操作步骤"></a>最简单的配置操作步骤</h3><ol>
<li><p>项目的<code>Capabilities</code>打开<code>Siri</code></p>
</li>
<li><p>授权</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (@available(iOS 10.0, *)) &#123;</span><br><span class="line">	[INPreferences requestSiriAuthorization:^(INSiriAuthorizationStatus status) &#123;</span><br><span class="line">		switch (status) &#123;</span><br><span class="line">			case INSiriAuthorizationStatusNotDetermined:</span><br><span class="line">				NSLog(@&quot;用户尚未对该应用程序作出选择。&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case INSiriAuthorizationStatusRestricted:</span><br><span class="line">				NSLog(@&quot;此应用程序无权使用Siri服务&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case INSiriAuthorizationStatusDenied:</span><br><span class="line">				NSLog(@&quot;用户已明确拒绝此应用程序的授权&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case INSiriAuthorizationStatusAuthorized:</span><br><span class="line">				NSLog(@&quot;用户可以使用此应用程序的授权&quot;);</span><br><span class="line">				break;</span><br><span class="line">			default:</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>新建一个<code>intentdefinition</code>，比如<code>A.intentdefinition</code></li>
<li>新建一个<code>Target</code>,<code>Intent Extension</code>有需要的话把<code>Intent UI Extension</code>也加上，<code>General</code>中配置相关证书</li>
<li>进入<code>A.intentdefinition</code>，界面左下角<code>+</code>号点一下，点击<code>new intent</code></li>
<li>界面右边<code>Target Membership</code>，把<code>步骤2</code>中新增的<code>Target</code>给勾上</li>
<li> 界面中间<code>Title</code>填写需要展示的标题，<code>Descripion</code> 写描述</li>
<li>Build一下，系统自动生成头文件，头文件名字在界面右测的导航页的第三个按钮的<code>Custom Class</code>里</li>
<li>找个控制器，导入<code>步骤8</code>生成的头文件，添加个按钮，比如</li>
</ul>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.navigationItem.rightBarButtonItem &#x3D; [[UIBarButtonItem alloc] initWithTitle:@&quot;捷径&quot; style:UIBarButtonItemStylePlain target:self action:@selector(siri:)];</span><br></pre></td></tr></table></figure></li>
<li><p>点击按钮召唤添加Shortcut的控制器</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)siri:(UIBarButtonItem *)item &#123;</span><br><span class="line">    if (@available(iOS 12.0, *)) &#123;</span><br><span class="line">    	 &#x2F;&#x2F; 这个类名具体看你生成了叫什么名字的头文件</span><br><span class="line">        ZeRiIntent *intent &#x3D; [[ZeRiIntent alloc] init];</span><br><span class="line">        intent.suggestedInvocationPhrase &#x3D; @&quot;打开xxx&quot;; &#x2F;&#x2F; 引导用户说的语句</span><br><span class="line">        INShortcut *shortCur &#x3D; [[INShortcut alloc] initWithIntent:intent];</span><br><span class="line">        INUIAddVoiceShortcutViewController *vc &#x3D; [[INUIAddVoiceShortcutViewController alloc] initWithShortcut:shortCur];</span><br><span class="line">        vc.delegate &#x3D; self;</span><br><span class="line">        [self presentViewController:vc animated:YES completion:nil];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Fallback on earlier versions</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>同个地方实现代理方法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma mark - INUIAddVoiceShortcutViewControllerDelegate</span><br><span class="line">- (void)addVoiceShortcutViewControllerDidCancel:(INUIAddVoiceShortcutViewController *)controller  API_AVAILABLE(ios(12.0))&#123;</span><br><span class="line">	[controller dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">- (void)addVoiceShortcutViewController:(INUIAddVoiceShortcutViewController *)controller didFinishWithVoiceShortcut:(INVoiceShortcut *)voiceShortcut error:(NSError *)error  API_AVAILABLE(ios(12.0))&#123;</span><br><span class="line">	[controller dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进入<code>Intent</code> target中的<code>IntentHandler</code>类，导入<code>步骤8</code>生成的头文件，要是头文件找不到，在这个target的<code>info.plist</code>中<code>NSExtension</code>下的<code>IntentsSupported</code>下添加一个名为那个头文件的值，主target的<code>info.plist</code>的<code>NSUserActivityTypes</code>下也加一个一样的</p>
</li>
<li><p><code>IntentHandler.m</code>遵循协议<code>XXXIntentHandling</code>（具体协议名看你的类名），实现两个方法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F; 用户说了那句话之后要Siri做什么事情</span><br><span class="line">- (void)handleZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion &#123;</span><br><span class="line">	completion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);</span><br><span class="line">&#125;</span><br><span class="line">  &#x2F;&#x2F; 用户确认了之后要Siri做什么事情</span><br><span class="line">- (void)confirmZeRiIntent:(ZeRiIntent *)intent completion:(void (^)(ZeRiIntentResponse * _Nonnull))completion &#123;</span><br><span class="line">	completion([[ZeRiIntentResponse alloc] initWithCode:ZeRiIntentResponseCodeContinueInApp userActivity:nil]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   <code>ZeRiIntentResponseCodeContinueInApp</code>只是枚举中其中一个值，使用不同的值会有不同     效果，自己探索一下，这里的值指的是打开app(具体方法名看协议)</p>
</li>
<li><p>进入<code>AppDelegate</code>，实现方法如下，根据<code>Intent</code>类名判断用户想要的操作</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	- (BOOL)application:(UIApplication *)application continueUserActivity:(nonnull NSUserActivity *)userActivity restorationHandler:(nonnull void (^)(NSArray&lt;id&lt;UIUserActivityRestoring&gt;&gt; * _Nullable))restorationHandler &#123;</span><br><span class="line">	if ([userActivity.activityType isEqualToString:@&quot;XXXIntent&quot;]) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>结束</p>
</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS动态加载字体</title>
    <url>/post/f82939c6.html</url>
    <content><![CDATA[<p>当你某个在开发某个SDK时需要使用到特殊字体，因为无法修改应用的info.plist，所以这时候我们需要采用动态注册字体的方式加载字体，方法如下</p>
<span id="more"></span>

<ul>
<li><p>OC</p>
<p>  方法调用</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[UIFont fontWithName:&lt;#(nonnull NSString *)#&gt; size:&lt;#(CGFloat)#&gt;]</span><br></pre></td></tr></table></figure>

<p>  如果上述方法返回nil,则你需要注册你的字体</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   NSBundle *bundle &#x3D; [NSBundle bundleForClass:[self class]];</span><br><span class="line">NSURL *fontURL &#x3D; [bundle URLForResource:&lt;#fontName#&gt; withExtension:@&quot;otf&quot;&#x2F;*or TTF*&#x2F;];</span><br><span class="line">NSData *inData &#x3D; [NSData dataWithContentsOfURL:fontURL];</span><br><span class="line">CFErrorRef error;</span><br><span class="line">CGDataProviderRef provider &#x3D; CGDataProviderCreateWithCFData((CFDataRef)inData);</span><br><span class="line">CGFontRef font &#x3D; CGFontCreateWithDataProvider(provider);</span><br><span class="line">if (!CTFontManagerRegisterGraphicsFont(font, &amp;error)) &#123;</span><br><span class="line">	CFStringRef errorDescription &#x3D; CFErrorCopyDescription(error);</span><br><span class="line">	NSLog(@&quot;Failed to load font: %@&quot;, errorDescription);</span><br><span class="line">	CFRelease(errorDescription);</span><br><span class="line">&#125;</span><br><span class="line">CFSafeRelease(font);</span><br><span class="line">CFSafeRelease(provider);</span><br></pre></td></tr></table></figure>

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CFSafeRelease(CFTypeRef cf) &#123;</span><br><span class="line">	if (cf !&#x3D; NULL) &#123;</span><br><span class="line">		CFRelease(cf);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Swift</p>
<p>  方法调用</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIFont.customFont(name:&quot;xxx&quot; size: 12)</span><br></pre></td></tr></table></figure>

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension UIFont &#123;</span><br><span class="line">	    static func customFont(fontName:String, size: CGFloat) -&gt; UIFont &#123;</span><br><span class="line">        if let font &#x3D; UIFont(name: fontName, size: size) &#123;</span><br><span class="line">            return font</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            _ &#x3D; self.registerFont(bundle: Bundle.init(for: XXXX.self), fontName: fontName, fontExtension: &quot;otf&quot;) &#x2F;&#x2F; 也可以写ttf,看具体格式</span><br><span class="line">            if let newFont &#x3D; UIFont(name: fontName, size: size) &#123;</span><br><span class="line">                return newFont</span><br><span class="line">            &#125;</span><br><span class="line">            return UIFont.customFont(ofSize: size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static func registerFont(bundle: Bundle, fontName: String, fontExtension: String) -&gt; Bool &#123;</span><br><span class="line">        guard let fontURL &#x3D; bundle.url(forResource: fontName, withExtension: fontExtension) else &#123;</span><br><span class="line">            fatalError(&quot;Couldn&#39;t find font \(fontName)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        guard let fontDataProvider &#x3D; CGDataProvider(url: fontURL as CFURL) else &#123;</span><br><span class="line">            fatalError(&quot;Couldn&#39;t load data from the font \(fontName)&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        guard let font &#x3D; CGFont(fontDataProvider) else &#123;</span><br><span class="line">            fatalError(&quot;Couldn&#39;t create font from data&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        var error: Unmanaged&lt;CFError&gt;?</span><br><span class="line">        let success &#x3D; CTFontManagerRegisterGraphicsFont(font, &amp;error)</span><br><span class="line">        guard success else &#123;</span><br><span class="line">            print(&quot;Error registering font: maybe it was already registered.&quot;)</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>参考资料：<br>    <a href="https://stackoverflow.com/questions/12919513/how-do-i-add-a-custom-font-to-a-cocoapod">https://stackoverflow.com/questions/12919513/how-do-i-add-a-custom-font-to-a-cocoapod</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 14新API</title>
    <url>/post/36f1cd4f.html</url>
    <content><![CDATA[<p>iOS 14 新API</p>
<span id="more"></span>

<h3 id="Control-Appearance-update"><a href="#Control-Appearance-update" class="headerlink" title="Control Appearance update"></a>Control Appearance update</h3><p>控件外观更新，比如UISlider、 UIProgressView、UIActivityIndicatorView，长得稍微有点不一样，不影响适配。</p>
<p><img src="https://s1.ax1x.com/2020/06/29/NfJ6zt.png"></p>
<p>UIPageControl样式改变并且可以自定义icon</p>
<p><img src="https://s1.ax1x.com/2020/06/29/NfYs7F.png"></p>
<p>自定义小心心icon和书签icon</p>
<p><img src="https://s1.ax1x.com/2020/06/29/NfYO1I.png"></p>
<h3 id="Color-Picker"><a href="#Color-Picker" class="headerlink" title="Color Picker"></a>Color Picker</h3><p>新增颜色选择器<code>UIColorPickerViewController</code></p>
<p>支持取色器 收藏常用颜色等等</p>
<p>可以配置是否支持调整透明度等等，具体配置项目参考api文档</p>
<p>建议Present弹出</p>
<p><a href="https://sm.ms/image/iz1WnGFImlUvkty" target="_blank"><img src="https://i.loli.net/2020/06/29/iz1WnGFImlUvkty.png" width=50% ></a></p>
<h3 id="Date-Picker"><a href="#Date-Picker" class="headerlink" title="Date Picker"></a>Date Picker</h3><p>UIDatePicker更新UI</p>
<p>两种样式</p>
<p>支持农历</p>
<p><a href="https://sm.ms/image/wMmTIykghRNqWQn" target="_blank"><img src="https://i.loli.net/2020/06/29/wMmTIykghRNqWQn.png" width=50% ></a></p>
<p><a href="https://sm.ms/image/uF3WonxPAsDyXaO" target="_blank"><img src="https://i.loli.net/2020/06/29/uF3WonxPAsDyXaO.png" width=50% ></a></p>
<h3 id="Menus"><a href="#Menus" class="headerlink" title="Menus"></a>Menus</h3><p>貌似可以替代我们常有的角标弹窗列表按钮需求</p>
<p>基于<code>UIButton</code>和<code>UIBarButtonItem</code>的新增的<code>menu</code>属性，可以配置长按或者单击(配置 <code>button.showsMenuAsPrimaryAction = true</code>)弹出菜单列表</p>
<p><a href="https://sm.ms/image/L1XmoD2d7EKj49Y" target="_blank"><img src="https://i.loli.net/2020/06/29/L1XmoD2d7EKj49Y.png" width=50% ></a></p>
<p><a href="https://sm.ms/image/ZflMaksQFDuKp3T" target="_blank"><img src="https://i.loli.net/2020/06/29/ZflMaksQFDuKp3T.png" width=50% ></a></p>
<p>UINavigationBar 的原生返回按钮长按会弹出菜单，可以跳回导航栏栈中的任意一个页面，按钮标题为前面控制器的标题</p>
<p><a href="https://sm.ms/image/FVdgXvpGeTBfYKZ" target="_blank"><img src="https://i.loli.net/2020/06/29/FVdgXvpGeTBfYKZ.png" width=50% ></a></p>
<p>更新弹出菜单内容，将会实时更新并自带系统动画：</p>
<p><code>updateVisibleMenu(_ block: (UIMenu) -&gt; UIMenu)</code></p>
<h3 id="UIActions"><a href="#UIActions" class="headerlink" title="UIActions"></a>UIActions</h3><p>UIBarButtonItem 新增 fixedSpace(width:) 和 flexibleSpace方法 去调节item之间的间隔，不用像之前那样子创建一个fixedSpace类型的UIBarButtonItem去占位</p>
<p>UIButton新增了一个初始化方法init(type:primaryAction:) type默认为.system 标题为primaryAction.title ，图片为 primaryAction.image</p>
<h3 id="WidgetKit"><a href="#WidgetKit" class="headerlink" title="WidgetKit"></a>WidgetKit</h3><p>iOS14 重大新特性之一 支持三种宽度的widget，具体内容另外开篇再讲<br><a href="https://sm.ms/image/eiXyvjhfgAqQURr" target="_blank"><img src="https://i.loli.net/2020/06/29/eiXyvjhfgAqQURr.png" width=50% ></a></p>
<h3 id="让你的app支持物理键盘"><a href="#让你的app支持物理键盘" class="headerlink" title="让你的app支持物理键盘"></a>让你的app支持物理键盘</h3><p><a href="https://developer.apple.com/documentation/uikit/keyboards_and_input/adding_hardware_keyboard_support_to_your_app">具体内容查看文档</a></p>
<h3 id="Asynchronously-Loading-Images-into-Table-and-Collection-Views"><a href="#Asynchronously-Loading-Images-into-Table-and-Collection-Views" class="headerlink" title="Asynchronously Loading Images into Table and Collection Views"></a>Asynchronously Loading Images into Table and Collection Views</h3><p><a href="https://developer.apple.com/documentation/uikit/uiimage/asynchronously_loading_images_into_table_and_collection_views">文档</a></p>
<p>tableView和CollectionView异步加载网络图片的API</p>
<h3 id="PHPicker-图片选择器"><a href="#PHPicker-图片选择器" class="headerlink" title="PHPicker 图片选择器"></a>PHPicker 图片选择器</h3><p>新的图片选择器，支持多选，不需要用户允许相册访问权限，可以选择图片（包括livePhoto）和视频</p>
<p><a href="https://sm.ms/image/R9fc3SZIlpLhuwB" target="_blank"><img src="https://i.loli.net/2020/06/29/R9fc3SZIlpLhuwB.png" width=50% ></a></p>
<h3 id="定位权限更新"><a href="#定位权限更新" class="headerlink" title="定位权限更新"></a>定位权限更新</h3><p>旧的定位权限弹窗如下：</p>
<p><a href="https://sm.ms/image/kSgBdY3hjRWG21E" target="_blank"><img src="https://i.loli.net/2020/06/29/kSgBdY3hjRWG21E.png" width=50% ></a></p>
<p>新的定位权限弹窗如下：</p>
<p><a href="https://sm.ms/image/svo9OnAS1BZdLDP" target="_blank"><img src="https://i.loli.net/2020/06/29/svo9OnAS1BZdLDP.png" width=50% ></a></p>
<p>多了个小地图，并且小地图的左上角多了个按钮，点击选择是否允许准确定位。</p>
<p>若不允许的话，开发者获取的定位会变成一个±5公里的范围，并且只能持续定位最多20分钟</p>
<p>通过一个枚举值得知是否用户选择了模糊定位：</p>
<p><a href="https://sm.ms/image/9gh6mbKL7VWe3uH" target="_blank"><img src="https://i.loli.net/2020/06/29/9gh6mbKL7VWe3uH.png" ></a></p>
<p>用户可以改变设置，是否允许app获取准确定位</p>
<p><a href="https://sm.ms/image/jsQr4xoevXNa2Ju" target="_blank"><img src="https://i.loli.net/2020/06/29/jsQr4xoevXNa2Ju.png" ></a></p>
<p>开发者可以通过在<code>info.plist</code>里面配置信息解释为何需要用户选择准确定位</p>
<p><a href="https://sm.ms/image/X5CRUopcnOHG3I2" target="_blank"><img src="https://i.loli.net/2020/06/29/X5CRUopcnOHG3I2.png" ></a></p>
<p>让隐私弹窗默认选择模糊定位</p>
<p><a href="https://sm.ms/image/UeLtJhGXOvbKmns" target="_blank"><img src="https://i.loli.net/2020/06/29/UeLtJhGXOvbKmns.png" width=50%></a></p>
<h3 id="UICollectionView重大更新"><a href="#UICollectionView重大更新" class="headerlink" title="UICollectionView重大更新"></a>UICollectionView重大更新</h3><p>UICollection从数据源协议到Cell都有了新的API，开发者可以为cell添加各种“附件”，已适配复杂的列表样式，如下第二张图，另外可以在collectionView上使用类似tableView的样式，如下图</p>
<p><a href="https://sm.ms/image/Iaho8TuHE1P4iRx" target="_blank"><img src="https://i.loli.net/2020/06/30/Iaho8TuHE1P4iRx.png" ></a></p>
<p><a href="https://sm.ms/image/taEDOVHfAk2LnQe" target="_blank"><img src="https://i.loli.net/2020/06/30/taEDOVHfAk2LnQe.png"  width=50% ></a></p>
<p>通过新的配置类，可以做成如下效果</p>
<p><a href="https://sm.ms/image/nlrR8VBkzqy2SdP" target="_blank"><img src="https://i.loli.net/2020/06/30/nlrR8VBkzqy2SdP.png"  width=50% ></a></p>
<p><a href="https://sm.ms/image/PhtUgJrCR2OTQwY" target="_blank"><img src="https://i.loli.net/2020/06/30/PhtUgJrCR2OTQwY.png"  width=50% ></a></p>
<p>新增一个UICollectionListViewCell，可以做出如下样式的cell</p>
<p><a href="https://sm.ms/image/jlZKFpCybNJPoET" target="_blank"><img src="https://i.loli.net/2020/06/30/jlZKFpCybNJPoET.png" width=50%  ></a></p>
<p>Cell的注册方式也有所改变，可以看出苹果从API层面已经进入MVVM架构模式了，注册cell需要带上对应的CellViewModel</p>
<p><a href="https://sm.ms/image/2awdL6yOmUzIGrZ" target="_blank"><img src="https://i.loli.net/2020/06/30/2awdL6yOmUzIGrZ.jpg" width=50% ></a></p>
<p>另外也支持像UITableViewCell的侧滑操作等等，详细内容将会另外开篇讲述。</p>
<p>具体查看<a href="https://developer.apple.com/videos/play/wwdc2020/10097/">视频</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>feature</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS从服务器下载DAE文件并动态加载到SCNScene</title>
    <url>/post/8c9c88ab.html</url>
    <content><![CDATA[<p>ViewController 已有 SCNScene,怎么从服务器下载3D模型文件(DAE)然后加载到这个 SCNScene呢？</p>
<span id="more"></span>

<ol>
<li><p>由于 <code>SCNScene</code> 不支持动态加载 DAE 文件，或者说不支持动态加载 <code>COLLADA</code> 方案下的所有3d 类型，但是测试发现直接把 DAE 文件放进 <code>arc.scnassets</code> 文件夹下的时候是可以加载的，可见系统编译的时候应该是做了某些手脚，查询资料后发现系统是执行了两个脚本，两个脚本的路径分别是<code>/Applications/Xcode.app/Contents/Developer/usr/bin/copySceneKitAssets</code>和<br><code>/Applications/Xcode.app/Contents/Developer/usr/bin/scntool</code> 所以先把这两个文件拷出来</p>
</li>
<li><p>新建一个文件夹，命名是 自定义名字.scnassets,例如abc.scnassets</p>
</li>
<li><p>把模型文件放在里面,然后在这个文件夹外面放上copySceneKitAssets和scntool</p>
</li>
<li><p>终端执行./copySceneKitAssets abc.scnassets -o abc-o.scnassets 如果没问题的话就会生成一个 abc-o.scnassets 文件夹</p>
</li>
<li><p>打包 zip 上传服务器</p>
</li>
<li><p>代码下载 zip包,解压,然后载入文件</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">documentsDirectoryURL &#x3D; [documentsDirectoryURL URLByAppendingPathComponent:@&quot;abc-o.scnassets&#x2F;test.dae&quot;];</span><br><span class="line">SCNSceneSource *sceneSource &#x3D; [SCNSceneSource sceneSourceWithURL:documentsDirectoryURL options:nil];</span><br><span class="line">SCNNode *theCube &#x3D; [sceneSource entryWithIdentifier:@&quot;Cube&quot; withClass:[SCNNode class]];</span><br></pre></td></tr></table></figure>
<p>或者使用SCNScene这个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (nullable instancetype)sceneWithURL:(NSURL *)url options:(nullable NSDictionary&lt;SCNSceneSourceLoadingOption, id&gt; *)options error:(NSError **)error;</span><br></pre></td></tr></table></figure>
<p>也是可以的</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Scene Kit</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS基于Navigation-Base-on-ViewModel的路由搭建——HOOK方式实现</title>
    <url>/post/b111382b.html</url>
    <content><![CDATA[<p>本文主要讲述的是在 iOS 中使用 MVVM 架构开发的情况下，将 ViewModel 作为行为驱动主体，通过 Hook 的方式，设计一个 App 的路由层</p>
<span id="more"></span>

<ul>
<li><p>什么是路由</p>
<ul>
<li>路由在服务端指的是url请求的分层解析，将一个请求分发到对应的应用处理程序。<br>在移动端指的是将 App 内页面访问、H5与App之间和访问请求和 App之间的访问请求 进行分发的逻辑层。</li>
</ul>
</li>
<li><p>在移动端中路由需要做什么事情</p>
<ul>
<li>针对网络上的各种说法，这里做一下简要说明：<ul>
<li>提供接口供外部访问，这里的”外部”指的可能是App内的一个ViewController，也有可能是其他应用（包括系统应用），也有可能是 H5页面。<br>分发资源。路由不需要依赖外部的资源的定义，就可以将资源传递给目的地。（‘资源’在这里指的是原生页面、模块、组件等等）</li>
<li>统一的标识符（或者统一格式的标识符）去标识资源，并且可以通过这些标示符去统一访问请求的过程。</li>
<li>解决安全访问的问题，如果是外部的H5、App去访问你的 App,那么就得特别注意这个问题。（本文暂不提及这个问题）</li>
</ul>
</li>
</ul>
</li>
<li><p>在移动端中路由的使用场景</p>
<ul>
<li>原生界面之间，模块之间与组件之间的交互（例如页面的跳转之类）</li>
<li>H5页面与原生界面之间的交互</li>
<li>解除业务依赖</li>
<li>组件化开发</li>
</ul>
</li>
<li><p>iOS自带的系统访问方式、统一的连接协议</p>
<ul>
<li>苹果开发了<a href="https://developer.apple.com/library/content/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899">URLScheme</a>这种东西，使得 App 能够在沙盒机制的前提下互相调用，定义URL-Scheme的方式如下<blockquote>
<ul>
<li>协议部分来标示App应用</li>
<li>主机Host部分用于标示业务线或者是应用提供的划分好的服务实体，比方说index、discover是业务条线，api-asycn是对外提供的api，pushService是App内部的推送服务等。</li>
<li>路径部分则可以是细分的页面、组件或者服务的标示</li>
<li>参数定义有一些是必要的，比如说action来标示动作，比方说可以使用get标示获取、insert增加，userToken表示安全的用户令牌，source表示来源，当然像是userToken与source这些都是路由层需要进行解析和验证的，而action则是业务相关的参数，这一点在路由曾设计的时候需要进行详细区分</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>讲完了路由的概念，接下来谈谈 路由设计</p>
<ul>
<li>我们先抽取最常见的页面跳转来讲，因为我们使用的是 MVVM,那么从理论上来讲，我们就应该让App以 ViewModel为驱动进行运作，而不是用 ViewController,之前说 ViewController 在跳转的时候只需要关心跳转过去的界面是否是一个 UIViewController 的子类，而不需要关心这个 viewController的具体细节,所以考虑用 ViewModel把 目的 ViewController 传递到当前 ViewController，但是ViewModel 严格来讲不能引入任何 UIKit 的任何内容，不然ViewModel级就会失去其可测试性，所以我们通过引入服务总线的概念，维护一个NavigationController 的堆栈（这个思想来自于雷纯锋的博客中的一篇文章<a href="http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/">MVVM With ReactiveCocoa</a>）具体实现如下</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;这个是协议声明部分</span><br><span class="line">@protocol MRCNavigationProtocol &lt;NSObject&gt;</span><br><span class="line">- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated;</span><br><span class="line">- (void)popViewModelAnimated:(BOOL)animated;</span><br><span class="line">- (void)popToRootViewModelAnimated:(BOOL)animated;</span><br><span class="line">- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion;</span><br><span class="line">- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion;</span><br><span class="line">- (void)resetRootViewModel:(MRCViewModel *)viewModel;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>以下是方法的实现部分，没有写任何方法的实现过程，只是进行了空操作，目的是使用 Hook 思想去捕获操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)pushViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated &#123;&#125;</span><br><span class="line">- (void)popViewModelAnimated:(BOOL)animated &#123;&#125;</span><br><span class="line">- (void)popToRootViewModelAnimated:(BOOL)animated &#123;&#125;</span><br><span class="line">- (void)presentViewModel:(MRCViewModel *)viewModel animated:(BOOL)animated completion:(VoidBlock)completion &#123;&#125;</span><br><span class="line">- (void)dismissViewModelAnimated:(BOOL)animated completion:(VoidBlock)completion &#123;&#125;</span><br><span class="line">- (void)resetRootViewModel:(MRCViewModel *)viewModel &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>栈顶的 NavigationController 进行 Hook 并执行真正的跳转操作(使用到了 ReactiveCocoa， 因为要捕获的方法太多，这里只列举两条)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)registerNavigationHooks &#123;</span><br><span class="line">  	 @weakify(self)</span><br><span class="line">    [[(NSObject *)self.services</span><br><span class="line">        rac_signalForSelector:@selector(pushViewModel:animated:)]</span><br><span class="line">        subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class="line">            @strongify(self)</span><br><span class="line">            UIViewController *viewController &#x3D; (UIViewController *)[MRCRouter.sharedInstance viewControllerForViewModel:tuple.first];</span><br><span class="line">            [self.navigationControllers.lastObject pushViewController:viewController animated:[tuple.second boolValue]];</span><br><span class="line">        &#125;];</span><br><span class="line">    [[(NSObject *)self.services</span><br><span class="line">        rac_signalForSelector:@selector(popViewModelAnimated:)]</span><br><span class="line">        subscribeNext:^(RACTuple *tuple) &#123;</span><br><span class="line">          @strongify(self)</span><br><span class="line">            [self.navigationControllers.lastObject popViewControllerAnimated:[tuple.first boolValue]];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际在 ViewController 里面调用起来就会是这种感觉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    [tableView deselectRowAtIndexPath:indexPath animated:YES];</span><br><span class="line">    if (indexPath.section &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        MRCTrendingViewModel *trendingViewModel &#x3D; [[MRCTrendingViewModel alloc] initWithServices:self.viewModel.services params:nil];</span><br><span class="line">        [self.viewModel.services pushViewModel:trendingViewModel animated:YES];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看下将ViewModel与 ViewController 关联起来的 路由内的映射(截取部分)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSDictionary *)viewModelViewMappings &#123;</span><br><span class="line">   return @&#123;</span><br><span class="line">   	   @&quot;MRCLoginViewModel&quot;: @&quot;MRCLoginViewController&quot;,</span><br><span class="line">      @&quot;MRCHomepageViewModel&quot;: @&quot;MRCHomepageViewController&quot;,</span><br><span class="line">      @&quot;MRCRepoDetailViewModel&quot;: @&quot;MRCRepoDetailViewController&quot;,</span><br><span class="line">      @&quot;MRCWebViewModel&quot;: @&quot;MRCWebViewController&quot;,</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这上面的只是路由的实现方案1，纯粹地将 ViewController 与 ViewModel 关联起来，方案2是 建立一个路由层通过URL 的方式进行路由交互参考<a href="http://www.jianshu.com/p/3a902f274a3d">一步步构建iOS路由</a>这部分我后面会讲讲我的思考。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>ipad和iphone使用UIAlertViewController</title>
    <url>/post/f0080c3e.html</url>
    <content><![CDATA[<p>ipad和iphone使用UIAlertViewController</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id aController;</span><br><span class="line">    if(DKDeviceiPad)&#123;</span><br><span class="line">    alertC.modalPresentationStyle &#x3D; UIModalPresentationPopover;</span><br><span class="line">    UIPopoverPresentationController *popPc &#x3D; alertC.popoverPresentationController;</span><br><span class="line">    popPc.barButtonItem &#x3D; self.downloadItem;</span><br><span class="line">    popPc.permittedArrowDirections &#x3D; UIPopoverArrowDirectionAny;</span><br><span class="line">    aController &#x3D; alertC;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    aController &#x3D; alertC;</span><br><span class="line">&#125;</span><br><span class="line">[window.rootViewController presentViewController:aController animated:YES completion:nil];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 底层原理 --- 方法、消息发送与super关键字</title>
    <url>/post/5ed61a9.html</url>
    <content><![CDATA[<p>本文主要简述类（元类）对象里面的方法缓存、消息发送（包括消息发送，动态方法解析与消息转发）与super关键字的底层原理</p>
<span id="more"></span>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Class对象的结构"><a href="#Class对象的结构" class="headerlink" title="Class对象的结构"></a>Class对象的结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache; &#x2F;&#x2F; 方法缓存</span><br><span class="line">    class_data_bits_t bits; &#x2F;&#x2F; 用于获取具体的类信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>bits</code>成员变量与<code>FAST_DATA_MASK</code>进行一次与运算之后，会获得一个其属性可读可写的对象的地址，这个对象长这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    const clsss_ro_t *ro;</span><br><span class="line">    method_array_t * methods; &#x2F;&#x2F; 方法列表</span><br><span class="line">    property_array_t *properties; &#x2F;&#x2F; 属性列表</span><br><span class="line">    protocol_array_t protocols; &#x2F;&#x2F; 协议列表</span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    char *demangledName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>class_ro_t</code>里面存放的是类的原始信息(不包括分类里面的东西)，是仅可读的，结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    unit32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize; &#x2F;&#x2F; instance对象占用的内存空间</span><br><span class="line">#ifdef __LP__64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">    const uint8_t *ivarLayout;</span><br><span class="line">    const char * name; &#x2F;&#x2F; 类名</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars; &#x2F;&#x2F; 成员变量列表</span><br><span class="line">    const uint8_t * weakIverLayout;</span><br><span class="line">    property_list_t * baseProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h3><p><code>class_rw_t</code>里面的methods、properties、protocols是二维数组，是可读可写的，比如方法列表随时可以新增<code>method_list_t</code>类型的数据进去。<code>class_rw_t</code>包含了类的初始内容和分类的内容，其中方法列表类似如下结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">method_array_t: [</span><br><span class="line">    method_list_t : [</span><br><span class="line">      method_t,</span><br><span class="line">      method_t,</span><br><span class="line">      method_t</span><br><span class="line">    ],</span><br><span class="line">    method_list_t : [</span><br><span class="line">      method_t,</span><br><span class="line">      method_t,</span><br><span class="line">      method_t</span><br><span class="line">    ],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>objc_class</code>内有一个<code>data()</code>函数，其返回值一开始是指向<code>class_ro_t</code>类型的对象的。在合并分类内的内容时，才会产生<code>class_rw_t</code>类型的对象，并指向这个对象。可以参考runtime源码，<code>objc-runtime-new.mm</code>中<code>realizeClassWithoutSwift</code>函数的实现，这里贴出关键部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static Class realizeClassWithoutSwift(Class cls, Class previously)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    auto ro &#x3D; (const class_ro_t *)cls-&gt;data();</span><br><span class="line">    auto isMeta &#x3D; ro-&gt;flags &amp; RO_META;</span><br><span class="line">    if (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        &#x2F;&#x2F; This was a future class. rw data is already allocated.</span><br><span class="line">        rw &#x3D; cls-&gt;data();</span><br><span class="line">        ro &#x3D; cls-&gt;data()-&gt;ro();</span><br><span class="line">        ASSERT(!isMeta);</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Normal class. Allocate writeable class data.</span><br><span class="line">        rw &#x3D; objc::zalloc&lt;class_rw_t&gt;();</span><br><span class="line">        rw-&gt;set_ro(ro);</span><br><span class="line">        rw-&gt;flags &#x3D; RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">        cls-&gt;setData(rw);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h3><p><code>class_ro_t</code>里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，所以不能新增内容，包含了类的初始内容，其中方法列表类似如下结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">method_list_t : [</span><br><span class="line">  method_t,</span><br><span class="line">  method_t,</span><br><span class="line">  method_t</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在runtime源码，<code>objc-runtime-new.mm</code>中的<code>attachCategories</code>方法中我们可以看到分类合并到<code>class_rw_t</code>对象的过程，比如方法的合并如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">method_list_t *mlist &#x3D; entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">if (mlist) &#123;</span><br><span class="line">    if (mcount &#x3D;&#x3D; 64) &#123;</span><br><span class="line">        prepareMethodLists(cls, mlists, mcount, NO, fromBundle, __func__);</span><br><span class="line">        rwe-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">        mcount &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    mlists[ATTACH_BUFSIZ - ++mcount] &#x3D; mlist;</span><br><span class="line">    fromBundle |&#x3D; entry.hi-&gt;isBundle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><ul>
<li><code>method_t</code>是对方法/函数的封装（下面是缩减版定义）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    ...</span><br><span class="line">    SEL name(); &#x2F;&#x2F; 函数名</span><br><span class="line">    const char *types(); &#x2F;&#x2F; 编码（返回值类型、参数类型）</span><br><span class="line">    IMP imp(bool needsLock); &#x2F;&#x2F; 指向函数的指针（函数地址）</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>IMP</code>代表具体函数的实现</p>
<p>  <code>typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</code></p>
</li>
<li><p><code>SEL</code>可以代表方法\函数名，一般叫做选择器，底层结构跟<code>char *</code>类似</p>
<p>  <code>typedef struct objc_selector *SEL</code>;</p>
<ul>
<li>可以通过<code>@selector()</code>和<code>sel_registerName()</code>获得</li>
<li>可以通过<code>sel_getName()</code>和<code>NSStringFromSelector()</code>转成字符串</li>
<li>不同类中相同名字的方法，所对应的方法选择器是相同的</li>
</ul>
</li>
<li><p><code>types</code>包含了函数返回值、参数编码的字符串，称作<code>Type Encodings</code>（类型编码），具体可以参考<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100">苹果官方文档</a></p>
<ul>
<li>比如<code>-（void）test:(int)a;</code>的方法编码为<code>v@:i</code>，v = void,@表示指针变量(因为编译后第一个参数是self)，：表示选择器(因为编译后第二个参数是_cmd)，</li>
<li>有时类型编码会带上数字，比如<code>v16@0:8</code>，第一个数字表示这个函数的参数一共占用16个字节，第二个数字开始往后的数字都代表偏移值，0代表第一个参数的字节偏移值为0，第三个数字8代表偏移8个字节，也就是第一个参数已经占用了8个字节了，所以第二个参数就从第8个字节开始</li>
</ul>
</li>
</ul>
<h3 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h3><ul>
<li>Class内部结构中有个方法缓存（cache_t），用散列表来缓存曾经调用过的方法，可以提高方法的查找速度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            explicit_atomic&lt;mask_t&gt;    _maybeMask; &#x2F;&#x2F; 散列表的长度 - 1</span><br><span class="line">            uint16_t                   _flags;</span><br><span class="line">            uint16_t                   _occupied; &#x2F;&#x2F; 已经缓存的方法数量</span><br><span class="line">        &#125;;</span><br><span class="line">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;</span><br><span class="line">    &#125;;   </span><br><span class="line">    struct bucket_t *buckets() const;</span><br><span class="line">    mask_t mask() const;</span><br><span class="line">    mask_t occupied() const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，通过<code>buckets()</code>函数我们可以得知<code>_bucketsAndMaybeMask</code>是一个存放<code>bucket_t</code>数组的指针（即<code>_bucketsAndMaybeMask</code>指针指向的是数组的第一个元素），是通过位运算取出来的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct bucket_t *cache_t::buckets() const</span><br><span class="line">&#123;</span><br><span class="line">    uintptr_t addr &#x3D; _bucketsAndMaybeMask.load(memory_order_relaxed);</span><br><span class="line">    return (bucket_t *)(addr &amp; bucketsMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>bucket_t</code>的结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct bucket_t &#123;</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _imp; 	&#x2F;&#x2F; 函数的内存地址</span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel; &#x2F;&#x2F; SEL作为key</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过IMP和SEL，我们就可以调用方法了，所以综上所述，一个实例对象调用方法，其类对象从方法缓存里面找方法的大概流程就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取sel : class - isa - 偏移16个字节 - cache_t - buckets() - [bucket_t] - 计算出下标index - bucket_t - sel()</span><br><span class="line">获取imp : class - isa - 偏移16个字节 - cache_t - buckets() - [bucket_t] - 计算出下标index - bucket_t - imp(nil,cls)</span><br></pre></td></tr></table></figure>

<p>另外<code>_bucketsAndMaybeMask</code>之所以叫这个名字是因为它不仅存放着<code>buckets</code>还存放着<code>maybeMask</code>，在arm64位真机环境下，取高16位，如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mask_t cache_t::mask() const</span><br><span class="line">&#123;</span><br><span class="line">    uintptr_t maskAndBuckets &#x3D; _bucketsAndMaybeMask.load(memory_order_relaxed);</span><br><span class="line">    &#x2F;&#x2F;maskShift 为48,</span><br><span class="line">    return maskAndBuckets &gt;&gt; maskShift;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法缓存的流程"><a href="#方法缓存的流程" class="headerlink" title="方法缓存的流程"></a>方法缓存的流程</h4><p>先看看runtime源码中，将方法插入缓存的函数（摘抄核心流程）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void cache_t::insert(SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;对_occupied赋值 + 1。首次 newOccupied &#x3D; 1。</span><br><span class="line">    mask_t newOccupied &#x3D; occupied() + 1;</span><br><span class="line">    &#x2F;&#x2F;旧容量，（mask + 1） 或者 0</span><br><span class="line">    unsigned oldCapacity &#x3D; capacity(), capacity &#x3D; oldCapacity;</span><br><span class="line">    &#x2F;&#x2F;是否为空，首次进入这里</span><br><span class="line">    if (slowpath(isConstantEmptyCache())) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is read-only. Replace it.</span><br><span class="line">        &#x2F;&#x2F;默认容量给4</span><br><span class="line">        if (!capacity) capacity &#x3D; INIT_CACHE_SIZE;&#x2F;&#x2F;1 &lt;&lt; 2 &#x3D; 4</span><br><span class="line">        &#x2F;&#x2F;0 4 false 开辟新的容器空间。由于旧容器为空这里不需要释放传false。</span><br><span class="line">        reallocate(oldCapacity, capacity, &#x2F;* freeOld *&#x2F;false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;newOccupied + 1 (相当于 _occupied + 2) &lt;&#x3D; capacity * 3 &#x2F; 4 容量够的时候什么都不做，直接插入。&lt;&#x3D;75%的容积正常插入，否则扩容。</span><br><span class="line">    &#x2F;&#x2F;## ⚠️在arm64位的情况下，CACHE_END_MARKER 0 扩容条件为：7 &#x2F; 8 87.5% 这个时候CACHE_ALLOW_FULL_UTILIZATION 为 1</span><br><span class="line">    else if (fastpath(newOccupied + CACHE_END_MARKER &lt;&#x3D; cache_fill_ratio(capacity))) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is less than 3&#x2F;4 or 7&#x2F;8 full. Use it as-is.</span><br><span class="line">    &#125;</span><br><span class="line">#if CACHE_ALLOW_FULL_UTILIZATION</span><br><span class="line">    &#x2F;&#x2F;capacity &lt;&#x3D; 1&lt;&lt;3 (8), _occupied + 1（CACHE_END_MARKER为0） &lt;&#x3D; 容量。少于8个元素的时候允许100%占满。</span><br><span class="line">    else if (capacity &lt;&#x3D; FULL_UTILIZATION_CACHE_SIZE &amp;&amp; newOccupied + CACHE_END_MARKER &lt;&#x3D; capacity) &#123;</span><br><span class="line">        &#x2F;&#x2F; Allow 100% cache utilization for small buckets. Use it as-is.</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;&#x2F;扩容</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F;容量不为空返回 2倍的容量，否则返回4</span><br><span class="line">        capacity &#x3D; capacity ? capacity * 2 : INIT_CACHE_SIZE;</span><br><span class="line">        &#x2F;&#x2F;MAX_CACHE_SIZE 1&lt;&lt;16 &#x3D; 2^16。最大缓存65536</span><br><span class="line">        if (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">            capacity &#x3D; MAX_CACHE_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;开辟新的容器控件，释放旧的空间。</span><br><span class="line">        reallocate(oldCapacity, capacity, true);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;从_bucketsAndMaybeMask获取buckets</span><br><span class="line">    bucket_t *b &#x3D; buckets();</span><br><span class="line">    mask_t m &#x3D; capacity - 1;&#x2F;&#x2F;首次是4-1</span><br><span class="line">    &#x2F;&#x2F;计算插入的index</span><br><span class="line">    mask_t begin &#x3D; cache_hash(sel, m);</span><br><span class="line">    mask_t i &#x3D; begin;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Scan for the first unused slot and insert there.</span><br><span class="line">    &#x2F;&#x2F; There is guaranteed to be an empty slot.</span><br><span class="line">    &#x2F;&#x2F;循环判断插入数据。</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F;能走到这里大概率是cache不存在，所以这里走fastpath</span><br><span class="line">        if (fastpath(b[i].sel() &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">            &#x2F;&#x2F;Occupied + 1</span><br><span class="line">            incrementOccupied();</span><br><span class="line">            &#x2F;&#x2F;buckets中插入bucket</span><br><span class="line">            b[i].set&lt;Atomic, Encoded&gt;(b, sel, imp, cls());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;已经存在了，不进行任何处理。有可能是其它线程插入的。</span><br><span class="line">        if (b[i].sel() &#x3D;&#x3D; sel) &#123;</span><br><span class="line">            &#x2F;&#x2F; The entry was added to the cache by some other thread</span><br><span class="line">            &#x2F;&#x2F; before we grabbed the cacheUpdateLock.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;cache_next为了防止hash冲突。再hash了一次（下文会讲到）。</span><br><span class="line">    &#125; while (fastpath((i &#x3D; cache_next(i, m)) !&#x3D; begin));</span><br><span class="line">    &#x2F;&#x2F;异常处理</span><br><span class="line">    bad_cache(receiver, (SEL)sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首次进入isConstantEmptyCache分支。会创建一个容量为4的空buckets。这个时候由于旧buckets不存在不需要释放所以参数传递false。</li>
<li>当容量大于等于3/4或7/8的情况下扩容。arm64的条件下为7 / 8。</li>
<li>arm64条件下容量小于等于8的时候会占用100%才扩容。</li>
<li>扩容是直接翻倍，默认值4。最大值MAX_CACHE_SIZE为216(65536)。在扩容的时候直接释放了旧值。</li>
<li>mask值为capacity - 1</li>
<li>通过cache_hash（下文会提及的散列表算法）计算插入的index，后面会通过cache_next再进行计算hash解决冲突问题。</li>
<li>循环判断通过b[i].set插入bucket数据。</li>
<li><strong>reallocate函数在开辟控件的同时，把缓存给直接清空了</strong>，清空之后再把现在要缓存的方法放进去，所以扩容后occupied会为1。</li>
</ul>
<h4 id="散列表（哈希表）缓存"><a href="#散列表（哈希表）缓存" class="headerlink" title="散列表（哈希表）缓存"></a>散列表（哈希表）缓存</h4><ul>
<li><p>方法缓存的容器，不是简单的数组，而是用散列表的方式进行存储。</p>
<p>假如现在散列表长度为10，那么mask（即cache_t里面的_maybeMask）就是10-1 = 9，当selector传进来的时候，会跟mask进行一次与运算，如下：</p>
<p><code>@selector(personTest) &amp; mask = 4</code></p>
<p>假如得到的结果是4的话，那么就会插在列表的下标为4的位置，其他位置因为已经开辟好空间了，所以有值就放值，没值就NULL</p>
<p>这种列表的好处是，当想取到特定的bucket_t的时候，只需要把selector跟mask进行一次与运算，就可以直接得到下标，然后直接从列表取出，这样子就不用遍历查找了，大大节约了性能。</p>
<p>另外，由于与运算的特性，跟mask进行与运算之后的值，都不可能比mask更大，这样子就保证不会插入越界的位置。</p>
</li>
<li><p>如果通过计算后的下标值，插入列表的时候发现已经有东西了那怎么办？</p>
<p>  这也就是所谓的Hash冲突。为了处理这种问题，系统会调用<code>cache_next</code>函数</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return i ? i-1 : mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  也就是说如果<code>@selector(personTest) &amp; mask = 4</code>的4已经有东西了，那么就取 4 - 1 = 3，如果3还有东西，就放在2的位置，如果2还有，就放在1，以此类推，如果直到0都还没有可以插入的位置，那么就从mask的位置开始找，也就是9，然后再找9看看是否可以插入，插不进去再找8，以此类推，找到为止。</p>
<p>  由于列表在存放数量达到容量的87.5%的时候就会两倍的扩容（arm64），扩容后又会清空缓存，所以一定能找到合适的位置插入的。</p>
</li>
</ul>
<h2 id="消息发送机制"><a href="#消息发送机制" class="headerlink" title="消息发送机制"></a>消息发送机制</h2><p>调用一个不存在的方法的时候，他会经历这么一个流程</p>
<p>消息发送 - （找不到方法的话） -&gt; 动态方法解析 - （没有实现的话） -&gt; 消息转发 -&gt; （没有实现的话） -&gt; 抛出异常</p>
<h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p>假如我们这么调用一个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[person personTest];</span><br></pre></td></tr></table></figure>

<p>底层会转换为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc_msgSend(person,sel_registerName(&quot;personTest&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的person我们称作消息接受者（receiver），就是调用方法的对象，如果这里还是调用类方法的话，那么这里就会传入一个类对象</li>
<li><code>sel_registerName()</code>函数等价于<code>@selector</code></li>
<li>为了性能，<code>objc_msgSend</code>方法底层是使用汇编和C++实现的</li>
</ul>
<p>消息发送的流程如下：</p>
<ol>
<li>receiver 是否为空，如果是退出，否则继续</li>
<li>从receiver的类对象（如果传入的是类则找的是元类对象，下文统称为receiverClass）的cache中查找方法，如果找到则调用方法，如果找不到则继续</li>
<li>从receiverClass中的<code>class_rw_t</code>中查找方法，如果找到则调用方法，并将方法插入缓存，如果找不到则继续</li>
<li>从<code>superClass</code>的cache中查找方法，有则调用并缓存到当前receiverClass的cache中(不是superClass的cache),否则继续</li>
<li>从<code>superClass</code>的<code>class_rw_t</code>中找，有则调用并缓存到receiverClass的cache中，否则继续</li>
<li>继续通过<code>superClass</code>的<code>superClass</code>找方法，流程回到4，直到再也没有父类了，并且也找不到方法，那么将会进入动态方法解析阶段。</li>
</ol>
<p>其中：</p>
<ul>
<li>如果是从<code>class_rw_t</code>中查找方法，若方法列表已经排序好，那么就使用二分查找法查找</li>
<li>如果是还没排序的方法，那么就使用遍历的方法查找</li>
<li>在缓存中查找方法的过程也称作快速查找（使用汇编实现），在<code>class_rw_t</code>中查找方法的过程也称作慢速查找(使用汇编和C++实现)，C++部分方法源码在<code>lookUpImpOrForward</code>函数中，如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)</span><br><span class="line">&#123;</span><br><span class="line">    const IMP forward_imp &#x3D; (IMP)_objc_msgForward_impcache;</span><br><span class="line">    IMP imp &#x3D; nil;</span><br><span class="line">    Class curClass;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    &#x2F;&#x2F; Optimistic cache lookup</span><br><span class="line">    if (fastpath(behavior &amp; LOOKUP_CACHE)) &#123;</span><br><span class="line">        imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">        if (imp) goto done_nolock;</span><br><span class="line">    &#125;</span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line">    if (slowpath(!cls-&gt;isRealized())) &#123;</span><br><span class="line">        cls &#x3D; realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line">    if (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</span><br><span class="line">        cls &#x3D; initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    curClass &#x3D; cls;</span><br><span class="line">    for (unsigned attempts &#x3D; unreasonableClassCount();;) &#123;</span><br><span class="line">        &#x2F;&#x2F; curClass method list.</span><br><span class="line">        Method meth &#x3D; getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        if (meth) &#123;</span><br><span class="line">            imp &#x3D; meth-&gt;imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">        if (slowpath((curClass &#x3D; curClass-&gt;superclass) &#x3D;&#x3D; nil)) &#123;</span><br><span class="line">            imp &#x3D; forward_imp;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (slowpath(--attempts &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">            _objc_fatal(&quot;Memory corruption in class list.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Superclass cache.</span><br><span class="line">        imp &#x3D; cache_getImp(curClass, sel);</span><br><span class="line">        if (slowpath(imp &#x3D;&#x3D; forward_imp)) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (fastpath(imp)) &#123;</span><br><span class="line">            &#x2F;&#x2F; Found the method in a superclass. Cache it in this class.</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">        behavior ^&#x3D; LOOKUP_RESOLVER;</span><br><span class="line">        return resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">    &#125;</span><br><span class="line"> done:</span><br><span class="line">    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"> done_nolock:</span><br><span class="line">    if (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp &#x3D;&#x3D; forward_imp)) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>慢速查找流程图：</p>
<img src="https://p5-tt.byteimg.com/origin/pgc-image/47b512631098428e8bc60162e1df4ab7.png" >

<p>消息发送流程图：</p>
<img src="https://p9-tt.byteimg.com/origin/pgc-image/70dfbbc7f61a4a9fac15e5ff1af809b4.png">



<h3 id="动态方法解析（也称：动态方法决议）"><a href="#动态方法解析（也称：动态方法决议）" class="headerlink" title="动态方法解析（也称：动态方法决议）"></a>动态方法解析（也称：动态方法决议）</h3><p>当消息发送流程找不到方法后就会进入动态方法解析流程。</p>
<p>动态方法解析是当消息发送阶段找不到方法的时候，开发者可以通过重写特定方法（如果是类方法就重写<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>，如果是对象方法就重写<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>），给原先不存在的方法添加方法实现。主要是用到runtime里面的<code>class_addMethod</code>函数，并且动态解析后，会重新走”消息发送“的流程</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>假如这里的person没有实现print方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person *person &#x3D; [Person new];</span><br><span class="line">[person print];</span><br></pre></td></tr></table></figure>

<p>那我们可以在<code>Person.m</code>添加一个方法实现用来替换丢失的<code>print</code>，这里我们用<code>truePrint</code>来替代</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)truePrint &#123;</span><br><span class="line">    NSLog(@&quot;true print&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel &#x3D;&#x3D; @selector(print)) &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获取truePrint方法的Method对象</span><br><span class="line">        Method truePrint &#x3D; class_getInstanceMethod(self, @selector(truePrint));</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 动态添加print方法的实现，通过method_getImplementation获取到方法的函数指针，通过method_getTypeEncoding拿到方法的函数编码即 v@: 或 v16@0:8</span><br><span class="line">        class_addMethod(self, sel, method_getImplementation(truePrint), method_getTypeEncoding(truePrint));</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 返回YES代表有动态添加方法</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Method的结构"><a href="#Method的结构" class="headerlink" title="Method的结构"></a>Method的结构</h4><p>点击Method我们可以看到结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct objc_method *Method;</span><br></pre></td></tr></table></figure>

<p>而<code>ojbc_method</code>的定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name;	</span><br><span class="line">    char * _Nullable method_types;</span><br><span class="line">    IMP _Nonnull method_imp;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>可以看到跟上面所说的<code>method_t</code>是类似的东西</p>
<p>以下是一些拿到<code>Method</code>对象后可以使用的一些函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数调用，但是不接收返回值类型为结构体</span><br><span class="line">method_invoke</span><br><span class="line">&#x2F;&#x2F; 函数调用，但是接收返回值类型为结构体</span><br><span class="line">method_invoke_stret</span><br><span class="line">&#x2F;&#x2F; 获取函数名</span><br><span class="line">method_getName</span><br><span class="line">&#x2F;&#x2F; 获取函数实现IMP</span><br><span class="line">method_getImplementation</span><br><span class="line">&#x2F;&#x2F; 获取函数type encoding</span><br><span class="line">method_getTypeEncoding</span><br><span class="line">&#x2F;&#x2F; 复制返回值类型</span><br><span class="line">method_copyReturnType</span><br><span class="line">&#x2F;&#x2F; 复制参数类型</span><br><span class="line">method_copyArgumentType</span><br><span class="line">&#x2F;&#x2F; 获取返回值类型</span><br><span class="line">method_getReturnType</span><br><span class="line">&#x2F;&#x2F; 获取参数个数</span><br><span class="line">method_getNumberOfArguments</span><br><span class="line">&#x2F;&#x2F; 获取函数参数类型</span><br><span class="line">method_getArgumentType</span><br><span class="line">&#x2F;&#x2F; 获取函数描述</span><br><span class="line">method_getDescription</span><br><span class="line">&#x2F;&#x2F; 设置函数实现IMP</span><br><span class="line">method_setImplementation</span><br><span class="line">&#x2F;&#x2F; 交换函数的实现IMP</span><br><span class="line">method_exchangeImplementations</span><br></pre></td></tr></table></figure>


<h4 id="Runtime中的原理"><a href="#Runtime中的原理" class="headerlink" title="Runtime中的原理"></a>Runtime中的原理</h4><p>在上面的消息发送的流程函数<code>lookUpImpOrForward</code>中，有一段代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">    behavior ^&#x3D; LOOKUP_RESOLVER;</span><br><span class="line">    return resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当找不到消息的时候就会进入动态方法解析的流程即<code>resolveMethod_locked</code>，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static NEVER_INLINE IMP resolveMethod_locked(id inst, SEL sel, Class cls, int behavior) &#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"></span><br><span class="line">    if (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        &#x2F;&#x2F; try [cls resolveInstanceMethod:sel]</span><br><span class="line">        resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; try [nonMetaClass resolveClassMethod:sel]</span><br><span class="line">        &#x2F;&#x2F; and [cls resolveInstanceMethod:sel]</span><br><span class="line">        resolveClassMethod(inst, sel, cls);</span><br><span class="line">        if (!lookUpImpOrNilTryCache(inst, sel, cls)) &#123;</span><br><span class="line">            resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return lookUpImpOrForwardTryCache(inst, sel, cls, behavior);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面我们可以发现<code>resolveInstanceMethod</code>和<code>resolveClassMethod</code>两个函数，分别是实现实例方法的动态消息解析和类方法的动态消息解析，这两个长得差不多，所以我们拿实例对象的函数查看一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void resolveInstanceMethod(id inst, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line">    SEL resolve_sel &#x3D; @selector(resolveInstanceMethod:);</span><br><span class="line"></span><br><span class="line">    if (!lookUpImpOrNilTryCache(cls, resolve_sel, cls-&gt;ISA(&#x2F;*authenticated*&#x2F;true))) &#123;</span><br><span class="line">        &#x2F;&#x2F; Resolver not implemented.</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) &#x3D; (typeof(msg))objc_msgSend;</span><br><span class="line">    bool resolved &#x3D; msg(cls, resolve_sel, sel);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Cache the result (good or bad) so the resolver doesn&#39;t fire next time.</span><br><span class="line">    &#x2F;&#x2F; +resolveInstanceMethod adds to self a.k.a. cls</span><br><span class="line">    IMP imp &#x3D; lookUpImpOrNilTryCache(inst, sel, cls);</span><br><span class="line"></span><br><span class="line">    if (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        if (imp) &#123;</span><br><span class="line">            _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot;</span><br><span class="line">                         &quot;dynamically resolved to %p&quot;, </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; Method resolver didn&#39;t add anything?</span><br><span class="line">            _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</span><br><span class="line">                         &quot;, but no new implementation of %c[%s %s] was found&quot;,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? &#39;+&#39; : &#39;-&#39;, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们可以看到对<code>resolveInstanceMethod</code>方法进行了一次<code>objc_msgSend</code>调用，调用之后又执行了<code>lookUpImpOrNilTryCache</code>函数进行了缓存，如果缓存成功，那么下次调用这个方法就不会在进入动态方法解析阶段，直接通过消息发送阶段就调用成功了。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>根据我们以前所学的知识可以知道，方法查找的流程为</p>
<p>实例方法：类 – 父类 – 父类 – … – 根类 – nil</p>
<p>类方法：元类 – 父元类 – 父元类 – … – 根元类 – 根类 – nil</p>
<p>也就是说丢失的方法最后都会回到根类去找方法，一般情况下是<code>NSObject</code></p>
<p>通过这个特性，我们可以直接在<code>NSObject</code>上添加分类，然后实现动态解析方法，根据方法名前缀进行判断，然后统一处理未被找到的方法添加默认实现。通过这种方式我们可以减少一些找不到方法导致的崩溃问题，提升用户体验。</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>如果没有实现动态方法解析，那么将进入消息转发阶段。消息转发即把消息交给别人发送的意思。</p>
<p>从上面的<code>lookUpImpOrForward</code>函数的源码我们可以看到，最后是调用了<code>_objc_msgForward_impcache</code>这个函数，这个函数是通过汇编实现的</p>
<p>要实现消息转发，我们有两种方式，一种是实现一个方法<code>-forwardingTargetForSelector</code>，一种是实现<code>-methodSignatureForSelector</code>和<code>-forwardInvocation</code>，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(print)) &#123;</span><br><span class="line">        return [[Student alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现了这个方法之后，最后系统会去我们提供的<code>Student</code>对象去寻找<code>print</code>方法，找到了的话就会进行调用。注意这个方法每次都会进来，每次都会生成新的<code>Student</code>对象对其<code>print</code>方法进行调用。</p>
<p>如果<code>forwardingTargetForSelector</code>没实现或者返回空的话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(print)) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么就会寻找<code>-methodSignatureForSelector</code>和<code>-forwardInvocation</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; 方法签名： 返回值类型、参数类型</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(print)) &#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; NSInvocation封装了一个方法调用，包括：方法调用者、方法名、方法参数</span><br><span class="line">&#x2F;&#x2F;&#x2F; anInvocation.target 方法调用者</span><br><span class="line">&#x2F;&#x2F;&#x2F; anInvocation.selector 方法名</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F; [anInvocation getArgument:NULL atIndex:0] 方法参数</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:[[Student alloc] init]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们在方法签名中指定方法类型，然后在<code>forwardInvocation</code>方法中，修改target，然后直接调用，这样子就会直接调用Student的print方法了</p>
<img src="https://p3-tt.byteimg.com/origin/pgc-image/ba2d1d5ff71a49c8913690d6f69fb7d7.png" width=80%>

<h4 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h4><p>当系统执行到<code>forwardInvocation</code>的时候，无论在方法内有任何实现，都不会执行到<code>doseNotRecognizeSelector</code>（抛出异常），所以实现了就不会崩，即便什么都不做。</p>
<p>在<code>forwardInvocation</code>内我们可以拿到方法调用的很多信息，比如方法调用者<code>anInvocation.target</code>、方法名<code>anInvocation.selector</code>和方法参数</p>
<p>比如调用方法为<code>[person print:1]</code>，进入到<code>forwardInvocation</code>后我们可以通过以下方法拿到<code>1</code>这个参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    int a;</span><br><span class="line">    [anInvocation getArgument:&amp;a atIndex:2]; &#x2F;&#x2F; 第一个参数是self，第二个是_cmd，所以从下标2开始取</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要拿返回值的话，就可以这么做</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    [anInvocation invokeWithTarget:[[Student alloc] init]]; &#x2F;&#x2F; 要先调用一下Student的print方法，这里假设返回值是整型</span><br><span class="line">    int result;</span><br><span class="line">    [anInvocation getReturnValue:&amp;result];</span><br><span class="line">    NSLog(@&quot;%d&quot;,result); &#x2F;&#x2F;&#x2F; 这里可以拿到返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NSMethodSignature"><a href="#NSMethodSignature" class="headerlink" title="NSMethodSignature"></a>NSMethodSignature</h4><p><code>[NSMethodSignature signatureWithObjCTypes:&quot;v16@0:8&quot;]</code>，注意这里的方法编码要跟下面<code>forwardInvocation</code>要调用的方法的方法编码一致 </p>
<p>我们除了可以通过方法编码拿到<code>NSMethodSignature</code>对象之外，还可以这么做</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(print)) &#123;</span><br><span class="line">        return [[Student new] methodSignatureForSelector:@selector(print)];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类方法的消息转发"><a href="#类方法的消息转发" class="headerlink" title="类方法的消息转发"></a>类方法的消息转发</h4><p><code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code></p>
<p><code>+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code></p>
<p><code>+ (void)forwardInvocation:(NSInvocation *)anInvocation</code></p>
<p>这几个方法也有类方法版本，但是代码补全没出来，但是实际使用是可行的</p>
<p><code>+ (id)forwardingTargetForSelector:(SEL)aSelector</code>在这个方法里面返回的消息接受者既可以是类对象也可以是实例对象。</p>
<h4 id="synthesize-和-dynamic"><a href="#synthesize-和-dynamic" class="headerlink" title="@synthesize 和 @dynamic"></a>@synthesize 和 @dynamic</h4><p><code>@synthesize</code>用来自动给成员变量名生成<code>setter</code>和<code>getter</code>的声明和实现</p>
<p><code>@dynamic</code>用来告诉编译器不要自动生成<code>setter</code>和<code>getter</code>的实现（声明还是会声明的），待到运行时开发者自己实现，并且不会为属性实现带下划线的成员变量</p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>假如我们调用<code>Student</code>实例的一个父类方法</p>
<p><code>[super run]</code></p>
<p>那么编译后会变成如下代码</p>
<p><code>objc_msgSendSuper2(self,class_getSuperclass(objc_getClass(&quot;Student&quot;)),@selector(run));</code></p>
<p>所以<code>super</code>发送消息的本质是调用<code>objc_msgSendSuper2</code>函数，最终的消息接受者依旧是<code>self</code>，只是实例方法寻找从父类的类对象开始寻找，类方法从父类的元类对象开始寻找。</p>
<p>所以当我们调用方法<code>[super class]</code>的时候，跟<code>[self class]</code>没区别，返回结果是一致的</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 镜像谷歌</title>
    <url>/post/a6a89073.html</url>
    <content><![CDATA[<p>nginx 镜像谷歌</p>
<span id="more"></span>

<p>安装nginx第三方模块</p>
<p>下载-&gt;解压-&gt;编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;artfiles.org&#x2F;openssl.org&#x2F;source&#x2F;old&#x2F;1.1.0&#x2F;openssl-1.1.0g.tar.gz</span><br><span class="line">wget ftp:&#x2F;&#x2F;ftp.csx.cam.ac.uk&#x2F;pub&#x2F;software&#x2F;programming&#x2F;pcre&#x2F;pcre-8.39.tar.gz</span><br><span class="line">wget http:&#x2F;&#x2F;zlib.net&#x2F;zlib-1.2.11.tar.gz</span><br><span class="line"></span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;nginx&#x2F;nginx.git</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;cuber&#x2F;ngx_http_google_filter_module</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;yaoweibin&#x2F;ngx_http_substitutions_filter_module</span><br><span class="line"></span><br><span class="line">cd ngx_http_google_filter_module</span><br><span class="line">git checkout 77532b9</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">tar -zxvf openssl-1.1.0g.tar.gz </span><br><span class="line">tar -zxvf pcre-8.39.tar.gz </span><br><span class="line">tar -zxvf zlib-1.2.11.tar.gz</span><br><span class="line"></span><br><span class="line">cd nginx</span><br><span class="line"></span><br><span class="line">.&#x2F;auto&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --conf-path&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf --with-http_v2_module --with-pcre&#x3D;..&#x2F;pcre-8.39 --with-openssl&#x3D;..&#x2F;openssl-1.1.0g --with-zlib&#x3D;..&#x2F;zlib-1.2.11 --with-http_ssl_module --add-module&#x3D;..&#x2F;ngx_http_google_filter_module --add-module&#x3D;..&#x2F;ngx_http_substitutions_filter_module</span><br><span class="line"></span><br><span class="line">make -j 4</span><br><span class="line"></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>修改配置文件</p>
<p><code>vi /usr/local/nginx/conf/nginx.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name g.arclin.me;</span><br><span class="line">    listen 80;</span><br><span class="line">    resolver 8.8.8.8;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        google on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>

<p>reload 时发生错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx: [error] open() &quot;&#x2F;var&#x2F;run&#x2F;nginx.pid&quot; failed (2: No such file or directory)</span><br></pre></td></tr></table></figure>

<p>解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>pan手势判断方向</title>
    <url>/post/34db2dbc.html</url>
    <content><![CDATA[<p>pan手势判断方向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIPanGestureRecognizer *pan &#x3D; (UIPanGestureRecognizer *)gestureRecognizer;</span><br><span class="line">CGPoint point &#x3D; [pan translationInView:gestureRecognizer.view]; &#x2F;&#x2F; point.x &lt; 0 左滑</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>ngrok 内网穿透使用</title>
    <url>/post/dda122f4.html</url>
    <content><![CDATA[<p>ngrok 内网穿透使用</p>
<span id="more"></span>

<h3 id="安装golang"><a href="#安装golang" class="headerlink" title="安装golang"></a>安装golang</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install build-essential golang mercurial git</span><br></pre></td></tr></table></figure>

<h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;tutumcloud&#x2F;ngrok.git ngrok</span><br><span class="line">export NGROK_DOMAIN&#x3D;&quot;ngrok.arclin.me&quot;</span><br><span class="line">cd ngrok</span><br><span class="line">openssl genrsa -out rootCA.key 2048</span><br><span class="line">openssl req -x509 -new -nodes -key rootCA.key -subj &quot;&#x2F;CN&#x3D;$NGROK_DOMAIN” -days 5000 -out rootCA.pem</span><br><span class="line">openssl genrsa -out device.key 2048</span><br><span class="line">openssl req -new -key device.key -subj &quot;&#x2F;CN&#x3D;$NGROK_DOMAIN” -out device.csr</span><br><span class="line">openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br><span class="line">cp rootCA.pem assets&#x2F;client&#x2F;tls&#x2F;ngrokroot.crt</span><br><span class="line">cp device.crt assets&#x2F;server&#x2F;tls&#x2F;snakeoil.crt</span><br><span class="line">cp device.key assets&#x2F;server&#x2F;tls&#x2F;snakeoil.key</span><br><span class="line">GOOS&#x3D;linux GOARCH&#x3D;amd64</span><br><span class="line">make release-server</span><br><span class="line">cd &#x2F;usr&#x2F;lib&#x2F;golang&#x2F;src&#x2F;</span><br><span class="line">GOOS&#x3D;darwin GOARCH&#x3D;amd64 .&#x2F;make.bash</span><br><span class="line">cd ~&#x2F;ngrok</span><br><span class="line">GOOS&#x3D;darwin GOARCH&#x3D;amd64 make release-client</span><br></pre></td></tr></table></figure>

<h3 id="服务端运行脚本"><a href="#服务端运行脚本" class="headerlink" title="服务端运行脚本"></a>服务端运行脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup  bin&#x2F;ngrokd -domain&#x3D;&quot;ngrok.arclin.me&quot; -httpAddr&#x3D;&quot;:8081&quot; -httpsAddr&#x3D;&quot;:8082&quot; &amp;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>nohub 后台运行</p>
</blockquote>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>新建 <code>./ngrok.cfg</code> 文件写入信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server_addr:arclin.me:4443</span><br><span class="line">trust_host_root_certs: false</span><br></pre></td></tr></table></figure>

<p>客户端运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;ngrok -config&#x3D;.&#x2F;ngrok.cfg -subdomain&#x3D;test 3000</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title>pod install速度慢的终极解决方案</title>
    <url>/post/826fbbdd.html</url>
    <content><![CDATA[<p>相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。</p>
<span id="more"></span>

<p><a href="https://blog.csdn.net/iotjin/article/details/81604034">原博文</a>已经被删掉了，所以我自己copy并整理了一份</p>
<p>相信大家已经感受到pod install速度越来越慢了，网上提供了几种解决方案，但是都没有完全解决速度慢的问题。</p>
<p>使用国内镜像的Specs<br>在pod install时使用命令<br><code>pod install --no-repo-update</code></p>
<p>使用proxychains使终端命令走代理<br>下面就来说明一下这几种方法为何没有完全解决问题</p>
<p>使用国内镜像的Specs<br>这个只是加快了Specs下载更新速度，而且如果使用国内镜像Specs，那么Podfile中就必须指明使用这个Specs。</p>
<p>在pod install时使用命令<br><code>pod install --no-repo-update</code></p>
<p>install时不更新本地库，但如果第一次install还是要去github clone代码</p>
<p>使用proxychains使终端命令走代理</p>
<p>这个只是使pod命令走代理，git download的时候不会走代理<br>其实真正慢的原因并不在pod命令，而是在于github上的代码库访问速度慢，那么就知道真正的解决方案就是要加快git命令的速度。</p>
<p>我使用Shadowsocks代理，默认代理端口为1080，配置好代理之后去终端输入git配置命令，命令如下</p>
<p><code>git config --global http.proxy socks5://127.0.0.1:1080</code></p>
<blockquote>
<p>注意这里的 socks5:// 协议 如果你用的是http/https协议 这里要改成 http:// 或https://</p>
</blockquote>
<blockquote>
<p>这里的http.proxy 一般不用改</p>
</blockquote>
<blockquote>
<p>查看端口号的方式可以在小飞机那里或者其他翻墙软件点击配置信息查看，看本地端口号一项</p>
</blockquote>
<p>上面的命令是给git设置全局代理，但是我们并不希望国内git库也走代理，而是只需要github上的代码库走代理，命令如下</p>
<p><code>git config --global http.https://github.com.proxy socks5://127.0.0.1:1080</code></p>
<blockquote>
<p>这里的socks5:// 协议 跟上面说的同理</p>
</blockquote>
<p>（ps：如果要恢复/移除上面设置的git代理，使用如下命令<br><code>git config --global --unset http.proxy</code><br><code>git config --global --unset http.https://github.com.proxy</code>)</p>
<p>（如果不恢复的话，你一旦关掉代理（小飞机），那么之后git命令都跑不了网络了）</p>
<blockquote>
<p>注意这里的 http.proxy 其实就是上面的<code>git config --global http.proxy socks5://127.0.0.1:1080</code>中的 http.proxy, 如果你写的是https.proxy，那么这里unset的时候应该也写https.proxy</p>
</blockquote>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Cocoapods</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>pop后强制竖屏</title>
    <url>/post/50c5f6e6.html</url>
    <content><![CDATA[<p>pop之后强制竖屏</p>
<span id="more"></span>

<p><code>AppDeleagte.h</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 控制全部不支持横屏，当allowRotation为YES的时候可以横&#x2F;竖屏切换</span><br><span class="line">- (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window &#123;</span><br><span class="line">    if (self.allowRotation) &#123;</span><br><span class="line">        return  UIInterfaceOrientationMaskAllButUpsideDown;</span><br><span class="line">    &#125;</span><br><span class="line">    return UIInterfaceOrientationMaskPortrait;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pop之后强制竖屏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">     [super viewDidAppear:animated];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 强制竖屏</span><br><span class="line">    [[UIDevice currentDevice] setValue:@(UIDeviceOrientationPortrait) forKey:@&quot;orientation&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>一句ipack命令解决iOS编译打包上传fir流程</title>
    <url>/post/4edc914d.html</url>
    <content><![CDATA[<p>一行命令即可将包含 cocoapods 的iOS 项目编译打包并上传到 fir</p>
<span id="more"></span>

<h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><ul>
<li>fir-cli</li>
<li>Cocopods</li>
</ul>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>进入任意一个有.xcodeworksapce文件的目录下，输入ipack（可以自定义）即可完成编译打包上传，加上-c 更新说明<br>参数就可以填写本次打包的更新说明，这个说明会在 fir 上面显示出来</p>
<h3 id="编写shell脚本"><a href="#编写shell脚本" class="headerlink" title="编写shell脚本"></a>编写shell脚本</h3><p>sh代码说明</p>
<p>变量定义</p>
<p><code>basepath=$(pwd)</code>  命令行代码执行位置<br><code>bName=$(basename $&#123;basepath&#125;)</code>  拿到项目文件夹名字<br><code>description=$(basename $&#123;basepath&#125;)</code> 要写在 fir 的更新说明<br><code>achivepath=$&#123;basepath&#125;&#39;/build/&#39;$&#123;bName&#125;&#39;.xcarchive&#39;</code> 构建文件的储存位置</p>
<p><code>ipaPath=$&#123;basepath&#125;&#39;/&#39;$&#123;bName&#125;&#39;.ipa&#39;</code> ipa 的储存位置</p>
<p>拿到参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while getopts &quot;:c:&quot; opt; do&#96; # 遍历参数 虽然现在只有一个，不过为了拓展还是可以加上去</span><br><span class="line">case $opt in</span><br><span class="line">    c ) description&#x3D;&quot;$OPTARG&quot;;;   # 如果参数是c 的话就把内容赋值给description</span><br><span class="line">    ? ) echo &quot;参数选项不正确，应该是 -c &lt;发布内容&gt;&quot;</span><br><span class="line">        exit 1;;</span><br><span class="line">    esca</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>判断命令是不是执行在有<code>.xcodeworksapce</code>文件的目录下</p>
<p><code>$(ls *.xcwork* &gt;/dev/null 2&gt;&amp;1)</code></p>
<p>清除缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;xcodebuild -target　$&#123;bName&#125; clean</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;xcodebuild -exportArchive -exportFormat ipa -archivePath $&#123;achivepath&#125; -exportPath $&#123;ipaPath&#125;</span><br></pre></td></tr></table></figure>

<p>判断编译成功了吗</p>
<p><code>if [ ! -d $&#123;achivepath&#125; ];</code></p>
<p>打包</p>
<p>/usr/bin/xcodebuild -exportArchive -exportFormat ipa -archivePath ${achivepath} -exportPath ${ipaPath}</p>
<p>判断打包成功了吗</p>
<p><code>if [ ! -f $&#123;ipaPath&#125; ];</code></p>
<p>上传到 fir</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fir publish $&#123;bName&#125;.ipa --token &lt;你的 Fir Token&gt; -c $&#123;description&#125;</span><br></pre></td></tr></table></figure>

<p>firToken 的位置</p>
<p><img src="/images/pasted-0.png"></p>
<p>清理编译打包的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf $&#123;ipaPath&#125; $&#123;achivepath&#125;</span><br></pre></td></tr></table></figure>

<p>完事</p>
<p>执行<br>如果你把 sh文件放在桌面的话，一般来说现在去到有.xcodeworksapce文件的目录下，执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~&#x2F;Desktop&#x2F;iosPackage.sh</span><br></pre></td></tr></table></figure>

<p>就可以了，加个参数就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~&#x2F;Desktop&#x2F;iosPackage.sh -c &quot;测试测试&quot;&#96;</span><br></pre></td></tr></table></figure>

<p>但是<code>~/Desktop/iosPackage.sh</code>太长了，所以得给他加个别名</p>
<p>所以执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">touch .bash_profile</span><br></pre></td></tr></table></figure>

<p>创建一个<code>.bash_profile</code>文件</p>
<p>然后在里面填写 <code>alias ipack=&#39;~/Desktop/iosPackage.sh&#39;</code><br>这个<code>ipack</code>你想写啥就啥</p>
<p>然后保存之后执行</p>
<p><code>source ./bash_profile</code></p>
<p>之后就可以直接用 ipack 代替 <code>~/Desktop/iosPackage.sh</code></p>
<p><code>ipack ipack -c &quot;测试测试&quot;</code></p>
<p>END</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Fir</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>使用DKHTTPTool时的异常处理</title>
    <url>/post/7daccd39.html</url>
    <content><![CDATA[<p>本文主要讲述的是在使用 DKHTTPTool 时，返回异常数据时的处理</p>
<span id="more"></span>

<p>如果是普通调用情况的话,也即是调用这个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSInteger)requestForMethod:(NSString *)method</span><br><span class="line">                cacheStragety:(DKCacheStrategy)strategy</span><br><span class="line">                          url:(NSString *)URLString</span><br><span class="line">                       header:(NSDictionary *)header</span><br><span class="line">                       params:(NSDictionary *)params</span><br><span class="line">                       filter:(DKHTTPRequestFilterBlock)filterBlock</span><br><span class="line">                 verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock</span><br><span class="line">                responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>

<p>那么捕获异常只需要拿到回调中的DKResponse中的error属性即可</p>
<p>如果是用链式调用的方法<code>RACSignal</code>回调的话，那么就得看情况了，如果你是用 <code>RACCommand</code> 去启用网络请求的话，那么记得 <code>RACCommand</code> 是用 <code>errors</code> 属性去存储错误信号的，如果你有多个 <code>RACCommand</code> 对象建议你在 <code>ViewModel</code> 里创建一个 <code>RACSubject</code> 去统一处理错误信号，然后你可以这么写<code>[[RACSignal merge:@[_addParamCommand.errors,_removeParamCommand.errors,_sendCommand.errors]] subscribe:self.errors];</code></p>
<p>如果你直接取得网络请求回调中的<code>RACSignal</code>对象的话 ，直接<code>subscribeError:</code>就可以得到<code>NSError</code>对象<br>关于提示错误信息，从交互的角度上来讲，我觉得友好程度</p>
<p><code>TopBarMessage(TWMessageBarManager) &gt; HUD &gt; ALERT</code></p>
<p>当然实际运用的时候还是得看情况，不同情况使用不同的提示方式</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用PHP进行webhook的注意点</title>
    <url>/post/f8291fcc.html</url>
    <content><![CDATA[<p>有时会编写PHP脚本进行webhook, 这里有些地方需要注意一下, 否则会导致脚本执行失败</p>
<span id="more"></span>

<p>允许某些敏感方法的执行<br>编辑<code>php.ini</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">disable_functions &#x3D; scandir,passthru,exec,system,chroot,chgrp,chown,shell_exec,proc_open,proc_get_status,</span><br><span class="line">ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,</span><br><span class="line">stream_socket_server,fsocket,fsockopen</span><br></pre></td></tr></table></figure>

<p>把<code>exec</code>去掉</p>
<p>检查<code>apache</code>用户的目录权限</p>
<p>apache用户公钥要配置在项目里面<br>也就是项目里会有两个公钥<br>一个是root的一个是apache的</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>webhook</tag>
      </tags>
  </entry>
  <entry>
    <title>什么时候用weakSelf什么时候用strongSelf</title>
    <url>/post/f9b1d95c.html</url>
    <content><![CDATA[<h4 id="什么时候用weakSelf-什么时候用-strongSelf"><a href="#什么时候用weakSelf-什么时候用-strongSelf" class="headerlink" title="什么时候用weakSelf 什么时候用 strongSelf"></a>什么时候用weakSelf 什么时候用 strongSelf</h4><ul>
<li><p>Objective C 的 Block 是一个很实用的语法，特别是与GCD结合使用，可以很方便地实现并发、异步任务。但是，如果使用不当，Block 也会引起一些循环引用问题(retain cycle)—— Block 会 retain ‘self’，而 ‘self‘ 又 retain 了 Block。因为在 ObjC 中，直接调用一个实例变量，会被编译器处理成 ‘self-&gt;theVar’，’self’ 是一个 strong 类型的变量，引用计数会加 1，于是，self retains queue， queue retains block，block retains self。</p>
</li>
<li><p>解决 retain circle</p>
<ul>
<li>Apple 官方的建议是，传进 Block 之前，把 ‘self’ 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。<br>示例代码：</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; </span><br><span class="line">	[weakSelf doSomething]; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line"> 	[weakSelf doSomething]; </span><br><span class="line"> 	[weakSelf doOtherThing]; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，于是，strongSelf 就派上用场了：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__weak __typeof__(self) weakSelf &#x3D; self;</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line"> 	__strong typeof(self) strongSelf &#x3D; weakSelf;</span><br><span class="line">   [strongSelf doSomething];</span><br><span class="line">   [strongSelf doOtherThing];</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>__strong 确保在 Block 内，strongSelf 不会被释放。</p>
</li>
<li><p>总结</p>
<ul>
<li><p>在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。</p>
</li>
<li><p>如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用RAC+DKHTTPTool实践</title>
    <url>/post/8d52056b.html</url>
    <content><![CDATA[<p>使用RAC+DKHTTP套件实践</p>
<ul>
<li>这次通过一个简单的例子来解说DKHTTP套件与 RAC 结合的使用</li>
</ul>
<span id="more"></span>

<p><img src="https://github.com/Arc-lin/BlogImage/blob/master/444.png?raw=true"></p>
<ul>
<li><p>首先简析下这个界面</p>
<ul>
<li>顶部搜索框部分的背景：广告栏位+图书推荐的图片，这里是一个获取图片的接口（接口 A）</li>
<li>图书推荐： 这里也是一个接口，需要显示图书的封面（接口 B）</li>
<li>笔记推荐： 这里也是一个接口，需要显示图书笔记的一些简介 （接口 C）</li>
</ul>
</li>
<li><p>页面渲染</p>
<ul>
<li>同页面多接口的渲染方式有多种： <ul>
<li>   一是接口的串联，也就是一个接口返回的数据交作为参数给下一个接口去发送请求 ；</li>
<li>二是同时发送请求，根据接口返回的顺序渲染页面；</li>
<li>三是同时请求，等所有的接口返回之后再一次性进行渲染。</li>
</ul>
</li>
<li>上面的三种渲染方式，RACSignal都有相应的解决方案，假设这里页面渲染的方式选择的是依次渲染，那么我们使用 DKHTTPChainTool 的executeSignal()来写个例子</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> RACSignal *signalA &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class="line">                                         .url(@&quot;&quot;)</span><br><span class="line">                                         .params(@&#123;@&quot;did&quot;:@&quot;1&quot;,@&quot;page&quot;:@&quot;1&quot;,@&quot;num&quot;:@&quot;100&quot;&#125;)</span><br><span class="line">                                         .executeSignal();</span><br><span class="line"></span><br><span class="line">RACSignal *signalB &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class="line">                                        .url(@&quot;&quot;)</span><br><span class="line">                                        .params(@&#123;@&quot;dis_id&quot;:@&quot;9&quot;&#125;)</span><br><span class="line">                                        .executeSignal();</span><br><span class="line"></span><br><span class="line">RACSignal *signalC &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class="line">                                        .url(@&quot;&quot;)</span><br><span class="line">                                        .params(@&#123;@&quot;dis_id&quot;:@&quot;9&quot;&#125;)</span><br><span class="line">                                        .executeSignal();</span><br><span class="line"></span><br><span class="line">RACSignal *mergeSignal &#x3D; [RACSignal merge:@[signalA,signalB,signalC]];</span><br><span class="line">[mergeSignal subscribeNext:^(DKResponse *x)&#123;</span><br><span class="line">      DKLog(@&quot;%zd  %@&quot;,x.taskIdentifier,x.rawData);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>上面这个例子的结果会依次执行三个接口，并且按照接口返回的顺序执行mergeSignal 的 subscribeNext 的 block</p>
<h3 id="同时请求接口，等所有接口返回数据之后再进行渲染"><a href="#同时请求接口，等所有接口返回数据之后再进行渲染" class="headerlink" title="同时请求接口，等所有接口返回数据之后再进行渲染"></a>同时请求接口，等所有接口返回数据之后再进行渲染</h3><blockquote>
<p>上面的三个 Signal就不重复写了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSignal *mergeSignal  &#x3D; [RACSignal zip:@[signalA,signalB,signalC]];</span><br><span class="line">[mergeSignal subscribeNext:^(RACTuple *x)&#123;</span><br><span class="line">     [x.rac_sequence.signal subscribeNext:^(DKResponse *x) &#123;</span><br><span class="line">         DKLog(@&quot;%@&quot;,x.rawData);</span><br><span class="line">     &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>上面的 <code>mergeSignal</code> 里面会发送一个 <code>RACTuple</code> ,里面依次包装着三个请求 Signal的 <code>DKResponse</code>回调对象</p>
<h3 id="接口串联，上一个接口响应的数据作为下一个接口的参数"><a href="#接口串联，上一个接口响应的数据作为下一个接口的参数" class="headerlink" title="接口串联，上一个接口响应的数据作为下一个接口的参数"></a>接口串联，上一个接口响应的数据作为下一个接口的参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> RACSignal *flattenSignal &#x3D; [signalA flattenMap:^RACStream *(DKResponse *value) &#123;</span><br><span class="line">        NSString *did &#x3D; value.result[@&quot;content&quot;][0][@&quot;d_id&quot;];</span><br><span class="line">        return DKHTTPChainInstance.method(@&quot;GET&quot;)</span><br><span class="line">                                 .url(@&quot;&quot;)</span><br><span class="line">                                 .params(@&#123;@&quot;did&quot;:did,@&quot;page&quot;:@&quot;1&quot;,@&quot;num&quot;:@&quot;20&quot;&#125;)</span><br><span class="line">                                 .executeSignal();</span><br><span class="line">&#125;];</span><br><span class="line">[flattenSignal subscribeNext:^(DKResponse *x) &#123;</span><br><span class="line">    DKLog(@&quot;%@&quot;,x.rawData);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>平时常用的大概就这么几个，待补充吧，之后我会继续讲讲关于异常处理的问题。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Reactive Cocoa</tag>
      </tags>
  </entry>
  <entry>
    <title>依赖注入与Objection</title>
    <url>/post/6ae5f77f.html</url>
    <content><![CDATA[<p>本文会说明iOS内依赖注入的概念和依赖注入框架Objection的一般使用</p>
<span id="more"></span>

<h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>首先先说明什么叫做依赖注入</p>
<p>比如AController跳转到BController,那么这时候BController就需要在AController内部进行实例化，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation AController : UIViewController</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (void)jump </span><br><span class="line">&#123;</span><br><span class="line">	BController *bController &#x3D; [[BController alloc] init];</span><br><span class="line">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这么做的话，当AController被封装成组件之后，BController的配置将会被限制，外部无法改变BController任何细节，所以我们 ** 稍 加 改 进 **</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation AController : UIViewController</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCreateBlock:(UIViewController *(^)(void))createBViewControllerBlock &#123;</span><br><span class="line">	....</span><br><span class="line">	self.createBViewControllerBlock &#x3D; createBViewControllerBlock;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jump </span><br><span class="line">&#123;</span><br><span class="line">	UIViewController *bController &#x3D; self.createBViewControllerBlock();</span><br><span class="line">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[AController alloc] initWithCreateBlock:UIViewController* ^&#123;</span><br><span class="line">	BController *bController &#x3D; [[BController alloc] initWithTitle:@&quot;xxx&quot;];</span><br><span class="line">	return bController;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>将BController的创建通过Block暴露出来，AController内部不关心BController是如何被创建的，那么AController对BController的依赖将通过外部的Block进行注入。</p>
<p>这，就是依赖注入。</p>
<p>当然这是最简单的依赖注入，无法满足我们复杂的需求，所以有时候我们需要使用第三方框架，如<code>Objection</code>和<code>Typhoon</code></p>
<h4 id="Objection"><a href="#Objection" class="headerlink" title="Objection"></a>Objection</h4><p>接下来说明一下Objection的使用</p>
<p>Objection 是一个依赖注入框架，能够在你获取一个类的实例的时候，这个类内部的属性也同时会被实例化。举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Car.h</span><br><span class="line"></span><br><span class="line">@class Engine,Break;</span><br><span class="line"></span><br><span class="line">@interface Car : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) Engine *engine;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) Break *breaks;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Car.m</span><br><span class="line"></span><br><span class="line">#import &lt;Objection&#x2F;Objection.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation Car</span><br><span class="line">objection_requires(@&quot;engine&quot;, @&quot;breaks&quot;)</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建一个默认注射器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSObjectionInjector *injector &#x3D; [JSObjection createInjector];</span><br><span class="line">[JSObjection setDefaultInjector:injector];</span><br></pre></td></tr></table></figure>

<p>实例化Car对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Car *car &#x3D; [[JSObjection defaultInjector] getObject:[Car class]];</span><br></pre></td></tr></table></figure>

<p>这时候所依赖的<code>engine</code>对象和<code>breaks</code>对象都会通过<code>init</code>方法实例化</p>
<p>最后打印属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">car &lt;Car: 0x6000006d8480&gt; engine &lt;Engine: 0x6000004841b0&gt; breaks &lt;Break: 0x6000004841e0&gt;</span><br></pre></td></tr></table></figure>

<p>假如说Car对象不能通过<code>init</code>或者<code>initWithXXX</code>等自定义构造方法去实例化，那么我们需要指定方法，让注射器在指定的方法构建依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Car</span><br><span class="line">objection_requires(@&quot;engine&quot;, @&quot;breaks&quot;)</span><br><span class="line">- (void)awakeFromNib &#123;</span><br><span class="line">  [[JSObjection defaultInjector] injectDependencies:self];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>当Car被注射器初始化完成之后，会调用<code>- awakeFromObjection</code>方法，这里可以额外赋一些值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)awakeFromObjection </span><br><span class="line">&#123;</span><br><span class="line">	self.test &#x3D; @&quot;111&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的说的都是直接init出来的对象，但是更多情况下我们需要指定构造方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Car</span><br><span class="line">objection_initializer_sel(@selector(initWithObject:)) &#x2F;&#x2F; 该宏只需且只能出现一次</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithObject:(id)object</span><br><span class="line">&#123;</span><br><span class="line">    if (self &#x3D; [super init]) &#123;</span><br><span class="line">        self.test &#x3D; object;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>取出的时候加上<code>argumentList:</code>参数即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Car *car &#x3D; [[JSObjection defaultInjector] getObject:[Car class] argumentList:@[@&quot;aaaa&quot;]];</span><br></pre></td></tr></table></figure>

<p>或者不想写<code>objection_initializer_sel()</code>宏的话<br>可以直接在取的方法那里改动一下变成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Car *car &#x3D; [[JSObjection defaultInjector] getObject:[Car class] initializer:@selector(initWithObject:) argumentList:@[@&quot;aaaa&quot;]];</span><br></pre></td></tr></table></figure>

<p>效果也是一样的</p>
<h5 id="对象工厂"><a href="#对象工厂" class="headerlink" title="对象工厂"></a>对象工厂</h5><p>在Car中添加一个对象工厂属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property(nonatomic, strong) JSObjectFactory *objectFactory;</span><br></pre></td></tr></table></figure>

<p>然后标记注入里面加多一个<code>objectFactory</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objection_requires(@&quot;engine&quot;, @&quot;breaks&quot;,@&quot;objectFactory&quot;)</span><br></pre></td></tr></table></figure>

<p>然后你就可以通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id obj &#x3D; [self.objectFactory getObject:[Engine class]];</span><br></pre></td></tr></table></figure>

<p>获取到对应的对象</p>
<h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>你可以创建一个继承自<code>JSObjectionModule</code>的模块，在里面绑定相对应的<code>事物</code>，便可直接取到对应的值</p>
<p>例如  一个协议和一个模块类，对象绑定了类名和这个类所遵循的协议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@protocol APIService &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)api:(NSString *)params;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface ModuleA : JSObjectionModule</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ModuleA</span><br><span class="line"></span><br><span class="line">- (void)configure</span><br><span class="line">&#123;</span><br><span class="line">    [self bindClass:[MyAPIService class] toProtocol:@protocol(APIService)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时候注射器初始化方式改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JSObjectionInjector *injectorA &#x3D; [JSObjection createInjector:ModuleA.new]; [JSObjection setDefaultInjector:injectorA];</span><br></pre></td></tr></table></figure>

<p>你就可以直接拿到对应遵循了这个协议的对象而不用通过ModuleA的实例对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyAPIService *delegate &#x3D; [injectorA getObject:@protocol(APIService)];</span><br></pre></td></tr></table></figure>

<p><strong>注意由于绑定的时候是用了bindClass:方法，所以每次取出都是不同的对象</strong></p>
<p>除了绑定对象类名和协议外，还可以绑定一个对象和绑定一个类名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation ModuleA</span><br><span class="line"></span><br><span class="line">- (void)configure</span><br><span class="line">&#123;</span><br><span class="line">    [self bind:对象实例 toClass:[UIApplication class]];</span><br><span class="line">    [self bind:对象实例 toProtocol:@protocol(UIApplicationDelegate)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**注意由于绑定的时候是用了bind:方法，所以每次取出都是相同的对象 **</p>
<p>当对象被创建的时候，可以通过bindBlock:方法进行干涉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation ModuleA</span><br><span class="line"></span><br><span class="line">- (void)configure</span><br><span class="line">&#123;</span><br><span class="line">    [self bindClass:[MyAPIService class] toProtocol:@protocol(APIService)];</span><br><span class="line">    [self bindBlock:^id(JSObjectionInjector *context) &#123;</span><br><span class="line">        MyAPIService *service &#x3D; [[MyAPIService alloc] init];</span><br><span class="line">        service.buildByMySelf &#x3D; YES;</span><br><span class="line">        return service;</span><br><span class="line">    &#125; toClass:[MyAPIService class]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>上面这个例子表示MyAPIService被实例化后都会带上<code>buildByMySelf = YES</code></p>
<p>但是用这种方法的话，假如用注射器取出对象的时候带上了参数，那我们就没办法拿到参数了，所以我们需要用到<code>ObjectionProvider</code>协议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface ProviderA : JSObjectionModule&lt;JSObjectionProvider&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ProviderA</span><br><span class="line">- (id)provide:(JSObjectionInjector *)context arguments:(NSArray *)arguments</span><br><span class="line">&#123;</span><br><span class="line">    MyAPIService *service &#x3D; [[MyAPIService alloc] init];</span><br><span class="line">    service.buildByProvider &#x3D; YES;</span><br><span class="line">    service.arguments &#x3D; arguments;</span><br><span class="line">    return service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)configure</span><br><span class="line">&#123;</span><br><span class="line">	[self bindProvider:[ModuleA new] toClass:MyAPIService.class];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>这样子就能手动构建对象并且得到参数了</p>
<h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>上面提及的<code>bindClass:</code>、<code>bindBlock:</code>、<code>bindProvider:</code>这些方法，都有一个拓展参数<code>inScope:(JSObjectionScope)scope;</code></p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self bindClass:[MyAPIService class] toProtocol:@protocol(APIService) inScope:JSObjectionScopeSingleton named:@&quot;&quot;];</span><br><span class="line"></span><br><span class="line">[self bindBlock:^id(JSObjectionInjector *context) &#123;</span><br><span class="line">	MyAPIService *service &#x3D; [[MyAPIService alloc] init];</span><br><span class="line">	service.buildByMySelf &#x3D; YES;</span><br><span class="line">	return service;</span><br><span class="line">&#125; toClass:[MyAPIService class] inScope:JSObjectionScopeSingleton named:@&quot;&quot;];</span><br><span class="line"></span><br><span class="line">[self bindProvider:[ModuleA new] toClass:MyAPIService.class inScope:JSObjectionScopeSingleton];</span><br></pre></td></tr></table></figure>

<p><code>JSObjectionScopeSingleton</code>意味着注射器取出来的都是同个对象，<br><code>JSObjectionScopeNormal</code>意味着注射器取出来的是不同对象。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Objection 帮助你实现** 依赖注入 **，你只需要完成两件事情，配置依赖关系和获取依赖对象。配置依赖关系时，你可以使用几个常用的宏来快速的完成依赖关系的配置，另外你还可以使用模块的概念来完成更多的绑定操作，它允许你将某些类或某些协议接口绑定到某个或某一类的对象上，在配置完成后，你就可以使用关键的 injector 注入器获取到你所需要的对象。</p>
<p>Objection 像是一种字典容器，通过多种形式将 value 和 key 关联起来，在完成配置之后，你只需要关注你通过何种 key 获取到需要的 value 即可。Objection 最主要的功能之一就是面向接口编程的实现，在上面的示例中也进行了演示，面向接口编程是一种非常重要的编程思想。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>关于案场管家的技术点总结</title>
    <url>/post/8ff6aa28.html</url>
    <content><![CDATA[<p>案场管家的技术点总结</p>
<span id="more"></span>

<h3 id="xib与storyboard"><a href="#xib与storyboard" class="headerlink" title="xib与storyboard"></a>xib与storyboard</h3><ol>
<li><p>xib和storyboard均是用于布局所用，其实如果不需要过于复杂的布局的话完全也可以时候用masonry或者直接CGRect定位亦或者NSNSLayoutConstraint进行布局，如果要用代码的话个人觉得masonry是非常好用的，并且该框架所使用的函数式编程思想和链式编程思想也是值得学习的</p>
</li>
<li><p>storyboard的作用类似于包含多个xib+视图管理，代码调用storyboard里面的控制器的代码如下</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIStoryboard *stroyboard &#x3D; [UIStoryboard storyboardWithName:&quot;storyboard的文件名&quot; bundle:nil];</span><br><span class="line">XXXViewController *vc &#x3D; [storyboard instantiateViewControllerWithIdentifier:“contorller的storyboard Id”];</span><br></pre></td></tr></table></figure>
<p> 如果是controller类xib，那么就直接 alloc init 一个该xib所绑定的controller就可以了<br> 如果是view类xib</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[[NSBundle mainBundle] loadNibNamed:@&quot;CMBuildingCell&quot; owner:nil options:nil] firstObject]</span><br></pre></td></tr></table></figure></li>
<li><p>之前曾经遇到过一个bug，从xib拖线到类文件的时候他会报错，原因是如果你的xib绑定的是一个继承UIView的类（比如一个cell），那么File Owner就应该保持为空，父view绑定类；如果绑定的是一个controller类，那父view绑定为空，File Owner绑定类，从以上说明我们可以得知，FileOwner就是这个xib所属的controller,如果他没有所属的controller，那么调用这个xib的controller就是他的File Owner，所以上面的代码里面的owner我们一直保持为nil就可以了</p>
</li>
</ol>
<h3 id="关于网络获取与数据本地化"><a href="#关于网络获取与数据本地化" class="headerlink" title="关于网络获取与数据本地化"></a>关于网络获取与数据本地化</h3><ol>
<li><p>关于网络方面的话我之前写过一份xmind，大概流程是这样子的</p>
<ul>
<li>首先定义一个布尔变量，判断是否有存档</li>
<li>viewDidLoad 取档并刷新数据</li>
<li>viewWillAppear 中执行 loadDataFromNet</li>
<li>loadDataFromNet方法中判断是否有存档，没有存档并且获取网络数据失败的时候才提示数据刷新失败</li>
</ul>
<p> 示例如下</p>
<ul>
<li>这里用NSCachesDirectory，也就是缓存目录，关于目录的选择看有道云笔记，上面有比较详细的说明 </li>
</ul>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> #define XXFileName [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] stringByAppendingPathComponent:@&quot;xx.data&quot;]</span><br><span class="line">- (void)viewDidLoad &#123;	</span><br><span class="line">	 [super viewDidLoad];</span><br><span class="line">	 &#x2F;&#x2F; 取档</span><br><span class="line">    	self.dataArray &#x3D; [NSKeyedUnarchiver unarchiveObjectWithFile:XXFileName];</span><br><span class="line">    </span><br><span class="line">	 if (self.dataArray) &#123;</span><br><span class="line">   		[self.tableView reloadData];</span><br><span class="line">   		hasArchive &#x3D; YES;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">    	hasArchive &#x3D; NO;</span><br><span class="line">    	&#x2F;&#x2F; 转菊花  或者 下拉刷新也行 </span><br><span class="line">    	[SVProgressHUD setDefaultMaskType:SVProgressHUDMaskTypeBlack];</span><br><span class="line"> 	    [SVProgressHUD show];</span><br><span class="line">	&#125;</span><br><span class="line">	[self loadDataFromNet];</span><br><span class="line">&#125;</span><br><span class="line">- (void)viewWillAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    **如果能保证这个controller每次进来都会经过viewDidLoad(例如本身自己就是子控制器且自己也没有子控制器)则这里就不用写了**</span><br><span class="line">	[self loadDataFromNet];</span><br><span class="line">&#125;	</span><br><span class="line">- (void)loadDataFromNet</span><br><span class="line">&#123;</span><br><span class="line">	[XXTool fetchMsg:^(XXData *data) &#123;</span><br><span class="line">  		self.data &#x3D; data;</span><br><span class="line">    	&#x2F;&#x2F; 归档</span><br><span class="line">    	[NSKeyedArchiver archiveRootObject:profile toFile:XXFileName];</span><br><span class="line">    	dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    		[SVProgressHUD dismiss];</span><br><span class="line">        	[self.tableView reloadData];</span><br><span class="line">    	&#125;);</span><br><span class="line">	 &#125; failure:^(NSError *error) &#123;</span><br><span class="line">    	NSLog(@&quot;%@&quot;,error);</span><br><span class="line">    	dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    	    if(!_hasArchive)[SVProgressHUD showErrorWithStatus:@&quot;加载失败&quot;];</span><br><span class="line">    	&#125;);</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不过做项目的时候还是看实际情况进行调整吧，上面所说的只是一般情况下的网络处理</li>
</ul>
<p> 近期稍微地研究了一下Runtime框架，加上一点脑洞和MJExtendsion的配合，感觉可以做出一个框架，能够实现获取数据之后直接生成跟远程数据库结构相同的本地数据库，一方面可以避开类似salesForce的SOQL语句无法进行多表查询之类的恶心问题，另一方面做数据筛选功能的时候也会简单很多，这个就待我去看看能不能搞出来</p>
</li>
</ol>
<h3 id="关于单例"><a href="#关于单例" class="headerlink" title="关于单例"></a>关于单例</h3><ol>
<li><p>在这个项目里面我导入了一个外部框架（应该说是一个文件？）：Singleton.h<br>这个东西使用起来很爽<br>只要在你想单例的类的声明h里加 singleton_interface（类名）<br>实现m里加 singleton_implementation（类名)<br>就可以了<br>之后你想调用这个类的时候就直接 [ClassName sharedClassName] 就可以直接获得到这个类的单例</p>
</li>
<li><p>什么情况下要用到单例？<br>以案场这个为例子，我每次获取数据都需要加上限制条件，筛选当前项目下和当前登录用户的数据<br>那么我就会频繁使用到projectId 和 userId ，<strong>并且这两个值基本不变</strong><br>所以我就给这个单例写了两个方法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSString *)currentProjectId;</span><br><span class="line">- (NSString *)userId;</span><br><span class="line">- (CMProject *)currentProject</span><br><span class="line">&#123;	</span><br><span class="line"> CMProject*currentProject &#x3D; [NSKeyedUnarchiverunarchiveObjectWithFile:CMSelectProjectFileName];</span><br><span class="line">   	return currentProject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)userId&#123; </span><br><span class="line">return [SFUserAccountManager sharedInstance].currentUser.credentials.userId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用</span><br><span class="line">[[CMUserTool sharedCMUserTool] userId];</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="关于传值"><a href="#关于传值" class="headerlink" title="关于传值"></a>关于传值</h3><ol>
<li><p>传值有三宝：代理、通知、block 另外还有storyboard专用segue传值和成员属性传值等，因为前三个比较重要所以我就说说前三个的使用</p>
<ul>
<li>代理用来两个视图之间的传值，最常用的就是自定义view上面的点击事件通过代理告诉调用它的controller，因为一个界面只能有一个controller，一般我们都是抽出另一个controller的view添加到这个controller上面，所以这时候就要用代理进行两个controller之间的数据传递<br>通知，先说说使用方法</li>
</ul>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**消息接收方**</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(方法名) name:消息名 object:nil];</span><br><span class="line"></span><br><span class="line">**消息发送方**</span><br><span class="line">&#x2F;&#x2F;创建一个消息对象</span><br><span class="line">NSNotification * notice &#x3D; [NSNotification notificationWithName:消息名 object:nil userInfo:nil];</span><br><span class="line">&#x2F;&#x2F;发送消息</span><br><span class="line">[[NSNotificationCenter defaultCenter]postNotification:notice];</span><br><span class="line">移除通知 </span><br><span class="line"></span><br><span class="line">移除单个通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] removeObserver:self name:消息名 object:self];</span><br><span class="line"></span><br><span class="line">移除当前所有通知:[[NSNotificationCenterdefaultCenter]removeObserver:self];</span><br></pre></td></tr></table></figure>

<p> 但是优缺点并存</p>
<blockquote>
<p>优势：</p>
<ol>
<li>不需要编写多少代码，实现比较简单</li>
<li>对于一个发出的通知，多个对象能够做出反应，即1对多的方式实现简单</li>
<li>controller能够传递context对象（dictionary），context对象携带了关于发送通知的自定义的信息</li>
</ol>
</blockquote>
<blockquote>
<p>缺点：</p>
<ol>
<li>在编译期不会检查通知是否能够被观察者正确的处理； </li>
<li>在释放注册的对象时，需要在通知中心取消注册；</li>
<li>在调试的时候应用的工作以及控制过程难跟踪；</li>
<li>需要第三方对象来管理controller与观察者对象之间的联系；</li>
<li>controller和观察者需要提前知道通知名称、UserInfo dictionary keys。如果这些没有在工作区间定义，那么会出现不同步的情况；</li>
<li>通知发出后，controller不能从观察者获得任何的反馈信息。</li>
</ol>
</blockquote>
<ul>
<li>block 用于反向传值，就是在子控制器操作数据后传值回到父控制器，这时候我们用block，不过block传值也有坑，很容易引起循环引用然后烧内存。解决方法就是用weak修饰对象比如 <code>weak typeof(self) weakSelf = self</code><br>这样子我们用weakSelf.对象就不会引起循环引用<ul>
<li>还有block有一个小地方要注意，如果要在block里面调用外部变量的话，要给外部变量加一个__block修饰符</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="关于枚举"><a href="#关于枚举" class="headerlink" title="关于枚举"></a>关于枚举</h3><p>枚举不用讲太多，枚举就是为了方便判断而已，但是命名规范还是要说的,举个栗子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef enum : NSUInteger &#123;</span><br><span class="line">     CMRelatedTypeOpportunity,</span><br><span class="line">     CMRelatedTypeBooking,</span><br><span class="line">     CMRelatedTypeSalesOrder,</span><br><span class="line">     CMRelatedTypeContract,</span><br><span class="line">     CMRelatedTypeCollection,</span><br><span class="line">     CMRelatedTypeTrade</span><br><span class="line"> &#125; CMRelatedType;</span><br></pre></td></tr></table></figure>
<p>枚举的成员名 = 枚举名 + 类型名</p>
<h3 id="关于案场的客户界面-——-复杂的逻辑-TO-一个Controller"><a href="#关于案场的客户界面-——-复杂的逻辑-TO-一个Controller" class="headerlink" title="关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller"></a>关于案场的客户界面 —— 复杂的逻辑 TO 一个Controller</h3><p>案场那个客户界是这个app中逻辑最复杂的一个界面，虽然通过了枚举的判断方便了一个代码的阅读，但总的来说上千行代码着实还是恶心。<br>类似的场景应该以后应该还会经常发生，但是虽然开发的时候可能方便了但是维护起来也太费劲了，并且之前项目的种种维护的体验也告诉了我们一个事实：MVC框架不够用了</p>
<p>所以——我们还是换个架构吧~</p>
<p>我大概考虑了一下，逻辑层还是尽可能的细分，多几个类都行，然后耦合性应该低<br>之前我们就已经习惯了把业务层从controller中抽取出来,这种方式应该保留<br>然后我们可以尝试引入MVCS架构以及MVVM架构等，具体的demo应该会在近期实现</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>关于App混合开发的介绍</title>
    <url>/post/b179ff40.html</url>
    <content><![CDATA[<p><img src="https://ooo.0o0.ooo/2017/03/14/58c75bfb373da.png"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Hybrid App 混合开发意思是在web-app、native-app这两者之间的app开发,兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”, 并且也方便我们进行热修复.</p>
<span id="more"></span>

<blockquote>
<p>跨平台就是你写一套代码,然后iOS和Android都能用,这样子可以大大节省人力成本和开发成本</p>
</blockquote>
<blockquote>
<p>热修复就是应用发布之后你还可以通过下发补丁或者直接修改web部分代码去修改app的内容,由于iOS版本应用要上传到应用市场需要经过严格的审核,这将会花费很多时间,如果每次项目一有点小问题就重新发布上架,这将会是一场灾难,所以app的热修复技术在iOS中显得尤为重要</p>
</blockquote>
<p>目前比较流行的有Cordova/PhoneGap,HTML 5+,React Native,Weex,AppCan(因为这个平台在很多地方吐槽很严重所以暂时不讨论),接下来我们一个个地讨论这些开发框架.</p>
<h3 id="Cordova-PhoneGap"><a href="#Cordova-PhoneGap" class="headerlink" title="Cordova/PhoneGap"></a>Cordova/PhoneGap</h3><p><img src="https://ooo.0o0.ooo/2017/03/14/58c7511a7b3cf.png" alt="Cordova logo"></p>
<p><a href="http://cordova.apache.org/">Cordova 官网</a></p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>为什么这两个要放在一起呢,因为PhoneGap被Adobe收购了,临走之前把核心代码给了Apache,Apache就把这个项目名作Cordova,所以说PhoneGap和Cordova出自同一家,他们都会被开源社区和Adobe所推动.</p>
<p>这个框架是作为原生与web之间的中间件,它采用插件的形式调用原生模块,最后成品就是原生页面和web页面的一个混合应用,现在是一个为大多数混合应用所采用的框架,拥有广大的前景</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>用相对简单,学习成本低,对于不熟悉原生开发的前端工程师来说是不错的选择.</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>说实话这个并不是Cordova的缺点,而是web应用共有的问题,就是页面响应迟钝和操作体验不佳的问题.但是这些问题在现在也已经有了足够多的解决方案,具体想了解可以自行上网查阅.</p>
<h3 id="HTML-5"><a href="#HTML-5" class="headerlink" title="HTML 5+"></a>HTML 5+</h3><p><img src="https://ooo.0o0.ooo/2017/03/14/58c7511a6ebea.png" alt="HTML5+ logo"></p>
<p><a href="http://ask.dcloud.net.cn/docs/">官方文档</a></p>
<h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>DCloud和H5中国产业联盟发起的项目,使用H5+框架自带的各种方法去进行与原生模块之间的沟通,结果产出的依然是web页面,但是性能相对比Cordova好.</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>上手简单,学习成本低,有完整的中文文档,作为移动端webView上的框架体验是很不错的,前端人员可以优先考虑使用这个框架.</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>貌似国外基本没人知道这东西,第三方插件和资源相对较少,要是遇到问题也只能去dcloud社区里面找,stackoverflow是帮不到你的啦,而且就目前看来框架自带的bug还是有的.</p>
<h3 id="ReactNative"><a href="#ReactNative" class="headerlink" title="ReactNative"></a>ReactNative</h3><p><img src="https://ooo.0o0.ooo/2017/03/14/58c7511a63fec.jpg" alt="ReactNative logo"></p>
<p><a href="http://reactnative.cn/">中文官网</a></p>
<h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>Facebook 发布的一个混合开发框架,使用ES5/ES6语法,通过ReactNative自带的框架去调用原生模块,但重点是他虽然写的是前端语言,JSX和ES5/ES6但是可以经过构建渲染,将DOM元素转为原生元素,也就是使用前端语言开发原生app已成为现实,既能保留原生的体验又能体现出跨平台和热修复的优势,所以近两年来这个框架十分火.</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>既有原生的体验,又能做到跨平台,虽然加载速度还是比纯原生慢一点,但是这个差距已经能达到毫秒级,基本不影响体验,目前像支付宝,手机QQ,淘宝 都已经在部分模块使用了React Native框架,市场前景广阔,拥有丰富的资料.</p>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>因为这个框架还出现不久,目前还是0.x版本阶段,有部分原生模块还没有接入,只能等他更新</p>
<p>需要一定的学习成本,如果你说你是个会HTML和CSS的前端工程师,那不好意思你还是从入门教程开始看吧╮(╯_╰)╭</p>
<h3 id="Weex"><a href="#Weex" class="headerlink" title="Weex"></a>Weex</h3><p>官网 … 额… 没官网..只有一个<a href="http://www.weex.help/">论坛</a></p>
<h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>阿里爸爸推出的跟ReactNative差不多的框架,所以介绍就跟上面差不多,其实我并不是很熟悉这个框架,而且这个框架是16年4月阿里才开放出来内测的,现在支持的原生元素还是不多,现在一年过去了感觉没引起多大关注,如果你学过Vue,那么这个框架你可能会比较好上手</p>
<p>总之阿里爸爸推出了这个轮子还是很吊的.之后说不定会一鸣惊人呢?</p>
<h3 id="AppCan"><a href="#AppCan" class="headerlink" title="AppCan"></a>AppCan</h3><p><a href="http://www.appcan.cn/">官网</a></p>
<h4 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h4><p>国内的混合开发框架</p>
<p>_(´ཀ`」 ∠) 这个东西是基于他们服务器运行的,所以说如果他们的服务器跪了,你的app就跪了,当然如果你是付费用户,他们就会很快地帮你处理.他们有自己的开发IDE,产出的是也是webView页面,这里就不过多介绍了,具体可以看他们官网.</p>
<h3 id="关于热修复"><a href="#关于热修复" class="headerlink" title="关于热修复"></a>关于热修复</h3><p>前言就讲了热修复是啥东西,然后说说最近发生的一件事</p>
<p>今年的三八妇女节那天,苹果发了邮件给使用了热修复的开发者,说你们在应用商店上面的app里面有使用了热修复框架,希望你们以后不要用,因为这会违反什么吧啦吧啦协议条款,然后一群不是很懂英文的程序员就猜来猜去,就说苹果不让用热修复了,JSPatch不能用了啊,ReactNative药丸啊╮(╯_╰)╭,我在V2看到的最多的就是iOS开发者的欢呼23333,感觉真是世态炎凉,原生的优势已经得通过保护才能体现了吗?</p>
<p>嘛.认真看看邮件,苹果是说你们不能用热修复的手段去改变app的功能,像是调用runtime底层方法之类的,就比如说你这个功能本来是显示一个公司的产品展示的的,但是你通过了应用审核之后,远程下发补丁,然后一打开app就弹出一大堆广告,那这样子肯定是违反协议的,当然你用JSPatch的方式你想做啥就做啥,显然不是很好,所以现在JSPatch官方也说近期不要用(前几天我更新了一个app的新版本,没有移除JSPatch,居然也过审了???),但是RN框架是不会做这些事情的,收到邮件的RN开发者大多是因为里面用了Code Push或Expo之类的第三方.</p>
<p>那结论就是,JSPatch不给用了,那也许大家会更倾向于RN或者web方案,所以近期RN的发展应该会更加迅速,反正无论如何,大家尝到热修复的甜头,肯定不会就此罢休.</p>
<hr>
<p>文: Arclin</p>
<p>2017.03.14</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>Cordova</tag>
        <tag>AppCan</tag>
        <tag>Weex</tag>
        <tag>HTML5+</tag>
      </tags>
  </entry>
  <entry>
    <title>关于第三方单元测试框架的简单说明</title>
    <url>/post/7daa41d8.html</url>
    <content><![CDATA[<p>关于第三方单元测试框架的简单说明</p>
<span id="more"></span>


<h2 id="Pod安装"><a href="#Pod安装" class="headerlink" title="Pod安装"></a>Pod安装</h2><p>Podfile编写（框架只能安装在UnitTest的Target中）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">target &#39;BaZiPaiPanSDK&#39; do</span><br><span class="line">    ...</span><br><span class="line">    target &#39;BaZiPaiPanSDKTests&#39; do</span><br><span class="line">        inherit! :search_paths</span><br><span class="line">        pod &#39;Specta&#39;</span><br><span class="line">        pod &#39;Expecta&#39;</span><br><span class="line">        pod &#39;OCMock&#39;</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h2 id="Specta"><a href="#Specta" class="headerlink" title="Specta"></a>Specta</h2><ul>
<li>Specta是一个BDD（行为驱动开发）框架</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;OCMock&#x2F;OCMock.h&gt;</span><br><span class="line">#import &lt;Specta&#x2F;Specta.h&gt;</span><br><span class="line">#import &lt;Expecta&#x2F;Expecta.h&gt;</span><br><span class="line">#import &lt;ReactiveCocoa&#x2F;ReactiveCocoa.h&gt;</span><br><span class="line">#import &quot;BZPPCaiYunViewModel.h&quot;</span><br><span class="line"></span><br><span class="line">SpecBegin(BZPPCaiYunViewModel)	&#x2F;&#x2F; 声明了一个测试类</span><br><span class="line"></span><br><span class="line">    __block BZPPCaiYunViewModel *viewModel; &#x2F;&#x2F; 我们要测试这个类</span><br><span class="line"></span><br><span class="line">    beforeEach(^&#123; 					&#x2F;&#x2F; 通过beforeEach 首先先初始化 </span><br><span class="line">        viewModel &#x3D; [[BZPPCaiYunViewModel alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    describe(@&quot;BZPPCaiYunViewModel&quot;, ^&#123;  &#x2F;&#x2F; 声明一组用例</span><br><span class="line">    </span><br><span class="line">        it(@&quot;refresh when data isn&#39;t empty&quot;, ^&#123; &#x2F;&#x2F; 通过 it 声明一个用例，前面的字符串是一个描述</span><br><span class="line">            __block id result;</span><br><span class="line">            waitUntil(^(DoneCallback done) &#123; &#x2F;&#x2F; 假设这里有网络请求，所以需要异步，有点像GCD的信号量</span><br><span class="line">                [[viewModel.loadDataCommand execute:nil] subscribeNext:^(id x) &#123;</span><br><span class="line">                    result &#x3D; x;</span><br><span class="line">                    done(); &#x2F;&#x2F; 请求结束，告知框架可以继续往下走</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;);</span><br><span class="line">            expect(result).notTo.beNull(); &#x2F;&#x2F; 这里是Expecta框架的内容，后面解释</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    afterEach(^&#123;</span><br><span class="line">        viewModel &#x3D; nil; &#x2F;&#x2F; 测试结束，清空</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">SpecEnd &#x2F;&#x2F; 类的结束，相当于 @end</span><br></pre></td></tr></table></figure>


<h2 id="OCMock"><a href="#OCMock" class="headerlink" title="OCMock"></a>OCMock</h2><ul>
<li><p>OCMock一般用来构造伪数据，比如说有时候我们一个方法内部需要通过很多数据才能完成，但是这些数据需要其他复杂的实现去获取，这时候我们用OCMock就可以方便地创造这些数据</p>
</li>
<li><p>OCMock可以做的事情大概如下</p>
<ul>
<li>指定一个方法的返回值</li>
<li>验证某个方法是否有被调用 (比如说指定了错误的数据会不会调用处理异常的方法)</li>
<li>验证方法block传出来的参数是否符合预期</li>
<li>模拟UI和验证UI的显示</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SpecBegin(BZPPCaiYunViewModel)</span><br><span class="line"></span><br><span class="line">    __block BZPPCaiYunViewModel *viewModel;</span><br><span class="line"></span><br><span class="line">    beforeEach(^&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    describe(@&quot;Test OCMock&quot;, ^&#123;</span><br><span class="line">        it(@&quot;It should not to be null&quot;, ^&#123;</span><br><span class="line">            id mockManager &#x3D; OCMClassMock([BZPPHunLianManager class]); &#x2F;&#x2F; 因为是单例所以要用这种方法mock一个对象</span><br><span class="line">            OCMStub([mockManager sharedInstance]).andReturn([BZPPHunLianManager class]); &#x2F;&#x2F; 同上，调用单例方法返回一个单例对象, OCMStub意思就是模拟执行某个方法, 用andReturn返回指定的值</span><br><span class="line">            OCMVerify([mockManager getGanQingHunYinData:OCMOCK_ANY isMale:YES]); &#x2F;&#x2F; 验证这个方法是否在上面的过程中被调用了，结果是没有被调用，测试失败</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    afterEach(^&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">SpecEnd</span><br></pre></td></tr></table></figure>

<h2 id="Expecta"><a href="#Expecta" class="headerlink" title="Expecta"></a>Expecta</h2><ul>
<li>Expecta是一个断言框架, 语法十分地通俗易懂, 很接近自然语言</li>
<li>Expecta的用法比较简单</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expect(obj).to.beNull(); &#x2F;&#x2F; 期望某对象应该是空值</span><br><span class="line">expect(obj).toNot.beNull(); &#x2F;&#x2F; 期望某对象不应该是空值</span><br><span class="line">expect(obj).equal(xxx); &#x2F;&#x2F; 期望等于某个值</span><br></pre></td></tr></table></figure>

<p>诸如此类比较多可以去看Github官方文档</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>发现一个api</title>
    <url>/post/54b26395.html</url>
    <content><![CDATA[<p>发现一个好用的api，用于找出selectedItem 在 dataSource 里面的位置，适用于tableView和collectionView</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSIndexSet *indexSet &#x3D; [self.photos indexesOfObjectsPassingTest:^BOOL(DKPhoto * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">    if ([self.selectedPhotoArray containsObject:obj]) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>在 iCloud Drive中显示 App的iCloud文件夹</title>
    <url>/post/3eb7dc04.html</url>
    <content><![CDATA[<ol>
<li>修改 info.plist</li>
</ol>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;NSUbiquitousContainers&lt;&#x2F;key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;iCloud.com.example.app&lt;&#x2F;key&gt;</span><br><span class="line">        &lt;dict&gt;</span><br><span class="line">            &lt;key&gt;NSUbiquitousContainerIsDocumentScopePublic&lt;&#x2F;key&gt;</span><br><span class="line">            &lt;true&#x2F;&gt;</span><br><span class="line">            &lt;key&gt;NSUbiquitousContainerName&lt;&#x2F;key&gt;</span><br><span class="line">            &lt;string&gt;App name to display in iCloud Drive&lt;&#x2F;string&gt;</span><br><span class="line">            &lt;key&gt;NSUbiquitousContainerSupportedFolderLevels&lt;&#x2F;key&gt;</span><br><span class="line">            &lt;string&gt;None&lt;&#x2F;string&gt;</span><br><span class="line">        &lt;&#x2F;dict&gt;</span><br><span class="line">    &lt;&#x2F;dict&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改版本构件号(必改)</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>利用MJExtension取出模型数组中的某个属性组成数组</title>
    <url>/post/8e2ebfdf.html</url>
    <content><![CDATA[<p>利用MJExtension取出模型数组中的某个属性组成数组</p>
<span id="more"></span>

<p>在做otg的时候想做这么一件事，就是遍历模型数组然后取出里面的属性值然后再保存到数组里，后来翻了翻MJExtension好像有类似的方法声明，试了一下果然可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MJProperty *p &#x3D; [[MJProperty alloc] init];</span><br><span class="line">[p setValue:@&quot;text&quot; forKey:@&quot;name&quot;]; \\ 因为name是readonly，所以我就只能用keyValue的方式去给他赋值了</span><br><span class="line">NSArray *arr &#x3D; [p valueForObject:self.topics];</span><br><span class="line">NSLog(@&quot;%@&quot;,arr);</span><br></pre></td></tr></table></figure>

<p>如果包装一下大概就是这样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSArray *)fetchPropertys:(NSString *)propertyName fromObjects:(NSArray *)objects&#123;</span><br><span class="line">	MJProperty *p &#x3D; [[MJProperty alloc] init];</span><br><span class="line">	[p setValue:propertyName forKey:@&quot;name&quot;]; </span><br><span class="line">	return [p valueForObject:objects];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>弄个分类可能会比较方便吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSArray *)fetchPropertys:(NSString *)propertyName&#123;</span><br><span class="line">	MJProperty *p &#x3D; [[MJProperty alloc] init];</span><br><span class="line">	[p setValue:propertyName forKey:@&quot;name&quot;]; </span><br><span class="line">	return [p valueForObject:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何开发/管理一个项目</title>
    <url>/post/3c7b026b.html</url>
    <content><![CDATA[<p>如何管理一个项目，这是个沉重的话题。实际上，目前很多人都是凭借经验进行项目管理和开发，事实上管理项目是有着大量的方法论，这些方法论整理起来被人归纳成了一个学科，名字叫做<code>软件工程</code>，接下来的内容将会归纳总结里面的一些要点，如果你有意成为一个项目管理者，请必须了解一下这些基础知识。</p>
<span id="more"></span>

<h2 id="软件系统模型"><a href="#软件系统模型" class="headerlink" title="软件系统模型"></a>软件系统模型</h2><p>开始一个项目之前，你需要做好准备，那就是建立系统模型，有了抽象的模型，才会有具像的实现。</p>
<ul>
<li>在软件开发中，软件系统模型大体可分为两类：<code>概念模型</code>和<code>软件模型</code>。</li>
<li>概念模型是创建在需求层上的，它描述了系统是什么。</li>
<li>软件模型是建立在抽象层上的，它描述了实现概念模型的软件解决方案。</li>
<li>软件模型可进一步分为<code>设计模型</code>、<code>实现模型</code>和<code>部署模型</code>。</li>
</ul>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p> 一个完整的需求需要有以下特征：</p>
<ol>
<li>必要的：该需求是用户所要求的（产品经常会提一些伪需求，比如说在帖子列表添加个一键评价，点击了就回复666，但实际上没有用户想毫无感情地666，所以这是伪需求，不满足该条件的请拒绝）；</li>
<li>无歧义的：该需求只能用一种方式解释（这个就不用解释了，遇到有歧义的需求请问清楚）；</li>
<li>可测的：该需求可以进行测试；</li>
<li>可跟踪的：该需求可以从一个开发阶段跟踪到另一个开发阶段（意思就是这个需求不会因为开发的进行变得模糊、不清晰）；</li>
<li>可测量的：该需求是可测量的（意思就是实现这个需求不能无限耗费人力物力，说好这个需求两个人一天能做完，就两个人一天真的能做完）。</li>
</ol>
<h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><ol>
<li>功能需求：系统或系统构件必须执行的功能</li>
<li>非功能需求：分为性能需求、外部接口需求、设计约束需求、质量属性需求。</li>
</ol>
<h3 id="怎么发现需求"><a href="#怎么发现需求" class="headerlink" title="怎么发现需求"></a>怎么发现需求</h3><table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">情况</th>
<th align="center">成功条件</th>
<th align="center">风险</th>
</tr>
</thead>
<tbody><tr>
<td align="center">自悟</td>
<td align="center">自己想</td>
<td align="center">要比你的最终客户拥有更多的一样弄领域和过程方面的知识和丰富的想象力，也就是你要比你的用户更加清楚用户要啥</td>
<td align="center">无法验证你想出来的东西是不是你的用户想要的</td>
</tr>
<tr>
<td align="center">交谈</td>
<td align="center">跟你的客户聊</td>
<td align="center">你能提出正确的问题，回答人能揭示需求本质的能力</td>
<td align="center">可能会获得一堆需求，而且越来越多，不断增长，可能还会推翻你之前的需求，可能导致超出项目成本和进度的限制<s>（甚至可能被你的开发揍一顿）</s></td>
</tr>
<tr>
<td align="center">观察</td>
<td align="center">你去看你的用户怎么用你的软件</td>
<td align="center">你需要有洞察事物本质的能力</td>
<td align="center">1. 你的用户会抵触你的观察（很明显侵犯隐私了）2. 用户会觉得你是不是这软件没做好或者哪里需求不到位所以老是来看我，对你的软件产生怀疑</td>
</tr>
<tr>
<td align="center">小组会</td>
<td align="center">项目组的人全部叫出来开会讨论需求</td>
<td align="center">你小组的人有不同观点，并且有良好的发现需求的能力，能揭示需求中存在的问题，最重要的是需求能跟用户达成共识</td>
<td align="center">会议组织不到位就凉了，而且天天开会你的项目组的人也受不了，可能会提出矛盾需求</td>
</tr>
<tr>
<td align="center">提炼</td>
<td align="center">针对已有的部分需求文档，看线上反馈情况，进行提炼</td>
<td align="center">你需要有想象力和需求标识能力，包括熟悉相关的技术标准</td>
<td align="center">跟自悟一样，你不能知道你发现的需求是否是对的</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="需求规约"><a href="#需求规约" class="headerlink" title="需求规约"></a>需求规约</h3><p>需求规约就是怎么写一个需求表，因为形式很多，所以最好就根据实际情况进行，这里不做规定，但是必须包含以下几个特征</p>
<ol>
<li>重要性和稳定性：需求要根据重要程度和稳定程度分优先级，例如：基本需求、可选需求和期望需求。</li>
<li>可修改的：在不过多地影响其他需求的情况下，可以容易地修改一个单一需求。</li>
<li>完整的：没有被遗漏的需求。</li>
<li>一致的：不存在互斥的需求。</li>
</ol>
<p>为什么需求规约很重要？（概念性东西）</p>
<ol>
<li>是软件开发组织和用户之间一份事实上的技术合同书，是产品功能及其环境的体现。</li>
<li>对于项目的其余大多数工作，需求规约是一个管理控制点。</li>
<li>对于产品/系统的设计，需求规约是一个正式的、受控的起点。</li>
</ol>
<h2 id="结构化方法"><a href="#结构化方法" class="headerlink" title="结构化方法"></a>结构化方法</h2><h3 id="结构化需求分析"><a href="#结构化需求分析" class="headerlink" title="结构化需求分析"></a>结构化需求分析</h3><ol>
<li><p>为什么要这么做？</p>
<p> 为了应对三大挑战：</p>
<pre><code> - 问题空间理解。（假如让你开发一个八字排盘App，但是你又不懂八字，所以要开发出一个高质量、满足用户要求的App，就不容易了）
 - 人与人之间的通信。（开发过程长、活动多、任务重，项目组成员多，直接面对面沟通起来难免有遗漏、误解等，所以这也是一个挑战）
 - 需求的变化性。（需求是不断变化的，所以这是软件开发人员面临的挑战）
</code></pre>
<p> 一种好的需求技术应该具有以下基本特征：</p>
<pre><code> 1. 提供方便通信的机子，例如，在不同开发阶段，使用对相关人员易于理解的语言。
 2. 鼓励需求分析人员使用问题空间的术语思考问题，编写文档。
 3. 提供定义系统边界的方法。
 4. 提供支持抽象的基本机制，例如，&quot;划分&quot;，&quot;功能抽象&quot;，&quot;结构抽象&quot;等。
 5. 为需求分析人员提供多种可供选择的方案。
 6. 提供特定的技术，适应需求的变化等。
</code></pre>
</li>
<li><p>几种基本术语的解释</p>
<p> (1) 数据流：数据流是数据的流动，用于表达在分析中所要使用的、用于表达”客体”的信息，用箭头表示。<br> 大概长这样：</p>
 <img width=50px src='https://i.loli.net/2019/10/21/wM2SkZXGDY46lQh.png'>
 (2) 加工：加工是数据变换的单元，即它接受输入的数据，对其进行处理，并产生输出。
 大概长这样
 <img width=50px src='https://i.loli.net/2019/10/21/mcfwVCaJI1Sn8kZ.png'>
 (3) 数据存储：数据存储是数据的静态结构。
 大概长这样(可以是横的或者竖的)
 <img width=50px src='https://i.loli.net/2019/10/21/xbXKc45RlYpnNB9.png'>
 (4) 数据源和数据潭: 数据源是数据流的起点，数据潭是数据流的归宿地。数据源和数据潭是系统之外的实体，可以是人、物或其他软件系统。
 大概长这样
 <img width=50px src='https://i.loli.net/2019/10/21/LiwWbnSAs7Pqzoh.png'></li>
<li><p>数据流图</p>
<p> 把上面的元素组成起来就是数据流图了<br> 大概长这样</p>
 <img width=70% src="https://i.loli.net/2019/10/21/wDdaFiLe9Ps6UzA.png">

<p> 几个要点：1）数据流起到连接其他实体的作用，实体可以是加工、数据存储、数据源和数据潭；2）加工之间可以有多个数据流，这些数据流之间可以没有任何关系，数据流图也不表明他们的先后次序；3）对于一个比较大的软件系统，往往需要采用多层次的数据流图。</p>
</li>
<li><p>建模过程</p>
<ol>
<li>建立系统环境图，确立系统语境</li>
<li>自顶向下，逐步求精，建立系统的层次数据流图</li>
<li>定义数据字典。数据字典有3种基本结构表示：顺序结构，选择结构，重复结构。<ul>
<li>顺序结构是指数据A由数据B和数据C顺序构成的，并记为”+”。例如：学生成绩=姓名+性别+学号+科目+成绩，其中”=”号表达的是”定义为”.</li>
<li>选择结构是指由数据A是由数据B或数据C定义的，即数据B不可能同时是B和C，并记为“|”，例如：性别=男|女</li>
<li>重复结构是指数据A是由多个重复出现的数据B构成的，并记为”| |”，例如：学生成绩表=|学生成绩|<img width="50%" src="https://i.loli.net/2019/10/21/43hSWgZPmVirHfA.png"></li>
</ul>
</li>
<li>描述加工：该步的目标为依据系统的数据流图，给出其中每一加工的小说明。加工可以有3种表达工具。<ol>
<li>结构化自然语言（自然语言描述）</li>
<li>判定表: 由条件类别，条件组合，操作，操作执行构成。举例如图<img width=50% src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D22%2C0%2C590%2C389%3Bc0%3Dbaike80%2C5%2C5%2C80%2C26/sign=d64b6fc508087bf469a30da9cfe16500/42166d224f4a20a48dfd6c499a529822730ed059.jpg"></li>
<li>判定树。举例如图<img width=60%  src="https://i.loli.net/2019/10/21/COmGSet5I61lFsH.png"></li>
</ol>
</li>
</ol>
</li>
<li><p>注意事项：</p>
<ol>
<li>模型平衡问题</li>
<li>信息复杂性控制问题</li>
</ol>
</li>
<li><p>需求验证<br> 验证需求规格说明书中的每一单一需求是否满足5个性质，即必要性、无歧义性、可测性、可跟踪性、可测量性；验证需求规格说明是否满足4个性质，即重要性和稳定程度、可修改性、完整性和一致性。在必要时还需要验证其他特性，如设计无关性。</p>
</li>
</ol>
<h3 id="结构化设计"><a href="#结构化设计" class="headerlink" title="结构化设计"></a>结构化设计</h3><h4 id="总体设计步骤"><a href="#总体设计步骤" class="headerlink" title="总体设计步骤"></a>总体设计步骤</h4><p>结构化设计方法基于<code>自顶向下，功能分解</code>的基本原则，针对两种不同类型的数据流图，分别提出了变换设计和事务设计。其中，变换设计的目标是将变换型数据流图映射为模块结构图，而事务设计的目标是将事务型数据流图映射为模块结构图。</p>
<ol>
<li><p>变换型数据流图和事务性和数据流图<br>（1）变换型数据流图：具有比较明显的输入部分和变换部分之间的界面、变换部分和输出部分之间界面的数据流图，称为变换型数据流图；<br><img src="https://www.sytm.net/ueditor/net/upload/2013-12-31/bdae1434-8b79-4209-b818-2502c7ea3bee.png"><br>（2）事务型数据流图：数据到达一个加工T，该加工T根据输入的值，在其后若干动作序列中选出一个来执行，这类数据流图成为事务型数据流图。<br><img src="https://www.sytm.net/ueditor/net/upload/2013-12-31/142b2c91-a9ad-4c6e-b075-ecd6a900ee63.png"></p>
</li>
<li><p>总体设计分为3个阶段。第一阶段为初始设计，在对给定的数据流图进行复审和精化的基础上，将其转化为初始的模块结构图。第二阶段为精化设计，依据模块“高内聚低耦合”的原则精化初始的模块结构图，并设计其中的全局数据结构和每一模块的接口。第三阶段为复审阶段，对前两个阶段所得到的高层软件结构进行复审，必要时还可能需要对该软件结构做一些精化工作，这对软件的一些性质，特别是对软件质量的提高，将产生非常大的影响。</p>
</li>
<li><p>天天扯着嗓子喊高内聚低耦合，到底什么是内聚什么是耦合？</p>
<ul>
<li>耦合：耦合是指不同模块之间相互依赖程度的度量<ul>
<li>内容耦合：当一个模块直接修改或操作另一个模块的数据，或当一个模块直接修改或操作，另一个模块的数据或一个模块不通过正常入口转入到一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该尽量避免使用。</li>
<li>公共耦合：两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。</li>
<li>控制耦合：一个模块通过接口向另一个模块传递一个控制信号，接收信号的模块根据信号值进行适当的动作，这种耦合被成为控制耦合。</li>
<li>标记耦合：若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。</li>
<li>数据耦合：模块之间通过参数来传递数据，则称为数据耦合。数据耦合是最低的一种耦合形式。</li>
</ul>
</li>
<li>内聚：内聚是指一个模块内部各成分之间相互关联程度的度量<ul>
<li>偶然内聚：如果一个模块的各成分之间基本不存在任何关系，则称为偶然内聚</li>
<li>逻辑内聚：几个逻辑上相关的功能被放在同一模块中，则称为逻辑内聚。</li>
<li>时间内聚：如果一个模块完成的功能必须在同一时间内执行（例如，初始化系统或一组变量），但这些功能只是因为时间因素关联在一起，则称为时间内聚。</li>
<li>过程内聚：如果一个模块内部的处理成分是相关的，而且这些处理必须以特定的次序执行，则称为过程内聚。</li>
<li>通信内聚：如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚</li>
<li>顺序内聚：如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚</li>
<li>功能内聚：最理想的内聚是功能内聚，模块所有的成分对于完成单一的功能都是基本的。功能内聚的模块对完成其功能而言是充分必要的。</li>
</ul>
</li>
<li>启发式规则：无论是变换设计还是事务设计，都涉一个共同的问题，即“基于高内聚低耦合的原理，采用一些经验性的启发式规则，对初始的模块结构图进行精化，形成最终的模块结构图”。</li>
<li>怎么做？<ol>
<li>改进软件结构，提高模块独立性。</li>
<li>力求模块规模适中。</li>
<li>力求深度、宽度、扇出和扇入适中。深度：表示其控制的<code>层数</code>(不包括自身)；宽度：同一层次上模块总数的<code>最大值</code>；扇出：一个模块<code>直接</code>控制（调用）的下级模块数目；扇入：一个模块有多少个上级模块<code>直接</code>调用它。</li>
<li>尽力使模块的作用域在其控制域之内。作用域：受该模块内<code>一个判定</code>所影响的所有模块的集合；控制域：模块本身以及所有<code>直接或间接</code>从属于它的模块的集合。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="详细设计步骤"><a href="#详细设计步骤" class="headerlink" title="详细设计步骤"></a>详细设计步骤</h4><ol>
<li>结构化程序设计<br> 包含三种基本控制结构：顺序结构、选择结构、循环结构</li>
<li>详细设计工具<ol>
<li>程序流程图 <img width=20% src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945069712&di=74b11092aae0042569e80dc22ee83438&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F09%2F17%2F02%2F27798515%2F15.files%2Ffile0001.jpg">
 缺点：不是一种逐步求精的工具，过早地考虑程序的流程，不去考虑程序的全局结构；所表达的控制流，往往不受任何约束可随意转移，从而会影响甚至破坏好的系统结构设计；不易表示数据结构。</li>
<li>盒图（N-S图） <img width=40% src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945228461&di=10908d6d12f9c8984356e884b3c0aeb5&imgtype=0&src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fzhidao%2Fwh%253D450%252C600%2Fsign%3Da401ed95523d26972e86005960cb9ecd%2Fd833c895d143ad4bd5fe969f81025aafa50f0698.jpg"></li>
<li>PAD图（Problem Analysis Diagram） <img width="40%" src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571945326054&di=d66d2f92c755db3f26640c2bbb6bc338&imgtype=0&src=http%3A%2F%2Fyzhtml01.book118.com%2F2016%2F12%2F15%2F14%2F51872755%2F6.files%2Ffile0001.jpeg"></li>
</ol>
 N-S图和PAD图支持“自顶向下逐步求精”的设计。可节省人工编码工作，有利于提高软件的可靠性和软件生产率<ol start="4">
<li>类程序设计语言（伪码/PDL）<br> 是一种用正文形式表示数据结构和处理过程的设计工具，PDL是一种“混合”的语言。</li>
</ol>
</li>
<li>设计规约<br> 完成软件设计后，应产生设计规约，完整准确地描述满足系统需求规约所要求的的所有功能模块，以及伴随功能模块而出现的非功能机制。设计规约通常包括<code>概要设计规约</code>和<code>详细设计规约</code>。 <code>概要设计规约</code>指明高层软件体系结构，其主要功能如下： 1.系统环境等与设计有关的限定条件 2. 软件模块的结构（模块之间的接口及设计的数据流和主要数据结构）3. 模块描述（接口定义，模块处理逻辑，必要的注释等）4. 文件结构和全局数据文件的逻辑结构 5.测试需求 <code>详细设计规约</code>（包括各处理过程的算法和算法所涉及的全部数据结构的描述）主要作为软件设计人员与程序员之间交流的媒体。</li>
</ol>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><h3 id="UML是一种图形化建模语言（Unified-Modeling-Language）"><a href="#UML是一种图形化建模语言（Unified-Modeling-Language）" class="headerlink" title="UML是一种图形化建模语言（Unified Modeling Language）"></a>UML是一种图形化建模语言（Unified Modeling Language）</h3><p>为了支持抽象分析和设计中的事物，UML给了八个基本术语，即类、接口、协作、用况、主动类、构件、制品、节点、</p>
<ul>
<li>类： 类是一组拥有相同属性、操作、关系和语义的对象的描述。类主要用于抽象客观世界中的事物。</li>
<li>接口：每个操作描述了类、构件或子系统的一个服务，接口就是操作的一个集合。接口是对系统/产品的“接缝”予以模型化，表明了一个类、构件、子系统所需要得到的、且与实现无关的行为。</li>
<li>用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的、可观察的结果。</li>
<li>协作：协作是一个交互，涉及交互的三要素：交互各方、交互方式以及交互内容</li>
<li>用况：用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的，可观察的结果。</li>
<li>主动类：主动类是一种至少具有一个进程或线程的类。</li>
<li>构件：构件是系统设计中的一种模块化部件，通过外部接口隐藏了它的内部实现。</li>
<li>制品：制品是系统中包含物理信息（比特）的、可替代的物理部件。</li>
<li>节点：节点是运行时存在的物理元素，通常表示一种具有记忆能力和处理能力的计算机资源。</li>
</ul>
<p>类在建模中的主要用途：</p>
<ol>
<li>模型化问题域中的概念</li>
<li>建立系统的职责分布模型</li>
<li>模型化建模中使用的基本类型</li>
</ol>
<p>使用接口应注意的问题</p>
<ol>
<li>接口只可以被其他类目使用，而本身不能访问其他类目</li>
<li>接口描述类的外部可见操作，通常是该类的一个特有限定行为。这些操作可以使用可见性、并发性、衍型、标记值和约束来修饰。</li>
<li>接口不描述其中操作的实现，也没有属性和状态。据此可见，接口在形式上等价于一个没有属性、没有方法而只有抽象操作的抽象类</li>
<li>接口之间没有关联、泛化、实现和依赖。但可以参与泛化、实现和依赖</li>
</ol>
<h3 id="表达关系的术语"><a href="#表达关系的术语" class="headerlink" title="表达关系的术语"></a>表达关系的术语</h3><pre><code>关联：关联是一组具有相同结构、相同链的描述，是类目之间的一种结构关系。关联可以用一条连接两个类目的线段表示，并可对其命名，其结构可以具有方向性，用一个实心三角形来指示关联的方向。
    1. 关联名 。
    2. 导航：对于一个给定的类目，可以找到与之关联的另一个类目，这称为导航。
    3. 角色：角色是关联一端的类目对另一端的类目的一种呈现。
    4. 可见性：通过导航可以找到另一类目的实例，有时候需要限制访问。
    5. 多重性：类中对象参与一个关联的数目，成为该关联的多重性
    6. 限定符：限定符是一个关联的属性或属性表。
    7. 聚合：分类是增强客观实际问题语义的一种手段。聚合是对象之间（不是类之间）的一种结构关系。
    8. 组合：组合是聚合的一种特殊形式
泛化：泛化是一般性类目和它的较为特殊类目之间的一种关系。子类可以继承父类的属性和操作，同时也可以替换父类的声明。
    泛化的四种约束：完整、不完整、互斥、重叠
细化：细化是类目之间的语义关系，其中一个类目规约保证了另一个类目执行的契约。
依赖：依赖用于描述一个类目使用另一个类目的信息和服务，是一种使用关系。
    依赖的分类：绑定、导出、允许、示例、实例化、幂类型、精化、使用。
    
关联、泛化和细化都是一类特地类型的依赖。

使用这四种术语，可以模型化以下各种关系：
1. 结构关系（静态结构和动态结构）
    进行模型化时两种驱动方式：1.以数据驱动 2. 以行为驱动
2. 继承关系
3. 精化关系
4. 依赖关系
</code></pre>
<h3 id="表达组合信息的术语————包"><a href="#表达组合信息的术语————包" class="headerlink" title="表达组合信息的术语————包"></a>表达组合信息的术语————包</h3><p>为了控制信息组织的复杂性，UML提供了组织信息的一种通用机制————包，支持形成一些可管理的部分。换言之，包可以作为“模块化”和“构件化”的一种机制。</p>
<p>包是模型元素的一个分组。一个包本身可以被嵌套在其他包中，并且可以含有子包和其他种类的模型元素。</p>
<p>通过在包的名字前加上一个可见性符号（+，-，#），来指示该包的可见性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ 表示对其他包而言都是可见的</span><br><span class="line"># 表示对子孙包而言是可见的</span><br><span class="line">- 表示对其他包而言都是不可见的</span><br></pre></td></tr></table></figure>

<p>为了模型化包之间的关系，UML给出了两种依赖，即访问和引入。</p>
<ul>
<li>访问：表明目标包中的内容可以被源包所引用，或被那些递归嵌套在源包中的其他包所引用。</li>
<li>引入：表明目标包中具有适当可见性的内容（名字）被加入到源包的公共命名空间中。</li>
</ul>
<p>UML中用虚线加箭头的方式表示源包到目标包的依赖（访问和引入）。</p>
<h3 id="UML术语的作用"><a href="#UML术语的作用" class="headerlink" title="UML术语的作用"></a>UML术语的作用</h3><ol>
<li>类用于抽象客观事物</li>
<li>接口用于抽象事物之间的缝隙</li>
<li>协作用于抽象协作性行为</li>
<li>用况用于抽象功能</li>
<li>主动类用于抽象并发行为</li>
<li>构件用于抽象软件解中标识的成分</li>
<li>制品用于抽象工作产品</li>
<li>节点用于抽象计算单元</li>
<li>关联用于抽象结构关系</li>
<li>泛化用于抽象“一般/特殊”关系</li>
<li>实现用于抽象精化关系</li>
<li>依赖用于抽象使用关系</li>
</ol>
<h3 id="UML的模型表达式"><a href="#UML的模型表达式" class="headerlink" title="UML的模型表达式"></a>UML的模型表达式</h3><ol>
<li>结构图和行为图<br> 结构图用于表达系统或系统成分的静态结构模型，给出系统或系统成分的一些说明性信息<br> 行为图用于表系统或系统成分的动态结构模型，给出系统或系统成分的一些行为信息</li>
<li>类图、用况图、顺序图及状态图<ul>
<li>类图是可视化地表达系统静态结构功能模型的工具，使用类图所表达的系统静态结构模型，给出的是一些关于系统的说明性信息。<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176025075&di=1875f9ac829f33a38a45131069ee3e4a&imgtype=0&src=http://images.cnblogs.com/cnblogs_com/a-i/Uml2.JPG"></li>
<li>用况图是一种表达系统功能模型的图形化工具，它包含六个模型元素，分别是主题、用况、参与者、关联、泛化、依赖<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176303343&di=4146dfc9badef7bc95f4c750ab149eb0&imgtype=0&src=http://yzhtml01.book118.com/2016/09/24/23/28839740/23.files/file0001.png"></li>
<li>顺序图由一组对象以及按时序组织的对象之间的关系组成，是一种交互图，包含对象之间传递的信息。控制操作包括<code>选择执行操作</code>、<code>条件操作</code>、<code>并发迭代操作</code>、<code>迭代执行操作</code>。<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176439921&di=d592e65ae4a1bc1c2e65a98e415a897a&imgtype=0&src=http://aliyunzixunbucket.oss-cn-beijing.aliyuncs.com/png/20180615101636402475.png"></li>
<li>状态图强调了从一个状态到另一个状态的控制流，是显示一个状态机的图。状态图由状态、事件和状态转移构成。使用状态图的作用有两个：一是创建一个系统的动态模型，二是创建一个场景的模型<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1572176576658&di=70e3de58666cf1d7315cf56a05ec0d35&imgtype=0&src=http://yzhtml01.book118.com/2016/12/07/08/48638362/25.files/file0001.png"></li>
<li></li>
</ul>
</li>
<li>创建一个系统的类图的步骤<ul>
<li>模型化代建系统中的概念，形成类图中的基本元素</li>
<li>模型化代建系统中的各种关系，形成该系统的初始类图</li>
<li>模型化系统中的协作，给出该系统的最终类图</li>
<li>模型化逻辑数据库模式</li>
</ul>
</li>
<li>信号事件、调用事件、时间事件和变化事件<ul>
<li>信号事件是一种异步事件，信号通常由状态机处理。如果没有定义对该事件的响应，那么事件均可能丢失。事件的丢失，就有可能引发接受者——状态机的一个错误的状态转移。</li>
</ul>
</li>
<li>状态转移所涉及的内容<br> 描述一个状态转换，一般涉及五个部分：<ol>
<li>源状态：发生状态转移的那个状态</li>
<li>转移触发器：在源状态中由对象识别的事件，并且一旦满足其监护条件，则使状态发生转移。</li>
<li>监护条件：一个布尔表达式，当某个事件触发器接受一个事件时，如果该表达式有值为真，则触发一个转移；若有值为假，则不发生状态转移。</li>
<li>效应：一种可执行的行为</li>
<li>目标状态：转移完成后所处的状态</li>
</ol>
</li>
<li>最常用的控制操作子<br> 选择执行操作子：该操作子由两部分组成：一是监护条件，二是控制体<br> 条件执行操作子：控制体通过水平线将其分为一些部分，每一部分表示一个条件分支，每一分支有一个监护条件。<br> 并发执行操作子：该控制操作子的体通过水平线将其分为多个部分，每一部分表示一个并行计算。该控制操作子表明，当进入该控制操作子是，所有部分并发执行。<br> 迭代执行操作子：该控制操作子表明，只要在每一次迭代之前该监护条件为真，那么该控制体就反复执行，当该控制体上面的监护条件为假时，控制绕过该控制操作子。</li>
<li>子状态机、简单状态和组合状态的概念<br> 子状态机：为了有效地组织状态、控制对象状态的复杂性，UML提供了组合状态，在一个状态机中引入了另一个状态机。被引入的状态机就称为子状态机。<br> 简单状态：子状态是被嵌套到另一状态中的状态。相对地，被引入的状态机就称为子状态机。<br> 组合状态：把含子状态的状态称为组合状态，组合状态可包含两种类型的子状态机，即非正交（顺序）子状态机和正交（并发）子状态机。<h2 id="RUP"><a href="#RUP" class="headerlink" title="RUP"></a>RUP</h2></li>
</ol>
<h3 id="RUP-Rational-Unified-Process-的特点"><a href="#RUP-Rational-Unified-Process-的特点" class="headerlink" title="RUP(Rational Unified Process)的特点"></a>RUP(Rational Unified Process)的特点</h3><p>RUP的突出特点是，它是一种以用况（Use Case）为驱动的、以体系结构为中心的迭代、增量式开发。</p>
<ol>
<li>以用况为驱动<br>以用况为驱动是指在系统的生存周期中，以用况作为基础，驱动系统有关人员对所要建立系统的功能需求进行交流，驱动系统分析、设计、实现和测试等活动。</li>
<li>以体系结构为中心<br>以体系结构为中心是指在系统的生存周期中，开发的任何阶段都要给出相关模型视角下有关体系结构的描述，作为构思、构造、管理和改善系统的主要标准。</li>
<li>迭代、增量式开发<br>迭代、增量式开发是指通过开发活动的迭代，不断地产生相应的增量。在RUP中，规定了四个开发阶段：初始阶段、精化阶段、构造阶段和移交阶段。</li>
</ol>
<h3 id="核心工作流"><a href="#核心工作流" class="headerlink" title="核心工作流"></a>核心工作流</h3><p>核心工作流：需求获取、分析、设计、实现和测试</p>
<h4 id="需求获取"><a href="#需求获取" class="headerlink" title="需求获取"></a>需求获取</h4><table>
<thead>
<tr>
<th align="center">基本步骤</th>
<th align="center">产生的制品</th>
</tr>
</thead>
<tbody><tr>
<td align="center">列出候选的特征</td>
<td align="center">特征表</td>
</tr>
<tr>
<td align="center">理解系统语境</td>
<td align="center">领域模型或业务模型</td>
</tr>
<tr>
<td align="center">捕获功能需求</td>
<td align="center">用况模型</td>
</tr>
<tr>
<td align="center">捕获非功能需求</td>
<td align="center">补充需求或针对特殊需求的用况</td>
</tr>
</tbody></table>
<h3 id="业务用况模型和业务对象模型"><a href="#业务用况模型和业务对象模型" class="headerlink" title="业务用况模型和业务对象模型"></a>业务用况模型和业务对象模型</h3><ol>
<li>业务用况模型。业务用况模型是以用框图予以表达的</li>
<li>业务对象模型。为了精化业务用况模型中的每一个业务用况，RUP引入了三个术语，用于表达参与业务的业务对象：<code>工作人员</code>、<code>业务实体</code>和<code>工作单元</code>。业务对象模型可通过交互图和活动图予以表达。</li>
</ol>
<h3 id="标识用况应注意的问题"><a href="#标识用况应注意的问题" class="headerlink" title="标识用况应注意的问题"></a>标识用况应注意的问题</h3><ol>
<li>建立用况的结构中，应尽可能反映用况的实际情况。</li>
<li>在用况的结构化中，不论是施加什么结构，新引入的用况都不应该太小或太大</li>
<li>在建立用况的结构是，应尽量避免对用况模型中的用况功能进行分解。</li>
</ol>
<h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><ol>
<li>分析类是类的一种衍型，分为边界类、实体类和控制类</li>
<li>用况细化时一个协作，针对一个用况，其行为可用多个分析类之间的相互作用来细化，并记为用况细化。用况细化对用况模型中的一个特定的用况提供了一种直接跟踪的方式。</li>
<li>分析包是一种控制信息组织复杂性的机制，提供了分析制品的一种组织手段。其主要特征为：体现问题的分离；高内聚、低耦合；尽可能体现一个系统的完整顶层设计，尽可能成为一些子系统或者成为一些子系统的组成部分。</li>
</ol>
<h4 id="具有良好结构的分析包的特征"><a href="#具有良好结构的分析包的特征" class="headerlink" title="具有良好结构的分析包的特征"></a>具有良好结构的分析包的特征</h4><ol>
<li>体现问题分离</li>
<li>高内聚、低耦合。</li>
<li>尽可能提现一个系统的完整顶层设计。</li>
</ol>
<h4 id="软件设计层上的术语"><a href="#软件设计层上的术语" class="headerlink" title="软件设计层上的术语"></a>软件设计层上的术语</h4><p>软件设计是满足需求规约所需要的软件结构。RUP为了满足系统/产品分析模型规约需求的软件结构，为设计层提供了是个术语：设计类、用况细化、设计子系统和接口，用于表达软件结构中的基本元素。</p>
<ol>
<li>设计类：一个设计类是对系统中实现一个类或类似构造的一个无缝抽象</li>
<li>用况细化：用况细化是设计模型的一个协作，其中使用设计类及其对象，描述一个特定用况是如何予以细化的，是如何执行的</li>
<li>设计子系统：设计子系统可以包含设计类、用况细化、接口，以及其他子系统，通过对其操作来显示其功能。</li>
<li>接口：接口用于规约由设计类和设计子系统，必须提供与该接口操作对应的实现方法。</li>
</ol>
<h4 id="创建系统-产品用况模型的活动和任务"><a href="#创建系统-产品用况模型的活动和任务" class="headerlink" title="创建系统/产品用况模型的活动和任务"></a>创建系统/产品用况模型的活动和任务</h4><p>创建系统/产品用况模型的活动和任务如下</p>
<ol>
<li>活动一：发现并描述参与者<br>任务1：发现参与者，即直接发现一些候选的参与者<br>任务2：描述参与者，即对参与者进行命名并描述</li>
<li>活动二：发现用况并对用况进行描述<br>任务1：发现用况<br>任务2：描述用况，即确定用况后对其进行描述</li>
<li>活动三：确定用况的优先级，目的是在寻找参与者并对其进行描述和发现用况的并对用况进行描述的基础上确定哪些用况适合在早期的迭代中开发，哪些适合在后期的迭代中开发。</li>
<li>活动四：精化用况。这一活动的目的是详细描述出每一用况的事件流，包括用况是怎样开始的，是怎样结束的，是怎样与参与者进行交互的，最终形成一系列精化的用况</li>
<li>活动五：构造用户界面原型。这一活动的目的在于建造用户界面原型，使用户可以有效地执行用况。</li>
<li>活动六：用况模型的结构化。需要进行以下工作。<ol>
<li>抽取用况描述中的那些一般性的和共享的功能并使用泛化关系标识和描述那些共享功能</li>
<li>抽取用况描述附加的或可选的功能</li>
<li>标识用况之间的包含关系。通过用况模型的结构化，最终形成一个系统/产品的精化用户模型</li>
</ol>
</li>
</ol>
<h4 id="创建系统-产品需求分析模型的活动和任务"><a href="#创建系统-产品需求分析模型的活动和任务" class="headerlink" title="创建系统/产品需求分析模型的活动和任务"></a>创建系统/产品需求分析模型的活动和任务</h4><ol>
<li>活动1：体系结构分析。该活动的目标是通过标识分析包和分析类，建立分析模型和体系结构“骨架”，并标识有关分析包和分析类的特定需求。<br>任务1：标识分析包。该任务的基本输入是系统的用况模型<br>任务2：处理分析包之间的共性<br>任务3：标识服务包<br>任务4：定义分析包的依赖，该任务的目标是发现相对独立的包，实现包的高内聚和低耦合<br>任务5：标识重要的实体类，该任务的目标是标识在体系结构方面具有意义的实体类。<br>任务6：标识分析包和重要实体类的公共特定需求，该任务的目标是依据需求获取阶段所标识的非功能需求，针对在分析期间所标识的包和分析类，标识它们的一些公共的特定要求。</li>
<li>活动2：用况分析。该活动的目标是：一是标识那些在用况事件流执行中所需要的分析类和对象；二是将用况的行为分布到参与交互的各个分析对象；三是捕获用况细化上的特定需求。<br>任务1：标识分析类，该任务的目标是标识在细化一个用况中所需要实体类、控制类和边界类，给出它们的名字、责任、属性和关系。<br>任务2：描述分析类对象之间的交互。首先确定细化该用况所必要的交互，其次分派该用况的功能，最后根据其责任，发现该交互图中的各个链。</li>
<li>活动3：类的分析。该活动的目标：一是标识并维护分析类的属性和关系；二是捕获分析类细化中的特殊需求。<br>任务1：标识责任，通过组合一个类在不同用况细化中所扮演的角色来完成。<br>任务2：标识属性<br>任务3：标识关联和聚合</li>
<li>活动4：包的分析。该活的目标是：一是确保分析包尽可能与其他包相对独立；而是确保分析包实现了它的目标；三是描述依赖，以益于可以估计未来的变化。</li>
</ol>
<h3 id="创建系统-产品设计模型的活动和任务"><a href="#创建系统-产品设计模型的活动和任务" class="headerlink" title="创建系统/产品设计模型的活动和任务"></a>创建系统/产品设计模型的活动和任务</h3><p>创建系统/产品设计模型的活动和任务如下：</p>
<ol>
<li>活动1：体系结构设计，该活动的目标是创建设计模型和部署模型，以及它们视角下的体系结构描述<br>任务1：标识节点和它们的网络配置，网络配置通常使用一种三元模式：客户端、数据库功能、业务/应用逻辑<br>任务2：标识子系统和它们的接口，目的是为了寻求一些复用的可能，而后随着设计模型的开发，在形成子系统结构中不断发现并烟花。<br>任务3：标识在体系结构方面有意义的设计类和它们的接口。标识在体系结构方面有意义的设计类的基本思想是：初始可以依据在体系结构方面有意义的分析类来标识一些体系结构上具有重要意义的设计类。标识在系统体系结构方面有意义的设计类时，应注意主动类往往是一类在体系结构方面具有重要意义的类。</li>
<li>活动2：用况的设计。其中分析模型用况细化分析是活动的输入、对应输出用况细化设计。<br>为了实现用况设计的输入/输出，一般采用两种方法：<ol>
<li>标识参与用况细化的设计类，首先基于分析模型研究相应用况细化分析中的分析类，来标识为细化这些分类所需要的设计类，然后基于用况的功能对每一个标识的设计类赋予相应的责任，最后为该细化创建一个类图，汇聚参与该用况细化的设计类，并给出类之间的关系。</li>
<li>标识参与用况细化的子系统和接口。</li>
</ol>
</li>
<li>活动3：类的设计。该活动的目标是完成用况细化设计中每一个类的角色设计，并完成有关每一类的非功能需求的设计。<br>任务1：概括描述设计类，该任务的输入为分析类/接口。<br>任务2：标识的操作，一般应依据分析类来标识设计类所提供的、所需要的操作，其中需要使用程序设计语言的语法来描述说标识的操作。<br>任务3：标识属性，该任务的目标是标识设计类所需要的属性，并使用程序设计语言的语法给出属性的描述。<br>任务4：标识关联和聚合。<br>任务5：标识泛化，基于分析模型中分析类之间的泛化，可以发现设计模型中的很多泛化。<br>任务6：描述方法，在设计期间一般用自然语言或适当的使用伪码对方法进行规约，但是在实现期间直接使用程序设计语言对方法进行规约。<br>任务7：描述状态，有些设计对象是受状态控制的，即它们的状态确定了它们接受一个消息的行为。在这种情况下，使用一个状态图描述一个对象的不同状态转移是有意义的。</li>
<li>活动4：子系统的设计。该活动的目标是：确保子系统尽可能独立于其他子系统或它们的接口；确保子系统提供正确的接口；确保子系统实现了它的目标，即给出了该子系统提供的那些接口所定义的操作的细化。</li>
</ol>
<h3 id="设计模型包含的元素"><a href="#设计模型包含的元素" class="headerlink" title="设计模型包含的元素"></a>设计模型包含的元素</h3><p>RUP设计的主要结果是设计模型，它尽量保持该系统具有分析模型的结构，并作为系统实现的输入，包含以下四个元素：</p>
<ol>
<li>设计子系统和服务子系统，以及它们的接口、依赖和内容。</li>
<li>设计类以及它们具有的操作、属性、关系及其实现的需求。</li>
<li>用况细化设计。</li>
<li>设计模型视角下的体系结构描述。</li>
</ol>
<h3 id="用况模型与分析模型的比较"><a href="#用况模型与分析模型的比较" class="headerlink" title="用况模型与分析模型的比较"></a>用况模型与分析模型的比较</h3><table>
<thead>
<tr>
<th align="center">用况模型</th>
<th align="center">分析模型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">使用客户语言来描述</td>
<td align="center">使用开发者语言来描述</td>
</tr>
<tr>
<td align="center">给出的是系统对外的视图</td>
<td align="center">给出的是系统对内的视图</td>
</tr>
<tr>
<td align="center">使用用况予以结构化，但给出的是外部视角下的系统结构</td>
<td align="center">使用衍型类予以结构化，当给出的是内部视角下的系统结构</td>
</tr>
<tr>
<td align="center">可以作为客户与开发者之间关于“系统应该做什么，不应该做什么”的契约</td>
<td align="center">可以作为开发者理解系统如何勾画、如何设计和如何实现的基础</td>
</tr>
<tr>
<td align="center">在需求之间可能存在一些冗余、不一致和冲突等问题</td>
<td align="center">在需求之间不应存在冗余、不一致和冲突问题</td>
</tr>
<tr>
<td align="center">捕获的是系统的功能，包括在体系结构方面有意义的功能</td>
<td align="center">给出的是细化的系统功能，包括在体系结构方面具有意义的功能</td>
</tr>
<tr>
<td align="center">定义了一些进一步需要在分析模型中予以分析的</td>
<td align="center">定义了用况模型中每一个用况的细化</td>
</tr>
</tbody></table>
<h3 id="RUP实现活动"><a href="#RUP实现活动" class="headerlink" title="RUP实现活动"></a>RUP实现活动</h3><p>目标：基于设计类和子系统生成构件；对构件进行单元测试，进行集成和连接；把可执行的构件映射到部署模型。</p>
<table>
<thead>
<tr>
<th align="center">输入</th>
<th align="center">活动</th>
<th align="center">执行者</th>
<th align="center">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">设计模型、部署模型、体系结构描述【设计模型、部署模型角度】</td>
<td align="center">实现体系结构</td>
<td align="center">体系结构设计者</td>
<td align="center">构件【概述】、体系结构描述【实现模型、部署模型角度】</td>
</tr>
<tr>
<td align="center">补充需求、用况模型、设计模型、实现模型【当前建造】</td>
<td align="center">集成系统</td>
<td align="center">系统集成者</td>
<td align="center">集成建造计划、实现模型【连续的建造】</td>
</tr>
<tr>
<td align="center">集成建造计划、体系结构描述【实现模型角度】、设计子系统【已设计】、接口【已设计】</td>
<td align="center">实现子接口</td>
<td align="center">构件工程师</td>
<td align="center">实现子系统【建造完成】、接口【建造完成】</td>
</tr>
<tr>
<td align="center">设计类【已设计】、接口【由设计类提供】</td>
<td align="center">实现类</td>
<td align="center">构件工程师</td>
<td align="center">构件【完成】</td>
</tr>
<tr>
<td align="center">构件【完成】、接口</td>
<td align="center">完成单元测试</td>
<td align="center">构件工程师</td>
<td align="center">构件【已完成单元测试】</td>
</tr>
</tbody></table>
<h3 id="RUP测试活动"><a href="#RUP测试活动" class="headerlink" title="RUP测试活动"></a>RUP测试活动</h3><p>RUP的测试包括内部测试、中间测试和最终测试</p>
<table>
<thead>
<tr>
<th align="center">输入</th>
<th align="center">活动</th>
<th align="center">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">补充需求、用况模型、分析模型、设计模型、实现模型、体系结构的描述</td>
<td align="center">计划测试</td>
<td align="center">测试计划</td>
</tr>
<tr>
<td align="center">补充需求、用况模型、分析模型、设计模型、实现模型、体系结构描述、测试计划</td>
<td align="center">设计测试</td>
<td align="center">测试用况 测试过程</td>
</tr>
<tr>
<td align="center">测试用况、测试过程、实现模型</td>
<td align="center">实现测试</td>
<td align="center">测试构件</td>
</tr>
<tr>
<td align="center">测试用况、测试过程、测试构件、实现模型</td>
<td align="center">执行集成测试</td>
<td align="center">缺陷</td>
</tr>
<tr>
<td align="center">测试用况、测试过程、测试构件、实现模型</td>
<td align="center">执行系统测试</td>
<td align="center">缺陷</td>
</tr>
<tr>
<td align="center">测试用况、测试模型、缺陷</td>
<td align="center">评价测试</td>
<td align="center">测试评价</td>
</tr>
</tbody></table>
<h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><h3 id="软件测试目标与软件测试过程模型"><a href="#软件测试目标与软件测试过程模型" class="headerlink" title="软件测试目标与软件测试过程模型"></a>软件测试目标与软件测试过程模型</h3><h4 id="软件测试及目标"><a href="#软件测试及目标" class="headerlink" title="软件测试及目标"></a>软件测试及目标</h4><p>软件测试的定义为：按照特定规程发现软件错误的过程。其目的是检验它是否满足规定的需求，或清楚了解预期结构与实际结果之间的差异</p>
<h4 id="软件测试与软件调试之间的区别"><a href="#软件测试与软件调试之间的区别" class="headerlink" title="软件测试与软件调试之间的区别"></a>软件测试与软件调试之间的区别</h4><p>软件测试与软件调试相比，在目的、技术和方法等方面都存在很大区别，主要表现在以下几个方面。</p>
<ol>
<li>测试从一个侧面证明程序员的”失败”.调试是为了证明程序员的正确。</li>
<li>测试以已知条件开始，使用预先定义的程序且有预知的结果，不可预见的仅是程序是否通过。调试一般是以不可知的内部条件开始，除统计性调试外，结果是不可预见的。</li>
<li>测试是有计划的，并要进行测试设计。调试是不受时间约束的。</li>
<li>测试是一个发现错误、改正错误、重新测试的过程。调试是一个推理过程。</li>
<li>测试的执行是有规程的。调试的执行往往要求程序员进行必要推理。</li>
<li>测试经常是由独立的测试组在不了解软件设计的条件下完成的。调试必须由了解详细设计的程序员完成。</li>
<li>大多数测试的执行和设计可由工具支持。调试时，程序员能利用的主要工具是调试器。</li>
</ol>
<h4 id="测试过程模型"><a href="#测试过程模型" class="headerlink" title="测试过程模型"></a>测试过程模型</h4><p>软件测试是一个有程序的过程，包括测试设计、测试执行以及测试结果比较。测试过程模型可分为三类：环境模型、被测对象模型和错误模型。</p>
<ol>
<li>环境模型：是对程序运行环境的抽象。程序运行环境又包括支持其运行的硬件、固件和软件，如计算机、终端设备、网卡、操作系统、编译系统、实用程序等。在软件测试过程中，建立环境模型的主要目的是，确定所发现的错误是否为环境造成的。</li>
<li>被测对象模型：该模型是从测试的角度对程序的抽象。为了测试，必须简化程序，形成被测程序的抽象版本、即对象模型。</li>
<li>错误模型：该模型是对程序中的错误及其分类的抽象。在软件测试中，往往需要定义“什么是错误”、“什么是一般性错误”、“什么是严重性错误”等，即要给出“错误模型”。</li>
</ol>
<h3 id="软件测试技术"><a href="#软件测试技术" class="headerlink" title="软件测试技术"></a>软件测试技术</h3><ol>
<li><p>测试覆盖及其他们之间的基本关系<br>软件测试技术大体上可分为两大类：一类是白盒测试技术，又称为结构测试技术，典型的是路径测试技术；另一种是黑盒测试技术，又称为功能测试技术，包括事务处理流程技术、状态测试技术、定义域测试技术等。白盒测试技术依据的是程序的逻辑结构，而黑盒测试技术依据的是软件行为的描述。</p>
</li>
<li><p>路径测试技术的分类</p>
<p> 测试覆盖包括路径覆盖、分支覆盖、条件覆盖与条件组合覆盖。</p>
<ol>
<li>路径覆盖：执行所以有可能穿过程序控制流程的路径。在路径测试中，该度量是最强的，一般是不可实现的。</li>
<li>语句覆盖：至少执行程序中所有语句一次</li>
<li>分支覆盖：至少将程序中的每一个分支执行一次</li>
<li>条件覆盖与条件组合覆盖：条件覆盖是指每个判定中所有的可能的条件的取值至少执行一次；条件组合覆盖是指设计足够的测试用例，使每个判定中所有可能的条件取值组合至少执行一次。</li>
</ol>
<p> 这四种测试覆盖的测试覆盖率由弱到强的顺序是：语句覆盖 &lt; 分支覆盖 &lt; 条件组合覆盖 &lt; 路径覆盖</p>
</li>
<li><p>事务流测试步骤</p>
<p> 事务流测试步骤具体如下。<br> 第一步：获得事务流程图。<br> 第二步：浏览、复审。<br> 第三步：用例设计。<br> 第四步：测试执行。</p>
</li>
<li><p>运用等价类划分技术进行测试的步骤</p>
<p> 具体测试步骤如下。<br> 第一步：建立等价类表<br> 第二步：为有效等价类设计测试用例<br> 第三步：为无效等价类至少设计一个测试用例</p>
</li>
<li><p>边界值分析的使用原则</p>
<p> 边界值分析是一种常用的黑盒测试技术。使用边界值分析在设计测试用例时，可以遵循以下原则。</p>
<ol>
<li>如果某个输入条件规定了输入值的范围，则应该选择正好等于边界值的数据，以及刚刚超过边界值的数据作为测试数据。</li>
<li>如果某个输入条件规定了值的个数，则可用最大个数、最小个数、比最大个数多1、比最小个数少1的数据作为测试数据</li>
<li>根据规格说明的每个输出条件，使用前面的原则1</li>
<li>根据规格说明的每个输出条件，使用前面的原则2</li>
<li>如果程序的规格说明中，输入域或输出域是有序集合，在实践中则经常选取集合的第一个元素、最后一个元素以及典型元素作为测试用例。</li>
<li>如果程序中使用了内部数据结构，则应该选择这个内部数据结构的边界上的值作为测试用例。</li>
<li>分析规格说明，找出其他可能的边界条件。</li>
</ol>
</li>
<li><p>使用因果图生成测试用例的步骤</p>
<p> 因果图技术是通过为判定表的每一列设计一个测试用例，从而实现测试用例的设计与选择的。该方法生成测试用例的基本步骤如下。</p>
<ol>
<li>通过软件规格说明书的分析，找出一个模块的原因和结果，并给每个原因和结果赋予一个标识符</li>
<li>分析原因与结果之间以及原因之间对应的关系，并画出因果图。</li>
<li>在因果图上标识出一些特定的约束或限制条件。</li>
<li>把因果图转换成判定表。</li>
<li>把判定表的每一列拿出来作为依据，设计测试用例。</li>
</ol>
</li>
</ol>
<h3 id="软件测试步骤"><a href="#软件测试步骤" class="headerlink" title="软件测试步骤"></a>软件测试步骤</h3><ol>
<li><p>单元测试<br> 单元测试主要检验软件设计的最小单元—模块。该测试以详细设计文档为指导，测试模块内的重要控制路径。一般来说，单元测试往往采用白盒测试技术。</p>
</li>
<li><p>集成测试<br> 集成测试是软件组装的一个系统化技术，其目标是发现与接口有关的错误，将经过单元测的模块构成一个满足设计要求的软件结构。集成测试集中于模块组合的功能和软件结构检验。集成测试可“自顶向下”地进行，称为自顶向下的集成测试；也可以“自底向上”地进行测试，称为自底向上的集成测试</p>
</li>
<li><p>有效性测试<br> 有效性测试的目标是发现软件实现的功能与需求规格说明书不一致的错误。因此有效性测试通常采用黑盒测试技术。</p>
</li>
<li><p>系统测试<br> 系统测试验证将软件融于更大系统中时整个系统的有效性。</p>
</li>
</ol>
<h2 id="软件生存周期过程与管理"><a href="#软件生存周期过程与管理" class="headerlink" title="软件生存周期过程与管理"></a>软件生存周期过程与管理</h2><h3 id="软件生存周期过程概述"><a href="#软件生存周期过程概述" class="headerlink" title="软件生存周期过程概述"></a>软件生存周期过程概述</h3><ol>
<li><p>过程分类</p>
<p> 按过程主体把软件生存周期过程分为以下几个过程。</p>
<ol>
<li>基本过程：是指那些与软件生产直接相关的活动集。该过程又可分为获取过程、供应过程、开发过程、运行过程和维护过程。</li>
<li>支持过程：是指有关各方按他们的目标所从事的一系列相关支持活动集。该过程又可分为文档过程、配置管理过程、质量保证过程、验证过程、确认过程、联合评审过程、审计过程和问题解决过程。</li>
<li>组织过程：是指那些与软件生产组织有关的活动集。该过程又可分为设计过程、基础设施过程、培训过程和改进过程。</li>
</ol>
</li>
<li><p>系统语境的过程类<br> 系统语境的过程类包含四个过程组，分别是协议过程组、项目过程组、技术过程组和组织上项目使能过程组。</p>
<ol>
<li>协议过程组包含两个过程：获取过程和供应过程。</li>
<li>项目过程组包含七个过程：项目规划过程、项目评价过程、决策管理过程、风险管理过程、配置管理过程、信息管理过程和测量过程。</li>
<li>技术过程组包含11个过程：利益攸关方需求定义过程、系统需求分析过程、系统体系结构设计过程、实现过程、系统集成过程、系统测试过程、软件安装过程、软件接受支持过程、软件运行过程、软件维护过程和软件销毁过程。</li>
<li>组织上使能过程组包含五个过程：生存周期模型管理过程、基础设施管理过程、项目包管理过程、人力资源管理过程和质量管理过程。</li>
</ol>
</li>
<li><p>组织上使能过程的作用。<br> 组织上使能的过程一般来说是组织层面上的工作，为项目的执行提供基本保障。该过程包含五个子过程。</p>
<ol>
<li>生存周期模型管理过程：其任务为过程建立、过程评估、过程改进。</li>
<li>基础设施管理过程：其任务为过程实现、基础设施的建立、基础设施的维护。</li>
<li>项目包管理过程：项目初始化、项目包评估、项目结束处理。</li>
<li>人力资源管理过程：其任务为技能标识、技能开发、技能获取和供给、知识管理。</li>
<li>质量管理过程：其任务为质量管理、质量管理纠正措施。</li>
</ol>
</li>
</ol>
<h3 id="过程描述"><a href="#过程描述" class="headerlink" title="过程描述"></a>过程描述</h3><p>软件验证过程包括两个活动：过程实现和验证。其中验证活动有五个任务：需求验证、设计验证、代码验证，集成验证和文档验证。</p>
<p>一个过程可通过过程意图，期望的结果以及到达过程结果需要执行的活动和任务来描述。对于一个过程的完整技术上的描述，还应包括：达到过程意图和实现过程结果的方法或规程，以及过程和活动文档。</p>
<h3 id="应用说明"><a href="#应用说明" class="headerlink" title="应用说明"></a>应用说明</h3><ol>
<li><p>系统和软件的关系</p>
<p> 在《ISO/IEC系统与软件工程-软件生产周期过程12207-2008》标准中，把软件认为是整个系统的一个组成从部分，执行系统中所确定的功能主要包括三大功能：控制功能、耦合功能以及软件本身提供的功能。由于软件通常存在与一个系统的上下文中，因此软件产品或服务一般可被认为是系统的一个项或称为系统元素。</p>
</li>
<li><p>剪裁过程及应用</p>
<p> 剪裁过程是使剪裁这一标准过程慢速以下特定情况或因素。</p>
<ol>
<li>围绕一个组织，其中该组织在一个协议中使用了这一标准</li>
<li>影响一个项目，其中要求该项目满足一个引用该标准的协议</li>
<li>反映一个组织的需要，其中该组织要供给产品或服务</li>
</ol>
</li>
</ol>
<h3 id="软件生存周期模型"><a href="#软件生存周期模型" class="headerlink" title="软件生存周期模型"></a>软件生存周期模型</h3><ol>
<li><p>瀑布模型</p>
<p> 瀑布模型是将软件生存周期各个活动规定为按固定顺序链接的若干阶段的模型。这一模型规定了个开发阶段的活动：系统需求、软件需求、需求分析、设计、编码、测试和运行，并且自上而下具有相互衔接的固定顺序；还规定了每一个阶段的输入，即工作对象以及本阶段的工作成果，作为输出传送到下一阶段。</p>
<p> 瀑布模型的提出，对软件工程的主要贡献如下。</p>
<ol>
<li>在决定系统怎样做之前存在一个需求阶段，它鼓励对系统做什么进行规约。</li>
<li>在系统构造之前存在一个需求阶段，它鼓励规划系统结构。</li>
<li>在每一阶段结束时进行评审，从而允许获取方和用户的参与。</li>
<li>前一步可以作为下一步被认可的、文档化的基线，并允许基线和配置早期接受控制。</li>
</ol>
<p> 瀑布模型的主要问题是：</p>
<ol>
<li>要求客户能完整、正确和清晰地表达他们的需求；并要求开发人员一开始就要理解这一应用。</li>
<li>由于需求的不稳定性，使设计、编码和测试阶段都可能发生延期；并且当项目接近结束时，出现了大量的集成和测试工作。</li>
<li>在开始的阶段中，很难评估真正的进度状态；并且直到项目结束之前都不能演示系统的能力。</li>
<li>在一个项目的早期开发阶段，过分地强调了基线和里程碑处的文档；并可能需要花费更多的时间用于建立一些用处不大的文档。</li>
</ol>
</li>
<li><p>增量模型</p>
<p> 增量模型是一种非整体开发的模型。软件在该模型中逐渐开发出来，开发出一部分，向用户展示一部分，可让用户及早看到部分软件，及早发现问题。该模型具有较大的灵活性，适合软件需求不明确、设计方案有一定风险的软件项目。</p>
</li>
<li><p>演化模型</p>
<p> 该模型主要针对事先不能完整定义需求的软件开发在用户提出待开发系统的核心需求的基础上，软件开发人员按照这一要求，首先开发一个核心系统并投入运行，以便用户能够有效地提出反馈，即精化系统、增强系统能力的需求；接着，软件开发人员根据用户反馈，实施开发的迭代过程；每一迭代过程均由需求、设计、编码、测试、集成等阶段组成，为整个系统增加一个可定义的，可管理的子集；如果在一次迭代中，有的需求不能满足用户的要求，可在下一次迭代中予以修正。</p>
<p> 主要特征：该模型显式地把需求获取扩展到需求阶段，既为了第二个构造增量，使用了第一个构造增量来精化需求。演化模型在一定程度上可以减少软件开发活动的盲目性。<br>不足之处：在演化模型的使用中，即使很好地理解了需求或设计，也很容易弱化需求分析阶段的工作。</p>
</li>
<li><p>螺旋模型</p>
<p> 螺旋模型将瀑布模型与增量模型结合起来，加入了两种模型均忽略了的风险分析，弥补了这两种模型的不足。因而它是一种风险驱动的模型。螺旋模型将开放过程分为几个螺旋周期，每个螺旋周期大致和瀑布模型相符合。</p>
<p> 螺旋模型关注解决问题的基本步骤，即标识问题，标识一些可选方案，选择一个最佳方案，遵循动作步骤并实施后续工作。其一个突出特征是，在开发的迭代中实际上只有一个迭代过程真正开发了可交付的软件。螺旋模型与演化模型和增量模型相比，同样适用了瀑布模型作为一个嵌入的过程，但螺旋模型所关注的阶段以及它们的活动是不同的。如果项目的开发风险很大或客户不能确定系统需求，在更广泛的意义上来讲，还包括一个系统或系统类型的要求，这时螺旋模型就是一个很好的生存周期模型。</p>
</li>
<li><p>喷泉模型</p>
<p> 喷泉模型体现了软件创建所固有的迭代和无间隙的特征。该模型主要用于支持面向对象技术的软件开发。由于对象概念的引入，使分析、设计、实现之间的表达没有明显间隙。</p>
</li>
</ol>
<h3 id="过程规划与管理"><a href="#过程规划与管理" class="headerlink" title="过程规划与管理"></a>过程规划与管理</h3><ol>
<li><p>创建一个软件项目生存周期过程的步骤</p>
<ol>
<li>选择软件生存周期模型</li>
<li>细化所选择的生存周期模型</li>
<li>为每一个活动或任务标识合适的实例数目</li>
<li>确定活动的时序关系，并检查信息流</li>
<li>建立过程计划的文档</li>
</ol>
</li>
<li><p>软件评估中应考虑的影响因素</p>
<ol>
<li>不管做怎么样的决策，都必须对所采取的的措施对生存周期过程所产生的影响进行评审，以便保证项目获得好的结果。在这一评估中，应考虑以下几方面的影响。<ol>
<li>所要求的的“返工”</li>
<li>资源需求</li>
<li>实施时间</li>
<li>对项目和用户的益处</li>
<li>员工情绪</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="集成化能力成熟度模型（CMMI）"><a href="#集成化能力成熟度模型（CMMI）" class="headerlink" title="集成化能力成熟度模型（CMMI）"></a>集成化能力成熟度模型（CMMI）</h2><h3 id="背景和原理"><a href="#背景和原理" class="headerlink" title="背景和原理"></a>背景和原理</h3><ol>
<li><p>过程改善</p>
<p> 历史过程改善，是指人为设计的一个活动程序，其目的是改进组织的过程性能和成熟度，并改进这一程序的结果</p>
</li>
<li><p>过程域、专用目标和共用目标</p>
<p> 过程域是一个业务域中一束相关的实践，当它们一起得以实现时，就满足被认为对该过程域的改善具有重要作用的一组条件<br> 专用目标是用于描述满足该过程域必须呈现的一些独有特征。经可以用于帮助确定一个过程域是否得以满足。<br> 共用目标用于描述产现制度化的该过程必须呈现的特征，仅用于确定一个过程域是否得以满足。</p>
</li>
</ol>
<h3 id="CMMI的模型部件"><a href="#CMMI的模型部件" class="headerlink" title="CMMI的模型部件"></a>CMMI的模型部件</h3><table>
<thead>
<tr>
<th align="center">过程域类名</th>
<th align="left">包括的过程域</th>
</tr>
</thead>
<tbody><tr>
<td align="center">项目管理类</td>
<td align="left">项目规划<br/>项目监控<br/>定量项目管理<br/>集成项目管理<br/>风险管理<br/>提供方协议管理</td>
</tr>
<tr>
<td align="center">工程类</td>
<td align="left">需求开发<br/>需求管理<br/>技术解决方案<br/>产品集成<br/>确认<br/>验证</td>
</tr>
<tr>
<td align="center">支持类</td>
<td align="left">配置管理<br/>过程和产品质量保证<br/>测量与分析<br/>原因分析与解决<br/>决策分析与解决</td>
</tr>
<tr>
<td align="center">过程管理类</td>
<td align="left">组织过程定义<br/>组织过程性能<br/>组织过程培训<br/>组织过程关注<br/>组织创新与部署</td>
</tr>
</tbody></table>
<h3 id="CMMI的等级"><a href="#CMMI的等级" class="headerlink" title="CMMI的等级"></a>CMMI的等级</h3><ol>
<li><p>能力等级的组成</p>
<p> 能力等级是用来表征组织对一个过程域的改善，是不断改善一个给定过程域的一种手段。在CMMI中，针对每个过程域设定了6个能力等级，即0级：未完成级；1级：已执行级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：待续优化级。</p>
</li>
<li><p>成熟度等级的组成</p>
<p> 在CMMI中，应用于一个组织过程改善的成熟度等级有5个。即1级：初始级；2级：已管理级；3级：已定义级；4级：已定量管理级；5级：持续优化级</p>
</li>
<li><p>能力等级与成熟度等级之间的基本关系</p>
<ol>
<li>能力等级与成熟度等级是互补的关系，两者都是一种过程改善路径，即表征组织对单一过程域的改进。</li>
<li>成熟度等级的路径可使组织针对单一过程域不断改善一组相关过程域，即表征组织对一组过程域的改进。</li>
<li>两种等级的2-5级使用了同样的名字</li>
</ol>
</li>
<li><p>达到各共用目标要实施的共同实践</p>
<p> 达到公用目标2、共用目标3、共用目标4和共用目标5所要实施的共同实践如下表所示</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">所要实施的共用实践</th>
</tr>
</thead>
<tbody><tr>
<td align="center">共用目标2：把过程制度化为一个管理过程</td>
<td align="center">GP2.1 建立组织策略<br/>GP2.2 规划过程<br/>GP2.3 提供资源<br/>GP2.4 指派责任<br/>GP2.5 培训人员<br/>GP2.6 管理配置<br/>GP2.7 标识相关利益方的参与<br/>GP2.8 监控过程<br/>GP2.9 客观地评估符合性<br/>GP2.10 从高层管理的视觉评审状态<br/></td>
</tr>
<tr>
<td align="center">共用目标3：把过程制度化为一个已定义过程</td>
<td align="center">GP3.1 建立一个已定义的过程<br/>GP3.2 收信进信息 所要实施的共用实践</td>
</tr>
<tr>
<td align="center">共用目标4：把过程制度化为一个已定量管理过程</td>
<td align="center">GP4.1 为该过程建立定量目的<br/>GP4.2 使子过程性能达到稳定</td>
</tr>
<tr>
<td align="center">共用目标5：把过程制度化为一个持续优化过程</td>
<td align="center">GP5.1 确保不断进行过程改善<br/>GP5.2 收集问题的根本原因</td>
</tr>
</tbody></table>
<p>完结</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/post/fe816c3c.html</url>
    <content><![CDATA[<p>关于建造者模式的个人理解<br>建造者模式适用于一个复杂的对象,但是他有多种构建方式,而且每种构建方式都不简单,写在一起不方便维护.建造者模式可以帮助分离对象和它的构建,使得调用相同的一个方法可以创建不同的表示.</p>
<span id="more"></span>
<p>比如说 蛋糕 对象,使用者需要通过调用一个方法,只要传入不同的参数,就可以返回草莓蛋糕,黑森林蛋糕,芝士蛋糕(懒得写了)等.</p>
<p>举蛋糕的例子:<br>怎么做蛋糕</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">	[super viewDidLoad];</span><br><span class="line">	&#x2F;&#x2F; 想要什么蛋糕就只要实例化这个蛋糕(下订单)</span><br><span class="line">	CakeBulider *bulider &#x3D; [[StraberryCakeBulider alloc] init];	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 然后让蛋糕店去做蛋糕</span><br><span class="line">	Cake *cake &#x3D; [CakeStore createCake:bulider];</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 看看蛋糕长什么样子</span><br><span class="line">	NSLog(@&quot;%@&quot;,cake.description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cake.m 蛋糕实体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface Cake : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign)NSInteger *self.scream;&#x2F;&#x2F; 奶油分量</span><br><span class="line">@property (nonatomic, copy)NSString *self.ingredients;&#x2F;&#x2F; 配料</span><br><span class="line">@property (nonatomic, assign)NSInteger *self.bakeTime;&#x2F;&#x2F; 烘焙时间</span><br><span class="line">&#x2F;&#x2F; 还有等等好多好多参数，但是我只关心这些</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Cake</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 让它做自我介绍</span><br><span class="line">- (NSString *)description&#123;</span><br><span class="line">   return [NSString stringWithFormat:@&quot;我是一个蛋糕:奶油分量%zd 配料%@ 烘焙时间是:%zd&quot;,self.scream,self.ingredients,self.bakeTime];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CakeStore.m 卖蛋糕的店铺</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (Cake *)createCake:(CakeBulider *)bulider</span><br><span class="line">&#123;</span><br><span class="line">	Cake *cake &#x3D; [bulider bakeCake];</span><br><span class="line">	return cake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CakeBulider.m 蛋糕自动烘焙机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (Cake *)bakeCake</span><br><span class="line">&#123;</span><br><span class="line">	Cake *cake &#x3D; [[Cake alloc] init];</span><br><span class="line">	cake.scream &#x3D; self.scream;</span><br><span class="line">	cake.ingredients &#x3D; self.ingredients;</span><br><span class="line">	cake.bakeTime &#x3D; self.bakeTime;</span><br><span class="line">	retrn cake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StrawberryCakeBulider.m 草莓蛋糕</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface StrawberryCakeBulider():Cake</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.scream &#x3D; 10;</span><br><span class="line">        self.ingredients &#x3D; @&quot;strawberry&quot;;</span><br><span class="line">        self.bakeTime &#x3D; 10;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BlackForestCakeBulider.m 黑森林蛋糕</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface BlackForestCakeBulider():Cake</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">	self &#x3D; [super init];</span><br><span class="line">	if(self)&#123;</span><br><span class="line">		self.scream &#x3D; 11;</span><br><span class="line">		self.ingredients &#x3D; @&quot;cholocate&quot;;</span><br><span class="line">		self.bakeTime &#x3D; 5;</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(话说大半夜的写蛋糕真的好吗)<br>其实QCCloud那个项目说不定就会用到这个模式,所以在这里稍微复习一下,回忆之前的知识.</p>
<p>(明天再去复习别的即将会用到的设计模式)</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>基于DKHTTPTool的业务层设计_尝试版</title>
    <url>/post/838ddddd.html</url>
    <content><![CDATA[<p>基于DKHTTPTool的业务层设计_尝试版</p>
<p>由于是尝试版,所以这里只是简单讲下思路.</p>
<span id="more"></span>

<ul>
<li><p>首先 DKHTTPTool提供了缓存策略的选择,让方法调用和缓存可以进行统一的处理<br>然后业务层进行缓存策略的选择, 但由于 ViewModel实际需要的是一个模型(数组) ,而 <code>DKHTTPTool</code>返回的是一个 <code>DKResponse</code> 对象,所以业务层除了进行缓存策略的选择外,还需要进行对 <code>DKResponse</code>的处理.</p>
</li>
<li><p>DKResponse 里面有一个成员属性result用来储存后台返回的 json 数据,所以业务层(以下称 Service)需要去对这个属性值进行封装 , 封装的方法我们选择使用 MJExtension 的方法就可以了</p>
</li>
<li><p>对于一些数据量比较大,数据结构比较复杂的模型, <code>MJExtension</code> 处理之后应该还需要存入数据库,便于日后的筛选,排序等操作.那么,此时逻辑就出现了变化</p>
<ul>
<li>对于简单的数据,处理流程是 VM调用Service方法 -&gt; Service 调用 HTTP方法 -&gt; 返回原始数据 -&gt; <code>MJExtension</code>处理数据 -&gt; 返回给 VM</li>
<li>对于复杂的数据,处理流程是 VM调用Service方法 -&gt; Service 调用 HTTP方法 -&gt; 返回原始数据 -&gt; <code>MJExtension</code>处理数据 -&gt; 插入 or 更新 数据库表 - -&gt; 同时返回处理好的数据给 VM</li>
</ul>
</li>
<li><p>当然第一种是最好处理的,只要套一层方法就可以把数组返回回去了(如果要进行比较简单的数据筛选操作,用 <code>NSPredicate</code>,排序用<code>NSSortDescriptor</code>也是可以实现的),但是对于第二种方法,那就需要我们新增一个 Service基类去统一处理取数据库数据的操作,包括条件筛选,排序 ,去重的等等的操作</p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>用Swift的框架Vapor写服务端初体验</title>
    <url>/post/73291e5a.html</url>
    <content><![CDATA[<p>咦? 用Swift写后端? 一开始听到的时候懵逼了一秒,一秒自后想了想感觉也没毛病,那就试试看咯.(没看WWDC的后果)</p>
<span id="more"></span>

<h2 id="安装Vapor"><a href="#安装Vapor" class="headerlink" title="安装Vapor"></a>安装Vapor</h2><p><code>curl -sL toolbox.vapor.sh | bash</code></p>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p><code>vapor new Hello --template=light</code></p>
<p><code>--template=light</code> 意思是使用light-template模板,如果不指定模板的话默认使用base-template模板</p>
<p>下载依赖并编译项目<br><code>vapor build</code></p>
<p>50多M的包,好久…</p>
<p>配置服务器<br>创建Config文件夹,新建servers.json文件, 指定host地址和端口号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;http&quot;: &#123;</span><br><span class="line">    &quot;host&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;port&quot;: 8000</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>0.0.0.0</code> 和 <code>127.0.0.1</code> 都表示本机，使用 <code>0.0.0.0</code> 的原因是，一个机器可能有多个 IP 地址，<code>0.0.0.0</code> 表示监听每个 IP <code>8000</code> 端口收到的请求。</p>
<p><code>127.0.0.1</code> 则表示只接受本机发给本机的请求，从网络上其他电脑发过来的请求，不论是请求的哪个 IP，都是不被处理的。</p>
<h2 id="打包成一个XCode项目"><a href="#打包成一个XCode项目" class="headerlink" title="打包成一个XCode项目"></a>打包成一个XCode项目</h2><p><code>vapor xcode -y</code> 这样子打包之后就会自动打开了</p>
<h2 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h2><p><code>vapor run</code> 或者在XCode运行</p>
<p>看到了控制台输出了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No command supplied, defaulting to serve...</span><br><span class="line">No preparations.</span><br><span class="line">Server &#39;http&#39; starting at 0.0.0.0:8000</span><br></pre></td></tr></table></figure>

<p>就可以了</p>
<p>如果说什么<code>Can not bind to xxxx</code> 就应该是端口占用的问题,可以用<code>lsof -i tcp:端口号</code> 和 <code>kill -9</code> 端口号解决这个问题</p>
<p>如果你在浏览器输入<code>http://localhost:8000</code>可以看到以下信息就证明服务器启动成功了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Request  </span><br><span class="line">- GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">- Headers:</span><br><span class="line">    Host: 0.0.0.0:8000</span><br><span class="line">    Upgrade-Insecure-Requests: 1</span><br><span class="line">    Connection: keep-alive</span><br><span class="line">    User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;57.0.2987.98 Safari&#x2F;537.36</span><br><span class="line">    Accept-Language: en-US,en;q&#x3D;0.8,zh-CN;q&#x3D;0.6,zh;q&#x3D;0.4,zh-TW;q&#x3D;0.2</span><br><span class="line">    Accept-Encoding: gzip, deflate, sdch</span><br><span class="line">    Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">- Body:</span><br></pre></td></tr></table></figure>

<p>会出现这串东西是因为他执行了<code>Sources/App/main.swift</code>的内容,把请求体返回回来.</p>
<p>修改<code>Sources/App/main.swift</code><br>把文件改成这样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vapor</span><br><span class="line"></span><br><span class="line">let drop &#x3D; Droplet()</span><br><span class="line"></span><br><span class="line">drop.get &#123; _ in</span><br><span class="line">    return try JSON(node: [</span><br><span class="line">            &quot;message&quot;:&quot;Hello Vapor&quot;</span><br><span class="line">        ])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drop.get(&quot;Hello&quot;,&quot;There&quot;) &#123; request in</span><br><span class="line">    return try JSON (node:[</span><br><span class="line">            &quot;message&quot;:&quot;Hello There&quot;</span><br><span class="line">        ])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drop.get(&quot;TEST&quot;) &#123; request in</span><br><span class="line">    return try JSON (node:[</span><br><span class="line">            &quot;message&quot;:&quot;Hello Test&quot;</span><br><span class="line">        ])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drop.run()</span><br></pre></td></tr></table></figure>

<p>然后我们使用Postman测试一下三个地址</p>
<p><code>http://localhost:8000/</code></p>
<p><img src="https://ooo.0o0.ooo/2017/03/16/58c9fe803b931.png" alt="WX20170316-105233@2x.png"></p>
<p>`<a href="http://localhost:8000/Hello/There">http://localhost:8000/Hello/There</a></p>
<p><img src="https://ooo.0o0.ooo/2017/03/16/58c9fe7f92afc.png" alt="WX20170316-105315@2x.png"></p>
<p><code>http://localhost:8000/TEST</code></p>
<p><img src="https://ooo.0o0.ooo/2017/03/16/58c9fe7fca399.png" alt="WX20170316-105336@2x.png"></p>
<p>接下来试试接受参数并返回</p>
<p>继续在<code>drop.run()</code> 上面补充</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop.post(&quot;post&quot;) &#123; request in</span><br><span class="line">    guard let name &#x3D; request.data[&quot;name&quot;]?.string else &#123;</span><br><span class="line">        throw Abort.badRequest</span><br><span class="line">    &#125;</span><br><span class="line">    return try JSON(node: [</span><br><span class="line">        &quot;name&quot;: &quot;Hello \(name)!&quot;</span><br><span class="line">        ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>guard近似的看做是Assert，但是你可以优雅的退出而非崩溃。</p>
</blockquote>
<p>判断如果没有接收到’name’参数的话就会抛出异常Invalid request,有的话就返回Hello + 参数值 + !</p>
<p>测试一下</p>
<p><img src="https://ooo.0o0.ooo/2017/03/16/58ca001f306a5.png" alt="WX20170316-110133@2x.png"></p>
<p>部署服务器<br>Vapor支持Heroku,Ubuntu,Digital Ocean,AWS等等服务器,具体怎么做我还没试过,有时间再去试试看</p>
<p>为什么要用Swift写服务器?<br>额,看了一下资料,也没发现有谁说这东西有什么特别突出的优点,不过没试过,觉得挺新鲜,就试试嘛.</p>
<blockquote>
<p>学习资料 :</p>
</blockquote>
<blockquote>
<p><a href="http://www.jianshu.com/p/3fc28570d951">服务端 Swift - Vapor 篇 （一）</a></p>
</blockquote>
<blockquote>
<p><a href="http://tips.producter.io/yong-swift-de-kuang-jia-vapor-xie-fu-wu-qi-zhe-shi-er-zen-yao-yang/">用 Swift 的框架 Vapor 写服务器这事儿怎么样？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>用flow.ci做iOS的持续化集成</title>
    <url>/post/2281692e.html</url>
    <content><![CDATA[<p>听说flow.ci上线公测了,赶紧拿着一把限时免费资格玩一玩体验一下.</p>
<span id="more"></span>

<p>结论: 一套下来行云流水,配置上基本没啥大问题,感觉还是挺好用的.可以支持简单的项目</p>
<p>官方中文文档在这里</p>
<p>里面讲的相当详细,在这里我就讲点注意点就好</p>
<ol>
<li>如果你想达到的功能除了编译打包外,还想上传到fir,并且想拿最新的git commit 信息作为fir版本更新备注,那么你的工作流可以这么配<br><img src="https://github.com/Arc-lin/BlogImage/blob/master/1012.png?raw=true"></li>
<li>‘自定义脚本’里面写的是export CHANGE_LOG=$(git log –pretty=format:”%s” -1 $describe) 然后 fir.im 上传插件 中 FIR_CHANGELOG就直接写$CHANGE_LOG这样子就可以做到拿最新的git commit 信息作为fir版本更新备注, $FIR_APP_PATH里面就直接写$FIR_APP_PATH就好了</li>
<li>‘缓存’那里启用一下安装速度会快些</li>
<li>如果你的git的根目录不是你项目的根目录的话,你要添加一个’环境变量’(就像上面的图),详情看这里</li>
<li>‘编译’那里的’Workspace’,填的时候记得把’.xcworkspace’后缀带上</li>
<li>‘编译’那里的’Workspace’和’Project’两个选一个填,不能一起填</li>
<li>大概就这么多,以后我遇到啥再补充</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Flow.ci</tag>
      </tags>
  </entry>
  <entry>
    <title>简易架构设计</title>
    <url>/post/4948514e.html</url>
    <content><![CDATA[<h3 id="继承关系："><a href="#继承关系：" class="headerlink" title="继承关系："></a>继承关系：</h3><ul>
<li><p>UIViewController</p>
<ul>
<li><p>DKViewContrller</p>
<ul>
<li><p>DKLoginBaseViewCotroller</p>
<ul>
<li>DKLoginViewController</li>
<li>DKRegisterViewController</li>
<li>DKFoundPswViewController</li>
</ul>
</li>
<li><p>DKModuleABaseViewCotroller</p>
<ul>
<li>DKAViewController</li>
</ul>
</li>
<li><p>DKModuleBBaseViewCotroller</p>
<ul>
<li>DKBViewController</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="常量配置"><a href="#常量配置" class="headerlink" title="常量配置"></a>常量配置</h3><ul>
<li><p>DKLoginBaseViewController : DKLoginConfig.h</p>
</li>
<li><p>DKLoginConfig 里面定义常量</p>
<p> 相关的常量使用UIKIT_EXTERN / FOUNDATION_EXTERA，并且UIKIT_EXTERN / FOUNDATION_EXTERA建议写在模块外的全局DKConfig.h(会在pch里引入)</p>
</li>
<li><p>ps: pch建议只写宏，宏之外的其他东西，写在DKConfig.h里面，然后导入pch</p>
</li>
<li><p>DKModuelABaseViewController : DKModuelAConfig.h</p>
</li>
</ul>
<h3 id="调用-import"><a href="#调用-import" class="headerlink" title="调用(import)"></a>调用(import)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DKHomeViewController</span><br><span class="line">    |-DKLoginViewController</span><br><span class="line">        |-DKRegisterViewController</span><br><span class="line">        |-DKLoginBaseViewController</span><br><span class="line">            |—DKViewController</span><br><span class="line">                |_ UIKit</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>组件化方案之强业务组件的设计</title>
    <url>/post/be708589.html</url>
    <content><![CDATA[<p>本文简述组件化方案之强业务组件的设计</p>
<span id="more"></span>

<h3 id="如何定义强业务组件"><a href="#如何定义强业务组件" class="headerlink" title="如何定义强业务组件"></a>如何定义强业务组件</h3><p>涉及到具体业务需求，能单独完成App某个功能点（主要feature）的组件</p>
<h3 id="需要符合什么要求"><a href="#需要符合什么要求" class="headerlink" title="需要符合什么要求"></a>需要符合什么要求</h3><p>UI层和逻辑层的绝对独立</p>
<p>需求内容完整</p>
<p>可拓展，可维护</p>
<p>可独立配置UI（UI只可重写、不可修改）</p>
<p>逻辑层不可配置</p>
<p>代码内容清晰明确</p>
<h3 id="接下来开始讲故事"><a href="#接下来开始讲故事" class="headerlink" title="接下来开始讲故事"></a>接下来开始讲故事</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>随着业务发展，灵机大师说的咨询室模块需要抽离到各个App当中使用，但是由于不同App的网关配置和UI配置都不一样，造成了代码不可以完全进行复用，所以需要对原有代码重新设计。</p>
<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>如何设计组件是个比较复杂的问题</p>
<p>首先参考其他第三方IM提供商的Demo，基本上要用他们的UI的话就只能全套用，提供的配置项比较有限，自己改里面的东西成本很大，也不方便。</p>
<p>然后考虑自己如何修改原有代码</p>
<p>参考原有MVVM架构的话，在View和ViewModel之间是一个强耦合的状态，View会直接依赖ViewModel，如果使用方需要定制UI则会十分懵逼，不明确自己的View需要做什么才能配合ViewModel的使用。但这并不意味着MVVM就不能用，在组件初期，为了快速成型，必须沿用之前的设计模式。</p>
<p>接下来思考第二种方案，一种能够高度分离职责的架构，那便是VIPER。确实，在VIPER的设计思想中，单一职责原则体现得很好：Presenter寻找实现了InputProtocol的ViewController并给予数据，ViewController内的操作事件则通过实现了OutputProtocol的Presenter去执行，Presenter内部又通过Interactor和wireframe去实现数据获取和路由的交互，这种面相协议的开发也十分契合我们的需求，协议的方式能够很明确的让使用者知道他要做什么和他需要给予什么。但是VIPER的结构比较复杂比较适合后期在发展，目前还是以MVVM为主比较好。</p>
<p>那么如何改进我们现有的MVVM模式？这里我们就要将VIPER的精髓，面向协议和依赖注入抽离出来。</p>
<h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>首先先说明什么叫做依赖注入</p>
<p>比如AController跳转到BController,那么这时候BController就需要在AController内部进行实例化，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation AController : UIViewController</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (void)jump </span><br><span class="line">&#123;</span><br><span class="line">	BController *bController &#x3D; [[BController alloc] init];</span><br><span class="line">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这么做的话，当AController被封装成组件之后，BController的配置将会被限制，外部无法改变BController任何细节，所以我们 ** 稍 加 改 进 **</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation AController : UIViewController</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCreateBlock:(UIViewController *(^)(void))createBViewControllerBlock &#123;</span><br><span class="line">	....</span><br><span class="line">	self.createBViewControllerBlock &#x3D; createBViewControllerBlock;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jump </span><br><span class="line">&#123;</span><br><span class="line">	UIViewController *bController &#x3D; self.createBViewControllerBlock();</span><br><span class="line">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[AController alloc] initWithCreateBlock:UIViewController* ^&#123;</span><br><span class="line">	BController *bController &#x3D; [[BController alloc] initWithTitle:@&quot;xxx&quot;];</span><br><span class="line">	return bController;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>将BController的创建通过Block暴露出来，AController内部不关心BController是如何被创建的，那么AController对BController的依赖将通过外部的Block进行注入。</p>
<p>这，就是依赖注入。</p>
<p>当然这是最简单的依赖注入，无法满足我们复杂的需求，所以有时候我们需要使用第三方框架，如<code>Objection</code>和<code>Typhoon</code></p>
<h4 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h4><p>依赖倒置是是六个设计原则之一。依赖倒置意味着实现依赖于抽象，抽象不依赖实现。</p>
<p>举个例子</p>
<p>当你需要买一杯饮料，你不需要到具体哪家店买，反正任意一个便利店都有饮料卖，所以你需要的并不是获得美宜佳的地址或者711的地址，你需要的只是一个“卖饮料的店”，这是一个抽象的概念，这样子就是依赖被倒置了，本来是你去寻找美宜佳，现在变成拥有“卖饮料”功能的店去满足你。</p>
<p>在iOS中，抽象是通过代理体现的</p>
<p>同样的，我们再来看看刚刚的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation AController : UIViewController</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (void)jump </span><br><span class="line">&#123;</span><br><span class="line">	BController *bController &#x3D; [[BController alloc] init];</span><br><span class="line">    [self.navigationController pushViewController:bController animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>根据依赖倒置原则进行改造</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@interface AController()</span><br><span class="line"></span><br><span class="line">@property(weak) id&lt;BControllerProtocol&gt; bViewController;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AController : UIViewController</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">- (void)jump </span><br><span class="line">&#123;</span><br><span class="line">    [self.navigationController pushViewController:self.bViewController animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AViewController *aViewController &#x3D; [[AViewController alloc] init];</span><br><span class="line">id&lt;BControllerProtocol&gt; bViewController &#x3D; [[BViewController alloc] init];</span><br><span class="line">aViewController.bViewController &#x3D; bViewController;</span><br></pre></td></tr></table></figure>


<h4 id="依赖注入-依赖倒置"><a href="#依赖注入-依赖倒置" class="headerlink" title="依赖注入+依赖倒置"></a>依赖注入+依赖倒置</h4><p>将协议和注入的模式进行结合，仿照上面的代码，估计就是这样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[AController alloc] initWithCreateBlock:UIViewController&lt;BControllerProtocol&gt;* ^&#123;</span><br><span class="line">	id&lt;BControllerProtocol&gt; bController &#x3D; [[BController alloc] initWithTitle:@&quot;xxx&quot;];</span><br><span class="line">	return bController;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>当然 这种模式只是个例子，给大家一种具体的观感</p>
<p>实际上在编码的时候，一个控制器往往有很多依赖，这里分为<code>可注入依赖</code>和<code>不可注入依赖</code></p>
<p>可注入的依赖往往是一些可以配置的依赖，使用者通过将自己自定义的配置注入，覆盖原有的默认依赖，达到配置内部样式的效果</p>
<p>反之，不可注入的依赖就会是代码中固定的耦合项目，合理的耦合以不至于组件产生过多未知问题。</p>
<p>刚刚说到一些依赖注入的第三方框架<code>Objection</code>和<code>Typhoon</code>，这个之后再详细介绍，这里简单说明一下，当使用方需要使用自定义类注入组件的时候，都是需要依赖这两种框架，不能只由组件内部依赖，所以为了避免不必要的学习成本，暂时先不使用，后面如果拓展开了使用方法，可能会修改使用，我们这里先用一些理解起来比较简单但是操作起来可能比较麻烦的注入方式。</p>
<p>首先我们这里我们新增一个单例用于注入，通过反射机制实例化自定义的对象，然后进行注入。</p>
<p>当然这个对象是需要遵循我们对应的协议的。</p>
<p>协议我们按照VIPIER的规范，分为两种<code>InputProtocol</code>和<code>OutputProtocol</code></p>
<p><code>InputProtocol</code>包括控制器需要的外部参数<br><code>OutputProtocol</code>包括控制器的回调参数</p>
<p>按照目前咨询室的设计模式看来，是由三个控制器（一个父控制器和两个子控制器）构成，他们分别会有自己的<code>InputProtocol</code>和<code>OutputProtocol</code>，如果业务端需要自己实现UI则自己实现协议然后进行注入即可。</p>
<p>待续</p>
<p>有空继续写</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/post/df879792.html</url>
    <content><![CDATA[<p>其实组合模式就是为了便于管理一个树形结构（抽象的）的对象，能让客户端统一处理这个对象的一种设计模式</p>
<span id="more"></span>

<p>举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">帽子</span><br><span class="line">  |_贝雷帽</span><br><span class="line">  |_鸭舌帽</span><br><span class="line">      |_黑色鸭舌</span><br><span class="line">衣服</span><br><span class="line">  |_衬衫</span><br><span class="line">      |_蓝色衬衫</span><br><span class="line">      |_白色衬衫</span><br><span class="line">  |_T恤</span><br><span class="line">裤子</span><br><span class="line">  |_牛仔裤</span><br><span class="line">      |_蓝色牛仔裤</span><br><span class="line">  |_短裤</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么这时候如果客户端要拿到一顶黑色鸭舌帽，一件白色衬衫和一条蓝色牛仔裤，那么应该怎么取到呢？或者想从对象中删除这些东西呢？</p>
<p>首先我们需要有一个衣柜</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Wardrobe *wardrobe &#x3D; [[Wardrobe alloc] init];</span><br></pre></td></tr></table></figure>

<p>然后为其我们添加子节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[wardrobe addDress:hat];</span><br><span class="line">[wardrobe addDress:clothes];</span><br><span class="line">[wardrobe addDress:trousers];</span><br></pre></td></tr></table></figure>

<p>那 <code>hat</code> 和 <code>clothes</code> 和 <code>trousers</code> 怎么来 (以 hat 举例)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hat *hat &#x3D; [[Hat alloc] init];</span><br><span class="line">Hat *yashe_hat &#x3D; [[Hat alloc] initWithType:@&quot;Yashe&quot;];</span><br><span class="line">Hat *beilei_hat &#x3D; [[Hat alloc] initWithType:@&quot;Beilei&quot;];</span><br><span class="line">Hat *black_hat &#x3D; [[Hat alloc] initWithColor:@&quot;Black Yashe&quot;];</span><br><span class="line"></span><br><span class="line">[hat addDress:beilei_hat];</span><br><span class="line"></span><br><span class="line">[yashe_hat addDress:black_hat];</span><br><span class="line">[hat addDress:yashe_hat];</span><br></pre></td></tr></table></figure>

<p>现在我们需要注意一下<br>· 上面的三个对象，必须遵守一个协议，我们姑且命名为 DressProtocol (服饰）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@protocol DressProtocol</span><br><span class="line"></span><br><span class="line">- (void)addDress:(id&lt;DressProtocol&gt;)dress;</span><br><span class="line">- (void)removeDress:(id&lt;DressProtocol&gt;)dress;</span><br><span class="line"></span><br><span class="line">- (void)showDresses;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面经过一轮 AddDress:之后，帽子那块应该就会生成这样子的结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">衣橱</span><br><span class="line">|_帽子</span><br><span class="line">  |_贝雷帽</span><br><span class="line">  |_鸭舌帽</span><br><span class="line">    |_黑色鸭舌帽</span><br></pre></td></tr></table></figure>
<p>然后我们来看看里面代理方法的实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)addDress:(id&lt;DressProtocol&gt;)dress</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; 有一个数组成员属性用来储存这些对象</span><br><span class="line">	[_child addObject:dress];</span><br><span class="line">&#125;</span><br><span class="line">- (void)removeDress:(id&lt;DressProtocol&gt;)dress</span><br><span class="line">&#123;</span><br><span class="line">	[_child removeObject:dress];</span><br><span class="line">&#125;</span><br><span class="line">- (void)showDresses</span><br><span class="line">&#123;</span><br><span class="line">	NSLog(@&quot;%@&quot;,_child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺便看看 Init的时候我们使用的两个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (instancetype)initWithType:(NSString *)type</span><br><span class="line">&#123;</span><br><span class="line">	if(self &#x3D; [super init])&#123;</span><br><span class="line">		self.type &#x3D; type;</span><br><span class="line">		self.color &#x3D; nil;</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithColor:(NSString *)color</span><br><span class="line">&#123;</span><br><span class="line">	if(self &#x3D; [super init])&#123;</span><br><span class="line">		self.type &#x3D; nil;</span><br><span class="line">		self.color &#x3D; color;</span><br><span class="line">	&#125;</span><br><span class="line">	return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>大概就是这种感觉</p>
<p>如果不是很清楚的话，可以想想 <code>UIView</code>的 <code>addSubView:</code><br><code>addSubView:</code>就是把一个新的 View加入到子节点，如果 subView 还有 subView，那就在 subView 上面继续添加 <code>addSubView:</code> 最后我们打印 subViews的时候就可以得到该View的所有的subview</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>给 APP添加外部文件导入功能</title>
    <url>/post/d2301e87.html</url>
    <content><![CDATA[<p>给 APP添加外部文件导入功能</p>
<p><img src="https://raw.githubusercontent.com/Arc-lin/BlogImage/master/333.jpeg"></p>
<span id="more"></span>

<p>修改 info.plist(这里是允许所有文件类型,如果要特定某种类型的文件,那么就得添加多个CFBundleTypeName CFBundleTypeRole LSHandlerRank LSItemContentTypes 具体见百度)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;key&gt;CFBundleDocumentTypes&lt;&#x2F;key&gt;</span><br><span class="line">   &lt;array&gt;</span><br><span class="line">       &lt;dict&gt;</span><br><span class="line">           &lt;key&gt;CFBundleTypeIconFiles&lt;&#x2F;key&gt;</span><br><span class="line">           &lt;array&#x2F;&gt;</span><br><span class="line">           &lt;key&gt;CFBundleTypeName&lt;&#x2F;key&gt;</span><br><span class="line">           &lt;string&gt;data&lt;&#x2F;string&gt;</span><br><span class="line">           &lt;key&gt;CFBundleTypeRole&lt;&#x2F;key&gt;</span><br><span class="line">           &lt;string&gt;Viewer&lt;&#x2F;string&gt;</span><br><span class="line">           &lt;key&gt;LSHandlerRank&lt;&#x2F;key&gt;</span><br><span class="line">           &lt;string&gt;Default&lt;&#x2F;string&gt;</span><br><span class="line">           &lt;key&gt;LSItemContentTypes&lt;&#x2F;key&gt;</span><br><span class="line">           &lt;array&gt;</span><br><span class="line">               &lt;string&gt;public.data&lt;&#x2F;string&gt;</span><br><span class="line">           &lt;&#x2F;array&gt;</span><br><span class="line">       &lt;&#x2F;dict&gt;</span><br><span class="line">   &lt;&#x2F;array&gt;</span><br></pre></td></tr></table></figure>
<p>APPDelegate.h</p>
<p>获取到根控制器,执行复制到Document文件夹方法<br>源路径:url.path</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (strong, nonatomic) NSURL *sharedURL;</span><br><span class="line"></span><br><span class="line">- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options</span><br><span class="line">&#123;</span><br><span class="line">	if(url.fileURL)&#123;</span><br><span class="line">        self.sharedURL &#x3D; url;</span><br><span class="line">        UIViewController *vc &#x3D; self.window.rootViewController;</span><br><span class="line">        if ([vc isKindOfClass:[UINavigationController class]]) &#123;</span><br><span class="line">            UINavigationController * nav &#x3D; (UINavigationController *)self.window.rootViewController;</span><br><span class="line">            UIViewController *topVC &#x3D; nav.childViewControllers.firstObject;</span><br><span class="line">            if ([topVC respondsToSelector:@selector(handleSharedFile)]) &#123;</span><br><span class="line">                [topVC performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if ([vc respondsToSelector:@selector(handleSharedFile)]) &#123;</span><br><span class="line">                [vc performSelectorOnMainThread:@selector(handleSharedFile) withObject:nil waitUntilDone:NO];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根控制器方法(头文件需要声明方法)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)handleSharedFile &#123;</span><br><span class="line">    AppDelegate *app &#x3D; (AppDelegate *)[UIApplication sharedApplication].delegate;</span><br><span class="line">    if (app.sharedURL !&#x3D; nil) &#123;</span><br><span class="line">        self.sharedURL &#x3D; [app.sharedURL copy];</span><br><span class="line">        app.sharedURL &#x3D; nil;</span><br><span class="line">        [self saveSharedFile:self.sharedURL];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)saveSharedFile:(NSURL *)url &#123;</span><br><span class="line">    MBProgressHUD *hud &#x3D; [MBProgressHUD showButtonHUDAddedTo:self.view animated:YES];</span><br><span class="line">    DKFile *file &#x3D; [[DKFile alloc] init];</span><br><span class="line">    file.fullPath &#x3D; url.path;</span><br><span class="line">    file.fileName &#x3D; url.path.lastPathComponent;</span><br><span class="line">    [[DKFileManager sharedInstance] copyItemsOfSelectFiles:@[file] fromStorage:DKFileStorageTypeInternal toStorage:DKFileStorageTypeInternal toPath:[DKFileManager defaultPath:kShareDirectory storage:DKFileStorageTypeInternal] progressHUD:hud complete:^&#123;</span><br><span class="line">        [SVProgressHUD showSuccessWithStatus:@&quot;已保存到 iPhone -&gt; SharedFiles&quot;];</span><br><span class="line">    &#125; failure:^(NSError *errors) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层方法封装</title>
    <url>/post/3d9cee8d.html</url>
    <content><![CDATA[<p>网络层的方法封装</p>
<span id="more"></span>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>集成AFNetworking</li>
<li>集成MJExtension</li>
<li>统一回调</li>
<li>方便顶层调用</li>
<li>统一错误处理</li>
<li>适应接口设计</li>
</ul>
<h2 id="设计（以POST和退出登录接口举例）"><a href="#设计（以POST和退出登录接口举例）" class="headerlink" title="设计（以POST和退出登录接口举例）"></a>设计（以POST和退出登录接口举例）</h2><ol>
<li>接口设计<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef void (^DKResponseBlock)(DKResponse *response);</span><br><span class="line"></span><br><span class="line">+ (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters success:(nonnull DKResponseBlock)callBack;</span><br><span class="line">1.1 DKResponse 回调模型设计（根据接口进行设计）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> #import &lt;Foundation&#x2F;Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface DKResponse : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;** state *&#x2F;</span><br><span class="line">@property (nonatomic,copy) NSString *state;</span><br><span class="line"></span><br><span class="line">&#x2F;** result *&#x2F;</span><br><span class="line">@property (nonatomic,copy) NSDictionary *result;</span><br><span class="line"></span><br><span class="line">&#x2F;** message *&#x2F;</span><br><span class="line">@property (nonatomic,copy) NSString *message;</span><br><span class="line"></span><br><span class="line">&#x2F;** 纯数据 *&#x2F;</span><br><span class="line">@property (nonatomic, strong) id rawData;</span><br><span class="line"></span><br><span class="line">&#x2F;** error *&#x2F;</span><br><span class="line">@property (nonatomic,copy) NSError *error;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li>
<li>底层方法实现<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(DKConfiguration.h 或者使用 plist)</span><br><span class="line"> static NSString *kDKTimeoutInterval &#x3D; 10.0f;</span><br><span class="line"> static NSString *kDKSuccessMessage &#x3D; @&quot;success&quot;;</span><br><span class="line"></span><br><span class="line">+ (void)POST:(nonnull NSString *)URLString parameters:(nullable id)parameters callBack:(nonnull DKResponseBlock)callBack &#123;</span><br><span class="line">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];</span><br><span class="line">    mgr.requestSerializer.timeoutInterval &#x3D; kDKTimeoutInterval;</span><br><span class="line">    [mgr POST:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject]; &#x2F;&#x2F; 转为响应信息模型</span><br><span class="line">        resp.rawData &#x3D; responseObject; &#x2F;&#x2F; 储存源数据</span><br><span class="line">        if(callBack)&#123;</span><br><span class="line">            if (![resp.message isEqualToString:kDKSuccessMessage]) &#123; &#x2F;&#x2F; 判断是否是成功的</span><br><span class="line">                resp.error &#x3D; [NSError errorWithDomain:@&quot;dankal.cn&quot; code:[resp.state integerValue] userInfo:@&#123;@&quot;message&quot;:resp.message&#125;]; &#x2F;&#x2F; 生成错误对象</span><br><span class="line">                callBack(resp);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                callBack(resp); &#x2F;&#x2F; 没有错误直接返回</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">        DKLog(@&quot;%@&quot;,error);</span><br><span class="line">        DKResponse *response &#x3D; [[DKResponse alloc] init]; &#x2F;&#x2F; 随便看看</span><br><span class="line">        response.error &#x3D; error;</span><br><span class="line">        if(callBack)&#123;</span><br><span class="line">            callBack(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>业务层接口设计<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(DKLogin.h)</span><br><span class="line">typedef void (^DKBlockSuccessOrError)(BOOL isSuccessful,NSError *error);</span><br><span class="line">&#x2F;&#x2F; 其他需求可以定制其他回调，如下</span><br><span class="line">typedef void (^DKArrayResultBlock)(NSArray *result,NSError *error);</span><br><span class="line">typedef void (^DKIntegerResultBlock)(NSInteger number, NSError *error) ;</span><br><span class="line">typedef void (^DKUserResultBlock)(DKUser *user, NSError *error); &#x2F;&#x2F; DKUser为模型</span><br><span class="line"></span><br><span class="line">+ (void)logout:(DKBlockSuccessOrError)callBack;</span><br></pre></td></tr></table></figure></li>
<li>业务层接口实现<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (void)logout:(DKBlockSuccessOrError)callBack</span><br><span class="line">&#123;</span><br><span class="line">    NSString *url &#x3D; @&quot;xxxx&quot;;</span><br><span class="line">    NSDictionary *params &#x3D; @&#123;@&quot;xxx&quot;:@&quot;xxx&quot;&#125;;</span><br><span class="line">    [DKHTTPTool POST:url parameters:params success:^(DKResponse *response) &#123;</span><br><span class="line">        if (callBack) &#123;</span><br><span class="line">          response.error ? callBack(NO,response.error) : callBack(YES,nil);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>ViewModel 或 ViewController 调用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[DKLoginService logout:^(BOOL isSuccess,NSError *error)&#123;</span><br><span class="line">    if(isSuccess)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层方法封装2</title>
    <url>/post/89e1dd7e.html</url>
    <content><![CDATA[<p>网络层方法封装2</p>
<span id="more"></span>
<ul>
<li>为了便于进行请求的管理，特地对之前的网络层方法封装加以改进，为了就是避免请求发送出去之后就管理不了的问题。</li>
<li>其中最为重要的就是请求的取消</li>
</ul>
<blockquote>
<p>当一个页面的请求正在天上飞的时候，用户等了好久不耐烦了，小手点了个back，然后ViewController被pop被回收。此时请求的着陆点就没了。这是很危险的情况，着陆点要是没了，就很容易crash的。-Casa</p>
</blockquote>
<ul>
<li><p>另外还添加了请求头，有需求的话就调用有添加请求头的方法</p>
</li>
<li><p>接下来说说改造</p>
<ol>
<li>添加单例方法，使用 sharedTool 管理请求</li>
<li>改原先的类方法为实例方法，并添加 NSInteger的返回值</li>
<li>添加取消请求和取消全部请求的方法</li>
<li>DKResponse 添加 taskIdentifier（NSInteger）属性</li>
</ol>
</li>
<li><p>声明部分</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** 请求头 *&#x2F;</span><br><span class="line">@property (nonatomic,strong)  NSDictionary *header;</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedTool;</span><br><span class="line"></span><br><span class="line">- (NSInteger)GET:(NSString *)URLString parameters:(id)parameters</span><br><span class="line">responseBlock:(DKHTTPResponseBlock)block;</span><br><span class="line"></span><br><span class="line">- (NSInteger)POST:(NSString *)URLString parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static DKHTTPTool *_tool;</span><br><span class="line"></span><br><span class="line">+ (id)allocWithZone:(struct _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _tool &#x3D; [super allocWithZone:zone];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _tool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedTool</span><br><span class="line">&#123;</span><br><span class="line">    if (_tool &#x3D;&#x3D; nil) &#123;</span><br><span class="line">        _tool &#x3D; [[DKHTTPTool alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return _tool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>GET请求添加请求头</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSInteger)GET:(NSString *)URLString header:(NSDictionary *)header parameters:(id)parameters responseBlock:(DKHTTPResponseBlock)block</span><br><span class="line">&#123;</span><br><span class="line">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];</span><br><span class="line">    AFHTTPRequestSerializer *requestSerializer &#x3D; mgr.requestSerializer;</span><br><span class="line">    [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        [requestSerializer setValue:obj forHTTPHeaderField:key];</span><br><span class="line">    &#125;];</span><br><span class="line">    requestSerializer.timeoutInterval &#x3D; kTimeOutInterval;</span><br><span class="line">    NSURLSessionTask *task &#x3D; [mgr GET:URLString parameters:parameters progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject];</span><br><span class="line">        resp.rawData &#x3D; responseObject;</span><br><span class="line">        resp.taskIdentifier &#x3D; task.taskIdentifier;</span><br><span class="line">        if(block)&#123;</span><br><span class="line">            block(resp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">        DKResponse *resp &#x3D; [[DKResponse alloc] init];</span><br><span class="line">        resp.error &#x3D; error;</span><br><span class="line">        if (block) &#123;</span><br><span class="line">            block(resp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    NSNumber *requestId &#x3D; @(task.taskIdentifier);</span><br><span class="line">    [self.dispatchTable setObject:task forKey:requestId];</span><br><span class="line">    return task.taskIdentifier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>取消请求</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)cancelRequestWithRequestIds:(NSArray *)requestIds</span><br><span class="line">&#123;</span><br><span class="line">    for (NSInteger i &#x3D; 0; i &lt; requestIds.count ; i++) &#123;</span><br><span class="line">        NSInteger requestId &#x3D; [requestIds[i] integerValue];</span><br><span class="line">        NSURLSessionTask *task &#x3D; [self.dispatchTable objectForKey:@(requestId)];</span><br><span class="line">        [task cancel];</span><br><span class="line">        [self.dispatchTable removeObjectForKey:@(requestId)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)cancelAllRequest</span><br><span class="line">&#123;</span><br><span class="line">    [self.dispatchTable enumerateKeysAndObjectsUsingBlock:^(NSNumber * _Nonnull key, NSURLSessionTask * _Nonnull obj, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        [obj cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其他方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma mark - seter &amp; getter</span><br><span class="line">- (NSMutableDictionary&lt;NSNumber *,NSURLSessionTask *&gt; *)dispatchTable</span><br><span class="line">&#123;</span><br><span class="line">    if (!_dispatchTable) &#123;</span><br><span class="line">        _dispatchTable &#x3D; [NSMutableDictionary dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    return _dispatchTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层方法封装3</title>
    <url>/post/fee6ede8.html</url>
    <content><![CDATA[<p>网络层方法封装3.1</p>
<span id="more"></span>

<p>** 其实很久之前就想写写这个东西,不过因为项目的原因一直没时间去整理出来,所以决定还是分开几天去写完这个东西吧</p>
<ul>
<li><p>新增特性:</p>
<ul>
<li>3.0<ul>
<li>多缓存策略</li>
<li>用宏定义减少代码量</li>
<li>使用 plist统一错误信息设置</li>
</ul>
</li>
<li>3.1<ul>
<li>输出一个漂亮的Log</li>
</ul>
</li>
</ul>
</li>
<li><p>先讲讲本地持久化策略的选择</p>
<ul>
<li><p>数据量小,单一的时候(比如一个模型数组,数组不大而且模型的成员属性不是很多),可以使用 <code>NSKeyArchive</code> 归档</p>
</li>
<li><p><code>NSUserDefault</code> 用于储存用户首选项</p>
</li>
<li><p><code>KeyChain</code>储存一些密码之类的东西</p>
</li>
<li><p>数据库储存数据量比较大,字段比较多的模型数组</p>
</li>
</ul>
</li>
<li><p>缓存策略</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger,DKCacheStrategy)&#123;</span><br><span class="line">    DKCacheStrategy_CACHE_ONLY, &#x2F;&#x2F; 只从本地取数据</span><br><span class="line">    DKCacheStrategy_NETWORK_ONLY, &#x2F;&#x2F; 只从网络取数据(不缓存)</span><br><span class="line">    DKCacheStrategy_NETWORK_AND_CACHE, &#x2F;&#x2F; 从网络取数据后缓存(缓存结束不回调)</span><br><span class="line">    DKCacheStrategy_CACHE_ELSE_NETWORK, &#x2F;&#x2F; 先取缓存,如果没有数据的话,才从网络取数据</span><br><span class="line">    DKCacheStrategy_CACHE_THEN_NETWORK &#x2F;&#x2F; 先取缓存,再加载网络数据,网络数据加载完会更新缓存,这个选择会有两次回调</span><br><span class="line">    DKCacheStrategy_AUTOMATIC &#x2F;&#x2F; 根据当前网络环境自动选择,如果有网络(WIFI&#x2F;WLAN)就取网络数据,没网络就取缓存数据</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Demo 说明<ul>
<li>github地址:没有</li>
<li>下载地址: NetworkDemo</li>
<li>选择本地持久化方式: <code>YYCache</code>,如果有更适合的缓存机制,那改一改也挺简单</li>
</ul>
</li>
<li>方法接口设计</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  发送HTTP请求</span><br><span class="line"> *</span><br><span class="line"> *  @param method 请求方法,你可以写@&quot;get&quot;或者@&quot;post&quot;(不区分大小写)或者已经定义好的 kGET 或 kPOST</span><br><span class="line"> *  @param strategy  缓存策略</span><br><span class="line"> *  @param header 请求头,可为空</span><br><span class="line"> *  @param params 请求参数,可为空</span><br><span class="line"> *  @param block  返回回调,这个就不要空啦</span><br><span class="line"> *</span><br><span class="line"> *  @return 请求标示 id 可以用来取消请求</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>

<p>之前两个方法继续保留,在这里就不说明了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)cancelAllRequest;</span><br><span class="line">- (void)cancelRequestWithRequestIds:(NSArray *)requestIds;</span><br></pre></td></tr></table></figure>

<p>然后写两个内部方法,分别是取缓存和取网络数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma mark - 仅本地</span><br><span class="line">- (NSInteger)requestWithCacheOnlyStrategyWithUrl:(NSString *)URLString params:(NSDictionary *)params requestBlock:(DKHTTPResponseBlock)block</span><br><span class="line">&#123;</span><br><span class="line">    DKResponse *response &#x3D; (DKResponse *)[self.cache objectForKey:[self cacheKeyForRequestUrl:URLString params:params]];</span><br><span class="line">    if (block) &#123;</span><br><span class="line">        if (response) &#123;</span><br><span class="line">            block(response);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            block(KERROR_RESPONSE(-1));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 仅网络</span><br><span class="line">- (NSInteger)requestWithNetworkOnlyStrategyForMethod:(NSString *)method url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block</span><br><span class="line">&#123;</span><br><span class="line">    NSNumber *taskIdentifier &#x3D; 0;</span><br><span class="line">    if ([method.uppercaseString isEqualToString:@&quot;GET&quot;]) &#123;</span><br><span class="line">        DKCALLAPI(GET, taskIdentifier);</span><br><span class="line">    &#125;else if([method.uppercaseString isEqualToString:@&quot;POST&quot;])&#123;</span><br><span class="line">        DKCALLAPI(POST, taskIdentifier);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return taskIdentifier.integerValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的宏DKCALLAPI 定义 主要是为了不想写 POST和 GET两个方法,在这里写一次就够了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define DKCALLAPI(REQUEST_METHOD,REQUEST_ID) \</span><br><span class="line">&#123;\</span><br><span class="line">    AFHTTPSessionManager *mgr &#x3D; [AFHTTPSessionManager manager];\</span><br><span class="line">    AFHTTPRequestSerializer *requestSerializer &#x3D; mgr.requestSerializer;\</span><br><span class="line">    if (header) &#123;\</span><br><span class="line">        [header enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id obj, BOOL * _Nonnull stop) &#123;\</span><br><span class="line">            [requestSerializer setValue:obj forHTTPHeaderField:key];\</span><br><span class="line">        &#125;];\</span><br><span class="line">    &#125;\</span><br><span class="line">    requestSerializer.timeoutInterval &#x3D; kTimeOutInterval;\</span><br><span class="line">    NSURLSessionTask *task &#x3D; [mgr REQUEST_METHOD:URLString parameters:params progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;\</span><br><span class="line">        DKResponse *resp &#x3D; [DKResponse mj_objectWithKeyValues:responseObject];\</span><br><span class="line">        resp.rawData &#x3D; responseObject;\</span><br><span class="line">        resp.taskIdentifier &#x3D; task.taskIdentifier;\</span><br><span class="line">        if(block)&#123;\</span><br><span class="line">            block(resp);\</span><br><span class="line">        &#125;\</span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;\</span><br><span class="line">        DKResponse *resp &#x3D; [DKResponse responseWithErrorOnly:error.description code:error.code];\</span><br><span class="line">        if (block) &#123;\</span><br><span class="line">            block(resp);\</span><br><span class="line">        &#125;\</span><br><span class="line">    &#125;];\</span><br><span class="line">    REQUEST_ID &#x3D; @(task.taskIdentifier);\</span><br><span class="line">    [self.dispatchTable setObject:task forKey:REQUEST_ID];\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 就可以实现我们的接口了 switch 里面的东西就就根据注释写吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params responseBlock:(DKHTTPResponseBlock)block</span><br><span class="line">&#123;</span><br><span class="line">    __weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">    NSInteger requestId;</span><br><span class="line">    switch (strategy) &#123;</span><br><span class="line">        case DKCacheStrategy_CACHE_ONLY:</span><br><span class="line">        &#x2F;&#x2F; 调用获取缓存方法</span><br><span class="line">            break;</span><br><span class="line">        case DKCacheStrategy_NETWORK_ONLY:</span><br><span class="line">        &#x2F;&#x2F; 调用获取网络方法</span><br><span class="line">            break;</span><br><span class="line">        case DKCacheStrategy_NETWORK_AND_CACHE:</span><br><span class="line">        &#x2F;&#x2F; 调用网络方法,回调后写入本地缓存</span><br><span class="line">            break;</span><br><span class="line">        case DKCacheStrategy_CACHE_ELSE_NETWORK:</span><br><span class="line">        &#x2F;&#x2F; 调用本地缓存方法,在回调中判断是否有缓存,如果没有的话调用网络方法</span><br><span class="line">            break;</span><br><span class="line">        case DKCacheStrategy_CACHE_THEN_NETWORK:</span><br><span class="line">        &#x2F;&#x2F; 调用本地方法接着调用网络方法 </span><br><span class="line">            break;</span><br><span class="line">        case DKCacheStrategy_AUTOMATICALLY:</span><br><span class="line">         &#x2F;&#x2F; 调用网络方法,回调中如果返回错误则调用本地缓存方法</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return requestId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>统一错误表处理<br>-建立一个plist 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">	&lt;key&gt;-2&lt;&#x2F;key&gt;</span><br><span class="line">	&lt;string&gt;网络连接失败&lt;&#x2F;string&gt;</span><br><span class="line">	&lt;key&gt;-1&lt;&#x2F;key&gt;</span><br><span class="line">	&lt;string&gt;没有缓存&lt;&#x2F;string&gt;</span><br><span class="line">&lt;&#x2F;dict&gt;</span><br><span class="line">&lt;&#x2F;plist&gt;</span><br></pre></td></tr></table></figure>

<p>一个成员属性加一个方法去调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSDictionary *)errorDic</span><br><span class="line">&#123;</span><br><span class="line">    if (!_errorDic) &#123;</span><br><span class="line">        NSString *path &#x3D; [[NSBundle mainBundle] pathForResource:@&quot;DKError&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">        _errorDic &#x3D; [NSDictionary dictionaryWithContentsOfFile:path];</span><br><span class="line">    &#125;</span><br><span class="line">    return _errorDic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)errorDescriptionWithCode:(NSInteger)code</span><br><span class="line">&#123;</span><br><span class="line">    NSString *codeStr &#x3D; [NSString stringWithFormat:@&quot;%zd&quot;,code];</span><br><span class="line">    if ([self.errorDic.allKeys containsObject:codeStr]) &#123;</span><br><span class="line">        return self.errorDic[codeStr];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;没有定义该类型错误&quot;);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包装成宏方便调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define KERROR_RESPONSE(errCode) [DKResponse responseWithErrorOnly:[self errorDescriptionWithCode:errCode] code:errCode]</span><br></pre></td></tr></table></figure>

<p>3.1 输出一个漂亮的 Log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  打印一个漂亮的 log</span><br><span class="line"> *</span><br><span class="line"> *  @param method              请求方法</span><br><span class="line"> *  @param url                 接口地址</span><br><span class="line"> *  @param params              参数</span><br><span class="line"> *  @param response            响应对象</span><br><span class="line"> *  @param showRequestContent  是否显示响应数据</span><br><span class="line"> *&#x2F;</span><br><span class="line">+ (void)logDebugInfoWithMethod:(NSString *)method URL:(NSString *)url params:(NSDictionary *)params response:(DKResponse *)response showRequestContent:(BOOL)showRequestContent;</span><br></pre></td></tr></table></figure>

<p>里面主要是字符串拼接.要看详细的话就去下载 Demo吧!</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层方法封装5</title>
    <url>/post/178548dd.html</url>
    <content><![CDATA[<p>网络层方法封装5.2.1</p>
<ul>
<li>特性<ul>
<li>添加链式调用方法</li>
</ul>
</li>
<li>5.1<ul>
<li>开启/关闭 Log</li>
<li>自定义 Logger</li>
<li>RAC支持</li>
</ul>
</li>
<li>5.2.1<ul>
<li>修复了一些 bug</li>
<li>由于服务器异常而返回的 NSData 转为 HTML 页面并展示出来（需要打开 DebugMode）</li>
<li>把链式调用方法抽出为一个 DKHTTPChainTool 类</li>
</ul>
</li>
</ul>
<span id="more"></span>
<ol>
<li>添加链式调用方法</li>
</ol>
<p>链式调用的好处就是要啥参数就添加啥,方便快捷,不用担心代码不够漂亮！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]</span><br><span class="line"></span><br><span class="line">&#x2F;** 链式调用 *&#x2F;</span><br><span class="line">- (DKHTTPChainTool * (^)(NSString *method))method;</span><br><span class="line">- (DKHTTPChainTool * (^)(NSString *url))url;</span><br><span class="line">- (DKHTTPChainTool * (^)(NSDictionary *header))header;</span><br><span class="line">- (DKHTTPChainTool * (^)(DKCacheStrategy strategy))cacheStrategy;</span><br><span class="line">- (DKHTTPChainTool * (^)(DKHTTPParamsVarifyBlock paramsVerify))verifyParams;</span><br><span class="line">- (DKHTTPChainTool * (^)(DKHTTPRequestFilterBlock resultFilter))requestFilter;</span><br><span class="line">- (DKHTTPChainTool * (^)(NSDictionary *params))params;</span><br><span class="line">&#x2F;** block返回请求Id *&#x2F;</span><br><span class="line">- (NSInteger (^)(DKHTTPResponseBlock responseBlock))execute;</span><br></pre></td></tr></table></figure>

<p>使用起来感觉是这样子的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class="line">           .url(@&quot;&quot;)</span><br><span class="line">           .params(@&#123;@&quot;account&quot;:@&quot;m13643046965@163.com&quot;,@&quot;password&quot;:@&quot;123456&quot;&#125;)</span><br><span class="line">           .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)</span><br><span class="line">           .verifyParams(^NSString *(NSDictionary *params)&#123;</span><br><span class="line">               return nil;</span><br><span class="line">           &#125;)</span><br><span class="line">           .requestFilter(^DKRequest *(DKRequest *request)&#123;</span><br><span class="line">               return request;</span><br><span class="line">           &#125;)</span><br><span class="line">           .execute(^(DKResponse *response)&#123;</span><br><span class="line">               NSLog(@&quot;%@&quot;,response.rawData);</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>5.1</li>
</ul>
<p>开启/关闭 Log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DKHTTPSharedTool.showLog &#x3D; YES&#x2F;NO;</span><br></pre></td></tr></table></figure>

<p>自定义 Logger</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define DKLog(...) NSLog(@&quot;%s %zd行 %@&quot;,__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])</span><br><span class="line"></span><br><span class="line">[DKHTTPTool setLogger:^(NSString *msg) &#123;</span><br><span class="line">  DKLog(@&quot;%@&quot;,msg);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>RAC支持</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (RACSignal *(^)())executeSignal;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSignal *signal &#x3D; DKHTTPChainInstance.method(@&quot;POST&quot;)</span><br><span class="line">                                        .url()</span><br><span class="line">                                        .header(@&#123;@&quot;token&quot;:@&quot;0e83179ac83741416e50b0ea12113f6e&quot;&#125;)</span><br><span class="line">                                        .params(@&#123;@&quot;account&quot;:@&quot;&quot;,@&quot;password&quot;:@&quot;123456&quot;&#125;)</span><br><span class="line">                                        .cacheStrategy(DKCacheStrategy_NETWORK_ONLY)</span><br><span class="line">                                        .verifyParams(^NSString *(NSDictionary *params)&#123;</span><br><span class="line">                                        return nil;</span><br><span class="line">                                        &#125;)</span><br><span class="line">                                      .requestFilter(^DKRequest *(DKRequest *request)&#123;</span><br><span class="line">                                        return request;</span><br><span class="line">                                        &#125;)</span><br><span class="line">                                      .executeSignal();</span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<ul>
<li>5.2.1</li>
</ul>
<p>1.DKHTTPTool的链式调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define DKHTTPChainInstance [[DKHTTPChainTool alloc] init]</span><br></pre></td></tr></table></figure>

<p>使用方法和上面说的一样</p>
<p>2.调试模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DKHTTPSharedTool.debugMode &#x3D; YES; &#x2F;&#x2F; 开启 Log 和 服务器异常弹窗</span><br><span class="line">如果服务器发生异常，那么就会发生如图情况</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/Arc-lin/BlogImage/blob/master/555.png?raw=true"><br><img src="https://github.com/Arc-lin/BlogImage/blob/master/666.png?raw=true"><br><img src="https://github.com/Arc-lin/BlogImage/blob/master/777.png?raw=true"></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层方法封装4</title>
    <url>/post/6082784b.html</url>
    <content><![CDATA[<p>网络层方法封装4</p>
<span id="more"></span>

<ul>
<li>新增特性:<ul>
<li>拦截器和验证器</li>
<li>封装请求对象</li>
</ul>
</li>
</ul>
<ol>
<li>说明</li>
</ol>
<p>  拦截器顾名思义就是在请求发送之前拦截请求，拦截到的请求可以进行修改之后进行发送，或者阻止请求的发送。可以用于添加分页参数之类的需求。</p>
<p>  验证器指的是验证参数（验证结果的方法后面再补充），验证参数主要用于判断输入参数的合法性，如果验证不通过则可以返回一个错误信息，由请求方法抛出错误，如果验证通过那就返回一个 nil就可以了。</p>
<ol start="2">
<li>代码</li>
</ol>
<p>  先说说请求对象模型</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface DKRequest : NSObject</span><br><span class="line"></span><br><span class="line">&#x2F;** 请求地址 *&#x2F;</span><br><span class="line">@property (nonatomic,copy) NSString * urlStr;</span><br><span class="line"></span><br><span class="line">&#x2F;** 请求方法 *&#x2F;</span><br><span class="line">@property (nonatomic,copy) NSString * method;</span><br><span class="line"></span><br><span class="line">&#x2F;** 请求参数 *&#x2F;</span><br><span class="line">@property (nonatomic,strong) NSDictionary *params;</span><br><span class="line"></span><br><span class="line">&#x2F;** 请求头 *&#x2F;</span><br><span class="line">@property (nonatomic,strong) NSDictionary *header;</span><br><span class="line"></span><br><span class="line">&#x2F;** 缓存策略 *&#x2F;</span><br><span class="line">@property (nonatomic,assign) DKCacheStrategy cacheStrategy;</span><br><span class="line"></span><br><span class="line">&#x2F;** 请求回调 *&#x2F;</span><br><span class="line">@property (nonatomic,copy) DKHTTPResponseBlock responseBlock;</span><br><span class="line"></span><br><span class="line">+ (instancetype)requestWithUrlStr:(NSString *)urlStr method:(NSString *)method header:(NSDictionary *)header params:(NSDictionary *)params strategy:(DKCacheStrategy)strategy;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>  完整的接口示例</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> 发送HTTP请求</span><br><span class="line"></span><br><span class="line"> @param method 请求方法,你可以写@&quot;get&quot;或者@&quot;post&quot;(不区分大小写)或者已经定义好的 kGET 或 kPOST</span><br><span class="line"> @param strategy 缓存策略</span><br><span class="line"> @param URLString 请求地址</span><br><span class="line"> @param header 请求头,可为空</span><br><span class="line"> @param params 请求参数,可为空</span><br><span class="line"> @param filterBlock  拦截器</span><br><span class="line"> @param verifyBlock 验证参数</span><br><span class="line"> @param block 回调</span><br><span class="line"> @return 请求 Id</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (NSInteger)requestForMethod:(NSString *)method cacheStragety:(DKCacheStrategy)strategy url:(NSString *)URLString header:(NSDictionary *)header params:(NSDictionary *)params filter:(DKHTTPRequestFilterBlock)filterBlock verifyParams:(DKHTTPParamsVarifyBlock)verifyBlock responseBlock:(DKHTTPResponseBlock)block;</span><br></pre></td></tr></table></figure>

<p>  拦截器的 block<br>  给你一个对象，你可以修改这个对象然后返回回去</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef DKRequest *(^DKHTTPRequestFilterBlock)(DKRequest *request);</span><br></pre></td></tr></table></figure>

<p>  验证器的 block<br>  给你参数，验证参数后你可以返回一个验证不通过的错误信息，也可以返回空表示验证通过</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NSString *(^DKHTTPParamsVarifyBlock)(NSDictionary *params);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>关于验证参数</p>
<p> 如果只是想单纯地验证参数是否是全部不为空(这里指空字符串，并不是nil,因为nil根本插不进字典)，那这里也提供了一个宏可以快速实现。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** 验证参数是否全部不为空 有空值的话会返回错误 *&#x2F;</span><br><span class="line">@property (nonatomic,copy) DKHTTPParamsVarifyBlock verifyIsAllNonNullBlock;</span><br></pre></td></tr></table></figure></li>
<li><p>关于过滤（验证）响应体<br>过滤响应体主要是为了防止错误的数据传回到 Service层，比如一些JSON 串解析后会传回 NSNull之类的恶心东西，如果误当做字符串操作的话会导致程序崩溃。不过因为 MJExtension 框架里面已经做了之类的处理，所以如果使用了MJExtension 框架的话，一般来说是不会出现问题，所以这个过滤方法作为单例的成员属性加入,设计为全局作用！<br>传给你一个 DKResponse, 你可以经过处理之后返回一个想要的 DKResponse</p>
</li>
</ol>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** 过滤响应体 *&#x2F;</span><br><span class="line">@property (nonatomic,copy) DKHTTPResultFilterBlock resultFilterBlock;</span><br></pre></td></tr></table></figure>

<p>今天逼哥放我假，所以我就写了这个.就这样子,demo我还是放在这里</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>解决git status中文问题</title>
    <url>/post/93da1b70.html</url>
    <content><![CDATA[<p>在中文情况下<code>git status</code>是 <code>\344\272\247\345\223\201\351\234\200\346\261\202</code> 差不多这样的。</p>
<p>解决这个问题方法是：</p>
<p><code>git config --global core.quotepath false</code></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一些关于iOS的一些小技巧</title>
    <url>/post/1b8f24c7.html</url>
    <content><![CDATA[<p>记录一些关于iOS的一些小技巧</p>
<span id="more"></span>

<p>XCode Profile 的路径<br>xcode5 provisioning profile path：<br><code>~/Library/MobileDevice/Provisioning Profiles</code></p>
<p>在升级XCode7.0使用UICollectionViewLayout进行自定义布局时，调试台会出现以下的警告打印。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UICollectionViewFlowLayout has cached frame mismatch for index path &#123;length &#x3D; 2, path &#x3D; 0 - 0&#125; - cached value: &#123;&#123;122, 15&#125;, &#123;170, 170&#125;&#125;; expected value: &#123;&#123;157, 50&#125;, &#123;100, 100&#125;&#125; </span><br><span class="line">This is likely occurring because the flow layout subclass LineLayout is modifying attributes returned by UICollectionViewFlowLayout without copying them</span><br></pre></td></tr></table></figure>

<p>这个警告来源主要是在使用layoutAttributesForElementsInRect：方法返回的数组时，没有使用该数组的拷贝对象，而是直接使用了该数组。解决办法对该数组进行拷贝，并且是深拷贝。拷贝代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSArray *)deepCopyWithArray:(NSArray *)array</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray *copys &#x3D; [NSMutableArray arrayWithCapacity:array.count];</span><br><span class="line"></span><br><span class="line">    for (UICollectionViewLayoutAttributes *attris in array) &#123;</span><br><span class="line">        [copys addObject:[attris copy]];</span><br><span class="line">    &#125;</span><br><span class="line">    return copys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将layoutAttributesForElementsInRect：方法返回的数组扔到这个方法中，并且使用返回后的数组就行了。</p>
<ul>
<li><p>在navigationController中插入ScrollView后，scrollView的ContentInset的值发生了变化</p>
<ul>
<li>解决： self.automaticallyAdjustsScrollViewInsets = NO;</li>
<li>原因： self.automaticallyAdjustsScrollViewInsets 默认值是YES，选择YES表示你允许视图控制器调整它内部插入的滑动视图来应对状态栏，导航栏，工具栏，和标签栏所消耗的屏幕区域。如果你设置为NO呢，就代表呀你要自己调整你插入的滑动视图，比如你的视图层次里面有多于一个的滑动视图。<br>这大概是个什么意思呢，就是你的视图控制器在没经你允许的情况下调整你的控件位置了</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Application Loader / Fastlane pilot 通过代理上传方案</title>
    <url>/post/undefined.html</url>
    <content><![CDATA[<h2 id="Application-Loader-Fastlane-pilot-通过代理上传方案"><a href="#Application-Loader-Fastlane-pilot-通过代理上传方案" class="headerlink" title="Application Loader / Fastlane pilot 通过代理上传方案"></a>Application Loader / Fastlane pilot 通过代理上传方案</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>为了避免苹果审核马甲包情况, 我们需要通过其他IP去上传包, 这里提供几种方案并记录踩坑过程.</p>
<span id="more"></span>

<h3 id="问题解决思路"><a href="#问题解决思路" class="headerlink" title="问题解决思路"></a>问题解决思路</h3><ol>
<li><p>用Application Loader(后面简称uploader)上传包, 电脑使用SS, VPN会导致上传失败, 原因是uploader内部自带开启代理配置, 但是默认是关闭的,  所以需要修改内部代理配置, 路径是<code>/Applications/Xcode.app/Contents/Applications/Application Loader.app/Contents/itms/java/lib/net.properties</code>, 配置如下(1086是本地ss的端口)</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.net.useSystemProxies&#x3D;true</span><br><span class="line">http.proxyHost&#x3D;127.0.0.1</span><br><span class="line">http.proxyPort&#x3D;1086</span><br><span class="line">https.proxyHost&#x3D;127.0.0.1</span><br><span class="line">https.proxyPort&#x3D;1086</span><br><span class="line">jdk.http.auth.tunneling.disabledSchemes&#x3D;Basic</span><br></pre></td></tr></table></figure>
</li>
<li><p>本来<code>net.properties</code>内是有socks代理的配置的, Shadowsocks开启socks代理后, 在配置文件中配置好ip(127.0.0.1)和端口(1086)之后测试发现无法连接到苹果服务器, 故只能选用<code>http/https</code>代理</p>
<blockquote>
<p>查询shadowsocks本地端口的方法, 执行<code>lsof -iTCP -sTCP:LISTEN -n -P | grep ss-local</code>, 就可以查到</p>
</blockquote>
</li>
<li><p>现在问题在于怎么将socks代理转成http/https代理, 通过查阅资料得知可以通过安装<code>privoxy</code>解决, 安装之后配置<code>/usr/local/etc/privoxy/config</code>文件, 把<code>forward-socks5t</code>那行注释掉, 加上本地socks ip和端口, 就像下面那段一样, 然后把<code>listen-address  127.0.0.1:8118</code> 改成 <code>listen-address  0.0.0.0:8118</code>就可以实现给局域网内共享你的代理.</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">forward           &#x2F;               127.0.0.1:1086 .</span><br><span class="line">forward-socks4    &#x2F;               127.0.0.1:1086 .</span><br><span class="line">forward-socks4a   &#x2F;               127.0.0.1:1086 .</span><br><span class="line">forward-socks5    &#x2F;               127.0.0.1:1086 .</span><br><span class="line">forward-socks5t   &#x2F;               127.0.0.1:1086 .</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开<code>系统偏好设置-网络-高级-代理</code>, 把网页代理和安全网页代理勾上, 填上ip <code>127.0.0.1</code> 端口 <code>8118</code> , 就可以了.  这里的<code>8118</code>是刚刚说到的<code>listen-address  0.0.0.0:8118</code>里面的端口号, 要改也可以改, 记得同步就行.</p>
</li>
</ol>
<h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><ol>
<li><p>校验<code>privoxy</code>是否代理成功可以通过浏览器访问<code>http://config.privoxy.org/</code>这个网址就能看到成功与否了</p>
</li>
<li><p>执行<code>netstat -an | grep 8118</code> 查看<code>8188</code>是否全局监听着, 如果是就会看到<br> <code>tcp4       0      0  *.8118                 *.*                    LISTEN  </code>执行<code>ps aux | grep privoxy</code>, 则可以看到<code>privoxy</code>进程是否正在运行中. 可以通过<code>sudo /Applications/Privoxy/stopPrivoxy.sh</code>停止<code>privoxy</code>和<code>sudo /Applications/Privoxy/startPrivoxy.sh</code>启动<code>privoxy</code></p>
</li>
<li><p>浏览器访问<code>https://ip.cn</code>,就可以得知网页代理是否成功了</p>
</li>
<li><p>fastlane上传包实际上是调用了<code>/Applications/Xcode.app/Contents/Applications/Application\ Loader.app/Contents/Frameworks/ITunesSoftwareService.framework/Versions/A/Support/altool</code>, 也就是Xcode自带的命令行工具 , uploader就不用说了, 反正殊途同归, 最后都会根据<code>net.properties</code>去走代理,  那么问题来了 , 如何验证命令行和桌面应用uploader走的都是代理方式呢. 很遗憾苹果并不会弄出一个界面或者打印出一行log告诉你现在是用哪个ip上传, 我现在能想到的办法是通过工具查看上传过程中的流量波动, 通过实验, 两种方式再上传过程中, <code>ss-local</code>进程有过较大数据上传的流量波动(会有100k/s以上的上传流量速度), 因此我判定确实是走了代理上传包的.  如果要再证据确凿的话, 只能想办法抓包查看他的信息收集了, 但是<code>Charles</code>抓包的原理是再开一个代理, 会造成混乱….所以这就很头疼了.</p>
</li>
<li><p>开启了网页代理之后, 影响的只是网页, 实际上只是为了验证<code>Privoxy</code>的可用性, 开启之后你如果在命令行中使用<code>curl ip.cn</code>得到的结果会是你真实网络的出网ip, 而不是你想要的代理的ip, 实际上<code>uploader</code>和<code>fastlane pilot</code>命令行是否真正走了代理, 目前我只能通过<code>ss-local</code>这个代理的进程查看他的上传流量去判断, 具有一定风险. 或者通过安装命令行工具<code>proxychains</code>, 然后执行<code>proxychains4 fastlane pilot upload</code>传包, 但是这种方式100%上传失败 , 原因猜想是<code>net.properties</code>的配置没改, <code>proxychains</code>怎么转发请求都没用.  所以这是不是从某种意义上证明了<code>fastlane pilot</code>是走<code>net.properties</code>配置的呢, 至少我觉得按照目前情况可以这么认为,  后续如果有想法我会进行更多实验去证明的.</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>项目里面的库和框架里面的库冲突问题</title>
    <url>/post/b072216a.html</url>
    <content><![CDATA[<p>项目里面有一个libFat.a 然后项目里面的KxMovie.framework 里面也有一个libFat.a，编译时会冲突<br>如果有用Cocopods,那么只要删掉-ObjC编译选项就可以</p>
<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/Arc-lin/BlogImage/master/111.png"></p>
<p><img src="https://raw.githubusercontent.com/Arc-lin/BlogImage/master/222.png"></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>
