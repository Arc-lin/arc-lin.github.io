<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.arclin.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"VOFC7668C9","apiKey":"24c644edc8e7353bf2e8d8e31f03a940","indexName":"hexo","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文主要简述类（元类）对象里面的方法缓存、消息发送（包括消息发送，动态方法解析与消息转发）与super关键字的底层原理">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS 底层原理 --- 方法、消息发送与super关键字">
<meta property="og:url" content="https://www.arclin.cn/post/5ed61a9.html">
<meta property="og:site_name" content="Arclin">
<meta property="og:description" content="本文主要简述类（元类）对象里面的方法缓存、消息发送（包括消息发送，动态方法解析与消息转发）与super关键字的底层原理">
<meta property="og:locale">
<meta property="og:image" content="https://p5-tt.byteimg.com/origin/pgc-image/47b512631098428e8bc60162e1df4ab7.png">
<meta property="og:image" content="https://p9-tt.byteimg.com/origin/pgc-image/70dfbbc7f61a4a9fac15e5ff1af809b4.png">
<meta property="article:published_time" content="2021-06-28T17:11:00.000Z">
<meta property="article:modified_time" content="2021-07-05T18:12:44.568Z">
<meta property="article:author" content="Arclin">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="底层原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p5-tt.byteimg.com/origin/pgc-image/47b512631098428e8bc60162e1df4ab7.png">

<link rel="canonical" href="https://www.arclin.cn/post/5ed61a9.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>iOS 底层原理 --- 方法、消息发送与super关键字 | Arclin</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Arclin" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Arclin</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Advocate Technology. Enjoy Technology.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://www.arclin.cn/post/5ed61a9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/12107804?v=4">
      <meta itemprop="name" content="Arclin">
      <meta itemprop="description" content="Stay hungry,stay foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arclin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          iOS 底层原理 --- 方法、消息发送与super关键字
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-29 01:11:00" itemprop="dateCreated datePublished" datetime="2021-06-29T01:11:00+08:00">2021-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文主要简述类（元类）对象里面的方法缓存、消息发送（包括消息发送，动态方法解析与消息转发）与super关键字的底层原理</p>
<span id="more"></span>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Class对象的结构"><a href="#Class对象的结构" class="headerlink" title="Class对象的结构"></a>Class对象的结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache; &#x2F;&#x2F; 方法缓存</span><br><span class="line">    class_data_bits_t bits; &#x2F;&#x2F; 用于获取具体的类信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>bits</code>成员变量与<code>FAST_DATA_MASK</code>进行一次与运算之后，会获得一个其属性可读可写的对象的地址，这个对象长这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line">    const clsss_ro_t *ro;</span><br><span class="line">    method_array_t * methods; &#x2F;&#x2F; 方法列表</span><br><span class="line">    property_array_t *properties; &#x2F;&#x2F; 属性列表</span><br><span class="line">    protocol_array_t protocols; &#x2F;&#x2F; 协议列表</span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line">    char *demangledName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>class_ro_t</code>里面存放的是类的原始信息(不包括分类里面的东西)，是仅可读的，结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    unit32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize; &#x2F;&#x2F; instance对象占用的内存空间</span><br><span class="line">#ifdef __LP__64__</span><br><span class="line">    uint32_t reserved;</span><br><span class="line">#endif</span><br><span class="line">    const uint8_t *ivarLayout;</span><br><span class="line">    const char * name; &#x2F;&#x2F; 类名</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    const ivar_list_t * ivars; &#x2F;&#x2F; 成员变量列表</span><br><span class="line">    const uint8_t * weakIverLayout;</span><br><span class="line">    property_list_t * baseProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h3><p><code>class_rw_t</code>里面的methods、properties、protocols是二维数组，是可读可写的，比如方法列表随时可以新增<code>method_list_t</code>类型的数据进去。<code>class_rw_t</code>包含了类的初始内容和分类的内容，其中方法列表类似如下结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">method_array_t: [</span><br><span class="line">    method_list_t : [</span><br><span class="line">      method_t,</span><br><span class="line">      method_t,</span><br><span class="line">      method_t</span><br><span class="line">    ],</span><br><span class="line">    method_list_t : [</span><br><span class="line">      method_t,</span><br><span class="line">      method_t,</span><br><span class="line">      method_t</span><br><span class="line">    ],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>objc_class</code>内有一个<code>data()</code>函数，其返回值一开始是指向<code>class_ro_t</code>类型的对象的。在合并分类内的内容时，才会产生<code>class_rw_t</code>类型的对象，并指向这个对象。可以参考runtime源码，<code>objc-runtime-new.mm</code>中<code>realizeClassWithoutSwift</code>函数的实现，这里贴出关键部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static Class realizeClassWithoutSwift(Class cls, Class previously)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    auto ro &#x3D; (const class_ro_t *)cls-&gt;data();</span><br><span class="line">    auto isMeta &#x3D; ro-&gt;flags &amp; RO_META;</span><br><span class="line">    if (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        &#x2F;&#x2F; This was a future class. rw data is already allocated.</span><br><span class="line">        rw &#x3D; cls-&gt;data();</span><br><span class="line">        ro &#x3D; cls-&gt;data()-&gt;ro();</span><br><span class="line">        ASSERT(!isMeta);</span><br><span class="line">        cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Normal class. Allocate writeable class data.</span><br><span class="line">        rw &#x3D; objc::zalloc&lt;class_rw_t&gt;();</span><br><span class="line">        rw-&gt;set_ro(ro);</span><br><span class="line">        rw-&gt;flags &#x3D; RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">        cls-&gt;setData(rw);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h3><p><code>class_ro_t</code>里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，所以不能新增内容，包含了类的初始内容，其中方法列表类似如下结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">method_list_t : [</span><br><span class="line">  method_t,</span><br><span class="line">  method_t,</span><br><span class="line">  method_t</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在runtime源码，<code>objc-runtime-new.mm</code>中的<code>attachCategories</code>方法中我们可以看到分类合并到<code>class_rw_t</code>对象的过程，比如方法的合并如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">method_list_t *mlist &#x3D; entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">if (mlist) &#123;</span><br><span class="line">    if (mcount &#x3D;&#x3D; 64) &#123;</span><br><span class="line">        prepareMethodLists(cls, mlists, mcount, NO, fromBundle, __func__);</span><br><span class="line">        rwe-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">        mcount &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    mlists[ATTACH_BUFSIZ - ++mcount] &#x3D; mlist;</span><br><span class="line">    fromBundle |&#x3D; entry.hi-&gt;isBundle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><ul>
<li><code>method_t</code>是对方法/函数的封装（下面是缩减版定义）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    ...</span><br><span class="line">    SEL name(); &#x2F;&#x2F; 函数名</span><br><span class="line">    const char *types(); &#x2F;&#x2F; 编码（返回值类型、参数类型）</span><br><span class="line">    IMP imp(bool needsLock); &#x2F;&#x2F; 指向函数的指针（函数地址）</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>IMP</code>代表具体函数的实现</p>
<p>  <code>typedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</code></p>
</li>
<li><p><code>SEL</code>可以代表方法\函数名，一般叫做选择器，底层结构跟<code>char *</code>类似</p>
<p>  <code>typedef struct objc_selector *SEL</code>;</p>
<ul>
<li>可以通过<code>@selector()</code>和<code>sel_registerName()</code>获得</li>
<li>可以通过<code>sel_getName()</code>和<code>NSStringFromSelector()</code>转成字符串</li>
<li>不同类中相同名字的方法，所对应的方法选择器是相同的</li>
</ul>
</li>
<li><p><code>types</code>包含了函数返回值、参数编码的字符串，称作<code>Type Encodings</code>（类型编码），具体可以参考<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100">苹果官方文档</a></p>
<ul>
<li>比如<code>-（void）test:(int)a;</code>的方法编码为<code>v@:i</code>，v = void,@表示指针变量(因为编译后第一个参数是self)，：表示选择器(因为编译后第二个参数是_cmd)，</li>
<li>有时类型编码会带上数字，比如<code>v16@0:8</code>，第一个数字表示这个函数的参数一共占用16个字节，第二个数字开始往后的数字都代表偏移值，0代表第一个参数的字节偏移值为0，第三个数字8代表偏移8个字节，也就是第一个参数已经占用了8个字节了，所以第二个参数就从第8个字节开始</li>
</ul>
</li>
</ul>
<h3 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a>cache_t</h3><ul>
<li>Class内部结构中有个方法缓存（cache_t），用散列表来缓存曾经调用过的方法，可以提高方法的查找速度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct cache_t &#123;</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _bucketsAndMaybeMask;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct &#123;</span><br><span class="line">            explicit_atomic&lt;mask_t&gt;    _maybeMask; &#x2F;&#x2F; 散列表的长度 - 1</span><br><span class="line">            uint16_t                   _flags;</span><br><span class="line">            uint16_t                   _occupied; &#x2F;&#x2F; 已经缓存的方法数量</span><br><span class="line">        &#125;;</span><br><span class="line">        explicit_atomic&lt;preopt_cache_t *&gt; _originalPreoptCache;</span><br><span class="line">    &#125;;   </span><br><span class="line">    struct bucket_t *buckets() const;</span><br><span class="line">    mask_t mask() const;</span><br><span class="line">    mask_t occupied() const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，通过<code>buckets()</code>函数我们可以得知<code>_bucketsAndMaybeMask</code>是一个存放<code>bucket_t</code>数组的指针（即<code>_bucketsAndMaybeMask</code>指针指向的是数组的第一个元素），是通过位运算取出来的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct bucket_t *cache_t::buckets() const</span><br><span class="line">&#123;</span><br><span class="line">    uintptr_t addr &#x3D; _bucketsAndMaybeMask.load(memory_order_relaxed);</span><br><span class="line">    return (bucket_t *)(addr &amp; bucketsMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>bucket_t</code>的结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct bucket_t &#123;</span><br><span class="line">    explicit_atomic&lt;uintptr_t&gt; _imp; 	&#x2F;&#x2F; 函数的内存地址</span><br><span class="line">    explicit_atomic&lt;SEL&gt; _sel; &#x2F;&#x2F; SEL作为key</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过IMP和SEL，我们就可以调用方法了，所以综上所述，一个实例对象调用方法，其类对象从方法缓存里面找方法的大概流程就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获取sel : class - isa - 偏移16个字节 - cache_t - buckets() - [bucket_t] - 计算出下标index - bucket_t - sel()</span><br><span class="line">获取imp : class - isa - 偏移16个字节 - cache_t - buckets() - [bucket_t] - 计算出下标index - bucket_t - imp(nil,cls)</span><br></pre></td></tr></table></figure>

<p>另外<code>_bucketsAndMaybeMask</code>之所以叫这个名字是因为它不仅存放着<code>buckets</code>还存放着<code>maybeMask</code>，在arm64位真机环境下，取高16位，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mask_t cache_t::mask() const</span><br><span class="line">&#123;</span><br><span class="line">    uintptr_t maskAndBuckets &#x3D; _bucketsAndMaybeMask.load(memory_order_relaxed);</span><br><span class="line">    &#x2F;&#x2F;maskShift 为48,</span><br><span class="line">    return maskAndBuckets &gt;&gt; maskShift;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法缓存的流程"><a href="#方法缓存的流程" class="headerlink" title="方法缓存的流程"></a>方法缓存的流程</h4><p>先看看runtime源码中，将方法插入缓存的函数（摘抄核心流程）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">void cache_t::insert(SEL sel, IMP imp, id receiver)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;对_occupied赋值 + 1。首次 newOccupied &#x3D; 1。</span><br><span class="line">    mask_t newOccupied &#x3D; occupied() + 1;</span><br><span class="line">    &#x2F;&#x2F;旧容量，（mask + 1） 或者 0</span><br><span class="line">    unsigned oldCapacity &#x3D; capacity(), capacity &#x3D; oldCapacity;</span><br><span class="line">    &#x2F;&#x2F;是否为空，首次进入这里</span><br><span class="line">    if (slowpath(isConstantEmptyCache())) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is read-only. Replace it.</span><br><span class="line">        &#x2F;&#x2F;默认容量给4</span><br><span class="line">        if (!capacity) capacity &#x3D; INIT_CACHE_SIZE;&#x2F;&#x2F;1 &lt;&lt; 2 &#x3D; 4</span><br><span class="line">        &#x2F;&#x2F;0 4 false 开辟新的容器空间。由于旧容器为空这里不需要释放传false。</span><br><span class="line">        reallocate(oldCapacity, capacity, &#x2F;* freeOld *&#x2F;false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;newOccupied + 1 (相当于 _occupied + 2) &lt;&#x3D; capacity * 3 &#x2F; 4 容量够的时候什么都不做，直接插入。&lt;&#x3D;75%的容积正常插入，否则扩容。</span><br><span class="line">    &#x2F;&#x2F;## ⚠️在arm64位的情况下，CACHE_END_MARKER 0 扩容条件为：7 &#x2F; 8 87.5% 这个时候CACHE_ALLOW_FULL_UTILIZATION 为 1</span><br><span class="line">    else if (fastpath(newOccupied + CACHE_END_MARKER &lt;&#x3D; cache_fill_ratio(capacity))) &#123;</span><br><span class="line">        &#x2F;&#x2F; Cache is less than 3&#x2F;4 or 7&#x2F;8 full. Use it as-is.</span><br><span class="line">    &#125;</span><br><span class="line">#if CACHE_ALLOW_FULL_UTILIZATION</span><br><span class="line">    &#x2F;&#x2F;capacity &lt;&#x3D; 1&lt;&lt;3 (8), _occupied + 1（CACHE_END_MARKER为0） &lt;&#x3D; 容量。少于8个元素的时候允许100%占满。</span><br><span class="line">    else if (capacity &lt;&#x3D; FULL_UTILIZATION_CACHE_SIZE &amp;&amp; newOccupied + CACHE_END_MARKER &lt;&#x3D; capacity) &#123;</span><br><span class="line">        &#x2F;&#x2F; Allow 100% cache utilization for small buckets. Use it as-is.</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;&#x2F;扩容</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F;容量不为空返回 2倍的容量，否则返回4</span><br><span class="line">        capacity &#x3D; capacity ? capacity * 2 : INIT_CACHE_SIZE;</span><br><span class="line">        &#x2F;&#x2F;MAX_CACHE_SIZE 1&lt;&lt;16 &#x3D; 2^16。最大缓存65536</span><br><span class="line">        if (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">            capacity &#x3D; MAX_CACHE_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;开辟新的容器控件，释放旧的空间。</span><br><span class="line">        reallocate(oldCapacity, capacity, true);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;从_bucketsAndMaybeMask获取buckets</span><br><span class="line">    bucket_t *b &#x3D; buckets();</span><br><span class="line">    mask_t m &#x3D; capacity - 1;&#x2F;&#x2F;首次是4-1</span><br><span class="line">    &#x2F;&#x2F;计算插入的index</span><br><span class="line">    mask_t begin &#x3D; cache_hash(sel, m);</span><br><span class="line">    mask_t i &#x3D; begin;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Scan for the first unused slot and insert there.</span><br><span class="line">    &#x2F;&#x2F; There is guaranteed to be an empty slot.</span><br><span class="line">    &#x2F;&#x2F;循环判断插入数据。</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F;能走到这里大概率是cache不存在，所以这里走fastpath</span><br><span class="line">        if (fastpath(b[i].sel() &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">            &#x2F;&#x2F;Occupied + 1</span><br><span class="line">            incrementOccupied();</span><br><span class="line">            &#x2F;&#x2F;buckets中插入bucket</span><br><span class="line">            b[i].set&lt;Atomic, Encoded&gt;(b, sel, imp, cls());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;已经存在了，不进行任何处理。有可能是其它线程插入的。</span><br><span class="line">        if (b[i].sel() &#x3D;&#x3D; sel) &#123;</span><br><span class="line">            &#x2F;&#x2F; The entry was added to the cache by some other thread</span><br><span class="line">            &#x2F;&#x2F; before we grabbed the cacheUpdateLock.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;cache_next为了防止hash冲突。再hash了一次（下文会讲到）。</span><br><span class="line">    &#125; while (fastpath((i &#x3D; cache_next(i, m)) !&#x3D; begin));</span><br><span class="line">    &#x2F;&#x2F;异常处理</span><br><span class="line">    bad_cache(receiver, (SEL)sel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首次进入isConstantEmptyCache分支。会创建一个容量为4的空buckets。这个时候由于旧buckets不存在不需要释放所以参数传递false。</li>
<li>当容量大于等于3/4或7/8的情况下扩容。arm64的条件下为7 / 8。</li>
<li>arm64条件下容量小于等于8的时候会占用100%才扩容。</li>
<li>扩容是直接翻倍，默认值4。最大值MAX_CACHE_SIZE为216(65536)。在扩容的时候直接释放了旧值。</li>
<li>mask值为capacity - 1</li>
<li>通过cache_hash（下文会提及的散列表算法）计算插入的index，后面会通过cache_next再进行计算hash解决冲突问题。</li>
<li>循环判断通过b[i].set插入bucket数据。</li>
<li><strong>reallocate函数在开辟控件的同时，把缓存给直接清空了</strong>，清空之后再把现在要缓存的方法放进去，所以扩容后occupied会为1。</li>
</ul>
<h4 id="散列表（哈希表）缓存"><a href="#散列表（哈希表）缓存" class="headerlink" title="散列表（哈希表）缓存"></a>散列表（哈希表）缓存</h4><ul>
<li><p>方法缓存的容器，不是简单的数组，而是用散列表的方式进行存储。</p>
<p>假如现在散列表长度为10，那么mask（即cache_t里面的_maybeMask）就是10-1 = 9，当selector传进来的时候，会跟mask进行一次与运算，如下：</p>
<p><code>@selector(personTest) &amp; mask = 4</code></p>
<p>假如得到的结果是4的话，那么就会插在列表的下标为4的位置，其他位置因为已经开辟好空间了，所以有值就放值，没值就NULL</p>
<p>这种列表的好处是，当想取到特定的bucket_t的时候，只需要把selector跟mask进行一次与运算，就可以直接得到下标，然后直接从列表取出，这样子就不用遍历查找了，大大节约了性能。</p>
<p>另外，由于与运算的特性，跟mask进行与运算之后的值，都不可能比mask更大，这样子就保证不会插入越界的位置。</p>
</li>
<li><p>如果通过计算后的下标值，插入列表的时候发现已经有东西了那怎么办？</p>
<p>  这也就是所谓的Hash冲突。为了处理这种问题，系统会调用<code>cache_next</code>函数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static inline mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    return i ? i-1 : mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  也就是说如果<code>@selector(personTest) &amp; mask = 4</code>的4已经有东西了，那么就取 4 - 1 = 3，如果3还有东西，就放在2的位置，如果2还有，就放在1，以此类推，如果直到0都还没有可以插入的位置，那么就从mask的位置开始找，也就是9，然后再找9看看是否可以插入，插不进去再找8，以此类推，找到为止。</p>
<p>  由于列表在存放数量达到容量的87.5%的时候就会两倍的扩容（arm64），扩容后又会清空缓存，所以一定能找到合适的位置插入的。</p>
</li>
</ul>
<h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><p>调用一个不存在的方法的时候，他会经历这么一个流程</p>
<p>消息发送 - （找不到方法的话） -&gt; 动态方法解析 - （没有实现的话） -&gt; 消息转发 -&gt; （没有实现的话） -&gt; 抛出异常</p>
<h3 id="消息发送-1"><a href="#消息发送-1" class="headerlink" title="消息发送"></a>消息发送</h3><p>假如我们这么调用一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[person personTest];</span><br></pre></td></tr></table></figure>

<p>底层会转换为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(person,sel_registerName(&quot;personTest&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的person我们称作消息接受者（receiver），就是调用方法的对象，如果这里还是调用类方法的话，那么这里就会传入一个类对象</li>
<li><code>sel_registerName()</code>函数等价于<code>@selector</code></li>
<li>为了性能，<code>objc_msgSend</code>方法底层是使用汇编和C++实现的</li>
</ul>
<p>消息发送的流程如下：</p>
<ol>
<li>receiver 是否为空，如果是退出，否则继续</li>
<li>从receiver的类对象（如果传入的是类则找的是元类对象，下文统称为receiverClass）的cache中查找方法，如果找到则调用方法，如果找不到则继续</li>
<li>从receiverClass中的<code>class_rw_t</code>中查找方法，如果找到则调用方法，并将方法插入缓存，如果找不到则继续</li>
<li>从<code>superClass</code>的cache中查找方法，有则调用并缓存到当前receiverClass的cache中(不是superClass的cache),否则继续</li>
<li>从<code>superClass</code>的<code>class_rw_t</code>中找，有则调用并缓存到receiverClass的cache中，否则继续</li>
<li>继续通过<code>superClass</code>的<code>superClass</code>找方法，流程回到4，直到再也没有父类了，并且也找不到方法，那么将会进入动态方法解析阶段。</li>
</ol>
<p>其中：</p>
<ul>
<li>如果是从<code>class_rw_t</code>中查找方法，若方法列表已经排序好，那么就使用二分查找法查找</li>
<li>如果是还没排序的方法，那么就使用遍历的方法查找</li>
<li>在缓存中查找方法的过程也称作快速查找（使用汇编实现），在<code>class_rw_t</code>中查找方法的过程也称作慢速查找(使用汇编和C++实现)，C++部分方法源码在<code>lookUpImpOrForward</code>函数中，如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrForward(id inst, SEL sel, Class cls, int behavior)</span><br><span class="line">&#123;</span><br><span class="line">    const IMP forward_imp &#x3D; (IMP)_objc_msgForward_impcache;</span><br><span class="line">    IMP imp &#x3D; nil;</span><br><span class="line">    Class curClass;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    &#x2F;&#x2F; Optimistic cache lookup</span><br><span class="line">    if (fastpath(behavior &amp; LOOKUP_CACHE)) &#123;</span><br><span class="line">        imp &#x3D; cache_getImp(cls, sel);</span><br><span class="line">        if (imp) goto done_nolock;</span><br><span class="line">    &#125;</span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    checkIsKnownClass(cls);</span><br><span class="line">    if (slowpath(!cls-&gt;isRealized())) &#123;</span><br><span class="line">        cls &#x3D; realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line">    if (slowpath((behavior &amp; LOOKUP_INITIALIZE) &amp;&amp; !cls-&gt;isInitialized())) &#123;</span><br><span class="line">        cls &#x3D; initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">    &#125;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    curClass &#x3D; cls;</span><br><span class="line">    for (unsigned attempts &#x3D; unreasonableClassCount();;) &#123;</span><br><span class="line">        &#x2F;&#x2F; curClass method list.</span><br><span class="line">        Method meth &#x3D; getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        if (meth) &#123;</span><br><span class="line">            imp &#x3D; meth-&gt;imp;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">        if (slowpath((curClass &#x3D; curClass-&gt;superclass) &#x3D;&#x3D; nil)) &#123;</span><br><span class="line">            imp &#x3D; forward_imp;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (slowpath(--attempts &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">            _objc_fatal(&quot;Memory corruption in class list.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Superclass cache.</span><br><span class="line">        imp &#x3D; cache_getImp(curClass, sel);</span><br><span class="line">        if (slowpath(imp &#x3D;&#x3D; forward_imp)) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (fastpath(imp)) &#123;</span><br><span class="line">            &#x2F;&#x2F; Found the method in a superclass. Cache it in this class.</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">        behavior ^&#x3D; LOOKUP_RESOLVER;</span><br><span class="line">        return resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">    &#125;</span><br><span class="line"> done:</span><br><span class="line">    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"> done_nolock:</span><br><span class="line">    if (slowpath((behavior &amp; LOOKUP_NIL) &amp;&amp; imp &#x3D;&#x3D; forward_imp)) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>慢速查找流程图：</p>
<img src="https://p5-tt.byteimg.com/origin/pgc-image/47b512631098428e8bc60162e1df4ab7.png" >

<p>消息发送流程图：</p>
<img src="https://p9-tt.byteimg.com/origin/pgc-image/70dfbbc7f61a4a9fac15e5ff1af809b4.png">



<h3 id="动态方法解析（也称：动态方法决议）"><a href="#动态方法解析（也称：动态方法决议）" class="headerlink" title="动态方法解析（也称：动态方法决议）"></a>动态方法解析（也称：动态方法决议）</h3><p>当消息发送流程找不到方法后就会进入动态方法解析流程。</p>
<p>动态方法解析是当消息发送阶段找不到方法的时候，开发者可以通过重写特定方法（如果是类方法就重写<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>，如果是对象方法就重写<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>），给原先不存在的方法添加方法实现。主要是用到runtime里面的<code>class_addMethod</code>函数，并且动态解析后，会重新走”消息发送“的流程</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>假如这里的person没有实现print方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *person &#x3D; [Person new];</span><br><span class="line">[person print];</span><br></pre></td></tr></table></figure>

<p>那我们可以在<code>Person.m</code>添加一个方法实现用来替换丢失的<code>print</code>，这里我们用<code>truePrint</code>来替代</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)truePrint &#123;</span><br><span class="line">    NSLog(@&quot;true print&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel &#x3D;&#x3D; @selector(print)) &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获取truePrint方法的Method对象</span><br><span class="line">        Method truePrint &#x3D; class_getInstanceMethod(self, @selector(truePrint));</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 动态添加print方法的实现，通过method_getImplementation获取到方法的函数指针，通过method_getTypeEncoding拿到方法的函数编码即 v@: 或 v16@0:8</span><br><span class="line">        class_addMethod(self, sel, method_getImplementation(truePrint), method_getTypeEncoding(truePrint));</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 返回YES代表有动态添加方法</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Method的结构"><a href="#Method的结构" class="headerlink" title="Method的结构"></a>Method的结构</h4><p>点击Method我们可以看到结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method;</span><br></pre></td></tr></table></figure>

<p>而<code>ojbc_method</code>的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name;	</span><br><span class="line">    char * _Nullable method_types;</span><br><span class="line">    IMP _Nonnull method_imp;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>可以看到跟上面所说的<code>method_t</code>是类似的东西</p>
<p>以下是一些拿到<code>Method</code>对象后可以使用的一些函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数调用，但是不接收返回值类型为结构体</span><br><span class="line">method_invoke</span><br><span class="line">&#x2F;&#x2F; 函数调用，但是接收返回值类型为结构体</span><br><span class="line">method_invoke_stret</span><br><span class="line">&#x2F;&#x2F; 获取函数名</span><br><span class="line">method_getName</span><br><span class="line">&#x2F;&#x2F; 获取函数实现IMP</span><br><span class="line">method_getImplementation</span><br><span class="line">&#x2F;&#x2F; 获取函数type encoding</span><br><span class="line">method_getTypeEncoding</span><br><span class="line">&#x2F;&#x2F; 复制返回值类型</span><br><span class="line">method_copyReturnType</span><br><span class="line">&#x2F;&#x2F; 复制参数类型</span><br><span class="line">method_copyArgumentType</span><br><span class="line">&#x2F;&#x2F; 获取返回值类型</span><br><span class="line">method_getReturnType</span><br><span class="line">&#x2F;&#x2F; 获取参数个数</span><br><span class="line">method_getNumberOfArguments</span><br><span class="line">&#x2F;&#x2F; 获取函数参数类型</span><br><span class="line">method_getArgumentType</span><br><span class="line">&#x2F;&#x2F; 获取函数描述</span><br><span class="line">method_getDescription</span><br><span class="line">&#x2F;&#x2F; 设置函数实现IMP</span><br><span class="line">method_setImplementation</span><br><span class="line">&#x2F;&#x2F; 交换函数的实现IMP</span><br><span class="line">method_exchangeImplementations</span><br></pre></td></tr></table></figure>


<h4 id="Runtime中的原理"><a href="#Runtime中的原理" class="headerlink" title="Runtime中的原理"></a>Runtime中的原理</h4><p>在上面的消息发送的流程函数<code>lookUpImpOrForward</code>中，有一段代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (slowpath(behavior &amp; LOOKUP_RESOLVER)) &#123;</span><br><span class="line">    behavior ^&#x3D; LOOKUP_RESOLVER;</span><br><span class="line">    return resolveMethod_locked(inst, sel, cls, behavior);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当找不到消息的时候就会进入动态方法解析的流程即<code>resolveMethod_locked</code>，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static NEVER_INLINE IMP resolveMethod_locked(id inst, SEL sel, Class cls, int behavior) &#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line"></span><br><span class="line">    if (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        &#x2F;&#x2F; try [cls resolveInstanceMethod:sel]</span><br><span class="line">        resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; try [nonMetaClass resolveClassMethod:sel]</span><br><span class="line">        &#x2F;&#x2F; and [cls resolveInstanceMethod:sel]</span><br><span class="line">        resolveClassMethod(inst, sel, cls);</span><br><span class="line">        if (!lookUpImpOrNilTryCache(inst, sel, cls)) &#123;</span><br><span class="line">            resolveInstanceMethod(inst, sel, cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return lookUpImpOrForwardTryCache(inst, sel, cls, behavior);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"># iOS</a>
              <a href="/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" rel="tag"># 底层原理</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/post/78ececc4.html" rel="prev" title="iOS 底层原理 --- isa指针">
      <i class="fa fa-chevron-left"></i> iOS 底层原理 --- isa指针
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.</span> <span class="nav-text">Class对象的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class-rw-t"><span class="nav-number">1.2.</span> <span class="nav-text">class_rw_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class-ro-t"><span class="nav-number">1.3.</span> <span class="nav-text">class_ro_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#method-t"><span class="nav-number">1.4.</span> <span class="nav-text">method_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache-t"><span class="nav-number">1.5.</span> <span class="nav-text">cache_t</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%BC%93%E5%AD%98%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">1.5.1.</span> <span class="nav-text">方法缓存的流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89%E7%BC%93%E5%AD%98"><span class="nav-number">1.5.2.</span> <span class="nav-text">散列表（哈希表）缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81"><span class="nav-number">2.</span> <span class="nav-text">消息发送</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81-1"><span class="nav-number">2.1.</span> <span class="nav-text">消息发送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B9%9F%E7%A7%B0%EF%BC%9A%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E5%86%B3%E8%AE%AE%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">动态方法解析（也称：动态方法决议）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Method%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.2.</span> <span class="nav-text">Method的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Runtime%E4%B8%AD%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.3.</span> <span class="nav-text">Runtime中的原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91"><span class="nav-number">2.3.</span> <span class="nav-text">消息转发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super"><span class="nav-number">3.</span> <span class="nav-text">super</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Arclin"
      src="https://avatars.githubusercontent.com/u/12107804?v=4">
  <p class="site-author-name" itemprop="name">Arclin</p>
  <div class="site-description" itemprop="description">Stay hungry,stay foolish</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">86</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Arc-lin" title="GitHub → https://github.com/Arc-lin" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:arclin325@gmail.com" title="E-Mail → mailto:arclin325@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Arclin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'df6d1f33bb4a66f5fa60',
      clientSecret: '5fcc9fb756ac9d4b16381288da7b29f691b45e0a',
      repo        : 'arc-lin.github.io',
      owner       : 'Arc-lin',
      admin       : ['Arc-lin'],
      id          : '1cc7c2dc04e24e2db79eb1c8985f9f83',
        language: 'zh-CN',
      distractionFreeMode: false
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
